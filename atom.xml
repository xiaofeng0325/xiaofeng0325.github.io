<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>Knowledge is power.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-22T03:31:29.335Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter入门指南(九)之弹窗和提示(SnackBar、BottomSheet、Dialog)</title>
    <link href="http://yoursite.com/posts/5da6faeb.html"/>
    <id>http://yoursite.com/posts/5da6faeb.html</id>
    <published>2019-05-22T03:30:42.000Z</published>
    <updated>2019-05-22T03:31:29.335Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(八)之Sliver组件及NestedScrollView</title>
    <link href="http://yoursite.com/posts/f600e8a7.html"/>
    <id>http://yoursite.com/posts/f600e8a7.html</id>
    <published>2019-05-22T02:57:48.000Z</published>
    <updated>2019-05-22T03:17:46.252Z</updated>
    
    <content type="html"><![CDATA[<p>上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去</p><p>在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。</p><h3 id="SliverAppBar"><a href="#SliverAppBar" class="headerlink" title="SliverAppBar"></a>SliverAppBar</h3><p>相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverAppBar(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.leading,</span><br><span class="line"><span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">this</span>.title,</span><br><span class="line"><span class="keyword">this</span>.actions,</span><br><span class="line"><span class="keyword">this</span>.flexibleSpace, <span class="comment">// 通过这个来设置背景</span></span><br><span class="line"><span class="keyword">this</span>.bottom,</span><br><span class="line"><span class="keyword">this</span>.elevation,</span><br><span class="line"><span class="keyword">this</span>.forceElevated = <span class="keyword">false</span>, <span class="comment">// 是否显示层次感</span></span><br><span class="line"><span class="keyword">this</span>.backgroundColor,</span><br><span class="line"><span class="keyword">this</span>.brightness,</span><br><span class="line"><span class="keyword">this</span>.iconTheme,</span><br><span class="line"><span class="keyword">this</span>.textTheme,</span><br><span class="line"><span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">this</span>.centerTitle,</span><br><span class="line"><span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line"><span class="keyword">this</span>.expandedHeight, <span class="comment">// 展开的高度</span></span><br><span class="line"><span class="comment">// 以下三个等例子再讲</span></span><br><span class="line"><span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span><br><span class="line"><span class="keyword">this</span>.pinned = <span class="keyword">false</span>,</span><br><span class="line"><span class="keyword">this</span>.snap = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: CustomScrollView(slivers: &lt;Widget&gt;[</span><br><span class="line">SliverAppBar(</span><br><span class="line">title: Text(<span class="string">'Sliver Demo'</span>),</span><br><span class="line">centerTitle: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 展开的高度</span></span><br><span class="line">expandedHeight: <span class="number">300.0</span>,</span><br><span class="line"><span class="comment">// 强制显示阴影</span></span><br><span class="line">forceElevated: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 设置该属性，当有下滑手势的时候，就会显示 AppBar</span></span><br><span class="line"><span class="comment">// floating: true,</span></span><br><span class="line"><span class="comment">// 该属性只有在 floating 为 true 的情况下使用，不然会报错</span></span><br><span class="line"><span class="comment">// 当上滑到一定的比例，会自动把 AppBar 收缩（不知道是不是 bug，当 AppBar 下面的部件没有被 AppBar 覆盖的时候，不会自动收缩）</span></span><br><span class="line"><span class="comment">// 当下滑到一定比例，会自动把 AppBar 展开</span></span><br><span class="line"><span class="comment">// snap: true,</span></span><br><span class="line"><span class="comment">// 设置该属性使 Appbar 折叠后不消失</span></span><br><span class="line"><span class="comment">// pinned: true,</span></span><br><span class="line"><span class="comment">// 通过这个属性设置 AppBar 的背景</span></span><br><span class="line">flexibleSpace: FlexibleSpaceBar(</span><br><span class="line"><span class="comment">// title: Text('Expanded Title'),</span></span><br><span class="line"><span class="comment">// 背景折叠动画</span></span><br><span class="line">collapseMode: CollapseMode.parallax,</span><br><span class="line">background: Image.asset(<span class="string">'images/timg.jpg'</span>, fit: BoxFit.cover),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，</span></span><br><span class="line"><span class="comment">// 可以在 child 属性加入需要展示的部件</span></span><br><span class="line">SliverFillRemaining(</span><br><span class="line">child: Center(child: Text(<span class="string">'FillRemaining'</span>, style: TextStyle(fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br><span class="line">]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分别给出不同的动图来查看三个属性的影响</p><p>如果设置了 floating 属性，当有下拉动作时，会显示 AppBar</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/a2.gif" alt=""></p><p>如果设置了 snap 属性，滑动距离达到一定值后，会根据滑动方向收缩或者展开</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111020.gif" alt=""></p><p>如果设置了 pinned 属性，那么 AppBar 就会在界面上不会消失</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111101.gif" alt=""></p><p>以上的效果图把 SliverFillRemaining 换成列表 SliverFixedExtentList 效果可能会更加明显，这边给小伙伴自己替换测试吧。</p><h3 id="SliverFillViewport"><a href="#SliverFillViewport" class="headerlink" title="SliverFillViewport"></a>SliverFillViewport</h3><p>这边提到了 SliverFillRemaining 用来填充视图，那么顺带提下 SliverFillViewport 这个部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverFillViewport(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="meta">@required</span> SliverChildDelegate delegate, <span class="comment">// 这个 delegate 同 SliverGrid</span></span><br><span class="line"><span class="keyword">this</span>.viewportFraction = <span class="number">1.0</span>, <span class="comment">// 同屏幕的比例值，1.0 为一个屏幕大小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果一个滑动列表，每个 item 需要占满一个屏幕或者更大，可以使用该部件生成列表，但是如果 item 的高度小于一个屏幕高度，那就不太推荐了，在首尾会用空白 item 来把未填满的补上，就是首尾都会留空白。我们使用 SliverFillViewport 对 SliverFillRemaning 进行替换</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverFillViewport(</span><br><span class="line">viewportFraction: <span class="number">1.0</span>,</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Container(child: Text(<span class="string">'Item $index'</span>), alignment: Alignment.center, color: colors[index % <span class="number">4</span>]),</span><br><span class="line">childCount: <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>效果就不展示了，可自行运行查看。</p><h3 id="SliverToBoxAdapter"><a href="#SliverToBoxAdapter" class="headerlink" title="SliverToBoxAdapter"></a>SliverToBoxAdapter</h3><p>还记得上节最后的代码中，有使用 SliverToBoxAdapter 这个部件吗，这个部件只需要传入一个 child 属性。因为在 CustomScrollView 中只允许传入 Sliver 部件，那么类似 Container 等普通部件就不可以使用了，那么这样就需要更多的 Sliver 组件才能完成视图，所以为了方便，直接通过 SliverToBoxAdapter 对普通部件进行包裹，这样就成为一个 Sliver 部件了。总结下 SliverToBoxAdapter 的功能就是 把一个普通部件包裹成为 Sliver 部件，例子就不举了，上节已经有了。</p><h3 id="SliverPadding"><a href="#SliverPadding" class="headerlink" title="SliverPadding"></a>SliverPadding</h3><p>那么在 CustomScrollView 中部件之间如何设置间距呢，可能你会想到用 SliverToBoxAdapter 包裹一个 Padding 来处理，当然没问题。不过 Flutter 也提供了专门的部件 SliverPadding 使用方式同 Padding，但是需要传入一个 sliver 作为子类。</p><h3 id="SliverPersistentHeader"><a href="#SliverPersistentHeader" class="headerlink" title="SliverPersistentHeader"></a>SliverPersistentHeader</h3><p>Flutter 中，为我们提供了这么一个作为头部的部件 SliverPersistentHeader，这个部件可以根据滚动的距离缩小高度，有点类似 SliverAppBar 的背景效果。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverPersistentHeader(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="meta">@required</span> <span class="keyword">this</span>.delegate, <span class="comment">// SliverPersistentHeaderDelegate，用来创建展示内容</span></span><br><span class="line"><span class="keyword">this</span>.pinned = <span class="keyword">false</span>, <span class="comment">// 同 SliverAppBar 属性</span></span><br><span class="line"><span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="SliverPersistentHeaderDelegate"><a href="#SliverPersistentHeaderDelegate" class="headerlink" title="SliverPersistentHeaderDelegate"></a>SliverPersistentHeaderDelegate</h3><p>这个代理比较特殊，是个抽象类，也就是需要我们自己进行继承后再实现方法。SliverPersistentHeaderDelegate 需要提供一个最大值，最小值，展示内容，以及更新部件条件</p><p>比如我们需要展示一个最大高度 300，最小高度 100，居中的文字，那么我们可以这么写这个代理类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoHeader</span> <span class="keyword">extends</span> <span class="title">SliverPersistentHeaderDelegate</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context, <span class="built_in">double</span> shrinkOffset, <span class="built_in">bool</span> overlapsContent) &#123;</span><br><span class="line"><span class="keyword">return</span> Container(</span><br><span class="line">color: Colors.pink,</span><br><span class="line">alignment: Alignment.center,</span><br><span class="line">child: Text(<span class="string">'我是一个头部部件'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)));</span><br><span class="line">&#125; <span class="comment">// 头部展示内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> maxExtent =&gt; <span class="number">300.0</span>; <span class="comment">// 最大高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> minExtent =&gt; <span class="number">100.0</span>; <span class="comment">// 最小高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) =&gt; <span class="keyword">false</span>; <span class="comment">// 因为所有的内容都是固定的，所以不需要更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 SliverPersistentHeader 代替 SliverAppBar，看下效果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: CustomScrollView(slivers: &lt;Widget&gt;[</span><br><span class="line">SliverPersistentHeader(delegate: DemoHeader(), pinned: <span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，</span></span><br><span class="line"><span class="comment">// 可以在 child 属性加入需要展示的部件</span></span><br><span class="line">SliverFillRemaining(</span><br><span class="line">child: Center(child: Text(<span class="string">'FillRemaining'</span>, style: TextStyle(fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br><span class="line">]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/201905221400.gif" alt=""></p><p>当然，为了方便扩展，需要重新封装下 Delegate ，通过外部传入范围和展示内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 SliverPersistentHeaderDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSliverPersistentHeaderDelegate</span> <span class="keyword">extends</span> <span class="title">SliverPersistentHeaderDelegate</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> max; <span class="comment">// 最大高度</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> min; <span class="comment">// 最小高度</span></span><br><span class="line"><span class="keyword">final</span> Widget child; <span class="comment">// 需要展示的内容</span></span><br><span class="line"></span><br><span class="line">CustomSliverPersistentHeaderDelegate(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.max, <span class="meta">@required</span> <span class="keyword">this</span>.min, <span class="meta">@required</span> <span class="keyword">this</span>.child&#125;)</span><br><span class="line"><span class="comment">// 如果 assert 内部条件不成立，会报错</span></span><br><span class="line">: <span class="keyword">assert</span>(max != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(min != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(min &lt;= max),</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回展示的内容，如果内容固定可以直接在这定义，如果需要可扩展，这边通过传入值来定义</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context, <span class="built_in">double</span> shrinkOffset, <span class="built_in">bool</span> overlapsContent) =&gt; child;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> maxExtent =&gt; max; <span class="comment">// 返回最大高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> minExtent =&gt; min; <span class="comment">// 返回最小高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> shouldRebuild(CustomSliverPersistentHeaderDelegate oldDelegate) &#123;</span><br><span class="line"><span class="comment">// 是否需要更新，这里我们定义当高度范围和展示内容被替换的时候进行刷新界面</span></span><br><span class="line"><span class="keyword">return</span> max != oldDelegate.max || min != oldDelegate.min || child != oldDelegate.child;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以愉快的使用了，不需要每个 Delegate 都重新写一遍，例如替换下刚才写死的 DemoHeader</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverPersistentHeader(</span><br><span class="line"><span class="comment">// 属性同 SliverAppBar</span></span><br><span class="line">pinned: <span class="keyword">true</span>,</span><br><span class="line">floating: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 因为 SliverPersistentHeaderDelegate 是一个抽象类，所以需要自定义</span></span><br><span class="line">delegate: CustomSliverPersistentHeaderDelegate(</span><br><span class="line">max: <span class="number">300.0</span>, min: <span class="number">100.0</span>, child: Text(<span class="string">'我是一个头部部件'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>例如需要替换成一张图片，直接将 Text 修改成 Image 即可。</p><p>以上部分代码查看 sliver_main.dart 文件</p><h3 id="NestedScrollView"><a href="#NestedScrollView" class="headerlink" title="NestedScrollView"></a>NestedScrollView</h3><p>讲到这了，不得不提下 Scrollable 中比较重要的一员 NestedScrollView，先看下官方的解释</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A scrolling view inside of which can be nested other scrolling views, with</span></span><br><span class="line"><span class="comment">/// their scroll positions being intrinsically linked.</span></span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 1：一个内部能够嵌套其他滚动部件，并使其滚动位置联结到一起的滚动部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The most common use case for this widget is a scrollable view with a</span></span><br><span class="line"><span class="comment">/// flexible [SliverAppBar] containing a [TabBar] in the header (build by</span></span><br><span class="line"><span class="comment">/// [headerSliverBuilder], and with a [TabBarView] in the [body], such that the</span></span><br><span class="line"><span class="comment">/// scrollable view's contents vary based on which tab is visible.</span></span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 2：最常用的情况，就是在其 headerSliverBuilder 中使用携带 TabBar 的 SliverAppBar（就是使用 SliverAppBar 的 bottom 属性添加 tab 切换也），其 body 属性使用 TabBarView 来展示 Tab 页的内容，这样通过切换 Tab 页就能展示该页下的展示内容。</p><p>看下 headerSliverBuilder 的定义</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Signature used by [NestedScrollView] for building its header.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The `innerBoxIsScrolled` argument is typically used to control the</span></span><br><span class="line"><span class="comment">/// [SliverAppBar.forceElevated] property to ensure that the app bar shows a</span></span><br><span class="line"><span class="comment">/// shadow, since it would otherwise not necessarily be aware that it had</span></span><br><span class="line"><span class="comment">/// content ostensibly below it.</span></span><br><span class="line"><span class="keyword">typedef</span> NestedScrollViewHeaderSliversBuilder = <span class="built_in">List</span>&lt;Widget&gt; <span class="built_in">Function</span>(BuildContext context, <span class="built_in">bool</span> innerBoxIsScrolled);</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 3：用于构建 NestScrollView 的头部部件，innerBoxIsScrolled 主要用来控制 SliverAppBar 的 forceElevated 属性，当内部内容滚动时，显示 SliverAppbar 的阴影，主要用来提醒内部的内容低于 SliverAppBar （相当于给人一种物理层次感，否则很容易被认为，头部和内容是连接在一起的）</p><p>接下来看下 NestedScrollView 内部个人觉得有点重要的一个方法 sliverOverlapAbsorberHandleFor</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Returns the [SliverOverlapAbsorberHandle] of the nearest ancestor</span></span><br><span class="line"><span class="comment">/// [NestedScrollView].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is necessary to configure the [SliverOverlapAbsorber] and</span></span><br><span class="line"><span class="comment">/// [SliverOverlapInjector] widgets.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// For sample code showing how to use this method, see the [NestedScrollView]</span></span><br><span class="line"><span class="comment">/// documentation.</span></span><br><span class="line"><span class="keyword">static</span> SliverOverlapAbsorberHandle sliverOverlapAbsorberHandleFor(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> _InheritedNestedScrollView target = context.inheritFromWidgetOfExactType(_InheritedNestedScrollView);</span><br><span class="line">  <span class="keyword">assert</span>(target != <span class="keyword">null</span>, <span class="string">'NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.'</span>);</span><br><span class="line">  <span class="keyword">return</span> target.state._absorberHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意到中间的注释</p><p>糟透了的翻译 X 4：这个方法返回的值对于 SliverOverlapAbsorber 和 SliverOverlapInjector 部件是非常重要的参数</p><p>接着请注意代码中的那段 assert 中的文字</p><p>糟透了的翻译 X 5：sliverOverlapAbsorberHandleFor 传入的参数 context 中必须包含 NestedScrollView</p><h3 id="SliverOverlapAbsorber"><a href="#SliverOverlapAbsorber" class="headerlink" title="SliverOverlapAbsorber"></a>SliverOverlapAbsorber</h3><p>这边又引入了两个部件 SliverOverlapAbsorber + SliverOverlapInjector 还是看源码的解释吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Creates a sliver that absorbs overlap and reports it to a</span></span><br><span class="line"><span class="comment">/// [SliverOverlapAbsorberHandle].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [handle] must not be null.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [child] must be a sliver.</span></span><br><span class="line"><span class="keyword">const</span> SliverOverlapAbsorber(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.handle,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 6：一个 sliver 部件，用于把部件重叠的高度反馈给 SliverOverlapAbsorberHandle，而且指明了 handle 不能空，可以通过 NestedScrollView 的 sliverOverlapAbsorberHandleFor 方法来赋值，并且 child 必须是个 sliver 部件，也就是说我们的 SliverAppBar 需要放到 SliverOverlapAbsorber 里面。</p><h3 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Creates a sliver that is as tall as the value of the given [handle]'s</span></span><br><span class="line"><span class="comment">/// layout extent.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [handle] must not be null.</span></span><br><span class="line"><span class="keyword">const</span> SliverOverlapInjector(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.handle,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 7：创建一个和指定的 handle 一样高度的 sliver 部件，这个 handle 同 SliverOverlapAbsorber 的 handle 保持一致即可。</p><p>分析完源码后，例子的目标很明确，使用 SliverAppBar + TabBar + TabBarView，先看下最后的效果图吧</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111721.gif" alt=""></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> _tabs = &lt;<span class="built_in">String</span>&gt;[<span class="string">'TabA'</span>, <span class="string">'TabB'</span>];</span><br><span class="line"><span class="keyword">final</span> colors = &lt;Color&gt;[Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: DefaultTabController(</span><br><span class="line">length: _tabs.length,</span><br><span class="line">child: NestedScrollView(</span><br><span class="line">headerSliverBuilder: (context, innerScrolled) =&gt; &lt;Widget&gt;[</span><br><span class="line">SliverOverlapAbsorber(</span><br><span class="line"><span class="comment">// 传入 handle 值，直接通过 `sliverOverlapAbsorberHandleFor` 获取即可</span></span><br><span class="line">handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),</span><br><span class="line">child: SliverAppBar(</span><br><span class="line">pinned: <span class="keyword">true</span>,</span><br><span class="line">title: Text(<span class="string">'NestedScroll Demo'</span>),</span><br><span class="line">expandedHeight: <span class="number">200.0</span>,</span><br><span class="line">flexibleSpace: FlexibleSpaceBar(background: Image.asset(<span class="string">'images/timg.jpg'</span>, fit: BoxFit.cover)),</span><br><span class="line">bottom: TabBar(tabs: _tabs.map((tab) =&gt; Text(tab, style: TextStyle(fontSize: <span class="number">18.0</span>))).toList()),</span><br><span class="line">forceElevated: innerScrolled,</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">],</span><br><span class="line">body: TabBarView(</span><br><span class="line">children: _tabs</span><br><span class="line"><span class="comment">// 这边需要通过 Builder 来创建 TabBarView 的内容，否则会报错</span></span><br><span class="line"><span class="comment">// NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.</span></span><br><span class="line">.map((tab) =&gt; Builder(</span><br><span class="line">builder: (context) =&gt; CustomScrollView(</span><br><span class="line"><span class="comment">// key 保证唯一性</span></span><br><span class="line">key: PageStorageKey&lt;<span class="built_in">String</span>&gt;(tab),</span><br><span class="line">slivers: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">// 将子部件同 `SliverAppBar` 重叠部分顶出来，否则会被遮挡</span></span><br><span class="line">SliverOverlapInjector(</span><br><span class="line">handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),</span><br><span class="line">SliverGrid(</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Image.asset(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">childCount: <span class="number">8</span>),</span><br><span class="line">gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">crossAxisCount: <span class="number">4</span>, mainAxisSpacing: <span class="number">10.0</span>, crossAxisSpacing: <span class="number">10.0</span>)),</span><br><span class="line">SliverFixedExtentList(</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Container(</span><br><span class="line">child: Text(<span class="string">'$tab - item<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>,</span><br><span class="line">style: TextStyle(fontSize: <span class="number">20.0</span>, color: colors[index % <span class="number">6</span>])),</span><br><span class="line">alignment: Alignment.center),</span><br><span class="line">childCount: <span class="number">15</span>),</span><br><span class="line">itemExtent: <span class="number">50.0</span>)</span><br><span class="line">],</span><br><span class="line">),</span><br><span class="line">))</span><br><span class="line">.toList()))),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的部件和之前讲的没啥大区别，就是多了 SliverOverlapAbsorber 和 SliverOverlapInjector 没啥难度</p><p>以上部分代码查看 nested_scroll_main.dart 文件</p><p>sliver 部件常用的也就那么多了，望小伙伴好好吸收，跟着例子撸撸代码，撸顺下思路</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去&lt;/p&gt;
&lt;p&gt;在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(七)之滑动部件</title>
    <link href="http://yoursite.com/posts/8d9ab46a.html"/>
    <id>http://yoursite.com/posts/8d9ab46a.html</id>
    <published>2019-05-22T02:37:07.000Z</published>
    <updated>2019-05-22T03:03:44.777Z</updated>
    
    <content type="html"><![CDATA[<p>前面的小节基本上讲完了常用的部件和容器部件，也可以完成很多的界面，但是又一个问题，假如我们要显示一段文字，比如将 一段又臭又长的文字 在界面上显示 1000 次，不难完成吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..省略一些无关代码</span></span><br><span class="line">body: Text(<span class="string">'一段又臭又长的文字'</span> * <span class="number">1000</span>, softWrap: <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>很简单，运行到手机…「诶诶诶，**，怎么只显示了一部分，剩下的怎么画不下去」</p><p>日常开发中，会遇到很多这种情况，许多界面不是一页就能够显示完的。那么这里提下可滑动的容器部件</p><a id="more"></a><h3 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h3><p>这个部件非常简单，不贴源码了。最简单的使用方式只需要提供一个 child 即可。现在给前面写的 Text 包裹上一层 SingleChildScrollView 然后再运行，文字全部都展示出来了。</p><p>如果需要实现一个垂直的滚动列表，可以直接通过 SingleChildScrollView 包裹 Column 来实现，列表内容全部塞到 Column 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildScrollDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">/// letters 自由发挥吧...一定要大量，大量，大量</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; letters = [......];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Single Child Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: SingleChildScrollView(</span><br><span class="line">          child: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          children: <span class="built_in">List</span>.generate(</span><br><span class="line">              letters.length,</span><br><span class="line">              (index) =&gt; Padding(</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>),</span><br><span class="line">                    child: Text(letters[index], style: TextStyle(fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                  )),</span><br><span class="line">        ),</span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果会根据你的 letters 不同而不同，这边就不贴效果图了，反正你可以看到一串列表…</p><p>那么如果需要实现横向滚动列表呢，稍稍做下修改就行了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body: SingleChildScrollView(</span><br><span class="line">    <span class="comment">// 设置滚动方向</span></span><br><span class="line">    scrollDirection: Axis.horizontal,</span><br><span class="line">    child: Center(</span><br><span class="line">      <span class="comment">// 修改为 `Row` 即可</span></span><br><span class="line">      child: Row(</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            letters.length,</span><br><span class="line">            <span class="comment">// 如果你的 letters 数量比较少，推荐加个 `Container` 把宽度指定大点</span></span><br><span class="line">            (index) =&gt; Container(</span><br><span class="line">                child: Padding(</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>, horizontal: <span class="number">6.0</span>),</span><br><span class="line">                    child: Text(letters[index], style: TextStyle(fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                    ),</span><br><span class="line">                    width: <span class="number">30.0</span>)),</span><br><span class="line">      ),</span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><p>效果图也不贴了，都比较简单。</p><p>该部分代码查看 single_child_scroll_main.dart 文件*</p><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p>平时开发 Android 的时候，如果有相同格式的列表要实现，一般会使用 ListView 或者 RecyclerView 来实现，Flutter 也提供了类似的部件 ListView</p><p>实现 ListView 的方法主要有</p><ul><li><p>通过 ListView 设置 children 属性实现</p></li><li><p>通过 ListView.custom 实现</p></li><li><p>通过 ListView.builder 实现</p></li><li><p>通过 ListView.separated 实现带分割线列表</p></li></ul><h4 id="ListView-children"><a href="#ListView-children" class="headerlink" title="ListView children"></a>ListView children</h4><p>第一种方法实现列表，和通过 SingleChildScrollView + Column / Row 的方法比较类似，不过可以直接通过指定 ListView 的 scrollDirection 就可以了。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: ListView(</span><br><span class="line">    <span class="comment">// 通过修改滑动方向设置水平或者垂直方向滚动</span></span><br><span class="line">    scrollDirection: Axis.vertical,</span><br><span class="line">    <span class="comment">// 通过 iterable.map().toList 和 List.generate 方法效果是一样的</span></span><br><span class="line">    children: letters</span><br><span class="line">        .map((s) =&gt;</span><br><span class="line">        Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">            child: Center(</span><br><span class="line">                child: Text(s))))</span><br><span class="line">        .toList()),</span><br></pre></td></tr></table></figure><h4 id="ListView-custom"><a href="#ListView-custom" class="headerlink" title="ListView.custom"></a>ListView.custom</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body: ListView.custom(</span><br><span class="line">    <span class="comment">// 指定 item 的高度，可以加快渲染的速度</span></span><br><span class="line">    itemExtent: <span class="number">40.0</span>,</span><br><span class="line">    <span class="comment">// item 代理</span></span><br><span class="line">    childrenDelegate: SliverChildBuilderDelegate(</span><br><span class="line">      <span class="comment">// IndexedWidgetBuilder，根据 index 设置 item 中需要变化的数据</span></span><br><span class="line">      (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.red))),</span><br><span class="line">      <span class="comment">// 指定 item 的数量</span></span><br><span class="line">      childCount: letters.length,</span><br><span class="line">    )),</span><br></pre></td></tr></table></figure><p>如果每个 item 的高度可以确定，那么推荐通过 itemExtent 来设置 item 的高度/宽度，能够加快 ListView 的渲染速度。如果不指定高度/宽度，ListView 需要根据每个 item 来计算 ListView 的高度，这个计算过程是需要消耗时间和资源的</p><h4 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder"></a>ListView.builder</h4><p>该方法同 custom 类似，custom 需要通过一个 Delegate 生成 item，该方法直接通过 builder 生成，同时也可以直接指定 item 的高度</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: ListView.builder(</span><br><span class="line">    itemBuilder: (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.green))),</span><br><span class="line">    itemExtent: <span class="number">40.0</span>,</span><br><span class="line">    itemCount: letters.length),</span><br><span class="line">)),</span><br></pre></td></tr></table></figure><p>相对比较简单，代码也比较少…就冲这点，我也愿意用这个方法</p><h4 id="ListView-separated"><a href="#ListView-separated" class="headerlink" title="ListView.separated"></a>ListView.separated</h4><p>如果需要在每个 item 之间添加分割线，那么通过以上的方式实现就比较困难了，所以 Flutter 提供了 separated 方法用来快速构建带有分割线的 ListView</p><p>加入我们的 item 之间的分割线需要如下样式：奇数位和偶数位之间用黑色分割线，偶数位和奇数位之间用红色分割线</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要分割线的时候才使用，不能指定 item 的高度</span></span><br><span class="line">body: ListView.separated(</span><br><span class="line">    itemBuilder: (_, index) =&gt; Padding(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">20.0</span>),</span><br><span class="line">        child: Center(child: Text(letters[index], style: TextStyle(color: Colors.blue))),</span><br><span class="line">      ),</span><br><span class="line">    <span class="comment">// 这里用来定义分割线</span></span><br><span class="line">    separatorBuilder: (_, index) =&gt; Divider(height: <span class="number">1.0</span>, color: index % <span class="number">2</span> == <span class="number">0</span> ? Colors.black : Colors.red),</span><br><span class="line">    itemCount: letters.length),</span><br></pre></td></tr></table></figure><p>最终的效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522104259.png" alt=""></p><p>以上代码查看 listview_main.dart 文件</p><p>总结下：如果 item 的高度能够准确获取，一定要指定 itemExtent 的值，这样会更加高效，至于要通过哪种方式来生成，完全看个人喜好吧。</p><h3 id="ExpansionTile"><a href="#ExpansionTile" class="headerlink" title="ExpansionTile"></a>ExpansionTile</h3><p>既然讲到了 ListView，在日常开发中，折叠列表也是一个比较常用的，所以这边要提下 ExpansionTile 这个部件，因为相对比较简单，所以直接上代码了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpansionTilesDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'ExpansionTile Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: ExpansionTile(</span><br><span class="line">        <span class="comment">// 最前面的 widget</span></span><br><span class="line">        leading: Icon(Icons.phone_android),</span><br><span class="line">        <span class="comment">// 替换默认箭头</span></span><br><span class="line"><span class="comment">//        trailing: Icon(Icons.phone_iphone),</span></span><br><span class="line">        title: Text(<span class="string">'Parent'</span>),</span><br><span class="line">        <span class="comment">// 默认是否展开</span></span><br><span class="line">        initiallyExpanded: <span class="keyword">true</span>,</span><br><span class="line">        <span class="comment">// 展开时候的背景色</span></span><br><span class="line">        backgroundColor: Colors.yellow[<span class="number">100</span>],</span><br><span class="line">        <span class="comment">// 展开或者收缩的回调，true 表示展开</span></span><br><span class="line">        onExpansionChanged: (expanded) =&gt; <span class="built_in">print</span>(<span class="string">'ExpansionTile is <span class="subst">$&#123;expanded ? <span class="string">'expanded'</span> : <span class="string">'collapsed'</span>&#125;</span>'</span>),</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">                (position) =&gt;</span><br><span class="line">                Container(</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">80.0</span>),</span><br><span class="line">                  child: Text(<span class="string">'Children <span class="subst">$&#123;position + <span class="number">1</span>&#125;</span>'</span>),</span><br><span class="line">                  height: <span class="number">50.0</span>,</span><br><span class="line">                  alignment: Alignment.centerLeft,</span><br><span class="line">                )),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了一个折叠部件，看下最后的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/640.gif" alt=""></p><p>那么实现折叠列表也就是通过 ListView 创建一个 ExpansionTile 列表即可，先准备下模拟的数据</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> _keys = [<span class="string">'ParentA'</span>, <span class="string">'ParentB'</span>, <span class="string">'ParentC'</span>, <span class="string">'ParentD'</span>, <span class="string">'ParentE'</span>, <span class="string">'ParentF'</span>];</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; _data = &#123;</span><br><span class="line">    <span class="string">'ParentA'</span>: [<span class="string">'Child A0'</span>, <span class="string">'Child A1'</span>, <span class="string">'Child A2'</span>, <span class="string">'Child A3'</span>, <span class="string">'Child A4'</span>, <span class="string">'Child A5'</span>],</span><br><span class="line">    <span class="string">'ParentB'</span>: [<span class="string">'Child B0'</span>, <span class="string">'Child B1'</span>, <span class="string">'Child B2'</span>, <span class="string">'Child B3'</span>, <span class="string">'Child B4'</span>, <span class="string">'Child B5'</span>],</span><br><span class="line">    <span class="string">'ParentC'</span>: [<span class="string">'Child C0'</span>, <span class="string">'Child C1'</span>, <span class="string">'Child C2'</span>, <span class="string">'Child C3'</span>, <span class="string">'Child C4'</span>, <span class="string">'Child C5'</span>],</span><br><span class="line">    <span class="string">'ParentD'</span>: [<span class="string">'Child D0'</span>, <span class="string">'Child D1'</span>, <span class="string">'Child D2'</span>, <span class="string">'Child D3'</span>, <span class="string">'Child D4'</span>, <span class="string">'Child D5'</span>],</span><br><span class="line">    <span class="string">'ParentE'</span>: [<span class="string">'Child E0'</span>, <span class="string">'Child E1'</span>, <span class="string">'Child E2'</span>, <span class="string">'Child E3'</span>, <span class="string">'Child E4'</span>, <span class="string">'Child E5'</span>],</span><br><span class="line">    <span class="string">'ParentF'</span>: [<span class="string">'Child F0'</span>, <span class="string">'Child F1'</span>, <span class="string">'Child F2'</span>, <span class="string">'Child F3'</span>, <span class="string">'Child F4'</span>, <span class="string">'Child F5'</span>]</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>在平时开发过程中，后台返回的数据应该是列表嵌套列表的形式比较多，我这边主要就是为了偷懒就随便弄了，接着修改下 body 的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: ListView(</span><br><span class="line">          children: _keys</span><br><span class="line">              .map((key) =&gt; ExpansionTile(</span><br><span class="line">                    title: Text(key),</span><br><span class="line">                    children: _data[key]</span><br><span class="line">                        .map((value) =&gt; InkWell(</span><br><span class="line">                            child: Container(</span><br><span class="line">                              child: Text(value),</span><br><span class="line">                              padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">80.0</span>),</span><br><span class="line">                              height: <span class="number">50.0</span>,</span><br><span class="line">                              alignment: Alignment.centerLeft,</span><br><span class="line">                            ),</span><br><span class="line">                            onTap: () &#123;&#125;))</span><br><span class="line">                        .toList(),</span><br><span class="line">                  ))</span><br><span class="line">              .toList()),</span><br></pre></td></tr></table></figure><p>最终的效果就是个折叠列表了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/1212.gif" alt=""></p><p>该部分代码查看 expansion_tile_main.dart 文件</p><p>当然了，只要数据到位，别说两层折叠，三层，四层甚至更多层都能够实现，源码中有实现四层的 demo，这边就不贴代码了，有需要的小伙伴可以查看源码</p><h3 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h3><p>生成列表可以通过 ListView 来实现，那么同样，实现网格列表 Flutter 也提供了 GridView 来实现，实现 GridView 的方法也很多…我数了下，大概有 10 种..对你没看错，就是那么多，(诶诶诶，别走啊…虽然方法有点多，但是，大同小异)</p><p>GridView</p><p>GridView 需要一个 gridDelegate，gridDelegate 目前有两种</p><p>SliverGridDelegateWithFixedCrossAxisCount 看命名就知道，值固定数量的，这个数量是只单排的数量</p><p>SliverGridDelegateWithMaxCrossAxisExtent 这个是设置最大宽度/高度，在这个值范围内取最大值，比如一排能给你排下 6 个，但是远不到设置的最大值，它绝不给你排 6 个</p><p>那么接下来的使用就比较简单了</p> <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GridViewDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 自行设置</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; letters = [ ..... ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于区分网格单元</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'GridView Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">        body: GridView(</span><br><span class="line">        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">            crossAxisCount: <span class="number">5</span>, <span class="comment">// 单行的个数</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10.0</span>, <span class="comment">// 同 scrollDirection 挂钩，item 之间在主轴方向的间隔</span></span><br><span class="line">            crossAxisSpacing: <span class="number">10.0</span>, <span class="comment">// item 之间在副轴方法的间隔</span></span><br><span class="line">            childAspectRatio: <span class="number">1.0</span> <span class="comment">// item 的宽高比</span></span><br><span class="line">            ),</span><br><span class="line">        <span class="comment">// 需要根据 index 设置不同背景色，所以使用 List.generate，如果不设置背景色，也可用 iterable.map().toList</span></span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            letters.length,</span><br><span class="line">            (index) =&gt; Container(</span><br><span class="line">                  alignment: Alignment.center,</span><br><span class="line">                  child: Text(letters[index]),</span><br><span class="line">                  color: colors[index % <span class="number">4</span>],</span><br><span class="line">                )),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键地方已经添加了注释，跑下运行效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522105021.png" alt=""></p><p>接下来换一种 delegate 试试效果，当然这个最大值可以根据个人喜好来设置</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: GridView(</span><br><span class="line">        <span class="comment">// 通过设置 `maxCrossAxisExtent` 来指定最大的宽度，在这个值范围内，会选取相对较大的值</span></span><br><span class="line">        gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(</span><br><span class="line">            maxCrossAxisExtent: <span class="number">60.0</span>, crossAxisSpacing: <span class="number">10.0</span>, mainAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            letters.length,</span><br><span class="line">            (index) =&gt; Container(</span><br><span class="line">                  alignment: Alignment.center,</span><br><span class="line">                  child: Text(letters[index]),</span><br><span class="line">                  color: colors[index % <span class="number">4</span>],</span><br><span class="line">                )),</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>最后效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522105054.png" alt=""></p><p>为了方便写法呢，Flutter 对以上的两种方式进行了封装，省略了 delegate</p><p><strong>GridView.count/GridView.extent</strong></p><p>直接看下如何修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithFixedCrossAxisCount` 代理的方法</span></span><br><span class="line">    body: GridView.count(</span><br><span class="line">          crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          childAspectRatio: <span class="number">1.0</span>,</span><br><span class="line">          crossAxisCount: <span class="number">5</span>,</span><br><span class="line">          childAspectRatio: <span class="number">2.0</span>,</span><br><span class="line">          children: <span class="built_in">List</span>.generate(</span><br><span class="line">              letters.length,</span><br><span class="line">              (index) =&gt; Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    child: Text(letters[index]),</span><br><span class="line">                  ))),</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithMaxCrossAxisExtent` 代理的方法</span></span><br><span class="line">      body: GridView.extent(</span><br><span class="line">          crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          childAspectRatio: <span class="number">1.0</span>,</span><br><span class="line">          maxCrossAxisExtent: <span class="number">60.0</span>,</span><br><span class="line">          children: <span class="built_in">List</span>.generate(</span><br><span class="line">              letters.length,</span><br><span class="line">                  (index) =&gt;</span><br><span class="line">                  Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    child: Text(letters[index]),</span><br><span class="line">                  ))),</span><br></pre></td></tr></table></figure><p>运行的效果入和前面的相同</p><p><strong>GridView.custom</strong></p><p>这种生成方式，比 GridView 多了一个 childrenDelegate，childrenDelegate 主要分为两种，一种是通过 IndexedWidgetBuilder 来构建 item 的 SliverChildBuilderDelegate，还有一种是通过 List 来构建 item 的 SliverChildListDelegate，所以…这边直接有 4 中生成方式，当然，我们只需要了解 childrenDelegate 如何使用即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body: GridView.custom(</span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">              crossAxisCount: <span class="number">5</span>, mainAxisSpacing: <span class="number">10.0</span>, </span><br><span class="line">              crossAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">          <span class="comment">// item 通过 delegate 来生成，内部实现还是 `IndexedWidgetBuilder`</span></span><br><span class="line">          childrenDelegate: SliverChildBuilderDelegate(</span><br><span class="line">              (_, index) =&gt; Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    child: Text(letters[index]),</span><br><span class="line">                  ),</span><br><span class="line">              childCount: letters.length)),</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: GridView.custom(</span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">              crossAxisCount: <span class="number">5</span>, mainAxisSpacing: <span class="number">10.0</span>, </span><br><span class="line">              crossAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">          <span class="comment">// 内部通过返回控件列表实现</span></span><br><span class="line">          childrenDelegate: SliverChildListDelegate(</span><br><span class="line">            <span class="built_in">List</span>.generate(</span><br><span class="line">                letters.length,</span><br><span class="line">                (index) =&gt; Container(</span><br><span class="line">                      child: Text(letters[index]),</span><br><span class="line">                      alignment: Alignment.center,</span><br><span class="line">                      color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    )),</span><br><span class="line">          )),</span><br></pre></td></tr></table></figure><p>运行效果也同上面。</p><p><strong>GridView.builder</strong></p><p>前面介绍的方法中，生成 item 的方式基本上是通过 List 进行转换的，在 custom 提到了 IndexWidgetBuilder 的生成方式，当然，在 ListView 的时候也用到了这种生成方式，当然 GridView 也有啊，要「雨露均沾」你说是吧</p> <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 `IndexedWidgetBuilder` 来构建 item，别的参数同上</span></span><br><span class="line">      body: GridView.builder(</span><br><span class="line">          <span class="comment">// 这里又需要分两种 `gridDelegate`</span></span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">              crossAxisCount: <span class="number">5</span>, crossAxisSpacing: <span class="number">10.0</span>, mainAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">          itemCount: letters.length,</span><br><span class="line">          itemBuilder: (_, index) =&gt;</span><br><span class="line">              Container(color: colors[index % <span class="number">4</span>], child: Text(letters[index]), alignment: Alignment.center)),</span><br></pre></td></tr></table></figure><p>到这 10 种方式就说完了。终于可以歇一口气了。</p><p>该部分代码查看 gridview_main.dart 文件</p><h3 id="CustomScrollView"><a href="#CustomScrollView" class="headerlink" title="CustomScrollView"></a>CustomScrollView</h3><p>在平时的开发中，应该会遇到这么种情况，头部是一个 GridView 接下来拼接一些别的部件，然后再拼接一个列表，例如下图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522105306.png" alt=""></p><p>因为 GridView  和 ListView 亮着都是可滑动的部件，直接拼接肯定会有「滑动冲突」，所以 Flutter 就提供了一个粘合剂，CustomScrollView，那么 Flutter 如何实现呢，因为会涉及到 Sliver 系列部件，所以这边先看下大概的代码，下节会补充 Sliver 系列部件的内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomScrollDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这边用的 A-Z 字母</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; letters = [ ..... ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'CustomScrollDemo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: CustomScrollView(</span><br><span class="line">        <span class="comment">// 这里需要传入 `Sliver` 部件，下节课填坑</span></span><br><span class="line">        slivers: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// SliverGrid 实现同 GridView 实现方式一样</span></span><br><span class="line">          <span class="comment">// 同样 SliverGrid 有提供 `count`, `entent` 方法便于快速生成 SliverGrid</span></span><br><span class="line">          SliverGrid(</span><br><span class="line">              delegate: SliverChildBuilderDelegate(</span><br><span class="line">                  (_, index) =&gt; InkWell(</span><br><span class="line">                        child: Image.asset(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">                        onTap: () &#123;&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                  childCount: <span class="number">8</span>),</span><br><span class="line">              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                  crossAxisCount: <span class="number">4</span>, mainAxisSpacing: <span class="number">10.0</span>, crossAxisSpacing: <span class="number">10.0</span>)),</span><br><span class="line">          <span class="comment">// 这里下节讲</span></span><br><span class="line">          SliverToBoxAdapter(</span><br><span class="line">              child: Container(</span><br><span class="line">                  color: Colors.black12,</span><br><span class="line">                  margin: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">10.0</span>),</span><br><span class="line">                  child: Column(children: &lt;Widget&gt;[</span><br><span class="line">                    Divider(height: <span class="number">2.0</span>, color: Colors.black54),</span><br><span class="line">                    Stack(</span><br><span class="line">                      alignment: Alignment.center,</span><br><span class="line">                      children: &lt;Widget&gt;[</span><br><span class="line">                        Image.asset(<span class="string">'images/app_bar_hor.jpg'</span>, fit: BoxFit.cover),</span><br><span class="line">                        Text(<span class="string">'我是一些别的东西..例如广告'</span>, textScaleFactor: <span class="number">1.5</span>, style: TextStyle(color: Colors.red))</span><br><span class="line">                      ],</span><br><span class="line">                    ),</span><br><span class="line">                    Divider(height: <span class="number">2.0</span>, color: Colors.black54),</span><br><span class="line">                  ], mainAxisAlignment: MainAxisAlignment.spaceBetween),</span><br><span class="line">                  alignment: Alignment.center)),</span><br><span class="line">          <span class="comment">// SliverFixedExtentList 实现同 List.custom 实现类似</span></span><br><span class="line">          SliverFixedExtentList(</span><br><span class="line">              delegate: SliverChildBuilderDelegate(</span><br><span class="line">                  (_, index) =&gt; InkWell(</span><br><span class="line">                        child: Container(</span><br><span class="line">                          child: Text(letters[index] * <span class="number">10</span>,</span><br><span class="line">                              style: TextStyle(color: colors[index % colors.length], letterSpacing: <span class="number">2.0</span>),</span><br><span class="line">                              textScaleFactor: <span class="number">1.5</span>),</span><br><span class="line">                          alignment: Alignment.center,</span><br><span class="line">                        ),</span><br><span class="line">                        onTap: () &#123;&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                  childCount: letters.length),</span><br><span class="line">              itemExtent: <span class="number">60.0</span>)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看 custom_scroll_main.dart 文件</p><p>滑动部件其实还有好几个，但是以上介绍的在平时开发过程中够用了，如果后期发现还需要别的部件，我会继续补上。在结束前，我们再说下如何通过 ScrollController 来控制 Scrollable 的滚动位置。例如我们需要实现，当滚动的距离大于一定距离的时候显示一个回到顶部的按钮，有了 ScrollController 就能够非常方便的实现</p><h3 id="ScrollController"><a href="#ScrollController" class="headerlink" title="ScrollController"></a>ScrollController</h3><p>因为需要根据滑动的距离显示回到顶部按钮，那么就需要通过一个状态位来控制按钮显隐</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollControllerDemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScrollControllerDemoPageState createState() =&gt; _ScrollControllerDemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScrollControllerDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ScrollControllerDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _scrollController = ScrollController();</span><br><span class="line">  <span class="keyword">var</span> _showBackTop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 scrollController 进行监听</span></span><br><span class="line">    _scrollController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// _scrollController.position.pixels 获取当前滚动部件滚动的距离</span></span><br><span class="line">      <span class="comment">// window.physicalSize.height 获取屏幕高度</span></span><br><span class="line">      <span class="comment">// 当滚动距离大于 800 后，显示回到顶部按钮</span></span><br><span class="line">      setState(() =&gt; _showBackTop = _scrollController.position.pixels &gt;= <span class="number">800</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 记得销毁对象</span></span><br><span class="line">    _scrollController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'ScrollController Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: ListView(</span><br><span class="line">        controller: _scrollController,</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            <span class="number">20</span>, (index) =&gt; Container(height: <span class="number">50.0</span>, alignment: Alignment.center, child: Text(<span class="string">'Item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>))),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: _showBackTop <span class="comment">// 当需要显示的时候展示按钮，不需要的时候隐藏，设置 null</span></span><br><span class="line">          ? FloatingActionButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                <span class="comment">// scrollController 通过 animateTo 方法滚动到某个具体高度</span></span><br><span class="line">                <span class="comment">// duration 表示动画的时长，curve 表示动画的运行方式，flutter 在 Curves 提供了许多方式</span></span><br><span class="line">                _scrollController.animateTo(<span class="number">0.0</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), curve: Curves.decelerate);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Icon(Icons.vertical_align_top),</span><br><span class="line">            )</span><br><span class="line">          : <span class="keyword">null</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/a1.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的小节基本上讲完了常用的部件和容器部件，也可以完成很多的界面，但是又一个问题，假如我们要显示一段文字，比如将 一段又臭又长的文字 在界面上显示 1000 次，不难完成吧&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ..省略一些无关代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;body: Text(&lt;span class=&quot;string&quot;&gt;&#39;一段又臭又长的文字&#39;&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;, softWrap: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很简单，运行到手机…「诶诶诶，**，怎么只显示了一部分，剩下的怎么画不下去」&lt;/p&gt;
&lt;p&gt;日常开发中，会遇到很多这种情况，许多界面不是一页就能够显示完的。那么这里提下可滑动的容器部件&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(六)路由</title>
    <link href="http://yoursite.com/posts/b89d6378.html"/>
    <id>http://yoursite.com/posts/b89d6378.html</id>
    <published>2019-04-25T08:49:46.000Z</published>
    <updated>2019-05-22T03:02:57.042Z</updated>
    
    <content type="html"><![CDATA[<p>上一节撸了个界面，虽然比较简单，但是把前面讲的知识串联了下，但是界面之间的跳转一直没说，这节就讲下 Flutter 中的「路由」来管理界面。</p><h3 id="1、Navigator"><a href="#1、Navigator" class="headerlink" title="1、Navigator"></a>1、Navigator</h3><p>Flutter 通过 Navigator  来进行页面之间的跳转，分为 push 系列和 pop 系列操作，带 push 方法为入栈操作，带 pop 方法为出栈操作。Navigator 的 push 方法分两类，一类是带 Name 的，需要在 MaterialApp 下将 routers 属性进行注册，否则将会找不到该路由，还有一个是不带 Name 的，可以通过 Router 直接跳转。</p><p>说那么多相信还不如直接上代码和图来的更直接。因为需要展示所有的跳转至少需要 3 个页面，所以我们创建最简单的三个界面，通过文字来区别不同的页面，因为需要调用带有 Name 的方法，所以需要先在 MaterialApp 对路由进行注册。</p><a id="more"></a><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Learning Demo'</span>,</span><br><span class="line">      <span class="comment">// 在这里注册路由，关联 name 和界面</span></span><br><span class="line">      <span class="comment">// '/' 表示根页面，也就是 home 所对应的页面，这边就不需要配置 home 属性了</span></span><br><span class="line">      routes: &#123;<span class="string">'/'</span>: (_) =&gt; APage(), <span class="string">'/page_b'</span>: (_) =&gt; BPage(), <span class="string">'/page_c'</span>: (_) =&gt; CPage()&#125;,</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Page A，Button 的跳转事件等会进行修改，目前先空着</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Page A'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(child: RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'To Page B'</span>))),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Page B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Page B'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">        RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'To Page C'</span>)),</span><br><span class="line">        RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Back Page A'</span>))</span><br><span class="line">      ])),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Page C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Page C'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">              mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">              children: &lt;Widget&gt;[RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Back Last Page'</span>))])),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>push / pushNamed 方式跳转</strong></p><p>我们在 APage 的 RaiseButton 的 onPressed 方法加入如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage()));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushNamed(context, <span class="string">'/page_b'</span>);</span><br></pre></td></tr></table></figure><p>效果相同。跳转后，可以发现，在 BPage 的 AppBar 上有个返回按钮，点击可以返回 APage ，那么也就是说通过 push 或者 pushNamed 方式跳转的时候，界面堆栈的变化是直接在原来的堆栈上添加一个新的 page</p><p><strong>为了凸显堆栈的变化，所以绘制的图中，会比使用的实际页面多一个，下图同</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165301.png" alt=""></p><p><strong>pushReplacement / pushReplacementNamed / popAndPushNamed</strong></p><p>将 APage 中的跳转方式进行替换</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushReplacement(context, MaterialPageRoute(builder: (_) =&gt; BPage()));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushReplacementNamed(context, <span class="string">'/page_b'</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">/ 如果是第一个界面跳转到下个界面，勿用，`BPage` 会显示返回按钮，但是点击后，界面会变黑</span><br><span class="line"><span class="comment">// 因为 `APage` 已经不在堆栈中了，点击后堆栈就没有 `Page` 了，所以界面变黑</span></span><br><span class="line">Navigator.popAndPushNamed(context, <span class="string">'/page_b'</span>);</span><br></pre></td></tr></table></figure><p>效果相同，跳转后，可以发现 BPage 的返回按钮消失了，消失了，消失了，我们可以试下点击返回按键，发现 App 直接退出了，也就是说，BPage 替代了 APage 在堆栈中的位置。那么堆栈的变化图就是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165609.png" alt=""></p><p><strong>pushAndRemoveUntil / pushNamedAndRemoveUntil</strong></p><p><strong>CASE 1</strong></p><p>这个跳转方式需要通过 CPage 来协助完成，将 APage 的跳转方式修改为 push 方式，然后在 BPage 的第一个按钮加入如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushAndRemoveUntil(context, </span><br><span class="line">                   MaterialPageRoute(builder: (_) =&gt; CPage()), (Route router) =&gt; <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushNamedAndRemoveUntil(context, <span class="string">'/page_c'</span>, (Route router) =&gt; <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>效果相同，点击 BPage 的跳转 CPage 按钮后，界面来到 CPage，然后发现还是没有返回按钮，没有返回按钮，没有返回按钮，点击下返回按键，然后发现 App 直接退出了，退出了，退出了，那么堆栈变化如图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165652.png" alt=""></p><p><strong>CASE 2</strong></p><p>你以为这两个方法只是为了把堆栈都清空吗，那就太图样图森破了，这边展示另一种。修改跳转的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushAndRemoveUntil(context, </span><br><span class="line">                MaterialPageRoute(builder: (_) =&gt; CPage()), ModalRoute.withName(<span class="string">'/'</span>));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushNamedAndRemoveUntil(context, <span class="string">'/page_c'</span>, ModalRoute.withName(<span class="string">'/'</span>));</span><br></pre></td></tr></table></figure><p>点击跳转 CPage 以后，发现返回按钮又回来了…就这么回来了…只是修改了一个参数，点击返回按钮，又回到了 APage，你可以在 APage 跳转 BPage 中加入DPage EPage 等等更多的界面，只要保证 BPage 跳转 CPage 的方式不变，点击 CPage 的返回按钮，又回到 APage 了，所以…堆栈的变化图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165739.png" alt=""></p><p><strong>SUMMARY</strong></p><p>为什么会这样变化呢，还记得在 MaterialApp 中注册的 router 么，APage 的 name 对应的为 ‘/‘，也就是说，该方法会把堆栈中在 ModalRoute.withName 所对应的 page 上的所有都 pop 出堆栈，如果把参数换成 /page_b，然后在跳转 CPage 之前加入更多的界面，点击 CPage 的返回按钮，就会回到 BPage</p><p><strong>pop</strong></p><p>在 BPage 的第二个按钮中加入 pop 操作</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pop(context);</span><br></pre></td></tr></table></figure><p>跳转到 BPage 后点击该按钮，界面回到 APage，那么堆栈的变化很明显了，如图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165912.png" alt=""></p><p><strong>popUntil</strong></p><p>这个方法还需要借助 CPage ，在 CPage 的按钮中加入</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.popUntil(context, ModalRoute.withName(<span class="string">'/'</span>));</span><br></pre></td></tr></table></figure><p>点击返回按钮，界面跳过 BPage 回到了 APage，解释同 pushAndRemoveUntil 那么堆栈的变化也显而易见咯</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165937.png" alt=""></p><h3 id="2、Navigator-传值"><a href="#2、Navigator-传值" class="headerlink" title="2、Navigator 传值"></a>2、Navigator 传值</h3><p><strong>CASE 1 传值给下个界面</strong></p><p>修改下 BPage 和 APage 的按钮点击事件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  BPage(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.message&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'passed value: $message'</span>);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// 省略相同代码</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// APage 跳转事件</span></span><br><span class="line">Navigator.push(context, MaterialPageRoute(builder: </span><br><span class="line">                                          (_) =&gt; BPage(message: <span class="string">'Message From Page A'</span>)));</span><br></pre></td></tr></table></figure><p>点击 APage 可以查看控制台有输出</p><blockquote><p>2019-03-17 00:04:06.854 12868-12888/com.kuky.demo.flutterartsdemosapp I/flutter: passed value: Message From Page A</p></blockquote><p>也就是成功把值传递过来了。<strong>但是，需要传递参数的话，之前在 MaterialApp 下注册的路由就需要去除了。</strong></p><p><strong>CASE 2 传值给上个界面</strong></p><p>这边可以查看下 pop 方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  <span class="comment">// pop 可以传入一个可选参数 result，这个 result 也就是回传给上个页面的参数值了</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> pop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, [ T result ]) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).pop&lt;T&gt;(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>既然知道 pop 如何传递值给上个界面，那么如何在上个界面接收这个参数呢，还是看下 push 方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  <span class="keyword">static</span> Future&lt;T&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, Route&lt;T&gt; route) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).push(route);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  Future&lt;T&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(Route&lt;T&gt; route) &#123;</span><br><span class="line">    <span class="comment">// ...省略无关代码</span></span><br><span class="line">    <span class="comment">// 这边返回一个 Future 值，`pop` 所传递的值会在这边返回</span></span><br><span class="line">    <span class="keyword">return</span> route.popped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The future completes with the value given to [Navigator.pop], if any.</span></span><br><span class="line">Future&lt;T&gt; <span class="keyword">get</span> popped =&gt; _popCompleter.future;</span><br></pre></td></tr></table></figure><p>官方的注释非常明白的指出，会在 Future 中携带 pop 传递的参数，那么我们对 APage跳转 BPage 以及 BPage 返回 APage 的逻辑进行修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// APage</span></span><br><span class="line">Navigator.push(context, MaterialPageRoute(builder: (_) </span><br><span class="line">                                          =&gt; BPage(message: <span class="string">'Message From Page A'</span>)))</span><br><span class="line">                    .then((value) =&gt; <span class="built_in">print</span>(<span class="string">'BACK MESSAGE =&gt; $value'</span>));</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/// BPage</span></span><br><span class="line">Navigator.pop(context, <span class="string">'Message back to PageA From BPage'</span>);</span><br></pre></td></tr></table></figure><p>点击返回后，能够在控制台发现有如下输入</p><blockquote><p>2019-03-17 16:35:53.820 13417-13442/com.kuky.demo.flutterartsdemosapp I/flutter: BACK MESSAGE =&gt; Message back to PageA From BPage</p></blockquote><p>上个页面成功接收到下个页面回传的数据。</p><p><strong>CASE 3 通过系统返回按钮传值</strong></p><p>在 CASE 2 情况下，通过按钮对返回事件进行监听，那加入我们需求没有这个按钮，只能通过系统默认的返回按钮，或者物理返回按键，那该如何传值呢，这里就需要用 WillpopScope 对系统的返回按钮进行监听。我们对 CPage 做下修改，在 Scaffold 外面包裹一个 WillpopScope</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> WillPopScope(</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Page C'</span>),</span><br><span class="line">          ),</span><br><span class="line">          body: Center(</span><br><span class="line">              child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">            RaisedButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.popUntil(context, ModalRoute.withName(<span class="string">'/'</span>));</span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">'Back Last Page'</span>))</span><br><span class="line">          ])),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 这里对系统返回按钮做监听..</span></span><br><span class="line">        <span class="comment">// 如果返回的是 `true` 则相当于 `pop` 操作，返回 `false` 则只执行上一步的 `pop` 操作</span></span><br><span class="line">        <span class="comment">// 例如双击返回退出，也是通过 `WillpopScope` 来进行监听</span></span><br><span class="line">        onWillPop: () <span class="keyword">async</span> &#123;</span><br><span class="line">          Navigator.pop(context, <span class="string">'Hello~'</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过返回按钮，BPage 会成功收到从 CPage 返回的 Hello~ 值</p><p>以上代码查看 router_main.dart 文件</p><h3 id="3、路由切换动画"><a href="#3、路由切换动画" class="headerlink" title="3、路由切换动画"></a>3、路由切换动画</h3><p>假如说我们不想用系统自带的切换动画，需要弄一些比较酷炫的效果该怎么办，那就需要用到自定义路由切换动画了。直接修改 BPage 跳转 CPage 的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    PageRouteBuilder(</span><br><span class="line">        <span class="comment">// 返回目标页面</span></span><br><span class="line">        pageBuilder: (context, anim, _) =&gt; CPage(),</span><br><span class="line">        <span class="comment">// 切换动画的切换时长</span></span><br><span class="line">        transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">        <span class="comment">// 切换动画的切换效果，系统自带的常用 Transition</span></span><br><span class="line">        <span class="comment">// ScaleTransition: 缩放  SlideTransition: 滑动</span></span><br><span class="line">        <span class="comment">// RotationTransition: 旋转  FadeTransition: 透明度</span></span><br><span class="line">        transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition(</span><br><span class="line">              <span class="comment">// Tween 是 flutter 的补间动画，等讲到动画的时候再提吧，这边先记住这么使用</span></span><br><span class="line">              scale: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">              <span class="comment">// 这个值必须记得要传，否则会不显示界面</span></span><br><span class="line">              child: child,</span><br><span class="line">            )));</span><br></pre></td></tr></table></figure><p>当再次点击跳转的时候，切换的动画就有开始自带的平滑效果变成缩放效果了。那如果要实现多个动画呢，例如边缩放，边改变透明度，也很容易实现，只需要将 child 替换成 Transition 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    PageRouteBuilder(</span><br><span class="line">        pageBuilder: (context, anim, _) =&gt; CPage(),</span><br><span class="line">        transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">        transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition(</span><br><span class="line">              scale: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">              <span class="comment">// 替换即可，如果要加入更多的动画，替换 `child` 属性就可以了</span></span><br><span class="line">              child: FadeTransition(</span><br><span class="line">                opacity: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">                child: child,</span><br><span class="line">              ),</span><br><span class="line">            )));</span><br></pre></td></tr></table></figure><p>当然，为了方便重复利用，需要进行封装，例如我们要封装上面的缩放动画效果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalePageRoute</span> <span class="keyword">extends</span> <span class="title">PageRouteBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget widget;</span><br><span class="line"></span><br><span class="line">  ScalePageRoute(<span class="keyword">this</span>.widget)</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">            transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">            pageBuilder: (context, anim, _) =&gt; widget,</span><br><span class="line">            transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition(</span><br><span class="line">                  scale: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">                  child: child,</span><br><span class="line">                ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接在 Navigator 跳转的时候调用该 Route 就可以了</p><p>该部分代码查看 custom_routes.dart 文件</p><p>还记得我们之前写的 demo 都是单个文件写一个入口的吗，现在我们就可以写一个统一管理的页面，对这些界面进行管理了，这个工作就交给大家伙自己了，当然我也在源码做了修改，可以查看 main.dart 文件</p><p>代码地址:</p><p><a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一节撸了个界面，虽然比较简单，但是把前面讲的知识串联了下，但是界面之间的跳转一直没说，这节就讲下 Flutter 中的「路由」来管理界面。&lt;/p&gt;
&lt;h3 id=&quot;1、Navigator&quot;&gt;&lt;a href=&quot;#1、Navigator&quot; class=&quot;headerlink&quot; title=&quot;1、Navigator&quot;&gt;&lt;/a&gt;1、Navigator&lt;/h3&gt;&lt;p&gt;Flutter 通过 Navigator  来进行页面之间的跳转，分为 push 系列和 pop 系列操作，带 push 方法为入栈操作，带 pop 方法为出栈操作。Navigator 的 push 方法分两类，一类是带 Name 的，需要在 MaterialApp 下将 routers 属性进行注册，否则将会找不到该路由，还有一个是不带 Name 的，可以通过 Router 直接跳转。&lt;/p&gt;
&lt;p&gt;说那么多相信还不如直接上代码和图来的更直接。因为需要展示所有的跳转至少需要 3 个页面，所以我们创建最简单的三个界面，通过文字来区别不同的页面，因为需要调用带有 Name 的方法，所以需要先在 MaterialApp 对路由进行注册。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(五)输入处理及登录界面实战</title>
    <link href="http://yoursite.com/posts/4b62f141.html"/>
    <id>http://yoursite.com/posts/4b62f141.html</id>
    <published>2019-04-25T08:40:00.000Z</published>
    <updated>2019-05-22T03:03:31.283Z</updated>
    
    <content type="html"><![CDATA[<p>前面提到基础部件的时候，忘了提输入内容处理部件，这里补上，然后顺带撸个实际的界面吧</p><h3 id="1、TextField"><a href="#1、TextField" class="headerlink" title="1、TextField"></a>1、TextField</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.controller, <span class="comment">// 定义一个 `TextEditingController` 实例，用来获取输入框内容等操作</span></span><br><span class="line">    <span class="keyword">this</span>.focusNode, <span class="comment">// 定义一个 `FocusNode` 实例，判断当前输入框是否获取到焦点等操作</span></span><br><span class="line">    <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(), <span class="comment">// 输入框样式，包括提醒字样，hint 等等</span></span><br><span class="line">    TextInputType keyboardType, <span class="comment">// 输入文本类型，例如 数字，email 等等</span></span><br><span class="line">    <span class="keyword">this</span>.textInputAction, <span class="comment">// 键盘确认按钮的事件类型</span></span><br><span class="line">    <span class="keyword">this</span>.textCapitalization = TextCapitalization.none,</span><br><span class="line">    <span class="keyword">this</span>.style, <span class="comment">// 文字样式</span></span><br><span class="line">    <span class="keyword">this</span>.textAlign = TextAlign.start, <span class="comment">// 对齐方式</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection, <span class="comment">// 文字方向</span></span><br><span class="line">    <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>, <span class="comment">// 是否自动获取焦点</span></span><br><span class="line">    <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>, <span class="comment">// 文字是否隐藏，多用于密码</span></span><br><span class="line">    <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>, </span><br><span class="line">    <span class="keyword">this</span>.maxLines = <span class="number">1</span>, <span class="comment">//</span></span><br><span class="line">    <span class="keyword">this</span>.maxLength, <span class="comment">// 最大长度</span></span><br><span class="line">    <span class="keyword">this</span>.maxLengthEnforced = <span class="keyword">true</span>, <span class="comment">// 设置最大长度后，输入内容超出后是否强制不给输入</span></span><br><span class="line">    <span class="keyword">this</span>.onChanged, <span class="comment">// 输入内容发生变化时候的回调</span></span><br><span class="line">    <span class="keyword">this</span>.onEditingComplete, <span class="comment">// 输入完毕的回调</span></span><br><span class="line">    <span class="keyword">this</span>.onSubmitted, <span class="comment">// 提交内容的回调</span></span><br><span class="line">    <span class="keyword">this</span>.inputFormatters, <span class="comment">// </span></span><br><span class="line">    <span class="keyword">this</span>.enabled, <span class="comment">// 是否可输入，false 不可输入</span></span><br><span class="line">    <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>, <span class="comment">// 游标宽度</span></span><br><span class="line">    <span class="keyword">this</span>.cursorRadius, <span class="comment">// 游标半径</span></span><br><span class="line">    <span class="keyword">this</span>.cursorColor, <span class="comment">// 游标颜色</span></span><br><span class="line">    <span class="keyword">this</span>.keyboardAppearance, <span class="comment">// 该属性只在 iOS 设备有效</span></span><br><span class="line">    <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">    <span class="keyword">this</span>.enableInteractiveSelection,</span><br><span class="line">    <span class="keyword">this</span>.onTap, <span class="comment">// 点击事件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>那么，简单的来个输入框示例吧，然后通过 Text 展示结果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 可以传入初始值</span></span><br><span class="line">  TextEditingController _editController = TextEditingController();</span><br><span class="line">  FocusNode _editNode = FocusNode();</span><br><span class="line">  <span class="comment">// 保存按钮点击后的输入内容值</span></span><br><span class="line">  <span class="built_in">String</span> _content = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 监听输入内容变化的内容值</span></span><br><span class="line">  <span class="built_in">String</span> _spyContent = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 当输入框获取到焦点或者失去焦点的时候回调用</span></span><br><span class="line">    _editNode.addListener(() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'edit has focus? =&gt; <span class="subst">$&#123;_editNode.hasFocus&#125;</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 记得销毁，防止内存溢出</span></span><br><span class="line">    _editController.dispose();</span><br><span class="line">    _editNode.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Input Content'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              TextField(</span><br><span class="line">                controller: _editController,</span><br><span class="line">                focusNode: _editNode,</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                    icon: Icon(Icons.phone_iphone, color: Theme.of(context).primaryColor),</span><br><span class="line">                    labelText: <span class="string">'请输入手机号'</span>,</span><br><span class="line">                    helperText: <span class="string">'手机号'</span>,</span><br><span class="line">                    hintText: <span class="string">'手机号...在这儿输入呢'</span>),</span><br><span class="line">                keyboardType: TextInputType.number,</span><br><span class="line">                <span class="comment">// 输入类型为数字类型</span></span><br><span class="line">                textInputAction: TextInputAction.done,</span><br><span class="line">                style: TextStyle(color: Colors.redAccent, fontSize: <span class="number">18.0</span>),</span><br><span class="line">                textDirection: TextDirection.ltr,</span><br><span class="line">                maxLength: <span class="number">11</span>, <span class="comment">// 最大长度为 11</span></span><br><span class="line">                maxLengthEnforced: <span class="keyword">true</span>, <span class="comment">// 超过长度的不显示</span></span><br><span class="line">                onChanged: (v) &#123; <span class="comment">// 输入的内容发生改变会调用</span></span><br><span class="line">                  setState(() =&gt; _spyContent = v);</span><br><span class="line">                &#125;,</span><br><span class="line">                onSubmitted: (s) &#123; <span class="comment">// 点击确定按钮时候会调用</span></span><br><span class="line">                  setState(() =&gt; _spyContent = _editController.value.text);</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              Padding(</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">                  child: RaisedButton(</span><br><span class="line">                      onPressed: () &#123; </span><br><span class="line">                        <span class="comment">// 获取输入的内容</span></span><br><span class="line">                        setState(() =&gt; _content = _editController.value.text);</span><br><span class="line">                        <span class="comment">// 清理输入内容</span></span><br><span class="line">                        _editController.clear();</span><br><span class="line">                        setState(() =&gt; _spyContent = <span class="string">''</span>);</span><br><span class="line">                      &#125;,</span><br><span class="line">                      child: Text(<span class="string">'获取输入内容'</span>))),</span><br><span class="line">              <span class="comment">// 展示输入的内容，点击按钮会显示</span></span><br><span class="line">              Text(_content.isNotEmpty ? <span class="string">'获取到输入内容: $_content'</span> : <span class="string">'还未获取到任何内容...'</span>),</span><br><span class="line">              Padding(</span><br><span class="line">                padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">                <span class="comment">// 监听输入内容的变化，会跟随输入的内容进行改变</span></span><br><span class="line">                child: Text(<span class="string">'我是文字内容监听：$_spyContent'</span>),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边需要提下的是 setState 方法，该方法只有 StatefulWidget 才有，当需要修改某个值的内容的时候，通过该方法进行修改，最后的效果图如下，当输入框文字发生变化的时候，监听的 Text 内容会随之改变，获取内容的 Text 当点击按钮了才发生变化</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164133.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164145.png" alt=""></p><p>该部分代码查看 text_field_main.dart 文件</p><p>那么如果有个需求，在点击按钮的时候需要对输入的内容的合理性进行检测，当然可以通过 TextEditingController 的结果进行检测，但是还有个更加方便的方法，可以直接使用部件 TextFormField 来实现，不过需要我们在外层加一个 Form 部件，接下来，就要准备通过 TextFormField 来撸一个登录界面，但是这之前，前面有个坑需要先解决下</p><h3 id="2、导入自定义的图标"><a href="#2、导入自定义的图标" class="headerlink" title="2、导入自定义的图标"></a>2、导入自定义的图标</h3><p>在这之前，涉及到 Icon 部件，都是使用的系统自带的图标，那么如何导入第三方自定义图标呢，马上为你揭晓答案，首先我们需要打开「阿里妈妈」也就是 iconfont，不知道的小伙伴通过链接打开，然后需要注册个账户，也可以直接通过 Github 等三方登录，然后就可以搜索我们需要的图标了，接下来需要撸一个登录，那我们就找一个 用户  和 密码 的图标吧，选择喜欢的图标，然后鼠标放到图标会出现三个按钮，直接点击 购物车 那个按钮，然后就可以通过顶部的 购物车 按钮查看添加的图标，点击下载代码，把资源文件下载到本地。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164358.png" alt=""></p><p>解压后，需要用到的文件有两个，别的可以忽略</p><ol><li>demo_index.html 这边用来查看图标的 unicode</li><li>iconfont.ttf 这边就是图标资源文件了</li></ol><p>回到项目，创建一个文件夹 fonts ，和 images 同级，将 iconfont.ttf 文件放到该文件夹下，然后打开 pubspec.ymal 文件，注册下导入的资源，可以自己命名 iconfont.ttf 文件名，便于自己发现就行，例如我命名为 third_part_icon.ttf，在注册图片下面继续添加</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">fonts:</span><br><span class="line">  - family: ThirdPartIcons</span><br><span class="line">    fonts:</span><br><span class="line">    - asset: fonts/third_part_icon.ttf</span><br></pre></td></tr></table></figure><p>注册完了记得点击 Package get，否则会找不到资源。接着新建个 third_icons.dart文件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdIcons</span> </span>&#123;</span><br><span class="line">  <span class="comment">// codePoint 值通过打开 `demo_index.html` 获取</span></span><br><span class="line">  <span class="comment">// 会在相应 icon 下带有相应的 code，把 `&amp;#` 替换成 `0`，然后去掉最后的 `;` 即可</span></span><br><span class="line">  <span class="comment">// 例如 &amp;#xe672; 对应我们需要的图标就是 0xe672</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData username = ThirdIconData(<span class="number">0xe672</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData password = ThirdIconData(<span class="number">0xe62f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdIconData</span> <span class="keyword">extends</span> <span class="title">IconData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// fontFamily 就是我们在 `pubspec.yaml` 中注册的 family 值</span></span><br><span class="line">  <span class="keyword">const</span> ThirdIconData(<span class="built_in">int</span> codePoint) : <span class="keyword">super</span>(codePoint, fontFamily: <span class="string">'ThirdPartIcons'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以通过该类导入需要的第三方图标了。</p><h3 id="3、导入第三方插件"><a href="#3、导入第三方插件" class="headerlink" title="3、导入第三方插件"></a>3、导入第三方插件</h3><p>其实 Flutter 中缺少很多功能，需要通过导入第三方插件来实现功能，插件就是 Flutter 和原生交互的桥梁，也就是说，要写 Flutter 的插件，需要写 Android 和 iOS 两端代码才可，否则只有在其中一个端能够实现功能。好在有很多现成的插件已经开源，可以通过 FlutterPackage 搜索到，例如等会我们会需要用到 FlutterToast 这个插件，用来做提醒用，在 FlutterPackage 中搜索到插件后，打开项目中的 pubspec.ymal 文件，在 dependencies 类目下将 fluttertoast 插件引入，如图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164504.png" alt=""></p><p>然后点击 Package get 让其导入即可，别的插件也是这样导入。做好准备工作，我们就可以撸一个登录界面了~</p><h3 id="4、撸一个登录界面"><a href="#4、撸一个登录界面" class="headerlink" title="4、撸一个登录界面"></a>4、撸一个登录界面</h3><p>在开撸之前，我们先看下最终的效果图吧，虽然是比较常用的界面</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164542.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164604.png" alt=""></p><p>因为两个界面比较相似，所以这边只贴外层的代码和登录的代码，具体的代码，可以查看源码，已经推到 Github</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(LoginApp());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">    <span class="keyword">var</span> style = SystemUiOverlayStyle(statusBarColor: Colors.transparent);</span><br><span class="line">    SystemChrome.setSystemUIOverlayStyle(style);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 外层界面，包裹登录界面和注册界面，使用的都是前面讲过的，忘记可以查看之前的章节</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Login Demo'</span>,</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      theme: ThemeData(primarySwatch: Colors.lightBlue),</span><br><span class="line">      home: LoginHomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LoginHomePageState createState() =&gt; _LoginHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginHomePage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  TabController _tabController;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _pageIndicators = [<span class="string">'登录'</span>, <span class="string">'注册'</span>];</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; _pages = [];</span><br><span class="line">  <span class="built_in">int</span> _position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _tabController = TabController(length: _pageIndicators.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将登录界面和注册界面添加到列表，用于放到 IndexStack 的 children 属性</span></span><br><span class="line">    _pages..add(LoginPage())..add(RegisterPage());</span><br><span class="line"></span><br><span class="line">    _tabController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// 当 tab 切换的时候，联动 IndexStack 的 child 页面也进行修改，通过 setState 来修改值</span></span><br><span class="line">      <span class="keyword">if</span> (_tabController.indexIsChanging) setState(() =&gt; _position = _tabController.index);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 先忽略...</span></span><br><span class="line">    <span class="keyword">return</span> Theme(</span><br><span class="line">        data: ThemeData(primarySwatch: Colors.pink, iconTheme: IconThemeData(color: Colors.pink)),</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          body: Container(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">            alignment: Alignment.center,</span><br><span class="line">            decoration:</span><br><span class="line">                BoxDecoration(image: DecorationImage(image: AssetImage(<span class="string">'images/login_bg.png'</span>), fit: BoxFit.cover)),</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 先忽略...下面会讲，主要是解决软键盘弹出的时候，界面内容会溢出的问题</span></span><br><span class="line">            child: SingleChildScrollView(</span><br><span class="line">              child: SafeArea(</span><br><span class="line">                  child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 顶部页面切换指示器，代码可以参考 `app_bar_main.dart` 文件</span></span><br><span class="line">                TabBar(</span><br><span class="line">                    indicatorSize: TabBarIndicatorSize.label,</span><br><span class="line">                    controller: _tabController,</span><br><span class="line">                    indicatorWeight: <span class="number">4.0</span>,</span><br><span class="line">                    indicatorColor: Colors.white,</span><br><span class="line">                    <span class="comment">// 返回 tab 列表</span></span><br><span class="line">                    tabs: _pageIndicators</span><br><span class="line">                        .map((v) =&gt; Text(v, style: TextStyle(color: Colors.white, fontSize: <span class="number">24.0</span>)))</span><br><span class="line">                        .toList()),</span><br><span class="line">                Padding(</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">30.0</span>),</span><br><span class="line">                    child: SizedBox(</span><br><span class="line">                        <span class="comment">// 切换界面列表</span></span><br><span class="line">                        child: IndexedStack(children: _pages, index: _position),</span><br><span class="line">                        <span class="comment">// 指定高度</span></span><br><span class="line">                        height: MediaQuery.of(context).size.height / <span class="number">2</span>))</span><br><span class="line">              ])),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 登录界面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LoginPageState createState() =&gt; _LoginPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 用于后面判断表单内容是否有效</span></span><br><span class="line">  GlobalKey&lt;FormState&gt; _formKey = GlobalKey();</span><br><span class="line">  <span class="comment">// 用于获取输入框的内容</span></span><br><span class="line">  TextEditingController _usernameController = TextEditingController();</span><br><span class="line">  TextEditingController _passwordController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 防止内存溢出，记得销毁..销毁..销毁</span></span><br><span class="line">    _usernameController.dispose();</span><br><span class="line">    _passwordController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _login() &#123;</span><br><span class="line">    <span class="comment">// 取消焦点</span></span><br><span class="line">    FocusScope.of(context).requestFocus(FocusNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断表单是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (_formKey.currentState.validate()) &#123;</span><br><span class="line">      <span class="comment">// 获取输入框内容</span></span><br><span class="line">      <span class="keyword">var</span> username = _usernameController.value.text;</span><br><span class="line">      <span class="keyword">var</span> password = _passwordController.value.text;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断登录条件</span></span><br><span class="line">      <span class="keyword">if</span> (username == <span class="string">'kuky'</span> &amp;&amp; password == <span class="string">'123456'</span>)</span><br><span class="line">        <span class="comment">// 引入的三方插件方法，`Flutter` 没有自带的 `Taost`</span></span><br><span class="line">        Fluttertoast.showToast(msg: <span class="string">'登录成功'</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        Fluttertoast.showToast(msg: <span class="string">'登录失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Form(</span><br><span class="line">        <span class="comment">// 将 key 设置给表单，用于判断表单是否有效</span></span><br><span class="line">        key: _formKey,</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>),</span><br><span class="line">              <span class="comment">// 表单输入框，参数同 TextField 基本类似</span></span><br><span class="line">              child: TextFormField(</span><br><span class="line">                controller: _usernameController,</span><br><span class="line">                style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>),</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                    icon: Icon(ThirdIcons.username, size: <span class="number">24.0</span>, color: Colors.white),</span><br><span class="line">                    labelText: <span class="string">'请输入用户名'</span>,</span><br><span class="line">                    labelStyle: TextStyle(color: Colors.white),</span><br><span class="line">                    helperStyle: TextStyle(color: Colors.white)),</span><br><span class="line">                <span class="comment">// 有效条件(为空不通过，返回提示语，通过返回 null)</span></span><br><span class="line">                validator: (value) =&gt; value.trim().isEmpty ? <span class="string">'用户名不能为空'</span> : <span class="keyword">null</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>),</span><br><span class="line">              child: TextFormField(</span><br><span class="line">                obscureText: <span class="keyword">true</span>,</span><br><span class="line">                controller: _passwordController,</span><br><span class="line">                style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>),</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                    icon: Icon(ThirdIcons.password, size: <span class="number">24.0</span>, color: Colors.white),</span><br><span class="line">                    labelText: <span class="string">'请输入密码'</span>,</span><br><span class="line">                    labelStyle: TextStyle(color: Colors.white),</span><br><span class="line">                    helperStyle: TextStyle(color: Colors.white)),</span><br><span class="line">                validator: (value) =&gt; value.trim().length &lt; <span class="number">6</span> ? <span class="string">'密码长度不能小于6位'</span> : <span class="keyword">null</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">              child: SizedBox(</span><br><span class="line">                <span class="comment">// 主要用于使 RaisedButton 和上层容器同宽</span></span><br><span class="line">                width: MediaQuery.of(context).size.width,</span><br><span class="line">                child: RaisedButton(</span><br><span class="line">                    color: Colors.pink,</span><br><span class="line">                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(<span class="number">4.0</span>))),</span><br><span class="line">                    onPressed: _login,</span><br><span class="line">                    child: Text(</span><br><span class="line">                      <span class="string">'登录'</span>,</span><br><span class="line">                      style: TextStyle(color: Colors.white, fontSize: <span class="number">20.0</span>),</span><br><span class="line">                    )),</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撸完界面后，可以试下登录效果，如果输入框的内容，和 TextFormField 的 validator的条件不符合，则会显示错误文字的提示</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164811.png" alt=""></p><p>如果按照条件用户名为 kuky 密码为 123456 (条件可以根据自己进行修改)则会显示登录成功的逻辑</p><p>以上代码查看 login_home_page.dart 文件</p><p>注册界面的逻辑和登录界面的逻辑几乎一样，算是第一次实战了，望小伙伴能够好好的写一遍</p><p>代码地址:</p><p><a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面提到基础部件的时候，忘了提输入内容处理部件，这里补上，然后顺带撸个实际的界面吧&lt;/p&gt;
&lt;h3 id=&quot;1、TextField&quot;&gt;&lt;a href=&quot;#1、TextField&quot; class=&quot;headerlink&quot; title=&quot;1、TextField&quot;&gt;&lt;/a&gt;1、TextField&lt;/h3&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; TextField(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.controller, &lt;span class=&quot;comment&quot;&gt;// 定义一个 `TextEditingController` 实例，用来获取输入框内容等操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.focusNode, &lt;span class=&quot;comment&quot;&gt;// 定义一个 `FocusNode` 实例，判断当前输入框是否获取到焦点等操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.decoration = &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; InputDecoration(), &lt;span class=&quot;comment&quot;&gt;// 输入框样式，包括提醒字样，hint 等等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TextInputType keyboardType, &lt;span class=&quot;comment&quot;&gt;// 输入文本类型，例如 数字，email 等等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textInputAction, &lt;span class=&quot;comment&quot;&gt;// 键盘确认按钮的事件类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textCapitalization = TextCapitalization.none,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.style, &lt;span class=&quot;comment&quot;&gt;// 文字样式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textAlign = TextAlign.start, &lt;span class=&quot;comment&quot;&gt;// 对齐方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textDirection, &lt;span class=&quot;comment&quot;&gt;// 文字方向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.autofocus = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 是否自动获取焦点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.obscureText = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 文字是否隐藏，多用于密码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.autocorrect = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxLines = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxLength, &lt;span class=&quot;comment&quot;&gt;// 最大长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxLengthEnforced = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 设置最大长度后，输入内容超出后是否强制不给输入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onChanged, &lt;span class=&quot;comment&quot;&gt;// 输入内容发生变化时候的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onEditingComplete, &lt;span class=&quot;comment&quot;&gt;// 输入完毕的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onSubmitted, &lt;span class=&quot;comment&quot;&gt;// 提交内容的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.inputFormatters, &lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.enabled, &lt;span class=&quot;comment&quot;&gt;// 是否可输入，false 不可输入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cursorWidth = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 游标宽度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cursorRadius, &lt;span class=&quot;comment&quot;&gt;// 游标半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cursorColor, &lt;span class=&quot;comment&quot;&gt;// 游标颜色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyboardAppearance, &lt;span class=&quot;comment&quot;&gt;// 该属性只在 iOS 设备有效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.scrollPadding = &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; EdgeInsets.all(&lt;span class=&quot;number&quot;&gt;20.0&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.enableInteractiveSelection,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onTap, &lt;span class=&quot;comment&quot;&gt;// 点击事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(四)常用布局</title>
    <link href="http://yoursite.com/posts/14587b6a.html"/>
    <id>http://yoursite.com/posts/14587b6a.html</id>
    <published>2019-04-25T08:23:54.000Z</published>
    <updated>2019-05-22T03:02:46.524Z</updated>
    
    <content type="html"><![CDATA[<p>上节填完了 Scaffold 留下的坑，这节继续填坑，之前留下关于 Layout 的坑，又是一堆部件袭来</p><h3 id="1、Container"><a href="#1、Container" class="headerlink" title="1、Container"></a>1、Container</h3><p>为了让我们的界面更容易被扩展，通常会在最外层包裹一层 Container，其构造函数也不是很难理解</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.alignment, <span class="comment">// child 的对齐方式，包括左对齐，居中，右对齐，左上对齐..等等</span></span><br><span class="line">    <span class="keyword">this</span>.padding, <span class="comment">// child 和 Container 的边距</span></span><br><span class="line">    Color color, <span class="comment">// Container 的背景色</span></span><br><span class="line">    Decoration decoration, <span class="comment">// 样式，可以设置背景图，圆角等属性</span></span><br><span class="line">    <span class="keyword">this</span>.foregroundDecoration, <span class="comment">// child 的样式</span></span><br><span class="line">    <span class="built_in">double</span> width, <span class="comment">// 宽度</span></span><br><span class="line">    <span class="built_in">double</span> height, <span class="comment">// 高度</span></span><br><span class="line">    BoxConstraints constraints, <span class="comment">// 默认使用 BoxConstraints.tightFor，可以手动传入</span></span><br><span class="line">    <span class="keyword">this</span>.margin, <span class="comment">// Container 同上层容器的边距</span></span><br><span class="line">    <span class="keyword">this</span>.transform, <span class="comment">// 是个 Matrix4 矩阵，(嗯..这个参数基本很少用，没怎么了解 /捂脸)</span></span><br><span class="line">    <span class="keyword">this</span>.child, <span class="comment">// 需要展示的内容</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> BoxConstraints.tightFor(&#123;</span><br><span class="line">    <span class="built_in">double</span> width,</span><br><span class="line">    <span class="built_in">double</span> height</span><br><span class="line">  &#125;): minWidth = width != <span class="keyword">null</span> ? width : <span class="number">0.0</span>,</span><br><span class="line">      maxWidth = width != <span class="keyword">null</span> ? width : <span class="built_in">double</span>.infinity,</span><br><span class="line">      minHeight = height != <span class="keyword">null</span> ? height : <span class="number">0.0</span>,</span><br><span class="line">      maxHeight = height != <span class="keyword">null</span> ? height : <span class="built_in">double</span>.infinity;</span><br></pre></td></tr></table></figure><a id="more"></a><p>让我们写个圆角矩形的外层，内层值显示白色文字</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        <span class="comment">// 宽，高度同上层容器相同</span></span><br><span class="line">        width: MediaQuery.of(context).size.width,</span><br><span class="line">        height: MediaQuery.of(context).size.height,</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">        <span class="comment">// Container 的样式</span></span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            borderRadius: BorderRadius.circular(<span class="number">20.0</span>),</span><br><span class="line">            color: Colors.red,</span><br><span class="line"><span class="comment">//            shape: BoxShape.circle, // 该属性不可同 borderRadius 一起使用</span></span><br><span class="line">            backgroundBlendMode: BlendMode.colorDodge, <span class="comment">// 背景图片和颜色混合模式</span></span><br><span class="line">            image: DecorationImage(image: AssetImage(<span class="string">'images/ali.jpg'</span>), fit: BoxFit.cover)),</span><br><span class="line">        child: Text(<span class="string">'Container Text'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line"><span class="comment">//        color: Theme.of(context).primaryColor, // 该属性不可和 decoration 一起使用</span></span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163312.png" alt=""></p><p>该部分代码查看 column_main.dart 文件</p><p>看到这，应该很多小伙伴注意到 margin 和 padding 属性用来和别的部件保持间距，那…那我就是不用 Container 呢(专门来挑事的…)，当然没问题，有个专门用来设置间距的部件 Padding，看名字就可以看出来作用了，修改下 child 部分代码，这边先提前用下接下来会讲的部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'Container Text'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Padding(</span><br><span class="line">                <span class="comment">// 需要传入一个间隔值，`Flutter` 提供了很多 EdgeInsets 来设置间隔，</span></span><br><span class="line">                <span class="comment">// 参数也很明确，可以一一尝试</span></span><br><span class="line">                padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">12.0</span>),</span><br><span class="line">                <span class="comment">// 传入需要间隔的部件</span></span><br><span class="line">                child: Text(<span class="string">'Container Text'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)))</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>效果就不展示了，接下来就要开始我的填坑之旅了….</p><h3 id="2、Flex，Row，Column"><a href="#2、Flex，Row，Column" class="headerlink" title="2、Flex，Row，Column"></a>2、Flex，Row，Column</h3><p>写 Android 的小伙伴应该比较常用 LinearLayout，在 Flutter 中用两个部件，Row Column来代替 Android 中的 LinearLayout，其中 Row 是横向布局，Column 是垂直布局，因为 Row 和 Column 都是继承于 Flex 部件，Flex 比他们多了 direction 属性用来指定方向，所以主要拿 Column 来讲解，Flex 、Row 用法相同</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Column(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 对齐方式，对于 `Column` start 为顶部，对于 `Row` 需要分语言，和语言同向</span></span><br><span class="line">    <span class="comment">// 3 种比较特殊的对齐方式，前端的小伙伴会了解，</span></span><br><span class="line">    <span class="comment">// spaceAround 两个部件之间的间隔是部件和上层容器间隔的两倍</span></span><br><span class="line">    <span class="comment">// spaceBetween 两侧部件同上层容器间隔为 0，部件之间的间隔相等</span></span><br><span class="line">    <span class="comment">// spaceEvenly 部件之间的间隔同两侧部件与上层容器间隔</span></span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, </span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max, <span class="comment">// 主轴的大小</span></span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, <span class="comment">// 副轴对齐方式</span></span><br><span class="line">    TextDirection textDirection, <span class="comment">// 文字方向，决定 start</span></span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down, <span class="comment">// 垂直方向</span></span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[], <span class="comment">// 内部子部件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Row 和 Column 都有主轴和副轴，如何区分呢，布局平行方向为主轴，垂直方向为副轴，我们把 Container 的 child 修改成 Column，然后把 Text 放到 Column 中，多放几个，然后自己设置 mainAxisAlignment 属性，查看布局的变化</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 省略相同代码</span></span><br><span class="line">child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'Container Text 1'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 2'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 3'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 4'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 5'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>最后的效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163435.png" alt=""></p><p>这边 Column 内部的子部件因为高度相同，如果不同还需要等分空间的话，就不可以通过设置 mainAxisAlignment 属性来实现了，这里介绍一个等分的部件 Expanded</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">int</span> flex = <span class="number">1</span>, <span class="comment">// 所占比例</span></span><br><span class="line">    <span class="meta">@required</span> Widget child, <span class="comment">// 子部件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>直接给 Text 外层加一个 Expanded 即可实现效果，当然可以按照需求来设置 flex 来修改比例值。</p><p>当然，在使用过程中也会遇到那么些坑，我们修改下代码，把 child 的代码修改成如下</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>))</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>然后运行下，你的屏幕就提示你 RIGHT OVERFLOWED BY XXX PIXELS 「<strong>,  ***</strong>」我猜你内心肯定这样的，冷静冷静</p><p>既然遇到问题，当然要解决，不然和产品去撕逼吗..？这边，我们把 Row 换成另一个布局 Wrap 然后再运行，Prefect，Wrap 和 Row 的参数基本类似</p><h3 id="3、Wrap"><a href="#3、Wrap" class="headerlink" title="3、Wrap"></a>3、Wrap</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Wrap(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.direction = Axis.horizontal,</span><br><span class="line">    <span class="keyword">this</span>.alignment = WrapAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.spacing = <span class="number">0.0</span>, <span class="comment">// 两个子部件之间的间隔，默认 0.0，如果值过大，可能导致原来同行的两个部件分行</span></span><br><span class="line">    <span class="keyword">this</span>.runAlignment = WrapAlignment.start, </span><br><span class="line">    <span class="keyword">this</span>.runSpacing = <span class="number">0.0</span>, <span class="comment">// 排布方向上 两个子部件的间隔</span></span><br><span class="line">    <span class="keyword">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当然，很多时候只有以上的布局是不行的，比如我们需要实现一个圆形头像，然后一段文字在其上面 ，例如下面的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163555.png" alt=""></p><p>接下来介绍一个堆叠的部件 Stack，源码比较简单，就不贴了，直接上效果代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Stack(</span><br><span class="line">        <span class="comment">// 内部子部件的对齐方式</span></span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 圆形头像，指定半径，指定背景图为头像即可</span></span><br><span class="line">          CircleAvatar(backgroundImage: AssetImage(<span class="string">'images/ali.jpg'</span>), radius: <span class="number">100.0</span>),</span><br><span class="line">          Text(</span><br><span class="line">            <span class="string">'Kuky'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">34.0</span>)),</span><br><span class="line">        ],</span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要第三个部件，底部距离圆形头像10px，那么只靠 alignment 是不可能实现了</p><p>所以，另外一个灰常流弊的部件就出来了 Positioned，其源码也比较简单，我还是不贴了吧~，还是直接上代码，直接修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Stack(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          CircleAvatar(backgroundImage: AssetImage(<span class="string">'images/ali.jpg'</span>), radius: <span class="number">100.0</span>),</span><br><span class="line">          Text(</span><br><span class="line">            <span class="string">'Kuky'</span>,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: <span class="number">34.0</span>),</span><br><span class="line">          ),</span><br><span class="line">          Positioned(child: Text(<span class="string">'另外一段文字'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">20.0</span>)), bottom: <span class="number">10.0</span>), <span class="comment">// left, right, top, bottom 分别表示和 stack 的间距</span></span><br><span class="line">        ],</span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163821.png" alt=""></p><p>很好，今天填了布局的这个大坑，而且讲的部件貌似还挺多的，虽然还是比较简单，剩下的就给小伙伴们慢慢消化今天的内容。</p><p>下节，除了有常用的部件外，我会尽量加上实战内容</p><p>代码地址:</p><p><a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节填完了 Scaffold 留下的坑，这节继续填坑，之前留下关于 Layout 的坑，又是一堆部件袭来&lt;/p&gt;
&lt;h3 id=&quot;1、Container&quot;&gt;&lt;a href=&quot;#1、Container&quot; class=&quot;headerlink&quot; title=&quot;1、Container&quot;&gt;&lt;/a&gt;1、Container&lt;/h3&gt;&lt;p&gt;为了让我们的界面更容易被扩展，通常会在最外层包裹一层 Container，其构造函数也不是很难理解&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Container(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.alignment, &lt;span class=&quot;comment&quot;&gt;// child 的对齐方式，包括左对齐，居中，右对齐，左上对齐..等等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.padding, &lt;span class=&quot;comment&quot;&gt;// child 和 Container 的边距&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Color color, &lt;span class=&quot;comment&quot;&gt;// Container 的背景色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Decoration decoration, &lt;span class=&quot;comment&quot;&gt;// 样式，可以设置背景图，圆角等属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.foregroundDecoration, &lt;span class=&quot;comment&quot;&gt;// child 的样式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; width, &lt;span class=&quot;comment&quot;&gt;// 宽度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; height, &lt;span class=&quot;comment&quot;&gt;// 高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BoxConstraints constraints, &lt;span class=&quot;comment&quot;&gt;// 默认使用 BoxConstraints.tightFor，可以手动传入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.margin, &lt;span class=&quot;comment&quot;&gt;// Container 同上层容器的边距&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.transform, &lt;span class=&quot;comment&quot;&gt;// 是个 Matrix4 矩阵，(嗯..这个参数基本很少用，没怎么了解 /捂脸)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.child, &lt;span class=&quot;comment&quot;&gt;// 需要展示的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; BoxConstraints.tightFor(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; width,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; height&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;): minWidth = width != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? width : &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      maxWidth = width != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? width : &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt;.infinity,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      minHeight = height != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? height : &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      maxHeight = height != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? height : &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt;.infinity;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(三)快速搭建界面</title>
    <link href="http://yoursite.com/posts/5c762cf7.html"/>
    <id>http://yoursite.com/posts/5c762cf7.html</id>
    <published>2019-04-25T08:00:21.000Z</published>
    <updated>2019-05-22T03:03:14.079Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲完 Flutter 中的一些基本部件，这篇就先填完上篇留下的没写的 AppBar 的坑，以及 Scaffold 其他参数的使用，在开始前，先补一张缩略版的脑图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425155737.png" alt=""></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160120.png" alt=""></p><h3 id="1、AppBar"><a href="#1、AppBar" class="headerlink" title="1、AppBar"></a>1、AppBar</h3><p>这一部分，我们只关注 Scaffold 中的 AppBar 剩下的还是埋坑【坑4】(<img src="https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_05.png?wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img">，居然已经埋了那么多坑了，坑虽多，代码还是要继续的)，因为稍后会用到 StatefulWidget 的属性，所以就直接先使用了，和 StatelessWidget 区别用法可以这么记 需要数据更新的界面用 StatefulWidget，当然也不是绝对的，就是之前留的【坑1】所说的状态管理</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _abs = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'S'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>, <span class="comment">// 标题内容居中</span></span><br><span class="line">        automaticallyImplyLeading: <span class="keyword">false</span>, <span class="comment">// 不使用默认</span></span><br><span class="line">        leading: Icon(Icons.menu, color: Colors.red, size: <span class="number">30.0</span>), <span class="comment">// 左侧按钮</span></span><br><span class="line">        flexibleSpace: Image.asset(<span class="string">'images/app_bar_hor.jpg'</span>, fit: BoxFit.cover), <span class="comment">// 背景</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)), <span class="comment">// 标题内容</span></span><br><span class="line">        <span class="comment">// 末尾的操作按钮列表</span></span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图，未点击右侧按钮如左侧所示，点击右侧按钮会弹出相应的 mune</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160332.png" alt=""></p><p>该部分代码查看 app_bar_main.dart 文件</p><p>看到效果图，相信很多小伙伴会吐槽，「**，上面那层半透明的啥玩意，那么丑」，接下来我们来解决这个问题，修改 void main 方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(DemoApp());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加如下代码，使状态栏透明</span></span><br><span class="line">  <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">    <span class="keyword">var</span> style = SystemUiOverlayStyle(statusBarColor: Colors.transparent);</span><br><span class="line">    SystemChrome.setSystemUIOverlayStyle(style);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭后重新运行，就可以看到那层丑丑的「半透明蒙层」没有了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160534.png" alt=""></p><p>接着介绍下 PopupMenuButton 这个部件，还是按照惯例看构造函数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// itemBuilder</span></span><br><span class="line"><span class="keyword">typedef</span> PopupMenuItemBuilder&lt;T&gt; = <span class="built_in">List</span>&lt;PopupMenuEntry&lt;T&gt;&gt; <span class="built_in">Function</span>(BuildContext context);</span><br><span class="line"><span class="comment">// onSelected</span></span><br><span class="line"><span class="keyword">typedef</span> PopupMenuItemSelected&lt;T&gt; = <span class="keyword">void</span> <span class="built_in">Function</span>(T value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PopupMenuButton(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.itemBuilder, <span class="comment">// 用于定义 menu 列表，需要传入 List&lt;PopupMenuEntry&lt;T&gt;&gt;</span></span><br><span class="line">    <span class="keyword">this</span>.initialValue, <span class="comment">// 初始值，是个泛型 T，也就是类型和你传入的值有关</span></span><br><span class="line">    <span class="keyword">this</span>.onSelected, <span class="comment">// 选中 item 的回调函数，返回 T value，例如选中 `s` 则返回 s</span></span><br><span class="line">    <span class="keyword">this</span>.onCanceled, <span class="comment">// 未选择任何 menu，直接点击外侧使 mune 列表关闭的回调</span></span><br><span class="line">    <span class="keyword">this</span>.tooltip, <span class="comment">// 长按时的提示</span></span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">8.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.padding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">    <span class="keyword">this</span>.child, <span class="comment">// 用于自定义按钮的内容</span></span><br><span class="line">    <span class="keyword">this</span>.icon, <span class="comment">// 按钮的图标</span></span><br><span class="line">    <span class="keyword">this</span>.offset = Offset.zero, <span class="comment">// 展示时候的便宜，Offset 需要传入 x,y 轴偏移量，会根据传入值平移</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="2、AppBar-bottom"><a href="#2、AppBar-bottom" class="headerlink" title="2、AppBar - bottom"></a>2、AppBar - bottom</h3><p>AppBar 还有个 bottom 属性没讲，因为 bottom 这个属性和图片背景一起使用会比较丑，所以就单独拎出来讲，我们直接在原来的代码上修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里需要用 with 引入 `SingleTickerProviderStateMixin` 这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _abs = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'S'</span>];</span><br><span class="line">  TabController _tabController; <span class="comment">// TabBar 必须传入这个参数</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 引入 `SingleTickerProviderStateMixin` 类主要是因为 _tabController 需要传入 vsync 参数</span></span><br><span class="line">    _tabController = TabController(length: _abs.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 需要在界面 dispose 之前把 _tabController dispose，防止内存泄漏</span></span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line">        automaticallyImplyLeading: <span class="keyword">false</span>,</span><br><span class="line">        leading: Icon(Icons.menu, color: Colors.red, size: <span class="number">30.0</span>),</span><br><span class="line"><span class="comment">//        flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover),</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              offset: Offset(<span class="number">50.0</span>, <span class="number">100.0</span>),</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">            labelColor: Colors.red, <span class="comment">// 选中时的颜色</span></span><br><span class="line">            unselectedLabelColor: Colors.white, <span class="comment">// 未选中颜色</span></span><br><span class="line">            controller: _tabController,</span><br><span class="line">            isScrollable: <span class="keyword">false</span>, <span class="comment">// 是否固定，当超过一定数量的 tab 时，如果一行排不下，可设置 true</span></span><br><span class="line">            indicatorColor: Colors.yellow, <span class="comment">// 导航的颜色</span></span><br><span class="line">            indicatorSize: TabBarIndicatorSize.tab, <span class="comment">// 导航样式，还有个选项是 TabBarIndicatorSize.label tab 时候，导航和 tab 同宽，label 时候，导航和 icon 同宽</span></span><br><span class="line">            indicatorWeight: <span class="number">5.0</span>, <span class="comment">// 导航高度</span></span><br><span class="line">            tabs: <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), <span class="comment">// 导航内容列表</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160654.png" alt=""></p><h3 id="3、PageView-TabBar"><a href="#3、PageView-TabBar" class="headerlink" title="3、PageView + TabBar"></a>3、PageView + TabBar</h3><p>那么如何通过 TabBar 切换界面呢，这边我们需要用到 PageView 这个部件，当然还有别的部件，例如 IndexStack 等，小伙伴可以自己尝试使用别的，这边通过 PageView 和 TabBar 进行关联，带动页面切换，PageViede 的属性参数相对比较简单，这边就不贴啦。最终的效果我们目前只展示一个文字即可，我们先定义一个通用的切换界面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabChangePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要传入的参数</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> content;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TabChangePage(this.content); 不推荐这样写构造方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 推荐用这样的构造方法，key 可以作为唯一值查找</span></span><br><span class="line">  TabChangePage(&#123;Key key, <span class="keyword">this</span>.content&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 仅展示传入的内容</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">        alignment: Alignment.center, child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义通用界面后，就可以作为 PageView 的子界面传入并展示</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _abs = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'S'</span>];</span><br><span class="line">  TabController _tabController;</span><br><span class="line">  <span class="comment">// 用于同 TabBar 进行联动</span></span><br><span class="line">  PageController _pageController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _tabController = TabController(length: _abs.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">    _pageController = PageController(initialPage: <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    _tabController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// 判断 TabBar 是否切换位置了，如果切换了，则修改 PageView 的显示</span></span><br><span class="line">      <span class="keyword">if</span> (_tabController.indexIsChanging) &#123;</span><br><span class="line">        <span class="comment">// PageView 的切换通过 controller 进行滚动</span></span><br><span class="line">        <span class="comment">// duration 表示切换滚动的时长，curve 表示滚动动画的样式，</span></span><br><span class="line">        <span class="comment">// flutter 已经在 Curves 中定义许多样式，可以自行切换查看效果</span></span><br><span class="line">        _pageController.animateToPage(_tabController.index,</span><br><span class="line">            duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>), curve: Curves.decelerate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line">        automaticallyImplyLeading: <span class="keyword">false</span>,</span><br><span class="line">        leading: Icon(Icons.menu, color: Colors.red, size: <span class="number">30.0</span>),</span><br><span class="line"><span class="comment">//        flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover),</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              offset: Offset(<span class="number">50.0</span>, <span class="number">100.0</span>),</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">            labelColor: Colors.red,</span><br><span class="line">            unselectedLabelColor: Colors.white,</span><br><span class="line">            controller: _tabController,</span><br><span class="line">            isScrollable: <span class="keyword">false</span>,</span><br><span class="line">            indicatorColor: Colors.yellow,</span><br><span class="line">            indicatorSize: TabBarIndicatorSize.tab,</span><br><span class="line">            indicatorWeight: <span class="number">5.0</span>,</span><br><span class="line">            tabs: <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 通过 body 来展示内容，body 可以传入任何 Widget，里面就是你需要展示的界面内容</span></span><br><span class="line">      <span class="comment">// 所以前面留下 Scaffold 中 body 部分的坑就解决了</span></span><br><span class="line">      body: PageView(</span><br><span class="line">        controller: _pageController,</span><br><span class="line">        children:</span><br><span class="line">            _abs.map((str) =&gt; TabChangePage(content: str)).toList(), <span class="comment">// 通过 Map 转换后再通过 toList 转换成列表，效果同 List.generate</span></span><br><span class="line">        onPageChanged: (position) &#123;</span><br><span class="line">          <span class="comment">// PageView 切换的监听，这边切换 PageView 的页面后，TabBar 也需要随之改变</span></span><br><span class="line">          <span class="comment">// 通过 tabController 来改变 TabBar 的显示位置</span></span><br><span class="line">          _tabController.index = position;</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果图就不贴了，可以发现滑动 PageView 或者点击切换 TabBar 的位置，界面显示的内容都会随之改变，同时，解决前面 Scaffold 留下 body 属性没讲的一个坑，就剩下 drawer 、 bottomNavigationBar 属性没讲了，在解决这两个坑之前，我们先处理下另一个问题</p><p>Scaffold 能够使我们快速去搭建一个界面，但是，并不是所有的界面都需要 AppBar 这个标题，那么我们就不会传入 appBar 的属性，我们注释 _HomePageState 中 Scaffold 的 appBar 传入值，把 body 传入的 PageView 修改成单个 TabChangePage ，然后把 TabChangePage 这个类做下修改，把 Container 的 aligment 属性也注释了，这样显示的内容就会显示在左上角</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _HomePageState</span></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(body: TabChangePage(content: <span class="string">'Content'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabChangePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> content;</span><br><span class="line">    </span><br><span class="line">  TabChangePage(&#123;Key key, <span class="keyword">this</span>.content&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行下，「**，文字怎么被状态栏给挡了…」<br>不要慌，静下心喝杯茶，眺望下远方，这里就需要用 SafeArea 来处理了，在 TabChangePage 的 Container 外层加一层 SafeArea</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SafeArea(</span><br><span class="line">        child:</span><br><span class="line">            Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>))));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后重新运行，一切正常，SafeArea 的用途可以看下源码的解释</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A widget that insets its child by sufficient padding to avoid intrusions by</span></span><br><span class="line"><span class="comment">/// the operating system.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// For example, this will indent the child by enough to avoid the status bar at</span></span><br><span class="line"><span class="comment">/// the top of the screen.</span></span><br></pre></td></tr></table></figure><p>翻译过来大概就是「给子部件和系统点击无效区域留有足够空间，比如状态栏和系统导航栏」，SafeArea 可以很好解决刘海屏覆盖页面内容的问题，那么到目前为止，AppBar 的一些坑就说的差不多了，就要解决剩下的坑了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425161326.png" alt=""></p><h3 id="4、Scaffold-Drawer"><a href="#4、Scaffold-Drawer" class="headerlink" title="4、Scaffold - Drawer"></a>4、Scaffold - Drawer</h3><p>drawer 同 endDrawer 属性是一样的，除了滑动的方向，Drawer 这个组件也相对比较简单，只要传入一个 child 即可，在展示之前，先对 appBar 做下处理，设置 leading 为系统默认，点击 leading 的时候 Drawer 就可以滑出来了，当然手动滑也可以</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">//        automaticallyImplyLeading: false,</span></span><br><span class="line"><span class="comment">//        leading: Icon(Icons.menu, color: Colors.red, size: 30.0),</span></span><br><span class="line"><span class="comment">//        flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover),</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              offset: Offset(<span class="number">50.0</span>, <span class="number">100.0</span>),</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">            labelColor: Colors.red,</span><br><span class="line">            unselectedLabelColor: Colors.white,</span><br><span class="line">            controller: _tabController,</span><br><span class="line">            isScrollable: <span class="keyword">false</span>,</span><br><span class="line">            indicatorColor: Colors.yellow,</span><br><span class="line">            indicatorSize: TabBarIndicatorSize.tab,</span><br><span class="line">            indicatorWeight: <span class="number">5.0</span>,</span><br><span class="line">            tabs: <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// body ....</span></span><br><span class="line">      drawer: Drawer(</span><br><span class="line">        <span class="comment">// 记得要先添加 `SafeArea` 防止视图顶到状态栏下面</span></span><br><span class="line">        child: SafeArea(</span><br><span class="line">            child: Container(</span><br><span class="line">          child: Text(<span class="string">'Drawer'</span>, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">        )),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    return Scaffold(body: TabChangePage(content: 'Content'));</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终的效果图也不贴了，当手势从左侧滑出或者点击 leading 图标，抽屉就出来了</p><h3 id="5、AppBar-bottomNavigationBar"><a href="#5、AppBar-bottomNavigationBar" class="headerlink" title="5、AppBar - bottomNavigationBar"></a>5、AppBar - bottomNavigationBar</h3><p>bottomNavigarionBar 可以传入一个 BottomNavigationBar 实例，BottomNavigationBar 需要传入 BottomNavigationBarItem 列表作为 items ，但是这边为了实现一个 bottomNavigationBar 和 floatingActionButton 一个特殊的组合效果，我们不使用 BottomNavigationBar，换做 BottomAppBar，直接上代码吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">/// 一样的代码省略....</span></span><br><span class="line">      bottomNavigationBar: BottomAppBar(</span><br><span class="line">        shape: CircularNotchedRectangle(),</span><br><span class="line">        child: Row(</span><br><span class="line">          mainAxisSize: MainAxisSize.max,</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            IconButton(icon: Icon(Icons.android, size: <span class="number">30.0</span>, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;),</span><br><span class="line">            IconButton(icon: Icon(Icons.people, size: <span class="number">30.0</span>, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton:</span><br><span class="line">          FloatingActionButton(onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'Add'</span>), child: Icon(Icons.add, color: Colors.white)),</span><br><span class="line">      <span class="comment">// FAB 的位置，一共有 7 中位置可以选择，centerDocked, endDocked, centerFloat, endFloat, endTop, startTop, miniStartTop，这边选择悬浮在 dock</span></span><br><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>最终的效果图</p><p><img src="/Users/zm/Library/Application Support/typora-user-images/image-20190425161447777.png" alt="image-20190425161447777"></p><p>既然提到了 StatefulWidget，顺带提下两种比较简单的部件，也算是基础部件吧。CheckBox、CheckboxListTile，Switch、SwitchListTile 因为比较简单，就直接上代码了，里面都有完整的注释</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckSwitchDemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CheckSwitchDemoPageState createState() =&gt; _CheckSwitchDemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CheckSwitchDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CheckSwitchDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _isChecked = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">var</span> _isTitleChecked = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">var</span> _isOn = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">var</span> _isTitleOn = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Check Switch Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(children: &lt;Widget&gt;[</span><br><span class="line">        Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Checkbox(</span><br><span class="line">              <span class="comment">// 是否开启三态</span></span><br><span class="line">              tristate: <span class="keyword">true</span>,</span><br><span class="line">              <span class="comment">// 控制当前 checkbox 的开启状态</span></span><br><span class="line">              value: _isChecked,</span><br><span class="line">              <span class="comment">// 不设置该方法，处于不可用状态</span></span><br><span class="line">              onChanged: (checked) &#123;</span><br><span class="line">                <span class="comment">// 管理状态值</span></span><br><span class="line">                setState(() =&gt; _isChecked = checked);</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="comment">// 选中时的颜色</span></span><br><span class="line">              activeColor: Colors.pink,</span><br><span class="line">              <span class="comment">// 这个值有 padded 和 shrinkWrap 两个值，</span></span><br><span class="line">              <span class="comment">// padded 时候所占有的空间比 shrinkWrap 大，别的原谅我没看出啥</span></span><br><span class="line">              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,</span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 点击无响应</span></span><br><span class="line">            Checkbox(value: _isChecked, onChanged: <span class="keyword">null</span>, tristate: <span class="keyword">true</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Switch(</span><br><span class="line">                <span class="comment">// 开启时候，那个条的颜色</span></span><br><span class="line">                activeTrackColor: Colors.yellow,</span><br><span class="line">                <span class="comment">// 关闭时候，那个条的颜色</span></span><br><span class="line">                inactiveTrackColor: Colors.yellow[<span class="number">200</span>],</span><br><span class="line">                <span class="comment">// 设置指示器的图片，当然也有 color 可以设置</span></span><br><span class="line">                activeThumbImage: AssetImage(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">                inactiveThumbImage: AssetImage(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">                <span class="comment">// 开始时候的颜色，貌似会被 activeTrackColor 顶掉</span></span><br><span class="line">                activeColor: Colors.pink,</span><br><span class="line">                materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,</span><br><span class="line">                value: _isOn,</span><br><span class="line">                onChanged: (onState) &#123;</span><br><span class="line">                  setState(() =&gt; _isOn = onState);</span><br><span class="line">                &#125;),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 点击无响应</span></span><br><span class="line">            Switch(value: _isOn, onChanged: <span class="keyword">null</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        CheckboxListTile(</span><br><span class="line">          <span class="comment">// 描述选项</span></span><br><span class="line">          title: Text(<span class="string">'Make this item checked'</span>),</span><br><span class="line">          <span class="comment">// 二级描述</span></span><br><span class="line">          subtitle: Text(<span class="string">'description...description...\ndescription...description...'</span>),</span><br><span class="line">          <span class="comment">// 和 checkbox 对立边的部件，例如 checkbox 在头部，则 secondary 在尾部</span></span><br><span class="line">          secondary: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">30.0</span>, height: <span class="number">30.0</span>),</span><br><span class="line">          value: _isTitleChecked,</span><br><span class="line">          <span class="comment">// title 和 subtitle 是否为垂直密集列表中一员，最明显就是部件会变小</span></span><br><span class="line">          dense: <span class="keyword">true</span>,</span><br><span class="line">          <span class="comment">// 是否需要使用 3 行的高度，该值为 true 时候，subtitle 不可为空</span></span><br><span class="line">          isThreeLine: <span class="keyword">true</span>,</span><br><span class="line">          <span class="comment">// 控制 checkbox 选择框是在前面还是后面</span></span><br><span class="line">          controlAffinity: ListTileControlAffinity.leading,</span><br><span class="line">          <span class="comment">// 是否将主题色应用到文字或者图标</span></span><br><span class="line">          selected: <span class="keyword">true</span>,</span><br><span class="line">          onChanged: (checked) &#123;</span><br><span class="line">            setState(() =&gt; _isTitleChecked = checked);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        SwitchListTile(</span><br><span class="line">            title: Text(<span class="string">'Turn On this item'</span>),</span><br><span class="line">            subtitle: Text(<span class="string">'description...description...\ndescription...description...'</span>),</span><br><span class="line">            secondary: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">30.0</span>, height: <span class="number">30.0</span>),</span><br><span class="line">            isThreeLine: <span class="keyword">true</span>,</span><br><span class="line">            value: _isTitleOn,</span><br><span class="line">            selected: <span class="keyword">true</span>,</span><br><span class="line">            onChanged: (onState) &#123;</span><br><span class="line">              setState(() =&gt; _isTitleOn = onState);</span><br><span class="line">            &#125;)</span><br><span class="line">      ]),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/1.gif" alt=""></p><p><em>该部分代码查看 checkbox_swicth_main.dart 文件</em></p><p>终于这节把 <code>Scaffold</code> 留下的坑都填完了，然后又讲了两种基础部件，下节要填留下的别的坑了，目测还留了 2 个大坑，那就等以后继续解决吧~</p><p>最后代码的地址还是要的：</p><ol><li>文章中涉及的代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_arts_demos_app" target="_blank" rel="noopener">demos</a></li><li>基于郭神 <code>cool weather</code> 接口的一个项目，实现 <code>BLoC</code> 模式，实现状态管理：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather" target="_blank" rel="noopener">flutter_weather</a></li><li>一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_shop" target="_blank" rel="noopener">flutter_shop</a></li></ol><p>作者：Kuky_xs</p><p>链接：<a href="https://www.jianshu.com/p/9119a1c1a123" target="_blank" rel="noopener">https://www.jianshu.com/p/9119a1c1a123</a></p><p>来源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇讲完 Flutter 中的一些基本部件，这篇就先填完上篇留下的没写的 AppBar 的坑，以及 Scaffold 其他参数的使用，在开始前，先补一张缩略版的脑图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425155737.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(二)基础部件</title>
    <link href="http://yoursite.com/posts/88b946ec.html"/>
    <id>http://yoursite.com/posts/88b946ec.html</id>
    <published>2019-04-24T09:17:10.000Z</published>
    <updated>2019-05-22T03:02:25.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要包括 MaterialApp、Scaffold、Text、Image、Icon、Button 以及 AppBar 部分内容，准备出发~</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162620.png" alt=""></p><p>​                            看完这篇文章你就在知道怎么写以上效果了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162652.png" alt=""></p><a id="more"></a><h3 id="1、Flutter-runApp"><a href="#1、Flutter-runApp" class="headerlink" title="1、Flutter runApp"></a>1、Flutter runApp</h3><p>新建 flutter 项目后，可以看到 lib 下的 main.dart 中 void main() =&gt; runApp(MyApp());这句就是程序的入口了。这里可以简单看下源码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///....</span></span><br><span class="line"><span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">  <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">    WidgetsFlutterBinding();</span><br><span class="line">  <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///....</span></span><br><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">    container: renderView,</span><br><span class="line">    debugShortDescription: <span class="string">'[root]'</span>,</span><br><span class="line">    child: rootWidget</span><br><span class="line">  ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会创建一个 WidgetsBinding 单例对象，然后把传入的 App 添加到 rootWidget中，scheduleWarmUpFrame 方法比较长，这边看下对该方法的注释第一句就能了解方法的主要功能了</p><p><code>Schedule a frame to run as soon as possible</code></p><p>「安排框架尽快运行起来」(原谅我这渣英语，只能看懂不会翻译..大概就是「快速启动框架」的意思吧)</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162708.png" alt=""></p><h3 id="2、Flutter-App"><a href="#2、Flutter-App" class="headerlink" title="2、Flutter App"></a>2、Flutter App</h3><p>接着看下 MyApp 这个类，继承自 StatelessWidget 并在 build 方法返回一个 MaterialApp 实例，(偷偷讲下，其实这边还可以返回 CupertinoApp，这是一个 iOS 风格的 widget，基本上你看到部件带 「Cupertino」的都是 iOS 风格的 widget，这里先不讲 iOS 风格的部件，目前 flutter 对 Cupertino 系列的 widget 支持不是很好，包括部件的广度，多语言的支持等等方面都不是很友好，所以我们还是继续看 MD 风格的 Android 部件吧~)，这里先看下 MaterialApp 的构造函数，介绍一些常用的参数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialApp(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">    <span class="keyword">this</span>.home, <span class="comment">// 主界面的内容 widget</span></span><br><span class="line">    <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;, <span class="comment">// 带 router 和路由跳转有关</span></span><br><span class="line">    <span class="keyword">this</span>.initialRoute,</span><br><span class="line">    <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">    <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">    <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[], </span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">''</span>, <span class="comment">// *类似标题</span></span><br><span class="line">    <span class="keyword">this</span>.onGenerateTitle, <span class="comment">// 主要用于多语言情况下，需要根据当前语言替换 title，需要使用该值</span></span><br><span class="line">    <span class="keyword">this</span>.color, <span class="comment">// 主题色，如果该值未设置，取 theme.primaryColor,未设置 theme 则取蓝色</span></span><br><span class="line">    <span class="keyword">this</span>.theme, <span class="comment">// App 的主题风格，包括主题色，按钮默认颜色等等</span></span><br><span class="line">    <span class="keyword">this</span>.locale, <span class="comment">// 带 locale 的和多语言适配相关</span></span><br><span class="line">    <span class="keyword">this</span>.localizationsDelegates,</span><br><span class="line">    <span class="keyword">this</span>.localeListResolutionCallback,</span><br><span class="line">    <span class="keyword">this</span>.localeResolutionCallback,</span><br><span class="line">    <span class="keyword">this</span>.supportedLocales = <span class="keyword">const</span> &lt;Locale&gt;[Locale(<span class="string">'en'</span>, <span class="string">'US'</span>)],</span><br><span class="line">    <span class="keyword">this</span>.debugShowMaterialGrid = <span class="keyword">false</span>, </span><br><span class="line">    <span class="keyword">this</span>.showPerformanceOverlay = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.checkerboardRasterCacheImages = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.checkerboardOffscreenLayers = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.showSemanticsDebugger = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.debugShowCheckedModeBanner = <span class="keyword">true</span>, <span class="comment">// debug 模式下，是否显示 DEBUG 标示横幅</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>MaterialApp 继承自 StatefulWidget，它和 MyApp 所继承的类 StatelessWidget，就是日常开发中，自定义部件通常继承的抽象类了。</p><ul><li>StatelessWidget 是状态不可变部件，通过其构建的部件一般用来展示固定内容，例如需要展示固定的功能按钮列表，不需要根据不同界面状态进行修改其展示内容</li><li>StatefulWidget 是可改变状态的部件，比如我们需要通过网络或者数据库获取数据，然后修改部件锁展示的数据内容，则需要通过 StatefulWidget 来构建。当然，不是说 StatelessWidget 不能实现修改界面数据的功能，这就需要涉及到 状态管理 的概念了，后面有机会再讲，这边先埋坑【坑1】</li></ul><h3 id="3、Flutter-Scaffold"><a href="#3、Flutter-Scaffold" class="headerlink" title="3、Flutter Scaffold"></a>3、Flutter Scaffold</h3><p>进入 App 后就需要构建界面了，Flutter 提供了 Scaffold 来快速构建一个 MaterialDesign 风格的界面，还是先看下 Scaffold 的构造函数吧，了解几个比较常用的部分。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scaffold(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.appBar, <span class="comment">// 界面顶部的那条栏，这边需要返回一个 AppBar 实例</span></span><br><span class="line">    <span class="keyword">this</span>.body, <span class="comment">// 界面的内容部分</span></span><br><span class="line">    <span class="keyword">this</span>.floatingActionButton, <span class="comment">// 悬浮部分，可以通过 floatingActionButtonLocation 设置位置</span></span><br><span class="line">    <span class="keyword">this</span>.floatingActionButtonLocation,</span><br><span class="line">    <span class="keyword">this</span>.floatingActionButtonAnimator,</span><br><span class="line">    <span class="keyword">this</span>.persistentFooterButtons,</span><br><span class="line">    <span class="keyword">this</span>.drawer, <span class="comment">// 侧滑抽屉部分，从左侧滑出(应该和语言有关，和文字方向同向)</span></span><br><span class="line">    <span class="keyword">this</span>.endDrawer, <span class="comment">// 侧滑抽屉部分，从右侧滑出</span></span><br><span class="line">    <span class="keyword">this</span>.bottomNavigationBar, <span class="comment">// 底部导航栏，就是通常看到的底部 TAB 切换部件</span></span><br><span class="line">    <span class="keyword">this</span>.bottomSheet, <span class="comment">// 展示从底部弹出的，起到提示作用的，通过 showModalBottomSheet 展示</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor, <span class="comment">// 界面的背景色</span></span><br><span class="line">    <span class="keyword">this</span>.resizeToAvoidBottomPadding = <span class="keyword">true</span>, <span class="comment">// 避免 body 被底部弹出部件填充，例如输入法键盘</span></span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>, <span class="comment">// 当前的 Scaffold 是否需要被展示在屏幕最上层</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>来张图吧，简洁明了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162756.png" alt=""></p><p>了解完 Scaffold 的整体构造后，我们从上到下，通过构造函数来了解下各个 Widget的使用方法</p><h3 id="4、AppBar"><a href="#4、AppBar" class="headerlink" title="4、AppBar"></a>4、AppBar</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.leading, <span class="comment">// 用于设置 AppBar 前置的按钮，例如设置返回我们需要的返回按钮等</span></span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>, <span class="comment">// 是否使用系统默认生成的按钮，如果替换 leading 的默认按钮，最好将该属性设置成 false</span></span><br><span class="line">    <span class="keyword">this</span>.title, <span class="comment">// AppBar 所需要展示的组件，传入一个 Widget 实例，通常使用 Text 展示一个标题</span></span><br><span class="line">    <span class="keyword">this</span>.actions, <span class="comment">// AppBar 末尾悬浮的一些操作组件，例如常见的会在末尾设置一个「...」按钮，点击弹出一个 menue 提供给用户操作选择</span></span><br><span class="line">    <span class="keyword">this</span>.flexibleSpace, <span class="comment">// AppBar 的背景，可以设置颜色，背景图等等 </span></span><br><span class="line">    <span class="keyword">this</span>.bottom, <span class="comment">// bottom 用于展示顶部导航 TAB</span></span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">4.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor, <span class="comment">// AppBar 的背景色，如果只需要修改颜色，可以不通过 flexibleSpace 修改</span></span><br><span class="line">    <span class="keyword">this</span>.brightness,</span><br><span class="line">    <span class="keyword">this</span>.iconTheme, <span class="comment">// 按钮的默认样式</span></span><br><span class="line">    <span class="keyword">this</span>.textTheme, <span class="comment">// 文字的默认样式</span></span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.centerTitle, <span class="comment">// 是否将展示的 title 居中</span></span><br><span class="line">    <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing, <span class="comment">// AppBar title 两侧的空白间隔</span></span><br><span class="line">    <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在展示 AppBar 的 demo 之前，我们先学习几个基本的组件 Text、Image、Icon、Button 分布用于展示文字，图片，图标，按钮</p><h3 id="5、Text"><a href="#5、Text" class="headerlink" title="5、Text"></a>5、Text</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text(<span class="keyword">this</span>.data, &#123; <span class="comment">// Text 需要展示的文字</span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.style, <span class="comment">// 文字的样式，包括颜色，大小，间距等等属性，这边就不继续展示 TextStyle 构造函数了，不然我怕大家都不想继续看了，稍后通过例子来说明</span></span><br><span class="line">    <span class="keyword">this</span>.textAlign, <span class="comment">// 文字的对齐方式，包括左对齐，右对齐，居中等，详见 TextAlign 类</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection, <span class="comment">// 文字方向，ltr(left to right) 或者 rtl(right to left)</span></span><br><span class="line">    <span class="keyword">this</span>.locale, </span><br><span class="line">    <span class="keyword">this</span>.softWrap, <span class="comment">// 当文字一行显示不完是否换行</span></span><br><span class="line">    <span class="keyword">this</span>.overflow, <span class="comment">// 如果超出限制的行数，以哪种方式省略未展示的内容</span></span><br><span class="line">    <span class="keyword">this</span>.textScaleFactor, <span class="comment">// 文字缩放比例</span></span><br><span class="line">    <span class="keyword">this</span>.maxLines, <span class="comment">// 最多展示的行数</span></span><br><span class="line">    <span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>说了那么多，相信很多小伙伴都要急着撸代码了吧，接着来展示一些 Text 的示例，接下来的例子都会直接替换 HomePage 内的展示内容，其余都是相同的，接下来请关注 Text 别的部件先忽略，后面会介绍，这边先埋坑【坑2】</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(DemoApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      theme: ThemeData(primarySwatch: Colors.lightBlue),</span><br><span class="line">      home: HomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(),</span><br><span class="line">        body: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">10.0</span>),</span><br><span class="line">          child: Center(</span><br><span class="line">              child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(<span class="string">'绿色背景黑色文字展示'</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                      color: Colors.black, <span class="comment">// 设置文字颜色，不可和 foreground 同时设置</span></span><br><span class="line">                      fontSize: <span class="number">24.0</span>, <span class="comment">// 字体大小</span></span><br><span class="line">                      letterSpacing: <span class="number">2.0</span>, <span class="comment">// 每个字符之间的间隔</span></span><br><span class="line">                      background: Paint()..color = Colors.green)), <span class="comment">// 背景色</span></span><br><span class="line">              Text(<span class="string">'这是一个带红色下划线的文字展示'</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                      color: Colors.black,</span><br><span class="line">                      fontSize: <span class="number">24.0</span>,</span><br><span class="line">                      <span class="comment">// 文字装饰线，除了 underline 还有 overline, lineThrough，</span></span><br><span class="line">                      <span class="comment">// 不同的样式小伙伴可以通过自己修改代码来查看</span></span><br><span class="line">                      decoration: TextDecoration.underline,</span><br><span class="line">                      <span class="comment">// 文字装饰线的类型，除了 solid 还有 double,dotted,dashed,wavy 可选</span></span><br><span class="line">                      decorationStyle: TextDecorationStyle.solid,</span><br><span class="line">                      <span class="comment">// 装饰线的颜色</span></span><br><span class="line">                      decorationColor: Colors.red))</span><br><span class="line">            ],</span><br><span class="line">          )),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看源码 text_main.dart 文件</p><p>最后的展示效果如下图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162845.png" alt=""></p><h3 id="6、Image"><a href="#6、Image" class="headerlink" title="6、Image"></a>6、Image</h3><p>按照惯例，我们还是先看下 Image 的构造函数吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Image(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 一个 ImageProvider 实例，但是 ImageProvider 是一个抽象类，Flutter 已经给我们提供如下</span></span><br><span class="line">    <span class="comment">// AssetImage，NetworkImage，FileImage，MemoryImage 这四种图片加载器，为了方便调用</span></span><br><span class="line">    <span class="comment">// 我们可以直接通过 Image.asset, Image.network, Image.file, Image.memory 简化，</span></span><br><span class="line">    <span class="comment">// 通过方法名，可以看出分别从 asset 文件，网络，文件，内存中加载图片</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.image, </span><br><span class="line">    <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">    <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.width, <span class="comment">// 图片宽度</span></span><br><span class="line">    <span class="keyword">this</span>.height, <span class="comment">// 图片高度</span></span><br><span class="line">    <span class="keyword">this</span>.color, <span class="comment">// 图片背景色</span></span><br><span class="line">    <span class="keyword">this</span>.colorBlendMode, <span class="comment">// color 和图片的混合模式(这个值比较多，可以一个个尝试)</span></span><br><span class="line">    <span class="keyword">this</span>.fit, <span class="comment">// 图片填充方式 fill, cover, contain, fillWidth, fillHeight, scaleDown, none</span></span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center, <span class="comment">// 对齐方式</span></span><br><span class="line">    <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat, <span class="comment">// 若未填充满空间，重复展示的方式</span></span><br><span class="line">    <span class="keyword">this</span>.centerSlice,</span><br><span class="line">    <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>好了好了，我知道你们又想自己写代码尝试下了，在这之前，需要你先准备一张本地图片，然后在项目的根目录，也就是 lib 文件夹同层，创建一个新的文件夹，命名为 images，把你准备好的图片放到这个目录下。放好之后打开 pubspec.yaml 把图片资源文件注册下</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># The following section <span class="keyword">is</span> specific to Flutter.</span><br><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font <span class="keyword">is</span></span><br><span class="line">  # included <span class="keyword">with</span> your application, so that you can use the icons <span class="keyword">in</span></span><br><span class="line">  # the material Icons <span class="class"><span class="keyword">class</span>.</span></span><br><span class="line"><span class="class">  <span class="title">uses</span>-<span class="title">material</span>-<span class="title">design</span>: <span class="title">true</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  # 这边注册资源文件，以后有图片文件也可以只注册 <span class="title">images</span> 文件夹，会自动读取内部的文件</span></span><br><span class="line"><span class="class">  <span class="title">assets</span>:</span></span><br><span class="line"><span class="class">    - <span class="title">images</span>/<span class="title">ali</span>.<span class="title">jpg</span></span></span><br></pre></td></tr></table></figure><p>注册完成后，就可以继续愉快的撸代码了~</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _assetAli = <span class="string">'images/ali.jpg'</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _picUrl =</span><br><span class="line">      <span class="string">'https://timg05.bdimg.com/timg?wapbaike&amp;quality=60&amp;size=b1440_952&amp;cut_x=143&amp;cut_y=0&amp;cut_w=1633&amp;'</span></span><br><span class="line">      <span class="string">'cut_h=1080&amp;sec=1349839550&amp;di=cbbc175a45ccec5482ce2cff09a3ae34&amp;'</span></span><br><span class="line">      <span class="string">'src=http://imgsrc.baidu.com/baike/pic/item/4afbfbedab64034f104872baa7c379310b551d80.jpg'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(),</span><br><span class="line">        body: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">10.0</span>),</span><br><span class="line">          child: Center(</span><br><span class="line">              child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              <span class="comment">// 这种展示图片方式和下一种会有相同的效果</span></span><br><span class="line">              Image(image: AssetImage(_assetAli), width: <span class="number">80.0</span>, height: <span class="number">80.0</span>),</span><br><span class="line">              <span class="comment">// 接下来加载图片都会使用这些比较方便的方法</span></span><br><span class="line">              Image.asset(_assetAli, width: <span class="number">80.0</span>, height: <span class="number">80.0</span>),</span><br><span class="line">              <span class="comment">// 加载一张网络图片</span></span><br><span class="line">              Image.network(_picUrl,</span><br><span class="line">                  height: <span class="number">80.0</span>,</span><br><span class="line">                  <span class="comment">// 横向重复</span></span><br><span class="line">                  repeat: ImageRepeat.repeatX,</span><br><span class="line">                  <span class="comment">// MediaQuery.of(context).size 获取到的为上层容器的宽高</span></span><br><span class="line">                  width: MediaQuery.of(context).size.width),</span><br><span class="line">              <span class="comment">// 通过设置混合模式，可以看到图片展示的样式已经修改</span></span><br><span class="line">              Image.asset(_assetAli,</span><br><span class="line">                  width: <span class="number">80.0</span>, height: <span class="number">80.0</span>, color: Colors.green, colorBlendMode: BlendMode.colorDodge),</span><br><span class="line">              <span class="comment">// 会优先加载指定的 asset 图片，然后等网络图片读取成功后加载网络图片，会通过渐隐渐现方式展现</span></span><br><span class="line">              <span class="comment">// cover 方式按照较小的边布满，较大的给切割</span></span><br><span class="line">              <span class="comment">// contain 会按照最大的边布满，较小的会被留白</span></span><br><span class="line">              <span class="comment">// fill 会把较大的一边压缩</span></span><br><span class="line">              <span class="comment">// fitHeight, fitWidth 分别按照长宽来布满</span></span><br><span class="line">              FadeInImage.assetNetwork(</span><br><span class="line">                  placeholder: _assetAli, image: _picUrl, width: <span class="number">120.0</span>, height: <span class="number">120.0</span>, fit: BoxFit.cover),</span><br><span class="line">              <span class="comment">// Icon 相对属性少了很多，需要传入一个 IconData 实例，flutter 提供了很多图标，</span></span><br><span class="line">              <span class="comment">// 但是实际情况我们需要加入我们自己的图标，这边再埋坑【坑3】</span></span><br><span class="line">              <span class="comment">// size 为图标显示的大小，color 为图标的颜色，这边通过 Theme 获取主题色调</span></span><br><span class="line">              Icon(Icons.android, size: <span class="number">40.0</span>, color: Theme.of(context).primaryColorDark)</span><br><span class="line">            ],</span><br><span class="line">          )),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看源码 image_main.dart 文件</p><p>最后的效果如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162908.png" alt=""></p><h3 id="7、Button"><a href="#7、Button" class="headerlink" title="7、Button"></a>7、Button</h3><p>Flutter 提供了各种类型的 Button 几乎是大同小异的，这边就抽取一些比较常用的展示下效果，常用的主要有 RaisedButton 、FlatButton、IconButton、OutlineButton、MaterialButton、FloatActionButton、FloatingActionButton.extended</p><p>Button 都有一个 onPress 参数，是 VoidCallback 类型的参数，通过查看源码可以知道 VoidCallback 是无参无返回值的一种类型参数。如果该参数传入的值为 null 那么这个按钮的就不可点击状态，无点击效果，等会可以在例子中查看。还有就是 child 参数，这里就是传入你需要展示的内容，比如 Text、Icon 等等。别的参数基本可以通过参数名了解，这边不扩展了(再看源码我怕你们都不想继续看下去了…)</p><p><code>Talk is cheap, show me the code</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">10.0</span>),</span><br><span class="line">        child: Center(</span><br><span class="line">            child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'This is a Rased Button can be clicked'</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">'Raised Enable'</span>),</span><br><span class="line">            ),</span><br><span class="line">            RaisedButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Raised Disable'</span>)),</span><br><span class="line">            FlatButton(</span><br><span class="line">              onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'This is a Flat Button can be clicker'</span>),</span><br><span class="line">              child: Text(<span class="string">'Flat Enable'</span>),</span><br><span class="line">            ),</span><br><span class="line">            FlatButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Flat Disable'</span>)),</span><br><span class="line">            IconButton(icon: Icon(Icons.android), onPressed: () &#123;&#125;),</span><br><span class="line">            IconButton(icon: Icon(Icons.android), onPressed: <span class="keyword">null</span>),</span><br><span class="line">            MaterialButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Material Enable'</span>)),</span><br><span class="line">            MaterialButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Material Disable'</span>)),</span><br><span class="line">            OutlineButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Outline Enable'</span>)),</span><br><span class="line">            OutlineButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Outline Enable'</span>)),</span><br><span class="line">          ],</span><br><span class="line">        )),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton:</span><br><span class="line">          FloatingActionButton.extended(onPressed: () &#123;&#125;, icon: Icon(Icons.android), label: Text(<span class="string">'Android'</span>)),</span><br><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看源码 button_main.dart 部分</p><p>最终的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163010.png" alt=""></p><p>这篇终于到末尾了，最后留了 3 个坑等以后解决</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163039.png" alt=""></p><p>文章 demo 的地址：<a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p><p>一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：<a href="https://github.com/kukyxs/flutter_shop" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_shop</a></p><p>如果对你有帮助的话，记得给个 Star，先谢过，你的认可就是支持我继续写下去的动力~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要包括 MaterialApp、Scaffold、Text、Image、Icon、Button 以及 AppBar 部分内容，准备出发~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162620.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                            看完这篇文章你就在知道怎么写以上效果了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162652.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(一)Dart</title>
    <link href="http://yoursite.com/posts/6114f592.html"/>
    <id>http://yoursite.com/posts/6114f592.html</id>
    <published>2019-04-24T08:22:52.000Z</published>
    <updated>2019-05-22T03:02:05.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近 Flutter 真心火爆到不要不要的，随大流，学一波，在这之前，对于语言的语法还是需要有些必要的了解的，<strong>Dart</strong> 这门语言，说实话对于会 Java 这类面向对象的语言的小伙伴们来说，真的灰常灰常简单，这边我总结了一些 Dart 和 Java 的一些语法差异，当然，只是部分，但是，按照我目前的学习进度来说，了解了这些对于写 Flutter 项目绝对够了。小伙伴也可以自己查看，我这边提供一个自己学习的网址 <strong>Dart</strong> 快速入门：<a href="http://dart.goodev.org/guides/language" target="_blank" rel="noopener">http://dart.goodev.org/guides/language</a></p><p>温馨提示：本篇文章没有图，没有图，没有图，可能会造成部分不适，请注意，请注意，请注意，系好安全带，我们要「开车了」……</p><a id="more"></a><h3 id="1、Variables"><a href="#1、Variables" class="headerlink" title="1、Variables"></a>1、Variables</h3><p><strong>Dart</strong> 变量类型可以通过具体的赋值进行推导，例如：var name = ‘kuky’ 则定义了一个 String 类型对象 name，也可以通过指定具体的类型 String name = ‘kuky’，如果没有初始化变量，则默认值为 null，类型为数字的变量默认值同为 null（同 java 不同，java 中 int 默认为 0.）如果需要定义常量，可以通过 final 和 const 进行定义，final 变量只能赋值一次，const 是编译时常量。</p><h3 id="2、Build-in-types"><a href="#2、Build-in-types" class="headerlink" title="2、Build-in-types"></a>2、Build-in-types</h3><p>Dart 内置类型包括 ：</p><ul><li><strong>Numbers</strong>    包括 int[-2^53 ~ 2^53]， double[64-bit 浮点数]</li><li><strong>Strings </strong>   Dart 字符串是 UTF-16 编码的字符序列， 可以使用单引号或者双引号来创建字符串。</li><li>通过 <strong>==</strong> 判断两个字符串是否相同</li><li>通过三对单引号’’’aaa’’’或者双引号”””aaa”””可以创建多行字符串对象</li><li>使用前缀 r 创建 raw string，字符串内不会进行转义，例如：var a = r’haha \n breakLine’ 打印 a 对象则会按照输入的输出，不会进行换行</li><li><strong>Booleans</strong>    Dart 中，只有 true 对象才被认为是 true， 所有其他的值都是 false</li><li><strong>Lists</strong>    列表，例如：var list = [1, 2, 3, 4]</li><li>通过 <strong>const</strong> 关键词可以定义一个不可变列表 var list = const [1, 2, 3, 4]</li><li>参数化定义<strong>var</strong> name = <string>[‘Jone’, ‘Jack’]</string></li><li><strong>Maps</strong>    键值对，例如：var map = {‘one’: 1, ‘two’: 2}</li><li>如果键值对需要添加新的键值对，直接指定即可，map[‘three’] = 3，若查找的键不存在，返回 null</li><li>参数化定义 var map = &lt;String, int&gt;{‘one’: 1, ‘two’: 2}</li><li><strong>Runes</strong>    代表字符串的 UTF-32 code points，通常使用 \uXXXX 的方式来表示 Unicode code point， XXXX 是4个 16 进制的数，例如 \u2665 返回心形符号 ()</li><li><strong>Symbols</strong>    代表 Dart 程序中声明的操作符或者标识符，几乎不使用</li></ul><h3 id="3、Function"><a href="#3、Function" class="headerlink" title="3、Function"></a>3、Function</h3><p>函数方法的可选参数通过在参数列表中用 {} 指定，例如：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> say(<span class="built_in">String</span> name, &#123;<span class="built_in">String</span> word = <span class="string">'hello'</span>&#125;)&#123;    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">'$name say $word'</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过（可选参数名 + :）进行可选参数的赋值</span></span><br><span class="line">main()&#123;    </span><br><span class="line">say(<span class="string">'zm'</span>, word: <span class="string">'Hello World'</span>); <span class="comment">// kuky say Hello World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>word 参数为可选参数，默认值为 hello</p><h3 id="4、Operators"><a href="#4、Operators" class="headerlink" title="4、Operators"></a>4、Operators</h3><p>操作符几乎和别的语言类似，提个比较特殊的赋值操作符 ??= 和 ?.操作符</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b ?? = a; <span class="comment">// 如果 b 的值是 null 则将 a 赋值给 b，否则保持不变</span></span><br><span class="line"><span class="keyword">var</span> c = size?.x; <span class="comment">// 如果 size 为 null 则返回 null，否则返回 size.a 的值</span></span><br></pre></td></tr></table></figure><h3 id="5、Conditional-Expressions"><a href="#5、Conditional-Expressions" class="headerlink" title="5、Conditional Expressions"></a>5、Conditional Expressions</h3><p>Dart 可以通过两个特殊的操作符替换 if(){} else{} 表达式</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// condition? expr1: expr2 同 java 三目运算符</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">if</span>(a &lt; <span class="number">0</span>) -a : a</span><br><span class="line"><span class="comment">/// expr1 ?? expr2 </span></span><br><span class="line"><span class="built_in">String</span> toString() =&gt; msg ?? <span class="keyword">super</span>.toString() <span class="comment">// 如果 expr1 不为 null 则返回 expr1 否则返回 expr</span></span><br></pre></td></tr></table></figure><h3 id="6、Cascade-Notaion"><a href="#6、Cascade-Notaion" class="headerlink" title="6、Cascade Notaion(..)"></a>6、Cascade Notaion(..)</h3><p>级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span></span>&#123;</span><br><span class="line">    <span class="built_in">double</span> x;</span><br><span class="line">    <span class="built_in">double</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Size&#123;x: $x, y: $y&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size = Size();</span><br><span class="line"><span class="comment">/// 通过级联操作符进行赋值，可以更加简洁，!!如果函数返回值为 void 则不能进行级联!!</span></span><br><span class="line"><span class="built_in">print</span>(size</span><br><span class="line">      ..x = <span class="number">10</span></span><br><span class="line">      ..y = <span class="number">100</span></span><br><span class="line">      ..toString()); <span class="comment">/// 输出 Size&#123;x: 10.0, y: 100.0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="7、foreach"><a href="#7、foreach" class="headerlink" title="7、foreach"></a>7、foreach</h3><p>通过 foreach 循环遍历一个实现 Iterable 接口的对象</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> maps = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">items.where((i) =&gt; i &gt; <span class="number">2</span>).forEach((i) =&gt; <span class="built_in">print</span>(i));  <span class="comment">// 3, 4, 5</span></span><br><span class="line">maps.forEach((key, value) =&gt; <span class="built_in">print</span>(<span class="string">'$key =&gt; $value'</span>)); <span class="comment">// a =&gt; 1, b =&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="8、Switch-and-case"><a href="#8、Switch-and-case" class="headerlink" title="8、Switch and case"></a>8、Switch and case</h3><p>如果需要实现继续到下一个 case 语句中继续执行，则可以 使用 continue 语句跳转到对应的标签处继续执行</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'Close'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command.toLowerCase()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'close'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'close'</span>);</span><br><span class="line">    <span class="keyword">continue</span> open;</span><br><span class="line">        </span><br><span class="line">  open: <span class="comment">// 这是个标签</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'open'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'open'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、Assert"><a href="#9、Assert" class="headerlink" title="9、Assert"></a>9、Assert</h3><p>如果条件表达式结果不满足需要，则可以使用 assert 语句俩打断代码的执行，例如：assert(a == 1);</p><h3 id="10、Exceptions"><a href="#10、Exceptions" class="headerlink" title="10、Exceptions"></a>10、Exceptions</h3><p>所有的 Dart 异常是非检查异常。捕捉 exceptions 的时候可以通过 on 指定 exceptions 类型，再使用 catch 捕获</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: $e'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e, s) &#123; <span class="comment">// 函数 catch 可以带有一个或两个参数，第一个参数为抛出的异常对象，第二个为堆栈信息</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Something really unknown: $e'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Stack trace:\n $s'</span>);</span><br><span class="line">  <span class="keyword">rethrow</span>; <span class="comment">// 通过 rethrow 可以将异常重新抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、Classes"><a href="#11、Classes" class="headerlink" title="11、Classes"></a>11、Classes</h3><p>Dart 中的类都是单继承，但是同时支持 mixin 的继承机制（除 Object 类，每个类都只有一个超类），所有的类都继承于 Object，通过调用 runtimeType 判断实例的类型。每个实例变量都会自动生成一个 getter 方法（隐含的）， Non-final 实例变量还会自动生成一个 setter 方法。</p><p><strong>Constructors</strong></p><p>Dart 的构造函数同 Java 类似</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Size(<span class="built_in">num</span> nx, <span class="built_in">num</span> y)&#123;</span><br><span class="line">    x = nx;</span><br><span class="line">    <span class="keyword">this</span>.y = y; <span class="comment">// this 关键字只有当名字冲突时候使用，否则 Dart 推荐省略 this</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  Size(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y); <span class="comment">// Dart 通过语法糖省略了构造函数的赋值过程，效果同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有定义构造函数，则会有个默认构造函数。默认构造函数没有参数，并且会调用超类的 没有参数的构造函数。子类不会继承超类的构造函数，子类如果没有定义构造函数，则只有一个默认构造函数。</p><p>Dart 通过命名构造函数为类创建多个构造函数，同时指明意图</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Size(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Size.fromJson(<span class="built_in">Map</span> json)&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = json[<span class="string">'x'</span>];</span><br><span class="line">    <span class="keyword">this</span>.y = json[<span class="string">'y'</span>];</span><br><span class="line">  &#125; <span class="comment">// 因为构造函数不能继承，如果希望子类也有超类一样的命名构造函数，必须在子类中实现该构造函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造函数体执行之前除了可以调用超类构造函数之外，还可以初始化实例参数</span></span><br><span class="line">  <span class="comment">// 初始化列表非常适合用来设置 final 变量的值</span></span><br><span class="line">  Size.fromJsonInit(<span class="built_in">Map</span> json)</span><br><span class="line">      : <span class="keyword">this</span>.x = json[<span class="string">'x'</span>],</span><br><span class="line">        <span class="keyword">this</span>.y = json[<span class="string">'y'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量构造函数（如果类需要提供一个状态不变的对象，通过 const 构造函数实现）</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstPoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ConstPoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法构造函数（如果一个类不需要每次都提供一个新的对象，通过 factory 构造函数实现）</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpCore</span> </span>&#123;</span><br><span class="line">  HttpCore._internal();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> HttpCore() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) _instance = HttpCore._internal();</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> HttpCore _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> HttpCore <span class="keyword">get</span> instance =&gt; HttpCore();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _request()&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类都隐式的定义了一个包含所有实例成员的接口， 并且这个类实现了这个接口，通过抽象类实现类似 Java 接口的功能。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">print</span>(<span class="built_in">String</span> msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">print</span>(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mixins  Dart | 什么是Mixin：<a href="https://www.jianshu.com/p/a578bd2c42aa" target="_blank" rel="noopener">https://www.jianshu.com/p/a578bd2c42aa</a></p><h3 id="12、Asynchrony-support"><a href="#12、Asynchrony-support" class="headerlink" title="12、Asynchrony support"></a>12、Asynchrony support</h3><p><strong>Future</strong></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">loopIntegers() &#123;</span><br><span class="line">  <span class="comment">// 通过 then 进行获取到 Future 对象后的操作</span></span><br><span class="line">  getListDelay().then((ints) =&gt; ints.forEach((i) =&gt; <span class="built_in">print</span>(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个 Future 对象</span></span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; getListDelay() &#123;</span><br><span class="line">  <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () =&gt; <span class="built_in">List</span>.generate(<span class="number">10</span>, (delta) =&gt; delta));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 async await 简化 Future 操作</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">runUsingFuture() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  findEntrypoint().then((entrypoint) &#123;</span><br><span class="line">    <span class="keyword">return</span> runExecutable(entrypoint, args);</span><br><span class="line">  &#125;).then(flushThenExit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化了 then</span></span><br><span class="line">runUsingAsyncAwait() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line">  <span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line">  <span class="keyword">await</span> flushThenExit(exitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候要求调用很多异步方法，并且等待 所有方法完成后再继续执行，通过使用 Future.wait() 进行管理</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future deleteDone = deleteLotsOfFiles();</span><br><span class="line">Future copyDone = copyLotsOfFiles();</span><br><span class="line">Future checksumDone = checksumLotsOfOtherFiles();</span><br><span class="line"></span><br><span class="line">Future.wait([deleteDone, copyDone, checksumDone])</span><br><span class="line">    .then((<span class="built_in">List</span> values) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Done with all the long steps'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Stream Dart|什么是 Stream：<a href="https://www.jianshu.com/p/a5d7758938ef" target="_blank" rel="noopener">https://www.jianshu.com/p/a5d7758938ef</a></p><p>大概了解了 Dart 的语法，下节就开始写 Flutter 啦~，环境的安装具体查看官网，很详细 Flutter 环境安装 记得一定要<strong>配置镜像，配置镜像，配置镜像</strong></p><p><a href="https://flutterchina.club/get-started/install/" target="_blank" rel="noopener">https://flutterchina.club/get-started/install/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近 Flutter 真心火爆到不要不要的，随大流，学一波，在这之前，对于语言的语法还是需要有些必要的了解的，&lt;strong&gt;Dart&lt;/strong&gt; 这门语言，说实话对于会 Java 这类面向对象的语言的小伙伴们来说，真的灰常灰常简单，这边我总结了一些 Dart 和 Java 的一些语法差异，当然，只是部分，但是，按照我目前的学习进度来说，了解了这些对于写 Flutter 项目绝对够了。小伙伴也可以自己查看，我这边提供一个自己学习的网址 &lt;strong&gt;Dart&lt;/strong&gt; 快速入门：&lt;a href=&quot;http://dart.goodev.org/guides/language&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dart.goodev.org/guides/language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;温馨提示：本篇文章没有图，没有图，没有图，可能会造成部分不适，请注意，请注意，请注意，系好安全带，我们要「开车了」……&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android面试笔记</title>
    <link href="http://yoursite.com/posts/e9998381.html"/>
    <id>http://yoursite.com/posts/e9998381.html</id>
    <published>2019-04-23T07:02:25.000Z</published>
    <updated>2019-05-16T07:44:23.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p><strong>注册方式：</strong></p><p>1、静态注册 ，在Manifest文件的<code>application</code>节点中配置广播接收者</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyBroadCastReceiver"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">actionandroid:name="android.provider.Telephony.SMS_RECEIVED"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、动态注册，通过<code>Context</code>对象的<code>registerReceiver</code>方法注册广播</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new出上边定义好的BroadcastReceiver</span></span><br><span class="line">MyBroadCastReceiver yBroadCastReceiver = <span class="keyword">new</span> MyBroadCastReceiver();</span><br><span class="line"><span class="comment">//实例化过滤器并设置要过滤的广播  </span></span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>);</span><br><span class="line"><span class="comment">//注册广播   </span></span><br><span class="line">myContext.registerReceiver(smsBroadCastReceiver,intentFilter, </span><br><span class="line">             <span class="string">"android.permission.RECEIVE_SMS"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>区别：静态注册的为常驻型广播，即使应用程序关闭了，如果又信息广播来，程序也会被系统调用执行。而动态注册的广播不是常驻型，广播被取消注册或者应用程序关闭后都不能接收</p></blockquote><p><strong> 广播的两种类型：</strong></p><p>1、有序广播：按照优先级，一级一级向下传递，接收者可以修改广播数据，也可以终止广播事件。</p><p>2、无序广播：所有接收者都会接收事件，不能被拦截跟修改。</p><a id="more"></a><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p><strong>启动</strong></p><p>1、使用<code>Context</code>的<code>startService</code>方法启动</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; onCreate()`---&gt;`onStartCommand()`---&gt;`onDestroy()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>2、使用<code>Context</code>的<code>bindService</code>方法启动</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; onCreate()`---&gt;`onBind()`---&gt;`onUnBind()`---&gt;`onDestroy()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>停止</strong></p><p>1、在外部使用<code>stopService</code>方法，如果使用<code>bindService</code>的方式启动，则使用<code>unbindService</code>方法停止</p><p>2、在<code>Service</code>内部（<code>onStartCommand</code>方法内）使用<code>stopSelf</code></p><p><strong><code>onStartCommand</code></strong>方法的返回值</p><p>1、<code>START_NOT_STICKY</code>：“非粘性的”。使用这个返回值时，如果在执行完<code>onStartCommand</code>方法后，服务被异常kill掉，系统不会自动重启该服务</p><p>2、<code>START_STICKY</code>：如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。</p><p>3、<code>START_REDELIVER_INTENT</code>：重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>继承于<code>Service</code>，启动方式与<code>Service</code>的传统启动方式一样，不同点在于内部有一个线程来处理耗时操作，当任务执行完成时服务会自动停止。</p><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><ul><li><code>standard</code>：标准模式，默认的启动模式，不管是否已经存在实例都会生成新的实例</li><li><code>singleTop</code>：栈顶复用模式，如果发现有对应Activity的实例正位于栈顶，则直接打开此页面，不再生成新的实例，同时<code>onNewIntent</code>方法会被执行，<code>onCreate</code>跟<code>onStart</code>方法都不会执行。否则跟<code>standard</code>模式一样继续生成新的实例。</li><li><code>singleTask</code>：站内复用模式，如果栈内存在对应Activity的实例就会复用这个Activity，复用时会将它上面的Activity全部出栈，同时<code>onNewIntent</code>方法也会被执行。</li><li><code>singleInstance</code>：单例模式，该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</li></ul><h2 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h2><p>app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。</p><blockquote><ol><li><code>Luncher.startActivitySafely()</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class">&gt; <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>, </span></span><br><span class="line"><span class="class">&gt;                     <span class="title">OnLongClickListener</span>, </span></span><br><span class="line"><span class="class">&gt;                     <span class="title">LauncherModel</span>.<span class="title">Callbacks</span>, </span></span><br><span class="line"><span class="class">&gt;                     <span class="title">AllAppsView</span>.<span class="title">Watcher</span> </span>&#123;</span><br><span class="line">&gt;                         </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;         </span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">startActivitySafely</span><span class="params">(Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">&gt; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; startActivity(intent);</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;                         </span><br><span class="line">&gt;     ......</span><br><span class="line">&gt;         </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="2"><li><code>Activity.startActivity</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></span><br><span class="line"><span class="class">&gt; <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks</span> </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">&gt; startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="3"><li><code>Activity.startActivityForResult</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></span><br><span class="line"><span class="class">&gt; <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks</span> </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; Instrumentation.ActivityResult ar =</span><br><span class="line">&gt; mInstrumentation.execStartActivity(</span><br><span class="line">&gt; <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">&gt; intent, requestCode);</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="4"><li><code>Instrumentation.execStartActivity</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">&gt; IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">&gt; <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">&gt; .startActivity(whoThread, intent,</span><br><span class="line">&gt; intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">&gt; <span class="keyword">null</span>, <span class="number">0</span>, token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">&gt; requestCode, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这里的<code>ActivityManagerNative.getDefault</code>返回<code>ActivityManagerService</code>的远程接口，即<code>ActivityManagerProxy</code>接口</p><ol start="5"><li><code>ActivityManagerProxy.startActivity</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span></span><br><span class="line"><span class="class">&gt; </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; String resolvedType, Uri[] grantedUriPermissions, <span class="keyword">int</span> grantedMode,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; IBinder resultTo, String resultWho,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; <span class="keyword">int</span> requestCode, <span class="keyword">boolean</span> onlyIfNeeded,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; <span class="keyword">boolean</span> debug)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">&gt; Parcel data = Parcel.obtain();</span><br><span class="line">&gt; Parcel reply = Parcel.obtain();</span><br><span class="line">&gt; data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">&gt; data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">&gt; intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">&gt; data.writeString(resolvedType);</span><br><span class="line">&gt; data.writeTypedArray(grantedUriPermissions, <span class="number">0</span>);</span><br><span class="line">&gt; data.writeInt(grantedMode);</span><br><span class="line">&gt; data.writeStrongBinder(resultTo);</span><br><span class="line">&gt; data.writeString(resultWho);</span><br><span class="line">&gt; data.writeInt(requestCode);</span><br><span class="line">&gt; data.writeInt(onlyIfNeeded ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&gt; data.writeInt(debug ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&gt; mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">&gt; reply.readException();</span><br><span class="line">&gt; <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">&gt; reply.recycle();</span><br><span class="line">&gt; data.recycle();</span><br><span class="line">&gt; <span class="keyword">return</span> result;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="6"><li><code>ActivityManagerService.startActivity</code></li></ol></blockquote><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context是一个抽象基类，翻译为上下文，也可以理解为环境，提供一些程序运行基础信息。</p><p>Context有两个子类，<code>ContextWrapper</code>是上下文功能的封装类，而 <code>ContextImpl</code> 则是上下文功能的实现类。而 <code>ContextWrapper</code> 又有三个直接的子类， <code>ContextThemeWrapper</code>、<code>Service</code>和<code>Application</code>。其中，<code>ContextThemeWrapper</code>是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由<code>ContextImpl</code>类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p><h2 id="Activity、Window、View三者之间的关系"><a href="#Activity、Window、View三者之间的关系" class="headerlink" title="Activity、Window、View三者之间的关系"></a>Activity、Window、View三者之间的关系</h2><ol><li><code>Activity</code> 构造的时候会初始化一个Window( <code>PhoneWindw</code> )</li><li><code>PhoneWindow</code> 有一个 <code>RootView</code> ，这个<code>RootView</code> 是一个ViewGroup，是最初始的根视图</li><li><code>RootView</code> 通过 <code>addView</code> 方法来一个个添加 <code>View</code></li></ol><h2 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h2><p>View的绘制流程：<code>onMeasure</code> -&gt; <code>onLayout</code> -&gt; <code>onDraw</code></p><p>第一步：<code>onMeasure</code> 测量视图大小，从顶层父View到子View递归调用 <code>measure</code> 方法，<code>measure</code> 方法又回调 <code>onMeasure</code>方法。</p><p>第二步：<code>onLayout</code> 确定View位置，进行页面布局。从顶层父View向子View递归调用 <code>layout</code> 方法的过程，即父View根据上一步 <code>measure</code> 得到的布局大小和布局参数，将子View放在合适的位置上。</p><p>第三步：<code>onDraw</code> 绘制视图。主要步骤为①：绘制背景，②：绘制自己，③：绘制子View，④：绘制滚动条</p><h2 id="View、ViewGroup事件分发"><a href="#View、ViewGroup事件分发" class="headerlink" title="View、ViewGroup事件分发"></a>View、ViewGroup事件分发</h2><p>ViewGroup 包含 <code>dispatchTouchEvent</code> 、<code>onInterceptTouchEvent</code> 、<code>onTouchEvent</code>三个相关方法，View包含 <code>dispatchTouchEvent</code>、<code>onTouchEvent</code>两个相关方法。</p><ol><li>当 <code>Activity</code> 接收到Touch事件时，将遍历子View进行Down事件分发，分发的目的是为了找到真正处理本次完整触摸事件的View，这个View会在 <code>onTouchEvent</code> 返回true。</li><li>当某个子View返回true时，就终止事件分发，并同时在ViewGroup中记录该View，接下来的move事件跟up事件都由该子View直接进行处理。</li><li>当ViewGroup所有子View都不捕获Down事件时，将触发ViewGroup自身的 <code>onTouchEvent</code> 事件。触发的方式是调用 <code>super.dispatchTouchEvent</code>函数，即调用父View的<code>dispatchTouchEvent</code>方法。</li></ol><h2 id="Handler实现原理"><a href="#Handler实现原理" class="headerlink" title="Handler实现原理"></a>Handler实现原理</h2><p>Android的主线程不能进行耗时操作，子线程不能进行更新UI，所以就有了Handler，它的作用就是实现线程之间的通信。</p><p>Handler整个流程中主要有四个对象：<code>Handler</code>、<code>Message</code>、<code>MessageQueue</code>、<code>Looper</code>。通过将要传递的消息放在<code>Message</code>中，<code>Handler</code>通过 <code>sendMessage</code> 方法将消息放入 <code>MessageQueue</code> 中，<code>Looper</code> 对象会不断的调用<code>loop()</code> 方法不断从 <code>MessageQueue</code> 中取出 <code>Message</code> 交给 <code>Handler</code>进行处理。</p><h2 id="Android内存泄露"><a href="#Android内存泄露" class="headerlink" title="Android内存泄露"></a>Android内存泄露</h2><ol><li><p>内存泄漏跟内存溢出的区别：</p><ul><li>内存泄漏：指程序在申请内存后，无法释放已经申请的内存空间</li><li>内存溢出：指程序在申请内存时，没有足够的内存空间供其使用</li></ul></li><li><p>内存泄漏的原因：</p><ul><li><p>Handler引起的内存泄漏：</p><p>将Handler声明为静态内部类，就不会持有外部类的引用，其生命周期就跟外部类无关。如果Handler内部要使用Context，则可以使用弱引用的方式。</p></li><li><p>单例模式引起的内存泄漏：</p><p>Context是ApplicationCotnext，ApplicationCotnext的生命周期与app一致，不会导致内存泄漏.</p></li><li><p>非静态内部类创建实例引起的：</p><p>创建为静态实例</p></li><li><p>非静态匿名内部类引起的：</p><p>将匿名内部类修改为静态的</p></li><li><p>注册/反注册未成对使用引起的内存泄漏</p><p>注册广播接受器、EventBus等，记得解绑</p></li><li><p>资源对象没有关闭引起的内存泄漏</p><p>在这些资源不使用的时候，记得调用相应的类似close()、destroy()、recycler()、release()等方法释放</p></li><li><p>集合对象没有及时清理引起的内存泄漏</p><p>通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用</p></li></ul></li><li><p>内存泄漏检测：LeakCanary</p></li></ol><h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><p>ANR全名”Application not responding”，即应用无响应。产生的原因：</p><ul><li>5s内无法响应用户输入事件</li><li>广播在10s内无法结束</li><li>Service在20s内无法结束</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;广播&quot;&gt;&lt;a href=&quot;#广播&quot; class=&quot;headerlink&quot; title=&quot;广播&quot;&gt;&lt;/a&gt;广播&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注册方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、静态注册 ，在Manifest文件的&lt;code&gt;application&lt;/code&gt;节点中配置广播接收者&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;receiver&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;.MyBroadCastReceiver&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:priority&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;20&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;actionandroid:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;receiver&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2、动态注册，通过&lt;code&gt;Context&lt;/code&gt;对象的&lt;code&gt;registerReceiver&lt;/code&gt;方法注册广播&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//new出上边定义好的BroadcastReceiver&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyBroadCastReceiver yBroadCastReceiver = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyBroadCastReceiver();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//实例化过滤器并设置要过滤的广播  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IntentFilter intentFilter = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IntentFilter(&lt;span class=&quot;string&quot;&gt;&quot;android.provider.Telephony.SMS_RECEIVED&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//注册广播   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myContext.registerReceiver(smsBroadCastReceiver,intentFilter, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&quot;android.permission.RECEIVE_SMS&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;区别：静态注册的为常驻型广播，即使应用程序关闭了，如果又信息广播来，程序也会被系统调用执行。而动态注册的广播不是常驻型，广播被取消注册或者应用程序关闭后都不能接收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; 广播的两种类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、有序广播：按照优先级，一级一级向下传递，接收者可以修改广播数据，也可以终止广播事件。&lt;/p&gt;
&lt;p&gt;2、无序广播：所有接收者都会接收事件，不能被拦截跟修改。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>android和java泛型扫盲</title>
    <link href="http://yoursite.com/posts/c4ef6275.html"/>
    <id>http://yoursite.com/posts/c4ef6275.html</id>
    <published>2019-04-23T06:51:54.000Z</published>
    <updated>2019-05-16T07:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android、Java泛型扫盲"><a href="#Android、Java泛型扫盲" class="headerlink" title="Android、Java泛型扫盲"></a>Android、Java泛型扫盲</h1><p>首先我们定义A、B、C、D四个类，他们的关系如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="不指明泛型类型"><a href="#不指明泛型类型" class="headerlink" title="不指明泛型类型"></a>不指明泛型类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码均编译通过</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//不指明泛型类型，泛型默认为Object类型，故能往里面添加任意实例对象</span></span><br><span class="line">list.add(<span class="keyword">new</span> A());</span><br><span class="line">list.add(<span class="keyword">new</span> B());</span><br><span class="line">list.add(<span class="keyword">new</span> C());</span><br><span class="line"><span class="comment">//取出则默认为Object类型</span></span><br><span class="line">Object o = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这个好理解，因为所有的类都继承与Object，故能往list里面添加任意实例对象</p><a id="more"></a><h3 id="无边界通配符-？"><a href="#无边界通配符-？" class="headerlink" title="无边界通配符 ？"></a>无边界通配符 <code>？</code></h3><p>首先我们要明白一个概念，通配符<code>？</code>意义就是它是一个未知的符号，可以是代表任意的类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们发现，这样写编译不通过，原因很简单，泛型不匹配，虽然B继承A</span></span><br><span class="line">List&lt;A&gt; listA = <span class="keyword">new</span> ArrayList&lt;B&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//以下5行代码均编译通过</span></span><br><span class="line">List&lt;?&gt; list;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;A&gt;();</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;B&gt;();</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;C&gt;();</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;D&gt;();</span><br><span class="line"></span><br><span class="line">Object o = list.get(<span class="number">0</span>); <span class="comment">//编译通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> A());      <span class="comment">//编译不通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> B());      <span class="comment">//编译不通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> C());      <span class="comment">//编译不通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> D());      <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p><code>知识点</code></p><ul><li>无边界通配符 <code>？</code> 能取不能存。这个好理解，因为编译器不知道<code>?</code>具体是啥类型，故不能存；但是任意类型都继承于Object，故能取，但取出默认为Object对象。</li></ul><h3 id="上边界符-？extends"><a href="#上边界符-？extends" class="headerlink" title="上边界符 ？extends"></a>上边界符 <code>？extends</code></h3><p>继续上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends C&gt; listC;</span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;A&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;B&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;C&gt;(); <span class="comment">//编译通过</span></span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;D&gt;(); <span class="comment">//编译通过</span></span><br><span class="line"></span><br><span class="line">C c = listC.get(<span class="number">0</span>); <span class="comment">//编译通过</span></span><br><span class="line">listC.add(<span class="keyword">new</span> C()); <span class="comment">//编译不通过</span></span><br><span class="line">listC.add(<span class="keyword">new</span> D()); <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong></p><ol><li>上边界符 <code>? extends</code> 只是限定了赋值给它的实例类型(这里为赋值给listC的实例类型)，且边界包括自身。</li><li>上边界符 <code>? extends</code> 跟 <code>？</code> 一样能取不能存，道理是一样的，虽然限定了上边界，但编译器依然不知道 <code>?</code> 是啥类型，故不能存；但是限定了上边界，故取出来的对象类型默认为上边界的类型</li></ol><h3 id="下边界符-？super"><a href="#下边界符-？super" class="headerlink" title="下边界符 ？super"></a>下边界符 <code>？super</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> B&gt; listB;</span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;A&gt;(); <span class="comment">//编译通过</span></span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;B&gt;(); <span class="comment">//编译通过</span></span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;C&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;D&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line"></span><br><span class="line">Object o = listB.get(<span class="number">0</span>); <span class="comment">//编译通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> A()); <span class="comment">//编译不通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> B()); <span class="comment">//编译通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> C()); <span class="comment">//编译通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> D()); <span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong></p><ol><li>下边界符 <code>？super</code>，跟上边界符一样，只是限定了赋值给它的实例类型，也包括边界自身</li><li>下边界符 <code>？super</code> 能存能取，因为设定了下边界，故我们能存下边界以下的类型，当然也包括边界自身；然而取得时候编译器依然不知道 <code>?</code> 具体是什么类型，故取出默认为Object类型。</li></ol><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>首先我们要明白一点：Java 的泛型在编译期有效，在运行期会被删除 我们来看一段代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这两个方法写在同一个类里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List&lt;A&gt; listA)</span> </span>&#123;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List&lt;B&gt; listB)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会有问题吗？显然是有的，编译器报错，提示如下信息： <code>list(List&lt;A&gt;) clashed with list(List&lt;B&gt;) ; both methods have same erasure</code> 翻译过来就是，在类型擦除后，两个方法具有相同的签名，我们来看看类型擦除后是什么样子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List listA)</span> </span>&#123;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List listB)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看出，两个方法签名完全一致，故编译不通过。 明白了类型擦除，我们还需要明白一个概念</p><ul><li>泛型类并没有自己独有的Class类对象</li></ul><p>比如并不存在List<a>.class或是List<b>.class，而只有List.class 接下来这个案例就好理解了</b></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;A&gt; listA = <span class="keyword">new</span> ArrayList&lt;A&gt;();</span><br><span class="line">List&lt;B&gt; listB = <span class="keyword">new</span> ArrayList&lt;B&gt;();</span><br><span class="line">System.out.println(listA.getClass() == listB.getClass());  <span class="comment">//输出true</span></span><br></pre></td></tr></table></figure><h3 id="泛型传递"><a href="#泛型传递" class="headerlink" title="泛型传递"></a>泛型传递</h3><p>现实开发中，我们经常会用到泛型传递，例如我们经常需要对Http请求返回的结果做反序列化操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String result, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(result, type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们传进去是什么类型，就会返回自动该类型的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result=<span class="string">"xxx"</span>;</span><br><span class="line">A a = fromJson(result, A.class);</span><br><span class="line">B b = fromJson(result, B.class);</span><br><span class="line">C c = fromJson(result, C.class);</span><br><span class="line">D d = fromJson(result, D.class);</span><br><span class="line">Integer integer = fromJson(result, Integer.class);</span><br><span class="line">String str = fromJson(result, String.class);</span><br><span class="line">Boolean boo = fromJson(result, Boolean.class);</span><br></pre></td></tr></table></figure><p>那如果我们想返回一个集合呢，如<code>List&lt;A&gt;</code>，下面这样明显是不对的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译报错，前面类型擦除时，我们讲过，不存List&lt;A&gt;.class这种类型</span></span><br><span class="line">ArrayList&lt;A&gt; list = fromJson(result, ArrayList&lt;A&gt;.class)；</span><br></pre></td></tr></table></figure><p>那我们该怎么做呢？首先，我们对<code>fromJson</code>改造一下，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type为一个数组类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">fromJson</span><span class="params">(String result, Class&lt;T[]&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T[] arr = <span class="keyword">new</span> Gson().fromJson(result, type);<span class="comment">//首先拿到数组</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(arr); <span class="comment">//数组转集合</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们就可以这么做了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result=<span class="string">"xxx"</span>;</span><br><span class="line">List&lt;A&gt; listA = fromJson(result, A[].class);</span><br><span class="line">List&lt;B&gt; listB = fromJson(result, B[].class);</span><br><span class="line">List&lt;C&gt; listC = fromJson(result, C[].class);</span><br><span class="line">List&lt;D&gt; listD = fromJson(result, D[].class);</span><br><span class="line">List&lt;Integer&gt; listInt = fromJson(result, Integer[].class);</span><br><span class="line">List&lt;String&gt; listStr = fromJson(result, String[].class);</span><br><span class="line">List&lt;Boolean&gt; listBoo = fromJson(result, Boolean[].class);</span><br></pre></td></tr></table></figure><p>ok，我在再来，相信大多数Http接口返回的数据格式是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">//省略get/set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这种我们又该如何传递呢？显然用前面的两个<code>fromJson</code>方法都行不通，我们再来改造一下，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我们直接传递一个Type类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String result, Type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(result, type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Type是什么鬼？点进去看看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦，原来就是一个接口，并且只有一个方法，我们再来看看它的实现类</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428180503.png" alt=""></p><p>发现有5个实现类，其中4个是接口，另外一个是Class类，我们再来看看Class类的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">                              <span class="comment">//省略内部代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有没有明白点，现在我们重点来关注下<code>Type</code>接口的其中一个实现接口<code>ParameterizedType</code>，我们来看下它的内部代码，里面就只有3个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如:</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list; 则返回 &#123;String.class&#125;</span></span><br><span class="line"><span class="comment">     * Map&lt;String,Long&gt; map; 则返回 &#123;String.class,Long.class&#125;</span></span><br><span class="line"><span class="comment">     * Map.Entry&lt;String,Long&gt; entry; 则返回 &#123;String.class,Long.class&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 以数组的形式返回所有的泛型类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如:</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list; 则返回 List.class</span></span><br><span class="line"><span class="comment">     * Map&lt;String,Long&gt; map; 则返回 Map.class</span></span><br><span class="line"><span class="comment">     * Map.Entry&lt;String,Long&gt; entry; 则返回 Entry.class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回泛型类的真实类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如:</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list; 则返回 null</span></span><br><span class="line"><span class="comment">     * Map&lt;String,Long&gt; map; 则返回 null</span></span><br><span class="line"><span class="comment">     * Map.Entry&lt;String,Long&gt; entry; 则返回 Map.class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回泛型类持有者的类型，这里可以简单理解为返回外部类的类型，如果没有外部类，则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，<code>ParameterizedType</code> 代表一个参数化类型。</p><p>这个时候我们来自定义一个类，并实现ParameterizedType接口，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedTypeImpl</span> <span class="keyword">implements</span> <span class="title">ParameterizedType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Type rawType;<span class="comment">//真实类型</span></span><br><span class="line">    <span class="keyword">private</span> Type actualType;<span class="comment">//泛型类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseType</span><span class="params">(Type rawType,Type actualType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType;</span><br><span class="line">        <span class="keyword">this</span>.actualType = actualType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Type[] getActualTypeArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Type[]&#123;actualType&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getRawType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rawType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getOwnerType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次贴出<code>fromJson</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我们直接传递一个Type类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String result, Type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(result, type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们想得到<code>Response&lt;T&gt;</code>对象，就可以这样写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response&lt;A&gt; responseA = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, A.class));</span><br><span class="line">Response&lt;B&gt; responseB = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, B.class));</span><br><span class="line">Response&lt;C&gt; responseC = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, C.class));</span><br></pre></td></tr></table></figure><p>想得到<code>List&lt;T&gt;</code>对象，也可以通过<code>ParameterizedTypeImpl</code>得到，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;A&gt; listA = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(List.class, A.class));</span><br><span class="line">List&lt;B&gt; listB = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(List.class, B.class));</span><br><span class="line">List&lt;C&gt; listC = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(List.class, C.class));</span><br></pre></td></tr></table></figure><p>然而，如果我们想得到<code>Response&lt;List&lt;T&gt;&gt;</code>对象，又该如何得到呢？ <code>ParameterizedTypeImpl</code>一样能够实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，创建List&lt;T&gt;对象对应的Type类型</span></span><br><span class="line">Type listAType = <span class="keyword">new</span> ParameterizedTypeImpl(List.class, A.class);</span><br><span class="line">Type listBType = <span class="keyword">new</span> ParameterizedTypeImpl(List.class, B.class);</span><br><span class="line">Type listCType = <span class="keyword">new</span> ParameterizedTypeImpl(List.class, C.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型</span></span><br><span class="line">Type responseListAType = <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, listAType);</span><br><span class="line">Type responseListBType = <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, listBType);</span><br><span class="line">Type responseListCType = <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, listCType);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象</span></span><br><span class="line">Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);</span><br><span class="line">Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);</span><br><span class="line">Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType);</span><br></pre></td></tr></table></figure><p>然后，能不能再简单一点呢？可以，我们对<code>ParameterizedTypeImpl</code>改造一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User: ljx</span></span><br><span class="line"><span class="comment"> * Date: 2018/10/23</span></span><br><span class="line"><span class="comment"> * Time: 09:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedTypeImpl</span> <span class="keyword">implements</span> <span class="title">ParameterizedType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type   rawType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type   ownerType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type[] actualTypeArguments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适用于单个泛型参数的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterizedTypeImpl</span><span class="params">(Type rawType, Type actualType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, rawType, actualType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适用于多个泛型参数的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterizedTypeImpl</span><span class="params">(Type ownerType, Type rawType, Type... actualTypeArguments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType;</span><br><span class="line">        <span class="keyword">this</span>.ownerType = ownerType;</span><br><span class="line">        <span class="keyword">this</span>.actualTypeArguments = actualTypeArguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本方法仅使用于单个泛型参数的类</span></span><br><span class="line"><span class="comment">     * 根据types数组，确定具体的泛型类型</span></span><br><span class="line"><span class="comment">     * List&lt;List&lt;String&gt;&gt;  对应  get(List.class, List.class, String.class)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> types Type数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ParameterizedTypeImpl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterizedTypeImpl <span class="title">get</span><span class="params">(@NonNull Type rawType, @NonNull Type... types)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = types.length;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Type parameterizedType = <span class="keyword">new</span> ParameterizedTypeImpl(types[length - <span class="number">2</span>], types[length - <span class="number">1</span>]);</span><br><span class="line">            Type[] newTypes = Arrays.copyOf(types, length - <span class="number">1</span>);</span><br><span class="line">            newTypes[newTypes.length - <span class="number">1</span>] = parameterizedType;</span><br><span class="line">            <span class="keyword">return</span> get(rawType, newTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(rawType, types[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适用于多个泛型参数的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterizedTypeImpl <span class="title">getParameterized</span><span class="params">(@NonNull Type rawType, @NonNull Type... actualTypeArguments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(<span class="keyword">null</span>, rawType, actualTypeArguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Type[] getActualTypeArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> actualTypeArguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getOwnerType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ownerType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getRawType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rawType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们就可以这样写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，直接创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型</span></span><br><span class="line">Type responseListAType = ParameterizedTypeImpl.get(Response.class, List.class, A.class);</span><br><span class="line">Type responseListBType = ParameterizedTypeImpl.get(Response.class, List.class, B.class)</span><br><span class="line">Type responseListCType = ParameterizedTypeImpl.get(Response.class, List.class, C.class)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象</span></span><br><span class="line">Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);</span><br><span class="line">Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);</span><br><span class="line">Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType);</span><br></pre></td></tr></table></figure><p>现实开发中，我们还可能遇到这样的数据结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"totalPage"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"list"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>Response&lt;T&gt;</code> 里面的泛型传List肯定是不能正常解析的，我们需要再定一个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageList</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> totalPage;</span><br><span class="line">   <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">   <span class="comment">//省略get/set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以这样解析数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，直接创建Response&lt;PageList&lt;T&gt;&gt;对象对应的Type类型</span></span><br><span class="line">Type responsePageListAType = ParameterizedTypeImpl.get(Response.class, PageList.class, A.class);</span><br><span class="line">Type responsePageListBType = ParameterizedTypeImpl.get(Response.class, PageList.class, B.class)</span><br><span class="line">Type responsePageListCType = ParameterizedTypeImpl.get(Response.class, PageList.class, C.class)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，通过Type对象，获取对应的Response&lt;PageList&lt;T&gt;&gt;对象</span></span><br><span class="line">Response&lt;PageList&lt;A&gt;&gt; responsePageListA = fromJson(result, responsePageListAType);</span><br><span class="line">Response&lt;PageList&lt;B&gt;&gt; responsePageListB = fromJson(result, responsePageListBType);</span><br><span class="line">Response&lt;PageList&lt;C&gt;&gt; responsePageListC = fromJson(result, responsePageListCType);</span><br></pre></td></tr></table></figure><p>注：<code>ParameterizedTypeImpl get(Type... types)</code>仅仅适用于单个泛型参数的时候，如Map等，有两个泛型参数以上的不要用此方法获取Type类型。如果需要获取Map等两个泛型参数以上的Type类型。可调用<code>getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments)</code>构造方法获取，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 Map&lt;String,String&gt; 对应的Type类型</span></span><br><span class="line">Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, String.classs, String.class)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Map&lt;A,B&gt; 对应的Type类型</span></span><br><span class="line">Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, A.classs, B.class)</span><br></pre></td></tr></table></figure><p>到这，泛型相关知识点讲解完毕，如有疑问，请留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android、Java泛型扫盲&quot;&gt;&lt;a href=&quot;#Android、Java泛型扫盲&quot; class=&quot;headerlink&quot; title=&quot;Android、Java泛型扫盲&quot;&gt;&lt;/a&gt;Android、Java泛型扫盲&lt;/h1&gt;&lt;p&gt;首先我们定义A、B、C、D四个类，他们的关系如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;不指明泛型类型&quot;&gt;&lt;a href=&quot;#不指明泛型类型&quot; class=&quot;headerlink&quot; title=&quot;不指明泛型类型&quot;&gt;&lt;/a&gt;不指明泛型类型&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以下代码均编译通过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//不指明泛型类型，泛型默认为Object类型，故能往里面添加任意实例对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; B());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; C());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//取出则默认为Object类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object o = list.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个好理解，因为所有的类都继承与Object，故能往list里面添加任意实例对象&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ES5 to ESNext 自2015以来JavaScript新增的所有新特性</title>
    <link href="http://yoursite.com/posts/bf9085e4.html"/>
    <id>http://yoursite.com/posts/bf9085e4.html</id>
    <published>2019-04-23T02:23:46.000Z</published>
    <updated>2019-05-16T07:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。</p><p>JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。</p><p>JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。</p><a id="more"></a><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h5 id="ECMAScript-简介"><a href="#ECMAScript-简介" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h5><h5 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h5><ul><li>let 和 const</li><li>箭头函数</li><li>类</li><li>默认参数</li><li>模板字符串</li><li>解构赋值</li><li>增强的对象字面量</li><li>For-of 循环</li><li>Promises</li><li>模块</li><li>String 新方法</li><li>Object 新方法</li><li>展开运算符</li><li>Set</li><li>Map</li><li>Generators</li></ul><h5 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h5><ul><li>Array.prototype.includes()</li><li>求幂运算符</li></ul><h5 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h5><ul><li>字符串填充</li><li>Object.values()</li><li>Object.entries()</li><li>Object.getOwnPropertyDescriptors()</li><li>尾逗号</li><li>共享内存 and 原子操作</li></ul><h5 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h5><ul><li>Rest/Spread Properties</li><li>Asynchronous iteration</li><li>Promise.prototype.finally()</li><li>正则表达式改进</li></ul><h5 id="ESNext"><a href="#ESNext" class="headerlink" title="ESNext"></a>ESNext</h5><ul><li>Array.prototype.{flat,flatMap}</li><li>try/catch 可选的参数绑定</li><li>Object.fromEntries()</li><li>String.prototype.{trimStart,trimEnd}</li><li>Symbol.prototype.description</li><li>JSON improvements</li><li>Well-formed JSON.stringify()</li><li>Function.prototype.toString()</li></ul><h4 id="ECMAScript-简介-1"><a href="#ECMAScript-简介-1" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h4><p>每当阅读 JavaScript 相关的文章时，我都会经常遇到如下术语： ES3, ES5, ES6, ES7, ES8, ES2015, ES2016, ES2017, ECMAScript 2017, ECMAScript 2016, ECMAScript 2015 等等，那么它们是指代的是什么？</p><p>它们都是指代一个名为 ECMAScript 的标准。</p><p>JavaScript 就是基于这个标准实现的，ECMAScript 经常缩写为 ES。</p><p>除了 JavaScript 以外，其它基于 ECMAScript 实现语言包括：</p><ul><li>ActionScript ( Flash 脚本语言)，由于 Adobe 将于 2020 年末停止对 Flash 的支持而逐渐失去热度。</li><li>JScript (微软开发的脚本语言),在第一次浏览器大战最激烈的时期，JavaScript 只被Netscape所支持，微软必须为 Internet Explorer 构建自己的脚本语言。</li></ul><p>但是现在流传最广、影响最大的基于 ES 标准的语言实现无疑就是 JavaScript了</p><p>为啥要用这个奇怪的名字呢？Ecma International 是瑞士标准协会，负责制定国际标准。</p><p>JavaScript 被创建以后，经由 Netscape 和 Sun Microsystems 公司提交给欧洲计算机制造商协会进行标准化，被采纳的 ECMA-262 别名叫 ECMAScript。</p><blockquote><p>This press release by Netscape and Sun Microsystems (the maker of Java) might help figure out the name choice, which might include legal and branding issues by Microsoft which was in the committee, according to Wikipedia.</p></blockquote><p>IE9 之后微软的浏览器中就看不到对 JScript 这个命名的引用了，取而代之都统称为 JavaScript。</p><p>因此，截至201x，JavaScript 成为最流行的基于 ECMAScript 规范实现的语言。</p><h5 id="ECMAScript-当前的版本。"><a href="#ECMAScript-当前的版本。" class="headerlink" title="ECMAScript 当前的版本。"></a>ECMAScript 当前的版本。</h5><p>目前的最新的 ECMAScript 版本是 ES2018。</p><p>于 2018 年 6 月发布。</p><h5 id="TC39-是什么？"><a href="#TC39-是什么？" class="headerlink" title="TC39 是什么？"></a>TC39 是什么？</h5><p>TC39（Technical Committee 39）是一个推动 JavaScript 发展的委员会。</p><p>TC39的成员包括各个主流浏览器厂商以及业务与浏览器紧密相连的公司，其中包括 Mozilla，Google ，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。</p><p>每个标准版本提案都必须经过四个不同的阶段，这里有详细的解释。</p><h5 id="ES-Versions"><a href="#ES-Versions" class="headerlink" title="ES Versions"></a>ES Versions</h5><p>令我费解的是 ES 版本的命名依据有时根据迭代的版本号，有时却根据年份来进行命名。而这个命名的不确定性又使得人们更加容易混淆 JS/ES 这个两个概念😄。</p><p>在 ES2015 之前，ECMAScript 各个版本的命名规范通常与跟着标准的版本更新保持一致。因此，2009年 ECMAScript 规范更新以后的的正式版本是 ES5。</p><blockquote><p>Why does this happen? During the process that led to ES2015, the name was changed from ES6 to ES2015, but since this was done late, people still referenced it as ES6, and the community has not left the edition naming behind — the world is still calling ES releases by edition number.</p></blockquote><p>为什么会发生这一切？在ES2015诞生的过程中，名称由ES6更改为ES2015，但由于最终完成太晚，人们仍然称其为ES6，社区也没有将版本号完全抛之于后 — 世界仍然使用 ES 来定义版本号。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175944.png" alt=""></p><p>接下来，我们来深入了解 JavaScript 自 ES5 以来增加的特性。</p><h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><p>ES2015 之前, var 是唯一可以用来声明变量的语句。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面语句如果你遗漏了 var，那么你会把这个值（0）赋给一个未声明的变量，其中声明和未声明变量之间存在一些差异。</p><p>在现代浏览器开启严格模式时，给未声明的变量赋值会抛出 ReferenceError 异常，在较老的浏览器（或者禁用严格模式）的情况下，未声明的变量在执行赋值操作时会隐式的变为全局对象的属性。</p><p>当你声明一个变量却没有进行初始化，那么它的值直到你对它进行赋值操作之前都是 undefined 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="comment">//typeof a === 'undefined'</span></span><br></pre></td></tr></table></figure><p>你可以对一个变量进行多次重新声明，并覆盖它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>你也可以在一条声明语句中一次声明多个变量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>作用域是变量可访问的代码部分。</p><p>在函数之外用 var 声明的会分配给全局对象，这种变量可以在全局作用域中被访问到。而在函数内部声明的变量只能在函数局部作用域被访问到，这类似于函数参数。</p><p>在函数中定义的局部变量名如何跟全局变量重名，那么局部变量的优先级更高，在函数内无法访问到同名的全局变量。</p><p>需要注意的是，var 是没有块级作用域（标识符是一对花括号）的，但是 var 是有函数作用域的，所以在新创建的块级作用域或者是函数作用域里面声明变量会覆盖全局同名变量，因为 var 在这两种情况下没有创建新的作用域。</p><p>在函数内部，其中定义的任何变量在所有函数代码中都是可见的，因为JavaScript在执行代码之前实际上将所有变量都移到了顶层（被称为悬挂的东西）。 在函数的内部定义的变量在整个函数作用域中都是可见（可访问），即使变量是在函数体末尾被声明，但是仍然可以再函数体开头部分被引用，因为 JavaScript存在变量提升机制。为避免混淆，请在函数开头声明变量，养成良好的编码规范。</p><h4 id="Using-let"><a href="#Using-let" class="headerlink" title="Using let"></a>Using let</h4><p>let 是ES2015中引入的新功能，它本质上是具有块级作用域的 var 。它可以被当前作用域（函数以及块级作用域）以及子级作用域访问到。</p><p>现代 JavaScript 开发者在 let 和 var 的选择中可能会更倾向于前者。</p><blockquote><p>如果 let 看起来是一个很抽象的术语，当你阅读到 let color = ‘red’ 这一段，因为使用 let 定义了color 为红色，那么这一切就变的有意义了。</p></blockquote><p>在任何函数之外用 let 声明变量，和 var相反的是 它并不会创建全局变量。</p><h4 id="Using-const"><a href="#Using-const" class="headerlink" title="Using const"></a>Using const</h4><p>使用变量 var 或 let 声明的变量可以被重新赋值。 使用 const 声明的变量一经初始化，它的值就永远不能再改变，即不可重新被赋值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'test'</span></span><br></pre></td></tr></table></figure><p>我们不能再为 a 进行赋值操作。然而，a 如果它是一个具有属性或者方法的对象，那么我们可以改变它的属性或者方法。</p><p>const 并不意味着具有不可变性，只是保证用 const 声明的变量的引用地址不被变更。</p><p>类似于 let，const 也具有块级作用域。</p><p>现代 JavaScript 开发者在遇到不会进行二次赋值的变量声明时，应该尽量使用 const。</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数的引入极大的改变了代码的书写风格和一些工作机制。</p><p>在我看来，箭头函数很受开发者欢迎，现在很少在比较新的代码库中看到 function 关键字了，虽然它并未被废弃。</p><p>箭头函数看起来会更加的简洁，因为它允许你使用更短的语法来书写函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数体中只包含一条语句，你甚至可以省略大括号并直接书写这条语句：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> doSomething()</span><br></pre></td></tr></table></figure><p>参数在括号中传递：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function">(<span class="params">param1, param2</span>) =&gt;</span> doSomething(param1, param2)</span><br></pre></td></tr></table></figure><p>如果该函数只有一个参数，那么可以省略掉括号：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myFunction = param =&gt; doSomething(param)</span><br></pre></td></tr></table></figure><p>由于这种简短的语法，使得我们可以更便捷的使用比较简短的函数</p><h4 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h4><p>箭头函数支持隐式返回：可以正常的 return 一个返回值但是可以不使用 return 关键字。</p><p>隐式返回只在函数体内只包含一条语句的情况下生效：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'test'</span></span><br><span class="line">myFunction() <span class="comment">//'test'</span></span><br></pre></td></tr></table></figure><p>需要注意的一种情况，当返回一个对象时，记得将大括号括在括号中以避免产生歧义，误将其（大括号）解析为函数体的大括号。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">value</span>:<span class="string">'test'</span> &#125;)</span><br><span class="line">myFunction() <span class="comment">//&#123;value: 'test'&#125;</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h4><p>this 可能是一个很难掌握的概念，因为它会根据上下文而进行变化，并且会在不同的 JavaScript的模式（是否为严格模式）下表现出差异。</p><p>理解 this 这个概念对于箭头函数的使用很重要，因为与常规函数相比，箭头函数的表现非常不同。</p><p>对象的方法为常规函数时，方法中的this指向这个对象，因此可以这样做：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  model:<span class="string">'Fiesta'</span>,</span><br><span class="line">  manufacturer:<span class="string">'Ford'</span>,</span><br><span class="line">  fullName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.manufacturer&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 car.fullName() 会返回 “Ford Fiesta”。</p><p>如果上述方法使用是是箭头函数，由于箭头中的 this 的作用域继承自执行上下文，箭头函数自身不绑定 this，因此 this 的值将在调用堆栈中查找，因此在此代码 car.fullName() 中不会返回常规函数那样的结果，实际会返回字符串 “undefined undefined”：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  model:<span class="string">'Fiesta'</span>,</span><br><span class="line">  manufacturer:<span class="string">'Ford'</span>,</span><br><span class="line">  fullName:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.manufacturer&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，箭头函数不适合作为对象方法。</p><p>同样，箭头函数也不适合使用在作为创建构造函数，因为在实例化对象时会抛出 TypeError。</p><p>所以在不需要动态上下文时请使用常规函数。</p><p>当然，在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>)</span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// this === window</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>)</span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this === link</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Classes类"><a href="#Classes类" class="headerlink" title="Classes类"></a>Classes类</h4><p>JavaScript 实现继承的方式比较罕见：原型继承。原型继承虽然在我看来很棒，但与其它大多数流行的编程语言的继承实现机制不同，后者是基于类的。</p><p>因此 Java、Python 或其它语言的开发者很难理解原型继承的方式，因此 ECMAScript 委员会决定在原型继承之上实现 class 的语法糖，这样便于让其它基于类实现继承的语言的开发者更好的理解 JavaScript 代码。</p><p>注意：class 并没有对 JavaScript 底层做修改，你仍然可以直接访问对象原型。</p><h5 id="class-定义"><a href="#class-定义" class="headerlink" title="class 定义"></a>class 定义</h5><p>如下是一个 class 的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, I am '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class 具有一个标识符，我们可以使用 new ClassIdentifier() 来创建一个对象实例。</p><p>初始化对象时，调用 constructor方法，并将参数传递给此方法。</p><p>类声明语句中也可以增加类需要的一些原型方法。在这种情况下 hello 是 Person 类的一个原型方法，可以在这个类的对象实例上调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flavio = <span class="keyword">new</span> Person(<span class="string">'Flavio'</span>)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure><h4 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h4><p>一个子类可以 extend 另一个类，通过子类实例化出来的对象可以继承这两个类的所有方法。</p><p>如果子类中的方法与父类中的方法名重复，那么子类中的同名方法优先级更高：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">' I am a programmer.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> flavio = <span class="keyword">new</span> Programmer(<span class="string">'Flavio'</span>)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure><p>(上述代码会打印出：“Hello, I am Flavio. I am a programmer.”)</p><p>类没有显示的类变量声明，但你必须在初始化构造函数 constructor 中去初始化类成员变量。</p><p>在子类中，你可以通过调用super()引用父类。</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在类中，通常会把方法直接挂载到实例对象上，直接在实例对象上调用。</p><p>而静态方法则是直接使用类名来调用，而不是通过对象实例调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> genericHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.genericHello() <span class="comment">//Hello</span></span><br></pre></td></tr></table></figure><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>JavaScript 没有内置真正意义上的受保护的私有方法。</p><p>社区有解决方法，但我不会在这里做讲解。</p><h5 id="Getters-和-setters"><a href="#Getters-和-setters" class="headerlink" title="Getters 和 setters"></a>Getters 和 setters</h5><p>你可以通过增加方法 前缀 get 或者 set 创建一个 getter 和 setter，getter 和 setter会在你去获取特定值或者修改特定值的时候执行 get 或者 set内的相关方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只有 getter，该属性无法被设置，并且设置此属性的操作都会被忽略：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只有一个 setter，则可以更改该值，但不能从外部访问它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>函数 doSomething 接收一个 param1 参数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以给 param1 设定默认值，如果在调用函数时未传入参数，那么该参数自动设定未默认值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1 = <span class="string">'test'</span></span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这种机制同样适用于多个参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1 = <span class="string">'test'</span>, param2 = <span class="string">'test2'</span></span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如你的函数是一个具有特定属性的对象该怎么处理？</p><p>曾几何时，如果我们必须要取一个对象的特定属性值，为了做兼容处理（对象格式不正确），你必须在函数中添加一些代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colorize = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">    options = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> color = (<span class="string">'color'</span> <span class="keyword">in</span> options) ? options.color :<span class="string">'yellow'</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过解构，你可以给特定属性提供默认值，如此可以大大简化代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const colorize = (&#123; color = &apos;yellow&apos; &#125;) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在调用 colorize 函数时没有传递任何对象，我们同样可以得到一个默认对象作为参数以供使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spin = <span class="function">(<span class="params">&#123; color = <span class="string">'yellow'</span> &#125; = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串不同于 ES5 以前的版本，你可以用新颖的方式使用字符串。</p><p>这个语法看起来非常简便，只需要使用一个反引号替换掉单引号或双引号：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a_string = <span class="string">`something`</span></span><br></pre></td></tr></table></figure><p>这个用法是独一无二的，因为它提供了许多普通字符串所没有的功能，如下：</p><ul><li>它为定义多行字符串提供了一个很好的语法</li><li>它提供了一种在字符串中插入变量和表达式的简单方法</li><li>它允许您创建带有模板标签的DSL (DSL意味着领域特定语言，例如：就如同在 React 中使用 styled-components 定义你组件的 CSS 一样)</li></ul><p>下面让我们深入每个功能的细节。</p><h5 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h5><p>在 ES6 标准之前，创建跨越两行的字符串只能在一行的结尾使用 ‘’ 字符：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string =</span><br><span class="line">  <span class="string">'first part</span></span><br><span class="line"><span class="string">second part'</span></span><br></pre></td></tr></table></figure><p>这样使得你创建的字符串虽然跨越了两汉，但是渲染时仍然表现成一行：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">first part second part</span><br></pre></td></tr></table></figure><p>需要渲染为多行的话，需要在一行结尾添加 ‘ ’，比如这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string =</span><br><span class="line">  <span class="string">'first line</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">second line'</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">'first line</span></span><br><span class="line"><span class="string">'</span>+ <span class="string">'second line'</span></span><br></pre></td></tr></table></figure><p>模板字符串使得定义多行字符串变得更加简便。</p><p>一个模板字符串由一个反引号开始，你只需要按下回车键来创建新的一行，不需要插入特殊符号，最终的渲染效果如下所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`Hey</span></span><br><span class="line"><span class="string">this</span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">is awesome!`</span></span><br></pre></td></tr></table></figure><p>需要特别留意空格在这里是有特殊意义的，如果这样做的话：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`First</span></span><br><span class="line"><span class="string">                Second`</span></span><br></pre></td></tr></table></figure><p>那么它会创建出像下面的字符串：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">First</span><br><span class="line">                Second</span><br></pre></td></tr></table></figure><p>有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`</span></span><br><span class="line"><span class="string">First</span></span><br><span class="line"><span class="string">Second`</span>.trim()</span><br></pre></td></tr></table></figure><h5 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h5><p>模板字符串提供了插入变量和表达式的便捷方法</p><p>你只需要使用 ${…} 语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">var</span> = <span class="string">'test'</span></span><br><span class="line"><span class="keyword">const</span> string = <span class="string">`something <span class="subst">$&#123;<span class="keyword">var</span>&#125;</span>`</span> <span class="comment">//something test</span></span><br></pre></td></tr></table></figure><p>在 ${} 里面你可以加入任何东西，甚至是表达式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`something <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> string2 = <span class="string">`something <span class="subst">$&#123;foo() ? <span class="string">'x'</span> : <span class="string">'y'</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure><h5 id="Template-tags"><a href="#Template-tags" class="headerlink" title="Template tags"></a>Template tags</h5><p>标记模板可能是一个听起来不太有用的功能，但它实际上被许多流行的库使用，如 Styled Components 、Apollo 、GraphQL客户端/服务器库，因此了解它的工作原理至关重要。</p><p>在 Styled Components 模板标签中用于定义CSS字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 1.5em;</span></span><br><span class="line"><span class="string">  background-color: black;</span></span><br><span class="line"><span class="string">  color: white;</span></span><br></pre></td></tr></table></figure><p>在 Apollo 中，模板标签用于定义 GraphQL 查询模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = gql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面两个例子中的styled.button和gql模板标签其实都是函数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gql</span>(<span class="params">literals, ...expressions</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回一个字符串，可以是任意类型的计算结果。</p><p>字面量(literals)是一个包含了表达式插值的模板字面量的序列。 表达式(expressions)包含了所有的插值。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const string = `something $&#123;1 + 2 + 3&#125;`</span><br></pre></td></tr></table></figure><p>这个例子里面的字面量是由2个部分组成的序列。第1部分就是something，也就是第一个插值位置(${})之前的字符串，第2部分就是一个空字符串，从第1个插值结束的位置直到字符串的结束。</p><p>这个例子里面的表达式就是只包含1个部分的序列，也就是6。</p><p>举一个更复杂的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`something</span></span><br><span class="line"><span class="string">another <span class="subst">$&#123;<span class="string">'x'</span>&#125;</span></span></span><br><span class="line"><span class="string">new line <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">test`</span></span><br></pre></td></tr></table></figure><p>这个例子里面的字面量的序列里面，第1个部分是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="string">`something</span></span><br><span class="line"><span class="string">another `</span></span><br></pre></td></tr></table></figure><p>第2部分是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="string">`</span></span><br><span class="line"><span class="string">new line `</span></span><br></pre></td></tr></table></figure><p>第3部分是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="string">`</span></span><br><span class="line"><span class="string">test`</span></span><br></pre></td></tr></table></figure><p>这个例子里面的表达式包含了2个部分：x和6。</p><p>拿到了这些值的函数就可以对其做任意处理，这就是这个特性的威力所在。</p><p>比如最简单的处理就是字符串插值，把字面量和表达式拼接起来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interpolated = interpolate<span class="string">`I paid <span class="subst">$&#123;<span class="number">10</span>&#125;</span>€`</span></span><br></pre></td></tr></table></figure><p>插值的过程就是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interpolate</span>(<span class="params">literals, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> string = <span class="string">``</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, val] <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    string += literals[i] + val</span><br><span class="line">  &#125;</span><br><span class="line">  string += literals[literals.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>给定一个object，你可以抽取其中的一些值并且赋值给命名的变量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  firstName:<span class="string">'Tom'</span>,</span><br><span class="line">  lastName:<span class="string">'Cruise'</span>,</span><br><span class="line">  actor:<span class="literal">true</span>,</span><br><span class="line">  age:<span class="number">54</span>, <span class="comment">//made up</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">firstName</span>: name, age&#125; = person</span><br></pre></td></tr></table></figure><p>name和age就包含了对应的值。</p><p>这个语法同样可以用到数组当中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [first, second] = a</span><br></pre></td></tr></table></figure><p>下面这个语句创建了3个新的变量，分别取的是数组a的第0、1、4下标对应的值：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, second, , , fifth] = a</span><br></pre></td></tr></table></figure><h5 id="更强大的对象字面量"><a href="#更强大的对象字面量" class="headerlink" title="更强大的对象字面量"></a>更强大的对象字面量</h5><p>ES2015赋予了对象字面量更大的威力。</p><p>简化了包含变量的语法<br>原来的写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> something = <span class="string">'y'</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  something: something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> something = <span class="string">'y'</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>原型可以这样指定：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> anObject = &#123; <span class="attr">y</span>:<span class="string">'y'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  __proto__: anObject</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">super</span>()</span><br><span class="line"><span class="keyword">const</span> anObject = &#123; <span class="attr">y</span>:<span class="string">'y'</span>, <span class="attr">test</span>:<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'zoo'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  __proto__: anObject,</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.test() + <span class="string">'x'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">x.test() <span class="comment">//zoox</span></span><br></pre></td></tr></table></figure><h5 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'_'</span> + <span class="string">'b'</span>]:<span class="string">'z'</span></span><br><span class="line">&#125;</span><br><span class="line">x.a_b <span class="comment">//z</span></span><br></pre></td></tr></table></figure><h4 id="For-of循环"><a href="#For-of循环" class="headerlink" title="For-of循环"></a>For-of循环</h4><p>2009年的ES5引入了forEach()循环。虽然很好用，但是它跟for循环一样，没法break。</p><p>ES2015引入了<strong>for-of</strong> 循环，就是在forEach的基础上加上了break的功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterate over the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get the index as well, using `entries()`</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [i, v] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">//index</span></span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留意一下const的使用。这个循环在每次迭代中都会创建一个新的作用域，所以我们可以使用const来代替let。</p><p>它跟for…in的区别在于：</p><ul><li>for…of遍历属性值</li><li>for…in遍历属性名</li></ul><h4 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h4><p>promise的一般定义： 它是一个代理，通过它可以最终得到一个值.</p><p>Promise是处理异步代码的一种方式，可以少写很多回调。</p><p>异步函数是建立在promise API上面的，所以理解Promise是一个基本的要求。</p><h5 id="promise的原理简述"><a href="#promise的原理简述" class="headerlink" title="promise的原理简述"></a>promise的原理简述</h5><p>一个promise被调用的时候，首先它是处于pending状态。在promise处理的过程中，调用的函数（caller）可以继续执行，直到promise给出反馈。</p><p>此时，调用的函数等待的promise结果要么是resolved状态，要么是rejected状态。但是由于JavaScript是异步的，所以promise处理的过程中，函数会继续执行。</p><h5 id="为什么JS-API使用promises"><a href="#为什么JS-API使用promises" class="headerlink" title="为什么JS API使用promises?"></a>为什么JS API使用promises?</h5><p>除了你的代码和第三方库的代码之外，promise在用在现代的Web API中，比如：</p><ul><li>电池API</li><li>Fetch API</li><li>Service Workers</li></ul><p>在现代的JavaScript中，不使用promise是不太可能的，所以我们来深入研究下promise吧。</p><h5 id="创建一个promise"><a href="#创建一个promise" class="headerlink" title="创建一个promise"></a>创建一个promise</h5><p>Promise API暴露了一个Promise构造函数，可以通过new Promise()来初始化：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> done = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">const</span> workDone = <span class="string">'Here is the thing I built'</span></span><br><span class="line">    resolve(workDone)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> why = <span class="string">'Still working on something else'</span></span><br><span class="line">    reject(why)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>promise会检查done这个全局变量，如果为true，就返回一个resolved promise，否则就返回一个rejected promise。</p><p>通过resolve和reject，我们可以得到一个返回值，返回值可以是字符串也可以是对象。</p><h5 id="使用一个promise"><a href="#使用一个promise" class="headerlink" title="使用一个promise"></a>使用一个promise</h5><p>上面讲了怎么创建一个promise，下面就讲怎么使用（consume）这个promise。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> checkIfItsDone = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  isItDoneYet</span><br><span class="line">    .then(<span class="function"><span class="params">ok</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ok)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行checkIfItsDone()方法时，会执行isItDoneYet()这个promise，并且等待它resolve的时候使用then回调，如果有错误，就用catch回调来处理。</p><h5 id="链式promise"><a href="#链式promise" class="headerlink" title="链式promise"></a>链式promise</h5><p>一个promise可以返回另一个promise，从而创建promise链条（chain）。</p><p>一个很好的例子就是Fetch API，它是基于XMLHttpRequest API的一个上层API，我们可以用它来获取资源，并且在获取到资源的时候链式执行一系列promise。</p><p>Fetch API是一个基于promise的机制，调用fetch()相当于使用new Promise()来声明我们自己的promise。</p><p>链式promise的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> status = <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> json = <span class="function"><span class="params">response</span> =&gt;</span> response.json()</span><br><span class="line">fetch(<span class="string">'/todos.json'</span>)</span><br><span class="line">  .then(status)</span><br><span class="line">  .then(json)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request failed'</span>, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们调用fetch()，从根目录的todos.json文件中获取一系列的TODO项目，并且创建一个链式promise。</p><p>运行fetch()方法会返回一个response，它包含很多属性，我们从中引用如下属性：</p><ul><li>status, 一个数值，表示HTTP状态码</li><li>statusText, 一个状态消息，当请求成功的时候返回OK</li><li>response还有一个json()方法，它返回一个promise，返回内容转换成JSON后的结果。</li></ul><p>所以这些promise的调用过程就是：第一个promise执行一个我们定义的status()方法，检查response status，判断是否一个成功的响应(status在200和299之间)，如果不是成功的响应，就reject这个promise。</p><p>这个reject操作会导致整个链式promise跳过后面的所有promise直接到catch()语句，打印Request failed和错误消息。</p><p>如果这个promise成功了，它会调用我们定义的json()函数。因为前面的promise成功之后返回的response对象，我们可以拿到并作为第2个promise的参数传入。</p><p>在这个例子里面，我们返回了JSON序列化的数据，所以第3个promise直接接收这个JSON：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们把它打印到console。</p><h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><p>在上一节的的例子里面，我们有一个catch接在链式promise后面。</p><p>当promise链中的任意一个出错或者reject的时候，就会直接跳到promise链后面最近的catch()语句。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'Error'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="级联错误"><a href="#级联错误" class="headerlink" title="级联错误"></a>级联错误</h5><p>如果在catch()里面抛出一个错误，你可以在后面接上第二个catch()来处理这个错误，以此类推。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="组织多个promise"><a href="#组织多个promise" class="headerlink" title="组织多个promise"></a>组织多个promise</h4><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>如果你要同时完成不同的promise,可以用Promise.all()来声明一系列的promise，然后当它们全部resolve的时候再执行一些操作。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = fetch(<span class="string">'/something.json'</span>)</span><br><span class="line"><span class="keyword">const</span> f2 = fetch(<span class="string">'/something2.json'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([f1, f2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Array of results'</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>结合ES2015的解构赋值语法，你可以这样写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([f1, f2]).then(<span class="function">(<span class="params">[res1, res2]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Results'</span>, res1, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然这不限于使用fetch， 这适用于任何promise.</p><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()运行所有传递进去的promise，但是只要有其中一个resolve了，就会运行回调函数，并且只执行一次回调，回调的参数就是第一个resolve的promise返回的结果。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseOne = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">500</span>, <span class="string">'one'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promiseTwo = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'two'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.race([promiseOne, promiseTwo]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// 'two'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>ES Module是用于处理模块的ECMAScript标准。</p><p>虽然 Node.js 多年来一直使用 CommonJS标准，但浏览器却从未有过模块系统，因为模块系统的决策首先需要 ECMAScript 标准化后才由浏览器厂商去实施实现。</p><p>这个标准化已经完成在 ES2015中，浏览器也开始实施实现这个标准，大家试图保持一致，以相同的方式工作。现在 ES Module 可以在 Chrome Safari Edge 和 Firefox（从60版本开始） 中使用。</p><p>模块非常酷，他们可以让你封装各种各样的功能，同时将这些功能作为库暴露给其它 JavaScript 文件使用。</p><h5 id="ES-模块语法"><a href="#ES-模块语法" class="headerlink" title="ES 模块语法"></a>ES 模块语法</h5><p>引入模块的语法:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">import package from 'module-name'</span><br></pre></td></tr></table></figure><p>CommonJS 则是这样使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> package = <span class="built_in">require</span>(<span class="string">'module-name'</span>)</span><br></pre></td></tr></table></figure><p>一个模块是一个 JavaScript 文件，这个文件使用 export 关键字 导出 一个或多个值（对象、函数或者变量）。例如，下面这个模块提供了一个将字符串变成大写形式的函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uppercase.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure><p>在这个例子中，这个模块定义了唯一一个 default export，因此可以是一个匿名函数。否则，需要一个名称来和其它 导出 做区分。</p><p>现在，任何其它的 JavaScript 模块 可以通过 import 导入 uppercase.js 的这个功能。</p><p>一个 HTML 页面可以通过使用了特殊的 type=module 属性的 <code>&lt;script&gt;</code> 标签添加一个模块。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意: 这个模块导入的行为就像 <em>defer</em> 脚本加载一样。具体可以看 efficiently load JavaScript with defer and async</p></blockquote><p>需要特别注意的是，任何通过 type=”module” 载入的脚本会使用 严格模式 加载。</p><p>在这个例子中，uppercase.js 模块定义了一个 default export，因此当我们在导入它的时候，我们可以给他起一个任何我们喜欢的名字：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> toUpperCase <span class="keyword">from</span> <span class="string">'./uppercase.js'</span></span><br></pre></td></tr></table></figure><p>同时我们可以这样使用它:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">toUpperCase(<span class="string">'test'</span>) <span class="comment">//'TEST'</span></span><br></pre></td></tr></table></figure><p>你也可以通过一个绝对路径来导入模块，下面是一个引用来自其它域底下定义的模块的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> toUpperCase <span class="keyword">from</span> <span class="string">'https://flavio-es-modules-example.glitch.me/uppercase.js'</span></span><br></pre></td></tr></table></figure><p>下面同样是一些合法的 import语法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'/uppercase.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'../uppercase.js'</span></span><br></pre></td></tr></table></figure><p>下面是错误的使用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'uppercase.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'utils/uppercase.js'</span></span><br></pre></td></tr></table></figure><p>因为这里既不是使用绝对地址，也不是使用的相对地址。</p><h5 id="其它的-import-export-语法"><a href="#其它的-import-export-语法" class="headerlink" title="其它的 import/export 语法"></a>其它的 import/export 语法</h5><p>我们了解了上面的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure><p>这里生成了一个 default export。然而，你可以通过下面的语法在一个文件里面 导出 多个功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> &#123; a, b, c &#125;</span><br></pre></td></tr></table></figure><p>另外一个模块可以使用下面的方式 import 导入所有：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure><p>你也可以通过解构赋值的方式仅仅 import 导出一部分：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure><p>为了方便，你还可以使用 as 重命名任何 import 的东西：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, b <span class="keyword">as</span> two &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure><p>你可以导入模块中的默认出口以及通过名称导入任何非默认的出口：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><p>这是一篇关于 ES 模块的文章，可以看一下： <a href="https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html" target="_blank" rel="noopener">https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html</a></p><h4 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS(跨域资源共享)"></a>CORS(跨域资源共享)</h4><p>进行远程获取模块的时候是遵循 CORS 机制的。这意味着当你引用远程模块的时候，必须使用合法的 CORS 请求头来允许跨域访问（例如：Access-Control-Allow-Origin: *）。</p><h5 id="对于不支持模块的浏览器应该怎么做？"><a href="#对于不支持模块的浏览器应该怎么做？" class="headerlink" title="对于不支持模块的浏览器应该怎么做？"></a>对于不支持模块的浏览器应该怎么做？</h5><p>结合 type=”module”、nomodule 一起使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"module.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script nomodule src=<span class="string">"fallback.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="包装模块"><a href="#包装模块" class="headerlink" title="包装模块"></a>包装模块</h5><p>ES 模块是现代浏览器中的一大特性。这些特性是 ES6 规范中的一部分，要在浏览器中全部实现这些特性的路还很漫长。</p><p>我们现在就能使用它们！但是我们同样需要知道，有一些模块会对我们的页面性能产生性能影响。因为浏览器必须要在运行时执行它们。</p><p>Webpack 可能仍然会被大量使用，即使 ES 模块可以在浏览器中执行。但是语言内置这个特性对于客户端和 nodejs 在使用模块的时候是一种巨大的统一。</p><h4 id="新的字符串方法"><a href="#新的字符串方法" class="headerlink" title="新的字符串方法"></a>新的字符串方法</h4><p>任何字符串有了一些实例方法：</p><ul><li>repeat()</li><li>codePointAt()</li><li>repeat()</li></ul><p>根据指定的次数重复字符串：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Ho'</span>.repeat(<span class="number">3</span>) <span class="comment">//'HoHoHo'</span></span><br></pre></td></tr></table></figure><p>没有提供参数以及使用 0 作为参数的时候返回空字符串。如果给一个负数参数则会得到一个 RangeError 的错误。</p><h5 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h5><p>这个方法能用在处理那些需要 2 个 UTF-16 单元表示的字符上。</p><p>使用 charCodeAt 的话，你需要先分别得到两个 UTF-16 的编码然后结合它们。但是使用 codePointAt() 你可以直接得到整个字符。</p><p>下面是一个例子，中文的 “𠮷” 是由两个 UTF-16 编码组合而成的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">//d842</span></span><br><span class="line"><span class="string">"𠮷"</span>.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>) <span class="comment">//dfb7</span></span><br></pre></td></tr></table></figure><p>如果你将两个 unicode 字符组合起来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span> <span class="comment">//"𠮷"</span></span><br></pre></td></tr></table></figure><p>你也可以用 codePointAt() 得到同样的结果:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.codePointAt(<span class="number">0</span>) <span class="comment">//20bb7</span></span><br></pre></td></tr></table></figure><p>如果你将得到的 unicode 编码组合起来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span> <span class="comment">//"𠮷"</span></span><br></pre></td></tr></table></figure><p>更多关于 Unicode 的使用方法，参考我的Unicode guide。</p><h4 id="新的对象方法"><a href="#新的对象方法" class="headerlink" title="新的对象方法"></a>新的对象方法</h4><p>ES2015 在 Object 类下引入了一些静态方法：</p><ul><li>Object.is() 确定两个值是不是同一个</li><li>Object.assign() 用来浅拷贝一个对象</li><li>Object.setPrototypeOf 设置一个对象的原型</li><li>Object.is()</li></ul><p>这个方法用来帮助比较对象的值：</p><p>使用方式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(a, b)</span><br></pre></td></tr></table></figure><p>返回值在下列情况之外一直是 false：</p><ul><li>a 和 b 是同一个对象</li><li>a 和 b 是相等的字符串(用同样的字符组合在一起的字符串是相等的)</li><li>a 和 b 是相等的数字</li><li>a 和 b 都是 undefined, null, NaN, true 或者都是 false</li><li>0 和 -0 在 JavaScript 里面是不同的值, 所以对这种情况要多加小心（例如在比较之前，使用 + 一元操作符将所有值转换成 +0）。</li></ul><h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>在 ES2015 版本中引入，这个方法拷贝所有给出的对象中的可枚举的自身属性到另一个对象中。</p><p>这个 API 的基本用法是创建一个对象的浅拷贝。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copied = <span class="built_in">Object</span>.assign(&#123;&#125;, original)</span><br></pre></td></tr></table></figure><p>作为浅拷贝，值会被复制，对象则是拷贝其引用（不是对象本身），因此当你修改了源对象的一个属性值，这个修改也会在拷贝出的对象中生效，因为内部引用的对象是相同的。:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;</span><br><span class="line">  name:<span class="string">'Fiesta'</span>,</span><br><span class="line">  car:&#123;</span><br><span class="line">    color:<span class="string">'blue'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copied = <span class="built_in">Object</span>.assign(&#123;&#125;, original)</span><br><span class="line">original.name = <span class="string">'Focus'</span></span><br><span class="line">original.car.color = <span class="string">'yellow'</span></span><br><span class="line">copied.name <span class="comment">//Fiesta</span></span><br><span class="line">copied.car.color <span class="comment">//yellow</span></span><br></pre></td></tr></table></figure><p>我之前提到过，源对象可以是一个或者多个:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wisePerson = &#123;</span><br><span class="line">  isWise:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foolishPerson = &#123;</span><br><span class="line">  isFoolish:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wiseAndFoolishPerson = <span class="built_in">Object</span>.assign(&#123;&#125;, wisePerson, foolishPerson)</span><br><span class="line"><span class="built_in">console</span>.log(wiseAndFoolishPerson) <span class="comment">//&#123; isWise: true, isFoolish: true &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf()</span><br></pre></td></tr></table></figure><p>设置一个对象的原型。可以接受两个参数：对象以及原型。</p><p>使用方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  isAnimal:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mammal = &#123;</span><br><span class="line">  isMammal:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">mammal.__proto__ = animal</span><br><span class="line">mammal.isAnimal <span class="comment">//true</span></span><br><span class="line"><span class="keyword">const</span> dog = <span class="built_in">Object</span>.create(animal)</span><br><span class="line">dog.isAnimal  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.isMammal)  <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(dog, mammal)</span><br><span class="line">dog.isAnimal <span class="comment">//true</span></span><br><span class="line">dog.isMammal <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h4><p>你可以展开一个数组、一个对象甚至是一个字符串，通过使用展开操作符 …。</p><p>让我们以数组来举例，给出：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>你可以使用下面的方式创建出一个新的数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [...a, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>你也可以像下面这样创建一个数组的拷贝：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = [...a]</span><br></pre></td></tr></table></figure><p>这中方式对于对象仍然有效。使用下面的方式克隆一个对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = &#123; ...oldObj &#125;</span><br></pre></td></tr></table></figure><p>用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hey = <span class="string">'hey'</span></span><br><span class="line"><span class="keyword">const</span> arrayized = [...hey] <span class="comment">// ['h', 'e', 'y']</span></span><br></pre></td></tr></table></figure><p>这个操作符有一些非常有用的应用。其中最重要的一点就是以一种非常简单的方式使用数组作为函数参数的能力：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">foo, bar</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">f(...a)</span><br></pre></td></tr></table></figure><p>（在之前的语法规范中，你只能通过 f.apply(null, a) 的方式来实现，但是这种方式不是很友好和易读。）</p><p>剩余参数（rest element）在和数组解构（array destructuring）搭配使用的时候非常有用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure><p>下面是展开元素 （spread elements）:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> a + b + c + d + e</span><br><span class="line"><span class="keyword">const</span> sum = sum(...numbers)</span><br></pre></td></tr></table></figure><p>ES2018 引入了 剩余属性 ，同样的操作符但是只能用在对象上。</p><h4 id="剩余属性（Rest-properties）"><a href="#剩余属性（Rest-properties）" class="headerlink" title="剩余属性（Rest properties）:"></a>剩余属性（Rest properties）:</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; first, second, ...others &#125; = &#123;</span><br><span class="line">  first:<span class="number">1</span>,</span><br><span class="line">  second:<span class="number">2</span>,</span><br><span class="line">  third:<span class="number">3</span>,</span><br><span class="line">  fourth:<span class="number">4</span>,</span><br><span class="line">  fifth:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">second <span class="comment">// 2</span></span><br><span class="line">others <span class="comment">// &#123; third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure><p>属性展开（Spread properties）允许我们结合跟在 … 操作符之后对象的属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = &#123; first, second, ...others &#125;</span><br><span class="line">items <span class="comment">//&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一个 Set 数据结构允许我们在一个容器里面增加数据。</p><p>一个 Set 是一个对象或者基础数据类型（strings、numbers或者booleans）的集合，你可以将它看作是一个 Map，其中值作为映射键，map 值始终为 true。</p><h5 id="初始化一个-Set"><a href="#初始化一个-Set" class="headerlink" title="初始化一个 Set"></a>初始化一个 Set</h5><p>Set 可以通过下面的方式初始化：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure><h5 id="向-Set-中添加一项"><a href="#向-Set-中添加一项" class="headerlink" title="向 Set 中添加一项"></a>向 Set 中添加一项</h5><p>你可以使用 add 方法向 Set 中添加项：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="string">'one'</span>)</span><br><span class="line">s.add(<span class="string">'two'</span>)</span><br></pre></td></tr></table></figure><p>Set 仅会存贮唯一的元素，因此多次调用 s.add(‘one’) 不会重复添加新的元素。</p><p>你不可以同时向 set 中加入多个元素。你需要多次调用 add() 方法。</p><h5 id="检查元素是否在-set-中"><a href="#检查元素是否在-set-中" class="headerlink" title="检查元素是否在 set 中"></a>检查元素是否在 set 中</h5><p>我们可以通过下面的方式检查元素是否在 set 中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.has(<span class="string">'one'</span>) <span class="comment">//true</span></span><br><span class="line">s.has(<span class="string">'three'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h5 id="从-set-中删除一个元素："><a href="#从-set-中删除一个元素：" class="headerlink" title="从 set 中删除一个元素："></a>从 set 中删除一个元素：</h5><p>使用 delete() 方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.delete(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure><h5 id="确定-set-中元素的数量"><a href="#确定-set-中元素的数量" class="headerlink" title="确定 set 中元素的数量"></a>确定 set 中元素的数量</h5><p>使用 size 属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.size</span><br></pre></td></tr></table></figure><h5 id="删除-set-中的全部元素"><a href="#删除-set-中的全部元素" class="headerlink" title="删除 set 中的全部元素"></a>删除 set 中的全部元素</h5><p>使用 clear() 方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure><h5 id="对-set-进行迭代"><a href="#对-set-进行迭代" class="headerlink" title="对 set 进行迭代"></a>对 set 进行迭代</h5><p>使用 keys() 或者 values() 方法 - 它们等价于下面的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entries() 方法返回一个迭代器，你可以这样使用它：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const i = s.entries()</span><br><span class="line">console.log(i.next())</span><br></pre></td></tr></table></figure><p>调用 i.next() 将会以 { value, done = false } 对象的形式返回每一个元素，直到迭代结束，这时 done 是 true。</p><p>你也可以调用 set 的 forEach() 方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.forEach(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure><p>或者你就直接使用 for..of 循环吧：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用一些初始值初始化一个-set"><a href="#使用一些初始值初始化一个-set" class="headerlink" title="使用一些初始值初始化一个 set"></a>使用一些初始值初始化一个 set</h5><p>你可以使用一些值初始化一个 set：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>将 set 转换为一个数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...s.keys()]</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> a = [...s.values()]</span><br></pre></td></tr></table></figure><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>一个 WeakSet 是一个特殊的 Set.</p><p>在 set 中，元素不会被 gc（垃圾回收）。一个 weakSet 让它的所有元素都是可以被 gc 的。weakSet 中的每个键都是一个对象。当这个对象的引用消失的时候，对应的值就可以被 gc 了。</p><p>下面是主要的不同点：</p><ul><li>WeakSet 不可迭代</li><li>你不能清空 weakSet 中的所有元素</li><li>不能够得到 weakSet 的大小</li></ul><p>一个 weakSet 通常是在框架级别的代码中使用，仅仅暴露了下面的方法：</p><ul><li>add()</li><li>has()</li><li>delete()</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>一份map结构的数据允许我们建立数据和key的关系</p><h5 id="在ES6之前"><a href="#在ES6之前" class="headerlink" title="在ES6之前"></a>在ES6之前</h5><p>在引入Map之前，开发者通常把对象(Object)当Map使用，把某个object或value值与指定的key进行关联:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;&#125;</span><br><span class="line">car[<span class="string">'color'</span>] = <span class="string">'red'</span></span><br><span class="line">car.owner = <span class="string">'Flavio'</span></span><br><span class="line"><span class="built_in">console</span>.log(car[<span class="string">'color'</span>]) <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(car.color) <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(car.owner) <span class="comment">//Flavio</span></span><br><span class="line"><span class="built_in">console</span>.log(car[<span class="string">'owner'</span>]) <span class="comment">//Flavio</span></span><br></pre></td></tr></table></figure><h5 id="引入Map之后"><a href="#引入Map之后" class="headerlink" title="引入Map之后"></a>引入Map之后</h5><p>ES6引入了Map数据结构，它为我们处理这种数据结构提供了一种合适的工具</p><p>Map的初始化:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br></pre></td></tr></table></figure><p>添加条目到Map中</p><p>你可以通过set()方法把条目设定到map中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m.set(&apos;color&apos;, &apos;red&apos;)</span><br><span class="line">m.set(&apos;age&apos;, 2)</span><br></pre></td></tr></table></figure><p>通过key值从map中获取条目</p><p>你可以通过get()方法从map中取出条目:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> color = m.get(<span class="string">'color'</span>)</span><br><span class="line"><span class="keyword">const</span> age = m.get(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure><p>通过key值从map中删除条目</p><p>使用delete()方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.delete(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure><p>从map中删除所有条目</p><p>使用clear()方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.clear()</span><br></pre></td></tr></table></figure><p>通过key值检查map中是否含有某个条目</p><p>使用has()方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hasColor = m.has(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure><p>获取map中的条目数量</p><p>使用 size 属性:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> size = m.size</span><br></pre></td></tr></table></figure><p>用value值初始化一个map</p><p>你可以用一组value来初始化一个map：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'color'</span>, <span class="string">'red'</span>], [<span class="string">'owner'</span>, <span class="string">'Flavio'</span>], [<span class="string">'age'</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p>Map 的key值</p><p>任何值(对象，数组，字符串，数字)都可以作为一个map的value值(使用key-value键值的形式)，任何值也可以用作key，即使是object对象。</p><p>如果你想通过get()方法从map中获取不存在的key，它将会返回undefined</p><p>在真实世界中你几乎不可能找到的诡异情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="literal">NaN</span>, <span class="string">'test'</span>)</span><br><span class="line">m.get(<span class="literal">NaN</span>) <span class="comment">//test</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(+<span class="number">0</span>, <span class="string">'test'</span>)</span><br><span class="line">m.get(<span class="number">-0</span>) <span class="comment">//test</span></span><br></pre></td></tr></table></figure><p>使用Iterate迭代器获取map的keys值</p><p>Map提供了keys()方法，通过该方法我们可以迭代出所有的key值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Iterate迭代器获取map的values值</p><p>Map提供了values()方法，通过该方法我们可以迭代出所有的value值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Iterate迭代器获取key-value组成的键值对</p><p>Map提供了entries()方法，通过该方法我们可以迭代出所有的键值对:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法还可以简化为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将map的keys值转换为数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...m.keys()]</span><br></pre></td></tr></table></figure><p>将map的values值转换为数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...m.values()]</span><br></pre></td></tr></table></figure><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap是一种特殊的Map</p><p>在一个map对象中，定义在其上数据永远不会被垃圾回收，WeakMap替而代之的是它允许在它上面定义的数据可以自由的被垃圾回收走，WeakMap的每一个key都是一个对象，当指向该对象的指针丢失，与之对应的value就会被垃圾回收走。</p><p>这是WeakMap的主要不同处：</p><ul><li>你不可以在WeakMap上迭代keys值和values值(或者key-value键值对)</li><li>你不可以从WeakMap上清除所有条目</li></ul><h5 id="你不可以获取WeakMap的大小"><a href="#你不可以获取WeakMap的大小" class="headerlink" title="你不可以获取WeakMap的大小"></a>你不可以获取WeakMap的大小</h5><p>WeakMap提供了如下几种方法，这些方法的使用和在Map中一样：</p><ul><li>get(k)</li><li>set(k, v)</li><li>has(k)</li><li>delete(k)</li></ul><p>关于WeakMap的用例不如Map的用例那么明显，你可能永远也不会在哪里会用到它，但从实际出发，WeakMap可以构建不会干扰到垃圾回收机制的内存敏感性缓存，还可以满足封装的严谨性及信息的隐藏性需求。</p><h4 id="Generators生成器"><a href="#Generators生成器" class="headerlink" title="Generators生成器"></a>Generators生成器</h4><p>Generators是一种特殊的函数，它能够暂停自身的执行并在一段时间后再继续运行，从而允许其它的代码在此期间运行(有关该主题的详细说明，请参阅完整的“javascript生成器指南”)。</p><p>Generators的代码决定它必须等待，因此它允许队列中的其它代码运行，并保留“当它等待的事情”完成时恢复其操作的权力。</p><p>所有这一切都是通过一个简单的关键字“yield`”完成的。当生成器包含该关键字时，将停止执行。</p><p>generator生成器可以包含许多yield关键字，从而使自己能多次停止运行，它是由*function关键字标识(不要将其与C、C++或Go等低级语言中使用的取消指针引用操作符混淆)。</p><p>Generators支持JavaScript中全新的编程范式，包括：</p><ul><li>在generator运行时支持双向通信</li><li>不会“冻结”长期运行在程序中的while循环</li></ul><p>这里有一个解释generator如何工作的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">calculator</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doubleThat = <span class="number">2</span> * (<span class="keyword">yield</span> (input / <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">var</span> another = <span class="keyword">yield</span> (doubleThat)</span><br><span class="line">  <span class="keyword">return</span> (input * doubleThat * another)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先初始化它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calc = calculator(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>然后我们在generator中开始进行iterator迭代：</p><h5 id="calc-next"><a href="#calc-next" class="headerlink" title="calc.next()"></a>calc.next()</h5><p>第一个迭代器开始了迭代，代码返回如下object对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">false</span></span><br><span class="line">  value:<span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程如下：代码运行了函数，并把input=10传入到生成器构造函数中，该函数一直运行直到抵达yield，并返回yield输出的内容: input / 2 = 5，因此，我们得到的值为5，并告知迭代器还没有done(函数只是暂停了)。</p><p>在第二个迭代处，我们输入7：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">calc.next(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>然后我们得到了结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">false</span></span><br><span class="line">  value:<span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7被作为doubleThat的值，注意：你可能会把input/2作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2.</p><p>然后，我们得到第二个yield的值，它返回doubleThat，因此返回值为14。</p><p>在下一个，也是最后一个迭代器，我们输入100</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">calc.next(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>这样我们得到:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">true</span></span><br><span class="line">  value:<span class="number">14000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当迭代器完成时(没有更多的yield关键字)，我们返回input <em>doubleThat</em> another，这相当于10 <em>14</em>100。</p><p>这些都是在2015年的ES2015引入的特性，现在我们深入了解下ES2016，它的作用域范围更小。</p><h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h4><p>该特性引入了一种更简洁的语法，同来检查数组中是否包含指定元素。</p><p>对于ES6及更低版本，想要检查数组中是否包含指定元素，你不得不使用indexOf方法，它检查数组中的索引，如果元素不存在，它返回-1，由于-1被计算为true，你需对其进行取反操作，例子如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="number">1</span>,<span class="number">2</span>].indexOf(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not found'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ES7引入的新特性，我们可以如此做：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="number">1</span>,<span class="number">2</span>].includes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not found'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求幂运算符"><a href="#求幂运算符" class="headerlink" title="求幂运算符"></a>求幂运算符</h4><p>求幂运算符**相当于Math.pow()方法，但是它不是一个函数库，而是一种语言机制：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">4</span>, <span class="number">2</span>) == <span class="number">4</span> ** <span class="number">2</span></span><br></pre></td></tr></table></figure><p>对于需要进行密集数学运算的程序来说，这个特性是个很好的增强，在很多语言中，**运算符都是标准(包括Python、Ruby、MATLAB、Perl等其它多种语言)。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190318/29ddbe9d6db84099ba7c67597ac82c0b.png" alt="img"></p><p>这些都是2016年引入的特性，现在让我们进入2017年。</p><h4 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h4><p>字符串填充的目的是给字符串添加字符，以使其达到指定长度。</p><p>ES2017引入了两个String方法：padStart()和padEnd()。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">padStart(targetLength [, padString])</span><br><span class="line">padEnd(targetLength [, padString])</span><br></pre></td></tr></table></figure><p>使用例子：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428180419.png" alt=""></p><h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p>该方法返回一个数组，数组包含了对象自己的所有属性，使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.values(person) <span class="comment">// ['Fred', 87]</span></span><br></pre></td></tr></table></figure><p>Object.values()也可以作用于数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Fred'</span>, <span class="string">'Tony'</span>]</span><br><span class="line"><span class="built_in">Object</span>.values(people) <span class="comment">// ['Fred', 'Tony']</span></span><br></pre></td></tr></table></figure><h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><p>该方法返回一个数组，数组包含了对象自己的所有属性键值对，是一个[key, value]形式的数组，使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(person) <span class="comment">// [['name', 'Fred'], ['age', 87]]</span></span><br></pre></td></tr></table></figure><p>Object.entries()也可以作用于数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Fred'</span>, <span class="string">'Tony'</span>]</span><br><span class="line"><span class="built_in">Object</span>.entries(people) <span class="comment">// [['0', 'Fred'], ['1', 'Tony']]</span></span><br></pre></td></tr></table></figure><h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>该方法返回自己(非继承)的所有属性描述符，JavaScript中的任何对象都有一组属性，每个属性都有一个描述符，描述符是属性的一组属性(attributes)，由以下部分组成：</p><ul><li>value: 熟悉的value值</li><li>writable: 属性是否可以被更改</li><li>get: 属性的getter函数, 当属性读取时被调用</li><li>set: 属性的setter函数, 当属性设置值时被调用</li><li>configurable: 如果为false, 不能删除该属性，除了它的value值以为，也不能更改任何属性。</li><li>enumerable: 该属性是否能枚举</li></ul><p>Object.getOwnPropertyDescriptors(obj)接受一个对象，并返回一个带有描述符集合的对象。</p><h4 id="In-what-way-is-this-useful"><a href="#In-what-way-is-this-useful" class="headerlink" title="In what way is this useful?"></a>In what way is this useful?</h4><p>ES6给我们提供了Object.assign()方法，它从一个一个或多个对象中复制所有可枚举的属性值，并返回一个新对象。</p><p>但是，这也存在着一个问题，因为它不能正确的复制一个具有非默认属性值的属性。</p><p>如果对象只有一个setter，那么它就不会正确的复制到一个新对象上，使用Object.assign()进行如下操作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person1 = &#123;</span><br><span class="line">    set name(newName) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将不会起作用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(person2, person1)</span><br></pre></td></tr></table></figure><p>但这将会起作用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person3 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person3,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(person1))</span><br></pre></td></tr></table></figure><p>通过一个简单的console控制台，你可以查看以下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person1.name = <span class="string">'x'</span></span><br><span class="line"><span class="string">"x"</span></span><br><span class="line">person2.name = <span class="string">'x'</span></span><br><span class="line">person3.name = <span class="string">'x'</span></span><br><span class="line"><span class="string">"x"</span></span><br></pre></td></tr></table></figure><p>person2没有setter，它没能复制进去，对象的浅复制限定也出现在Object.create()方法中。</p><h4 id="尾逗号"><a href="#尾逗号" class="headerlink" title="尾逗号"></a>尾逗号</h4><p>该特性允许在函数定义时有尾逗号，在函数使用时可以有尾逗号：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">var1, var2,</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">doSomething(<span class="string">'test2'</span>, <span class="string">'test2'</span>,)</span><br></pre></td></tr></table></figure><p>该改变将鼓励开发者停止“在一行开始时写逗号”的丑陋习惯</p><h4 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h4><p>JavaScript在很短的时间内从回调函数进化到Promise函数(ES2015)，并自从ES2017以来，异步JavaScript的async/wait语法变得更加简单。 异步函数是Promise和generator的结合，基本上，它是比Promise更高级的抽象，我再重复一般：async/await是基于Promise建立的</p><h5 id="为什么要引入async-await"><a href="#为什么要引入async-await" class="headerlink" title="为什么要引入async/await"></a>为什么要引入async/await</h5><p>它减少了围绕promise的引用，并打破了Promise — “不要打断链式调用”的限制。</p><p>当Promise在ES2015中引入时，它的本意是来解决异步代码的问题，它也确实做到了，但在ES2015和ES2017间隔的这两年中，大家意识到：Promise不是解决问题的终极方案。</p><p>Promise是为了解决著名的回调地狱而被引入的，但它本身也带来了使用复杂性和语法复杂性。</p><p>Promise是很好的原生特性，围绕着它开发人员可以探索出更好的语法，因此当时机成熟后，我们得到了async函数</p><p>async函数使代码看起来像是同步函数一样，但其背后却是异步和非堵塞的。</p><h5 id="它如何工作"><a href="#它如何工作" class="headerlink" title="它如何工作"></a>它如何工作</h5><p>一个async函数会返回一个promise，如下例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomethingAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想要调用该函数时，你在前面加上了一个wait，这样调用就会被停止，直到该promise进行resolve或reject，需注意的是：外层函数必须定义为async，这是例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> doSomethingAsync())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个上手示例"><a href="#一个上手示例" class="headerlink" title="一个上手示例"></a>一个上手示例</h5><p>这是一个使用async/await进行异步函数的简单示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomethingAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> doSomethingAsync())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Before'</span>)</span><br><span class="line">doSomething()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'After'</span>)</span><br></pre></td></tr></table></figure><p>上面的代码将会在浏览器的console中打印出如下结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Before</span><br><span class="line">After</span><br><span class="line">I did something <span class="comment">//after 3s</span></span><br></pre></td></tr></table></figure><h4 id="关于-Promise"><a href="#关于-Promise" class="headerlink" title="关于 Promise"></a>关于 Promise</h4><p>将 async 关键字标记在任何函数上，意味着这个函数都将返回一个 Promise，即使这个函数没有显式的返回，它在内部也会返回一个 Promise，这就是下面这份代码有效的原因：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aFunction = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) <span class="comment">// This will alert 'test'</span></span><br></pre></td></tr></table></figure><p>下面的例子也一样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aFunction = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'test'</span>)</span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) <span class="comment">// This will alert 'test'</span></span><br></pre></td></tr></table></figure><h5 id="更易于阅读的代码"><a href="#更易于阅读的代码" class="headerlink" title="更易于阅读的代码"></a>更易于阅读的代码</h5><p>正如上述的例子，我们将它与普通回调函数或链式函数进行比较，我们的代码看起来非常的简单。</p><p>这是一个很简单的例子，当代码足够复杂时，它会产生更多的收益。</p><p>例如，使用 Promise 来获取 JSON 资源并解析它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstUserData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'/users.json'</span>) <span class="comment">// get users list</span></span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()) <span class="comment">// parse JSON</span></span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> users[<span class="number">0</span>]) <span class="comment">// pick first user</span></span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> fetch(<span class="string">`/users/<span class="subst">$&#123;user.name&#125;</span>`</span>)) <span class="comment">// get user data</span></span><br><span class="line">    .then(<span class="function"><span class="params">userResponse</span> =&gt;</span> response.json()) <span class="comment">// parse JSON</span></span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure><p>这是使用 async/await 实现相同功能的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstUserData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/users.json'</span>) <span class="comment">// get users list</span></span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> response.json() <span class="comment">// parse JSON</span></span><br><span class="line">  <span class="keyword">const</span> user = users[<span class="number">0</span>] <span class="comment">// pick first user</span></span><br><span class="line">  <span class="keyword">const</span> userResponse = <span class="keyword">await</span> fetch(<span class="string">`/users/<span class="subst">$&#123;user.name&#125;</span>`</span>) <span class="comment">// get user data</span></span><br><span class="line">  <span class="keyword">const</span> userData = <span class="keyword">await</span> user.json() <span class="comment">// parse JSON</span></span><br><span class="line">  <span class="keyword">return</span> userData</span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure><h5 id="串行多个异步功能"><a href="#串行多个异步功能" class="headerlink" title="串行多个异步功能"></a>串行多个异步功能</h5><p>async 函数非常容易，并且它的语法比 Promise 更易读。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseToDoSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">10000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> watchOverSomeoneDoingSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> something = <span class="keyword">await</span> promiseToDoSomething()</span><br><span class="line">  <span class="keyword">return</span> something + <span class="string">' and I watched'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> something = <span class="keyword">await</span> watchOverSomeoneDoingSomething()</span><br><span class="line">  <span class="keyword">return</span> something + <span class="string">' and I watched as well'</span></span><br><span class="line">&#125;</span><br><span class="line">watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">I did something and I watched and I watched <span class="keyword">as</span> well</span><br></pre></td></tr></table></figure><h4 id="更简单的调试"><a href="#更简单的调试" class="headerlink" title="更简单的调试"></a>更简单的调试</h4><p>调试 Promise 就很困难，因为调试器无法跨越异步代码，但调试 async/await 就非常的简单，调试器会像调试同步代码一样来处理它。</p><h5 id="共享内存和原子"><a href="#共享内存和原子" class="headerlink" title="共享内存和原子"></a>共享内存和原子</h5><p>WebWorkers 可以在浏览器中创建多线程程序。</p><p>它们通过事件的方式来传递消息，从 ES2017 开始，你可以使用 SharedArrayBuffer 在每一个 Worker 中和它们的创建者之间共享内存数组.</p><p>由于不知道写入内存部分需要多长的周期来广播，因此在读取值时，任何类型的写入操作都会完成，Atomics 可以避免竞争条件的发生。</p><p>关于它的更多细节可以在proposal中找到。</p><p>这是 ES2017，接下来我将介绍 ES2018 的功能。</p><h5 id="Rest-Spread-Properties"><a href="#Rest-Spread-Properties" class="headerlink" title="Rest/Spread Properties"></a>Rest/Spread Properties</h5><p>ES2015 引入了解构数组的方法，当你使用时：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure><p>and 展开参数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> a + b + c + d + e</span><br><span class="line"><span class="keyword">const</span> sum = sum(...numbers)</span><br></pre></td></tr></table></figure><p>ES2018 为对象引入了同样的功能。</p><p>解构:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; first, second, ...others &#125; = &#123; <span class="attr">first</span>:<span class="number">1</span>, <span class="attr">second</span>:<span class="number">2</span>, <span class="attr">third</span>:<span class="number">3</span>, <span class="attr">fourth</span>:<span class="number">4</span>, <span class="attr">fifth</span>:<span class="number">5</span> &#125;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">second <span class="comment">// 2</span></span><br><span class="line">others <span class="comment">// &#123; third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure><p>展开属性 允许通过组合在展开运算符之后传递的对象属性而创建新对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = &#123; first, second, ...others &#125;</span><br><span class="line">items <span class="comment">//&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure><h5 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h5><p>for-await-of 允许你使用异步可迭代对象做为循环迭代：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLines(filePath)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它使用的了 await，因此你只能在 async 函数中使用它。</p><h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h5><p>当一个 Promise 是 fulfilled 时，它会一个接一个的调用 then。</p><p>如果在这个过程中发生了错误，则会跳过 then 而执行 catch。</p><p>而 finally() 允许你运行一些代码，无论是成功还是失败：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'file.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> data.json())</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error))</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finished'</span>))</span><br></pre></td></tr></table></figure><h5 id="正则表达式改进"><a href="#正则表达式改进" class="headerlink" title="正则表达式改进"></a>正则表达式改进</h5><p>ES2018 对正则表达式引入了许多改进，这些都可以在 <a href="https://flaviocopes.com/javascript-regular-expressions/" target="_blank" rel="noopener">https://flaviocopes.com/javascript-regular-expressions/</a> 上找到。</p><p>以下是关于 ES2018 正则表达式改进的具体补充：</p><p>RegExp lookbehind assertions: 根据前面的内容匹配字符串</p><p>这是一个 lookahead: 你可以使用 ?= 来匹配字符串，后面跟随一个特定的字符串：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/Roger(?=Waters)/</span><br><span class="line">/Roger(?=Waters)/.test(<span class="string">'Roger is my dog'</span>) <span class="comment">//false</span></span><br><span class="line">/Roger(?=Waters)/.test(<span class="string">'Roger is my dog and Roger Waters is a famous musician'</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>?! 可以执行逆操作，如果匹配的字符串是no而不是在此后跟随特定的子字符串的话：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/Roger(?!Waters)/</span><br><span class="line">/Roger(?!Waters)/.test(<span class="string">'Roger is my dog'</span>) <span class="comment">//true</span></span><br><span class="line">/Roger(?!Waters)/.test(<span class="string">'Roger Waters is a famous musician'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>Lookaheads 使用 ?= Symbol，它们已经可以用了。</p><p>Lookbehinds, 是一个新功能使用?&lt;=.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=Roger)</span> <span class="attr">Waters</span>/</span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Pink</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span>') //<span class="attr">false</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Roger</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span> <span class="attr">and</span> <span class="attr">Roger</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">a</span> <span class="attr">famous</span> <span class="attr">musician</span>') //<span class="attr">true</span></span></span></span><br></pre></td></tr></table></figure><p>如果一个 lookbehind 是否定，那么使用 ?&gt;!:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">!Roger)</span> <span class="attr">Waters</span>/</span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">!Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Pink</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span>') //<span class="attr">true</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">!Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Roger</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span> <span class="attr">and</span> <span class="attr">Roger</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">a</span> <span class="attr">famous</span> <span class="attr">musician</span>') //<span class="attr">false</span></span></span></span><br></pre></td></tr></table></figure><h5 id="Unicode属性转义-p-…-and-P-…"><a href="#Unicode属性转义-p-…-and-P-…" class="headerlink" title="Unicode属性转义 p{…} and P{…}"></a>Unicode属性转义 p{…} and P{…}</h5><p>在正则表达式模式中，你可以使用 d 来匹配任意的数字，s 来匹配任意不是空格的字符串，w 来匹配任意字母数字字符串，以此类推。</p><blockquote><p>This new feature extends this concept to all Unicode characters introducing p{} and is negation P{}.</p></blockquote><p>这个新功能扩展了unicode字符，引入了 p{} 来处理</p><p>任何 unicode 字符都有一组属性，例如 script 确认语言，ASCII 是一个布尔值用于检查 ASCII 字符。你可以将此属性方在() 中，正则表达式将来检查是否为真。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'abc'</span>)   <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC@'</span>)  <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC🙃'</span>) <span class="comment">//❌</span></span><br></pre></td></tr></table></figure><p>ASCII_Hex_Digit 是另一个布尔值，用于检查字符串是否包含有效的十六进制数字：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'0123456789ABCDEF'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'h'</span>)                <span class="comment">//❌</span></span><br></pre></td></tr></table></figure><p>此外，还有很多其它的属性。你可以在()中添加它们的名字来检查它们，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji等等：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^p&#123;Lowercase&#125;$/u.test(<span class="string">'h'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;Uppercase&#125;$/u.test(<span class="string">'H'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;Emoji&#125;+$/u.test(<span class="string">'H'</span>)   <span class="comment">//❌</span></span><br><span class="line">/^p&#123;Emoji&#125;+$/u.test(<span class="string">'🙃🙃'</span>) <span class="comment">//✅</span></span><br></pre></td></tr></table></figure><p>除了二进制属性外，你还可以检查任何 unicode 字符属性以匹配特定的值，在这个例子中，我检查字符串是用希腊语还是拉丁字母写的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^p&#123;Script=Greek&#125;+$/u.test(&apos;ελληνικά&apos;) //✅</span><br><span class="line">/^p&#123;Script=Latin&#125;+$/u.test(&apos;hey&apos;) //✅</span><br></pre></td></tr></table></figure><p>阅读<a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener">https://github.com/tc39/proposal-regexp-unicode-property-escapes</a> 获取使用所有属性的详细信息。</p><p>Named capturing groups<br>In ES2018 a capturing group can be assigned to a name, rather than just being assigned a slot in the result array:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/(?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">const</span> result = re.exec(<span class="string">'2015-01-02'</span>)</span><br><span class="line"><span class="comment">// result.groups.year === '2015';</span></span><br><span class="line"><span class="comment">// result.groups.month === '01';</span></span><br><span class="line"><span class="comment">// result.groups.day === '02';</span></span><br><span class="line">The s flag <span class="keyword">for</span> regular expressions</span><br><span class="line">The s flag, short <span class="keyword">for</span> single line, causes the . to match <span class="keyword">new</span> line characters <span class="keyword">as</span> well. Without it, the dot matches regular characters but not the <span class="keyword">new</span> line:</span><br><span class="line"></span><br><span class="line">/hi.welcome/.test(<span class="string">'hi</span></span><br><span class="line"><span class="string">welcome'</span>) <span class="comment">// false</span></span><br><span class="line">/hi.welcome/s.test(<span class="string">'hi</span></span><br><span class="line"><span class="string">welcome'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="ESNext-1"><a href="#ESNext-1" class="headerlink" title="ESNext"></a>ESNext</h4><p>什么是 ESNext ？</p><p>ESNext 是一个始终指向下一个版本 JavaScript 的名称。</p><p>当前的 ECMAScript 版本是 ES2018，它于2018年6月被发布。</p><p>历史上 JavaScript 标准化的版本都是在夏季被发布，因此我们可以预期 ECMAScript 2019 将于 2019 年的夏季被发布。</p><p>所以在编写本文时 ES2018 已经被发布，因此 ESNext 指的是 ES2019。</p><p>ECMAScript 标准的提案是分阶段组织的，第一到第三阶段属于功能性的孵化，第四阶段的功能才最终确定为新标准的一部分。</p><p>在编写本文时主要浏览器都实现了第四阶段大部分的功能，因此我将在本文中介绍它们。</p><p>其中一些变化主要在内部使用，但知道发生了什么这也很好。</p><p>第三阶段还有一些其它功能，可能会在接下来的几个月内升级到第四阶段，你可以在这个 Github 仓库中查看它们：<a href="https://github.com/tc39/proposals。" target="_blank" rel="noopener">https://github.com/tc39/proposals。</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.&#123;flat,flatMap&#125;</span><br></pre></td></tr></table></figure><p>flat() 是一个新的数组实例方法，它可以将多维数组转化成一维数组。</p><p>例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, <span class="string">'Wolf'</span>]].flat()</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br></pre></td></tr></table></figure><p>默认情况下它只能将二维的数组转化成一维的数组，但你可以添加一个参数来确定要展开的级别，如果你将这个参数设置为 Infinity 那么它将展开无限的级别到一维数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat()</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', [ 'Wolf' ] ]</span></span><br><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br></pre></td></tr></table></figure><p>如果你熟悉数组的 map 方法，那么你就知道使用它可以对数组的每个元素执行一个函数。</p><p>flatMap() 是一个新的数组实例方法，它将 flat() 和 map 结合了起来，当你期望在map函数中做一些处理时这非常有用，同时又希望结果如同 flat ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'My dog'</span>, <span class="string">'is awesome'</span>].map(<span class="function"><span class="params">words</span> =&gt;</span> words.split(<span class="string">' '</span>))</span><br><span class="line"><span class="comment">//[ [ 'My', 'dog' ], [ 'is', 'awesome' ] ]</span></span><br><span class="line">[<span class="string">'My dog'</span>, <span class="string">'is awesome'</span>].flatMap(<span class="function"><span class="params">words</span> =&gt;</span> words.split(<span class="string">' '</span>))</span><br><span class="line"><span class="comment">//[ 'My', 'dog', 'is', 'awesome' ]</span></span><br></pre></td></tr></table></figure><h5 id="Optional-catch-binding"><a href="#Optional-catch-binding" class="headerlink" title="Optional catch binding"></a>Optional catch binding</h5><p>有时候我们并不需要将参数绑定到 try/catch 中。</p><p>在以前我们不得不这样做：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">//handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使我们从来没有通过 e 来分析错误，但现在我们可以简单的省略它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">//handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.fromEntries()</span><br><span class="line">Objects have an entries() method, since ES2017.</span><br></pre></td></tr></table></figure><p>从 ES2017 开始 Object将有一个 entries() 方法。</p><p>它将返回一个包含所有对象自身属性的数组的数组，如[key, value]：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(person) <span class="comment">// [['name', 'Fred'], ['age', 87]]</span></span><br></pre></td></tr></table></figure><p>ES2019 引入了一个新的 Object.fromEntries() 方法，它可以从上述的属性数组中创建一个新的对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="keyword">const</span> entries = <span class="built_in">Object</span>.entries(person)</span><br><span class="line"><span class="keyword">const</span> newPerson = <span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"></span><br><span class="line">person !== newPerson <span class="comment">//true</span></span><br><span class="line"><span class="built_in">String</span>.prototype.&#123;trimStart,trimEnd&#125;</span><br></pre></td></tr></table></figure><p>这些功能已经被 v8/Chrome 实现了近一年的时间，它将在 ES2019 中实现标准化。</p><h5 id="trimStart"><a href="#trimStart" class="headerlink" title="trimStart()"></a>trimStart()</h5><p>删除字符串首部的空格并返回一个新的字符串：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing '</span>.trimStart() <span class="comment">//'Testing '</span></span><br><span class="line"><span class="string">'Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br></pre></td></tr></table></figure><h5 id="trimEnd"><a href="#trimEnd" class="headerlink" title="trimEnd()"></a>trimEnd()</h5><p>删除字符串尾部的空格并返回一个新的字符串：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Testing'</span>.trimEnd() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing'</span>.trimEnd() <span class="comment">//' Testing'</span></span><br><span class="line"><span class="string">' Testing '</span>.trimEnd() <span class="comment">//' Testing'</span></span><br><span class="line"><span class="string">'Testing '</span>.trimEnd() <span class="comment">//'Testing'</span></span><br></pre></td></tr></table></figure><h5 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h5><p>现在你可以使用 description 来获取 Symbol 的值，而不必使用 toString() 方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testSymbol = <span class="built_in">Symbol</span>(<span class="string">'Test'</span>)</span><br><span class="line">testSymbol.description <span class="comment">// 'Test'</span></span><br></pre></td></tr></table></figure><h5 id="JSON-improvements"><a href="#JSON-improvements" class="headerlink" title="JSON improvements"></a>JSON improvements</h5><p>在此之前 JSON 字符串中不允许使用分隔符（）和分隔符（）。</p><p>使用 JSON.parse 时，这些字符会导致一个 SyntaxError 错误，但现在它们可以正确的解析并如 JSON 标准定义的那样。</p><h5 id="Well-formed-JSON-stringify"><a href="#Well-formed-JSON-stringify" class="headerlink" title="Well-formed JSON.stringify()"></a>Well-formed JSON.stringify()</h5><p>修复 JSON.stringify() 在处理 UTF-8 code points (U+D800 to U+DFFF)。</p><p>在修复之前，调用 JSON.stringify() 将返回格式错误的 Unicode 字符，如（a “�”)。</p><p>现在你可以安全放心的使用 JSON.stringify() 转成字符串，也可以使用 JSON.parse() 将它转换回原始表示的形态。</p><h5 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h5><p>函数总会有一个 toString 方法，它将返回一个包含函数代码的字符串。</p><p>ES2019 对返回值做了修改，以避免剥离注释和其它字符串（如：空格），将更准确的表示函数的定义。</p><blockquote><p>If previously we had</p></blockquote><p>以前也许我们这样过：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">this</span> <span class="title">is</span> <span class="title">bar</span> */ <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当时的行为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bar.toString() <span class="comment">//'function bar() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>现在的行为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bar.toString(); <span class="comment">// 'function /* this is bar */ bar () &#123;&#125;'</span></span><br></pre></td></tr></table></figure><p>总结一下，我希望这篇文章可以帮助你了解一些最新的 JavaScript 以及我们在 2019 年即将看见的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。&lt;/p&gt;
&lt;p&gt;JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。&lt;/p&gt;
&lt;p&gt;JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程看这篇就够了</title>
    <link href="http://yoursite.com/posts/52228cda.html"/>
    <id>http://yoursite.com/posts/52228cda.html</id>
    <published>2019-04-23T02:07:59.000Z</published>
    <updated>2019-05-16T07:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。</p><p>用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。</p><p>很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。</p><a id="more"></a><ul><li>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程</li><li>并行与并发：</li><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428174913.png" alt=""></p><ul><li><p>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(User from, User to, <span class="keyword">float</span> amount)</span></span>&#123;</span><br><span class="line">    to.setMoney(to.getBalance() + amount);</span><br><span class="line">    from.setMoney(from.getBalance() - amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入<code>@synchronized</code>关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p></li></ul><p>好了，让我们开始吧。我准备分成几部分来总结涉及到多线程的内容：</p><ol><li>扎好马步：线程的状态</li><li>内功心法：每个对象都有的方法（机制）</li><li>太祖长拳：基本线程类</li><li>九阴真经：高级多线程控制类</li></ol><h2 id="一、扎好马步：线程的状态"><a href="#一、扎好马步：线程的状态" class="headerlink" title="一、扎好马步：线程的状态"></a>一、扎好马步：线程的状态</h2><p>先来两张图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428174935.png" alt=""></p><p>​                                            线程状态</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428174959.png" alt=""></p><p>​                                            线程状态转换</p><p>各种状态一目了然，值得一提的是”Blocked”和”Waiting”这两个状态的区别：</p><ul><li><p>线程在Running的过程中可能会遇到阻塞(Blocked)情况<br>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。从jdk源码注释来看，blocked指的是对monitor的等待（可以参考下文的图）即该线程位于等待区。</p></li><li><p>线程在Running的过程中可能会遇到等待（Waiting）情况<br>线程可以主动调用object.wait或者sleep，或者join（join内部调用的是sleep，所以可看成sleep的一种）进入。从jdk源码注释来看，waiting是等待另一个线程完成某一个操作，如join等待另一个完成执行，object.wait()等待object.notify()方法执行。</p></li></ul><blockquote><p><strong>Waiting状态和Blocked状态</strong>有点费解，我个人的理解是：Blocked其实也是一种wait，等待的是monitor，但是和Waiting状态不一样，举个例子，有三个线程进入了同步块，其中两个调用了object.wait()，进入了waiting状态，这时第三个调用了object.notifyAll()，这时候前两个线程就一个转移到了Runnable,一个转移到了Blocked。</p></blockquote><blockquote><p>从下文的monitor结构图来区别：每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态Blocked,从jstack的dump中来看是 “Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是Waiting，表现在jstack的dump中是 “in Object.wait()”。</p></blockquote><p>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</p><h2 id="二、-内功心法：每个对象都有的方法（机制）"><a href="#二、-内功心法：每个对象都有的方法（机制）" class="headerlink" title="二、 内功心法：每个对象都有的方法（机制）"></a>二、 <strong>内功心法：每个对象都有的方法（机制）</strong></h2><p>synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175213.png" alt=""></p><p>他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。</p><p>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。</p><p>当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。</p><p>再讲用法：</p><ul><li><p>synchronized单独使用：</p></li><li><p>代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Object lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">              ..<span class="keyword">do</span> something</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接用于方法：相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             ..<span class="keyword">do</span> something</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>synchronized, wait, notify结合:典型场景生产者消费者问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者生产出来的产品交给店员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.product &gt;= MAX_PRODUCT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                wait();</span><br><span class="line">                System.out.println(<span class="string">"产品已满,请稍候再生产"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.product++;</span><br><span class="line">        System.out.println(<span class="string">"生产者生产第"</span> + <span class="keyword">this</span>.product + <span class="string">"个产品."</span>);</span><br><span class="line">        notifyAll();   <span class="comment">//通知等待区的消费者可以取出产品了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者从店员取产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.product &lt;= MIN_PRODUCT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                wait();</span><br><span class="line">                System.out.println(<span class="string">"缺货,稍候再取"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者取走了第"</span> + <span class="keyword">this</span>.product + <span class="string">"个产品."</span>);</span><br><span class="line">        <span class="keyword">this</span>.product--;</span><br><span class="line">        notifyAll();   <span class="comment">//通知等待去的生产者可以生产产品了</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>volatile</strong></p><p>多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175254.png" alt=""></p><p>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。</p><h2 id="三、太祖长拳：基本线程类"><a href="#三、太祖长拳：基本线程类" class="headerlink" title="三、太祖长拳：基本线程类"></a>三、<strong>太祖长拳：基本线程类</strong></h2><p>基本线程类指的是Thread类，Runnable接口，Callable接口<br>Thread 类实现了Runnable接口，启动一个线程的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">　　my.start();</span><br></pre></td></tr></table></figure><p><strong>Thread类相关方法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.yield()</span><br><span class="line"><span class="comment">//暂停一段时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.sleep()</span><br><span class="line"><span class="comment">//在一个线程中调用other.join(),将等待other执行完后才继续本线程。　　　　</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//后两个函数皆可以被打断</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">interrupte</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>关于中断</strong>：它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。<br>Thread.interrupted()检查当前线程是否发生中断，返回boolean<br>synchronized在获锁的过程中是不能被中断的。</p><p>中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体</p><p><strong>Thread类最佳实践</strong>：<br>写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。</p><p><strong>如何获取线程中的异常</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175557.png" alt=""></p><p>​                                不能用try,catch来获取线程中的异常</p><p><strong>Runnable</strong></p><p>与Thread类似 </p><p><strong>Callable</strong></p><p>future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService e = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"> <span class="comment">//submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.</span></span><br><span class="line">Future future = e.submit(<span class="keyword">new</span> myCallable());</span><br><span class="line">future.isDone() <span class="comment">//return true,false 无阻塞</span></span><br><span class="line">future.get() <span class="comment">// return 返回值，阻塞直到该线程运行结束</span></span><br></pre></td></tr></table></figure><h2 id="四、九阴真经：高级多线程控制类"><a href="#四、九阴真经：高级多线程控制类" class="headerlink" title="四、九阴真经：高级多线程控制类"></a>四、<strong>九阴真经：高级多线程控制类</strong></h2><p>以上都属于内功心法，接下来是实际项目中常用到的工具了，Java1.5提供了一个非常高效实用的多线程包:<em>java.util.concurrent</em>, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。</p><p><strong>1.ThreadLocal类</strong></p><p>用处：保存线程的独立变量。对一个线程类（继承自Thread)<br>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。</p><p>实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。</p><p>主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。 </p><p><strong>2.原子类（AtomicInteger、AtomicBoolean……）</strong></p><p>如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值为boolean</span></span><br><span class="line">AtomicInteger.compareAndSet(<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</span><br></pre></td></tr></table></figure><p>该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(b.value.compareAndSet(old, value))&#123;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//try again</span></span><br><span class="line">   <span class="comment">// if that fails, rollback and log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AtomicReference</strong></p><p>对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。<br>这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号</p><p><strong>3.Lock类</strong></p><p>lock: 在java.util.concurrent包内。共有三个实现：</p><ul><li>ReentrantLock</li><li>ReentrantReadWriteLock.ReadLock</li><li>ReentrantReadWriteLock.WriteLock</li></ul><p>主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。</p><p>区别如下：</p><ol><li><p>lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序）</p></li><li><p>提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。</p></li><li><p>本质上和监视器锁（即synchronized是一样的）</p></li><li><p>能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。</p></li><li><p>和Condition类的结合。</p></li><li><p>性能更高，对比如下图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175738.png" alt=""></p><p>​                                    synchronized和Lock性能对比</p></li></ol><p><strong>ReentrantLock</strong>　<br>可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。<br>使用方法是：</p><p><strong>1.先new一个实例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ReentrantLock r=<span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><p><strong>2.加锁</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.lock()或r.lockInterruptibly();</span><br></pre></td></tr></table></figure><p>此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch）</p><p><strong>3.释放锁</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.unlock()</span><br></pre></td></tr></table></figure><p>必须做！何为必须做呢，要放在finally里面。以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。</p><p><strong>ReentrantReadWriteLock</strong></p><p>可重入读写锁（读写锁的一个实现）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock()</span><br><span class="line">　　ReadLock r = lock.readLock();</span><br><span class="line">　　WriteLock w = lock.writeLock();</span><br></pre></td></tr></table></figure><p>两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码 </p><p><strong>4.容器类</strong></p><p>这里就讨论比较常用的两个：</p><ul><li>BlockingQueue</li><li>ConcurrentHashMap</li></ul><p><strong>BlockingQueue</strong></p><p>阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管　　道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究</p><p>BlockingQueue在队列的基础上添加了多线程协作的功能：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175825.png" alt=""></p><p>除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队　列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。</p><p>常见的阻塞队列有：</p><ul><li>ArrayListBlockingQueue</li><li>LinkedListBlockingQueue</li><li>DelayQueue</li><li>SynchronousQueue</li></ul><p><strong>ConcurrentHashMap</strong></p><p>高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</p><p><strong>5.管理类</strong></p><p>管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。<br>了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean</p><p><strong>ThreadPoolExecutor</strong></p><p>如果不了解这个类，应该了解前面提到的ExecutorService，开一个自己的线程池非常方便：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService e = Executors.newCachedThreadPool();</span><br><span class="line">    ExecutorService e = Executors.newSingleThreadExecutor();</span><br><span class="line">    ExecutorService e = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 第一种是可变大小线程池，按照任务数来分配线程，</span></span><br><span class="line">    <span class="comment">// 第二种是单线程池，相当于FixedThreadPool(1)</span></span><br><span class="line">    <span class="comment">// 第三种是固定大小线程池。</span></span><br><span class="line">    <span class="comment">// 然后运行</span></span><br><span class="line">    e.execute(<span class="keyword">new</span> MyRunnableImpl());</span><br></pre></td></tr></table></figure><p>该类内部是通过ThreadPoolExecutor实现的，掌握该类有助于理解线程池的管理，本质上，他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175843.png" alt=""></p><p>​                                    ThreadPoolExecutor参数解释</p><p>翻译一下：<br><strong>corePoolSize</strong>:池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。<br><strong>maximumPoolSize</strong>:线程最大值，线程的增长始终不会超过该值。<br><strong>keepAliveTime</strong>：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态<br><strong>unit</strong>：<br>时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS　<br><strong>workQueue</strong>:待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿死(starving)<br><strong>threadFactory</strong>:线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。&lt;/p&gt;
&lt;p&gt;用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。&lt;/p&gt;
&lt;p&gt;很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>让我们聊一聊计算机基础知识的最小集合组</title>
    <link href="http://yoursite.com/posts/2d2dd747.html"/>
    <id>http://yoursite.com/posts/2d2dd747.html</id>
    <published>2019-04-23T02:01:30.000Z</published>
    <updated>2019-05-16T07:44:24.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多人工作后痛感计算机基础知识的缺乏， 那计算机基础知识都有哪些呢？</p><p>我觉得首先计算机专业的那六大件：组成原理，操作系统，数据库，编译原理，计算机网络，数据结构（这个说太多遍了，这次不再讲了）， 其次还得加上分布式的基础知识， 因为现在的系统都变成分布式的了。</p><p>如果你是做应用层开发的，那几门课程中的有些内容和日常工作关联度不大，我挑那些最重要的来说一说，也算是一个<strong>最小集合</strong>吧！</p><a id="more"></a><h2 id="一、计算机组成原理"><a href="#一、计算机组成原理" class="headerlink" title="一、计算机组成原理"></a>一、计算机组成原理</h2><p>如果你不是做操作系统/驱动程序的，直接和硬件打交道的机会很少，因为操作系统已经把他们屏蔽掉了，提供了抽象的API给我们使用。</p><p>但是还必须理解冯诺依曼体系的结构，CPU和内存，硬盘，各种外设之间的关系，寄存器、缓存等知识。</p><p>CPU有哪些指令，如何执行这些指令，如果实现数组，结构体，函数调用，这就涉及到汇编的知识。</p><p>像原码，反码，补码，定点数、浮点数的表示和运算也是编程中必备的知识，几乎每种语言都要涉及。</p><p>现在很多语言都是在虚拟机上运行的，你只要是了解了计算机的组成原理，再去看哪些虚拟机，就会发现概念都是相通的。</p><p>另外CPU中的缓存，缓存一致性协议，DMA的异步思想都会在应用层中有所体现。</p><p>如果能找一本书，尽可能多的囊括这些知识的话，我觉得还是神书《深入理解计算机系统》的前4章。</p><p>《编码》是一个更加科普性，但是也更加有趣的讲组成原理的书。</p><h2 id="二、操作系统言"><a href="#二、操作系统言" class="headerlink" title="二、操作系统言"></a>二、操作系统言</h2><p>操作系统是比较枯燥的， 站在应用层的角度，我认为重点是<strong>掌握操作系统对外提供的抽象</strong>，包括进程、线程，文件，虚拟内存，以及进程间的通信问题。</p><p>几乎所有的编程语言都会涉及到对多进程或者多线程编程的支持， 特别是多线程的并发编程，所以必须得搞明白他们的本质是什么，线程都有哪些实现方式（对以后学习各种语言和并发模型有极大好处）。得真正地体会到“进程是资源分配的最小单位，线程是调度的最小单位。” 这句话的含义。</p><p>几乎所有的编程语言都会涉及到锁和死锁，最好在最底层理解锁是怎么实现的。</p><p>需要理解虚拟内存和物理内存直接的关系，分段和分页，文件系统的基本原理。</p><p>对于进程的调度，页面分配/置换算法，磁盘的调度算法，I/O系统，我认为优先级比较低。</p><h2 id="三、计算机网络"><a href="#三、计算机网络" class="headerlink" title="三、计算机网络"></a>三、计算机网络</h2><p>我认为必须要理解的是这些：</p><p>什么分组交换</p><p>TCP可靠性传输原理，TCP/IP的协议细节， 三次握手，四次挥手，TCP状态转换。</p><p>几个重要的协议DHCP，UDP, ARP, DNS。</p><p>能够说出一个客户端如何在接入网络以后，通过这些协议，跨域网络和服务器通信的。</p><p>和应用层结合非常紧密的Socket知识和网络安全（对称加密，非对称加密，Hash, 数字签名，以及集大成者Https）</p><p>至于网络层的路由选择算法，链路层的各种协议，我认为优先级比较低。</p><p>还有一个重要的知识点，一般的网络书都没提，<strong>就是I/O多路复用</strong>，涉及到同步/异步，阻塞/非阻塞，select/epoll ，这个是很多软件的基础，在《Unix网络编程》，《深入理解计算机系统》中有讲述。</p><p>以上这些知识，<strong>在你学习Redis ,Ngnix, Tomcat, LVS等软件时将有极大的帮助</strong>。</p><h2 id="四、数据库"><a href="#四、数据库" class="headerlink" title="四、数据库"></a>四、数据库</h2><p>你这一辈子也许都不会去写一个编译器，但是很有可能会利用现成的工具去生成/操作一个抽象语法树（AST），甚至可以会写一个DSL（领域特定语言）。所以你得<strong>理解词法分析、语法分析、语义分析，中间代码生成，代码优化这个基本编译的过程。</strong></p><p>学习了编译与原理，会对语言的一些设计有更深的理解，比如LISP。</p><h2 id="五、分布式的理论知识"><a href="#五、分布式的理论知识" class="headerlink" title="五、分布式的理论知识"></a>五、分布式的理论知识</h2><p>由于现在的系统慢慢地变成了分布式， 所以又扩展出了很多相关基础知识需要学习：</p><p><strong>数据复制与一致性:</strong></p><p>CAP理论， BASE原则，幂等性, 2PC, TCC</p><p>Paxos , Raft , Gossip</p><p><strong>数据分片和路由:</strong></p><p>Hash分片：Hash取模（实际中非常常见的算法）， 虚拟桶（Redis使用），一致性Hash（memcached使用）</p><p>范围分片</p><p>最后想说的是，不能带着特别功利的目的去学习这些基础，不能想着立刻、马上就应用到实战中，从中获益。更重要的理解掌握它们背后的思想，有一天你会发现：奥，这个问题我在哪里见过，可以用类似的办法来解决啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很多人工作后痛感计算机基础知识的缺乏， 那计算机基础知识都有哪些呢？&lt;/p&gt;
&lt;p&gt;我觉得首先计算机专业的那六大件：组成原理，操作系统，数据库，编译原理，计算机网络，数据结构（这个说太多遍了，这次不再讲了）， 其次还得加上分布式的基础知识， 因为现在的系统都变成分布式的了。&lt;/p&gt;
&lt;p&gt;如果你是做应用层开发的，那几门课程中的有些内容和日常工作关联度不大，我挑那些最重要的来说一说，也算是一个&lt;strong&gt;最小集合&lt;/strong&gt;吧！&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习总结-数组</title>
    <link href="http://yoursite.com/posts/979f2162.html"/>
    <id>http://yoursite.com/posts/979f2162.html</id>
    <published>2019-04-19T06:42:17.000Z</published>
    <updated>2019-05-16T07:44:23.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、创建方法"><a href="#一、创建方法" class="headerlink" title="一、创建方法"></a>一、创建方法</h2><h3 id="1、空数组"><a href="#1、空数组" class="headerlink" title="1、空数组"></a>1、空数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Obj = new Array();</span><br></pre></td></tr></table></figure><h3 id="2、指定长度数组"><a href="#2、指定长度数组" class="headerlink" title="2、指定长度数组"></a>2、指定长度数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Obj = new Array(Size);</span><br></pre></td></tr></table></figure><h3 id="3、指定元素数组"><a href="#3、指定元素数组" class="headerlink" title="3、指定元素数组"></a>3、指定元素数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Obj = new Array(元素1,元素2,元素3,...,元素N);</span><br></pre></td></tr></table></figure><h3 id="4、单维数组"><a href="#4、单维数组" class="headerlink" title="4、单维数组"></a>4、单维数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Obj = [元素1,元素2,元素3,...,元素N]</span><br></pre></td></tr></table></figure><h3 id="5、多维数组"><a href="#5、多维数组" class="headerlink" title="5、多维数组"></a>5、多维数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = new Array([数组序列1],[数组序列2],[数组序列N]);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h2><h3 id="1、存取数组元素"><a href="#1、存取数组元素" class="headerlink" title="1、存取数组元素"></a>1、存取数组元素</h3><ul><li><p>单维数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组名[下标索引]</span><br></pre></td></tr></table></figure></li><li><p>多维数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组名[外层数组下标][内层元素下标]</span><br></pre></td></tr></table></figure></li><li><p>特性</p><ul><li>数组长度是弹性的，可自由伸缩</li><li>数组下标从0开始</li><li>下标类型<ul><li>数值</li><li>非数值<ul><li>转为字符串</li><li>生成关联数组</li><li>下标将作为对象属性的名字</li></ul></li></ul></li><li>数组元素可添加到对象中</li></ul></li></ul><h3 id="2、增加数组"><a href="#2、增加数组" class="headerlink" title="2、增加数组"></a>2、增加数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用“[]”运算符指定一个新下标</span><br></pre></td></tr></table></figure><h3 id="3、删除数组"><a href="#3、删除数组" class="headerlink" title="3、删除数组"></a>3、删除数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete数组名[下标];</span><br></pre></td></tr></table></figure><h3 id="4、遍历数组"><a href="#4、遍历数组" class="headerlink" title="4、遍历数组"></a>4、遍历数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var 数组元素变量 in 数组)</span><br></pre></td></tr></table></figure><h2 id="三、数组属性"><a href="#三、数组属性" class="headerlink" title="三、数组属性"></a>三、数组属性</h2><h3 id="1、constructor"><a href="#1、constructor" class="headerlink" title="1、constructor"></a>1、constructor</h3><p>引用数组对象的构造函数</p><h3 id="2、length"><a href="#2、length" class="headerlink" title="2、length"></a>2、length</h3><p>返回数组的长度</p><h3 id="3、prototype"><a href="#3、prototype" class="headerlink" title="3、prototype"></a>3、prototype</h3><p>通过增加属性和方法扩展数组定义</p><h2 id="四、ECMAScript-3-方法"><a href="#四、ECMAScript-3-方法" class="headerlink" title="四、ECMAScript 3 方法"></a>四、ECMAScript 3 方法</h2><h3 id="1、添加"><a href="#1、添加" class="headerlink" title="1、添加"></a>1、添加</h3><ul><li><p><strong>push()</strong></p><p>在数组末尾增加数组</p></li><li><p><strong>unshift</strong></p><p>在数组头部添加元素</p></li><li><p><strong>concat</strong></p><p>合并两个数组</p></li></ul><h3 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h3><ul><li><p><strong>pop()</strong></p><p>删除并返回数值的最后一个元素</p></li><li><p><strong>shift()</strong></p><p>删除并返回数组的第一个元素</p></li></ul><blockquote><p>队列方法，先进先出</p><p>栈方法，后进先出</p></blockquote><h3 id="3、子数组"><a href="#3、子数组" class="headerlink" title="3、子数组"></a>3、子数组</h3><ul><li><p><strong>splice()</strong></p><ul><li>删除任意数量的项<ul><li>要删除的起始下标</li><li>要删除的项数</li></ul></li><li>在指定位置插入指定的项<ul><li>起始下标</li><li><strong>0</strong>（不删除任何项）</li><li>要插入的项</li></ul></li><li>替换任意数量的项<ul><li>起始下标</li><li>要删除的项数</li><li>要插入的项</li></ul></li></ul></li><li><p><strong>功能</strong></p><p>从已有数组中选取部分元素构成新数组</p></li><li><p><strong>参数</strong></p><ul><li>返回项的起始位置</li><li>返回项的结束位置</li></ul></li><li><p><strong>特性</strong></p><ul><li>如果是负数，则用数组长度加上该值确定位置</li><li>起始位置实为数组的实际下标</li><li>结束位置的实际下标为结束数值减<strong>1</strong></li></ul></li></ul><h3 id="4、数组排序"><a href="#4、数组排序" class="headerlink" title="4、数组排序"></a>4、数组排序</h3><ul><li><p><strong>reverse()</strong></p><p>颠倒数组中元素的顺序</p></li><li><p><strong>sort()</strong></p><ul><li><p>功能：对字符数组或数字数组进行排序</p></li><li><p>特性：按数值大小比较，需函数支持（升序）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function</span><br><span class="line">compare(value1,value2)&#123;</span><br><span class="line">    if(value1 &lt; value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if(value1 &gt; value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5、数组转换"><a href="#5、数组转换" class="headerlink" title="5、数组转换"></a>5、数组转换</h3><ul><li><p><strong>toString()</strong></p><p>转换为字符串并返回</p></li><li><p><strong>toLocaleString()</strong></p><p>转换为本地格式字符串并返回</p></li><li><p><strong>join()</strong></p><p>用指定分隔符分割数组并转换为字符串</p></li></ul><h2 id="五、ECMAScript-5-方法"><a href="#五、ECMAScript-5-方法" class="headerlink" title="五、ECMAScript 5 方法"></a>五、ECMAScript 5 方法</h2><h3 id="1、位置方法"><a href="#1、位置方法" class="headerlink" title="1、位置方法"></a>1、位置方法</h3><ul><li><p><strong>indexof</strong></p><p>从数组的起始位置开始查找</p></li><li><p><strong>lastIndexof</strong></p><p>从数组的结束位置开始查找</p></li><li><p><strong>参数</strong></p><ul><li>要查找的项</li><li>标识查找起点的位置索引</li></ul></li></ul><h3 id="2、迭代方法"><a href="#2、迭代方法" class="headerlink" title="2、迭代方法"></a>2、迭代方法</h3><ul><li><p><strong>every</strong></p><p>如果该函数对每一项都返回true，则返回true</p></li><li><p><strong>filter</strong></p><p>返回值为true的所有数组成员</p></li><li><p><strong>forEach</strong></p><p>无返回值</p></li><li><p><strong>map</strong></p><p>返回每次函数调用的结果数组</p></li><li><p><strong>some</strong></p><p>有任意一项返回true，则返回true</p></li><li><p><strong>参数</strong></p><ul><li>接收参数<ul><li>要在每一项上运行的函数</li><li>运行该函数的作用域对象</li></ul></li><li>传入参数<ul><li>数组项的值 item</li><li>该项在数组中的位置index</li><li>数组对象本身 array</li></ul></li></ul></li></ul><h3 id="3、缩小方法"><a href="#3、缩小方法" class="headerlink" title="3、缩小方法"></a>3、缩小方法</h3><ul><li><p><strong>reduce</strong></p><p>从数组起始位开始遍历</p></li><li><p><strong>reduceRight</strong></p><p>从数组末尾开始遍历</p></li><li><p><strong>参数</strong></p><ul><li>接收参数<ul><li>每一项上调用的函数</li><li>作为缩小基础的初始值</li></ul></li><li>传入参数<ul><li>前一个值 prev</li><li>当前值 cur</li><li>项的索引 index</li><li>数组对象 array</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、创建方法&quot;&gt;&lt;a href=&quot;#一、创建方法&quot; class=&quot;headerlink&quot; title=&quot;一、创建方法&quot;&gt;&lt;/a&gt;一、创建方法&lt;/h2&gt;&lt;h3 id=&quot;1、空数组&quot;&gt;&lt;a href=&quot;#1、空数组&quot; class=&quot;headerlink&quot; title=&quot;1、空数组&quot;&gt;&lt;/a&gt;1、空数组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Obj = new Array();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2、指定长度数组&quot;&gt;&lt;a href=&quot;#2、指定长度数组&quot; class=&quot;headerlink&quot; title=&quot;2、指定长度数组&quot;&gt;&lt;/a&gt;2、指定长度数组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Obj = new Array(Size);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3、指定元素数组&quot;&gt;&lt;a href=&quot;#3、指定元素数组&quot; class=&quot;headerlink&quot; title=&quot;3、指定元素数组&quot;&gt;&lt;/a&gt;3、指定元素数组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Obj = new Array(元素1,元素2,元素3,...,元素N);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;4、单维数组&quot;&gt;&lt;a href=&quot;#4、单维数组&quot; class=&quot;headerlink&quot; title=&quot;4、单维数组&quot;&gt;&lt;/a&gt;4、单维数组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Obj = [元素1,元素2,元素3,...,元素N]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;5、多维数组&quot;&gt;&lt;a href=&quot;#5、多维数组&quot; class=&quot;headerlink&quot; title=&quot;5、多维数组&quot;&gt;&lt;/a&gt;5、多维数组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var a = new Array([数组序列1],[数组序列2],[数组序列N]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习总结-函数基础</title>
    <link href="http://yoursite.com/posts/5768cb4e.html"/>
    <id>http://yoursite.com/posts/5768cb4e.html</id>
    <published>2019-04-19T06:19:51.000Z</published>
    <updated>2019-05-16T07:44:23.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、定义方法"><a href="#一、定义方法" class="headerlink" title="一、定义方法"></a>一、定义方法</h2><h3 id="1、静态方法"><a href="#1、静态方法" class="headerlink" title="1、静态方法"></a>1、静态方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 函数名([虚参数列表])&#123;</span><br><span class="line">    函数体;</span><br><span class="line">    [return[函数返回值;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、动态匿名方法"><a href="#2、动态匿名方法" class="headerlink" title="2、动态匿名方法"></a>2、动态匿名方法</h3><p><strong>var</strong> 函数名 = <strong>new Function</strong>([“虚参数列表”],”函数体”);</p><h3 id="3、直接量方法"><a href="#3、直接量方法" class="headerlink" title="3、直接量方法"></a>3、直接量方法</h3><p>函数名 = <strong>function</strong>([虚参数列表]){函数体;}</p><a id="more"></a><h2 id="二、调用方法"><a href="#二、调用方法" class="headerlink" title="二、调用方法"></a>二、调用方法</h2><h3 id="1、直接调用"><a href="#1、直接调用" class="headerlink" title="1、直接调用"></a>1、直接调用</h3><p>函数名(实参列表)</p><h3 id="2、在连接中调用"><a href="#2、在连接中调用" class="headerlink" title="2、在连接中调用"></a>2、在连接中调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a herf = &quot;javascript:函数名()&quot;&gt;描述字&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="3、在事件中调用"><a href="#3、在事件中调用" class="headerlink" title="3、在事件中调用"></a>3、在事件中调用</h3><p>事件类型 = “函数名()”</p><h3 id="4、递归调用"><a href="#4、递归调用" class="headerlink" title="4、递归调用"></a>4、递归调用</h3><ul><li><p>定义</p><ul><li>在函数体内部调用函数自身</li></ul></li><li><p>格式</p><ul><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 函数名()&#123;</span><br><span class="line">    代码;</span><br><span class="line">    函数名();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h2><h3 id="1、apply"><a href="#1、apply" class="headerlink" title="1、apply"></a>1、apply</h3><ul><li>将函数作为对象的方法来调用</li><li>将参数以数组形式传递给该方法</li></ul><h3 id="2、call"><a href="#2、call" class="headerlink" title="2、call"></a>2、call</h3><ul><li>将函数作为对象的方法来调用</li><li>将指定参数传递给该方法</li></ul><h3 id="3、toString"><a href="#3、toString" class="headerlink" title="3、toString"></a>3、toString</h3><ul><li>返回函数的字符串表示</li></ul><h2 id="四、arguments对象"><a href="#四、arguments对象" class="headerlink" title="四、arguments对象"></a>四、arguments对象</h2><h3 id="1、功能"><a href="#1、功能" class="headerlink" title="1、功能"></a>1、功能</h3><ul><li>存放实参的参数列表</li></ul><h3 id="2、特性"><a href="#2、特性" class="headerlink" title="2、特性"></a>2、特性</h3><ul><li>仅能在函数体内使用</li><li>带有下标属性，并非数组</li><li>函数声明时自动初始化</li></ul><h3 id="3、属性"><a href="#3、属性" class="headerlink" title="3、属性"></a>3、属性</h3><ul><li><strong>length</strong> 获取函数实参的长度</li><li><strong>callee</strong> 返回当前正在指向的函数</li><li><strong>caler</strong> 返回调用当前正在执行的函数的函数名</li></ul><h2 id="五、函数参数"><a href="#五、函数参数" class="headerlink" title="五、函数参数"></a>五、函数参数</h2><h3 id="1、参数类型"><a href="#1、参数类型" class="headerlink" title="1、参数类型"></a>1、参数类型</h3><ul><li><strong>形参</strong><ul><li>定义函数时使用的参数</li><li>接收该函数时传递的参数</li></ul></li><li><strong>实参</strong><ul><li>调用函数时传递给函数的实际参数</li></ul></li></ul><h3 id="2、特性-1"><a href="#2、特性-1" class="headerlink" title="2、特性"></a>2、特性</h3><ul><li>参数个数没有限制<ul><li>实参 <strong>&lt;</strong> 形参 ：多余形参 <strong>= undefined</strong></li><li>实参 <strong>&gt;</strong> 形参 ：多余实参被忽略</li></ul></li><li>参数的数据类型没有限制</li><li>通过<strong>arguments</strong>对象访问参数数组</li><li>参数始终按值传递<ul><li>基本类型：传值</li><li>引用类型：传址</li></ul></li></ul><h2 id="六、指针标识"><a href="#六、指针标识" class="headerlink" title="六、指针标识"></a>六、指针标识</h2><h3 id="1、this"><a href="#1、this" class="headerlink" title="1、this"></a>1、this</h3><p>指向当前操作对象</p><h3 id="2、callee"><a href="#2、callee" class="headerlink" title="2、callee"></a>2、callee</h3><p>指向形参集合所属函数</p><h3 id="3、prototype"><a href="#3、prototype" class="headerlink" title="3、prototype"></a>3、prototype</h3><p>指向函数附带的原型对象</p><h3 id="4、constructor"><a href="#4、constructor" class="headerlink" title="4、constructor"></a>4、constructor</h3><p>指向创建该对象的构造函数</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、定义方法&quot;&gt;&lt;a href=&quot;#一、定义方法&quot; class=&quot;headerlink&quot; title=&quot;一、定义方法&quot;&gt;&lt;/a&gt;一、定义方法&lt;/h2&gt;&lt;h3 id=&quot;1、静态方法&quot;&gt;&lt;a href=&quot;#1、静态方法&quot; class=&quot;headerlink&quot; title=&quot;1、静态方法&quot;&gt;&lt;/a&gt;1、静态方法&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function 函数名([虚参数列表])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    函数体;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [return[函数返回值;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2、动态匿名方法&quot;&gt;&lt;a href=&quot;#2、动态匿名方法&quot; class=&quot;headerlink&quot; title=&quot;2、动态匿名方法&quot;&gt;&lt;/a&gt;2、动态匿名方法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;var&lt;/strong&gt; 函数名 = &lt;strong&gt;new Function&lt;/strong&gt;([“虚参数列表”],”函数体”);&lt;/p&gt;
&lt;h3 id=&quot;3、直接量方法&quot;&gt;&lt;a href=&quot;#3、直接量方法&quot; class=&quot;headerlink&quot; title=&quot;3、直接量方法&quot;&gt;&lt;/a&gt;3、直接量方法&lt;/h3&gt;&lt;p&gt;函数名 = &lt;strong&gt;function&lt;/strong&gt;([虚参数列表]){函数体;}&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习总结-运算符</title>
    <link href="http://yoursite.com/posts/4cf212f3.html"/>
    <id>http://yoursite.com/posts/4cf212f3.html</id>
    <published>2019-04-17T08:39:41.000Z</published>
    <updated>2019-05-16T07:44:23.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h2><h3 id="1、运算符"><a href="#1、运算符" class="headerlink" title="1、运算符"></a>1、运算符</h3><h4 id="a、"><a href="#a、" class="headerlink" title="a、+"></a>a、+</h4><ul><li>功能<ul><li>对数字进行代数求和</li><li>对字符串进行连接操作</li><li>将一个数值转换成字符串（数值+空字符串）</li></ul></li><li>字符串拼接<ul><li>字符串+字符串（二者直接拼接）</li><li>字符串+数值（数值转为字符串再拼接）</li></ul></li></ul><a id="more"></a><h4 id="b、"><a href="#b、" class="headerlink" title="b、-"></a>b、-</h4><ul><li>功能<ul><li>对操作数进行“取反”操作</li><li>对数字进行减法操作</li><li>将字符串转换成数值（数值型字符串 - 0）</li></ul></li></ul><h4 id="c、"><a href="#c、" class="headerlink" title="c、*"></a>c、*</h4><ul><li>功能<ul><li>对两个运算数进行乘法运算</li></ul></li><li>符号问题<ul><li>同号得正，异号得负</li></ul></li></ul><h4 id="d、"><a href="#d、" class="headerlink" title="d、/"></a>d、/</h4><ul><li>功能<ul><li>对两个运算数进行除法运算</li></ul></li><li>符号问题<ul><li>同号得正，异号得负</li></ul></li></ul><h4 id="e、"><a href="#e、" class="headerlink" title="e、%"></a>e、%</h4><ul><li>功能<ul><li>返回两个除数的余数</li></ul></li><li>符号问题<ul><li>和第一个运算数的符号相同</li></ul></li></ul><h3 id="2、复合赋值运算符"><a href="#2、复合赋值运算符" class="headerlink" title="2、复合赋值运算符"></a>2、复合赋值运算符</h3><ul><li><strong>+=、- =、*=、/=、%=</strong></li></ul><h2 id="二、自增与自减"><a href="#二、自增与自减" class="headerlink" title="二、自增与自减"></a>二、自增与自减</h2><h3 id="1、功能相反"><a href="#1、功能相反" class="headerlink" title="1、功能相反"></a>1、功能相反</h3><ul><li><strong>++</strong>：对唯一的运算数进行递增操作（每次加1）</li><li><strong>—</strong>：对唯一的运算数进行递减操作（每次减1）</li></ul><h3 id="2、规则相同"><a href="#2、规则相同" class="headerlink" title="2、规则相同"></a>2、规则相同</h3><ul><li>运算数必须是一个变量、数组的一个元素或者对象的属性</li><li>如果运算数是非数值的则运算符会将它转成数值</li></ul><h3 id="3、符号位置决定运算结果"><a href="#3、符号位置决定运算结果" class="headerlink" title="3、符号位置决定运算结果"></a>3、符号位置决定运算结果</h3><ul><li>运算数之前：先进行递增（递减）操作，再进行求值</li><li>运算数之后：先求值，再进行递增（递减）操作</li></ul><h2 id="三、关系运算符"><a href="#三、关系运算符" class="headerlink" title="三、关系运算符"></a>三、关系运算符</h2><h3 id="1、大小关系检测"><a href="#1、大小关系检测" class="headerlink" title="1、大小关系检测"></a>1、大小关系检测</h3><h4 id="a、运算符"><a href="#a、运算符" class="headerlink" title="a、运算符"></a>a、运算符</h4><ul><li><strong>&lt;</strong> ：如果A小于B，则返回true，否则返回false</li><li><strong>&lt;=</strong>：如果A小于等于B，则返回true，否则返回false</li><li><strong>&gt;=</strong>：如果A大于等于B，则返回true，否则返回false</li><li><strong>&gt;</strong>：如果A大于B，则返回true，否则返回false</li></ul><h4 id="b、操作规则"><a href="#b、操作规则" class="headerlink" title="b、操作规则"></a>b、操作规则</h4><ul><li>数值与数值的比较：比较它们的代数值</li><li>仅一个运算数是数值：将另一个运算数转换成数值，并比较它们的代数值</li><li>字符串间的比较：逐字符比较它们的Unicode数值</li><li>字符串与非数值的比较：将运算符转换成字符串并进行比较</li><li>运算数即非数值也非字符串：转换成数值或字符串后进行比较</li><li>运算数无法转换成数值或字符串：返回值为false</li><li>与NaN的比较：返回值为false</li></ul><h3 id="2、等值关系检测"><a href="#2、等值关系检测" class="headerlink" title="2、等值关系检测"></a>2、等值关系检测</h3><h4 id="a、相等比较"><a href="#a、相等比较" class="headerlink" title="a、相等比较"></a>a、相等比较</h4><ul><li>操作符<ul><li><strong>==</strong>：比较两个运算数的返回值看是否相等</li><li><strong>!=</strong>：比较两个运算数的返回值看是否不相等</li></ul></li><li>类型转换<ul><li>布尔值<ul><li>true：1</li><li>false：0</li></ul></li><li>对象<ul><li>调用valueOf()，基本类型</li></ul></li><li>字符串与数值的比较<ul><li>字符串转换为数值</li></ul></li></ul></li><li>比较原则<ul><li>null与undefined<ul><li>相等</li><li>比较前不进行任何转换</li></ul></li><li>NaN<ul><li>与任何数值都不相等包括其本身</li></ul></li><li>对象<ul><li>是否属于同一对象<ul><li>是：<strong>==</strong></li><li>否：<strong>!=</strong></li></ul></li></ul></li></ul></li></ul><h4 id="b、相同比较"><a href="#b、相同比较" class="headerlink" title="b、相同比较"></a>b、相同比较</h4><ul><li>运算符<ul><li><strong>===</strong>：比较两个运算数的返回值及数据类型看是否相同</li><li><strong>!==</strong>：比较两个运算数的返回值及数据类型看是否不同</li></ul></li><li>比较原则<ul><li>值类型比较<ul><li>只有数据类型相同，且数值相等时才能够相同</li></ul></li><li>值类型与引用类型比较<ul><li>肯定不相同</li></ul></li><li>引用类型间比较<ul><li>比较它们的引用值（内存地址）</li></ul></li></ul></li></ul><h2 id="四、对象运算符"><a href="#四、对象运算符" class="headerlink" title="四、对象运算符"></a>四、对象运算符</h2><ul><li><strong>in</strong>：判断左侧运算数是否为右侧运算数的成员</li><li><strong>instancesof</strong>：判断对象实例是否属于某个类或构造函数</li><li><strong>new</strong>：根据构造函数创建一个新的对象，并初始化该对象</li><li><strong>delete</strong>：删除指定对象的属性，数组元素或变量</li><li><strong>.及[]</strong>：存取对象或数组元素</li><li><strong>()</strong>：函数调用，改变运算运算符优先级等</li></ul><h2 id="五、逻辑运算符"><a href="#五、逻辑运算符" class="headerlink" title="五、逻辑运算符"></a>五、逻辑运算符</h2><h3 id="1、-逻辑非"><a href="#1、-逻辑非" class="headerlink" title="1、! 逻辑非"></a>1、! 逻辑非</h3><h4 id="a、返回值"><a href="#a、返回值" class="headerlink" title="a、返回值"></a>a、返回值</h4><ul><li>true<ul><li>空字符串</li><li>0</li><li>null</li><li>NaN</li><li>undefined</li></ul></li><li>false<ul><li>对象</li><li>非空字符串</li><li>非0数值（Infinity）</li></ul></li></ul><h4 id="b、特性"><a href="#b、特性" class="headerlink" title="b、特性"></a>b、特性</h4><ul><li>如果运算数的值为false则返回true，否则返回false</li><li>连续使用两次!，可将任意类型转为布尔值</li></ul><h3 id="2、-amp-amp-逻辑与"><a href="#2、-amp-amp-逻辑与" class="headerlink" title="2、&amp;&amp;逻辑与"></a>2、&amp;&amp;逻辑与</h3><h4 id="a、规则"><a href="#a、规则" class="headerlink" title="a、规则"></a>a、规则</h4><ul><li>第一个操作数是对象：返回第二个操作数</li><li>第二个操作数是对象：第一个操作数值为true时返回该对象</li><li>两个操作数都是对象：返回第二个操作数</li><li>一个操作数是null：返回null</li><li>一个操作数是NaN：返回NaN</li><li>一个操作数是undefined：返回undefined</li></ul><h4 id="b、特性-1"><a href="#b、特性-1" class="headerlink" title="b、特性"></a>b、特性</h4><ul><li>当且仅当两个运算数的值都是true时，才返回true，否则返回false</li><li>短路操作：当第一个操作数的值为false则不再对第二个操作数进行求值</li></ul><h3 id="3、-逻辑或"><a href="#3、-逻辑或" class="headerlink" title="3、||逻辑或"></a>3、||逻辑或</h3><h4 id="a、规则-1"><a href="#a、规则-1" class="headerlink" title="a、规则"></a>a、规则</h4><ul><li>第一个操作数是对象：返回第一个操作数</li><li>第一个操作数值为false：返回第二个操作数</li><li>两个操作数都是对象：返回第一个操作数</li><li>两个操作数是null：返回null</li><li>两个操作数是NaN：返回NaN</li><li>两个操作数是undefined：返回undefined</li></ul><h4 id="b、特性-2"><a href="#b、特性-2" class="headerlink" title="b、特性"></a>b、特性</h4><ul><li>当且仅当连个运算数的值都是false时，才返回false，否则返回true</li><li>如果第一个操作数为true，则不会对第二个操作数进行求值</li></ul><h2 id="六、位运算符"><a href="#六、位运算符" class="headerlink" title="六、位运算符"></a>六、位运算符</h2><h3 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h3><h4 id="a、类型"><a href="#a、类型" class="headerlink" title="a、类型"></a>a、类型</h4><ul><li>有符号<ul><li>数值位：前31位</li><li>符号位：第32位<ul><li>0：正数</li><li>1：负数</li></ul></li></ul></li><li>无符号<ul><li>只能是正数</li><li>第32位表示数值</li><li>数值范围可以加大</li></ul></li></ul><h4 id="b、数值范围"><a href="#b、数值范围" class="headerlink" title="b、数值范围"></a>b、数值范围</h4><ul><li><strong>- 2147483648 ~ 2147483647</strong></li></ul><h4 id="c、存储方式"><a href="#c、存储方式" class="headerlink" title="c、存储方式"></a>c、存储方式</h4><ul><li>正数<ul><li>纯二进制存储</li><li>31位中每一位表示2的幂</li><li>用0补充无用位</li></ul></li><li>负数<ul><li>二进制补码存储</li><li>补码的计算步骤<ul><li>确定该数字的非负版本的二进制表示</li><li>求得二进制反码，既要把0替换为1，把1替换为0</li><li>在二进制反码上加1</li></ul></li></ul></li></ul><h4 id="d、当做0来处理的特殊值"><a href="#d、当做0来处理的特殊值" class="headerlink" title="d、当做0来处理的特殊值"></a>d、当做0来处理的特殊值</h4><ul><li>NaN</li><li>Infinity</li></ul><h3 id="2、逻辑位运算符"><a href="#2、逻辑位运算符" class="headerlink" title="2、逻辑位运算符"></a>2、逻辑位运算符</h3><h4 id="a、返回值为1"><a href="#a、返回值为1" class="headerlink" title="a、返回值为1"></a>a、返回值为1</h4><ul><li>按位非~：0</li><li>按位与&amp;：对应位全是1</li><li>按位或|：任何一位都是1</li><li>按位异或^：既不同时为0，也不同时为1</li></ul><h4 id="b、返回值为0"><a href="#b、返回值为0" class="headerlink" title="b、返回值为0"></a>b、返回值为0</h4><ul><li>按位非~：1</li><li>按位与&amp;：任何一位都是0</li><li>按位或|：对应位全是0</li><li>按位异或^：对应位全是0或全是1</li></ul><h3 id="3、位移操作"><a href="#3、位移操作" class="headerlink" title="3、位移操作"></a>3、位移操作</h3><h4 id="a、左移-lt-lt"><a href="#a、左移-lt-lt" class="headerlink" title="a、左移&lt;&lt;"></a>a、左移&lt;&lt;</h4><ul><li>将数值的所有位左移指定的位数</li><li>所有空位用0补充</li><li>左移1位对其乘2，左移2为对其乘4，以此类推</li></ul><h4 id="b、有符号右移-gt-gt"><a href="#b、有符号右移-gt-gt" class="headerlink" title="b、有符号右移&gt;&gt;"></a>b、有符号右移&gt;&gt;</h4><ul><li>将数值的所有位右移指定的位数</li><li>移除位被舍弃</li><li>保留符号位</li><li>右移1位对其除2，右移2为对其除4，以此类推</li></ul><h4 id="c、无符号右移-gt-gt"><a href="#c、无符号右移-gt-gt" class="headerlink" title="c、无符号右移&gt;&gt;"></a>c、无符号右移&gt;&gt;</h4><ul><li>正数：与有符号右移结果相同</li><li>负数：会出现无限大的数值</li></ul><h3 id="4、复合赋值运算符"><a href="#4、复合赋值运算符" class="headerlink" title="4、复合赋值运算符"></a>4、复合赋值运算符</h3><ul><li>位操作符与等号结合，复合赋值不会有性能方面的提升</li></ul><h2 id="七、其他运算符"><a href="#七、其他运算符" class="headerlink" title="七、其他运算符"></a>七、其他运算符</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、?"></a>1、?</h3><ul><li>条件运算符，简洁的if else</li></ul><h3 id="2、type-of"><a href="#2、type-of" class="headerlink" title="2、type of"></a>2、type of</h3><ul><li>类型判定运算符</li></ul><h3 id="3、"><a href="#3、" class="headerlink" title="3、,"></a>3、,</h3><ul><li>逗号，在一行语句中执行多个不同的操作</li></ul><h3 id="4、void"><a href="#4、void" class="headerlink" title="4、void"></a>4、void</h3><ul><li>舍弃运算数的值，返回undefined作为表达式的值</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、算术运算符&quot;&gt;&lt;a href=&quot;#一、算术运算符&quot; class=&quot;headerlink&quot; title=&quot;一、算术运算符&quot;&gt;&lt;/a&gt;一、算术运算符&lt;/h2&gt;&lt;h3 id=&quot;1、运算符&quot;&gt;&lt;a href=&quot;#1、运算符&quot; class=&quot;headerlink&quot; title=&quot;1、运算符&quot;&gt;&lt;/a&gt;1、运算符&lt;/h3&gt;&lt;h4 id=&quot;a、&quot;&gt;&lt;a href=&quot;#a、&quot; class=&quot;headerlink&quot; title=&quot;a、+&quot;&gt;&lt;/a&gt;a、+&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;功能&lt;ul&gt;
&lt;li&gt;对数字进行代数求和&lt;/li&gt;
&lt;li&gt;对字符串进行连接操作&lt;/li&gt;
&lt;li&gt;将一个数值转换成字符串（数值+空字符串）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字符串拼接&lt;ul&gt;
&lt;li&gt;字符串+字符串（二者直接拼接）&lt;/li&gt;
&lt;li&gt;字符串+数值（数值转为字符串再拼接）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习总结-DOM基本操作</title>
    <link href="http://yoursite.com/posts/af67cb0c.html"/>
    <id>http://yoursite.com/posts/af67cb0c.html</id>
    <published>2019-04-15T09:41:18.000Z</published>
    <updated>2019-05-16T07:44:23.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、获取节点"><a href="#一、获取节点" class="headerlink" title="一、获取节点"></a>一、获取节点</h2><h3 id="1、document"><a href="#1、document" class="headerlink" title="1、document"></a>1、document</h3><ul><li><strong>getElementById</strong><ul><li>语法：<strong>document.getElementById(元素id)</strong></li><li>功能：通过元素<strong>ID</strong>获取节点</li></ul></li><li><strong>getElementByName</strong><ul><li>语法：<strong>document.getElementByName(元素name属性)</strong></li><li>功能：通过元素的<strong>name</strong>属性获取节点</li></ul></li><li><strong>getElementByTagName</strong><ul><li>语法：<strong>document.getElementByTagName(元素标签)</strong></li><li>功能：通过元素标签获取节点</li></ul></li></ul><a id="more"></a><h3 id="2、节点指针"><a href="#2、节点指针" class="headerlink" title="2、节点指针"></a>2、节点指针</h3><ul><li><strong>firstChild</strong><ul><li>语法：<strong>父节点.firstChild</strong></li><li>功能：获取元素的首个子节点</li></ul></li><li><strong>lastChild</strong><ul><li>语法：<strong>父节点.lastChild</strong></li><li>功能：获取元素的最好一个子节点</li></ul></li><li><strong>childNodes</strong><ul><li>语法：<strong>父节点.childNodes</strong></li><li>功能：获取元素的子节点列表</li></ul></li><li><strong>previousSibling</strong><ul><li>语法：<strong>兄弟节点.previousSibling</strong></li><li>功能：<strong>获取已知节点的前一个节点</strong></li></ul></li><li><strong>nextSibling</strong><ul><li>语法：<strong>兄弟节点.nextSibling</strong></li><li>功能：获取已知节点的后一个节点</li></ul></li><li><strong>parentNodes</strong><ul><li>语法：<strong>子节点.parentNodes</strong></li><li>功能：<strong>获取已知节点的父节点</strong></li></ul></li></ul><h2 id="二、节点操作"><a href="#二、节点操作" class="headerlink" title="二、节点操作"></a>二、节点操作</h2><h3 id="1、创建节点"><a href="#1、创建节点" class="headerlink" title="1、创建节点"></a>1、创建节点</h3><ul><li><strong>createElement</strong><ul><li>语法：<strong>document.createElement(元素标签)</strong></li><li>功能：创建元素节点</li></ul></li><li><strong>createAttribute</strong><ul><li>语法：<strong>documen.createAttribute(元素属性)</strong></li><li>功能：创建属性节点</li></ul></li><li><strong>createTextNode</strong><ul><li>语法：<strong>document.createTextNode(文本内容)</strong></li><li>功能：创建文本节点</li></ul></li></ul><h3 id="2、插入节点"><a href="#2、插入节点" class="headerlink" title="2、插入节点"></a>2、插入节点</h3><ul><li><strong>appendChild</strong><ul><li>语法：<strong>appendChild(所添加的新节点)</strong></li><li>功能：向节点的子节点列表的末尾添加新的子节点</li></ul></li><li><strong>insertBefore</strong><ul><li>语法：<strong>insertBefore(所要添加的新节点，已知子节点)</strong></li><li>功能：在已知子节点钱插入一个新的子节点</li></ul></li></ul><h3 id="3、替换节点"><a href="#3、替换节点" class="headerlink" title="3、替换节点"></a>3、替换节点</h3><ul><li><strong>replaceChild</strong><ul><li>语法：<strong>replaceChild(要插入的新元素，将被替换的老元素)</strong></li><li>功能：将某个子节点替换为另一个</li></ul></li></ul><h3 id="4、复制节点"><a href="#4、复制节点" class="headerlink" title="4、复制节点"></a>4、复制节点</h3><ul><li><strong>cloneNode</strong><ul><li>语法：<strong>需要被复制的节点.cloneNode(true/fasle)</strong></li><li>功能：创建置顶节点的副本</li><li>参数<ul><li><strong>true</strong>：复制当前节点及其所有子节点</li><li><strong>false</strong>：仅复制当前节点</li></ul></li></ul></li></ul><h3 id="5、删除节点"><a href="#5、删除节点" class="headerlink" title="5、删除节点"></a>5、删除节点</h3><ul><li><strong>removeChild</strong><ul><li>语法：<strong>removeChild*(要删除的节点)</strong></li><li>功能：删除指定的节点</li></ul></li></ul><h2 id="三、属性操作"><a href="#三、属性操作" class="headerlink" title="三、属性操作"></a>三、属性操作</h2><h3 id="1、获取属性"><a href="#1、获取属性" class="headerlink" title="1、获取属性"></a>1、获取属性</h3><ul><li><strong>getAttribute</strong><ul><li>语法：<strong>元素节点.getAttribute(元素属性名)</strong></li><li>功能：获取元素节点中指定属性的属性值</li></ul></li></ul><h3 id="2、设置设置属性"><a href="#2、设置设置属性" class="headerlink" title="2、设置设置属性"></a>2、设置设置属性</h3><ul><li><strong>setAttribute</strong><ul><li>语法：<strong>元素节点.setAttribute(属性名,属性值)</strong></li><li>功能：创建或改变元素节点的属性</li></ul></li></ul><h3 id="3、删除属性"><a href="#3、删除属性" class="headerlink" title="3、删除属性"></a>3、删除属性</h3><ul><li><strong>removeAttribute</strong><ul><li>语法：<strong>元素节点.removeAttribute(属性名)</strong></li><li>功能：删除元素中的指定属性</li></ul></li></ul><h2 id="四、文本操作"><a href="#四、文本操作" class="headerlink" title="四、文本操作"></a>四、文本操作</h2><ul><li><strong>insertData(offset,string)</strong> ：从offset指定的位置插入string</li><li><strong>appendata(sring)</strong> ：将string插入到文本节点的末尾处</li><li><strong>deleteData(offset,count)</strong> ：从offset起删除count个字符</li><li><strong>replaceData(off,count,string)</strong> ：从off将count个字符用string替代</li><li><strong>splitData(offset)</strong>：从offset起将文本节点分成两个节点</li><li><strong>substring(offset,count)</strong>：返回由offset起的count个节点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、获取节点&quot;&gt;&lt;a href=&quot;#一、获取节点&quot; class=&quot;headerlink&quot; title=&quot;一、获取节点&quot;&gt;&lt;/a&gt;一、获取节点&lt;/h2&gt;&lt;h3 id=&quot;1、document&quot;&gt;&lt;a href=&quot;#1、document&quot; class=&quot;headerlink&quot; title=&quot;1、document&quot;&gt;&lt;/a&gt;1、document&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;getElementById&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;语法：&lt;strong&gt;document.getElementById(元素id)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;功能：通过元素&lt;strong&gt;ID&lt;/strong&gt;获取节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getElementByName&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;语法：&lt;strong&gt;document.getElementByName(元素name属性)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;功能：通过元素的&lt;strong&gt;name&lt;/strong&gt;属性获取节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getElementByTagName&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;语法：&lt;strong&gt;document.getElementByTagName(元素标签)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;功能：通过元素标签获取节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习总结-流程语句</title>
    <link href="http://yoursite.com/posts/121ee7e9.html"/>
    <id>http://yoursite.com/posts/121ee7e9.html</id>
    <published>2019-04-15T09:07:20.000Z</published>
    <updated>2019-05-16T07:44:23.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、循环语句"><a href="#一、循环语句" class="headerlink" title="一、循环语句"></a>一、循环语句</h2><h3 id="1、while"><a href="#1、while" class="headerlink" title="1、while"></a>1、while</h3><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(条件表达式)&#123;</span><br><span class="line">    循环执行代码段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li>流程<ul><li>判断条件表达式的值</li><li>当值为<strong>true</strong>时循环执行代码段</li><li>当值为<strong>false</strong>时退出循环体</li></ul></li><li>热性<ul><li>先检查条件，再执行循环</li><li>条件不满足则循环一次也不执行</li></ul></li><li>时机<ul><li>一个动作被重复执行到满足某个 条件时</li></ul></li></ul><h3 id="2、do-while"><a href="#2、do-while" class="headerlink" title="2、do-while"></a>2、do-while</h3><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    循环执行的代码段</span><br><span class="line">&#125;while(条件表达式)</span><br></pre></td></tr></table></figure></li><li><p>流程</p><ul><li>先执行循环体内代码段再进行判断</li><li>如果表达式的值为<strong>true</strong>，则重复执行代码段</li><li>如果表达式的值为<strong>false</strong>，则退出循环体</li></ul></li><li>特性<ul><li>先执行循环体，再进行条件判断</li><li>循环体内代码至少执行一次</li></ul></li><li><p>时机</p><ul><li>希望一个动作至少被执行一次时</li></ul></li></ul><h3 id="3、for"><a href="#3、for" class="headerlink" title="3、for"></a>3、for</h3><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(循环变量 = 初值;循环条件;递增/递减计数器)&#123;</span><br><span class="line">    循环代码段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>流程</p><ul><li>用循环变量初始值与循环条件相比较，确定返回值</li><li>如果返回值为<strong>true</strong>则执行循环体</li><li>执行完一次后进行递增/递减运算</li><li>将运算结果与循环条件相比较</li><li>如果返回值为<strong>true</strong>则继续执行循环体</li><li>如果返回值为<strong>false</strong>则退出循环体</li></ul></li><li><p>时机</p><ul><li>重复一个动作到一定次数时</li></ul></li></ul><h3 id="4、for-in"><a href="#4、for-in" class="headerlink" title="4、for-in"></a>4、for-in</h3><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(声明变量 in 对象)&#123;</span><br><span class="line">    代码段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用</p><ul><li>枚举对象属性</li></ul></li><li><p>注意事项</p><ul><li>循环输出的属性顺序不可预知</li><li>对象的值不能是<strong>null</strong>或<strong>undefined</strong></li></ul></li></ul><h2 id="二、跳转语句"><a href="#二、跳转语句" class="headerlink" title="二、跳转语句"></a>二、跳转语句</h2><h3 id="1、return"><a href="#1、return" class="headerlink" title="1、return"></a>1、return</h3><ul><li>终止函数体的运行，并返回一个值</li></ul><h3 id="2、break"><a href="#2、break" class="headerlink" title="2、break"></a>2、break</h3><ul><li>终止整个循环，不再进行判断</li></ul><h3 id="3、continue"><a href="#3、continue" class="headerlink" title="3、continue"></a>3、continue</h3><ul><li>结束本次循环，接着去判断是否执行下次循环</li></ul><h2 id="三、选择语句"><a href="#三、选择语句" class="headerlink" title="三、选择语句"></a>三、选择语句</h2><h3 id="1、if"><a href="#1、if" class="headerlink" title="1、if"></a>1、if</h3><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件表达式1)&#123;</span><br><span class="line">    代码段1</span><br><span class="line">&#125;else if(条件表达式2)&#123;</span><br><span class="line">    代码段2</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    代码段3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>流程</p><ul><li>判断条件1，如果返回值为<strong>true</strong>则执行代码段1</li><li>如果条件1的返回值为<strong>false</strong>则跳过语句1并检测条件2</li><li>如果所有的表达式的值均为<strong>false</strong>则执行<strong>else</strong>后面的语句</li></ul></li><li><p>特性</p><ul><li><p>结构复杂，可嵌套</p></li><li><p>可测试多个条件表达式</p></li><li>表达式的值具有线性特征</li><li>表达式的值是动态的</li><li>适用于任意类型的数据</li><li>可处理复杂的逻辑关系</li></ul></li></ul><h3 id="2、switch"><a href="#2、switch" class="headerlink" title="2、switch"></a>2、switch</h3><ul><li><p>语句</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(条件表达式)&#123;</span><br><span class="line">    case 标签1:</span><br><span class="line">         代码段1;</span><br><span class="line">         break;</span><br><span class="line">    case 标签2:</span><br><span class="line">         代码段2;</span><br><span class="line">         break;</span><br><span class="line">     …… ……</span><br><span class="line">    default:</span><br><span class="line">     代码段n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>流程</p><ul><li>计算表达式的值，并与各标签相比较</li><li>若找到与之匹配的标签，则执行其后的代码段</li><li>若没有找到与之匹配的标签则执行<strong>default</strong>之后的代码段</li></ul></li><li><p>格式</p><ul><li><strong>case</strong>标签为常量，可以是字符串或数字</li><li>每个标签均以冒号<strong>:</strong>结束</li><li>虽然<strong>break</strong>与<strong>default</strong>为可选性，但为了逻辑清晰最好不要省略</li><li><strong>case</strong>标签的值必须和条件表达式在值完全匹配</li></ul></li><li><p>特性</p><ul><li>结构简洁，专为多重选择设计</li><li>仅可测试一条条件表达式</li><li>表达式的值具有离散性</li><li>表达式的值是固定的，不会动态变化的</li><li>仅能应用整数，枚举，字符串等类型数据</li><li>仅能处理多个枚举型逻辑关系</li></ul></li></ul><h2 id="四、异常处理语句"><a href="#四、异常处理语句" class="headerlink" title="四、异常处理语句"></a>四、异常处理语句</h2><ul><li><strong>throw</strong><ul><li>主动抛出异常</li></ul></li><li><strong>try</strong><ul><li>指明需要处理的代码段</li></ul></li><li><strong>catch</strong><ul><li>捕获异常</li></ul></li><li><strong>finally</strong><ul><li>后期处理</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、循环语句&quot;&gt;&lt;a href=&quot;#一、循环语句&quot; class=&quot;headerlink&quot; title=&quot;一、循环语句&quot;&gt;&lt;/a&gt;一、循环语句&lt;/h2&gt;&lt;h3 id=&quot;1、while&quot;&gt;&lt;a href=&quot;#1、while&quot; class=&quot;headerlink&quot; title=&quot;1、while&quot;&gt;&lt;/a&gt;1、while&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;语法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while(条件表达式)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    循环执行代码段&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习总结-正则表达式</title>
    <link href="http://yoursite.com/posts/75cf4b3.html"/>
    <id>http://yoursite.com/posts/75cf4b3.html</id>
    <published>2019-04-15T06:49:52.000Z</published>
    <updated>2019-05-16T07:44:23.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、创建"><a href="#一、创建" class="headerlink" title="一、创建"></a>一、创建</h2><h3 id="1、方式"><a href="#1、方式" class="headerlink" title="1、方式"></a>1、方式</h3><ul><li>字面量：<strong>var</strong>变量名 <strong>=</strong> <strong>/</strong> 表达式 <strong>/</strong> 模式修饰符</li><li>函数构造：<strong>var</strong>变量名 <strong>= </strong> <strong>new RegExp(“表达式”,”模式修饰符”)</strong></li></ul><a id="more"></a><h3 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h3><h4 id="a、表达式"><a href="#a、表达式" class="headerlink" title="a、表达式"></a>a、表达式</h4><ul><li>单个字符与数字<ul><li><strong>.</strong> : 匹配除换行符之外的任意字符</li><li><strong>[a-z0-9]</strong> ：匹配方括号中的任意字符</li><li><strong>[^a-z0-9]</strong> ：匹配不在方括号中的任意字符</li><li><strong>\d</strong>：匹配数字</li><li><strong>\D</strong>：匹配非数字</li><li><strong>\w</strong>：匹配字母</li><li><strong>\W</strong>：匹配非字母</li></ul></li><li>空白字符<ul><li><strong>\0</strong>：匹配<strong>null</strong>字符</li><li><strong>\b</strong>：匹配空格字符</li><li><strong>\f</strong>：匹配换页符</li><li><strong>\n</strong>：匹配换行符</li><li><strong>\r</strong>：匹配回车符</li><li><strong>\s</strong>：匹配空白字符、空格、制表符或换行符</li><li><strong>\S</strong>：匹配非空白字符</li><li><strong>\t</strong>：匹配制表符</li></ul></li><li>定位符<ul><li><strong>^</strong>：行首匹配</li><li><strong>$</strong>：行尾匹配</li><li><strong>\A</strong>：只匹配字符串的开始处</li><li><strong>\b</strong>：匹配单词边界，词在<strong>[]</strong>内无效</li><li><strong>\B</strong>：匹配非单词边界</li><li><strong>\G</strong>：匹配当前搜索的开始位置</li><li><strong>\Z</strong>：匹配字符串结束处或行尾</li><li><strong>\z</strong>：只匹配字符串结束处</li></ul></li><li>限定符<ul><li><strong>x?</strong>：匹配<strong>0</strong>个或<strong>1</strong>个<strong>x</strong></li><li><strong>x*</strong>：匹配<strong>0</strong>个或任意多个<strong>x</strong></li><li><strong>x+</strong>：匹配至少<strong>1</strong>个<strong>x</strong></li><li><strong>x(m,n)</strong>：匹配最少<strong>m</strong>个，最多<strong>n</strong>个<strong>x</strong></li></ul></li><li>分组<ul><li><strong>(?:x)</strong>：匹配<strong>x</strong>但不记录匹配结果</li><li><strong>x(?=y)</strong>：当<strong>x</strong>后接<strong>y</strong>时匹配<strong>x</strong></li><li><strong>x(?!y)</strong>：当<strong>x</strong>后不是<strong>y</strong>时匹配<strong>x</strong></li></ul></li><li>引用<ul><li><strong>\1…\9</strong>：$1…$9，返回九个在模式匹配期间找到的、最近保存的部分</li></ul></li><li>或模式<ul><li><strong>x|y|z</strong>：匹配<strong>x</strong>或<strong>z</strong>或<strong>y</strong></li></ul></li></ul><h4 id="b、模式修饰符"><a href="#b、模式修饰符" class="headerlink" title="b、模式修饰符"></a>b、模式修饰符</h4><ul><li><strong>g</strong> ：全局模式，应用于所有字符串</li><li><strong>i</strong> ：区分大小写模式</li><li><strong>m</strong> ：多行匹配模式</li></ul><h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><h3 id="1、实例属性"><a href="#1、实例属性" class="headerlink" title="1、实例属性"></a>1、实例属性</h3><ul><li><strong>global</strong>：检测是否设置<strong>g</strong>标记</li><li><strong>ignoreCase</strong>：检测是否设置<strong>i</strong>标记</li><li><strong>multiline</strong>：检测是否设置了<strong>m</strong>标记</li><li><strong>lastIndex</strong>：开始检索下一个匹配项的字符位置，开始为0</li><li><strong>source</strong>：返回正则表达式的字符串表示</li></ul><h3 id="2、构造函数属性"><a href="#2、构造函数属性" class="headerlink" title="2、构造函数属性"></a>2、构造函数属性</h3><ul><li><strong>$_</strong>   <strong>input</strong> ：返回最近一次匹配的字符串</li><li><strong>$&amp;</strong>  <strong>lastMatch</strong>：返回最近一次的匹配项</li><li><strong>$+</strong>  <strong>lastParen</strong>：返回最近一次匹配的捕获组</li><li><strong>$`</strong>  <strong>leftContext</strong>：返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符</li><li><strong>$’</strong> <strong>rightContext</strong>：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符</li><li><strong>$*</strong> <strong>multiline</strong>：检测表达式是否采用多行模式匹配<strong>m</strong></li></ul><h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h2><h3 id="1、实例方法"><a href="#1、实例方法" class="headerlink" title="1、实例方法"></a>1、实例方法</h3><h4 id="a、exec"><a href="#a、exec" class="headerlink" title="a、exec"></a>a、exec</h4><ul><li>功能：在字符串中执行匹配检索，返回结果数组</li><li>参数：要应用模式匹配的字符串</li><li>特性<ul><li>使用全局标记<strong>g</strong>：持续查找所有匹配项并返回</li><li>不使用全局标记<strong>g</strong>：始终返回第一个匹配项信息</li></ul></li><li>执行过程<ul><li>检索字符串参数，获取正则表达式匹配文本</li><li>找到匹配文本则返回一个数组<ul><li>第<strong>0</strong>个元素：与整个模式匹配的字符串</li><li>其他元素：与捕获组匹配的字符串</li></ul></li><li>否则返回null</li></ul></li><li>派生属性<ul><li><strong>index</strong>：匹配项在字符串中的位置</li><li><strong>input</strong>：应用正则表达式的字符串</li><li><strong>length</strong>：返回数组元素个数</li></ul></li></ul><h4 id="b、test"><a href="#b、test" class="headerlink" title="b、test"></a>b、test</h4><ul><li>功能：在字符串中测试模式匹配，返回<strong>true</strong>或<strong>false</strong></li></ul><h3 id="2、字符串方法"><a href="#2、字符串方法" class="headerlink" title="2、字符串方法"></a>2、字符串方法</h3><ul><li><strong>match</strong>：找到一个或多个正则表达式的匹配</li><li><strong>replace</strong>：替换与正则表达式匹配的子串</li><li><strong>seach</strong>：检索与正则表达式相匹配的值</li><li><strong>split</strong>：把字符串分割为字符串数组</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、创建&quot;&gt;&lt;a href=&quot;#一、创建&quot; class=&quot;headerlink&quot; title=&quot;一、创建&quot;&gt;&lt;/a&gt;一、创建&lt;/h2&gt;&lt;h3 id=&quot;1、方式&quot;&gt;&lt;a href=&quot;#1、方式&quot; class=&quot;headerlink&quot; title=&quot;1、方式&quot;&gt;&lt;/a&gt;1、方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;字面量：&lt;strong&gt;var&lt;/strong&gt;变量名 &lt;strong&gt;=&lt;/strong&gt; &lt;strong&gt;/&lt;/strong&gt; 表达式 &lt;strong&gt;/&lt;/strong&gt; 模式修饰符&lt;/li&gt;
&lt;li&gt;函数构造：&lt;strong&gt;var&lt;/strong&gt;变量名 &lt;strong&gt;= &lt;/strong&gt; &lt;strong&gt;new RegExp(“表达式”,”模式修饰符”)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
