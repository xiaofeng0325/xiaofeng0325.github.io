<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>Knowledge is power.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-25T14:09:27.103Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android中RelativeLayout和LinearLayout性能分析</title>
    <link href="http://yoursite.com/posts/e61a64df.html"/>
    <id>http://yoursite.com/posts/e61a64df.html</id>
    <published>2019-05-01T14:02:53.000Z</published>
    <updated>2019-06-25T14:09:27.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Optimizing-Layout-Hierarchies"><a href="#Optimizing-Layout-Hierarchies" class="headerlink" title="Optimizing Layout Hierarchies"></a>Optimizing Layout Hierarchies</h1><p>It is a common misconception that using the basic layout structures leads to the most efficient layouts. However, each widget and layout you add to your application requires initialization, layout, and drawing. For example, using nested instances of <code>LinearLayout</code> can lead to an excessively deep view hierarchy. Furthermore, nesting several instances of<code>LinearLayout</code> that use the <code>layout_weight</code> parameter can be especially expensive as each child needs to be measured twice. This is particularly important when the layout is inflated repeatedly, such as when used in a <code>ListView</code>or <code>GridView</code>.</p><p>这句话是对减少布局层次的描述。</p><p>有一个误解就是，使用基类布局可用产生更有效的布局方式。然而每一个你添加到application里面的控件和布局，都需要初始化，布局，绘制。例如，布局复杂的时候使用LinearLayout，会导致深层次的布局嵌套问题，而进一步来说，使用LinearLayout的weight属性给每个子view去分配位置的时候，会导致每一个子view被绘制两次，而LinearLayout嵌套LinearLayout使用weight会更加严重。如果布局被重复的inflated的话，当我们使用ListView或者GridView的时候就会特别明显的影响绘制效率。</p><a id="more"></a><p>先看一些现象吧：用eclipse或者Android studio，新建一个Activity自动生成的布局文件都是RelativeLayout，或许你会认为这是IDE的默认设置问题，其实不然，这是由 android-sdk\tools\templates\activities\BlankActivity\root\res\layout\activity_simple.xml.ftl 这个文件事先就定好了的，也就是说这是Google的选择，而非IDE的选择。那SDK为什么会默认给开发者新建一个默认的RelativeLayout布局呢？当然是因为RelativeLayout的性能更优，性能至上嘛。但是我们再看看默认新建的这个RelativeLayout的父容器，也就是当前窗口的顶级View——DecorView，它却是个垂直方向的LinearLayout，上面是标题栏，下面是内容栏。那么问题来了，Google为什么给开发者默认新建了个RelativeLayout，而自己却偷偷用了个LinearLayout，到底谁的性能更高，开发者该怎么选择呢？</p><h3 id="View的一些基本工作原理"><a href="#View的一些基本工作原理" class="headerlink" title="View的一些基本工作原理"></a>View的一些基本工作原理</h3><p>先通过几个问题，简单的了解写android中View的工作原理吧。</p><h5 id="View是什么？"><a href="#View是什么？" class="headerlink" title="View是什么？"></a>View是什么？</h5><p>简单来说，View是Android系统在屏幕上的视觉呈现，也就是说你在手机屏幕上看到的东西都是View。</p><h5 id="View是怎么绘制出来的？"><a href="#View是怎么绘制出来的？" class="headerlink" title="View是怎么绘制出来的？"></a>View是怎么绘制出来的？</h5><p>View的绘制流程是从ViewRoot的performTraversals（）方法开始，依次经过measure（），layout（）和draw（）三个过程才最终将一个View绘制出来。</p><h5 id="View是怎么呈现在界面上的？"><a href="#View是怎么呈现在界面上的？" class="headerlink" title="View是怎么呈现在界面上的？"></a>View是怎么呈现在界面上的？</h5><p>Android中的视图都是通过Window来呈现的，不管Activity、Dialog还是Toast它们都有一个Window，然后通过WindowManager来管理View。Window和顶级View——DecorView的通信是依赖ViewRoot完成的。</p><h5 id="View和ViewGroup什么区别？"><a href="#View和ViewGroup什么区别？" class="headerlink" title="View和ViewGroup什么区别？"></a>View和ViewGroup什么区别？</h5><p>不管简单的Button和TextView还是复杂的RelativeLayout和ListView，他们的共同基类都是View。所以说，View是一种界面层控件的抽象，他代表了一个控件。那ViewGroup是什么东西，它可以被翻译成控件组，即一组View。ViewGroup也是继承View，这就意味着View本身可以是单个控件，也可以是多个控件组成的控件组。根据这个理论，Button显然是个View，而RelativeLayout不但是一个View还可以是一个ViewGroup，而ViewGroup内部是可以有子View的，这个子View同样也可能是ViewGroup，以此类推。</p><h3 id="RelativeLayout和LinearLayout性能PK"><a href="#RelativeLayout和LinearLayout性能PK" class="headerlink" title="RelativeLayout和LinearLayout性能PK"></a>RelativeLayout和LinearLayout性能PK</h3><p>基于以上原理和大背景，我们要探讨的性能问题，说的简单明了一点就是：当RelativeLayout和LinearLayout分别作为ViewGroup，表达相同布局时绘制在屏幕上时谁更快一点。上面已经简单说了View的绘制，从ViewRoot的performTraversals（）方法开始依次调用perfromMeasure、performLayout和performDraw这三个方法。这三个方法分别完成顶级View的measure、layout和draw三大流程，其中perfromMeasure会调用measure，measure又会调用onMeasure，在onMeasure方法中则会对所有子元素进行measure，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程，接着子元素会重复父容器的measure，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw也分别完成perfromMeasure类似的流程。通过这三大流程，分别遍历整棵View树，就实现了Measure，Layout，Draw这一过程，View就绘制出来了。那么我们就分别来追踪下RelativeLayout和LinearLayout这三大流程的执行耗时。<br>如下图，我们分别用两用种方式简单的实现布局测试下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190625220831.png" alt=""></p><h5 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h5><p>Measure：0.738ms<br> Layout：0.176ms<br> draw：7.655ms</p><h5 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h5><p>Measure：2.280ms<br> Layout：0.153ms<br> draw：7.696ms<br> 从这个数据来看无论使用RelativeLayout还是LinearLayout，layout和draw的过程两者相差无几，考虑到误差的问题，几乎可以认为两者不分伯仲，关键是Measure的过程RelativeLayout却比LinearLayout慢了一大截。</p><h3 id="Measure都干什么了"><a href="#Measure都干什么了" class="headerlink" title="Measure都干什么了"></a>Measure都干什么了</h3><h5 id="RelativeLayout的onMeasure-方法"><a href="#RelativeLayout的onMeasure-方法" class="headerlink" title="RelativeLayout的onMeasure()方法"></a>RelativeLayout的onMeasure()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View[] views = mSortedHorizontalChildren;</span><br><span class="line">    <span class="keyword">int</span> count = views.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      View child = views[i];</span><br><span class="line">      <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">        LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"></span><br><span class="line">        applyHorizontalSizeRules(params, myWidth, rules);</span><br><span class="line">        measureChildHorizontal(child, params, myWidth, myHeight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</span><br><span class="line">          offsetHorizontalAxis = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    views = mSortedVerticalChildren;</span><br><span class="line">    count = views.length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      View child = views[i];</span><br><span class="line">      <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">        LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">       </span><br><span class="line">        applyVerticalSizeRules(params, myHeight);</span><br><span class="line">        measureChild(child, params, myWidth, myHeight);</span><br><span class="line">        <span class="keyword">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</span><br><span class="line">          offsetVerticalAxis = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">              width = Math.max(width, myWidth - params.mLeft);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              width = Math.max(width, myWidth - params.mLeft - params.leftMargin);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">              width = Math.max(width, params.mRight);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              width = Math.max(width, params.mRight + params.rightMargin);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">          <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            height = Math.max(height, params.mBottom);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            height = Math.max(height, params.mBottom + params.bottomMargin);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child != ignore || verticalGravity) &#123;</span><br><span class="line">          left = Math.min(left, params.mLeft - params.leftMargin);</span><br><span class="line">          top = Math.min(top, params.mTop - params.topMargin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child != ignore || horizontalGravity) &#123;</span><br><span class="line">          right = Math.max(right, params.mRight + params.rightMargin);</span><br><span class="line">          bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据源码我们发现RelativeLayout会对子View做两次measure。这是为什么呢？首先RelativeLayout中子View的排列方式是基于彼此的依赖关系，而这个依赖关系可能和布局中View的顺序并不相同，在确定每个子View的位置的时候，就需要先给所有的子View排序一下。又因为RelativeLayout允许A，B 2个子View，横向上B依赖A，纵向上A依赖B。所以需要横向纵向分别进行一次排序测量。</p><h5 id="LinearLayout的onMeasure-方法"><a href="#LinearLayout的onMeasure-方法" class="headerlink" title="LinearLayout的onMeasure()方法"></a>LinearLayout的onMeasure()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">    measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与RelativeLayout相比LinearLayout的measure就简单明了的多了，先判断线性规则，然后执行对应方向上的测量。随便看一个吧。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">      <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTotalLength += measureNullChild(i);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">       i += getChildrenSkipCount(child, i);</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">        mTotalLength += mDividerHeight;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">      totalWeight += lp.weight;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Optimization: don't bother measuring children who are going to use</span></span><br><span class="line">        <span class="comment">// leftover space. These views will get measured again down below if</span></span><br><span class="line">        <span class="comment">// there is any leftover space.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">        mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></span><br><span class="line">          <span class="comment">// child wanted to stretch to fill available space.</span></span><br><span class="line">          <span class="comment">// Translate that to WRAP_CONTENT so that it does not end up</span></span><br><span class="line">          <span class="comment">// with a height of 0</span></span><br><span class="line">          oldHeight = <span class="number">0</span>;</span><br><span class="line">          lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine how big this child would like to be. If this or</span></span><br><span class="line">        <span class="comment">// previous children have given a weight, then we allow it to</span></span><br><span class="line">        <span class="comment">// use all available space (and we will shrink things later</span></span><br><span class="line">        <span class="comment">// if needed).</span></span><br><span class="line">        measureChildBeforeLayout(</span><br><span class="line">           child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</span><br><span class="line">           totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">         lp.height = oldHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">        mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">           lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">          largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>父视图在对子视图进行measure操作的过程中，使用变量mTotalLength保存已经measure过的child所占用的高度，该变量刚开始时是0。在for循环中调用measureChildBeforeLayout（）对每一个child进行测量，该函数实际上仅仅是调用了measureChildWithMargins(),在调用该方法时，使用了两个参数。其中一个是heightMeasureSpec，该参数为LinearLayout本身的measureSpec；另一个参数就是mTotalLength，代表该LinearLayout已经被其子视图所占用的高度。 每次for循环对child测量完毕后，调用child.getMeasuredHeight()获取该子视图最终的高度，并将这个高度添加到mTotalLength中。<strong>在本步骤中，暂时避开了lp.weight&gt;0的子视图，即暂时先不测量这些子视图，因为后面将把父视图剩余的高度按照weight值的大小平均分配给相应的子视图。</strong>源码中使用了一个局部变量totalWeight累计所有子视图的weight值。处理lp.weight&gt;0的情况需要注意，如果变量heightMode是EXACTLY，那么，当其他子视图占满父视图的高度后，weight&gt;0的子视图可能分配不到布局空间，从而不被显示，只有当heightMode是AT_MOST或者UNSPECIFIED时，weight&gt;0的视图才能优先获得布局高度。最后我们的结论是：如果不使用weight属性，LinearLayout会在当前方向上进行一次measure的过程，如果使用weight属性，LinearLayout会避开设置过weight属性的view做第一次measure，完了再对设置过weight属性的view做第二次measure。由此可见，weight属性对性能是有影响的，而且本身有大坑，请注意避让。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>从源码中我们似乎能看出，我们先前的测试结果中RelativeLayout不如LinearLayout快的根本原因是RelativeLayout需要对其子View进行两次measure过程。而LinearLayout则只需一次measure过程，所以显然会快于RelativeLayout，但是如果LinearLayout中有weight属性，则也需要进行两次measure，但即便如此，应该仍然会比RelativeLayout的情况好一点。</p><h3 id="RelativeLayout另一个性能问题"><a href="#RelativeLayout另一个性能问题" class="headerlink" title="RelativeLayout另一个性能问题"></a>RelativeLayout另一个性能问题</h3><p>对比到这里就结束了嘛？显然没有！我们再看看View的Measure（）方法都干了些什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">        widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">        heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line">                     ......</span><br><span class="line">      &#125;</span><br><span class="line">       mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">    mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">        (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>View的measure方法里对绘制过程做了一个优化，如果我们或者我们的子View没有要求强制刷新，而父View给子View的传入值也没有变化（也就是说子View的位置没变化），就不会做无谓的measure。但是上面已经说了RelativeLayout要做两次measure，而在做横向的测量时，纵向的测量结果尚未完成，只好暂时使用myHeight传入子View系统，假如子View的Height不等于（设置了margin）myHeight的高度，那么measure中上面代码所做得优化将不起作用，这一过程将进一步影响RelativeLayout的绘制性能。而LinearLayout则无这方面的担忧。解决这个问题也很好办，如果可以，尽量使用padding代替margin。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>1.RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure<br> 2.RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。<br> 3.在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。<br> 最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Optimizing-Layout-Hierarchies&quot;&gt;&lt;a href=&quot;#Optimizing-Layout-Hierarchies&quot; class=&quot;headerlink&quot; title=&quot;Optimizing Layout Hierarchies&quot;&gt;&lt;/a&gt;Optimizing Layout Hierarchies&lt;/h1&gt;&lt;p&gt;It is a common misconception that using the basic layout structures leads to the most efficient layouts. However, each widget and layout you add to your application requires initialization, layout, and drawing. For example, using nested instances of &lt;code&gt;LinearLayout&lt;/code&gt; can lead to an excessively deep view hierarchy. Furthermore, nesting several instances of&lt;code&gt;LinearLayout&lt;/code&gt; that use the &lt;code&gt;layout_weight&lt;/code&gt; parameter can be especially expensive as each child needs to be measured twice. This is particularly important when the layout is inflated repeatedly, such as when used in a &lt;code&gt;ListView&lt;/code&gt;or &lt;code&gt;GridView&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这句话是对减少布局层次的描述。&lt;/p&gt;
&lt;p&gt;有一个误解就是，使用基类布局可用产生更有效的布局方式。然而每一个你添加到application里面的控件和布局，都需要初始化，布局，绘制。例如，布局复杂的时候使用LinearLayout，会导致深层次的布局嵌套问题，而进一步来说，使用LinearLayout的weight属性给每个子view去分配位置的时候，会导致每一个子view被绘制两次，而LinearLayout嵌套LinearLayout使用weight会更加严重。如果布局被重复的inflated的话，当我们使用ListView或者GridView的时候就会特别明显的影响绘制效率。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Android Tips" scheme="http://yoursite.com/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yoursite.com/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>FlutterPlugin开发流程</title>
    <link href="http://yoursite.com/posts/b7213cdb.html"/>
    <id>http://yoursite.com/posts/b7213cdb.html</id>
    <published>2019-04-29T08:00:03.000Z</published>
    <updated>2019-05-27T08:02:01.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章主要介绍了Flutter Plugin开发流程，包括如何利用Android Studio开发以及发布等。</p></blockquote><p>今天这篇文章，给大家介绍如何开发Flutter Plugin中Android的部分。有关Flutter以及Flutter Plugin的概念，感兴趣的可以从官网查看相关资料。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>笔者的环境是Mac下Android Studio进行的开发，AS也是谷歌官推的，安装flutter插件后，开发起来相对于其他IDE来说，方便很多，自带了三种模板：</p><ul><li>Flutter Application： Flutter应用</li><li>Flutter Plugin：Flutter插件</li><li>Flutter Package：纯Dart组件</li></ul><p><code>Plugin其实就是一个特殊的Package</code>。Flutter Plugin提供Android或者iOS的底层封装，在Flutter层提供组件功能，使Flutter可以较方便的调取Native的模块。很多平台相关性或者对于Flutter实现起来比较复杂的部分，都可以封装成Plugin。其原理如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527160122.png" alt=""></p><p>消息在client和host之间通过平台通道（platform channels）来进行的，之间的通讯都是<code>异步</code>的。</p><a id="more"></a><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><p>直接在Android Studio中新建一个Flutter Plugin的工程，当然也可以使用命令行来进行，例如创建一个flutter_text_plugin。</p><blockquote><p>flutter create –org com.example –plugin flutter_text_plugin</p></blockquote><p>如果想支持swift或者kotlin，可以用如下命令进行创建:</p><blockquote><p>flutter create –org com.example –plugin -i swift -a kotlin flutter_text_plugin</p></blockquote><p>更多的参数选项，大家可以 查看帮助文档，当然还是比较推荐直接用AS进行创建，简单直观。用AS打开项目，可以看到项目的组织结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">    android</span><br><span class="line">    example</span><br><span class="line">    ios</span><br><span class="line">    lib</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>android以及ios文件夹是我们将要编写插件的native层的地方，lib文件夹是编写与native层映射的地方，native与flutter之间不能直接通信，必须通过MethodChannel来间接调用。example文件夹则是例子工程，编写的插件可以直接在这个项目中进行验证。在本文中，我们主要在android目录下进行，也就是android部分。</p><h2 id="编写Android部分"><a href="#编写Android部分" class="headerlink" title="编写Android部分"></a>编写Android部分</h2><p>用AS打开flutter_text_plugin/android项目，这样子开发起来比较方便。但是打开过后，会发现出现了很多错误，提示找不到flutter相关的东西，我们仔细看这个项目，会发现跟我们平时用AS建的Android项目有所不同，少了很多部分，目录也有所不同。这是因为这个android项目不需要能够直接去运行，因此减少了很多东西。但是对于初次接触的人来说，可能是一头懵逼，例如该如何添加第三方库，如何添加proguard rule等等。</p><h3 id="引入flutter库"><a href="#引入flutter库" class="headerlink" title="引入flutter库"></a>引入flutter库</h3><p>android插件工程是没有引入flutter库的，所以才会出现错误提示，我们在项目根目录建立一个libs文件夹，用来存放flutter库。</p><p>flutter库就在我们的flutter sdk中，路径如下</p><blockquote><p><sdk project="">/bin/cache/artifacts/engine</sdk></p></blockquote><p>engine下面包含了各种平台的flutter库，我们随便拷贝一个Android平台的库到libs文件夹下，右键flutter.jar，弹出菜单选择<code>Add As Library...</code>。</p><p>经过这一步，项目中不会再报错了，但是，由于整个flutter plugin包含了flutter库，因此不能只是简单的添加就了事了，点击菜单<code>Project Structure...</code>，找到flutter_text_plugin的Dependencies中，将flutter库的Scope从Implementation改成<code>Compile Only</code>。至此，引入flutter库的工作完成了，可以进行插件的编写操作了。</p><h3 id="添加第三方库"><a href="#添加第三方库" class="headerlink" title="添加第三方库"></a>添加第三方库</h3><p>添加第三方库有两种，一种是jar包引入，另一种通过gradle的方式进行。由于进行了第一步flutter库的引入，这一步就简单多了。查看build.gradle文件，可以看到最下面出现了如下的信息。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compileOnly files(<span class="string">'libs/flutter.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个，是不是就明朗多了，添加静态库以及添加在线库都可以在这个地方进行。例如我添加一个bugly静态库以及okhttp3库：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compileOnly files(<span class="string">'libs/flutter.jar'</span>)</span><br><span class="line">  implementation <span class="string">'com.squareup.okhttp3:okhttp:3.10.0'</span></span><br><span class="line">  implementation files(<span class="string">'libs/bugly_crash_release.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加proguard-rule"><a href="#添加proguard-rule" class="headerlink" title="添加proguard rule"></a>添加proguard rule</h3><p>由于了bugly以及okhttp3库，因此需要添加progurad rule。我们发现项目中没有proguard-rules.pro文件，因此这一步也需要我们自己去创建，在根目录下，建立proguard-rules.pro文件，将混淆规则添加进去，然后修改build.gradle文件，添加如下信息，跟普通Android项目差不多：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">      minifyEnabled <span class="keyword">true</span></span><br><span class="line">      proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">    debug &#123;</span><br><span class="line">      minifyEnabled <span class="keyword">false</span></span><br><span class="line">      proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Android权限"><a href="#Android权限" class="headerlink" title="Android权限"></a>Android权限</h3><p>添加了bugly以及okhttp3库，需要对应的权限申明，才能正常运行。直接在manifest文件下，添加对应的权限</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_LOGS"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h3><p>至此，准备工作都已就绪，你可以把这个项目当做一个独立的Android项目，在上面进行各种封装操作，然后在FlutterTestPlugin文件下，将接口暴露出来。通过platform channels与flutter层关联起来。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>当插件开发完毕，可以将插件发布让其他人使用，在发布之前，确保pubspec.yaml,、README.md以及CHANGELOG.md文件的内容都正确填写完毕。可以通过dry-run命令来看准备是否就绪。</p><blockquote><p>flutter packages pub publish –dry-run</p></blockquote><p>检查无误后，可以执行下面的命令，发布到<a href="https://pub.dartlang.org/" target="_blank" rel="noopener">Pub</a>上。</p><blockquote><p>flutter packages pub publish</p></blockquote><h2 id="如何引用"><a href="#如何引用" class="headerlink" title="如何引用"></a>如何引用</h2><p>对插件的引用有两种，已经发布的和未发布的。</p><h3 id="引用发布的库"><a href="#引用发布的库" class="headerlink" title="引用发布的库"></a>引用发布的库</h3><p>flutter项目的很多资源管理都在根目录的pubspec.yaml下面，类似于js中的一些包管理一样，在<code>dependencies</code>加上我们需要引入的库，例如引入url_launcher库：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  url_launcher: ^<span class="number">0.4</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>如果这个库包含了一些平台相关的东西，例如需要在native层进行使用的话，则需要在对应的native项目单独做引用。</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>修改android/build.gradle的dependencies处做引用：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        provided rootProject.findProject(<span class="string">":url_launcher"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>修改ios/hello.podspec文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  # lines skipped</span><br><span class="line">  s.dependency &apos;url_launcher&apos;</span><br></pre></td></tr></table></figure><h4 id="引用冲突"><a href="#引用冲突" class="headerlink" title="引用冲突"></a>引用冲突</h4><p>引用不同的库可能会导致一些冲突，例如A和B两个插件，都包含了C插件，但是所需的版本不同。因此我们可以采取以下措施避免这种问题：</p><ul><li>尽量使用范围版本而不是指定一个特定的版本。</li><li>强制统一冲突的插件版本</li><li>对于native层，android可以通过force命令强制指定版本，而iOS这边，Cocoapods则不支持引用的override功能。</li></ul><h3 id="引用未发布的库"><a href="#引用未发布的库" class="headerlink" title="引用未发布的库"></a>引用未发布的库</h3><p>引用未发布的库有两种方式，通过本地路径和git地址的方式：</p><h4 id="基于Path的引用方式："><a href="#基于Path的引用方式：" class="headerlink" title="基于Path的引用方式："></a>基于Path的引用方式：</h4><p>这种方式主要针对本地的未发布的库，引用的路径可以是相对或者绝对路径。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  plugin1:</span><br><span class="line">    path: ../plugin1/</span><br></pre></td></tr></table></figure><h4 id="基于Git的引用方式："><a href="#基于Git的引用方式：" class="headerlink" title="基于Git的引用方式："></a>基于Git的引用方式：</h4><p>这种方式针对存放在git上的库，其中path是可选的，可以定位到某个子目录</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  package1:</span><br><span class="line">    git:</span><br><span class="line">      url: git:<span class="comment">//github.com/flutter/packages.git</span></span><br><span class="line">      path: packages/package1</span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>笔者新建了一个flutter学习相关的项目，<a href="https://github.com/yang7229693/flutter-study" target="_blank" rel="noopener">github地址</a>，里面包含了笔者写的关于flutter学习相关的一些文章，后期也会定期更新，也会上传一些学习demo，欢迎大家关注。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/hekaiyou/article/details/72862653" target="_blank" rel="noopener">Flutter进阶—平台插件</a></li><li><a href="https://www.youtube.com/watch?v=tErY3QWTZSA&amp;t=883s" target="_blank" rel="noopener">Flutter - Creating a Plugin</a></li><li><a href="https://flutter.io/flutter-for-android/" target="_blank" rel="noopener">Flutter for Android Developers</a></li><li><a href="https://flutter.io/platform-channels/" target="_blank" rel="noopener">Writing custom platform-specific code with platform channels</a></li><li><a href="https://flutter.io/developing-packages/#step-2b-add-android-platform-code-javakt" target="_blank" rel="noopener">Developing Packages &amp; Plugins</a></li><li><a href="https://flutter.io/using-packages/" target="_blank" rel="noopener">Using Packages</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章主要介绍了Flutter Plugin开发流程，包括如何利用Android Studio开发以及发布等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天这篇文章，给大家介绍如何开发Flutter Plugin中Android的部分。有关Flutter以及Flutter Plugin的概念，感兴趣的可以从官网查看相关资料。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;笔者的环境是Mac下Android Studio进行的开发，AS也是谷歌官推的，安装flutter插件后，开发起来相对于其他IDE来说，方便很多，自带了三种模板：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flutter Application： Flutter应用&lt;/li&gt;
&lt;li&gt;Flutter Plugin：Flutter插件&lt;/li&gt;
&lt;li&gt;Flutter Package：纯Dart组件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Plugin其实就是一个特殊的Package&lt;/code&gt;。Flutter Plugin提供Android或者iOS的底层封装，在Flutter层提供组件功能，使Flutter可以较方便的调取Native的模块。很多平台相关性或者对于Flutter实现起来比较复杂的部分，都可以封装成Plugin。其原理如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527160122.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;消息在client和host之间通过平台通道（platform channels）来进行的，之间的通讯都是&lt;code&gt;异步&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter与Android的交互</title>
    <link href="http://yoursite.com/posts/5ae94dfd.html"/>
    <id>http://yoursite.com/posts/5ae94dfd.html</id>
    <published>2019-04-29T07:46:33.000Z</published>
    <updated>2019-05-27T08:01:52.234Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 说到底只是一个 UI 框架，很多功能都需要通过原生的 Api 来实现，那么就会涉及到 Flutter 和 Native 的交互，因为本人不懂 iOS 开发，所以只能讲下 Flutter 同 Android 的交互。</p><h4 id="Android-项目配置-Flutter-依赖"><a href="#Android-项目配置-Flutter-依赖" class="headerlink" title="Android 项目配置 Flutter 依赖"></a>Android 项目配置 Flutter 依赖</h4><p>既然是互相交互，那么需要准备一个 Android 项目。接着就需要创建 flutter module，让 Android 项目依赖，创建的方法可以参考官网 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fwiki%2FAdd-Flutter-to-existing-apps" target="_blank" rel="noopener">Flutter Wiki</a>，虽然是官网提供的方法，但是完全按照这个步骤来，还是会有坑的，这边就慢慢一步步解决坑。</p><p>如果你用的是 Android Studio 进行开发的话，直接打开底部的 Terminal，直接创建 flutter module 依赖</p><p><code>flutter create -t module flutter_native_contact</code> 至于 module 名可以随意填写，module 创建完后结构大概是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154756.png" alt=""></p><a id="more"></a><p>接着切换到 module 下的 .android 文件夹，接着有坑来了，官网提供的方法是 <code>./gradlew flutter:assembleDebug</code> 可能会提示命令不存在，那么直接通过 <code>gradlew flutter:assembleDebug</code> 来运行，等它自动跑完后，打开根目录下的 <code>settings.gradle</code> 文件，加入官网提供的 gradle 代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setBinding(<span class="keyword">new</span> Binding([gradle: <span class="keyword">this</span>]))                                 <span class="comment">// new</span></span><br><span class="line">evaluate(<span class="keyword">new</span> File(                                                      <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                               <span class="comment">// new</span></span><br><span class="line">  <span class="string">'flutter_native_contact/.android/include_flutter.groovy'</span>              <span class="comment">// new</span></span><br><span class="line">))                                                                      <span class="comment">// new</span></span><br></pre></td></tr></table></figure><p>你以为这里没坑，真是图样图森破，没坑是不可能的，编译器大爷可能会给你甩这么个错误</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154815.png" alt=""></p><p>很明显可以看出是找不到我们的文件，所以把文件名路径给补全</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">evaluate(<span class="keyword">new</span> File(                                                      <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                               <span class="comment">// new</span></span><br><span class="line">  <span class="string">'FlutterNativeContactDemo/flutter_native_contact/.android/include_flutter.groovy'</span> <span class="comment">// 这里补全路径</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>接着打开原有项目下，原有项目下，原有项目下的 app 中的 <code>build.gradle</code> 文件，在 android 下加上如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">  sourceCompatibility <span class="number">1.8</span></span><br><span class="line">  targetCompatibility <span class="number">1.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个必须要加，不要问为什么，我也不知道为什么，最后在项目下添加 flutter module 的依赖就完成了。这个过程告诉我们一个什么道理呢？*不要以为官网的都对，官网讲的也不是完全可信的，时不时给你来个坑就能卡你老半天。</p><h4 id="原生界面加载-Flutter-页面"><a href="#原生界面加载-Flutter-页面" class="headerlink" title="原生界面加载 Flutter 页面"></a>原生界面加载 Flutter 页面</h4><p>那么如何在原生界面显示 Flutter 界面呢，这个就需要通过 FlutterView 来实现了，Flutter 这个类提供了 <code>createView</code> 和 <code>createFragment</code> 两个方法，分别用于返回 FlutterView 和 FlutterFragment 实例，FlutterFragment 的实现原理也是通过 FlutterView 来实现的，可以简单看下 FlutterFragment 的源码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;@link Fragment&#125; managing a &#123;@link FlutterView&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This file is auto-generated by Flutter tooling.</span></span><br><span class="line"><span class="comment"> * DO NOT EDIT.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlutterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> ARG_ROUTE = <span class="string">"route"</span>;</span><br><span class="line">  private <span class="built_in">String</span> mRoute = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public <span class="keyword">void</span> onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// 获取传入的路由值，默认为 '/'</span></span><br><span class="line">    <span class="keyword">if</span> (getArguments() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mRoute = getArguments().getString(ARG_ROUTE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public FlutterView onCreateView(<span class="meta">@NonNull</span> LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="comment">// 最后还是挺过 createView 方法来生成页面，只不过直接放在 fragment，</span></span><br><span class="line">    <span class="comment">// 放在 fragment 会比直接 使用 FlutterView 更方便管理，例如实现 ViewPager 等</span></span><br><span class="line">    <span class="keyword">return</span> Flutter.createView(getActivity(), getLifecycle(), mRoute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="createFragment-方式加载"><a href="#createFragment-方式加载" class="headerlink" title="createFragment 方式加载"></a>createFragment 方式加载</h5><p>在原生页面显示 Flutter 界面的第一种方式就是加载 FlutterFragment，看个比较简单的例子吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    tools:context=<span class="string">".MainActivity"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个布局用于加载 fragment --&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=<span class="string">"@+id/fragment_container"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">        android:id=<span class="string">"@+id/flutter_fragment"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_marginEnd=<span class="string">"20dp"</span></span><br><span class="line">        android:layout_marginBottom=<span class="string">"50dp"</span></span><br><span class="line">        android:src=<span class="string">"@drawable/ic_add_white_36dp"</span></span><br><span class="line">        app:fabSize=<span class="string">"auto"</span></span><br><span class="line">        app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintEnd_toEndOf=<span class="string">"parent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>在 Activity 可以直接通过返回 FlutterFragment 加载到 FrameLayout 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="title">AppCompatActivity</span>() </span>&#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        supportFragmentManager.beginTransaction()</span><br><span class="line">            .add(R.id.fragment_container, Flutter.createFragment(<span class="string">"route_flutter"</span>))</span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把 Flutter 页面加载到原生界面了，会通过传递的路由值在 dart 层进行查找，所以接着就需要编写 Flutter 界面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// runApp 内部值也可以直接传入 _buildWidgetForNativeRoute 方法</span></span><br><span class="line"><span class="comment">/// 这边在外层嵌套一层 MaterialApp 主要是防止一些不必要的麻烦，</span></span><br><span class="line"><span class="comment">/// 例如 MediaQuery 这方面的使用等</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(FlutterApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: _buildWidgetForNativeRoute(<span class="built_in">window</span>.defaultRouteName),</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Color(<span class="number">0XFF008577</span>),</span><br><span class="line">        accentColor: Color(<span class="number">0xFFD81B60</span>),</span><br><span class="line">        primaryColorDark: Color(<span class="number">0xFF00574B</span>),</span><br><span class="line">        iconTheme: IconThemeData(color: Color(<span class="number">0xFFD81B60</span>)),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 该方法用于判断原生界面传递过来的路由值，加载不同的页面</span></span><br><span class="line">Widget _buildWidgetForNativeRoute(<span class="built_in">String</span> route) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'route_flutter'</span>:</span><br><span class="line">      <span class="keyword">return</span> GreetFlutterPage();</span><br><span class="line">    <span class="comment">// 默认的路由值为 '/'，所以在 default 情况也需要返回页面，否则 dart 会报错，这里默认返回空页面</span></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> Scaffold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetFlutterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'NativeMessageContactPage'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(</span><br><span class="line">          <span class="string">'This is a flutter fragment page'</span>,</span><br><span class="line">          style: TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.black),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到页面加载出来了，不过会有一段时间的空白，这个在正式打包后就不会出现，所以不必担心。最后的页面应该是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154907.png" alt=""></p><h5 id="createView-方式加载"><a href="#createView-方式加载" class="headerlink" title="createView 方式加载"></a>createView 方式加载</h5><p>接着看下 createView 方法，说白了，第一种方法最后还是会通过该方式实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">public <span class="keyword">static</span> FlutterView createView(<span class="meta">@NonNull</span> <span class="keyword">final</span> Activity activity, <span class="meta">@NonNull</span> <span class="keyword">final</span> Lifecycle lifecycle, <span class="keyword">final</span> <span class="built_in">String</span> initialRoute) &#123;</span><br><span class="line">  <span class="comment">// 交互前的一些初始化工作，需要完成才可以继续下一步，同时需要保证当前线程为主线程</span></span><br><span class="line">  <span class="comment">// Looper.myLooper() == Looper.getMainLooper()，否则会甩你一脸的 IllegalStateException </span></span><br><span class="line">  FlutterMain.startInitialization(activity.getApplicationContext());</span><br><span class="line">  FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> FlutterNativeView nativeView = <span class="keyword">new</span> FlutterNativeView(activity);</span><br><span class="line">  <span class="comment">// 将 flutter 页面绑定到相应的 activity</span></span><br><span class="line">  <span class="keyword">final</span> FlutterView flutterView = <span class="keyword">new</span> FlutterView(activity, <span class="keyword">null</span>, nativeView) &#123;</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 将路由值传到 flutter 层，并加载相应的页面，</span></span><br><span class="line">  <span class="keyword">if</span> (initialRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">    flutterView.setInitialRoute(initialRoute);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 绑定 lifecycle，方便生命周期管理，同 activity 绑定</span></span><br><span class="line">  <span class="comment">// 不熟悉 LifeCycle 的同学可以自行网上查找资料</span></span><br><span class="line">  lifecycle.addObserver(<span class="keyword">new</span> LifecycleObserver() &#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    public <span class="keyword">void</span> onCreate() &#123;</span><br><span class="line">      <span class="comment">// 配置一些参数，传递到 flutter 层</span></span><br><span class="line">      <span class="keyword">final</span> FlutterRunArguments arguments = <span class="keyword">new</span> FlutterRunArguments();</span><br><span class="line">      arguments.bundlePath = FlutterMain.findAppBundlePath(activity.getApplicationContext());</span><br><span class="line">      arguments.entrypoint = <span class="string">"main"</span>;</span><br><span class="line">      <span class="comment">// 最终会调用方法 nativeRunBundleAndSnapshotFromLibrary，这是一个 native 方法，进行交互</span></span><br><span class="line">      flutterView.runFromBundle(arguments);</span><br><span class="line">      <span class="comment">// 进行注册</span></span><br><span class="line">      GeneratedPluginRegistrant.registerWith(flutterView.getPluginRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flutterView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 createView 方法返回的 FlutterView，通过设置 Layoutparams 参数就可以添加到相应的布局上，还有一种直接通过 addContentView 方式进行加载，这里直接修改原有代码，</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// setContentView(R.layout.activity_main) 不需要这一步了</span></span><br><span class="line">        val flutterView = Flutter.createView(<span class="keyword">this</span><span class="meta">@ContactActivity</span>, lifecycle, <span class="string">"route_flutter"</span>)</span><br><span class="line">        val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</span><br><span class="line">        addContentView(flutterView, lp) <span class="comment">// 直接加载到 activity 页面</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是通过这样加载的话，那么整个页面都是 flutter 的页面。那么之前的效果的 FAB 则不会被加载出来了，即使没有省略 <code>setContentView(R.layout.activity_main)</code> 方法，这个页面的 xml 布局也会被覆盖。</p><h4 id="PlantformChannel"><a href="#PlantformChannel" class="headerlink" title="PlantformChannel"></a>PlantformChannel</h4><p>那么能够在原生界面显示 flutter 页面了，如何互相交互呢，这就需要通过 PlantformChannel 来执行了，PlantformChannel 主要有三种类型，BasicMessageChannel，MethodChannel，EventChannel。通过查看源码可以发现，三个 Channel 的实现机制类似，都是通过 BinaryMessenger 进行信息交流，每个 Channel 通过传入的 channel name 进行区分，所以在注册 Channel 的时候必须要保证 channel name 是唯一的，同时需要传入一个 BinaryMessageHandler 实例，用于传递信息的处理，当 Handler 处理完信息后，会返回一个 result，然后通过 BinaryMessenger 将 result 返回到 Flutter 层。如果需要深入理解这边推荐一篇文章<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5b84ff6a6fb9a019f47d1cc9" target="_blank" rel="noopener">深入理解Flutter PlatformChannel</a></p><p>接下来直接看例子吧，在创建 PlatformChannel 的时候需要传入一个 BinaryMessenger 实例，通过查看 FlutterView 的源码可以发现，FlutterView 就是一个 BinaryMessenger 在 Android 端的实现，所以呢，可以直接通过前面介绍的 <code>Flutter.createView</code> 方法获取注册 Channel 时的 BinaryMessenger 实例了，真是得来全部费工夫~因为通信的方法可能在多个界面会使用，所以还是封装一个通用类来处理会比较合理</p><h5 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a>BasicMessageChannel</h5><blockquote><p>BasicMessageChannel 用于传递字符串和半结构化的信息。</p></blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span>(<span class="title">private</span> <span class="title">val</span> <span class="title">flutterView</span>: <span class="title">FlutterView</span>) :<span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">Any</span>&gt;</span>&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private <span class="keyword">const</span> val TAG = <span class="string">"FlutterPlugin"</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123;</span><br><span class="line">            <span class="comment">// channel name 需要保持两侧一致</span></span><br><span class="line">            val messageChannel =</span><br><span class="line">               BasicMessageChannel(flutterView, Constant.MESSAGE_CHANNEL_NAME, StandardMessageCodec.INSTANCE) <span class="comment">// MessageCodec 有多种实现方式，可以参考推荐的文章</span></span><br><span class="line"></span><br><span class="line">            val instance = FlutterPlugin(flutterView)</span><br><span class="line">            messageChannel.setMessageHandler(instance) <span class="comment">// 注册处理的 Hnadler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onMessage(`object`: Any?, reply: BasicMessageChannel.Reply&lt;Any&gt;?) &#123;</span><br><span class="line">        <span class="comment">// 简单的将从 Flutter 传过来的消息进行吐司，同时返回自己的交互信息</span></span><br><span class="line">        <span class="comment">// `object` 中包含的就是 Flutter 层传递过来的信息，reply 实例用于传递信息到 Flutter 层</span></span><br><span class="line">        Toast.makeText(flutterView.context, `object`.toString(), Toast.LENGTH_LONG).show()</span><br><span class="line">        reply?.reply(<span class="string">"\"Hello Flutter\"--- an message from Android"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就需要有个 FlutterView 用来注册，新建一个 Activity，用于加载 Flutter 页面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactActivity</span> : <span class="title">AppCompatActivity</span>() </span>&#123;</span><br><span class="line">    private lateinit <span class="keyword">var</span> plugin: FlutterPlugin</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入路由值，需要在 flutter 层生成相应的界面</span></span><br><span class="line">        val flutterView = Flutter.createView(<span class="keyword">this</span><span class="meta">@ContactActivity</span>, lifecycle, <span class="string">"route_contact"</span>)</span><br><span class="line">        val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</span><br><span class="line">        addContentView(flutterView, lp)</span><br><span class="line"></span><br><span class="line">        plugin = FlutterPlugin.registerPlugin(flutterView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就要在 Flutter 界面的 <code>_buildWidgetForNativeRoute</code> 方法加入新路由值对应的界面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _buildWidgetForNativeRoute(<span class="built_in">String</span> route) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'route_contact'</span>:</span><br><span class="line">      <span class="keyword">return</span> FlutterContactPage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> Scaffold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterContactPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注册对应的 channel，要保证 channel name 和原生层是一致的</span></span><br><span class="line">  <span class="keyword">final</span> BasicMessageChannel _messageChannel =</span><br><span class="line">      BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Flutter Page'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 简单放一个按钮，通过 channel 传输消息过去，同时将原生层返回的消息打印出来</span></span><br><span class="line">      body: RaisedButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          _messageChannel</span><br><span class="line">              .send(<span class="string">'"Hello Native" --- an message from flutter'</span>)</span><br><span class="line">              .then((str) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Receive message: $str'</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Text(<span class="string">'Send Message to Native'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果小伙伴可以自行执行，点击按钮后会弹出吐司，吐司内容就是 Flutter 传递的信息，同时在控制台可以看到从原生层返回的信息。</p><h5 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h5><blockquote><p>MethodChannel 用于传递方法调用（method invocation）</p></blockquote><p>直接在上述例子中进行修改，例如在 Flutter 页面中实现 Activity 的 finish 方法，并传递参数到前一个界面，先做 Flutter 页面的修改，在 AppBar 上增加一个返回按钮，用于返回上层页面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterContactPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注册对应的 channel，要保证 channel name 和原生层是一致的</span></span><br><span class="line">  <span class="keyword">final</span> BasicMessageChannel _messageChannel =</span><br><span class="line">      BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec());</span><br><span class="line">  <span class="keyword">final</span> MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        leading: InkWell(</span><br><span class="line">          child: Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">20.0</span>),</span><br><span class="line">            child: Icon(Icons.arrow_back),</span><br><span class="line">          ),</span><br><span class="line">          onTap: () &#123;</span><br><span class="line">            _methodChannel</span><br><span class="line">                <span class="comment">// invokeMethod 第一个值用于传递方法名，第二个值用于传递参数，</span></span><br><span class="line">                <span class="comment">// 这边简单的传递一个字符串，当然也可以传递别的类型，map，list 等等</span></span><br><span class="line">                .invokeMethod&lt;<span class="built_in">bool</span>&gt;(<span class="string">'finishActivity'</span>, <span class="string">'Finish Activity'</span>)</span><br><span class="line">                .then((result) &#123; <span class="comment">// 这边会返回一个结果值，通过判断是否成功来打印不同的信息</span></span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;result ? <span class="string">'has finish'</span> : <span class="string">'not finish'</span>&#125;</span>'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        title: Text(<span class="string">'Flutter Page'</span>),</span><br><span class="line">      ),</span><br><span class="line">        </span><br><span class="line">      body: <span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们需要在 FlutterPlugin 这个类中，做些必要的修改，首先需要实现 <code>MethodCallHandler</code> 接口，该接口中需要实现 <code>onMethodCall</code> 方法，通过获取调用的方法名和参数值，进行相应的处理</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span>(<span class="title">private</span> <span class="title">val</span> <span class="title">flutterView</span>: <span class="title">FlutterView</span>) :</span></span><br><span class="line"><span class="class">    <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span>, <span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">Any</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private <span class="keyword">const</span> val TAG = <span class="string">"FlutterPlugin"</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123;</span><br><span class="line">            val instance = FlutterPlugin(flutterView)</span><br><span class="line">            val methodChannel = MethodChannel(flutterView, Constant.METHOD_CHANNEL_NAME)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            messageChannel.setMessageHandler(instance)</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// call 中携带了 Flutter 层传递过来的方法名和参数信息</span></span><br><span class="line">    <span class="comment">// 可以分别通过 call.method 和 call.arguments 来获取</span></span><br><span class="line">    override fun onMethodCall(call: MethodCall?, result: MethodChannel.Result?) &#123;</span><br><span class="line">        when (call?.method) &#123;</span><br><span class="line">            <span class="string">"finishActivity"</span> -&gt; &#123;</span><br><span class="line">                val activity = flutterView.context <span class="keyword">as</span> Activity</span><br><span class="line">                val info = call.arguments.toString()</span><br><span class="line">                </span><br><span class="line">                val intent = Intent().apply &#123;</span><br><span class="line">                    putExtra(<span class="string">"info"</span>, info)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.setResult(Activity.RESULT_OK, intent)</span><br><span class="line">                activity.finish()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 成功时候通过 result.success 返回值，</span></span><br><span class="line">                <span class="comment">// 如果发生异常，通过 result.error 返回异常信息</span></span><br><span class="line">                <span class="comment">// Flutter 通过 invokeMethod().then() 来处理正常结束的逻辑</span></span><br><span class="line">                <span class="comment">// 通过 catchError 来处理发生异常的逻辑</span></span><br><span class="line">                result?.success(<span class="keyword">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果未找到对应的方法名，则通过 result.notImplemented 来返回异常</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; result?.notImplemented()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终的效果，当点击返回按钮的时候，会将 Flutter 层通过 invokeMethod 传递的 arguments 属性吐司出来，同时，控制台会打印出 “has finish” 的信息</p><h5 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h5><blockquote><p>EventChannel 用于数据流（event streams）的通信</p></blockquote><p>EventChannel 的实现方式也类似，EventChannel 可以持续返回多个信息到 Flutter 层，在 Flutter 层的表现就是一个 stream，原生层通过 sink 不断的添加数据，Flutter 层接收到数据的变化就会作出新相应的处理。在 Android 端实现状态的监听可以通过广播来实现。直接看例子，还是修改上述代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span>(<span class="title">private</span> <span class="title">val</span> <span class="title">flutterView</span>: <span class="title">FlutterView</span>) :</span></span><br><span class="line"><span class="class">    <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span>, <span class="title">EventChannel</span>.<span class="title">StreamHandler</span>, <span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">Any</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">var</span> mStateChangeReceiver: BroadcastReceiver? = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private <span class="keyword">const</span> val TAG = <span class="string">"FlutterPlugin"</span></span><br><span class="line">        <span class="keyword">const</span> val STATE_CHANGE_ACTION = <span class="string">"com.demo.plugins.action.StateChangeAction"</span></span><br><span class="line">        <span class="keyword">const</span> val STATE_VALUE = <span class="string">"com.demo.plugins.value.StateValue"</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123;</span><br><span class="line">            <span class="comment">// ... </span></span><br><span class="line">            val streamChannel = EventChannel(flutterView, Constant.STREAM_CHANNEL_NAME)</span><br><span class="line"></span><br><span class="line">            val instance = FlutterPlugin(flutterView)</span><br><span class="line">            methodChannel.setMethodCallHandler(instance)</span><br><span class="line">            streamChannel.setStreamHandler(instance)</span><br><span class="line">            messageChannel.setMessageHandler(instance)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 StreamHandler 需要重写 onListen 和 onCancel 方法</span></span><br><span class="line">    <span class="comment">// onListen 不会每次数据改变就会调用，只在 Flutter 层，eventChannel 订阅广播</span></span><br><span class="line">    <span class="comment">// 的时候调用，当取消订阅的时候则会调用 onCancel，</span></span><br><span class="line">    <span class="comment">// 所以当开始订阅数据的时候，注册接收数据变化的关闭，</span></span><br><span class="line">    <span class="comment">// 在取消订阅的时候，将注册的广播注销，防止内存泄漏</span></span><br><span class="line">    override fun onListen(argument: Any?, sink: EventChannel.EventSink?) &#123;</span><br><span class="line">        mStateChangeReceiver = createEventListener(sink)</span><br><span class="line">        flutterView.context.registerReceiver(mStateChangeReceiver, IntentFilter(STATE_CHANGE_ACTION))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCancel(argument: Any?) &#123;</span><br><span class="line">        unregisterListener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 activity 被销毁的时候，FlutterView 不一定会调用销毁生命周期，或者会延时调用</span></span><br><span class="line">    <span class="comment">// 这就需要手动去注销一开始注册的广播了</span></span><br><span class="line">    fun unregisterListener() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStateChangeReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            flutterView.context.unregisterReceiver(mStateChangeReceiver)</span><br><span class="line">            mStateChangeReceiver = <span class="keyword">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun createEventListener(sink: EventChannel.EventSink?):</span><br><span class="line">            BroadcastReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line"></span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.equals(intent?.action, STATE_CHANGE_ACTION)) &#123;</span><br><span class="line">                <span class="comment">// 这边广播只做简单的接收一个整数，然后通过 sink 传递到 Flutter 层</span></span><br><span class="line">                <span class="comment">// 当然，sink 还有 error 方法，用于传递发生的错误信息，</span></span><br><span class="line">                <span class="comment">// 以及 endOfStream 方法，用于结束接收</span></span><br><span class="line">                <span class="comment">// 在 Flutter 层分别有 onData 对应 success 方法，onError 对应 error 方法</span></span><br><span class="line">                <span class="comment">// onDone 对应 endOfStream 方法，根据不同的回调处理不同的逻辑</span></span><br><span class="line">                sink?.success(intent?.getIntExtra(STATE_VALUE, <span class="number">-1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Flutter 层，通过对 stream 的监听，对返回的数据进行处理，为了体现出变化，这边修改成 SatefulWidget 来存储状态</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterContactPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FlutterContactPageState createState() =&gt; _FlutterContactPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FlutterContactPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FlutterContactPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME);</span><br><span class="line">  <span class="keyword">final</span> EventChannel _eventChannel = EventChannel(STREAM_CHANNEL_NAME);</span><br><span class="line">  <span class="keyword">final</span> BasicMessageChannel _messageChannel =</span><br><span class="line">      BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec());</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line">  <span class="keyword">var</span> _receiverMessage = <span class="string">'Start receive state'</span>; <span class="comment">// 初始的状态值</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 当页面生成的时候就开始监听数据的变化</span></span><br><span class="line">    _subscription = _eventChannel.receiveBroadcastStream().listen((data) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _receiverMessage = <span class="string">'receive state value: $data'</span>; <span class="comment">// 数据变化了，则修改数据</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, onError: (e) &#123;</span><br><span class="line">      _receiverMessage = <span class="string">'process error: $e'</span>; <span class="comment">// 发生错误则显示错误信息</span></span><br><span class="line">    &#125;, onDone: () &#123;</span><br><span class="line">      _receiverMessage = <span class="string">'receive data done'</span>; <span class="comment">// 发送完毕则直接显示完毕</span></span><br><span class="line">    &#125;, cancelOnError: <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    _subscription.cancel(); <span class="comment">// 当页面销毁的时候需要将订阅取消，防止内存泄漏</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        leading: InkWell(</span><br><span class="line">          child: Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">20.0</span>),</span><br><span class="line">            child: Icon(Icons.arrow_back),</span><br><span class="line">          ),</span><br><span class="line">          onTap: () &#123;</span><br><span class="line">            <span class="comment">// MethodChannel demo</span></span><br><span class="line">            _methodChannel</span><br><span class="line">                .invokeMethod&lt;<span class="built_in">bool</span>&gt;(<span class="string">'finishActivity'</span>, _receiverMessage)</span><br><span class="line">                .then((result) &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;result ? <span class="string">'has finish'</span> : <span class="string">'not finish'</span>&#125;</span>'</span>);</span><br><span class="line">            &#125;).catchError((e) &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'error happend: $e'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        title: Text(<span class="string">'Flutter Page'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">              <span class="comment">// EventChannel demo，页面直接显示信息的变化</span></span><br><span class="line">              child: Text(</span><br><span class="line">                _receiverMessage,</span><br><span class="line">                style: TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.black),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            <span class="comment">// BasicMessageChannel demo</span></span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                _messageChannel</span><br><span class="line">                    .send(<span class="string">'"Hello Native" --- an message from flutter'</span>)</span><br><span class="line">                    .then((str) &#123;</span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'Receive message: $str'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">'Send Message to Native'</span>),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，需要在 Activity 层调用一个定时任务不断的发送广播</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactActivity</span> : <span class="title">AppCompatActivity</span>() </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">var</span> timer: Timer? = <span class="keyword">null</span></span><br><span class="line">    private <span class="keyword">var</span> task: TimerTask? = <span class="keyword">null</span></span><br><span class="line">    private lateinit <span class="keyword">var</span> random: Random</span><br><span class="line">    private lateinit <span class="keyword">var</span> plugin: FlutterPlugin</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        random = Random() <span class="comment">// 生成随机整数</span></span><br><span class="line">        val flutterView = Flutter.createView(<span class="keyword">this</span><span class="meta">@ContactActivity</span>, lifecycle, <span class="string">"route_contact"</span>)</span><br><span class="line">        val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</span><br><span class="line">        addContentView(flutterView, lp)</span><br><span class="line"></span><br><span class="line">        plugin = FlutterPlugin.registerPlugin(flutterView)</span><br><span class="line"></span><br><span class="line">        timer = Timer() <span class="comment">// 定时器</span></span><br><span class="line">        task = timerTask &#123; <span class="comment">// 定时任务</span></span><br><span class="line">            sendBroadcast(Intent(FlutterPlugin.STATE_CHANGE_ACTION).apply &#123;</span><br><span class="line">                putExtra(FlutterPlugin.STATE_VALUE, random.nextInt(<span class="number">1000</span>))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        timer?.schedule(task, <span class="number">3000</span>, <span class="number">2000</span>) <span class="comment">// 延时 3s 开启定时器，并 2s 发送一次广播</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 页面销毁的时候需要将定时器，定时任务销毁</span></span><br><span class="line">        <span class="comment">// 同时注销 Plugin 中注册的广播，防止内存泄漏</span></span><br><span class="line">        timer?.cancel()</span><br><span class="line">        timer = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        task?.cancel()</span><br><span class="line">        task = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        plugin.unregisterListener()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的实现效果大概是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-c604f0a652d1c172.gif" alt=""></p><p>Flutter 同 Android 端的交互到这讲的差不多了，和 iOS 的交互其实也类似，只不过在 Android 端通过 FlutterNativeView 来作为 Binarymessenger 的实现，在 iOS 端通过 FlutterBinaryMessenger 协议实现，原理是一致的。至于 Flutter 插件，其实现也是通过以上三种交互方式来实现的，可能我们目前通过 FlutterView 来作为 BinaryMessenger 实例，插件会通过 PluginRegistry.Registrar 实例的 messenger() 方法来获取 BinaryMessenger 实例。</p><p>最后贴上 demo 的地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2FFlutterNativeContactDemo" target="_blank" rel="noopener">ContactDemo</a></p><p>需要了解插件的写法也可以直接查看官方提供的检测电量插件：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fbattery" target="_blank" rel="noopener">Flutter Battery Plugin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 说到底只是一个 UI 框架，很多功能都需要通过原生的 Api 来实现，那么就会涉及到 Flutter 和 Native 的交互，因为本人不懂 iOS 开发，所以只能讲下 Flutter 同 Android 的交互。&lt;/p&gt;
&lt;h4 id=&quot;Android-项目配置-Flutter-依赖&quot;&gt;&lt;a href=&quot;#Android-项目配置-Flutter-依赖&quot; class=&quot;headerlink&quot; title=&quot;Android 项目配置 Flutter 依赖&quot;&gt;&lt;/a&gt;Android 项目配置 Flutter 依赖&lt;/h4&gt;&lt;p&gt;既然是互相交互，那么需要准备一个 Android 项目。接着就需要创建 flutter module，让 Android 项目依赖，创建的方法可以参考官网 &lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fwiki%2FAdd-Flutter-to-existing-apps&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Wiki&lt;/a&gt;，虽然是官网提供的方法，但是完全按照这个步骤来，还是会有坑的，这边就慢慢一步步解决坑。&lt;/p&gt;
&lt;p&gt;如果你用的是 Android Studio 进行开发的话，直接打开底部的 Terminal，直接创建 flutter module 依赖&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flutter create -t module flutter_native_contact&lt;/code&gt; 至于 module 名可以随意填写，module 创建完后结构大概是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154756.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十四)之实战</title>
    <link href="http://yoursite.com/posts/b447830c.html"/>
    <id>http://yoursite.com/posts/b447830c.html</id>
    <published>2019-04-28T07:33:17.000Z</published>
    <updated>2019-05-31T08:17:27.004Z</updated>
    
    <content type="html"><![CDATA[<p>讲完了常用的部件和网络请求后，差不多该进入整体实战了，这里我们将写一个比较熟悉的项目，郭神的 cool weather。项目将使用 fluro 实现路由管理，dio 实现网络请求，rxdart 实现 BLoC 进行状态管理和逻辑分离，使用文件，shared_preferences，sqflite 实现本地的数据持久化。这边先给出项目的地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather" target="_blank" rel="noopener">flutter_weather</a>，以及最后实现的效果图：</p><table><thead><tr><th>One</th><th>Two</th><th>Three</th></tr></thead><tbody><tr><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527153406.png" alt=""></td><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-50e81d7c4da87e57.gif" alt=""></td><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-eb02699bb66b1535.gif" alt=""></td></tr></tbody></table><a id="more"></a><p>除了 fluro 别的基本上前面都讲了，所以在开始正式的实战前，先讲下 fluro</p><h4 id="Fluro"><a href="#Fluro" class="headerlink" title="Fluro"></a>Fluro</h4><p>fluro 是对 Navigator 的一个封装，方便更好的管理路由跳转，当然还存在一些缺陷，例如目前只支持传递字符串，不能传递中文等，但是这些问题都算不上是大问题。</p><p>fluro 的使用很简单，大概分如下的步骤：</p><ol><li><p>在全局定义一个 <code>Router</code> 实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> router = Router();</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Router</code> 实例定义路径和其对应的 <code>Handler</code> 对象</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如定义一个 CityPage 的路径和 Handler</span></span><br><span class="line">Handler cityHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="comment">// 传递的参数都在 params 中，params 是一个 Map&lt;String, List&lt;String&gt;&gt; 类型参数</span></span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first; </span><br><span class="line">  <span class="keyword">return</span> BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由的路径和参数</span></span><br><span class="line"><span class="comment">// 需要注意的是，第一个页面的路径必须为 "/"，别的可为 "/" + 任意拼接</span></span><br><span class="line">router.define(<span class="string">'/city'</span>, handler: cityHandler);</span><br><span class="line"><span class="comment">// 或者官方提供的另一种方式</span></span><br><span class="line">router.define(<span class="string">'/city/:city_id'</span>, handler: cityHandler);</span><br></pre></td></tr></table></figure></li><li><p>将 <code>router</code> 注册到 <code>MaterialApp</code> 的 <code>onGenerateRoute</code> 中</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(onGenerateRoute: router);</span><br></pre></td></tr></table></figure></li><li><p>最后通过 <code>Router</code> 实例进行跳转，如果有参数传递则会在新的页面收到</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">router.navigateTo(context, <span class="string">'/city?city_id=CN13579'</span>);</span><br><span class="line"><span class="comment">// 或者官方的方式</span></span><br><span class="line">router.navigateTo(context, <span class="string">'/city/CN13579'</span>);</span><br></pre></td></tr></table></figure></li></ol><p>在 fluro 中提供了多种路由动画，包括 <code>fadeIn</code>，<code>inFromRight</code> 等。讲完了使用，就进入实战了。</p><h4 id="flutter-weather-实战"><a href="#flutter-weather-实战" class="headerlink" title="flutter_weather 实战"></a>flutter_weather 实战</h4><h5 id="导入插件"><a href="#导入插件" class="headerlink" title="导入插件"></a>导入插件</h5><p>在开始的时候，已经提到了整体功能的实现需求，所以这边需要导入的插件以及存放图片的文件夹如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">    </span><br><span class="line">  cupertino_icons: ^<span class="number">0.1</span><span class="number">.2</span></span><br><span class="line">  fluro: ^<span class="number">1.4</span><span class="number">.0</span></span><br><span class="line">  dio: ^<span class="number">2.1</span><span class="number">.0</span></span><br><span class="line">  shared_preferences: ^<span class="number">0.5</span><span class="number">.1</span>+<span class="number">2</span></span><br><span class="line">  sqflite: ^<span class="number">1.1</span><span class="number">.3</span></span><br><span class="line">  fluttertoast: ^<span class="number">3.0</span><span class="number">.3</span></span><br><span class="line">  rxdart: ^<span class="number">0.21</span><span class="number">.0</span></span><br><span class="line">  path_provider: <span class="number">0.5</span><span class="number">.0</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  flutter_test:</span><br><span class="line">    sdk: flutter</span><br><span class="line">    </span><br><span class="line">flutter:</span><br><span class="line">  uses-material-design: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">  assets:</span><br><span class="line">    - images/</span><br></pre></td></tr></table></figure><h5 id="顶层静态实例的实现"><a href="#顶层静态实例的实现" class="headerlink" title="顶层静态实例的实现"></a>顶层静态实例的实现</h5><p>有许多实例需要在顶层注册，然后在全局使用，包括但不限于 fluro 的 router，http，database 等等。在这个项目中，需要用到的就是这三个实例，会在全局调用，所以在开始前进行初始化，当然 http 和 database 在使用的时候创建也可以，完全看个人习惯，但是 fluro 的管理类必须在一开始就注册完成。首先需要定义一个 <code>Application</code> 类用来存放这些静态实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> HttpUtils http; <span class="comment">// 全局网络</span></span><br><span class="line">  <span class="keyword">static</span> Router router; <span class="comment">// 全局路由</span></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils db; <span class="comment">// 全局数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是对相应方法类的编写，其中 <code>HttpUtil</code> 和 <code>DatabaseUtils</code> 在前面有讲过，这边不重复讲，会讲下数据库如何建立。</p><h6 id="Fluro-路由管理类"><a href="#Fluro-路由管理类" class="headerlink" title="Fluro 路由管理类"></a>Fluro 路由管理类</h6><p>首先，需要知道，该项目的界面大概分如下的界面(当然可先只定义首页，剩下用到了再定义，该项目相对简单，所以先列出来)：省选择页，市选择页，区选择页，天气展示页，设置页。所以 fluro 的管理类可按如下定义：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看 `routers/routers.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 各个页面对应的路径</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> root = <span class="string">'/'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> weather = <span class="string">'/weather'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> provinces = <span class="string">'/provinces'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> cities = <span class="string">'/cities'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> districts = <span class="string">'/districts'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> settings = <span class="string">'/settings'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 该方法用于放到 `main` 方法中定义所有的路由，</span></span><br><span class="line">  <span class="comment">/// 对应的 handler 可放同一个文件，也可放另一个文件，看个人喜好</span></span><br><span class="line">  <span class="keyword">static</span> configureRouters(Router router) &#123;</span><br><span class="line">    router.notFoundHandler = notFoundHandler;</span><br><span class="line"></span><br><span class="line">    router.define(root, handler: rootHandler); <span class="comment">// 首页</span></span><br><span class="line"></span><br><span class="line">    router.define(weather, handler: weatherHandler); <span class="comment">// 天气展示页</span></span><br><span class="line"></span><br><span class="line">    router.define(provinces, handler: provincesHandler); <span class="comment">// 省列表页</span></span><br><span class="line"></span><br><span class="line">    router.define(cities, handler: citiesHandler); <span class="comment">// 省下市列表页</span></span><br><span class="line"></span><br><span class="line">    router.define(districts, handler: districtsHandler); <span class="comment">// 市下区列表页</span></span><br><span class="line"></span><br><span class="line">    router.define(settings, handler: settingsHandler); <span class="comment">// 设置页</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 生成天气显示页面路径，需要用到城市 id</span></span><br><span class="line">  <span class="keyword">static</span> generateWeatherRouterPath(<span class="built_in">String</span> cityId) =&gt; <span class="string">'$weather?city_id=$cityId'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 生成省下的市列表页相应路径 需要用到省 id 及省名</span></span><br><span class="line">  <span class="keyword">static</span> generateProvinceRouterPath(<span class="built_in">int</span> provinceId, <span class="built_in">String</span> name)</span><br><span class="line">                    =&gt; <span class="string">'$cities?province_id=$provinceId&amp;name=$name'</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/// 生成市下的区列表页相应路径，需用到市 id 及市名</span></span><br><span class="line">  <span class="keyword">static</span> generateCityRouterPath(<span class="built_in">int</span> provinceId, <span class="built_in">int</span> cityId, <span class="built_in">String</span> name) </span><br><span class="line">                    =&gt; <span class="string">'$districts?province_id=$provinceId&amp;city_id=$cityId&amp;name=$name'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 查看 `routers/handler.dart` 文件</span></span><br><span class="line">Handler notFoundHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  Logger(<span class="string">'RouterHandler:'</span>).log(<span class="string">'Not Found Router'</span>); <span class="comment">// 当找不到相应的路由时，打印信息处理</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler rootHandler = Handler(handlerFunc: (_, params) =&gt; SplashPage());</span><br><span class="line"></span><br><span class="line">Handler weatherHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first; <span class="comment">// 获取相应的参数</span></span><br><span class="line">  <span class="keyword">return</span> WeatherPage(city: cityId);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler provincesHandler = Handler(handlerFunc: (_, params) =&gt; ProvinceListPage());</span><br><span class="line"></span><br><span class="line">Handler citiesHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> provinceId = params[<span class="string">'province_id'</span>]?.first;</span><br><span class="line">  <span class="built_in">String</span> name = params[<span class="string">'name'</span>]?.first;</span><br><span class="line">  <span class="keyword">return</span> CityListPage(provinceId: provinceId, </span><br><span class="line">                      name: FluroConvertUtils.fluroCnParamsDecode(name));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler districtsHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> provinceId = params[<span class="string">'province_id'</span>]?.first;</span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first;</span><br><span class="line">  <span class="built_in">String</span> name = params[<span class="string">'name'</span>]?.first;</span><br><span class="line">  <span class="keyword">return</span> DistrictListPage(provinceId: provinceId, cityId: cityId, </span><br><span class="line">                          name: FluroConvertUtils.fluroCnParamsDecode(name));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler settingsHandler = Handler(handlerFunc: (_, params) =&gt; SettingsPage());</span><br></pre></td></tr></table></figure><p>那么界面的路由到这就编写好了，但是前面提到了 fluro 目前不支持中文的传递，所以在传递中文时候，需要先进行转码，这边提供一个自己写的方法，小伙伴有更好的方法也可以直接在项目提 issue</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `utils/fluro_convert_util.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FluroConvertUtils</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// fluro 传递中文参数前，先转换，fluro 不支持中文传递</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> fluroCnParamsEncode(<span class="built_in">String</span> originalCn) &#123;</span><br><span class="line">    <span class="built_in">StringBuffer</span> sb = <span class="built_in">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">var</span> encoded = Utf8Encoder().convert(originalCn); <span class="comment">// utf8 编码，会生成一个 int 列表</span></span><br><span class="line">    encoded.forEach((val) =&gt; sb.write(<span class="string">'$val,'</span>)); <span class="comment">// 将 int 列表重新转换成字符串</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString().substring(<span class="number">0</span>, sb.length - <span class="number">1</span>).toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// fluro 传递后取出参数，解析</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> fluroCnParamsDecode(<span class="built_in">String</span> encodedCn) &#123;</span><br><span class="line">    <span class="keyword">var</span> decoded = encodedCn.split(<span class="string">'['</span>).last.split(<span class="string">']'</span>).first.split(<span class="string">','</span>); <span class="comment">// 对参数字符串分割</span></span><br><span class="line">    <span class="keyword">var</span> list = &lt;<span class="built_in">int</span>&gt;[];</span><br><span class="line">    decoded.forEach((s) =&gt; list.add(<span class="built_in">int</span>.parse(s.trim()))); <span class="comment">// 转回 int 列表</span></span><br><span class="line">    <span class="keyword">return</span> Utf8Decoder().convert(list); <span class="comment">// 解码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Database-管理类编写"><a href="#Database-管理类编写" class="headerlink" title="Database 管理类编写"></a>Database 管理类编写</h6><p>因为数据库的开启是一个很耗资源的过程，所以这边通过单例并提取到顶层。在该项目中，数据库主要用于存储城市信息，因为城市之间的关联比较复杂，如果通过 <code>shared_preferences</code> 或者文件存储会很复杂。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `utils/db_utils.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _dbName = <span class="string">'weather.db'</span>; <span class="comment">// 数据表名</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableProvinces = <span class="string">'provinces'</span>; <span class="comment">// 省表</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableCities = <span class="string">'cities'</span>; <span class="comment">// 市表</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableDistricts = <span class="string">'districts'</span>; <span class="comment">// 区表</span></span><br><span class="line">  <span class="keyword">static</span> Database _db;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils <span class="keyword">get</span> instance =&gt; DatabaseUtils();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将数据库的初始化放到私有构造中，值允许通过单例访问</span></span><br><span class="line">  DatabaseUtils._internal() &#123;</span><br><span class="line">    getDatabasesPath().then((path) <span class="keyword">async</span> &#123;</span><br><span class="line">      _db = <span class="keyword">await</span> openDatabase(join(path, _dbName), version: <span class="number">1</span>, onCreate: (db, version) &#123;</span><br><span class="line">        db.execute(<span class="string">'create table $_tableProvinces('</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'province_id integer not null unique,'</span> <span class="comment">// 省 id，id 唯一</span></span><br><span class="line">            <span class="string">'province_name text not null'</span> <span class="comment">// 省名</span></span><br><span class="line">            <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">        db.execute(<span class="string">'create table $_tableCities('</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'city_id integer not null unique,'</span> <span class="comment">// 市 id，id 唯一</span></span><br><span class="line">            <span class="string">'city_name text not null,'</span> <span class="comment">// 市名</span></span><br><span class="line">            <span class="string">'province_id integer not null,'</span> <span class="comment">// 对应的省的 id，作为外键同省表关联</span></span><br><span class="line">            <span class="string">'foreign key(province_id) references $_tableProvinces(province_id)'</span></span><br><span class="line">            <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">        db.execute(<span class="string">'create table $_tableDistricts('</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'district_id integer not null unique,'</span> <span class="comment">// 区 id</span></span><br><span class="line">            <span class="string">'district_name text not null,'</span> <span class="comment">// 区名</span></span><br><span class="line">            <span class="string">'weather_id text not null unique,'</span> <span class="comment">// 查询天气用的 id，例如 CN13579826，id 唯一</span></span><br><span class="line">            <span class="string">'city_id integer not null,'</span> <span class="comment">// 对应市的 id，作为外键同市表关联</span></span><br><span class="line">            <span class="string">'foreign key(city_id) references $_tableCities(city_id)'</span></span><br><span class="line">            <span class="string">')'</span>);</span><br><span class="line">      &#125;, onUpgrade: (db, oldVersion, newVersion) &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 构建单例</span></span><br><span class="line">  <span class="keyword">factory</span> DatabaseUtils() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _instance = DatabaseUtils._internal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 查询所有的省，`ProvinceModel` 为省市接口返回数据生成的 model 类</span></span><br><span class="line">  <span class="comment">/// 查看 `model/province_model.dart` 文件</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; queryAllProvinces() <span class="keyword">async</span> =&gt;</span><br><span class="line">      ProvinceModel.fromProvinceTableList(<span class="keyword">await</span> _db.rawQuery(<span class="string">'select province_id, province_name from $_tableProvinces'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 查询某个省内的所有市</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; queryAllCitiesInProvince(<span class="built_in">String</span> proid) <span class="keyword">async</span> =&gt; ProvinceModel.fromCityTableList(<span class="keyword">await</span> _db.rawQuery(</span><br><span class="line">        <span class="string">'select city_id, city_name from $_tableCities where province_id = ?'</span>,</span><br><span class="line">        [proid],</span><br><span class="line">      ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 查询某个市内的所有区，`DistrictModel` 为区接口返回数据生成的 model 类</span></span><br><span class="line">  <span class="comment">/// 查看 `model/district_model.dart` 文件</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; queryAllDistrictsInCity(<span class="built_in">String</span> cityid) <span class="keyword">async</span> =&gt; DistrictModel.fromDistrictTableList(<span class="keyword">await</span> _db.rawQuery(</span><br><span class="line">        <span class="string">'select district_id, district_name, weather_id from $_tableDistricts where city_id = ?'</span>,</span><br><span class="line">        [cityid],</span><br><span class="line">      ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将所有的省插入数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; insertProvinces(<span class="built_in">List</span>&lt;ProvinceModel&gt; provinces) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch = _db.batch();</span><br><span class="line">    provinces.forEach((p) =&gt; batch.rawInsert(</span><br><span class="line">          <span class="string">'insert or ignore into $_tableProvinces (province_id, province_name) values (?, ?)'</span>,</span><br><span class="line">          [p.id, p.name],</span><br><span class="line">        ));</span><br><span class="line">    batch.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将省对应下的所有市插入数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; insertCitiesInProvince(<span class="built_in">List</span>&lt;ProvinceModel&gt; cities, <span class="built_in">String</span> proid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch = _db.batch();</span><br><span class="line">    cities.forEach((c) =&gt; batch.rawInsert(</span><br><span class="line">          <span class="string">'insert or ignore into $_tableCities (city_id, city_name, province_id) values (?, ?, ?)'</span>,</span><br><span class="line">          [c.id, c.name, proid],</span><br><span class="line">        ));</span><br><span class="line">    batch.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将市下的所有区插入数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; insertDistrictsInCity(<span class="built_in">List</span>&lt;DistrictModel&gt; districts, <span class="built_in">String</span> cityid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch = _db.batch();</span><br><span class="line">    districts.forEach((d) =&gt; batch.rawInsert(</span><br><span class="line">          <span class="string">'insert or ignore into $_tableDistricts (district_id, district_name, weather_id, city_id) values (?, ?, ?, ?)'</span>,</span><br><span class="line">          [d.id, d.name, d.weatherId, cityid],</span><br><span class="line">        ));</span><br><span class="line">    batch.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义完全局使用的方法，就可以在 <code>main</code> 函数中进行相关的初始化了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `main.dart` 文件</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 初始化 fluro router</span></span><br><span class="line">  Router router = Router();</span><br><span class="line">  Routers.configureRouters(router);</span><br><span class="line">  Application.router = router;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 http</span></span><br><span class="line">  Application.http = HttpUtils(baseUrl: WeatherApi.WEATHER_HOST);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 db</span></span><br><span class="line">  Application.db = DatabaseUtils.instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 强制竖屏，因为设置竖屏为 `Future` 方法，防止设置无效可等返回值后再启动 App</span></span><br><span class="line">  SystemChrome.setPreferredOrientations([DeviceOrientation.portraitDown, DeviceOrientation.portraitUp]).then((_) &#123;</span><br><span class="line">    runApp(WeatherApp()); <span class="comment">// App 类可放在同个文件，个人习惯单独一个文件存放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">      SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">            title: <span class="string">'Weather App'</span>,</span><br><span class="line">            onGenerateRoute: Application.router.generator, <span class="comment">// 将 fluro 的路由进行注册</span></span><br><span class="line">            debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">          );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完毕，接着就可以进行页面的编写了。</p><h5 id="首页编写"><a href="#首页编写" class="headerlink" title="首页编写"></a>首页编写</h5><p>首页主要是为了对 App 的一个大概展示，或者是一些广告的展示，同时也给一些数据初始化提供时间，当用户进入后有更好的体验效果。我们在这里就做一个图标的展示(图标可自行到项目中 <code>images</code> 文件夹查找)，延时 5s 后跳转下个页面。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `splash_page.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplashPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">/// 因为已经引入了 rxdart，这里通过 rxdart.timer 进行倒计时</span></span><br><span class="line">    <span class="comment">/// 当然也可以使用 Futuer.delayed 进行倒计时</span></span><br><span class="line">    <span class="comment">/// 5s 计时，如果已经选择城市，跳转天气界面，否则进入城市选择</span></span><br><span class="line">    Observable.timer(<span class="number">0</span>, <span class="built_in">Duration</span>(milliseconds: <span class="number">5000</span>)).listen((_) &#123;</span><br><span class="line">      PreferenceUtils.instance.getString(PreferencesKey.WEATHER_CITY_ID)</span><br><span class="line">          .then((city) &#123;</span><br><span class="line">        <span class="comment">// 如果当前还未选择城市，则进入城市选择页，否则跳转天气详情页</span></span><br><span class="line">        <span class="comment">// replace: true 即为 Navigator.pushReplacement 方法</span></span><br><span class="line">        Application.router.navigateTo(context, city.isEmpty </span><br><span class="line">                                      ? Routers.provinces </span><br><span class="line">                                      : Routers.generateWeatherRouterPath(city), </span><br><span class="line">                                                                        replace: <span class="keyword">true</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        color: Colors.white,</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">// 展示图标</span></span><br><span class="line">            Image.asset(Resource.pngSplash, width: <span class="number">200.0</span>, height: <span class="number">200.0</span>),</span><br><span class="line">            <span class="comment">// 展示文字提醒，用 SizedBox 设置区域大小</span></span><br><span class="line">            SizedBox(</span><br><span class="line">                width: MediaQuery.of(context).size.width * <span class="number">0.7</span>,</span><br><span class="line">                child: Text(</span><br><span class="line">                  <span class="string">'所有天气数据均为模拟数据，仅用作学习目的使用，请勿当作真实的天气预报软件来使用'</span>,</span><br><span class="line">                  textAlign: TextAlign.center,</span><br><span class="line">                  softWrap: <span class="keyword">true</span>,</span><br><span class="line">                  style: TextStyle(color: Colors.red[<span class="number">700</span>], fontSize: <span class="number">16.0</span>),</span><br><span class="line">                ))</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="城市选择页面"><a href="#城市选择页面" class="headerlink" title="城市选择页面"></a>城市选择页面</h5><p>当首次进入的时候，用户肯定没有选择城市，所以先编写城市选择列表页面，因为整体的项目使用 BLoC 分离业务逻辑和页面，所以先编写数据管理类吧，把数据请求和改变的业务逻辑放到这块，BLoC 的实现在前面讲过了，这边就不重复提了。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `provinces_bloc.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProvincesBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _logger = Logger(<span class="string">'ProvincesBloc'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; _provinces = []; <span class="comment">// 全国省</span></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; _cities = []; <span class="comment">// 省内市</span></span><br><span class="line">  <span class="built_in">List</span>&lt;DistrictModel&gt; _districts = []; <span class="comment">// 市内区</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; <span class="keyword">get</span> provinces =&gt; _provinces;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; <span class="keyword">get</span> cities =&gt; _cities;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;DistrictModel&gt; <span class="keyword">get</span> districts =&gt; _districts;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; _provinceController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; _citiesController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; _districtController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// stream，用于 StreamBuilder 的 stream 参数</span></span><br><span class="line">  Observable&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; <span class="keyword">get</span> provinceStream </span><br><span class="line">                                             =&gt; Observable(_provinceController.stream);</span><br><span class="line"></span><br><span class="line">  Observable&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; <span class="keyword">get</span> cityStream =&gt; Observable(_citiesController.stream);</span><br><span class="line"></span><br><span class="line">  Observable&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; <span class="keyword">get</span> districtStream</span><br><span class="line">                                            =&gt; Observable(_districtController.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 通知刷新省份列表</span></span><br><span class="line">  changeProvinces(<span class="built_in">List</span>&lt;ProvinceModel&gt; provinces) &#123;</span><br><span class="line">    _provinces.clear();</span><br><span class="line">    _provinces.addAll(provinces);</span><br><span class="line">    _provinceController.add(_provinces);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 通知刷新城市列表</span></span><br><span class="line">  changeCities(<span class="built_in">List</span>&lt;ProvinceModel&gt; cities) &#123;</span><br><span class="line">    _cities.clear();</span><br><span class="line">    _cities.addAll(cities);</span><br><span class="line">    _citiesController.add(_cities);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 通知刷新区列表</span></span><br><span class="line">  changeDistricts(<span class="built_in">List</span>&lt;DistrictModel&gt; districts) &#123;</span><br><span class="line">    _districts.clear();</span><br><span class="line">    _districts.addAll(districts);</span><br><span class="line">    _districtController.add(_districts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求全国省</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; requestAllProvinces() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http.getRequest(WeatherApi.WEATHER_PROVINCE, </span><br><span class="line">                                           error: (msg) =&gt; _logger.log(msg, <span class="string">'province'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? [] : ProvinceModel.fromMapList(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求省内城市</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; requestAllCitiesInProvince(<span class="built_in">String</span> proid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest(<span class="string">'<span class="subst">$&#123;WeatherApi.WEATHER_PROVINCE&#125;</span>/$proid'</span>, </span><br><span class="line">                                           error: (msg) =&gt; _logger.log(msg, <span class="string">'city'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? [] : ProvinceModel.fromMapList(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求市内的区</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; requestAllDistricts(<span class="built_in">String</span> proid, <span class="built_in">String</span> cityid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest(<span class="string">'<span class="subst">$&#123;WeatherApi.WEATHER_PROVINCE&#125;</span>/$proid/$cityid'</span>, </span><br><span class="line">                                           error: (msg) =&gt; _logger.log(msg, <span class="string">'district'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? [] : DistrictModel.fromMapList(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123; <span class="comment">// 及时销毁</span></span><br><span class="line">    _provinceController?.close();</span><br><span class="line">    _citiesController?.close();</span><br><span class="line">    _districtController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完 BLoC 需要对其进行注册，因为城市选择相对还是比较频繁的，所以可以放最顶层进行注册</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>  BlocProvider(</span><br><span class="line">      bloc: ProvincesBloc(), <span class="comment">// 城市切换 BLoC</span></span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'Weather App'</span>,</span><br><span class="line">        onGenerateRoute: Application.router.generator,</span><br><span class="line">        debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>城市选择就是一个列表，直接通过 <code>ListView</code> 生成即可，前面讲 <code>ListView</code> 的时候提到，尽可能固定 item 的高度，会提高绘制效率</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `provinces_page.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProvinceListPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _bloc = BlocProvider.of&lt;ProvincesBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入的时候先使用数据库的数据填充界面</span></span><br><span class="line">    Application.db.queryAllProvinces().then((ps) =&gt; _bloc.changeProvinces(ps));</span><br><span class="line">    <span class="comment">// 网络数据更新列表并刷新数据库数据</span></span><br><span class="line">    _bloc.requestAllProvinces().then((provinces) &#123;</span><br><span class="line">      _bloc.changeProvinces(provinces);</span><br><span class="line">      Application.db.insertProvinces(provinces);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'请选择省份'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        color: Colors.black12,</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        <span class="comment">// 省列表选择</span></span><br><span class="line">        child: StreamBuilder(</span><br><span class="line">          stream: _bloc.provinceStream,</span><br><span class="line">          initialData: _bloc.provinces,</span><br><span class="line">          builder: (_, AsyncSnapshot&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; snapshot) </span><br><span class="line">            =&gt; !snapshot.hasData || snapshot.data.isEmpty</span><br><span class="line">            <span class="comment">// 如果当前的数据未加载则给一个加载，否则显示列表加载</span></span><br><span class="line">              ? CupertinoActivityIndicator(radius: <span class="number">12.0</span>) </span><br><span class="line">              : ListView.builder(</span><br><span class="line">              physics: BouncingScrollPhysics(),</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">              itemBuilder: (_, index) =&gt; InkWell(</span><br><span class="line">                child: Container(</span><br><span class="line">                  alignment: Alignment.centerLeft,</span><br><span class="line">                  child: Text(snapshot.data[index].name, style: TextStyle(fontSize: <span class="number">18.0</span>, color: Colors.black)),</span><br><span class="line">                ),</span><br><span class="line">                onTap: () =&gt; Application.router.navigateTo(</span><br><span class="line">                    context,</span><br><span class="line">                    <span class="comment">// 跳转下层省内城市选择，需要将当前的省 id 以及省名传入</span></span><br><span class="line">                    Routers.</span><br><span class="line">                    generateProvinceRouterPath(snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)),</span><br><span class="line">                    transition: TransitionType.fadeIn),</span><br><span class="line">              ),</span><br><span class="line">              itemExtent: <span class="number">50.0</span>,</span><br><span class="line">              itemCount: snapshot.data.length),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于市和区的列表选择也类似，除了最后的点击会有些区别页面的布局几乎一致，这边只提下点击事件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `cities_page.dart` 文件</span></span><br><span class="line">Application.router.navigateTo(</span><br><span class="line">                                    context,</span><br><span class="line">                                    <span class="comment">// 跳转下层省内城市选择</span></span><br><span class="line">                                    Routers.generateProvinceRouterPath(</span><br><span class="line">                                        snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)),</span><br><span class="line">                                    transition: TransitionType.fadeIn),</span><br><span class="line">                              )</span><br><span class="line"><span class="comment">// 设置为当前区，并清理路由 stack，并将天气界面设置到最上层</span></span><br><span class="line">onTap: () &#123;</span><br><span class="line"> PreferenceUtils.instance</span><br><span class="line">     .saveString(PreferencesKey.WEATHER_CITY_ID, snapshot.data[index].weatherId);</span><br><span class="line">    </span><br><span class="line">                                  Application.router.navigateTo(context, Routers.generateWeatherRouterPath(snapshot.data[index].weatherId),</span><br><span class="line">                                      transition: TransitionType.inFromRight, clearStack: <span class="keyword">true</span>);</span><br><span class="line">                                &#125;)</span><br></pre></td></tr></table></figure><h5 id="天气详情页面"><a href="#天气详情页面" class="headerlink" title="天气详情页面"></a>天气详情页面</h5><p>天气详情页面相对部件会多点，为了看着舒服一点，这里拆成多个部分来编写，在这之前还是先编写数据的管理类，因为天气详情接口返回的数据嵌套层次比较多，关系比较复杂，不适合用 <code>database</code> 来做持久化，所以这里采用文件持久化方式。当然有些小伙伴会问干嘛不使用 <code>shared_preferences</code> 来存储，理论上应该没有太大的问题，但是个人建议相对复杂的数据使用文件存储会相对比较好点，一定要说个为什么，我也说不出来。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `weather_bloc.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _logger = Logger(<span class="string">'WeatherBloc'</span>);</span><br><span class="line"></span><br><span class="line">  WeatherModel _weather; <span class="comment">// 天气情况</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> _background = WeatherApi.DEFAULT_BACKGROUND; <span class="comment">// 背景</span></span><br><span class="line"></span><br><span class="line">  WeatherModel <span class="keyword">get</span> weather =&gt; _weather;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> background =&gt; _background;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;WeatherModel&gt; _weatherController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">String</span>&gt; _backgroundController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  Observable&lt;WeatherModel&gt; <span class="keyword">get</span> weatherStream =&gt; Observable(_weatherController.stream);</span><br><span class="line"></span><br><span class="line">  Observable&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> backgroundStream =&gt; Observable(_backgroundController.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 更新天气情况</span></span><br><span class="line">  updateWeather(WeatherModel weather) &#123;</span><br><span class="line">    _weather = weather;</span><br><span class="line">    _weatherController.add(_weather);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 更新天气背景</span></span><br><span class="line">  updateBackground(<span class="built_in">String</span> background) &#123;</span><br><span class="line">    _background = background;</span><br><span class="line">    _backgroundController.add(_background);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求天气情况</span></span><br><span class="line">  Future&lt;WeatherModel&gt; requestWeather(<span class="built_in">String</span> id) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest(WeatherApi.WEATHER_STATUS, </span><br><span class="line">                    params: &#123;<span class="string">'cityid'</span>: id, <span class="string">'key'</span>: WeatherApi.WEATHER_KEY&#125;, </span><br><span class="line">                    error: (msg) =&gt; _logger.log(msg, <span class="string">'weather'</span>));</span><br><span class="line">    <span class="comment">// 请求数据成功则写入到文件中</span></span><br><span class="line">    <span class="keyword">if</span> (resp != <span class="keyword">null</span> &amp;&amp; resp.data != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _writeIntoFile(json.encode(resp.data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WeatherModel.fromMap(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; requestBackground() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest&lt;<span class="built_in">String</span>&gt;(WeatherApi.WEATHER_BACKGROUND, </span><br><span class="line">                            error: (msg) =&gt; _logger.log(msg, <span class="string">'background'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? WeatherApi.DEFAULT_BACKGROUND : resp.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取存储文件路径</span></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; _getPath() <span class="keyword">async</span> =&gt; </span><br><span class="line">      <span class="string">'<span class="subst">$&#123;(await getApplicationDocumentsDirectory()).path&#125;</span>/weather.txt'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入到文件</span></span><br><span class="line">  _writeIntoFile(<span class="built_in">String</span> contents) <span class="keyword">async</span> &#123;</span><br><span class="line">    File file = File(<span class="keyword">await</span> _getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> file.exists()) file.deleteSync();</span><br><span class="line">    file.createSync();</span><br><span class="line">    file.writeAsString(contents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件读取存储信息，如果不存在文件则返回空字符串 ''，不推荐返回 null</span></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; readWeatherFromFile() <span class="keyword">async</span> &#123;</span><br><span class="line">    File file = File(<span class="keyword">await</span> _getPath());</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">await</span> file.exists()) ? file.readAsString() : <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _weatherController?.close();</span><br><span class="line">    _backgroundController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天气详情的刷新只有当个页面，所以 BLoC 的注册值需要在路由上注册即可，在 fluro 对应 handler 中加入注册</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Handler weatherHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first; <span class="comment">// 这个 id 可以通过 BLoC 获取也可以</span></span><br><span class="line">  <span class="keyword">return</span> BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么接下来就可以编写界面了，先实现最外层的背景图变化</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `weather_page.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> city;</span><br><span class="line"></span><br><span class="line">  WeatherPage(&#123;Key key, <span class="keyword">this</span>.city&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _bloc = BlocProvider.of&lt;WeatherBloc&gt;(context);</span><br><span class="line">    <span class="comment">// 请求背景并更新</span></span><br><span class="line">    _bloc.requestBackground().then((b) =&gt; _bloc.updateBackground(b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先读取本地文件缓存进行页面填充</span></span><br><span class="line">    _bloc.readWeatherFromFile().then((s) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.isNotEmpty) &#123;</span><br><span class="line">        _bloc.updateWeather(WeatherModel.fromMap(json.decode(s)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再请求网络更新数据</span></span><br><span class="line">    _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">          stream: _bloc.backgroundStream,</span><br><span class="line">          initialData: _bloc.background,</span><br><span class="line">          builder: (_, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; themeSnapshot) =&gt; Container(</span><br><span class="line">                padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">20.0</span>),</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                decoration: BoxDecoration(</span><br><span class="line">                  color: Colors.black12,</span><br><span class="line">                  image: DecorationImage(</span><br><span class="line">                      image: NetworkImage(themeSnapshot.data), fit: BoxFit.cover),</span><br><span class="line">                ),</span><br><span class="line">                child: <span class="comment">// 具体内部布局通过拆分小部件实现</span></span><br><span class="line">              )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面最顶部是显示两个按钮，一个跳转城市选择，一个跳转设置页面，显示当前的城市</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FollowedHeader</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot; <span class="comment">// snapshot 通过上层传入</span></span><br><span class="line"></span><br><span class="line">  FollowedHeader(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// 城市选择页面跳转按钮</span></span><br><span class="line">        IconButton(</span><br><span class="line">            icon: Icon(Icons.home, color: Colors.white, size: <span class="number">32.0</span>),</span><br><span class="line">            onPressed: () =&gt; Application.router.</span><br><span class="line">            navigateTo(context, Routers.provinces, </span><br><span class="line">                       transition: TransitionType.inFromLeft)),</span><br><span class="line">        <span class="comment">// 当前城市</span></span><br><span class="line">        Text(<span class="string">'<span class="subst">$&#123;snapshot.data.heWeather[<span class="number">0</span>].basic.location&#125;</span>'</span>, </span><br><span class="line">             style: TextStyle(fontSize: <span class="number">28.0</span>, color: Colors.white)),</span><br><span class="line">        <span class="comment">// 设置页面跳转按钮</span></span><br><span class="line">        IconButton(</span><br><span class="line">            icon: Icon(Icons.settings, color: Colors.white, size: <span class="number">32.0</span>),</span><br><span class="line">            onPressed: () =&gt; Application.router</span><br><span class="line">            .navigateTo(context, Routers.settings, </span><br><span class="line">                        transition: TransitionType.inFromRight))</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是当前的天气详情部分</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrentWeatherState</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  CurrentWeatherState(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _now = snapshot.data.heWeather[<span class="number">0</span>].now;</span><br><span class="line">    <span class="keyword">var</span> _update = snapshot.data.heWeather[<span class="number">0</span>].update.loc.split(<span class="string">' '</span>).last;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// 当前的温度</span></span><br><span class="line">        Text(<span class="string">'<span class="subst">$&#123;_now.tmp&#125;</span>℃'</span>, style: TextStyle(fontSize: <span class="number">50.0</span>, color: Colors.white)),</span><br><span class="line">        <span class="comment">// 当前的天气状况</span></span><br><span class="line">        Text(<span class="string">'<span class="subst">$&#123;_now.condTxt&#125;</span>'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, color: Colors.white)),</span><br><span class="line">        Row( <span class="comment">// 刷新的时间</span></span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Icon(Icons.refresh, size: <span class="number">16.0</span>, color: Colors.white),</span><br><span class="line">            Padding(padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">4.0</span>)),</span><br><span class="line">            Text(_update, style: TextStyle(fontSize: <span class="number">12.0</span>, color: Colors.white))</span><br><span class="line">          ],</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一个天气预报的列表块，以为是一个列表，当然可以通过 <code>Cloumn</code> 来实现，但是前面有提到过一个列表「粘合剂」—- <code>CustomScrollView</code>，所以这里的整体连接最后会通过 <code>CustomScrollView</code> 来实现，那么你可以放心在最上层容器的 <code>child</code> 属性加上 <code>CustomScrollView</code> 了。接着来实现这块预报模块</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherForecast</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  WeatherForecast(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _forecastList = snapshot.data.heWeather[<span class="number">0</span>].dailyForecasts; <span class="comment">// 获取天气预报</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SliverFixedExtentList(</span><br><span class="line">        delegate: SliverChildBuilderDelegate(</span><br><span class="line">          (_, index) =&gt; Container(</span><br><span class="line">              color: Colors.black54, <span class="comment">// 外层设置背景色，防止被最外层图片背景遮挡文字</span></span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">              alignment: Alignment.centerLeft,</span><br><span class="line">              child: index == <span class="number">0</span> <span class="comment">// 当第一个 item 情况，显示 ‘预报’</span></span><br><span class="line">                  ? Text(<span class="string">'预报'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, color: Colors.white))</span><br><span class="line">                  : Row(</span><br><span class="line">                      mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">                      crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">                      children: &lt;Widget&gt;[</span><br><span class="line">                        Text(_forecastList[index - <span class="number">1</span>].date,  <span class="comment">// 预报的日期</span></span><br><span class="line">                             style: TextStyle(fontSize: <span class="number">16.0</span>, color: Colors.white)),</span><br><span class="line">                        Expanded( <span class="comment">// 天气情况，这边通过 expanded 进行占位，并居中显示</span></span><br><span class="line">                            child: Center(child: Text(_forecastList[index - <span class="number">1</span>].cond.txtD, </span><br><span class="line">                                                      style: TextStyle(fontSize: <span class="number">16.0</span>,                                                                  color: Colors.white))),</span><br><span class="line">                            flex: <span class="number">2</span>),</span><br><span class="line">                        Expanded(</span><br><span class="line">                            child: Row( <span class="comment">// 最高温度，最低温度</span></span><br><span class="line">                              mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">                              children: &lt;Widget&gt;[</span><br><span class="line">                                Text(_forecastList[index - <span class="number">1</span>].tmp.max, </span><br><span class="line">                                     style: TextStyle(fontSize: <span class="number">16.0</span>, </span><br><span class="line">                                                      color: Colors.white)),</span><br><span class="line">                                Text(_forecastList[index - <span class="number">1</span>].tmp.min, </span><br><span class="line">                                     style: TextStyle(fontSize: <span class="number">16.0</span>, </span><br><span class="line">                                                      color: Colors.white)),</span><br><span class="line">                              ],</span><br><span class="line">                            ),</span><br><span class="line">                            flex: <span class="number">1</span>)</span><br><span class="line">                      ],</span><br><span class="line">                    )),</span><br><span class="line">          childCount: _forecastList.length + <span class="number">1</span>, <span class="comment">// 这个数量需要 +1，因为有个标题需要一个数量</span></span><br><span class="line">        ),</span><br><span class="line">        itemExtent: <span class="number">50.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是空气质量报告，一个标题，下面由两个布局进行平分</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirQuality</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  AirQuality(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> quality = snapshot.data.heWeather[<span class="number">0</span>].aqi.city;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">        color: Colors.black54,</span><br><span class="line">        alignment: Alignment.centerLeft,</span><br><span class="line">        child: Column(</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">// 标题</span></span><br><span class="line">            Padding(padding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">20.0</span>), child: </span><br><span class="line">                    Text(<span class="string">'空气质量'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, </span><br><span class="line">                                                  color: Colors.white))),</span><br><span class="line">            Row(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 通过 expanded 进行平分横向距离</span></span><br><span class="line">                Expanded(</span><br><span class="line">                    child: Center(</span><br><span class="line">                  <span class="comment">// 内部居中显示</span></span><br><span class="line">                  child: Column(</span><br><span class="line">                    children: &lt;Widget&gt;[</span><br><span class="line">                      Text(<span class="string">'<span class="subst">$&#123;quality.aqi&#125;</span>'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">40.0</span>, color: Colors.white)),</span><br><span class="line">                      Text(<span class="string">'AQI 指数'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.white)),</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                )),</span><br><span class="line">                Expanded(</span><br><span class="line">                    child: Center(</span><br><span class="line">                  child: Column(</span><br><span class="line">                    children: &lt;Widget&gt;[</span><br><span class="line">                      Text(<span class="string">'<span class="subst">$&#123;quality.pm25&#125;</span>'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">40.0</span>, color: Colors.white)),</span><br><span class="line">                      Text(<span class="string">'PM2.5 指数'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.white)),</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                )),</span><br><span class="line">              ],</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是生活质量模块，看着也是个列表，但是后台返回的不是列表，而是根据不同字段获取不同质量指数，因为布局类似，所以可以对其进行封装再整体调用</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeSuggestions</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  LifeSuggestions(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生活指数封装</span></span><br><span class="line">  Widget _suggestionWidget(<span class="built_in">String</span> content) =&gt;</span><br><span class="line">      Padding(padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>), child: </span><br><span class="line">              Text(content, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _suggestion = snapshot.data.heWeather[<span class="number">0</span>].suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">      color: Colors.black54,</span><br><span class="line">      alignment: Alignment.centerLeft,</span><br><span class="line">      child: Column(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">'生活建议'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, color: Colors.white)),</span><br><span class="line">          _suggestionWidget(<span class="string">'舒适度：<span class="subst">$&#123;_suggestion.comf.brf&#125;</span>\n<span class="subst">$&#123;_suggestion.comf.txt&#125;</span>'</span>),</span><br><span class="line">          _suggestionWidget(<span class="string">'洗车指数：<span class="subst">$&#123;_suggestion.cw.brf&#125;</span>\n<span class="subst">$&#123;_suggestion.cw.txt&#125;</span>'</span>),</span><br><span class="line">          _suggestionWidget(<span class="string">'运动指数：</span></span><br><span class="line"><span class="string">                                <span class="subst">$&#123;_suggestion.sport.brf&#125;</span>\n<span class="subst">$&#123;_suggestion.sport.txt&#125;</span>'</span>),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的分模块都已经编写完成，剩下就是通过粘合剂进行组装了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: StreamBuilder(</span><br><span class="line">                    initialData: _bloc.weather,</span><br><span class="line">                    stream: _bloc.weatherStream,</span><br><span class="line">                    builder: (_, AsyncSnapshot&lt;WeatherModel&gt; snapshot) =&gt; !snapshot.hasData</span><br><span class="line">                        ? CupertinoActivityIndicator(radius: <span class="number">12.0</span>)</span><br><span class="line">                        : SafeArea(</span><br><span class="line">                            child: RefreshIndicator(</span><br><span class="line">                                child: CustomScrollView(</span><br><span class="line">                                  physics: BouncingScrollPhysics(),</span><br><span class="line">                                  slivers: &lt;Widget&gt;[</span><br><span class="line">                                    SliverToBoxAdapter(child: FollowedHeader(snapshot: snapshot)),</span><br><span class="line">                                    <span class="comment">// 实时天气</span></span><br><span class="line">                                    SliverPadding(</span><br><span class="line">                                      padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">30.0</span>),</span><br><span class="line">                                      sliver: SliverToBoxAdapter(</span><br><span class="line">                                        child: CurrentWeatherState(snapshot: snapshot, city: city),</span><br><span class="line">                                      ),</span><br><span class="line">                                    ),</span><br><span class="line">                                    <span class="comment">// 天气预报</span></span><br><span class="line">                                    WeatherForecast(snapshot: snapshot),</span><br><span class="line">                                    <span class="comment">// 空气质量</span></span><br><span class="line">                                    SliverPadding(</span><br><span class="line">                                      padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">30.0</span>),</span><br><span class="line">                                      sliver: SliverToBoxAdapter(child: AirQuality(snapshot: snapshot)),</span><br><span class="line">                                    ),</span><br><span class="line">                                    <span class="comment">// 生活建议</span></span><br><span class="line">                                    SliverToBoxAdapter(child: LifeSuggestions(snapshot: snapshot))</span><br><span class="line">                                  ],</span><br><span class="line">                                ),</span><br><span class="line">                                onRefresh: () <span class="keyword">async</span> &#123;</span><br><span class="line">                                  _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w));</span><br><span class="line">                                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                &#125;),</span><br><span class="line">                          )),</span><br></pre></td></tr></table></figure><p>最后就剩下设置页的全局主题切换了</p><h5 id="设置页全局主题切换"><a href="#设置页全局主题切换" class="headerlink" title="设置页全局主题切换"></a>设置页全局主题切换</h5><p>既然提到了数据的切换，那肯定就涉及 BLoC 毫无疑问了，还是照常编写管理类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `setting_bloc.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 所有主题色列表</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> themeColors = [Colors.blue, Colors.red, Colors.green, </span><br><span class="line">                              Colors.deepOrange, Colors.pink, Colors.purple];</span><br><span class="line"></span><br><span class="line">  Color _color = themeColors[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  Color <span class="keyword">get</span> color =&gt; _color;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;Color&gt; _colorController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  Observable&lt;Color&gt; <span class="keyword">get</span> colorStream =&gt; Observable(_colorController.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 切换主题通知刷新</span></span><br><span class="line">  switchTheme(<span class="built_in">int</span> themeIndex) &#123;</span><br><span class="line">    _color = themeColors[themeIndex];</span><br><span class="line">    _colorController.add(_color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _colorController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是全局的切换，那么这个 BLoC 肯定需要在最顶层进行注册，这边就不贴代码了，同 <code>ProvinceBloc</code> 一致。接着编写界面，设置界面因为有 <code>GridView</code> 和其他部件，所以也需要用 <code>CustomScrollView</code> 作为粘合剂，当然，你也可以用 <code>Wrap</code> 代替 <code>GridView</code> 来实现网格，就不需要用 <code>CustomScrollView</code>，使用 <code>Column</code> 即可。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingsPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _bloc = BlocProvider.of&lt;SettingBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StreamBuilder(</span><br><span class="line">        stream: _bloc.colorStream,</span><br><span class="line">        initialData: _bloc.color,</span><br><span class="line">        <span class="comment">// Theme 是 Flutter 自带的一个设置主题的部件，里面可以设置多种颜色，</span></span><br><span class="line">        <span class="comment">// 通过接收到 color 的变化，改变主题色，其他页面也如此设置，小伙伴可以自己添加</span></span><br><span class="line">        builder: (_, AsyncSnapshot&lt;Color&gt; snapshot) =&gt; Theme(</span><br><span class="line">            <span class="comment">// IconThemeData 用于设置按钮的主题色</span></span><br><span class="line">              data: ThemeData(primarySwatch: snapshot.data, iconTheme: IconThemeData(color: snapshot.data)),</span><br><span class="line">              child: Scaffold(</span><br><span class="line">                appBar: AppBar(</span><br><span class="line">                  title: Text(<span class="string">'设置'</span>),</span><br><span class="line">                ),</span><br><span class="line">                body: Container(</span><br><span class="line">                  color: Colors.black12,</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">20.0</span>),</span><br><span class="line">                  child: CustomScrollView(</span><br><span class="line">                    slivers: &lt;Widget&gt;[</span><br><span class="line">                      SliverPadding(</span><br><span class="line">                        padding: <span class="keyword">const</span> EdgeInsets.only(right: <span class="number">12.0</span>),</span><br><span class="line">                        sliver: SliverToBoxAdapter(</span><br><span class="line">                            child: Row(</span><br><span class="line">                          mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">                          crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">                          children: &lt;Widget&gt;[</span><br><span class="line">                            Text(<span class="string">'当前主题色：'</span>, style: TextStyle(fontSize: <span class="number">16.0</span>, </span><br><span class="line">                                                            color: snapshot.data)),</span><br><span class="line">                            Container(width: <span class="number">20.0</span>, height: <span class="number">20.0</span>, color: snapshot.data)</span><br><span class="line">                          ],</span><br><span class="line">                        )),</span><br><span class="line">                      ),</span><br><span class="line">                      SliverPadding(padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">15.0</span>)),</span><br><span class="line">                      SliverGrid(</span><br><span class="line">                          delegate: SliverChildBuilderDelegate(</span><br><span class="line">                              (_, index) =&gt; InkWell(</span><br><span class="line">                                    child: Container(color: SettingBloc.themeColors[index]),</span><br><span class="line">                                    onTap: () &#123;</span><br><span class="line">                                        <span class="comment">// 选择后进行保存，当下次进入的时候直接使用该主题色</span></span><br><span class="line">                                        <span class="comment">// 同时切换主题色</span></span><br><span class="line">                                      _bloc.switchTheme(index);</span><br><span class="line">                                      PreferenceUtils.instance.saveInteger(PreferencesKey.THEME_COLOR_INDEX, index);</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                  ),</span><br><span class="line">                              childCount: SettingBloc.themeColors.length),</span><br><span class="line">                          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: <span class="number">3</span>, mainAxisSpacing: <span class="number">20.0</span>, crossAxisSpacing: <span class="number">20.0</span>)),</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终全局的主题切换也实现了。</p><p>编写完代码，需要打包啊，Android 下的打包大家肯定没问题，这里讲下 flutter 下如何打包 apk，ipa 因为没有 mac 所以你们懂的。</p><h5 id="apk-文件打包"><a href="#apk-文件打包" class="headerlink" title="apk 文件打包"></a>apk 文件打包</h5><ol><li><p>创建 jks 文件，如果已经存在可忽略这步从第二步开始。打开终端并输入</p><p><code>keytool -genkey -v -keystore [你的签名文件路径].jks -keyalg RSA -keysize 2048 -validity 10000 -alias key</code></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527153900.png" alt=""></p><p>然后输入密码以及一些基本信息就可以创建成功了</p></li><li><p>在项目的 <code>android</code> 目录下创建一个 <code>key.properties</code> 文件，里面进行如下配置</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">storePassword=&lt;password from previous step&gt;</span><br><span class="line">keyPassword=&lt;password from previous step&gt;</span><br><span class="line">keyAlias=key</span><br><span class="line">storeFile=&lt;[你的签名文件路径].jks&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>android/app</code> 下的 <code>build.gradle</code> 中进行如下修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">apply from: <span class="string">"$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 增加如下部分代码</span></span><br><span class="line">def keystorePropertiesFile = rootProject.file(<span class="string">"key.properties"</span>)</span><br><span class="line">def keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    defaultConfigs&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加如下代码</span></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">            keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">            storeFile file(keystoreProperties[<span class="string">'storeFile'</span>])</span><br><span class="line">            storePassword keystoreProperties[<span class="string">'storePassword'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buildTypes&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次打开终端运行 <code>flutter build apk</code> 会自动生成一个 apk 文件，文件路径为</p><p><code>[你的项目地址]\build\app\outputs\apk\release</code></p></li><li><p>通过 <code>flutter install</code> 就可以将正式包运行到手机上</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲完了常用的部件和网络请求后，差不多该进入整体实战了，这里我们将写一个比较熟悉的项目，郭神的 cool weather。项目将使用 fluro 实现路由管理，dio 实现网络请求，rxdart 实现 BLoC 进行状态管理和逻辑分离，使用文件，shared_preferences，sqflite 实现本地的数据持久化。这边先给出项目的地址：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;flutter_weather&lt;/a&gt;，以及最后实现的效果图：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;One&lt;/th&gt;
&lt;th&gt;Two&lt;/th&gt;
&lt;th&gt;Three&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527153406.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-50e81d7c4da87e57.gif&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-eb02699bb66b1535.gif&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十三)之网络</title>
    <link href="http://yoursite.com/posts/d9e32c9b.html"/>
    <id>http://yoursite.com/posts/d9e32c9b.html</id>
    <published>2019-04-28T07:24:59.000Z</published>
    <updated>2019-05-27T07:42:31.723Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲完了常用的部件，<code>BLoC</code> 模式，数据持久化等常用的，今天再介绍个重头戏 —— 网络请求</p><h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><p><code>HttpClient</code> 是 <code>dart</code> 自带的网络请求方式，在 <code>dart:io</code> 包下。使用 <code>HttpClient</code> 作为请求分以下几个步骤</p><ol><li><p>创建 HttpClient 实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpClient client = HttpClient();</span><br></pre></td></tr></table></figure></li><li><p>打开连接，并设置一些头参数，请求参数等</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 url 中没有查询参数可直接创建</span></span><br><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">'https://www.xxx.com'</span>);</span><br><span class="line"><span class="comment">// 如果存在查询参数则在 Uri 中添加</span></span><br><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>(scheme: <span class="string">'https'</span>, host: <span class="string">'www.xxx.com'</span>, queryParameters: &#123;<span class="string">'a'</span>: <span class="string">'AAA'</span>&#125;);</span><br><span class="line"><span class="comment">// 打开连接</span></span><br><span class="line">HttpClientRequest request = <span class="keyword">await</span> client.getUrl(uri);</span><br><span class="line">request.headers.add(<span class="string">'token'</span>, <span class="string">'Bear <span class="subst">$&#123;<span class="string">'x'</span> * <span class="number">20</span>&#125;</span>'</span>); <span class="comment">// 添加头部 token 信息</span></span><br><span class="line"><span class="comment">// 如果是 post 或者 put 请求，通过 `add` 添加请求体</span></span><br><span class="line"><span class="comment">// 因为 `add` 方法需要传入 `List&lt;int&gt;` 参数，可以通过 utf8.encode 进行编码</span></span><br><span class="line">request.add(utf8.encode(<span class="string">'&#123;"a": "aaa"&#125;'</span>));</span><br><span class="line"><span class="comment">// 也可以通过添加流的方式进行添加</span></span><br><span class="line">request.addStream(input);</span><br></pre></td></tr></table></figure></li><li><p>连接服务器</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 request 后通过 request.close() 获取一个响应对象 HttpClientResponse，</span></span><br><span class="line"><span class="comment">// 包括响应头，响应内容等</span></span><br><span class="line">HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br></pre></td></tr></table></figure></li><li><p>读取服务器响应内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> responseBody = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br></pre></td></tr></table></figure></li><li><p>关闭实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><p>例如我们要去请求 <code>Bird.so</code> 的首页并显示，我们可以这么实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_httpClientRequest() <span class="keyword">async</span> &#123;</span><br><span class="line">    HttpClient client;</span><br><span class="line">    <span class="comment">// try catch finally 用于捕获请求过程中发生的异常，在 finally 中设置保证 client 能够关闭</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client = HttpClient();</span><br><span class="line">      HttpClientRequest request = <span class="keyword">await</span> client.getUrl(<span class="built_in">Uri</span>.parse(_BIRD_SO_URL));</span><br><span class="line">      HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br><span class="line">      <span class="built_in">String</span> strResponse = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">      setState(() =&gt; _netBack = strResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;e.toString()&#125;</span>'</span>);</span><br><span class="line">      setState(() =&gt; _netBack = <span class="string">'Fail'</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后实现的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-1042230799d843a8.gif" alt=""></p><p>很显然，用 <code>HttpClient</code> 请求相对来说是个非常麻烦的过程，如果要涉及到文本上传之类的，那么就会更麻烦了，所以这边引入一个网络请求的插件 <code>dio</code>，写本文的时候版本为 <code>2.1.0</code></p><h4 id="Dio"><a href="#Dio" class="headerlink" title="Dio"></a>Dio</h4><p>dio 是个非常强大的网络请求库，他的方式类似 <code>OkHttp</code>，我们可以直接查看<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutterchina%2Fdio%2Fblob%2Fmaster%2FREADME-ZH.md" target="_blank" rel="noopener">官方文档</a>，使用方式非常简单，创建一个 <code>Dio</code> 实例，然后就可以通过 <code>get</code>，<code>post</code> 等方式发起请求，返回 <code>Future&lt;Response&gt;</code>，而且支持多个并发请求，可以设置返回响应的类型，监听上传下载进度等等，看着就很给力。对于简单的方式，这边就不做太多介绍，主要讲下拦截器，也是非常给力的一部分。比如我们需要请求这么个接口 <code>https://randomuser.me/api/</code></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527152811.png" alt=""></p><p>这个接口通过 <code>get</code> 请求，可以加入任意的查询参数。比如我们需要实现一个请求加解密的过程，如果每次都在上传参数或者返回请求的时候去加密，解密的话，就做了非常多无用功了，那么这时候拦截器就派上用场了。先定义下加解密的规则，上传的参数统一转为小写，不存在大写，请求回的数据，不能含有 <code>info</code> 字段。看下如何实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_dioRequest() <span class="keyword">async</span> &#123;</span><br><span class="line">    BaseOptions options = BaseOptions(connectTimeout: <span class="number">5000</span>, receiveTimeout: <span class="number">60000</span>);</span><br><span class="line">    Dio dio = Dio(options);</span><br><span class="line">    </span><br><span class="line">    dio.interceptors.add(InterceptorsWrapper(onRequest: (opt) &#123;</span><br><span class="line">      <span class="comment">// 获取查询的参数</span></span><br><span class="line">      <span class="built_in">Map</span> params = opt.queryParameters;</span><br><span class="line">      <span class="comment">// 将所有的参数转为小写，因为查询参数通过 map 形式上传</span></span><br><span class="line">      params.forEach((key, value) =&gt; </span><br><span class="line">                       opt.queryParameters[key] = <span class="string">'$value'</span>.toLowerCase());</span><br><span class="line">      <span class="comment">// 这边还可以做些别的操作，例如需要 token 进行用户身份验证，则通过头部进行添加</span></span><br><span class="line">      <span class="comment">// opt.headers['authorization'] = 'token';</span></span><br><span class="line">      <span class="comment">// 在官网中，提供了 lock 和 unlock 的写法，被 lock 后，接下来的请求会进入队列等待，</span></span><br><span class="line">      <span class="comment">// 直到 unlock 后才能继续，可以用于几个请求，后续的需要用到前面的返回值的情况使用</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 返回修改后的 RequestOptions</span></span><br><span class="line">      <span class="keyword">return</span> opt;</span><br><span class="line">    &#125;, onResponse: (resp) &#123;</span><br><span class="line">      <span class="comment">// 返回响应体后，将 info 字段的内容切除，并将 json 拼接完成</span></span><br><span class="line">      resp.data = <span class="string">'<span class="subst">$&#123;<span class="string">'<span class="subst">$&#123;resp.data&#125;</span>'</span>.split(<span class="string">', info'</span>).first&#125;</span>&#125;'</span>;</span><br><span class="line">      <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;, onError: (error) &#123;</span><br><span class="line">      <span class="comment">// 发生错误时的回调</span></span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送一个请求，可以查看下打印的结果</span></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(_USER_ME_URL, queryParameters: &#123;<span class="string">'a'</span>: <span class="string">'AAA'</span>, <span class="string">'b'</span>: <span class="string">'BbBbBb'</span>&#125;);</span><br><span class="line">    <span class="built_in">print</span>(response.data);</span><br><span class="line">    <span class="built_in">print</span>(response.request.headers);</span><br><span class="line">    <span class="built_in">print</span>(response.request.queryParameters);</span><br><span class="line">    setState(() =&gt; _netBack = response.data.toString()); <span class="comment">// 界面显示 response.data</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看下最后的显示信息</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527152843.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527152854.png" alt=""></p><p>请求体的头部成功加上了 <code>authorization</code> 参数，请求的参数全部变为小写，返回的信息也把 info 字段值去除。在很多时候，请求接口后，需要将 json 转换成 pojo 类来处理，可以通过 <code>json_serializable</code> 这个三方插件实现，这边提供文章 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5b5f00e7e51d45190571172f" target="_blank" rel="noopener">Flutter Json自动反序列化</a>，当然这种方式比较麻烦，这里推荐个 <code>Android Studio</code> 下的插件 <code>dart_json_format</code> 直接搜索就可以，如果用的是 <code>Vitual Code</code> 或者别的不是 <code>JetBrains</code> 系列的，这里有个转换的网址 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjaviercbk.github.io%2Fjson_to_dart" target="_blank" rel="noopener">JsonToDart</a>。</p><p><em>以上代码查看 http_main.dart 文件</em></p><h4 id="实践一下下"><a href="#实践一下下" class="headerlink" title="实践一下下"></a>实践一下下</h4><p>不知道小伙还记得前面讲的 <code>BLoC</code> 没有，忘了可以查看 <a href="https://zhangmiao.cc/posts/d121323a.html" target="_blank" rel="noopener">Flutter 状态管理及 BLoC</a>，这里结合 <code>BLoC</code> 和 <code>Dio</code> 实现界面和逻辑分离的小例子，接口使用前面提到的 <code>https://randomuser.me/api/</code> 接口。网络应该是比较常用的，所以对其进行一些封装还是很有必要的，这边提供下我自己封装的方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于错误信息回调</span></span><br><span class="line"><span class="keyword">typedef</span> ErrorCallback = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">String</span> msg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> GET = <span class="string">'get'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> POST = <span class="string">'post'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Dio _dio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> HttpUtils _instance;</span><br><span class="line"></span><br><span class="line">  Dio <span class="keyword">get</span> hp =&gt; _dio;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dio 可以在 BaseOptions 中指定域名 baseUrl，</span></span><br><span class="line">  <span class="comment">// 后续接口就不需要再添加域名了</span></span><br><span class="line">  <span class="comment">// 如果请求的接口域名发生了变化，只要把全部 url 写全，就会自动使用新的域名</span></span><br><span class="line">  HttpUtils._internal(<span class="built_in">String</span> base) &#123;</span><br><span class="line">    <span class="comment">// 生成一个单例，防止多次打开关闭造成开销</span></span><br><span class="line">    _dio = Dio(BaseOptions(baseUrl: base, connectTimeout: <span class="number">10000</span>, receiveTimeout: <span class="number">10000</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> HttpUtils(<span class="built_in">String</span> base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) _instance = HttpUtils._internal(base);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加拦截器</span></span><br><span class="line">  addInterceptor(<span class="built_in">List</span>&lt;InterceptorsWrapper&gt; interceptors) &#123;</span><br><span class="line">    _dio.interceptors.clear();</span><br><span class="line">    _dio.interceptors.addAll(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Response&lt;T&gt;&gt; getRequest&lt;T&gt;(url, &#123;<span class="built_in">Map</span> params, ErrorCallback callback&#125;) =&gt;</span><br><span class="line">      _request(url, GET, params: params, callback: callback);</span><br><span class="line"></span><br><span class="line">  Future&lt;Response&lt;T&gt;&gt; postRequest&lt;T&gt;(url, &#123;<span class="built_in">Map</span> params, ErrorCallback callback&#125;) =&gt;</span><br><span class="line">      _request(url, POST, params: params, callback: callback);</span><br><span class="line"></span><br><span class="line">  Future&lt;Response&gt; download(url, path, &#123;ProgressCallback receive, CancelToken token&#125;) =&gt;</span><br><span class="line">      _dio.download(url, path, onReceiveProgress: receive, cancelToken: token);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// T 可以指定返回的类型，String 或者 Map&lt;String, dynamic&gt;</span></span><br><span class="line">  Future&lt;Response&lt;T&gt;&gt; _request&lt;T&gt;(</span><br><span class="line">    url,</span><br><span class="line">    <span class="built_in">String</span> method, &#123;</span><br><span class="line">    <span class="built_in">Map</span> params, <span class="comment">// 上传的参数</span></span><br><span class="line">    Options opt,</span><br><span class="line">    ErrorCallback callback, <span class="comment">// 错误回调</span></span><br><span class="line">    ProgressCallback send, <span class="comment">// 上传进度监听</span></span><br><span class="line">    ProgressCallback receive, <span class="comment">// 下载监听</span></span><br><span class="line">    CancelToken token, <span class="comment">// 用于取消的 token，可以多个请求绑定一个 token</span></span><br><span class="line">  &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response&lt;T&gt; rep;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (method == GET) &#123;</span><br><span class="line">        <span class="comment">// 如果不是重新创建 Dio 实例，get 方法使用 queryParams 会出错，不懂原因，使用拼接没有问题</span></span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.isNotEmpty) &#123;</span><br><span class="line">          <span class="keyword">var</span> sb = <span class="built_in">StringBuffer</span>(<span class="string">'?'</span>);</span><br><span class="line">          params.forEach((key, value) &#123;</span><br><span class="line">            sb.write(<span class="string">'$key=$value&amp;'</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="comment">// get 请求下拼接路径</span></span><br><span class="line">          url += sb.toString().substring(<span class="number">0</span>, sb.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rep = <span class="keyword">await</span> _dio.<span class="keyword">get</span>(url, options: opt, onReceiveProgress: receive, cancelToken: token);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == POST) &#123;</span><br><span class="line">        <span class="comment">// post 参数放请求体</span></span><br><span class="line">        rep = params == <span class="keyword">null</span></span><br><span class="line">            ? <span class="keyword">await</span> _dio.post(url, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive)</span><br><span class="line">            : <span class="keyword">await</span> _dio.post(url,</span><br><span class="line">                data: params, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 statusCode 不是 200 则错误回调，返回空的 Response</span></span><br><span class="line">      <span class="keyword">if</span> (rep.statusCode != <span class="number">200</span> &amp;&amp; callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback(<span class="string">'network error, and code is <span class="subst">$&#123;rep.statusCode&#125;</span>'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> rep;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback(<span class="string">'network error, catch error: <span class="subst">$&#123;e.toString()&#125;</span>'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装后就可以愉快的调用了，如果有别的请求方式后期可以继续扩展。继续看代码，创建一个 <code>application.dart</code> 文件，用于存放全局参数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> HttpUtils http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在 <code>main()</code> 方法中进行初始化，接下来就可以直接使用</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Application.http = HttpUtils(<span class="string">'https://randomuser.me'</span>);</span><br><span class="line">  </span><br><span class="line">  runApp(DemoApp());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 透明状态栏</span></span><br><span class="line">  <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">      SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下最后的实现效果吧，刚进入没有数据则通过转圈圈提示，加载完数据后，点击头像更换下个</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-cbe4a21cc6b3b828.gif" alt=""></p><p>实现 <code>BLoC</code> 需要有一个管理类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  RandomUserModel _user;</span><br><span class="line"></span><br><span class="line">  RandomUserModel <span class="keyword">get</span> user =&gt; _user;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;RandomUserModel&gt; _controller = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  Observable&lt;RandomUserModel&gt; <span class="keyword">get</span> stream =&gt; Observable(_controller.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 网络请求获取新的数据，并更新</span></span><br><span class="line">  updateUserInfo() &#123;</span><br><span class="line">    Application.http.getRequest(<span class="string">'/api'</span>).then((response) &#123;</span><br><span class="line">      <span class="comment">// RandomUserModel 就是接口返回的 json 转成的 model 类</span></span><br><span class="line">      RandomUserModel model = RandomUserModel.fromMap(response.data);</span><br><span class="line">      _user = model;</span><br><span class="line">      <span class="comment">// add 到 controller 通知修改</span></span><br><span class="line">      _controller.add(model);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _controller?.close(); <span class="comment">// 及时销毁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好管理类后，就可以来编写界面了，界面也比较简单</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPageDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将首字母大写</span></span><br><span class="line">  <span class="built_in">String</span> _upperFirst(<span class="built_in">String</span> content) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(content != <span class="keyword">null</span> &amp;&amp; content.isNotEmpty);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'<span class="subst">$&#123;content.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase()&#125;</span><span class="subst">$&#123;content.substring(<span class="number">1</span>)&#125;</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 地址信息通用部件</span></span><br><span class="line">  Widget _userLocation(<span class="built_in">String</span> info) =&gt; Padding(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">4.0</span>),</span><br><span class="line">      child: Text(info, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    UserBloc _bloc = BlocProvider.of&lt;UserBloc&gt;(context);</span><br><span class="line">    _bloc.updateUserInfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// StreamBuilder 接受更新数据的 stream</span></span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">          builder: (_, AsyncSnapshot&lt;RandomUserModel&gt; snapshot) =&gt; Container(</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                decoration: BoxDecoration(</span><br><span class="line">                    gradient: LinearGradient(</span><br><span class="line">                        begin: Alignment.topCenter,</span><br><span class="line">                        end: Alignment.bottomCenter,</span><br><span class="line">                        colors: [Colors.blue[<span class="number">600</span>], Colors.blue[<span class="number">400</span>]])),</span><br><span class="line">                child: !snapshot.hasData</span><br><span class="line">                    ? CupertinoActivityIndicator(radius: <span class="number">12.0</span>)</span><br><span class="line">                    : Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">                        InkWell( <span class="comment">// 用于切换数据</span></span><br><span class="line">                            child: ClipOval( <span class="comment">// 圆形头像</span></span><br><span class="line">                              child: FadeInImage.assetNetwork(</span><br><span class="line">                                  placeholder: <span class="string">'images/ava_default.png'</span>, image: snapshot.data.results[<span class="number">0</span>].picture.large),</span><br><span class="line">                            ),</span><br><span class="line">                            onTap: () =&gt; _bloc.updateUserInfo()), <span class="comment">// 更新数据</span></span><br><span class="line">                        Padding(</span><br><span class="line">                          padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">                          child: Text(</span><br><span class="line">                              <span class="string">'<span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].name.first)&#125;</span> <span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].name.last)&#125;</span>'</span>,</span><br><span class="line">                              style: TextStyle(color: Colors.white, fontSize: <span class="number">24.0</span>)),</span><br><span class="line">                        ),</span><br><span class="line">                        Text(<span class="string">'<span class="subst">$&#123;snapshot.data.results[<span class="number">0</span>].email&#125;</span>'</span>,</span><br><span class="line">                            style: TextStyle(color: Colors.white, fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                        _userLocation(<span class="string">'<span class="subst">$&#123;snapshot.data.results[<span class="number">0</span>].location.street&#125;</span>'</span>),</span><br><span class="line">                        _userLocation(<span class="string">'<span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].location.city)&#125;</span>'</span>),</span><br><span class="line">                        _userLocation(<span class="string">'<span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].location.state)&#125;</span>'</span>),</span><br><span class="line">                      ]),</span><br><span class="line">              ),</span><br><span class="line">          initialData: _bloc.user, <span class="comment">// 注入初始值</span></span><br><span class="line">          stream: _bloc.stream), <span class="comment">// 注入更新 stream</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>以上代码查看 bloc_network 包下的所有文件</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面讲完了常用的部件，&lt;code&gt;BLoC&lt;/code&gt; 模式，数据持久化等常用的，今天再介绍个重头戏 —— 网络请求&lt;/p&gt;
&lt;h4 id=&quot;HttpClient&quot;&gt;&lt;a href=&quot;#HttpClient&quot; class=&quot;headerlink&quot; title=&quot;HttpClient&quot;&gt;&lt;/a&gt;HttpClient&lt;/h4&gt;&lt;p&gt;&lt;code&gt;HttpClient&lt;/code&gt; 是 &lt;code&gt;dart&lt;/code&gt; 自带的网络请求方式，在 &lt;code&gt;dart:io&lt;/code&gt; 包下。使用 &lt;code&gt;HttpClient&lt;/code&gt; 作为请求分以下几个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建 HttpClient 实例&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HttpClient client = HttpClient();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开连接，并设置一些头参数，请求参数等&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果 url 中没有查询参数可直接创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt; uri = &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt;.parse(&lt;span class=&quot;string&quot;&gt;&#39;https://www.xxx.com&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果存在查询参数则在 Uri 中添加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt; uri = &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt;(scheme: &lt;span class=&quot;string&quot;&gt;&#39;https&#39;&lt;/span&gt;, host: &lt;span class=&quot;string&quot;&gt;&#39;www.xxx.com&#39;&lt;/span&gt;, queryParameters: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;AAA&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 打开连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HttpClientRequest request = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; client.getUrl(uri);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.headers.add(&lt;span class=&quot;string&quot;&gt;&#39;token&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Bear &lt;span class=&quot;subst&quot;&gt;$&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&amp;#125;&lt;/span&gt;&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 添加头部 token 信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果是 post 或者 put 请求，通过 `add` 添加请求体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为 `add` 方法需要传入 `List&amp;lt;int&amp;gt;` 参数，可以通过 utf8.encode 进行编码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.add(utf8.encode(&lt;span class=&quot;string&quot;&gt;&#39;&amp;#123;&quot;a&quot;: &quot;aaa&quot;&amp;#125;&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 也可以通过添加流的方式进行添加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.addStream(input);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接服务器&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置 request 后通过 request.close() 获取一个响应对象 HttpClientResponse，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 包括响应头，响应内容等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HttpClientResponse response = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; request.close();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读取服务器响应内容&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; responseBody = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; response.transform(utf8.decoder).join();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关闭实例&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;client.close();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十二)之数据持久化</title>
    <link href="http://yoursite.com/posts/6358b348.html"/>
    <id>http://yoursite.com/posts/6358b348.html</id>
    <published>2019-04-28T07:18:47.000Z</published>
    <updated>2019-05-27T07:25:16.938Z</updated>
    
    <content type="html"><![CDATA[<p>上节讲了状态管理，但是当 <code>App</code> 重启后，数据就都丢失了，这样就比较尴尬了，什么都要重来，所以这节我们来讲下数据持久化。数据持久化主要有如下方式</p><ul><li>文件读写</li><li><code>shared_preferences</code> 存储</li><li>数据库存储</li></ul><p>持久化的实现都需要通过三方插件来实现，接着会慢慢介绍三种实现方式</p><a id="more"></a><h4 id="文件读写-IO-操作"><a href="#文件读写-IO-操作" class="headerlink" title="文件读写/ IO 操作"></a>文件读写/ IO 操作</h4><p>文件读写需要 <code>path_provider</code> 插件，写这篇文章的时候，最新版本是 <code>0.5.0+1</code>，小伙伴们可以根据官网最新的版本进行替换，导入后我们就可以来看下如何实现文件的读写了。<code>path_provider</code> 的源码比较简单，这边就不单独拎出来说了，可以自行查看。<code>path_provider</code> 用于获取手机的存储文件位置，一共有三个方法</p><ul><li><code>getTemporaryDirectory</code> 临时目录，在 Android 中对应的方法为 <code>getCacheDir</code>，而在 iOS 中对应为 <code>NSCachesDirectory</code>，可以通过系统检测并清除</li><li><code>getApplicationDocumentsDirectory</code> 缓存目录，在 Android 中对应为 <code>AppData</code> 文件夹，在 iOS 中对应为  <code>NSDocumentsDirectory</code>，只有当 App 被删除才能被删除</li><li><code>getExternalStorageDirectory</code> 外部存储目录，只有在 Android 中有效，在 iOS 调用会抛出 <code>UnsupportedError</code> 异常，不过 Android 在写入前记得先申请权限哟，否则也是不行滴。</li></ul><p>读写文件操作需要通过 <code>Dart</code> 的 <code>IO</code> 操作完成，这边小伙伴们可以自己看文档 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fapi.dartlang.org%2Fstable%2F2.2.0%2Fdart-io%2FFile-class.html" target="_blank" rel="noopener">File class</a>，接着我们就直接通过例子来看文件实现数据持久化。先看下效果吧，最终重启 App 后，数据也能正常读取显示，说明数据被保存下来了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-7a9977c10ad33aff.gif" alt=""></p><p>看下实现的代码，因为会涉及到多种方式，所以这边我把视图抽取出来实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _fileIoPart() &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">      margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(<span class="number">8.0</span>))),</span><br><span class="line">      child: Column(children: &lt;Widget&gt;[</span><br><span class="line">        Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">          child: Text(<span class="string">'File IO'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>, color: Theme.of(context).primaryColor)),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// RadioList 是单选按钮部件，通过选择不同的情况，创建不同目录的文件</span></span><br><span class="line">        RadioListTile(</span><br><span class="line">            value: _radioText[<span class="number">0</span>],</span><br><span class="line">            title: Text(_radioText[<span class="number">0</span>]),</span><br><span class="line">            subtitle: Text(_radioDescriptions[<span class="number">0</span>]),</span><br><span class="line">            groupValue: _currentValue,</span><br><span class="line">            onChanged: ((value) &#123;</span><br><span class="line">              setState(() =&gt; _currentValue = value);</span><br><span class="line">            &#125;)),</span><br><span class="line">        RadioListTile(</span><br><span class="line">            value: _radioText[<span class="number">1</span>],</span><br><span class="line">            title: Text(_radioText[<span class="number">1</span>]),</span><br><span class="line">            subtitle: Text(_radioDescriptions[<span class="number">1</span>]),</span><br><span class="line">            groupValue: _currentValue,</span><br><span class="line">            onChanged: ((value) &#123;</span><br><span class="line">              setState(() =&gt; _currentValue = value);</span><br><span class="line">            &#125;)),</span><br><span class="line">        RadioListTile(</span><br><span class="line">            value: _radioText[<span class="number">2</span>],</span><br><span class="line">            title: Text(_radioText[<span class="number">2</span>]),</span><br><span class="line">            subtitle: Text(_radioDescriptions[<span class="number">2</span>]),</span><br><span class="line">            groupValue: _currentValue,</span><br><span class="line">            onChanged: ((value) &#123;</span><br><span class="line">              setState(() =&gt; _currentValue = value);</span><br><span class="line">            &#125;)),</span><br><span class="line">        Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">          <span class="comment">// 用于写入文本信息</span></span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: _editController,</span><br><span class="line">            decoration: InputDecoration(labelText: <span class="string">'输入存储的文本内容'</span>, icon: Icon(Icons.text_fields)),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">          width: MediaQuery.of(context).size.width,</span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            onPressed: _writeTextIntoFile,</span><br><span class="line">            child: Text(<span class="string">'写入文件信息'</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">          child: Row(</span><br><span class="line">            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[Text(<span class="string">'文件内容：'</span>), Expanded(child: Text(_fileContent, softWrap: <span class="keyword">true</span>))],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">          width: MediaQuery.of(context).size.width,</span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            onPressed: _readTextFromFile,</span><br><span class="line">            child: Text(<span class="string">'读取文件信息'</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ]),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关键的部分在于 <code>_writeTextIntoFile</code> 和 <code>_readTextFromFile</code> 两个方法的实现。看下实现的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果写入外部内存需要读写权限，这边使用了第三方插件 `permission_handler`</span></span><br><span class="line"> <span class="keyword">void</span> _writeTextIntoFile() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (_currentValue == _radioText[<span class="number">2</span>]) &#123;</span><br><span class="line">     PermissionStatus status = <span class="keyword">await</span> PermissionHandler().checkPermissionStatus(PermissionGroup.storage);</span><br><span class="line">     <span class="keyword">if</span> (status == PermissionStatus.granted) <span class="comment">// 如果是写入外部存储，则检测权限状态，同意则写入</span></span><br><span class="line">       _writeContent();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (status == PermissionStatus.disabled) <span class="comment">// 拒绝了提示手动打开</span></span><br><span class="line">       Fluttertoast.showToast(msg: <span class="string">'未打开相关权限'</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">// 未同意则主动申请权限</span></span><br><span class="line">       PermissionHandler().requestPermissions([PermissionGroup.storage]);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="comment">// 不是写入外部存储直接写入文件</span></span><br><span class="line">     _writeContent();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本写入文件 </span></span><br><span class="line"> <span class="keyword">void</span> _writeContent() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="comment">// 写入文本操作</span></span><br><span class="line">   <span class="keyword">var</span> text = _editController.value.text; <span class="comment">// 获取文本框的内容</span></span><br><span class="line">   File file = File(<span class="keyword">await</span> _getFilePath()); <span class="comment">// 获取相应的文件</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (text == <span class="keyword">null</span> || text.isEmpty) &#123;</span><br><span class="line">     Fluttertoast.showToast(msg: <span class="string">'请输入内容'</span>); <span class="comment">// 内容为空，则不写入并提醒</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 内容不空，则判断是否已经存在，存在先删除，重新创建后写入信息</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">await</span> file.exists()) file.deleteSync();</span><br><span class="line">     file.createSync(); <span class="comment">// createSync 是一个同步的创建过程</span></span><br><span class="line">     file.writeAsStringSync(text); <span class="comment">// writeAsStringSync 是同步写入的过程</span></span><br><span class="line">     _editController.clear(); <span class="comment">// 写入文件后清空输入框信息</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 读取文本操作</span></span><br><span class="line"> <span class="keyword">void</span> _readTextFromFile() <span class="keyword">async</span> &#123;</span><br><span class="line">   File file = File(<span class="keyword">await</span> _getFilePath());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">await</span> file.exists()) &#123;</span><br><span class="line">     setState(() =&gt; _fileContent = file.readAsStringSync()); <span class="comment">// 文件存在则直接显示文本信息</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     setState(() =&gt; _fileContent = <span class="string">''</span>); <span class="comment">// 文件不存在则清空显示文本信息，并提示</span></span><br><span class="line">     Fluttertoast.showToast(msg: <span class="string">'文件还未创建，请先通过写入信息来创建文件'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为外部存储的文件需要涉及到权限问题，而且 iOS 也不支持，所以如果需要使用文件来持久化数据的话，尽量使用另外两种。因为在例子中，我们保存的数据相对比较简单，所以这边就不得不说另外一种更方便的持久化方式了 <code>shared_preferences</code></p><h4 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h4><p>写 Android 的小伙伴对这个应该不陌生了，但是 <code>Flutter</code> 并没有自带的 <code>shared_preferences</code> 功能，需要第三方插件来实现，引入 <code>shared_preferences</code> 插件，写文章的时候最新版本是 <code>^0.5.1+2</code>，还是先看下最后的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-6cbe9d19584b96b4.gif" alt=""></p><p>代码的实现相对比较简单</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _sharedPart() &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">        shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(<span class="number">8.0</span>))),</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">              child:</span><br><span class="line">                  Text(<span class="string">'Shared Preferences'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>, color: Theme.of(context).primaryColor)),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">12.0</span>, <span class="number">0</span>, <span class="number">12.0</span>, <span class="number">12.0</span>),</span><br><span class="line">              <span class="comment">// 用于设置 key 信息</span></span><br><span class="line">              child: TextField(</span><br><span class="line">                controller: _shareKeyController,</span><br><span class="line">                decoration: InputDecoration(labelText: <span class="string">'输入 share 存储的 key'</span>, icon: Icon(Icons.lock_outline)),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">12.0</span>, <span class="number">0</span>, <span class="number">12.0</span>, <span class="number">12.0</span>),</span><br><span class="line">              <span class="comment">// 用于写入文本信息</span></span><br><span class="line">              child: TextField(</span><br><span class="line">                controller: _shareValueController,</span><br><span class="line">                decoration: InputDecoration(labelText: <span class="string">'输入 share 存储的 value'</span>, icon: Icon(Icons.text_fields)),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">              width: MediaQuery.of(context).size.width,</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: _writeIntoShare,</span><br><span class="line">                child: Text(<span class="string">'写入 share'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">              child: Row(</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: &lt;Widget&gt;[Text(<span class="string">'share 存储内容：'</span>), Expanded(child: Text(_shareContent, softWrap: <span class="keyword">true</span>))],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">              width: MediaQuery.of(context).size.width,</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: _readFromShare,</span><br><span class="line">                child: Text(<span class="string">'读取 share'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实现的关键部分就是方法 <code>_writeIntoShare</code> 和 <code>_readFromShare</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _writeIntoShare() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> shareKey = _shareKeyController.value.text;</span><br><span class="line">    <span class="keyword">var</span> shareContent = _shareValueController.value.text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shareKey == <span class="keyword">null</span> || shareKey.isEmpty) &#123;</span><br><span class="line">      Fluttertoast.showToast(msg: <span class="string">'请输入 key'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shareContent == <span class="keyword">null</span> || shareContent.isEmpty) &#123;</span><br><span class="line">      Fluttertoast.showToast(msg: <span class="string">'请输入保存的内容'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 `getInstance` 获取 `shared_preferences` 单例</span></span><br><span class="line">      <span class="keyword">var</span> sp = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">      <span class="comment">// sp 能保存的数据类型包括 `int`, `String`, `bool`, `double`, `StringList`</span></span><br><span class="line">      sp.setString(shareKey, shareContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _readFromShare() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> shareKey = _shareKeyController.value.text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shareKey == <span class="keyword">null</span> || shareKey.isEmpty) &#123;</span><br><span class="line">      Fluttertoast.showToast(msg: <span class="string">'请输入 key'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> sp = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">      <span class="comment">// 数据读取的类型同写入类型，如果传入的 key 不存在则返回 null</span></span><br><span class="line">      <span class="keyword">var</span> value = sp.getString(shareKey);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Fluttertoast.showToast(msg: <span class="string">'未找到该 key'</span>);</span><br><span class="line">        setState(() =&gt; _shareContent = <span class="string">''</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setState(() =&gt; _shareContent = value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这两种数据持久化的方式主要用于存储相对简单，关系不复杂的数据，如果涉及到大量的，且字段之间有关系的情况就需要通过数据库来实现了，Android 和 iOS 都自带 sqlite 数据库。</p><p><em>以上代码查看 data_persistence_main.dart 文件</em></p><h4 id="Sqflite"><a href="#Sqflite" class="headerlink" title="Sqflite"></a>Sqflite</h4><p><code>Flutter</code> 实现数据库存储需要通过插件 <code>sqflite</code> 来实现，写文章的时候最新的版本是 <code>sqflite 1.1.3</code>，但是该版本需要 <code>flutter 1.2</code> 以上才行，所以我选择的是 <code>sqflite 1.1.0</code>，小伙伴可以根据自己的 <code>flutter</code> 版本选择相应的 <code>sqflite</code> 版本</p><p>sqflite 的基本操作语句，在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftekartik%2Fsqflite%2Fblob%2Fmaster%2Fsqflite%2FREADME.md" target="_blank" rel="noopener">文档中</a>已经写得非常明白了，所以就不搬运了，这边直接讲下对于数据库的一些封装处理吧，因为打开数据库是一个很消耗资源的一个过程，所以呢，推荐实现单例会比较好。例如我们要实现一个 <code>student</code> 存储表</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableStudent = <span class="string">'student'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Database _database; <span class="comment">// 创建单例，防止重复打开消耗内存</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line"></span><br><span class="line">  DatabaseUtils._internal() &#123;</span><br><span class="line">    getDatabasesPath().then((path) <span class="keyword">async</span> &#123;</span><br><span class="line">      _database = <span class="keyword">await</span> openDatabase(join(path, <span class="string">'demo.db'</span>), version: <span class="number">2</span>, onCreate: (db, version) &#123;</span><br><span class="line">        <span class="comment">// 创建数据库的时候在这边调用</span></span><br><span class="line">        db.execute(<span class="string">'create table $_tableStudent '</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'name text not null,'</span></span><br><span class="line">            <span class="string">'age integer not null default 0,'</span></span><br><span class="line">            <span class="string">'gender integer not null default 0'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新升级增加的字段</span></span><br><span class="line">        db.execute(<span class="string">'alter table $_tableStudent add column birthday text'</span>);</span><br><span class="line">      &#125;, onUpgrade: (db, oldVersion, newVersion) &#123;</span><br><span class="line">        <span class="comment">// 更新升级数据库的时候在这操作</span></span><br><span class="line">        <span class="keyword">if</span> (oldVersion == <span class="number">1</span>) db.execute(<span class="string">'alter table $_tableStudent add column birthday text'</span>);</span><br><span class="line">      &#125;, onOpen: (db) &#123;</span><br><span class="line">        <span class="comment">// 打开数据库时候的回调</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;db.path&#125;</span>'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> DatabaseUtils() &#123;</span><br><span class="line">    <span class="comment">// 如果当前的单例已经存在，则不再创建，否则重新创建，factory 关键词看第一章</span></span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) _instance = DatabaseUtils._internal();</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对数据库的操作就完全考验你的 <code>SQL</code> 的掌握程度了，但是千万记住，sqlite 中的类型只有，整型 <code>integer</code> ，字符类型 <code>text</code>，浮点类型 <code>real</code>，二进制 <code>blob</code>。数据库的具体例子会等到最后的实际项目中展示，原谅我不懂如何展示一个界面给你操作，实现数据库的各种功能。</p><p><em>该部分代码查看 db_util.dart 文件</em>，里面有一些基本的操作写法，小伙伴可自行查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节讲了状态管理，但是当 &lt;code&gt;App&lt;/code&gt; 重启后，数据就都丢失了，这样就比较尴尬了，什么都要重来，所以这节我们来讲下数据持久化。数据持久化主要有如下方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件读写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared_preferences&lt;/code&gt; 存储&lt;/li&gt;
&lt;li&gt;数据库存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;持久化的实现都需要通过三方插件来实现，接着会慢慢介绍三种实现方式&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十一)之状态管理，BLoC</title>
    <link href="http://yoursite.com/posts/d121323a.html"/>
    <id>http://yoursite.com/posts/d121323a.html</id>
    <published>2019-04-27T07:07:53.000Z</published>
    <updated>2019-05-27T07:12:22.212Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>在 <code>dart</code> 部分记得分享过 <code>Stream</code> 的文章链接，但是我知道你们肯定没几个愿意看的，所以这里再提下。还是得从源码开始…因为源码的注释比较长，就不贴注释了，可以自己看，我这边就提取一些关键信息。</p><p><code>Stream</code> 是 <code>Dart</code> 提供的一种数据流订阅管理的”工具”，感觉有点像 <code>Android</code> 中的 <code>EventBus</code> 或者 <code>RxBus</code>，<code>Stream</code> 可以接收任何对象，包括是另外一个 <code>Stream</code>，接收的对象通过 <code>StreamController</code> 的 <code>sink</code> 进行添加，然后通过 <code>StreamController</code> 发送给 <code>Stream</code>，通过 <code>listen</code> 进行监听，<code>listen</code> 会返回一个 <code>StreamSubscription</code> 对象，<code>StreamSubscription</code> 可以操作对数据流的监听，例如 <code>pause</code>，<code>resume</code>，<code>cancel</code> 等。</p><p><code>Stream</code> 分两种类型：</p><ol><li><code>Single-subscription Stream</code>：单订阅 stream，整个生命周期只允许有一个监听，如果该监听 cancel 了，也不能再添加另一个监听，而且只有当有监听了，才会发送数据，主要用于文件 <code>IO</code> 流的读取等。</li><li><code>Broadcast Stream</code>：广播订阅 stream，允许有多个监听，当添加了监听后，如果流中有数据存在就可以监听到数据，这种类型，不管是否有监听，只要有数据就会发送，用于需要多个监听的情况。</li></ol><a id="more"></a><p>还是看下例子会比较直观</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StreamHomeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StreamHome</span>&gt; </span>&#123;</span><br><span class="line">  StreamController _controller = StreamController();  <span class="comment">// 创建单订阅类型 `StreamController`</span></span><br><span class="line">  Sink _sink;</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    _sink = _controller.sink; <span class="comment">// _sink 用于添加数据</span></span><br><span class="line">    <span class="comment">// _controller.stream 会返回一个单订阅 stream，</span></span><br><span class="line">    <span class="comment">// 通过 listen 返回 StreamSubscription，用于操作流的监听操作</span></span><br><span class="line">    _subscription = _controller.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listener: $data'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据，stream 会通过 `listen` 方法打印</span></span><br><span class="line">    _sink.add(<span class="string">'A'</span>);</span><br><span class="line">    _sink.add(<span class="number">11</span>);</span><br><span class="line">    _sink.add(<span class="number">11.16</span>);</span><br><span class="line">    _sink.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    _sink.add(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 最后要释放资源...</span></span><br><span class="line">    _sink.close();</span><br><span class="line">    _controller.close();</span><br><span class="line">    _subscription.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Container(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下控制台的输出：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527150910.png" alt=""></p><p>果然把所有的数据都打印出来了，前面有说过，单订阅的 stream 只有当 <code>listen</code> 后才会发送数据，不试试我还是不相信的，我们把 <code>_sink.add</code> 放到 <code>listen</code> 前面去执行，再看控制台的打印结果。居然真的是一样的，Google 粑粑果然诚不欺我。接着试下 <code>pause</code>，<code>resume</code> 方法，看下数据如何监听，修改代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_sink = _controller.sink;</span><br><span class="line">_subscription = _controller.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listener: $data'</span>));</span><br><span class="line">_sink.add(<span class="string">'A'</span>);</span><br><span class="line">_subscription.pause(); <span class="comment">// 暂停监听</span></span><br><span class="line">_sink.add(<span class="number">11</span>);</span><br><span class="line">_sink.add(<span class="number">11.16</span>);</span><br><span class="line">_subscription.resume(); <span class="comment">// 恢复监听</span></span><br><span class="line">_sink.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">_sink.add(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>再看控制台的打印，你们可以先猜下是什么结果，我猜大部分人都会觉得应该是不会有 11 和 11.16 打印出来了。然鹅事实并非这样，打印的结果并未发生变化，也就是说，调用 <code>pause</code> 方法后，stream 被堵住了，数据不继续发送了。</p><p>接下来看下广播订阅 stream，对代码做下修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamController _controller = StreamController.broadcast();</span><br><span class="line">  Sink _sink;</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    _sink = _controller.sink;</span><br><span class="line"></span><br><span class="line">    _sink.add(<span class="string">'A'</span>);</span><br><span class="line">    _subscription = _controller.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listener: $data'</span>));</span><br><span class="line"></span><br><span class="line">    _sink.add(<span class="number">11</span>);</span><br><span class="line">    _subscription.pause();</span><br><span class="line">    _sink.add(<span class="number">11.16</span>);</span><br><span class="line">    _subscription.resume();</span><br><span class="line"></span><br><span class="line">    _sink.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    _sink.add(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看下控制台的打印：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527150935.png" alt=""></p><p>你猜对答案了吗，这边做下小总结：</p><p><strong>单订阅 Stream 只有当存在监听的时候，才发送数据，广播订阅 Stream 则不考虑这点，有数据就发送；当监听调用 pause 以后，不管哪种类型的 stream 都会停止发送数据，当 resume 之后，把前面存着的数据都发送出去。</strong></p><p>sink 可以接受任何类型的数据，也可以通过泛型对传入的数据进行限制，比如我们对 <code>StreamController</code> 进行类型指定 <code>StreamController&lt;int&gt; _controller = StreamController.broadcast();</code> 因为没有对 <code>Sink</code> 的类型进行限制，还是可以添加除了 <code>int</code> 外的类型参数，但是运行的时候就会报错，<code>_controller</code> 对你传入的参数做了类型判定，拒绝进入。</p><p><code>Stream</code> 中还提供了很多 <code>StremTransformer</code>，用于对监听到的数据进行处理，比如我们发送 0~19 的 20 个数据，只接受大于 10 的前 5 个数据，那么可以对 stream 如下操作</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_subscription = _controller.stream</span><br><span class="line">    .where((value) =&gt; value &gt; <span class="number">10</span>)</span><br><span class="line">    .take(<span class="number">5</span>)</span><br><span class="line">    .listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listen: $data'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>.generate(<span class="number">20</span>, (index) =&gt; _sink.add(index));</span><br></pre></td></tr></table></figure><p>那么打印出来的数据如下图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527150951.png" alt=""></p><p>除了 <code>where</code>，<code>take</code> 还有很多 <code>Transformer</code>， 例如 <code>map</code>，<code>skip</code> 等等，小伙伴们可以自行研究。了解了 <code>Stream</code> 的基本属性后，就可以继续往下了~</p><h4 id="StreamBuilder"><a href="#StreamBuilder" class="headerlink" title="StreamBuilder"></a>StreamBuilder</h4><p>前面提到了 stream 通过 <code>listen</code> 进行监听数据的变化，<code>Flutter</code> 就为我们提供了这么个部件 <code>StreamBuilder</code> 专门用于监听 stream 的变化，然后自动刷新重建。接着来看下源码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> StreamBuilder(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.initialData, <span class="comment">// 初始数据，不传入则为 null</span></span><br><span class="line">    Stream&lt;T&gt; stream,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key, stream: stream);</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">AsyncSnapshot&lt;T&gt; initial() =&gt; AsyncSnapshot&lt;T&gt;.withData(ConnectionState.none, initialData);</span><br></pre></td></tr></table></figure><p><code>StreamBuilder</code> 必须传入一个 <code>AsyncWidgetBuilder</code> 参数，初始值 <code>initialData</code> 可为空， <code>stream</code> 用于监听数据变化，<code>initial</code> 方法的调用在其父类 <code>StremBuilderBase</code> 中，接着看下 <code>StreamBuilderBaseState</code> 的源码，这里我删除一些不必要的源码，方便查看，完整的源码可自行查看</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StreamBuilderBaseState</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StreamBuilderBase</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _summary = widget.initial(); <span class="comment">// 通过传入的初始值生成默认值，如果没有传入则会是 null</span></span><br><span class="line">    _subscribe(); <span class="comment">// 注册传入的 stream，用于监听变化</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// _summary 为监听到的数据</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; widget.build(context, _summary);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">void</span> _subscribe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.stream != <span class="keyword">null</span>) &#123; </span><br><span class="line">      <span class="comment">// stream 通过外部传入，对数据的变化进行监听，</span></span><br><span class="line">      <span class="comment">// 在不同回调中，通过 setState 进行更新 _summary</span></span><br><span class="line">      <span class="comment">// 当 _summary 更新后，由于调用了 setState，重新调用 build 方法，将最新的 _summary 传递出去</span></span><br><span class="line">      _subscription = widget.stream.listen((T data) &#123;</span><br><span class="line">        setState(() &#123; </span><br><span class="line">          _summary = widget.afterData(_summary, data); </span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, onError: (<span class="built_in">Object</span> error) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _summary = widget.afterError(_summary, error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, onDone: () &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _summary = widget.afterDone(_summary);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      _summary = widget.afterConnected(_summary); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前更新数据都需要通过 <code>setState</code> 进行更新，这里了解完了 <code>stream</code>，我们就不使用 <code>setState</code> 更新，使用 <code>Stream</code> 来更新</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StreamHomeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StreamHome</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一个全局的 `StreamController`</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _controller = StreamController.broadcast();</span><br><span class="line">  <span class="comment">// `sink` 用于传入新的数据</span></span><br><span class="line">  Sink&lt;<span class="built_in">int</span>&gt; _sink;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _sink = _controller.sink;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 需要销毁资源</span></span><br><span class="line">    _sink.close();</span><br><span class="line">    _controller.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: StreamBuilder(</span><br><span class="line">          builder: (_, snapshot) =&gt; Text(<span class="string">'<span class="subst">$&#123;snapshot.data&#125;</span>'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>)),</span><br><span class="line">          stream: _controller.stream, <span class="comment">// stream 在 StreamBuilder 销毁的时候会自动销毁</span></span><br><span class="line">          initialData: _counter,</span><br><span class="line">        ),</span><br><span class="line">      )),</span><br><span class="line">      <span class="comment">// 通过 `sink` 传入新的数据，去通知 `stream` 更新到 builder 中</span></span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; _sink.add(_counter++),</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当点击按钮的时候，就会刷新界面上的值，通过上面的源码分析，<code>StreamBuilder</code> 也是通过 <code>setState</code> 方法进行刷新，那么两种方法孰优孰劣呢，当然是通过 <code>Stream</code> 啦，这不是废话吗。<strong>因为通过调用 setState 刷新的话，会把整个界面都进行重构，但是通过 StreamBuilder 的话，只刷新其 builder，这样效率就更高了</strong>，最后看小效果吧，所谓有图有真相嘛</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-31cb9b8c3a99abaf.gif" alt=""></p><p>这一步，我们摒弃了 <code>setState</code> 方法，那么下一步，我们试试把 <code>StatefulWidget</code> 替换成 <code>StatelessWidget</code> 吧，而且<strong>官方也推荐使用 StatelessWidget 替换 StatefulWidget</strong>，这里就需要提下 <code>BLoC</code> 模式了。</p><h4 id="BLoC"><a href="#BLoC" class="headerlink" title="BLoC"></a>BLoC</h4><p>说实话，现在 Google 下 「flutter bloc」能搜到很多文章，基本上都是通过 <code>InheritedWidget</code> 来实现的，例如这篇<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5bb6f344f265da0aa664d68a" target="_blank" rel="noopener">Flutter | 状态管理探索篇——BLoC(三)</a>，但是 <code>InheritedWidget</code> 没有提供 <code>dispose</code> 方法，那么就会存在 <code>StreamController</code> 不能及时销毁等问题，所以，参考了一篇国外的文章，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.didierboelens.com%2F2018%2F08%2Freactive-programming---streams---bloc%2F" target="_blank" rel="noopener">Reactive Programming - Streams - BLoC</a> 这里通过使用 <code>StatefulWidget</code> 来实现，当该部件销毁的时候，可以在其 <code>dispose</code> 方法中及时销毁 <code>StreamController</code>，这里我还是先当个搬运工，搬下大佬为我们实现好的基类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose(); <span class="comment">// 该方法用于及时销毁资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child; <span class="comment">// 这个 `widget` 在 stream 接收到通知的时候刷新</span></span><br><span class="line">  <span class="keyword">final</span> T bloc; </span><br><span class="line">  </span><br><span class="line">  BlocProvider(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.child, <span class="meta">@required</span> <span class="keyword">this</span>.bloc&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该方法用于返回 Bloc 实例</span></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BaseBloc&gt;(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;(); <span class="comment">// 获取当前 Bloc 的类型</span></span><br><span class="line">    <span class="comment">// 通过类型获取相应的 Provider，再通过 Provider 获取 bloc 实例</span></span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type); </span><br><span class="line">    <span class="keyword">return</span> provider.bloc; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BaseBloc</span>&gt;&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    widget.bloc.dispose(); <span class="comment">// 及时销毁资源</span></span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们对前面的例子使用 <code>BLoC</code> 进行修改。</p><p>首先，我们需要创建一个 <code>Bloc</code> 类，用于修改 count 的值</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; _count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stream</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _countController = StreamController.broadcast();</span><br><span class="line"></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> countStream =&gt; _countController.stream; <span class="comment">// 用于 StreamBuilder 的 stream</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispatch(<span class="built_in">int</span> value) &#123;</span><br><span class="line">    _count = value;</span><br><span class="line">    _countController.sink.add(_count); <span class="comment">// 用于通知修改值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _countController.close(); <span class="comment">// 注销资源</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 <code>Bloc</code> 前，需要在最上层的容器中进行注册，也就是 <code>MaterialApp</code> 中</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(StreamApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 这里对创建的 bloc 类进行注册，如果说有多个 bloc 类的话，可以通过 child 进行嵌套注册即可</span></span><br><span class="line">    <span class="comment">// 放在最顶层，可以全局调用，当 App 关闭后，销毁所有的 Bloc 资源，</span></span><br><span class="line">    <span class="comment">// 也可以在路由跳转的时候进行注册，至于在哪里注册，完全看需求</span></span><br><span class="line">    <span class="comment">// 例如实现主题色的切换，则需要在全局定义，当切换主题色的时候全局切换</span></span><br><span class="line">    <span class="comment">// 又比如只有某个或者某几个特殊界面调用，那么完全可以通过在路由跳转的时候注册</span></span><br><span class="line">    <span class="keyword">return</span> BlocProvider(  </span><br><span class="line">        child: MaterialApp(</span><br><span class="line">          debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">          home: StreamHome(),</span><br><span class="line">        ),</span><br><span class="line">        bloc: CounterBloc());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHome</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 获取注册的 bloc，必须先注册，再去查找</span></span><br><span class="line">    <span class="keyword">final</span> CounterBloc _bloc = BlocProvider.of&lt;CounterBloc&gt;(context); </span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: StreamBuilder(</span><br><span class="line">          initialData: _bloc.count,</span><br><span class="line">          stream: _bloc.countStream,</span><br><span class="line">          builder: (_, snapshot) =&gt; Text(<span class="string">'<span class="subst">$&#123;snapshot.data&#125;</span>'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>)),</span><br><span class="line">        ),</span><br><span class="line">      )),</span><br><span class="line">      floatingActionButton:</span><br><span class="line">          <span class="comment">// 通过 bloc 中的 dispatch 方法进行值的修改，通知 stream 刷新界面</span></span><br><span class="line">          FloatingActionButton(onPressed: () =&gt; </span><br><span class="line">                               _bloc.dispatch(_bloc.count + <span class="number">1</span>), child: Icon(Icons.add)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行后，查看效果还是一样的。所以我们成功的对 <code>StatefulWidget</code> 进行了替换</p><p>再继续讲之前，先总结下 <code>Bloc</code></p><p>​    <strong>1. 成功的把页面和逻辑分离开了，页面只展示数据，逻辑通过 BLoC 进行处理</strong></p><p>​    <strong>2. 减少了 setState 方法的使用，提高了性能</strong></p><p>​    <strong>3. 实现了状态管理</strong></p><h4 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h4><p>因为上面的参考文章中提到了 <code>RxDart</code>，个人觉得有必要了解下，当然目前也有很多文章介绍 <code>RxDart</code>，所以我就讲下和 <code>BLoC</code> 有点关系的部分吧。<code>RxDart</code> 需要通过引入插件的方式引入(<code>rxdart: ^0.21.0</code>)</p><p>如果需要查看详细的内容，我这里提供几篇文章链接</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FReactiveX%2Frxdart" target="_blank" rel="noopener">RxDart 文档</a></p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.burkharts.net%2Fapps%2Fblog%2Frxdart-magical-transformations-of-streams%2F" target="_blank" rel="noopener">RxDart: Magical transformations of Streams</a></p><p>其实 RxDart 就是对 Stream 的进一步分装，RxDart 提供了三种 Subject，其功能类似 Stream 中的单订阅 stream 和 广播 stream。</p><ol><li><p><code>PublishSubject</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// PublishSubject is, by default, a broadcast (aka hot) controller, in order</span></span><br><span class="line"><span class="comment">/// to fulfill the Rx Subject contract. This means the Subject's `stream` can</span></span><br><span class="line"><span class="comment">/// be listened to multiple times.</span></span><br></pre></td></tr></table></figure><p>通过注释可以发现 <code>PuslishSubject</code> 不可被多次订阅，尽管实现是通过 <code>StreamController&lt;T&gt;.broadcast</code> 方式实现，其实三种都是通过 <code>broadcast</code> 方式实现的，所以实现的功能就是类似 <code>Single-subscription Stream</code> 的功能。</p></li><li><p><code>BehaviorSubject</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// BehaviorSubject is, by default, a broadcast (aka hot) controller, in order</span></span><br><span class="line"><span class="comment">/// to fulfill the Rx Subject contract. This means the Subject's `stream` can</span></span><br><span class="line"><span class="comment">/// be listened to multiple times.</span></span><br></pre></td></tr></table></figure><p><code>BehaviorSubject</code> 可以被多次订阅，那么这个就是实现了 <code>Broadcast Stream</code> 功能。</p></li><li><p><code>ReplaySubject</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ReplaySubject is, by default, a broadcast (aka hot) controller, in order</span></span><br><span class="line"><span class="comment">/// to fulfill the Rx Subject contract. This means the Subject's `stream` can</span></span><br><span class="line"><span class="comment">/// be listened to multiple times.</span></span><br></pre></td></tr></table></figure><p><code>ReplaySubject</code> 其实也是实现 <code>Broadcast Stream</code> 功能，那么它和 <code>BehaviorSubject</code> 的区别在哪呢，别急，等我慢慢讲。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// As items are added to the subject, the ReplaySubject will store them.</span></span><br><span class="line"><span class="comment">/// When the stream is listened to, those recorded items will be emitted to</span></span><br><span class="line"><span class="comment">/// the listener.</span></span><br></pre></td></tr></table></figure><p>当有数据添加了，但是还没有监听的时候，它会将数据存储下来，等到有监听了，再发送出去，也就是说，<code>ReplaySubject</code> 实现了 <code>Brodacast Stream</code> 的多订阅功能，同时也实现了 <code>Single-subscription Stream</code> 的存储数据的功能，每次添加了新的监听，都能够获取到全部的数据。当然，这还不是它的全部功能，它还可以设置最大的监听数量，会只监听最新的几个数据，在注释中，提供了这么两个例子，可以看下</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ### Example </span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     final subject = new ReplaySubject&lt;int&gt;();</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.add(1);</span></span><br><span class="line"><span class="comment">///     subject.add(2);</span></span><br><span class="line"><span class="comment">///     subject.add(3);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 1, 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 1, 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 1, 2, 3</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ### Example with maxSize</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     final subject = new ReplaySubject&lt;int&gt;(maxSize: 2); // 实现监听数量限制</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.add(1);</span></span><br><span class="line"><span class="comment">///     subject.add(2);</span></span><br><span class="line"><span class="comment">///     subject.add(3);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 2, 3</span></span><br></pre></td></tr></table></figure></li></ol><p>那么我们可以使用 <code>RxDart</code> 对前面使用 <code>Stream</code> 实现的例子进行替换，最简单的其实只需要使用 <code>BehaviorSubject</code> 替换 <code>StreamController.broadcast()</code> 就可以了，别的都不需要变化。但是 <code>RxDart</code> 有自己的变量，还是按照 <code>RxDart</code> 的方式来</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 StreamController，所以 StreamController 拥有的属性都有</span></span><br><span class="line">BehaviorSubject&lt;<span class="built_in">int</span>&gt; _countController = BehaviorSubject();</span><br><span class="line"><span class="comment">//  StreamController&lt;int&gt; _countController = StreamController.broadcast();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 Stream，所以这里直接用之前 stream 的写法也没问题，但是这样就有点不 RxDart 了</span></span><br><span class="line">Observable&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> countStream =&gt; Observable(_countController.stream);</span><br><span class="line"><span class="comment">//  Stream&lt;int&gt; get countStream =&gt; _countController.stream;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dispatch(<span class="built_in">int</span> value) &#123;</span><br><span class="line">  _count = value;</span><br><span class="line">  <span class="comment">// 直接提供了 add 方法，不需要通过 sink 来添加</span></span><br><span class="line">  _countController.add(_count);</span><br><span class="line"><span class="comment">//    _countController.sink.add(_count);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行还是能过实现相同的效果。如果说要在 <code>RxDart</code> 和 <code>Stream</code> 两种实现方式中选择一种，个人更偏向于 <code>RxDart</code>，因为它对 <code>Stream</code> 进行了进一步的封装，提供了更多更方便的数据转换方法，而且链式的写法真的很舒服，用过了就停不下来，具体的方法介绍可以参考上面提供的链接。</p><h4 id="Provide"><a href="#Provide" class="headerlink" title="Provide"></a>Provide</h4><p>说实话自己封装 <code>BLoC</code> 来实现分离逻辑和界面，相对还是有点难度的，这边可以通过第三方来实现，这边推荐 Google 粑粑的库，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgoogle%2Fflutter-provide" target="_blank" rel="noopener">flutter_provide</a>，看下官方对关键部件和静态方法的介绍</p><blockquote><ul><li><code>Provide&lt;T&gt;</code> - Widget used to obtain values from a <code>ProviderNode</code> higher up in the widget tree and rebuild on change. The <code>Provide&lt;T&gt;</code>widget should only be used with <code>Stream</code>s or <code>Listenable</code>s. Equivalent to <code>ScopedModelDescendant</code> in <code>ScopedModel</code> </li><li><code>Provide.value&lt;T&gt;</code> - Static method used to get a value from a <code>ProviderNode</code> using the <code>BuildContext</code>. This will not rebuild on change. Similar to manually writing a static <code>.of()</code> method for an <code>InheritedWidget</code>.</li><li><code>Provide.stream&lt;T&gt;</code> - Static method used to get a <code>Stream</code> from a <code>ProviderNode</code>. Only works if either <code>T</code> is listenable, or if the <code>Provider</code>comes from a <code>Stream</code>.</li><li><code>Provider&lt;T&gt;</code> - A class that returns a typed value on demand. Stored in a <code>ProviderNode</code> to allow retrieval using <code>Provide</code>.</li><li><code>ProviderNode</code> - The equivalent of the <code>ScopedModel</code> widget. Contains <code>Providers</code> which can be found as an <code>InheritedWidget</code>.</li></ul></blockquote><p><code>Provide</code> 这个部件主要用于从上层的 <code>ProvideNode</code> 中获取值，当变化的时候刷新重建，只能同 <code>Stream</code> 和 <code>Listenable</code>  一同使用，类似于 <code>ScopeMode</code> 中的 <code>ScopedModelDescendant</code>。<em>(这个部件放在需要状态管理的部件的上层，例如有个 Text 需要修改状态，那么就需要在外层提供一个 Provide 部件，通过内部 builder 参数返回 Text 部件)</em></p><p><code>Provide.value</code> 是个静态方法，用于从 <code>ProvideNode</code> 获取值，但是当接收的值改变的时候不会重建。类似于 <code>InheritedWidget</code> 的静态方法 <code>of</code>。<em>(这个方法用于获取指定类型的 provide，每个 provide 都需要提供一个数据类，该类 with ChangeNotifier，当数据变化的时候通过 notifyListeners 通知 provide 变化，进行刷新重建)</em></p><p><code>Provide.stream</code> 是个静态方法，用于从 <code>ProvideNode</code> 获取一个 <code>stream</code>，仅在 T 可被监听，或者 Provide 来自 stream 的情况下有效。<em>(这个通常结合 StreamBuilder 使用，StreamBuilder 在上面已经提到，就不多说了)</em></p><p><code>Provider</code> 按需要的类型返回相关值的类，存储在 <code>ProviderNode</code> 中方便 <code>Provide</code> 进行检索。<em>(这个类主要是将我们自己创建的数据类通过 function 等方法转换成 Provider，并在 Providers 中进行注册)</em></p><p><code>ProvideNode</code> 类似于 <code>ScopedModel</code> 的一个部件，包含所有能被查找的 <code>Providers</code>。<em>(这个需要放在顶层，方便下面的容器进行查找 provider，刷新相应的部件，一般放在 MaterialApp 上层)</em></p><p><em>这边再补充一个个人觉得关键的类 Providers，这个类主要用于存储定义的 Provider，主要是在建立 MaterialApp 的时候将需要用到的 Provider 通过 provide 方法添加进去存储起来，然后在 ProvideNode 中注册所有的 provider 方便下层容器获取值，并调用。</em></p><p>说那么多，还不如直接看个例子直接，代码来了~，首先需要建立一个类似 <code>BLoC</code> 中监听数据变化的 <code>counter_bloc</code> 类的数据管理类，我们这边定义为 <code>count_provider</code> 需要混入 <code>ChangeNotifier</code> 类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountProvider</span> <span class="title">with</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _value = <span class="number">0</span>; <span class="comment">// 存储的数据，也是我们需要管理的状态值</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> value =&gt; _value; <span class="comment">// 获取状态值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> changeValue(<span class="built_in">int</span> value) &#123;</span><br><span class="line">    _value = value;</span><br><span class="line">    notifyListeners(); <span class="comment">// 当状态值发生变化的时候，通过该方法刷新重建部件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要将定义的类注册到全局的 <code>Providers</code> 中</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> providers = Providers()</span><br><span class="line">    <span class="comment">// 将我们创建的数据管理类，通过 Provider.function 方法转换成 Provider，</span></span><br><span class="line">    <span class="comment">// 然后添加到 Providers 中</span></span><br><span class="line">    ..provide(Provider.function((_) =&gt; CountProvider()));</span><br><span class="line">  <span class="comment">// 在 App 上层，通过包裹一层 ProvideNode，并将我们生成的 Providers 实例</span></span><br><span class="line">  <span class="comment">// 注册到 ProvideNode 中去，这样整个 App 都可以通过 Provide.value 查找相关的 Provider</span></span><br><span class="line">  <span class="comment">// 找到 Provider 后就可以找到我们的数据管理类</span></span><br><span class="line">  runApp(ProviderNode(child: StreamApp(), providers: providers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是替换我们的界面实现了，前面通过 <code>BLoC</code> 实现，这里替换成 <code>Provide</code> 来实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHome</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        <span class="comment">// 通过指定类型，获取特定的 Provide，这个 Provide 会返回我们的数据管理类 provider</span></span><br><span class="line">        <span class="comment">// 通过内部定义的方法，获取到需要展示的值</span></span><br><span class="line">        child: Provide&lt;CountProvider&gt;(builder: (_, widget, provider) =&gt; Text(<span class="string">'<span class="subst">$&#123;provider.value&#125;</span>'</span>)),</span><br><span class="line">      )),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">          onPressed: () =&gt;</span><br><span class="line">              <span class="comment">// 通过 value 方法获取到我们的数据管理类 provider，</span></span><br><span class="line">              <span class="comment">// 通过调用改变值的方法，修改内部的值，并通知界面刷新重建</span></span><br><span class="line">              Provide.value&lt;CountProvider&gt;(context).changeValue(</span><br><span class="line">                  Provide.value&lt;CountProvider&gt;(context).value + <span class="number">1</span>),</span><br><span class="line">          child: Icon(Icons.add))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>本文代码查看 bloc 包名下的所有文件，需要单独运行 stream_main.dart 文件</em></p><p>最后运行后还是一样的效果，也摒弃了 <code>StatefulWidget</code> 部件和 <code>SetState</code> 方法，实现了逻辑和界面分离。但是 <code>Provide</code> 最终还是通过 <code>InheritedWidget</code> 来实现，当然在资源方面 Google 的大佬们做了一些相关的处理，至于如何处理，这边就不多说了。目前 <code>provide</code> 的这个库还存在一点争议的地方，具体查看 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgoogle%2Fflutter-provide%2Fissues%2F3" target="_blank" rel="noopener">issue#3</a>，但是目前来看并没有太大的影响。当然你不放心的话，可以使用 <code>Scoped_model</code> 或者上面的 <code>Bloc</code> 模式，Google 在文档也有相关的注明</p><blockquote><p>If you must choose a package today, it’s safer to go with <code>package:scoped_model</code> than with this package.</p></blockquote><p>这篇概念性的比较多，但是等理解了以后，对于以后的开发还是非常有利的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;dart&lt;/code&gt; 部分记得分享过 &lt;code&gt;Stream&lt;/code&gt; 的文章链接，但是我知道你们肯定没几个愿意看的，所以这里再提下。还是得从源码开始…因为源码的注释比较长，就不贴注释了，可以自己看，我这边就提取一些关键信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 是 &lt;code&gt;Dart&lt;/code&gt; 提供的一种数据流订阅管理的”工具”，感觉有点像 &lt;code&gt;Android&lt;/code&gt; 中的 &lt;code&gt;EventBus&lt;/code&gt; 或者 &lt;code&gt;RxBus&lt;/code&gt;，&lt;code&gt;Stream&lt;/code&gt; 可以接收任何对象，包括是另外一个 &lt;code&gt;Stream&lt;/code&gt;，接收的对象通过 &lt;code&gt;StreamController&lt;/code&gt; 的 &lt;code&gt;sink&lt;/code&gt; 进行添加，然后通过 &lt;code&gt;StreamController&lt;/code&gt; 发送给 &lt;code&gt;Stream&lt;/code&gt;，通过 &lt;code&gt;listen&lt;/code&gt; 进行监听，&lt;code&gt;listen&lt;/code&gt; 会返回一个 &lt;code&gt;StreamSubscription&lt;/code&gt; 对象，&lt;code&gt;StreamSubscription&lt;/code&gt; 可以操作对数据流的监听，例如 &lt;code&gt;pause&lt;/code&gt;，&lt;code&gt;resume&lt;/code&gt;，&lt;code&gt;cancel&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 分两种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Single-subscription Stream&lt;/code&gt;：单订阅 stream，整个生命周期只允许有一个监听，如果该监听 cancel 了，也不能再添加另一个监听，而且只有当有监听了，才会发送数据，主要用于文件 &lt;code&gt;IO&lt;/code&gt; 流的读取等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Broadcast Stream&lt;/code&gt;：广播订阅 stream，允许有多个监听，当添加了监听后，如果流中有数据存在就可以监听到数据，这种类型，不管是否有监听，只要有数据就会发送，用于需要多个监听的情况。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十)之手势处理和动画</title>
    <link href="http://yoursite.com/posts/d4756fd3.html"/>
    <id>http://yoursite.com/posts/d4756fd3.html</id>
    <published>2019-04-27T06:55:04.000Z</published>
    <updated>2019-05-27T07:06:50.600Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Flutter</code> 中，自带手势监听的目前为止好像只有按钮部件和一些 <code>chip</code> 部件，例如 <code>Text</code> 等部件需要实现手势监听，就需要借助带有监听事件的部件来实现了，这节我们会讲下 <code>InkWell</code> 和 <code>GestureDetector</code> 来实现手势的监听。</p><h4 id="InkWell"><a href="#InkWell" class="headerlink" title="InkWell"></a>InkWell</h4><p>在前面的一些例子中，小伙伴应该看到了好几次 <code>InkWell</code> 这个部件，通过它我们可以实现对一些手势的监听，并实现 <code>MD</code> 的水波纹效果，举个简单的一个例子</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">InkWell(</span><br><span class="line">  child: Text(<span class="string">'点我...点我...我能响应点击手势'</span>),</span><br><span class="line">  onTap: () =&gt; <span class="built_in">print</span>(<span class="string">'啊...我被点击了...'</span>)</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>那么当点击 <code>Text</code> 的时候就会响应点击事件，控制台输出日志</p><a id="more"></a><p>我们还是老套路，分析下源码。<code>Ctrl</code> 点击 <code>InkWell</code> 来查看源码(<code>Android Studio</code> 的操作，别的我不懂喔…)，然后，「嗯…除了构造函数怎么什么都没有？？？」那只能看它的父类 <code>InkResponse</code> 了，在那之前，我们看下 <code>InkWell</code> 的说明</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; /// A rectangular area of a [Material] that responds to touch.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>InkWell</code> 是在 <strong>MaterialDesign</strong> 风格下的一个用来响应触摸的<strong>矩形区域</strong>（注意加粗的文字，1.如果不是 <code>MD</code> 风格的部件下，你是不能用这个来做点击响应的；2.<code>InkWell</code> 是一块矩形区域，如果你要的是圆形区域，8 好意思，不行！）</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; /// The [InkWell] widget must have a [Material] widget as an ancestor. The</span><br><span class="line">&gt; /// [Material] widget is where the ink reactions are actually painted. This</span><br><span class="line">&gt; /// matches the material design premise wherein the [Material] is what is</span><br><span class="line">&gt; /// actually reacting to touches by spreading ink.</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`InkWell` 必须要有一个 `Material` 风格的部件作为锚点，巴拉巴拉巴拉....再次强调必须要在 `MD` 风格下使用。</span><br><span class="line"></span><br><span class="line">接下来看下 `InkResponse` 吧</span><br><span class="line"></span><br><span class="line">#### InkResponse</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line">const InkResponse(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.child, // 需要监听的子部件</span><br><span class="line">    // 一个 `GestureTapCallback` 类型参数，看下 `GestureTapCallback` 的定义,</span><br><span class="line">    // `typedef GestureTapCallback = void Function();` 就是简单的无参无返回类型参数</span><br><span class="line">    // 监听手指点击事件</span><br><span class="line">    this.onTap,</span><br><span class="line">    // 一个 `GestureTapDownCallback` 类型参数，需要 `TapDownDetails` 类型参数，</span><br><span class="line">    // `TapDownDetails` 里面有个 `Offset` 参数用于记录点击的位置，监听手指点击屏幕的事件</span><br><span class="line">    this.onTapDown,</span><br><span class="line">    // 同 `onTap` 表示点击事件取消监听</span><br><span class="line">    this.onTapCancel,</span><br><span class="line">    // 同 `onTap` 表示双击事件监听</span><br><span class="line">    this.onDoubleTap,</span><br><span class="line">    // 一个 `GestureLongPressCallback` 类型参数，也是无参无返回值，表示长按的监听</span><br><span class="line">    this.onLongPress,</span><br><span class="line">    // 监听高亮的变化，返回 `true` 表示往高亮变化，`false` 相反</span><br><span class="line">    this.onHighlightChanged,</span><br><span class="line">    // 是否需要裁剪区域，`InkWell` 该值为 `true`，会根据 `highlightShape` 裁剪</span><br><span class="line">    this.containedInkWell = false,</span><br><span class="line">    // 高亮的外形，`InkWell` 该值设置成 `BoxShape.rectangle`，所以是个矩形区域</span><br><span class="line">    this.highlightShape = BoxShape.circle,</span><br><span class="line">    this.radius, // 手指点下去的时候，出现水波纹的半径</span><br><span class="line">    this.borderRadius, // 点击时候外圈阴影的圆角半径</span><br><span class="line">    this.customBorder,</span><br><span class="line">    this.highlightColor, // 高亮颜色</span><br><span class="line">    this.splashColor, // 手指点下生成的水波颜色</span><br><span class="line">    this.splashFactory, // 两个值 `InkRipple.splashFactory` 和 `InkSplash.splashFactory`</span><br><span class="line">    this.enableFeedback = true, // 检测到手势是否有反馈</span><br><span class="line">    this.excludeFromSemantics = false,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></blockquote><p>所以一些简单的触摸事件直接通过 <code>InkWell</code> 或者 <code>InkResponse</code> 就能够实现，但是面临一些比较复杂的手势，就有点不太够用了，我们需要通过 <code>GestureDector</code> 来进行处理</p><h4 id="GestureDector"><a href="#GestureDector" class="headerlink" title="GestureDector"></a>GestureDector</h4><p><code>GestureDetector</code> 也是一个部件，主要实现对各种手势动作的监听，其监听事件查看下面的表格</p><table><thead><tr><th style="text-align:left">回调方法</th><th>回调描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>onTapDown</code></td><td>点击屏幕的手势触碰到屏幕时候触发</td></tr><tr><td style="text-align:left"><code>onTapUp</code></td><td>点击屏幕抬手后触发，点击结束</td></tr><tr><td style="text-align:left"><code>onTap</code></td><td>点击事件已经完成的时候触发，和 <code>onTapUp</code> 几乎同时</td></tr><tr><td style="text-align:left"><code>onTapCancel</code></td><td>点击未完成，被其它手势取代的时候触发</td></tr><tr><td style="text-align:left"><code>onDoubleTap</code></td><td>双击屏幕的时候触发</td></tr><tr><td style="text-align:left"><code>onLongPress</code></td><td>长按屏幕的时候触发</td></tr><tr><td style="text-align:left"><code>onLongPressUp</code></td><td>长按屏幕后抬手触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragDown</code></td><td>触碰到屏幕，可能发生垂直方向移动触发，<code>onVerticalDrag</code> 系列事件不会同 <code>onHorizontalDrag</code> 系列事件同时发生 ，如果发生了 <code>onVerticalDrag</code> 则接下来如何变化移动，都不会触发 <code>onHorizontalDrag</code> 事件，除非取消后重新触发。判断两者的关键是准备滑动的意图，先发生横向滑动则触发 <code>onHorizontalDrag</code> 事件，否则 <code>onVerticalDrag</code> 事件。</td></tr><tr><td style="text-align:left"><code>onVerticalDragStart</code></td><td>触碰到屏幕，并开始发生垂直方向的移动触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragUpdate</code></td><td>垂直方向移动的距离变化触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragEnd</code></td><td>抬手取消垂直方向移动的时候触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragCancel</code></td><td>触发 <code>onVerticalDragDown</code> 但是没有完成整个 <code>onVerticalDrag</code> 事件触发</td></tr><tr><td style="text-align:left"></td><td><code>onHorizontalDrag</code> 系列介绍省略同上…</td></tr><tr><td style="text-align:left"><code>onPanDown</code></td><td>触碰到屏幕，准备滑动的时候触发，<code>onPan</code> 系列回调不可和 <code>onVerticalDrag</code> 或者 <code>onHorizontalDrag</code> 系列回调同时设置</td></tr><tr><td style="text-align:left"><code>onPanStart</code></td><td>触碰到屏幕，并开始滑动时候触发</td></tr><tr><td style="text-align:left"><code>onPanUpdate</code></td><td>滑动位置发生改变的时候触发</td></tr><tr><td style="text-align:left"><code>onPanEnd</code></td><td>滑动完成并抬手的时候触发</td></tr><tr><td style="text-align:left"><code>onPanCancel</code></td><td>触发 <code>onPanDown</code> 但是没有完成整个 <code>onPan</code> 事件触发</td></tr><tr><td style="text-align:left"><code>onScaleStart</code></td><td>两个手指之间建立联络点触发，初始缩放比例为 1.0</td></tr><tr><td style="text-align:left"><code>onScaleUpdate</code></td><td>手指距离发生变化，缩放比例也跟随变化触发</td></tr><tr><td style="text-align:left"><code>onScaleEnd</code></td><td>手指抬起，至间的联络断开时候触发</td></tr></tbody></table><p>还有 <code>onForcePress</code> 系列事件，这个是根据对屏幕的挤压力度进行触发，需要达到某些定值才能触发。<code>GestureDetector</code> 有个 <code>behavior</code> 属性用于设置手势监听过程中的表现形式</p><ol><li><code>deferToChild</code> 默认值，触摸到 <code>child</code> 的范围才会触发手势，空白处不会触发</li><li><code>opaque</code> 不透明模式，防止 <code>background widget</code> 接收到手势</li><li><code>translucent</code> 半透明模式，刚好同 <code>opaque</code> 相反，允许 <code>background widget</code> 接收到手势</li></ol><p>介绍完了手势，那就可以实际操练起来了，比如，实现一个跟随手指运动的小方块，先看下效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-fad16bdf993f54d8.gif" alt=""></p><p>简单的分析下，通过 <code>Positioned</code> 来设置小方块的位置，根据 <code>GestureDetector</code> 的 <code>onPanUpdate</code> 修改 <code>Positioned</code> 的 <code>left</code> 和 <code>top</code> 值，当 <code>onPanEnd</code> 或者 <code>onPanCancel</code> 的时候设置为原点，那么就可以有如图的效果了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GestureDemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _GestureDemoPageState createState() =&gt; _GestureDemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GestureDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GestureDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> left = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">double</span> top = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Gesture Demo'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Stack(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Positioned(child: Container(width: <span class="number">50.0</span>, height: <span class="number">50.0</span>, color: Colors.red), left: left, top: top),</span><br><span class="line">            GestureDetector(</span><br><span class="line">              behavior: HitTestBehavior.translucent,</span><br><span class="line">              child: Container(</span><br><span class="line">                  color: Colors.transparent,</span><br><span class="line">                  width: MediaQuery.of(context).size.width - <span class="number">10</span>,</span><br><span class="line">                  height: MediaQuery.of(context).size.height),</span><br><span class="line">              onPanDown: (details) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = details.globalPosition.dx;</span><br><span class="line">                  top = details.globalPosition.dy;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onPanUpdate: (details) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = details.globalPosition.dx;</span><br><span class="line">                  top = details.globalPosition.dy;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onPanCancel: () &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = <span class="number">0.0</span>;</span><br><span class="line">                  top = <span class="number">0.0</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onPanEnd: (details) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = <span class="number">0.0</span>;</span><br><span class="line">                  top = <span class="number">0.0</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说要实现一个放大缩小的方块，就可以通过 <code>onScaleUpdate</code> 中获取到的 <code>details.scale</code> 来设置方块的宽高即可。这个比较简单就留给小伙伴们自己实现效果了。</p><p><em>该部分代码查看 gesture_main.dart 文件</em></p><h4 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h4><p><code>Flutter</code> 的 <code>Animation</code> 是个抽象类，具体的实现需要看其子类 <code>AnimationController</code>，在这之前，先了解下 <code>Animation</code> 的一些方法和介绍。</p><ol><li><p><code>addListener</code> / <code>removeListener</code> 添加的监听用于监听值的变化，<code>remove</code> 用于停止监听</p></li><li><p><code>addStatusListener</code> / <code>removeStatusListener</code> 添加动画状态变化的监听，<code>remove</code> 停止监听，<code>Animation</code> 的状态有 4 种：<code>dismissed</code> 动画初始状态，反向运动结束状态，<code>forward</code> 动画正向运动状态，<code>reverse</code> 动画反向运动状态，<code>completed</code> 动画正向运动结束状态。</p></li><li><p><code>drive</code> 方法用于连接动画，例如官方举的例子，因为 <code>AnimationController</code> 是其子类，所以也拥有该方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Animation&lt;Alignment&gt; _alignment1 = _controller.drive(</span><br><span class="line">     AlignmentTween(</span><br><span class="line">       begin: Alignment.topLeft,</span><br><span class="line">       end: Alignment.topRight,</span><br><span class="line">     ),</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>上面的例子将 <code>AnimationController</code> 和 <code>AlignmentTween</code> 结合成一个 <code>Animation&lt;Alignment&gt;</code> 动画，当然 <code>drive</code> 可以结合多个动画，例如</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Animation&lt;Alignment&gt; _alignment3 = _controller</span><br><span class="line">       .drive(CurveTween(curve: Curves.easeIn))</span><br><span class="line">       .drive(AlignmentTween(</span><br><span class="line">         begin: Alignment.topLeft,</span><br><span class="line">         end: Alignment.topRight,</span><br><span class="line">       ));</span><br></pre></td></tr></table></figure></li></ol><p>因为 <code>Animation</code> 是抽象类，所以具体的还是需要通过 <code>AnimationController</code> 来实现。</p><h4 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController(&#123;</span><br><span class="line">    <span class="built_in">double</span> value, <span class="comment">// 设置初始的值</span></span><br><span class="line">    <span class="keyword">this</span>.duration, <span class="comment">// 动画的时长</span></span><br><span class="line">    <span class="keyword">this</span>.debugLabel, <span class="comment">// 主要是用于 `toString` 方法中输出信息</span></span><br><span class="line">    <span class="keyword">this</span>.lowerBound = <span class="number">0.0</span>, <span class="comment">// 最小范围</span></span><br><span class="line">    <span class="keyword">this</span>.upperBound = <span class="number">1.0</span>, <span class="comment">// 最大范围</span></span><br><span class="line">    <span class="comment">// AnimationController 结束时候的行为，有 `normal` 和 `preserve` 两个值可选</span></span><br><span class="line">    <span class="keyword">this</span>.animationBehavior = AnimationBehavior.normal, </span><br><span class="line">    <span class="comment">// 这个属性可以通过 with `SingleTickerProviderStateMixin` </span></span><br><span class="line">    <span class="comment">// 或者 `TickerProviderStateMixin` 引入到 `State`，通过 `this` 指定</span></span><br><span class="line">    <span class="meta">@required</span> TickerProvider vsync,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><code>AnimationController</code> 控制动画的方法有这么几个</p><ol><li><code>forward</code> 启动动画，和上面提到的 <code>forward</code> 状态不一样</li><li><code>reverse</code> 方向启动动画</li><li><code>repeat</code> 重复使动画运行</li><li><code>stop</code> 停止动画</li><li><code>reset</code> 重置动画</li></ol><p>大概了解了 <code>AnimationController</code> ，接下来通过一个实际的小例子来加深下印象，例如实现如下效果，点击开始动画，结束后再点击反向动画</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-0f55a9d8215eb84c.gif" alt=""></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoPage</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _animationController = AnimationController(</span><br><span class="line">        vsync: <span class="keyword">this</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>), lowerBound: <span class="number">28.0</span>, upperBound: <span class="number">50.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当动画值发生变化的时候，重绘下 icon</span></span><br><span class="line">    _animationController.addListener(() &#123;</span><br><span class="line">      setState(() &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 一定要释放资源</span></span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Animation Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: IconButton(</span><br><span class="line">            icon: Icon(Icons.android, color: Colors.green[<span class="number">500</span>], size: _animationController.value),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 根据状态执行不同动画运动方式</span></span><br><span class="line">              <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">                _animationController.reverse();</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed)</span><br><span class="line">                _animationController.forward();</span><br><span class="line">            &#125;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果要实现无限动画呢，那就可以通过 <code>addStatusListener</code> 监听动画的状态来执行，修改代码，在 <code>initState</code> 增加如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_animationController.addStatusListener((status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">        _animationController.reverse();  <span class="comment">// 正向结束后开始反向</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed) </span><br><span class="line">        _animationController.forward(); <span class="comment">// 反向结束后开始正向</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _animationController.forward(); <span class="comment">// 启动动画</span></span><br></pre></td></tr></table></figure><p>把 <code>Center</code> 的 <code>child</code> 替换成一个 <code>Icon</code>，因为上面已经启动了动画，所以不需要再用点击去启动了，运行后就会无限放大缩小循环跑了。</p><p>在这个例子中，通过设置 <code>AnimationController</code> 的 <code>lowerBound</code> 和 <code>upperBound</code> 实现了动画的变化范围，接下来，将通过 <code>Tween</code> 来实现动画的变化范围。先看下 <code>Tween</code> 的一些介绍。</p><h4 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h4><blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">/// A linear interpolation between a beginning and ending value.</span></span><br><span class="line">&gt; <span class="comment">///</span></span><br><span class="line">&gt; <span class="comment">/// [Tween] is useful if you want to interpolate across a range.</span></span><br><span class="line">&gt; <span class="comment">///</span></span><br><span class="line">&gt; <span class="comment">/// To use a [Tween] object with an animation, call the [Tween] object's</span></span><br><span class="line">&gt; <span class="comment">/// [animate] method and pass it the [Animation] object that you want to</span></span><br><span class="line">&gt; <span class="comment">/// modify.</span></span><br><span class="line">&gt; <span class="comment">///</span></span><br><span class="line">&gt; <span class="comment">/// You can chain [Tween] objects together using the [chain] method, so that a</span></span><br><span class="line">&gt; <span class="comment">/// single [Animation] object is configured by multiple [Tween] objects called</span></span><br><span class="line">&gt; <span class="comment">/// in succession. This is different than calling the [animate] method twice,</span></span><br><span class="line">&gt; <span class="comment">/// which results in two separate [Animation] objects, each configured with a</span></span><br><span class="line">&gt; <span class="comment">/// single [Tween].</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>Tween</code> 是一个线性插值(如果要修改运动的插值，可以通过 <code>CurveTween</code> 来修改)，所以在线性变化的时候很有用</p><p>通过调用 <code>Tween</code> 的 <code>animate</code> 方法生成一个 <code>Animation</code>(<code>animate</code> 一般传入 <code>AnimationController</code>)</p><p>还可以通过 <code>chain</code> 方法将多个 <code>Tween</code> 结合到一起，这样就不需要多次去调用 <code>Tween</code> 的 <code>animate</code> 方法来生成动画了，多次调用 <code>animate</code> 相当于使用了两个分开的动画来完成效果，但是 <code>chain</code> 结合到一起就是一个动画过程</p><p>那么对前面的动画进行一些修改，通过 <code>Tween</code> 来控制值的变化</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoPage</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  Animation _scaleAnimation; <span class="comment">// 动画实例，用于修改值的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _animationController = AnimationController(vsync: <span class="keyword">this</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>)); <span class="comment">// 不通过 `lowerBound` 和 `upperBound` 设置范围，改用 `Tween`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当动画值发生变化的时候，重绘下 icon</span></span><br><span class="line">    _animationController.addListener(() &#123;</span><br><span class="line">      setState(() &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _animationController.addStatusListener((status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">        _animationController.reverse();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed)</span><br><span class="line">        _animationController.forward();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 `Tween` 的 `animate` 生成一个 Animation</span></span><br><span class="line">    <span class="comment">// 再通过  Animation.value 进行值的修改</span></span><br><span class="line">    _scaleAnimation = Tween(begin: <span class="number">28.0</span>, end: <span class="number">50.0</span>).animate(_animationController);</span><br><span class="line">    _animationController.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 一定要释放资源</span></span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Animation Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        <span class="comment">// 通过动画返回的值，修改图标的大小</span></span><br><span class="line">        child: Icon(Icons.favorite, color: Colors.red, size: _scaleAnimation.value),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，还是能过达到之前的效果，那么很多小伙伴肯定会问了，「**，加了那么多代码，效果还是和以前的一样，还不如不加…」好吧，我无法反驳，但是如果要实现多个动画呢，那么使用 <code>Tween</code> 就有优势了，比如我们让图标大小变化的同时，颜色和位置也发生变化，只通过 <code>AnimationController</code> 要怎么实现? 又比如说，运动的方式要先加速后减速，那只通过 <code>AnimationController</code> 要如何实现？这些问题通过 <code>Tween</code> 就会非常方便解决，直接上代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoPage</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  Animation _scaleAnimation; <span class="comment">// 用于控制图标大小</span></span><br><span class="line">  Animation&lt;Color&gt; _colorAnimation; <span class="comment">// 控制图标颜色</span></span><br><span class="line">  Animation&lt;Offset&gt; _positionAnimation; <span class="comment">// 控制图标位置</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _animationController = AnimationController(vsync: <span class="keyword">this</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当动画值发生变化的时候，重绘下 icon</span></span><br><span class="line">    _animationController.addListener(() &#123;</span><br><span class="line">      setState(() &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _animationController.addStatusListener((status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">        _animationController.reverse();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed) _animationController.forward();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 通过 `chain` 结合 `CurveTween` 修改动画的运动方式，曲线类型可自行替换</span></span><br><span class="line">    _scaleAnimation =</span><br><span class="line">        Tween(begin: <span class="number">28.0</span>, end: <span class="number">50.0</span>).chain(CurveTween(curve: Curves.decelerate)).animate(_animationController);</span><br><span class="line"></span><br><span class="line">    _colorAnimation = ColorTween(begin: Colors.red[<span class="number">200</span>], end: Colors.red[<span class="number">900</span>])</span><br><span class="line">        .chain(CurveTween(curve: Curves.easeIn))</span><br><span class="line">        .animate(_animationController);</span><br><span class="line"></span><br><span class="line">    _positionAnimation = Tween(begin: Offset(<span class="number">100</span>, <span class="number">100</span>), end: Offset(<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line">        .chain(CurveTween(curve: Curves.bounceInOut))</span><br><span class="line">        .animate(_animationController);</span><br><span class="line"></span><br><span class="line">    _animationController.forward(); <span class="comment">// 启动动画</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Animation Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Stack(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Positioned(</span><br><span class="line">            child: Icon(Icons.favorite, color: _colorAnimation.value, size: _scaleAnimation.value),</span><br><span class="line">            left: _positionAnimation.value.dx,</span><br><span class="line">            top: _positionAnimation.value.dy,</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么最后的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-977e7de1b224aa58.gif" alt=""></p><p>当然，<code>Flutter</code> 中已经实现的 <code>Tween</code> 还有很多，包括 <code>BorderTween</code>、<code>TextStyleTween</code>、<code>ThemeDataTween</code> ..等等，实现的方式都是类似的，小伙伴们可以自己慢慢看。</p><h4 id="AnimationWidget"><a href="#AnimationWidget" class="headerlink" title="AnimationWidget"></a>AnimationWidget</h4><p>在上面的例子中，都是通过 <code>addListener</code> 监听动画值变化，然后通过 <code>setState</code> 方法来实现刷新效果。那么 <code>Flutter</code> 也提供了一个部件 <code>AnimationWidget</code> 来实现动画部件，就不需要一直监听了，还是实现上面的例子</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunningHeart</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Animation&gt; animations; <span class="comment">// 传入动画列表</span></span><br><span class="line">  <span class="keyword">final</span> AnimationController animationController; <span class="comment">// 控制动画</span></span><br><span class="line"></span><br><span class="line">  RunningHeart(&#123;<span class="keyword">this</span>.animations, <span class="keyword">this</span>.animationController&#125;)</span><br><span class="line">      <span class="comment">// 对传入的参数进行限制(当然你也可以不做限制)</span></span><br><span class="line">      : <span class="keyword">assert</span>(animations.length == <span class="number">3</span>),</span><br><span class="line">        <span class="keyword">assert</span>(animations[<span class="number">0</span>] <span class="keyword">is</span> Animation&lt;Color&gt;),</span><br><span class="line">        <span class="keyword">assert</span>(animations[<span class="number">1</span>] <span class="keyword">is</span> Animation&lt;<span class="built_in">double</span>&gt;),</span><br><span class="line">        <span class="keyword">assert</span>(animations[<span class="number">2</span>] <span class="keyword">is</span> Animation&lt;Offset&gt;),</span><br><span class="line">        <span class="keyword">super</span>(listenable: animationController);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Positioned(</span><br><span class="line">          <span class="comment">// 之前的 animation 都通过 animations 参数传入到 `AnimationWidget`</span></span><br><span class="line">          child: Icon(Icons.favorite, color: animations[<span class="number">0</span>].value, size: animations[<span class="number">1</span>].value),</span><br><span class="line">          left: animations[<span class="number">2</span>].value.dx,</span><br><span class="line">          top: animations[<span class="number">2</span>].value.dy,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实内部返回的部件和前面的是一样的</p><p>接着对 <code>_AnimationDemoPageState</code> 类进行修改，注释 <code>initState</code> 中的 <code>_animationController.addListener</code> 所有内容，然后将 <code>body</code> 属性替换成新建的 <code>RunningHeart</code> 部件，记得传入的动画列表的顺序</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: RunningHeart(</span><br><span class="line">        animations: [_colorAnimation, _scaleAnimation, _positionAnimation],</span><br><span class="line">        animationController: _animationController,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>这样就实现了刚才一样的效果，并且没有一直调用 <code>setState</code> 来刷新。</p><p><em>该部分代码查看 animation_main.dart 文件</em></p><h4 id="StaggeredAnimations"><a href="#StaggeredAnimations" class="headerlink" title="StaggeredAnimations"></a>StaggeredAnimations</h4><p><code>Flutter</code> 还提供了交错动画，听名字就可以知道，是按照时间轴，进行不同的动画，并且由同个<code>AnimationController</code> 进行控制。因为没有找到好的例子，原谅我直接搬官方的例子来讲，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fflutterchina.club%2Fanimations%2Fstaggered-animations%2F%23complete-staggered-animation" target="_blank" rel="noopener">官方交错动画 demo</a></p><p>在继续看之前，先了解下 <code>Interval</code></p><blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">/// An [Interval] can be used to delay an animation. For example, a six second</span></span><br><span class="line">&gt; <span class="comment">/// animation that uses an [Interval] with its [begin] set to 0.5 and its [end]</span></span><br><span class="line">&gt; <span class="comment">/// set to 1.0 will essentially become a three-second animation that starts</span></span><br><span class="line">&gt; <span class="comment">/// three seconds later.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>Interval</code> 用来延迟动画，例如一个时长 6s 的动画，通过 <code>Interval</code> 设置其 <code>begin</code> 参数为 0.5，<code>end</code> 参数设置为 1.0，那么这个动画就会变成 3s 的动画，并且开始的时间延迟了 3s。</p><p>了解 <code>Interval</code> 功能后，就可以看下实例了，当然我们不和官方的 demo 一样，中间加个旋转动画</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaggeredAnim</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AnimationController controller;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; opacity;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; width;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; height;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;EdgeInsets&gt; padding;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;BorderRadius&gt; border;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;Color&gt; color;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; rotate;</span><br><span class="line"></span><br><span class="line">  StaggeredAnim(&#123;Key key, <span class="keyword">this</span>.controller&#125;):</span><br><span class="line">        <span class="comment">// widget 透明度</span></span><br><span class="line">        opacity = Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.0</span>, <span class="number">0.1</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 宽</span></span><br><span class="line">        width = Tween(begin: <span class="number">50.0</span>, end: <span class="number">150.0</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.1</span>, <span class="number">0.250</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 高</span></span><br><span class="line">        height = Tween(begin: <span class="number">50.0</span>, end: <span class="number">150.0</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.25</span>, <span class="number">0.375</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 底部距离</span></span><br><span class="line">        padding = EdgeInsetsTween(begin: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">150.0</span>), end: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">.0</span>))</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.25</span>, <span class="number">0.375</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 旋转</span></span><br><span class="line">        rotate = Tween(begin: <span class="number">0.0</span>, end: <span class="number">0.25</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.375</span>, <span class="number">0.5</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 外形</span></span><br><span class="line">        border = BorderRadiusTween(begin: BorderRadius.circular(<span class="number">5.0</span>), end: BorderRadius.circular(<span class="number">75.0</span>))</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.5</span>, <span class="number">0.75</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 颜色</span></span><br><span class="line">        color = ColorTween(begin: Colors.blue, end: Colors.orange)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.75</span>, <span class="number">1.0</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  Widget _buildAnimWidget(BuildContext context, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      padding: padding.value,</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      <span class="comment">// 旋转变化</span></span><br><span class="line">      child: RotationTransition(</span><br><span class="line">        turns: rotate, <span class="comment">// turns 表示当前动画的值 * 360° 角度</span></span><br><span class="line">        child: Opacity(</span><br><span class="line">          opacity: opacity.value, <span class="comment">// 透明度变化</span></span><br><span class="line">          child: Container(</span><br><span class="line">            width: width.value, <span class="comment">// 宽度变化</span></span><br><span class="line">            height: height.value, <span class="comment">// 高度变化</span></span><br><span class="line">            decoration: BoxDecoration(</span><br><span class="line">                color: color.value, <span class="comment">// 颜色变化</span></span><br><span class="line">                border: Border.all(color: Colors.indigo[<span class="number">300</span>], width: <span class="number">3.0</span>),</span><br><span class="line">                borderRadius: border.value), <span class="comment">// 外形变化</span></span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// AnimatedBuilder 继承 AnimationWidget，用来快速构建动画部件</span></span><br><span class="line">    <span class="keyword">return</span> AnimatedBuilder(animation: controller, builder: _buildAnimWidget);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>body</code> 的参数，设置成我们的动画，当点击的时候就会启动动画</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">    behavior: HitTestBehavior.opaque,</span><br><span class="line">    onTap: _playAnim,</span><br><span class="line">    child: Center(</span><br><span class="line">      <span class="comment">// 定义一个外层圈，能够使动画显眼点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        width: <span class="number">300</span>,</span><br><span class="line">        height: <span class="number">300</span>,</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: Colors.black.withOpacity(<span class="number">0.1</span>), border: Border.all(color: Colors.black.withOpacity(<span class="number">0.5</span>))),</span><br><span class="line">        child: StaggeredAnim(controller: _controller),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>看下最后的效果吧</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-329d48585eee04b4.gif" alt=""></p><p><em>该部分代码查看 staggered_animation_main.dart 文件</em></p><p>结束前，我们再讲一种比较简单的 <code>Hreo</code> 动画，用来过渡用。</p><h4 id="Hero"><a href="#Hero" class="headerlink" title="Hero"></a>Hero</h4><p>通过指定 <code>Hero</code> 中的 <code>tag</code>，在切换的时候 <code>Hero</code> 会寻找相同的 <code>tag</code>，并实现动画，具体的实现逻辑，这里可以推荐一篇文章 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fyumi0629%2Farticle%2Fdetails%2F83176911" target="_blank" rel="noopener">谈一谈Flutter中的共享元素动画Hero</a>，里面写的很详细，就不造车轮了。当然这边还是得提供个简单的 demo 的，替换前面的 <code>body</code> 参数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: InkWell(</span><br><span class="line">          child: Hero(</span><br><span class="line">            tag: <span class="string">'hero_tag'</span>, <span class="comment">// 这里指定 tag</span></span><br><span class="line">            child: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">100.0</span>, height: <span class="number">100.0</span>),</span><br><span class="line">          ),</span><br><span class="line">          onTap: () =&gt; Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; HeroPage())),</span><br><span class="line">        ),</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>然后创建 <code>HeroPage</code> 界面，当然也可以是个 <code>Dialog</code>，只要通过路由实现即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: InkWell(</span><br><span class="line">          child: Hero(tag: <span class="string">'hero_tag'</span>, child: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">200.0</span>, height: <span class="number">200.0</span>)),</span><br><span class="line">          onTap: () =&gt; Navigator.pop(context),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下最后的效果图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-b20a401615f8acde.gif" alt=""></p><p><em>该部分代码查看 animation_main.dart 文件</em></p><p>这一部分讲的比较多，小伙伴可以慢慢消化，下节我会尽量填下之前留下的状态管理的坑。</p><p>最后代码的地址还是要的：</p><ol><li>文章中涉及的代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_arts_demos_app" target="_blank" rel="noopener">demos</a></li><li>基于郭神 <code>cool weather</code> 接口的一个项目，实现 <code>BLoC</code> 模式，实现状态管理：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather" target="_blank" rel="noopener">flutter_weather</a></li><li>一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_shop" target="_blank" rel="noopener">flutter_shop</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;Flutter&lt;/code&gt; 中，自带手势监听的目前为止好像只有按钮部件和一些 &lt;code&gt;chip&lt;/code&gt; 部件，例如 &lt;code&gt;Text&lt;/code&gt; 等部件需要实现手势监听，就需要借助带有监听事件的部件来实现了，这节我们会讲下 &lt;code&gt;InkWell&lt;/code&gt; 和 &lt;code&gt;GestureDetector&lt;/code&gt; 来实现手势的监听。&lt;/p&gt;
&lt;h4 id=&quot;InkWell&quot;&gt;&lt;a href=&quot;#InkWell&quot; class=&quot;headerlink&quot; title=&quot;InkWell&quot;&gt;&lt;/a&gt;InkWell&lt;/h4&gt;&lt;p&gt;在前面的一些例子中，小伙伴应该看到了好几次 &lt;code&gt;InkWell&lt;/code&gt; 这个部件，通过它我们可以实现对一些手势的监听，并实现 &lt;code&gt;MD&lt;/code&gt; 的水波纹效果，举个简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;InkWell(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  child: Text(&lt;span class=&quot;string&quot;&gt;&#39;点我...点我...我能响应点击手势&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  onTap: () =&amp;gt; &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;啊...我被点击了...&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;),&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么当点击 &lt;code&gt;Text&lt;/code&gt; 的时候就会响应点击事件，控制台输出日志&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(九)之弹窗和提示(SnackBar、BottomSheet、Dialog)</title>
    <link href="http://yoursite.com/posts/5da6faeb.html"/>
    <id>http://yoursite.com/posts/5da6faeb.html</id>
    <published>2019-04-27T03:30:42.000Z</published>
    <updated>2019-05-27T07:03:53.115Z</updated>
    
    <content type="html"><![CDATA[<p>前面的小节把常用的一些部件都介绍了，这节介绍下 <code>Flutter</code> 中的一些操作提示。<code>Flutter</code> 中的操作提示主要有这么几种 <code>SnackBar</code>、<code>BottomSheet</code>、<code>Dialog</code>，因为 <code>Dialog</code> 样式比较多，放最后讲好了</p><h4 id="SnackBar"><a href="#SnackBar" class="headerlink" title="SnackBar"></a>SnackBar</h4><p><code>SnackBar</code> 的源码相对简单</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SnackBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.content, <span class="comment">// 提示信息</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor, <span class="comment">// 背景色</span></span><br><span class="line">    <span class="keyword">this</span>.action, <span class="comment">// SnackBar 尾部的按钮，用于一些回退操作等</span></span><br><span class="line">    <span class="keyword">this</span>.duration = _kSnackBarDisplayDuration, <span class="comment">// 停留的时长，默认 4000ms</span></span><br><span class="line">    <span class="keyword">this</span>.animation, <span class="comment">// 进出动画</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>例如我们需要实现一个功能，修改某个值，修改后给用户一个提示，同时给用户一个撤销该操作的按钮，那么就可以通过 <code>SnackBar</code> 来简单实现。还有就是 <code>SnackBar</code> 可以和 <code>floatingActionButton</code> 完美的配合，弹出的时候不会遮挡住 <code>fab</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PromptDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">PromptDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自增操作</span></span><br><span class="line">  increase() &#123;</span><br><span class="line">    setState(() =&gt; count++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自减操作</span></span><br><span class="line">  decrease() &#123;</span><br><span class="line">    setState(() =&gt; count--);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _changeValue(BuildContext context) &#123;</span><br><span class="line">    increase();</span><br><span class="line">    Scaffold.of(context).showSnackBar(SnackBar(</span><br><span class="line">        content: Text(<span class="string">'当前值已修改'</span>),</span><br><span class="line">        action: SnackBarAction(label: <span class="string">'撤销'</span>, onPressed: decrease),</span><br><span class="line">        duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Prompt Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'当前值：$count'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>)),</span><br><span class="line">        Expanded(</span><br><span class="line">            <span class="comment">// 为了方便拓展，我这边提取了 `snackBar` 的方法，并把按钮放在列表</span></span><br><span class="line">            child: ListView(padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">8.0</span>), children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// SnackBar 需要提供一个包含 context，但是 context 不能是 Scaffold 节点下的 context，所以需要通过 Builder 包裹一层</span></span><br><span class="line">          Builder(builder: (context) =&gt; RaisedButton(onPressed: () =&gt; _changeValue(context), child: Text(<span class="string">'修改当前值'</span>))),</span><br><span class="line">        ]))</span><br><span class="line">      ]),</span><br><span class="line">      <span class="comment">// 当 SnackBar 弹出时，fab 会上移一段距离</span></span><br><span class="line">      floatingActionButton: Builder(</span><br><span class="line">          builder: (context) =&gt; FloatingActionButton(onPressed: () =&gt; _changeValue(context), child: Icon(Icons.send))),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看下最后的效果图，请注意看 <code>fab</code> 和值的变化：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-da29f7ede96f2215.gif" alt=""></p><h4 id="BottomSheet"><a href="#BottomSheet" class="headerlink" title="BottomSheet"></a>BottomSheet</h4><p><code>BottomSheet</code> 看命名就知道是从底部弹出的菜单，展示 <code>BottomSheet</code> 有两种方式，分别是 <code>showBottomSheet</code> 和 <code>showModalBottomSheet</code>，两种方式只有在展示类型上的差别，方法调用无差，而且 <code>showBottomSheet</code> 和 <code>fab</code> 有组合动画，<code>showModalBottomSheet</code> 则没有，看下实际的例子吧。在 <code>ListView</code> 中增加一个 <code>BottomSheet</code> 的按钮，因为 <code>BottomSheet</code> 需要的 <code>context</code> 也不能是 <code>Scaffold</code> 下的 <code>context</code>，所以需要通过 <code>Builder</code> 进行包裹一层，然后增加 <code>_showBottomSheet</code> 的方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showBottomSheet(BuildContext context) &#123;</span><br><span class="line">   showBottomSheet(</span><br><span class="line">     context: context,</span><br><span class="line">     builder: (context) =&gt; ListView(</span><br><span class="line">             <span class="comment">// 生成一个列表选择器</span></span><br><span class="line">             children: <span class="built_in">List</span>.generate(</span><br><span class="line">           <span class="number">20</span>,</span><br><span class="line">           (index) =&gt; InkWell(</span><br><span class="line">               child: Container(alignment: Alignment.center, height: <span class="number">60.0</span>, child: Text(<span class="string">'Item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>)),</span><br><span class="line">               onTap: () &#123;</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">'tapped item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>);</span><br><span class="line">                 Navigator.pop(context);</span><br><span class="line">               &#125;),</span><br><span class="line">         )),</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>把 <code>showBottomSheet</code> 替换成 <code>showModalBottomSheet</code> 就是另外一种展示方式了，内部不需要做任何改变，我们看下两种的运行效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-70e344e56f98f683.gif" alt=""></p><p>可以看到 <code>showBottomSheet</code> 会充满整个屏幕，然后 <code>fab</code> 会跟随一起到 <code>AppBar</code> 的底部位置，而 <code>showModalBottomSheet</code> 展示的高度不会超过半个屏幕的高度，但是 <code>fab</code> 被其遮挡了。假如我们只需要展示 2-3 个 <code>item</code>，但是按照刚才的方式 <code>showModalBottomSheet</code> 的高度太高了，那我们可以在 <code>ListView</code> 外层包裹一层 <code>Container</code>，然后指定 <code>height</code> 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showModalBottomSheet(BuildContext context) &#123;</span><br><span class="line">    showModalBottomSheet(</span><br><span class="line">      context: context,</span><br><span class="line">      builder: (context) =&gt; Container(</span><br><span class="line">            child: ListView(</span><br><span class="line">                children: <span class="built_in">List</span>.generate(</span><br><span class="line">              <span class="number">2</span>,</span><br><span class="line">              (index) =&gt; InkWell(</span><br><span class="line">                  child: Container(alignment: Alignment.center, height: <span class="number">60.0</span>, child: Text(<span class="string">'Item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>)),</span><br><span class="line">                  onTap: () &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">'tapped item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>);</span><br><span class="line">                    Navigator.pop(context);</span><br><span class="line">                  &#125;),</span><br><span class="line">            )),</span><br><span class="line">            height: <span class="number">120</span>,</span><br><span class="line">          ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>修改高度后的效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-51e8092d6a0e879b.gif" alt=""></p><h4 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h4><p>相对于 <code>SnackBar</code> 和 <code>BottomSheet</code>，<code>Dialog</code> 的使用场景相对会更多，在 <code>MaterialDesign</code> 下，<code>Dialog</code> 主要有 3 种：<code>AlertDialog</code>，<code>SimpleDialog</code> 和 <code>AboutDialog</code>，当然在 <code>Cupertino</code> 风格下也有相应的 <code>Dialog</code>，因为这个系列以 <code>MaterialDesign</code> 风格为主，所以 <code>Cupertiono</code> 等下次有时间再写吧。</p><h5 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h5><p>在 <code>ListView</code> 中增加一个 <code>AlertDialog</code> 的按钮，用于点击显示 <code>AlertDialog</code> 用，然后加入显示 <code>AlertDilaog</code> 的方法，并将按钮的 <code>onPressed</code> 指向该方法，<code>Dialog</code> 的 <code>context</code> 可以是 <code>Scaffold</code> 下的 <code>context</code>，所以不需要用 <code>Builder</code> 来包裹一层。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showAlertDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 设置点击 dialog 外部不取消 dialog，默认能够取消</span></span><br><span class="line">        barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt; AlertDialog(</span><br><span class="line">              title: Text(<span class="string">'我是个标题...嗯，标题..'</span>),</span><br><span class="line">              titleTextStyle: TextStyle(color: Colors.purple), <span class="comment">// 标题文字样式</span></span><br><span class="line">              content: Text(<span class="string">r'我是内容\(^o^)/~, 我是内容\(^o^)/~, 我是内容\(^o^)/~'</span>),</span><br><span class="line">              contentTextStyle: TextStyle(color: Colors.green), <span class="comment">// 内容文字样式</span></span><br><span class="line">              backgroundColor: CupertinoColors.white,</span><br><span class="line">              elevation: <span class="number">8.0</span>, <span class="comment">// 投影的阴影高度</span></span><br><span class="line">              semanticLabel: <span class="string">'Label'</span>, <span class="comment">// 这个用于无障碍下弹出 dialog 的提示</span></span><br><span class="line">              shape: Border.all(),</span><br><span class="line">              <span class="comment">// dialog 的操作按钮，actions 的个数尽量控制不要过多，否则会溢出 `Overflow`</span></span><br><span class="line">              actions: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 点击增加显示的值</span></span><br><span class="line">                FlatButton(onPressed: increase, child: Text(<span class="string">'点我增加'</span>)),</span><br><span class="line">                <span class="comment">// 点击减少显示的值</span></span><br><span class="line">                FlatButton(onPressed: decrease, child: Text(<span class="string">'点我减少'</span>)),</span><br><span class="line">                <span class="comment">// 点击关闭 dialog，需要通过 Navigator 进行操作</span></span><br><span class="line">                FlatButton(onPressed: () =&gt; Navigator.pop(context), </span><br><span class="line">                           child: Text(<span class="string">'你点我试试.'</span>)),</span><br><span class="line">              ],</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后看下效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-dd8dc81b43e02e44.gif" alt=""></p><h5 id="SimpleDialog"><a href="#SimpleDialog" class="headerlink" title="SimpleDialog"></a>SimpleDialog</h5><p><code>SimpleDialog</code> 相比于 <code>AlertDialog</code> 少了 <code>content</code> 和 <code>action</code> 参数，多了 <code>children</code> 属性，需要传入 <code>Widget</code> 列表，那就可以自定义全部内容了。那我们这里就实现一个性别选择的 <code>Dialog</code>，选择后通过 <code>Taost</code> 提示选择的内容，<code>Taost</code> 就是之前导入的第三方插件，先看下效果图吧</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-a9dd6de23478249e.gif" alt=""></p><p>只要实现 <code>children</code> 是个列表选择器就可以了，比较简单，直接上代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showSimpleDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt; SimpleDialog(</span><br><span class="line">              title: Text(<span class="string">'我是个比较正经的标题...\n选择你的性别'</span>),</span><br><span class="line">              <span class="comment">// 这里传入一个选择器列表即可</span></span><br><span class="line">              children: _genders</span><br><span class="line">                  .map((gender) =&gt; InkWell(</span><br><span class="line">                        child: Container(height: <span class="number">40.0</span>, child: Text(gender), alignment: Alignment.center),</span><br><span class="line">                        onTap: () &#123;</span><br><span class="line">                          Navigator.pop(context);</span><br><span class="line">                          Fluttertoast.showToast(msg: <span class="string">'你选择的性别是 $gender'</span>);</span><br><span class="line">                        &#125;,</span><br><span class="line">                      ))</span><br><span class="line">                  .toList(),</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="AboutDialog"><a href="#AboutDialog" class="headerlink" title="AboutDialog"></a>AboutDialog</h5><p><code>AboutDialog</code> 主要是用于展示你的 <code>App</code> 或者别的相关东西的内容信息的，平时用的比较少，显示 <code>AboutDialog</code> 有两种方式可以展示，一种是前面一样的 <code>showDialog</code> 方法，传入一个 <code>AboutDialog</code> 实例，还有中方法是直接调用 <code>showAboutDialog</code> 方法。我们还是一样在列表加个按钮，并指向显示 <code>AboutDialog</code> 的事件。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showAboutDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt; AboutDialog(</span><br><span class="line">              <span class="comment">// App 的名字</span></span><br><span class="line">              applicationName: <span class="string">'Flutter 入门指北'</span>,</span><br><span class="line">              <span class="comment">// App 的版本号</span></span><br><span class="line">              applicationVersion: <span class="string">'0.1.1'</span>,</span><br><span class="line">              <span class="comment">// App 基本信息下面会显示一行小字，主要用来显示版权信息</span></span><br><span class="line">              applicationLegalese: <span class="string">'Copyright: this is a copyright notice topically'</span>,</span><br><span class="line">              <span class="comment">// App 的图标</span></span><br><span class="line">              applicationIcon: Icon(Icons.android, size: <span class="number">28.0</span>, color: CupertinoColors.activeBlue),</span><br><span class="line">              <span class="comment">// 任何你想展示的</span></span><br><span class="line">              children: &lt;Widget&gt;[Text(<span class="string">'我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)'</span>)],</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也可以通过 <code>showAboutDialog</code> 实现同样的效果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showAboutDialog() &#123;</span><br><span class="line">  showAboutDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    applicationName: <span class="string">'Flutter 入门指北'</span>,</span><br><span class="line">    applicationVersion: <span class="string">'0.1.1'</span>,</span><br><span class="line">    applicationLegalese: <span class="string">'Copyright: this is a copyright notice topically'</span>,</span><br><span class="line">    applicationIcon: Image.asset(<span class="string">'images/app_icon.png'</span>, width: <span class="number">40.0</span>, height: <span class="number">40.0</span>),</span><br><span class="line">    children: &lt;Widget&gt;[Text(<span class="string">'我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)'</span>)],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-692a6d8b1b1b2ad1.gif" alt=""></p><p><code>AboutDialog</code> 会自带两个按钮 <code>VIEW LICENSES</code> 和 <code>CLOSE</code>，<code>VIEW LICENSES</code> 会跳转一个 <code>Flutter Licenses</code> 的网页，<code>CLOSE</code> 会关闭，至于为什么是英文的，是因为我们没有设置语言的原因，这个涉及到多语言，这边推荐几篇之前看过的文章，如果下次有时间的话会单独拿出来讲下</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.didierboelens.com%2F2018%2F04%2Finternationalization---make-an-flutter-application-multi-lingual%2F" target="_blank" rel="noopener">英文原版多语言设置，介绍两种方式实现</a></p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fyumi0629%2Farticle%2Fdetails%2F81873141" target="_blank" rel="noopener">国人翻译版，未持续更新第二种方式</a></p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5c701379f265da2d9b5e196a" target="_blank" rel="noopener">使用插件 in18 版</a></p><p>这边为了支持中文，我们做下如下的修改，首先打开 <code>pubspec.ymal</code> 文件加入如下支持</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522113832.png" alt=""></p><p><code>get package</code> 后给 <code>MaterialApp</code> 加入如下属性，这样就会支持中文了，这里需要导入包 <code>package:flutter_localizations/flutter_localizations.dart</code>，再次运行，就会发现之前的英文变成中文了，当然你也可以设置成别的语言。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522113849.png" alt=""></p><h4 id="Dialog-状态保持"><a href="#Dialog-状态保持" class="headerlink" title="Dialog 状态保持"></a>Dialog 状态保持</h4><p>假如有个需求，需要在弹出的 <code>Dialog</code> 显示当前被改变的值，然后通过按钮可以修改这个值 ，该如何实现。相信很多小伙伴都会这么认为，通过 <code>setState</code> 来修改不就行了吗，没错，我一开始的确这么去实现的，我们先看下代码好了，增加一个 <code>DialogState</code> 按钮，然后指向对应的点击事件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_showStateDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        context: context,</span><br><span class="line">        barrierDismissible: false,</span><br><span class="line">        builder: (context) =&gt; SimpleDialog(</span><br><span class="line">              title: Text(&apos;我这边能实时修改状态值&apos;),</span><br><span class="line">              contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Text(&apos;当前的值是： $_count&apos;, style: TextStyle(fontSize: 18.0)),</span><br><span class="line">                Padding(</span><br><span class="line">                  padding: const EdgeInsets.symmetric(vertical: 12.0),</span><br><span class="line">                  child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                      onPressed: increase,</span><br><span class="line">                      child: Text(&apos;点我自增&apos;),</span><br><span class="line">                    ),</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                      onPressed: decrease,</span><br><span class="line">                      child: Text(&apos;点我自减&apos;),</span><br><span class="line">                    ),</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                      onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                      child: Text(&apos;点我关闭&apos;),</span><br><span class="line">                    )</span><br><span class="line">                  ]),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后我们运行看下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-b90b21ff3cca2241.gif" alt=""></p><p>诶诶诶，怎么 <code>Dialog</code> 的值不改变呢，明明界面上的已经修改了啊。所以说图样图森破咯，看下官方对 <code>showDialog</code> 方法的解释吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This function takes a `builder` which typically builds a [Dialog] widget.</span></span><br><span class="line"><span class="comment">// Content below the dialog is dimmed with a [ModalBarrier]. The widget</span></span><br><span class="line"><span class="comment">// returned by the `builder` does not share a context with the location that</span></span><br><span class="line"><span class="comment">// `showDialog` is originally called from. Use a [StatefulBuilder] or a</span></span><br><span class="line"><span class="comment">// custom [StatefulWidget] if the dialog needs to update dynamically.</span></span><br></pre></td></tr></table></figure><p>糟糕透的翻译又来了：该方法通过 <code>builder</code> 参数来传入一个 <code>Dialog</code> 部件，<code>dialog</code> 下的内容被一个「模态障碍」阻隔，<code>builder</code> 的 <code>context</code> 和调用 <code>showDialog</code> 时候的 <code>context</code> 不是共享的，如果需要动态修改 <code>dialog</code> 的状态值，需要通过 <code>StatefulBuilder</code> 或者自定义 <code>dialog</code> 继承于 <code>StatefulWidget</code> 来实现</p><p>所以解决的方法很明确，对上面的代码进行修改，在外层嵌套一个 <code>StatefulBuilder</code> 部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showStateDialog() &#123;</span><br><span class="line">   showDialog(</span><br><span class="line">       context: context,</span><br><span class="line">       barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">       <span class="comment">// 通过 StatefulBuilder 来保存 dialog 状态</span></span><br><span class="line">       <span class="comment">// builder 需要传入一个 BuildContext 和 StateSetter 类型参数</span></span><br><span class="line">       <span class="comment">// StateSetter 有一个 VoidCallback，修改状态的方法在这写</span></span><br><span class="line">       builder: (context) =&gt; StatefulBuilder(</span><br><span class="line">           builder: (context, dialogStateState) =&gt; SimpleDialog(</span><br><span class="line">                 title: Text(<span class="string">'我这边能实时修改状态值'</span>),</span><br><span class="line">                 contentPadding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">8.0</span>),</span><br><span class="line">                 children: &lt;Widget&gt;[</span><br><span class="line">                   Text(<span class="string">'当前的值是： $_count'</span>, style: TextStyle(fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                   Padding(</span><br><span class="line">                     padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">12.0</span>),</span><br><span class="line">                     child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[</span><br><span class="line">                       RaisedButton(</span><br><span class="line">                         <span class="comment">// 通过 StatefulBuilder 的 StateSetter 来修改值</span></span><br><span class="line">                         onPressed: () =&gt; dialogStateState(() =&gt; increase()),</span><br><span class="line">                         child: Text(<span class="string">'点我自增'</span>),</span><br><span class="line">                       ),</span><br><span class="line">                       RaisedButton(</span><br><span class="line">                         onPressed: () =&gt; dialogStateState(() =&gt; decrease()),</span><br><span class="line">                         child: Text(<span class="string">'点我自减'</span>),</span><br><span class="line">                       ),</span><br><span class="line">                       RaisedButton(</span><br><span class="line">                         onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                         child: Text(<span class="string">'点我关闭'</span>),</span><br><span class="line">                       )</span><br><span class="line">                     ]),</span><br><span class="line">                   )</span><br><span class="line">                 ],</span><br><span class="line">               )));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后再运行下，可以看到 <code>dialog</code> 和界面的值保持一致了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-fe488a85d5276b4c.gif" alt=""></p><p><em>以上部分代码查看 prompt_main.dart 文件</em></p><p>差不多常用弹窗和操作提示就在这了，好好消化吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的小节把常用的一些部件都介绍了，这节介绍下 &lt;code&gt;Flutter&lt;/code&gt; 中的一些操作提示。&lt;code&gt;Flutter&lt;/code&gt; 中的操作提示主要有这么几种 &lt;code&gt;SnackBar&lt;/code&gt;、&lt;code&gt;BottomSheet&lt;/code&gt;、&lt;code&gt;Dialog&lt;/code&gt;，因为 &lt;code&gt;Dialog&lt;/code&gt; 样式比较多，放最后讲好了&lt;/p&gt;
&lt;h4 id=&quot;SnackBar&quot;&gt;&lt;a href=&quot;#SnackBar&quot; class=&quot;headerlink&quot; title=&quot;SnackBar&quot;&gt;&lt;/a&gt;SnackBar&lt;/h4&gt;&lt;p&gt;&lt;code&gt;SnackBar&lt;/code&gt; 的源码相对简单&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SnackBar(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@required&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.content, &lt;span class=&quot;comment&quot;&gt;// 提示信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.backgroundColor, &lt;span class=&quot;comment&quot;&gt;// 背景色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.action, &lt;span class=&quot;comment&quot;&gt;// SnackBar 尾部的按钮，用于一些回退操作等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.duration = _kSnackBarDisplayDuration, &lt;span class=&quot;comment&quot;&gt;// 停留的时长，默认 4000ms&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.animation, &lt;span class=&quot;comment&quot;&gt;// 进出动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(八)之Sliver组件及NestedScrollView</title>
    <link href="http://yoursite.com/posts/f600e8a7.html"/>
    <id>http://yoursite.com/posts/f600e8a7.html</id>
    <published>2019-04-26T02:57:48.000Z</published>
    <updated>2019-05-27T07:03:44.066Z</updated>
    
    <content type="html"><![CDATA[<p>上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去</p><p>在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。</p><h3 id="SliverAppBar"><a href="#SliverAppBar" class="headerlink" title="SliverAppBar"></a>SliverAppBar</h3><p>相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverAppBar(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.leading,</span><br><span class="line"><span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">this</span>.title,</span><br><span class="line"><span class="keyword">this</span>.actions,</span><br><span class="line"><span class="keyword">this</span>.flexibleSpace, <span class="comment">// 通过这个来设置背景</span></span><br><span class="line"><span class="keyword">this</span>.bottom,</span><br><span class="line"><span class="keyword">this</span>.elevation,</span><br><span class="line"><span class="keyword">this</span>.forceElevated = <span class="keyword">false</span>, <span class="comment">// 是否显示层次感</span></span><br><span class="line"><span class="keyword">this</span>.backgroundColor,</span><br><span class="line"><span class="keyword">this</span>.brightness,</span><br><span class="line"><span class="keyword">this</span>.iconTheme,</span><br><span class="line"><span class="keyword">this</span>.textTheme,</span><br><span class="line"><span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">this</span>.centerTitle,</span><br><span class="line"><span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line"><span class="keyword">this</span>.expandedHeight, <span class="comment">// 展开的高度</span></span><br><span class="line"><span class="comment">// 以下三个等例子再讲</span></span><br><span class="line"><span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span><br><span class="line"><span class="keyword">this</span>.pinned = <span class="keyword">false</span>,</span><br><span class="line"><span class="keyword">this</span>.snap = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件</p><a id="more"></a><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: CustomScrollView(slivers: &lt;Widget&gt;[</span><br><span class="line">SliverAppBar(</span><br><span class="line">title: Text(<span class="string">'Sliver Demo'</span>),</span><br><span class="line">centerTitle: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 展开的高度</span></span><br><span class="line">expandedHeight: <span class="number">300.0</span>,</span><br><span class="line"><span class="comment">// 强制显示阴影</span></span><br><span class="line">forceElevated: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 设置该属性，当有下滑手势的时候，就会显示 AppBar</span></span><br><span class="line"><span class="comment">// floating: true,</span></span><br><span class="line"><span class="comment">// 该属性只有在 floating 为 true 的情况下使用，不然会报错</span></span><br><span class="line"><span class="comment">// 当上滑到一定的比例，会自动把 AppBar 收缩（不知道是不是 bug，当 AppBar 下面的部件没有被 AppBar 覆盖的时候，不会自动收缩）</span></span><br><span class="line"><span class="comment">// 当下滑到一定比例，会自动把 AppBar 展开</span></span><br><span class="line"><span class="comment">// snap: true,</span></span><br><span class="line"><span class="comment">// 设置该属性使 Appbar 折叠后不消失</span></span><br><span class="line"><span class="comment">// pinned: true,</span></span><br><span class="line"><span class="comment">// 通过这个属性设置 AppBar 的背景</span></span><br><span class="line">flexibleSpace: FlexibleSpaceBar(</span><br><span class="line"><span class="comment">// title: Text('Expanded Title'),</span></span><br><span class="line"><span class="comment">// 背景折叠动画</span></span><br><span class="line">collapseMode: CollapseMode.parallax,</span><br><span class="line">background: Image.asset(<span class="string">'images/timg.jpg'</span>, fit: BoxFit.cover),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，</span></span><br><span class="line"><span class="comment">// 可以在 child 属性加入需要展示的部件</span></span><br><span class="line">SliverFillRemaining(</span><br><span class="line">child: Center(child: Text(<span class="string">'FillRemaining'</span>, style: TextStyle(fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br><span class="line">]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分别给出不同的动图来查看三个属性的影响</p><p>如果设置了 floating 属性，当有下拉动作时，会显示 AppBar</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/a2.gif" alt=""></p><p>如果设置了 snap 属性，滑动距离达到一定值后，会根据滑动方向收缩或者展开</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111020.gif" alt=""></p><p>如果设置了 pinned 属性，那么 AppBar 就会在界面上不会消失</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111101.gif" alt=""></p><p>以上的效果图把 SliverFillRemaining 换成列表 SliverFixedExtentList 效果可能会更加明显，这边给小伙伴自己替换测试吧。</p><h3 id="SliverFillViewport"><a href="#SliverFillViewport" class="headerlink" title="SliverFillViewport"></a>SliverFillViewport</h3><p>这边提到了 SliverFillRemaining 用来填充视图，那么顺带提下 SliverFillViewport 这个部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverFillViewport(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="meta">@required</span> SliverChildDelegate delegate, <span class="comment">// 这个 delegate 同 SliverGrid</span></span><br><span class="line"><span class="keyword">this</span>.viewportFraction = <span class="number">1.0</span>, <span class="comment">// 同屏幕的比例值，1.0 为一个屏幕大小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果一个滑动列表，每个 item 需要占满一个屏幕或者更大，可以使用该部件生成列表，但是如果 item 的高度小于一个屏幕高度，那就不太推荐了，在首尾会用空白 item 来把未填满的补上，就是首尾都会留空白。我们使用 SliverFillViewport 对 SliverFillRemaning 进行替换</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverFillViewport(</span><br><span class="line">viewportFraction: <span class="number">1.0</span>,</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Container(child: Text(<span class="string">'Item $index'</span>), alignment: Alignment.center, color: colors[index % <span class="number">4</span>]),</span><br><span class="line">childCount: <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>效果就不展示了，可自行运行查看。</p><h3 id="SliverToBoxAdapter"><a href="#SliverToBoxAdapter" class="headerlink" title="SliverToBoxAdapter"></a>SliverToBoxAdapter</h3><p>还记得上节最后的代码中，有使用 SliverToBoxAdapter 这个部件吗，这个部件只需要传入一个 child 属性。因为在 CustomScrollView 中只允许传入 Sliver 部件，那么类似 Container 等普通部件就不可以使用了，那么这样就需要更多的 Sliver 组件才能完成视图，所以为了方便，直接通过 SliverToBoxAdapter 对普通部件进行包裹，这样就成为一个 Sliver 部件了。总结下 SliverToBoxAdapter 的功能就是 把一个普通部件包裹成为 Sliver 部件，例子就不举了，上节已经有了。</p><h3 id="SliverPadding"><a href="#SliverPadding" class="headerlink" title="SliverPadding"></a>SliverPadding</h3><p>那么在 CustomScrollView 中部件之间如何设置间距呢，可能你会想到用 SliverToBoxAdapter 包裹一个 Padding 来处理，当然没问题。不过 Flutter 也提供了专门的部件 SliverPadding 使用方式同 Padding，但是需要传入一个 sliver 作为子类。</p><h3 id="SliverPersistentHeader"><a href="#SliverPersistentHeader" class="headerlink" title="SliverPersistentHeader"></a>SliverPersistentHeader</h3><p>Flutter 中，为我们提供了这么一个作为头部的部件 SliverPersistentHeader，这个部件可以根据滚动的距离缩小高度，有点类似 SliverAppBar 的背景效果。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverPersistentHeader(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="meta">@required</span> <span class="keyword">this</span>.delegate, <span class="comment">// SliverPersistentHeaderDelegate，用来创建展示内容</span></span><br><span class="line"><span class="keyword">this</span>.pinned = <span class="keyword">false</span>, <span class="comment">// 同 SliverAppBar 属性</span></span><br><span class="line"><span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="SliverPersistentHeaderDelegate"><a href="#SliverPersistentHeaderDelegate" class="headerlink" title="SliverPersistentHeaderDelegate"></a>SliverPersistentHeaderDelegate</h3><p>这个代理比较特殊，是个抽象类，也就是需要我们自己进行继承后再实现方法。SliverPersistentHeaderDelegate 需要提供一个最大值，最小值，展示内容，以及更新部件条件</p><p>比如我们需要展示一个最大高度 300，最小高度 100，居中的文字，那么我们可以这么写这个代理类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoHeader</span> <span class="keyword">extends</span> <span class="title">SliverPersistentHeaderDelegate</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context, <span class="built_in">double</span> shrinkOffset, <span class="built_in">bool</span> overlapsContent) &#123;</span><br><span class="line"><span class="keyword">return</span> Container(</span><br><span class="line">color: Colors.pink,</span><br><span class="line">alignment: Alignment.center,</span><br><span class="line">child: Text(<span class="string">'我是一个头部部件'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)));</span><br><span class="line">&#125; <span class="comment">// 头部展示内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> maxExtent =&gt; <span class="number">300.0</span>; <span class="comment">// 最大高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> minExtent =&gt; <span class="number">100.0</span>; <span class="comment">// 最小高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) =&gt; <span class="keyword">false</span>; <span class="comment">// 因为所有的内容都是固定的，所以不需要更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 SliverPersistentHeader 代替 SliverAppBar，看下效果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: CustomScrollView(slivers: &lt;Widget&gt;[</span><br><span class="line">SliverPersistentHeader(delegate: DemoHeader(), pinned: <span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，</span></span><br><span class="line"><span class="comment">// 可以在 child 属性加入需要展示的部件</span></span><br><span class="line">SliverFillRemaining(</span><br><span class="line">child: Center(child: Text(<span class="string">'FillRemaining'</span>, style: TextStyle(fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br><span class="line">]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/201905221400.gif" alt=""></p><p>当然，为了方便扩展，需要重新封装下 Delegate ，通过外部传入范围和展示内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 SliverPersistentHeaderDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSliverPersistentHeaderDelegate</span> <span class="keyword">extends</span> <span class="title">SliverPersistentHeaderDelegate</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> max; <span class="comment">// 最大高度</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> min; <span class="comment">// 最小高度</span></span><br><span class="line"><span class="keyword">final</span> Widget child; <span class="comment">// 需要展示的内容</span></span><br><span class="line"></span><br><span class="line">CustomSliverPersistentHeaderDelegate(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.max, <span class="meta">@required</span> <span class="keyword">this</span>.min, <span class="meta">@required</span> <span class="keyword">this</span>.child&#125;)</span><br><span class="line"><span class="comment">// 如果 assert 内部条件不成立，会报错</span></span><br><span class="line">: <span class="keyword">assert</span>(max != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(min != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(min &lt;= max),</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回展示的内容，如果内容固定可以直接在这定义，如果需要可扩展，这边通过传入值来定义</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context, <span class="built_in">double</span> shrinkOffset, <span class="built_in">bool</span> overlapsContent) =&gt; child;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> maxExtent =&gt; max; <span class="comment">// 返回最大高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> minExtent =&gt; min; <span class="comment">// 返回最小高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> shouldRebuild(CustomSliverPersistentHeaderDelegate oldDelegate) &#123;</span><br><span class="line"><span class="comment">// 是否需要更新，这里我们定义当高度范围和展示内容被替换的时候进行刷新界面</span></span><br><span class="line"><span class="keyword">return</span> max != oldDelegate.max || min != oldDelegate.min || child != oldDelegate.child;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以愉快的使用了，不需要每个 Delegate 都重新写一遍，例如替换下刚才写死的 DemoHeader</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverPersistentHeader(</span><br><span class="line"><span class="comment">// 属性同 SliverAppBar</span></span><br><span class="line">pinned: <span class="keyword">true</span>,</span><br><span class="line">floating: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 因为 SliverPersistentHeaderDelegate 是一个抽象类，所以需要自定义</span></span><br><span class="line">delegate: CustomSliverPersistentHeaderDelegate(</span><br><span class="line">max: <span class="number">300.0</span>, min: <span class="number">100.0</span>, child: Text(<span class="string">'我是一个头部部件'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>例如需要替换成一张图片，直接将 Text 修改成 Image 即可。</p><p>以上部分代码查看 sliver_main.dart 文件</p><h3 id="NestedScrollView"><a href="#NestedScrollView" class="headerlink" title="NestedScrollView"></a>NestedScrollView</h3><p>讲到这了，不得不提下 Scrollable 中比较重要的一员 NestedScrollView，先看下官方的解释</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A scrolling view inside of which can be nested other scrolling views, with</span></span><br><span class="line"><span class="comment">/// their scroll positions being intrinsically linked.</span></span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 1：一个内部能够嵌套其他滚动部件，并使其滚动位置联结到一起的滚动部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The most common use case for this widget is a scrollable view with a</span></span><br><span class="line"><span class="comment">/// flexible [SliverAppBar] containing a [TabBar] in the header (build by</span></span><br><span class="line"><span class="comment">/// [headerSliverBuilder], and with a [TabBarView] in the [body], such that the</span></span><br><span class="line"><span class="comment">/// scrollable view's contents vary based on which tab is visible.</span></span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 2：最常用的情况，就是在其 headerSliverBuilder 中使用携带 TabBar 的 SliverAppBar（就是使用 SliverAppBar 的 bottom 属性添加 tab 切换也），其 body 属性使用 TabBarView 来展示 Tab 页的内容，这样通过切换 Tab 页就能展示该页下的展示内容。</p><p>看下 headerSliverBuilder 的定义</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Signature used by [NestedScrollView] for building its header.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The `innerBoxIsScrolled` argument is typically used to control the</span></span><br><span class="line"><span class="comment">/// [SliverAppBar.forceElevated] property to ensure that the app bar shows a</span></span><br><span class="line"><span class="comment">/// shadow, since it would otherwise not necessarily be aware that it had</span></span><br><span class="line"><span class="comment">/// content ostensibly below it.</span></span><br><span class="line"><span class="keyword">typedef</span> NestedScrollViewHeaderSliversBuilder = <span class="built_in">List</span>&lt;Widget&gt; <span class="built_in">Function</span>(BuildContext context, <span class="built_in">bool</span> innerBoxIsScrolled);</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 3：用于构建 NestScrollView 的头部部件，innerBoxIsScrolled 主要用来控制 SliverAppBar 的 forceElevated 属性，当内部内容滚动时，显示 SliverAppbar 的阴影，主要用来提醒内部的内容低于 SliverAppBar （相当于给人一种物理层次感，否则很容易被认为，头部和内容是连接在一起的）</p><p>接下来看下 NestedScrollView 内部个人觉得有点重要的一个方法 sliverOverlapAbsorberHandleFor</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Returns the [SliverOverlapAbsorberHandle] of the nearest ancestor</span></span><br><span class="line"><span class="comment">/// [NestedScrollView].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is necessary to configure the [SliverOverlapAbsorber] and</span></span><br><span class="line"><span class="comment">/// [SliverOverlapInjector] widgets.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// For sample code showing how to use this method, see the [NestedScrollView]</span></span><br><span class="line"><span class="comment">/// documentation.</span></span><br><span class="line"><span class="keyword">static</span> SliverOverlapAbsorberHandle sliverOverlapAbsorberHandleFor(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> _InheritedNestedScrollView target = context.inheritFromWidgetOfExactType(_InheritedNestedScrollView);</span><br><span class="line">  <span class="keyword">assert</span>(target != <span class="keyword">null</span>, <span class="string">'NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.'</span>);</span><br><span class="line">  <span class="keyword">return</span> target.state._absorberHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意到中间的注释</p><p>糟透了的翻译 X 4：这个方法返回的值对于 SliverOverlapAbsorber 和 SliverOverlapInjector 部件是非常重要的参数</p><p>接着请注意代码中的那段 assert 中的文字</p><p>糟透了的翻译 X 5：sliverOverlapAbsorberHandleFor 传入的参数 context 中必须包含 NestedScrollView</p><h3 id="SliverOverlapAbsorber"><a href="#SliverOverlapAbsorber" class="headerlink" title="SliverOverlapAbsorber"></a>SliverOverlapAbsorber</h3><p>这边又引入了两个部件 SliverOverlapAbsorber + SliverOverlapInjector 还是看源码的解释吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Creates a sliver that absorbs overlap and reports it to a</span></span><br><span class="line"><span class="comment">/// [SliverOverlapAbsorberHandle].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [handle] must not be null.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [child] must be a sliver.</span></span><br><span class="line"><span class="keyword">const</span> SliverOverlapAbsorber(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.handle,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 6：一个 sliver 部件，用于把部件重叠的高度反馈给 SliverOverlapAbsorberHandle，而且指明了 handle 不能空，可以通过 NestedScrollView 的 sliverOverlapAbsorberHandleFor 方法来赋值，并且 child 必须是个 sliver 部件，也就是说我们的 SliverAppBar 需要放到 SliverOverlapAbsorber 里面。</p><h3 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Creates a sliver that is as tall as the value of the given [handle]'s</span></span><br><span class="line"><span class="comment">/// layout extent.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [handle] must not be null.</span></span><br><span class="line"><span class="keyword">const</span> SliverOverlapInjector(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.handle,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 7：创建一个和指定的 handle 一样高度的 sliver 部件，这个 handle 同 SliverOverlapAbsorber 的 handle 保持一致即可。</p><p>分析完源码后，例子的目标很明确，使用 SliverAppBar + TabBar + TabBarView，先看下最后的效果图吧</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111721.gif" alt=""></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> _tabs = &lt;<span class="built_in">String</span>&gt;[<span class="string">'TabA'</span>, <span class="string">'TabB'</span>];</span><br><span class="line"><span class="keyword">final</span> colors = &lt;Color&gt;[Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: DefaultTabController(</span><br><span class="line">length: _tabs.length,</span><br><span class="line">child: NestedScrollView(</span><br><span class="line">headerSliverBuilder: (context, innerScrolled) =&gt; &lt;Widget&gt;[</span><br><span class="line">SliverOverlapAbsorber(</span><br><span class="line"><span class="comment">// 传入 handle 值，直接通过 `sliverOverlapAbsorberHandleFor` 获取即可</span></span><br><span class="line">handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),</span><br><span class="line">child: SliverAppBar(</span><br><span class="line">pinned: <span class="keyword">true</span>,</span><br><span class="line">title: Text(<span class="string">'NestedScroll Demo'</span>),</span><br><span class="line">expandedHeight: <span class="number">200.0</span>,</span><br><span class="line">flexibleSpace: FlexibleSpaceBar(background: Image.asset(<span class="string">'images/timg.jpg'</span>, fit: BoxFit.cover)),</span><br><span class="line">bottom: TabBar(tabs: _tabs.map((tab) =&gt; Text(tab, style: TextStyle(fontSize: <span class="number">18.0</span>))).toList()),</span><br><span class="line">forceElevated: innerScrolled,</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">],</span><br><span class="line">body: TabBarView(</span><br><span class="line">children: _tabs</span><br><span class="line"><span class="comment">// 这边需要通过 Builder 来创建 TabBarView 的内容，否则会报错</span></span><br><span class="line"><span class="comment">// NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.</span></span><br><span class="line">.map((tab) =&gt; Builder(</span><br><span class="line">builder: (context) =&gt; CustomScrollView(</span><br><span class="line"><span class="comment">// key 保证唯一性</span></span><br><span class="line">key: PageStorageKey&lt;<span class="built_in">String</span>&gt;(tab),</span><br><span class="line">slivers: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">// 将子部件同 `SliverAppBar` 重叠部分顶出来，否则会被遮挡</span></span><br><span class="line">SliverOverlapInjector(</span><br><span class="line">handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),</span><br><span class="line">SliverGrid(</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Image.asset(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">childCount: <span class="number">8</span>),</span><br><span class="line">gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">crossAxisCount: <span class="number">4</span>, mainAxisSpacing: <span class="number">10.0</span>, crossAxisSpacing: <span class="number">10.0</span>)),</span><br><span class="line">SliverFixedExtentList(</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Container(</span><br><span class="line">child: Text(<span class="string">'$tab - item<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>,</span><br><span class="line">style: TextStyle(fontSize: <span class="number">20.0</span>, color: colors[index % <span class="number">6</span>])),</span><br><span class="line">alignment: Alignment.center),</span><br><span class="line">childCount: <span class="number">15</span>),</span><br><span class="line">itemExtent: <span class="number">50.0</span>)</span><br><span class="line">],</span><br><span class="line">),</span><br><span class="line">))</span><br><span class="line">.toList()))),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的部件和之前讲的没啥大区别，就是多了 SliverOverlapAbsorber 和 SliverOverlapInjector 没啥难度</p><p>以上部分代码查看 nested_scroll_main.dart 文件</p><p>sliver 部件常用的也就那么多了，望小伙伴好好吸收，跟着例子撸撸代码，撸顺下思路</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去&lt;/p&gt;
&lt;p&gt;在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。&lt;/p&gt;
&lt;h3 id=&quot;SliverAppBar&quot;&gt;&lt;a href=&quot;#SliverAppBar&quot; class=&quot;headerlink&quot; title=&quot;SliverAppBar&quot;&gt;&lt;/a&gt;SliverAppBar&lt;/h3&gt;&lt;p&gt;相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SliverAppBar(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.leading,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.automaticallyImplyLeading = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.title,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.actions,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.flexibleSpace, &lt;span class=&quot;comment&quot;&gt;// 通过这个来设置背景&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bottom,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.elevation,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.forceElevated = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 是否显示层次感&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.backgroundColor,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.brightness,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.iconTheme,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textTheme,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.primary = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.centerTitle,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.titleSpacing = NavigationToolbar.kMiddleSpacing,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.expandedHeight, &lt;span class=&quot;comment&quot;&gt;// 展开的高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下三个等例子再讲&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.floating = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.pinned = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.snap = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(七)之滑动部件</title>
    <link href="http://yoursite.com/posts/8d9ab46a.html"/>
    <id>http://yoursite.com/posts/8d9ab46a.html</id>
    <published>2019-04-26T02:37:07.000Z</published>
    <updated>2019-05-27T07:03:39.686Z</updated>
    
    <content type="html"><![CDATA[<p>前面的小节基本上讲完了常用的部件和容器部件，也可以完成很多的界面，但是又一个问题，假如我们要显示一段文字，比如将 一段又臭又长的文字 在界面上显示 1000 次，不难完成吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..省略一些无关代码</span></span><br><span class="line">body: Text(<span class="string">'一段又臭又长的文字'</span> * <span class="number">1000</span>, softWrap: <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>很简单，运行到手机…「诶诶诶，**，怎么只显示了一部分，剩下的怎么画不下去」</p><p>日常开发中，会遇到很多这种情况，许多界面不是一页就能够显示完的。那么这里提下可滑动的容器部件</p><a id="more"></a><h3 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h3><p>这个部件非常简单，不贴源码了。最简单的使用方式只需要提供一个 child 即可。现在给前面写的 Text 包裹上一层 SingleChildScrollView 然后再运行，文字全部都展示出来了。</p><p>如果需要实现一个垂直的滚动列表，可以直接通过 SingleChildScrollView 包裹 Column 来实现，列表内容全部塞到 Column 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildScrollDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">/// letters 自由发挥吧...一定要大量，大量，大量</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; letters = [......];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Single Child Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: SingleChildScrollView(</span><br><span class="line">          child: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          children: <span class="built_in">List</span>.generate(</span><br><span class="line">              letters.length,</span><br><span class="line">              (index) =&gt; Padding(</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>),</span><br><span class="line">                    child: Text(letters[index], style: TextStyle(fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                  )),</span><br><span class="line">        ),</span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果会根据你的 letters 不同而不同，这边就不贴效果图了，反正你可以看到一串列表…</p><p>那么如果需要实现横向滚动列表呢，稍稍做下修改就行了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body: SingleChildScrollView(</span><br><span class="line">    <span class="comment">// 设置滚动方向</span></span><br><span class="line">    scrollDirection: Axis.horizontal,</span><br><span class="line">    child: Center(</span><br><span class="line">      <span class="comment">// 修改为 `Row` 即可</span></span><br><span class="line">      child: Row(</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            letters.length,</span><br><span class="line">            <span class="comment">// 如果你的 letters 数量比较少，推荐加个 `Container` 把宽度指定大点</span></span><br><span class="line">            (index) =&gt; Container(</span><br><span class="line">                child: Padding(</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>, horizontal: <span class="number">6.0</span>),</span><br><span class="line">                    child: Text(letters[index], style: TextStyle(fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                    ),</span><br><span class="line">                    width: <span class="number">30.0</span>)),</span><br><span class="line">      ),</span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><p>效果图也不贴了，都比较简单。</p><p>该部分代码查看 single_child_scroll_main.dart 文件*</p><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p>平时开发 Android 的时候，如果有相同格式的列表要实现，一般会使用 ListView 或者 RecyclerView 来实现，Flutter 也提供了类似的部件 ListView</p><p>实现 ListView 的方法主要有</p><ul><li><p>通过 ListView 设置 children 属性实现</p></li><li><p>通过 ListView.custom 实现</p></li><li><p>通过 ListView.builder 实现</p></li><li><p>通过 ListView.separated 实现带分割线列表</p></li></ul><h4 id="ListView-children"><a href="#ListView-children" class="headerlink" title="ListView children"></a>ListView children</h4><p>第一种方法实现列表，和通过 SingleChildScrollView + Column / Row 的方法比较类似，不过可以直接通过指定 ListView 的 scrollDirection 就可以了。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: ListView(</span><br><span class="line">    <span class="comment">// 通过修改滑动方向设置水平或者垂直方向滚动</span></span><br><span class="line">    scrollDirection: Axis.vertical,</span><br><span class="line">    <span class="comment">// 通过 iterable.map().toList 和 List.generate 方法效果是一样的</span></span><br><span class="line">    children: letters</span><br><span class="line">        .map((s) =&gt;</span><br><span class="line">        Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">            child: Center(</span><br><span class="line">                child: Text(s))))</span><br><span class="line">        .toList()),</span><br></pre></td></tr></table></figure><h4 id="ListView-custom"><a href="#ListView-custom" class="headerlink" title="ListView.custom"></a>ListView.custom</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body: ListView.custom(</span><br><span class="line">    <span class="comment">// 指定 item 的高度，可以加快渲染的速度</span></span><br><span class="line">    itemExtent: <span class="number">40.0</span>,</span><br><span class="line">    <span class="comment">// item 代理</span></span><br><span class="line">    childrenDelegate: SliverChildBuilderDelegate(</span><br><span class="line">      <span class="comment">// IndexedWidgetBuilder，根据 index 设置 item 中需要变化的数据</span></span><br><span class="line">      (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.red))),</span><br><span class="line">      <span class="comment">// 指定 item 的数量</span></span><br><span class="line">      childCount: letters.length,</span><br><span class="line">    )),</span><br></pre></td></tr></table></figure><p>如果每个 item 的高度可以确定，那么推荐通过 itemExtent 来设置 item 的高度/宽度，能够加快 ListView 的渲染速度。如果不指定高度/宽度，ListView 需要根据每个 item 来计算 ListView 的高度，这个计算过程是需要消耗时间和资源的</p><h4 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder"></a>ListView.builder</h4><p>该方法同 custom 类似，custom 需要通过一个 Delegate 生成 item，该方法直接通过 builder 生成，同时也可以直接指定 item 的高度</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: ListView.builder(</span><br><span class="line">    itemBuilder: (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.green))),</span><br><span class="line">    itemExtent: <span class="number">40.0</span>,</span><br><span class="line">    itemCount: letters.length),</span><br><span class="line">)),</span><br></pre></td></tr></table></figure><p>相对比较简单，代码也比较少…就冲这点，我也愿意用这个方法</p><h4 id="ListView-separated"><a href="#ListView-separated" class="headerlink" title="ListView.separated"></a>ListView.separated</h4><p>如果需要在每个 item 之间添加分割线，那么通过以上的方式实现就比较困难了，所以 Flutter 提供了 separated 方法用来快速构建带有分割线的 ListView</p><p>加入我们的 item 之间的分割线需要如下样式：奇数位和偶数位之间用黑色分割线，偶数位和奇数位之间用红色分割线</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要分割线的时候才使用，不能指定 item 的高度</span></span><br><span class="line">body: ListView.separated(</span><br><span class="line">    itemBuilder: (_, index) =&gt; Padding(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">20.0</span>),</span><br><span class="line">        child: Center(child: Text(letters[index], style: TextStyle(color: Colors.blue))),</span><br><span class="line">      ),</span><br><span class="line">    <span class="comment">// 这里用来定义分割线</span></span><br><span class="line">    separatorBuilder: (_, index) =&gt; Divider(height: <span class="number">1.0</span>, color: index % <span class="number">2</span> == <span class="number">0</span> ? Colors.black : Colors.red),</span><br><span class="line">    itemCount: letters.length),</span><br></pre></td></tr></table></figure><p>最终的效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522104259.png" alt=""></p><p>以上代码查看 listview_main.dart 文件</p><p>总结下：如果 item 的高度能够准确获取，一定要指定 itemExtent 的值，这样会更加高效，至于要通过哪种方式来生成，完全看个人喜好吧。</p><h3 id="ExpansionTile"><a href="#ExpansionTile" class="headerlink" title="ExpansionTile"></a>ExpansionTile</h3><p>既然讲到了 ListView，在日常开发中，折叠列表也是一个比较常用的，所以这边要提下 ExpansionTile 这个部件，因为相对比较简单，所以直接上代码了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpansionTilesDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'ExpansionTile Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: ExpansionTile(</span><br><span class="line">        <span class="comment">// 最前面的 widget</span></span><br><span class="line">        leading: Icon(Icons.phone_android),</span><br><span class="line">        <span class="comment">// 替换默认箭头</span></span><br><span class="line"><span class="comment">//        trailing: Icon(Icons.phone_iphone),</span></span><br><span class="line">        title: Text(<span class="string">'Parent'</span>),</span><br><span class="line">        <span class="comment">// 默认是否展开</span></span><br><span class="line">        initiallyExpanded: <span class="keyword">true</span>,</span><br><span class="line">        <span class="comment">// 展开时候的背景色</span></span><br><span class="line">        backgroundColor: Colors.yellow[<span class="number">100</span>],</span><br><span class="line">        <span class="comment">// 展开或者收缩的回调，true 表示展开</span></span><br><span class="line">        onExpansionChanged: (expanded) =&gt; <span class="built_in">print</span>(<span class="string">'ExpansionTile is <span class="subst">$&#123;expanded ? <span class="string">'expanded'</span> : <span class="string">'collapsed'</span>&#125;</span>'</span>),</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">                (position) =&gt;</span><br><span class="line">                Container(</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">80.0</span>),</span><br><span class="line">                  child: Text(<span class="string">'Children <span class="subst">$&#123;position + <span class="number">1</span>&#125;</span>'</span>),</span><br><span class="line">                  height: <span class="number">50.0</span>,</span><br><span class="line">                  alignment: Alignment.centerLeft,</span><br><span class="line">                )),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了一个折叠部件，看下最后的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/640.gif" alt=""></p><p>那么实现折叠列表也就是通过 ListView 创建一个 ExpansionTile 列表即可，先准备下模拟的数据</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> _keys = [<span class="string">'ParentA'</span>, <span class="string">'ParentB'</span>, <span class="string">'ParentC'</span>, <span class="string">'ParentD'</span>, <span class="string">'ParentE'</span>, <span class="string">'ParentF'</span>];</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; _data = &#123;</span><br><span class="line">    <span class="string">'ParentA'</span>: [<span class="string">'Child A0'</span>, <span class="string">'Child A1'</span>, <span class="string">'Child A2'</span>, <span class="string">'Child A3'</span>, <span class="string">'Child A4'</span>, <span class="string">'Child A5'</span>],</span><br><span class="line">    <span class="string">'ParentB'</span>: [<span class="string">'Child B0'</span>, <span class="string">'Child B1'</span>, <span class="string">'Child B2'</span>, <span class="string">'Child B3'</span>, <span class="string">'Child B4'</span>, <span class="string">'Child B5'</span>],</span><br><span class="line">    <span class="string">'ParentC'</span>: [<span class="string">'Child C0'</span>, <span class="string">'Child C1'</span>, <span class="string">'Child C2'</span>, <span class="string">'Child C3'</span>, <span class="string">'Child C4'</span>, <span class="string">'Child C5'</span>],</span><br><span class="line">    <span class="string">'ParentD'</span>: [<span class="string">'Child D0'</span>, <span class="string">'Child D1'</span>, <span class="string">'Child D2'</span>, <span class="string">'Child D3'</span>, <span class="string">'Child D4'</span>, <span class="string">'Child D5'</span>],</span><br><span class="line">    <span class="string">'ParentE'</span>: [<span class="string">'Child E0'</span>, <span class="string">'Child E1'</span>, <span class="string">'Child E2'</span>, <span class="string">'Child E3'</span>, <span class="string">'Child E4'</span>, <span class="string">'Child E5'</span>],</span><br><span class="line">    <span class="string">'ParentF'</span>: [<span class="string">'Child F0'</span>, <span class="string">'Child F1'</span>, <span class="string">'Child F2'</span>, <span class="string">'Child F3'</span>, <span class="string">'Child F4'</span>, <span class="string">'Child F5'</span>]</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>在平时开发过程中，后台返回的数据应该是列表嵌套列表的形式比较多，我这边主要就是为了偷懒就随便弄了，接着修改下 body 的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: ListView(</span><br><span class="line">          children: _keys</span><br><span class="line">              .map((key) =&gt; ExpansionTile(</span><br><span class="line">                    title: Text(key),</span><br><span class="line">                    children: _data[key]</span><br><span class="line">                        .map((value) =&gt; InkWell(</span><br><span class="line">                            child: Container(</span><br><span class="line">                              child: Text(value),</span><br><span class="line">                              padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">80.0</span>),</span><br><span class="line">                              height: <span class="number">50.0</span>,</span><br><span class="line">                              alignment: Alignment.centerLeft,</span><br><span class="line">                            ),</span><br><span class="line">                            onTap: () &#123;&#125;))</span><br><span class="line">                        .toList(),</span><br><span class="line">                  ))</span><br><span class="line">              .toList()),</span><br></pre></td></tr></table></figure><p>最终的效果就是个折叠列表了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/1212.gif" alt=""></p><p>该部分代码查看 expansion_tile_main.dart 文件</p><p>当然了，只要数据到位，别说两层折叠，三层，四层甚至更多层都能够实现，源码中有实现四层的 demo，这边就不贴代码了，有需要的小伙伴可以查看源码</p><h3 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h3><p>生成列表可以通过 ListView 来实现，那么同样，实现网格列表 Flutter 也提供了 GridView 来实现，实现 GridView 的方法也很多…我数了下，大概有 10 种..对你没看错，就是那么多，(诶诶诶，别走啊…虽然方法有点多，但是，大同小异)</p><p>GridView</p><p>GridView 需要一个 gridDelegate，gridDelegate 目前有两种</p><p>SliverGridDelegateWithFixedCrossAxisCount 看命名就知道，值固定数量的，这个数量是只单排的数量</p><p>SliverGridDelegateWithMaxCrossAxisExtent 这个是设置最大宽度/高度，在这个值范围内取最大值，比如一排能给你排下 6 个，但是远不到设置的最大值，它绝不给你排 6 个</p><p>那么接下来的使用就比较简单了</p> <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GridViewDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 自行设置</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; letters = [ ..... ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于区分网格单元</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'GridView Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">        body: GridView(</span><br><span class="line">        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">            crossAxisCount: <span class="number">5</span>, <span class="comment">// 单行的个数</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10.0</span>, <span class="comment">// 同 scrollDirection 挂钩，item 之间在主轴方向的间隔</span></span><br><span class="line">            crossAxisSpacing: <span class="number">10.0</span>, <span class="comment">// item 之间在副轴方法的间隔</span></span><br><span class="line">            childAspectRatio: <span class="number">1.0</span> <span class="comment">// item 的宽高比</span></span><br><span class="line">            ),</span><br><span class="line">        <span class="comment">// 需要根据 index 设置不同背景色，所以使用 List.generate，如果不设置背景色，也可用 iterable.map().toList</span></span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            letters.length,</span><br><span class="line">            (index) =&gt; Container(</span><br><span class="line">                  alignment: Alignment.center,</span><br><span class="line">                  child: Text(letters[index]),</span><br><span class="line">                  color: colors[index % <span class="number">4</span>],</span><br><span class="line">                )),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键地方已经添加了注释，跑下运行效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522105021.png" alt=""></p><p>接下来换一种 delegate 试试效果，当然这个最大值可以根据个人喜好来设置</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: GridView(</span><br><span class="line">        <span class="comment">// 通过设置 `maxCrossAxisExtent` 来指定最大的宽度，在这个值范围内，会选取相对较大的值</span></span><br><span class="line">        gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(</span><br><span class="line">            maxCrossAxisExtent: <span class="number">60.0</span>, crossAxisSpacing: <span class="number">10.0</span>, mainAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            letters.length,</span><br><span class="line">            (index) =&gt; Container(</span><br><span class="line">                  alignment: Alignment.center,</span><br><span class="line">                  child: Text(letters[index]),</span><br><span class="line">                  color: colors[index % <span class="number">4</span>],</span><br><span class="line">                )),</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>最后效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522105054.png" alt=""></p><p>为了方便写法呢，Flutter 对以上的两种方式进行了封装，省略了 delegate</p><p><strong>GridView.count/GridView.extent</strong></p><p>直接看下如何修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithFixedCrossAxisCount` 代理的方法</span></span><br><span class="line">    body: GridView.count(</span><br><span class="line">          crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          childAspectRatio: <span class="number">1.0</span>,</span><br><span class="line">          crossAxisCount: <span class="number">5</span>,</span><br><span class="line">          childAspectRatio: <span class="number">2.0</span>,</span><br><span class="line">          children: <span class="built_in">List</span>.generate(</span><br><span class="line">              letters.length,</span><br><span class="line">              (index) =&gt; Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    child: Text(letters[index]),</span><br><span class="line">                  ))),</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithMaxCrossAxisExtent` 代理的方法</span></span><br><span class="line">      body: GridView.extent(</span><br><span class="line">          crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">          childAspectRatio: <span class="number">1.0</span>,</span><br><span class="line">          maxCrossAxisExtent: <span class="number">60.0</span>,</span><br><span class="line">          children: <span class="built_in">List</span>.generate(</span><br><span class="line">              letters.length,</span><br><span class="line">                  (index) =&gt;</span><br><span class="line">                  Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    child: Text(letters[index]),</span><br><span class="line">                  ))),</span><br></pre></td></tr></table></figure><p>运行的效果入和前面的相同</p><p><strong>GridView.custom</strong></p><p>这种生成方式，比 GridView 多了一个 childrenDelegate，childrenDelegate 主要分为两种，一种是通过 IndexedWidgetBuilder 来构建 item 的 SliverChildBuilderDelegate，还有一种是通过 List 来构建 item 的 SliverChildListDelegate，所以…这边直接有 4 中生成方式，当然，我们只需要了解 childrenDelegate 如何使用即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body: GridView.custom(</span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">              crossAxisCount: <span class="number">5</span>, mainAxisSpacing: <span class="number">10.0</span>, </span><br><span class="line">              crossAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">          <span class="comment">// item 通过 delegate 来生成，内部实现还是 `IndexedWidgetBuilder`</span></span><br><span class="line">          childrenDelegate: SliverChildBuilderDelegate(</span><br><span class="line">              (_, index) =&gt; Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    child: Text(letters[index]),</span><br><span class="line">                  ),</span><br><span class="line">              childCount: letters.length)),</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: GridView.custom(</span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">              crossAxisCount: <span class="number">5</span>, mainAxisSpacing: <span class="number">10.0</span>, </span><br><span class="line">              crossAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">          <span class="comment">// 内部通过返回控件列表实现</span></span><br><span class="line">          childrenDelegate: SliverChildListDelegate(</span><br><span class="line">            <span class="built_in">List</span>.generate(</span><br><span class="line">                letters.length,</span><br><span class="line">                (index) =&gt; Container(</span><br><span class="line">                      child: Text(letters[index]),</span><br><span class="line">                      alignment: Alignment.center,</span><br><span class="line">                      color: colors[index % <span class="number">4</span>],</span><br><span class="line">                    )),</span><br><span class="line">          )),</span><br></pre></td></tr></table></figure><p>运行效果也同上面。</p><p><strong>GridView.builder</strong></p><p>前面介绍的方法中，生成 item 的方式基本上是通过 List 进行转换的，在 custom 提到了 IndexWidgetBuilder 的生成方式，当然，在 ListView 的时候也用到了这种生成方式，当然 GridView 也有啊，要「雨露均沾」你说是吧</p> <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 `IndexedWidgetBuilder` 来构建 item，别的参数同上</span></span><br><span class="line">      body: GridView.builder(</span><br><span class="line">          <span class="comment">// 这里又需要分两种 `gridDelegate`</span></span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">              crossAxisCount: <span class="number">5</span>, crossAxisSpacing: <span class="number">10.0</span>, mainAxisSpacing: <span class="number">10.0</span>, childAspectRatio: <span class="number">1.0</span>),</span><br><span class="line">          itemCount: letters.length,</span><br><span class="line">          itemBuilder: (_, index) =&gt;</span><br><span class="line">              Container(color: colors[index % <span class="number">4</span>], child: Text(letters[index]), alignment: Alignment.center)),</span><br></pre></td></tr></table></figure><p>到这 10 种方式就说完了。终于可以歇一口气了。</p><p>该部分代码查看 gridview_main.dart 文件</p><h3 id="CustomScrollView"><a href="#CustomScrollView" class="headerlink" title="CustomScrollView"></a>CustomScrollView</h3><p>在平时的开发中，应该会遇到这么种情况，头部是一个 GridView 接下来拼接一些别的部件，然后再拼接一个列表，例如下图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522105306.png" alt=""></p><p>因为 GridView  和 ListView 亮着都是可滑动的部件，直接拼接肯定会有「滑动冲突」，所以 Flutter 就提供了一个粘合剂，CustomScrollView，那么 Flutter 如何实现呢，因为会涉及到 Sliver 系列部件，所以这边先看下大概的代码，下节会补充 Sliver 系列部件的内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomScrollDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这边用的 A-Z 字母</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; letters = [ ..... ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'CustomScrollDemo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: CustomScrollView(</span><br><span class="line">        <span class="comment">// 这里需要传入 `Sliver` 部件，下节课填坑</span></span><br><span class="line">        slivers: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// SliverGrid 实现同 GridView 实现方式一样</span></span><br><span class="line">          <span class="comment">// 同样 SliverGrid 有提供 `count`, `entent` 方法便于快速生成 SliverGrid</span></span><br><span class="line">          SliverGrid(</span><br><span class="line">              delegate: SliverChildBuilderDelegate(</span><br><span class="line">                  (_, index) =&gt; InkWell(</span><br><span class="line">                        child: Image.asset(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">                        onTap: () &#123;&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                  childCount: <span class="number">8</span>),</span><br><span class="line">              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                  crossAxisCount: <span class="number">4</span>, mainAxisSpacing: <span class="number">10.0</span>, crossAxisSpacing: <span class="number">10.0</span>)),</span><br><span class="line">          <span class="comment">// 这里下节讲</span></span><br><span class="line">          SliverToBoxAdapter(</span><br><span class="line">              child: Container(</span><br><span class="line">                  color: Colors.black12,</span><br><span class="line">                  margin: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">10.0</span>),</span><br><span class="line">                  child: Column(children: &lt;Widget&gt;[</span><br><span class="line">                    Divider(height: <span class="number">2.0</span>, color: Colors.black54),</span><br><span class="line">                    Stack(</span><br><span class="line">                      alignment: Alignment.center,</span><br><span class="line">                      children: &lt;Widget&gt;[</span><br><span class="line">                        Image.asset(<span class="string">'images/app_bar_hor.jpg'</span>, fit: BoxFit.cover),</span><br><span class="line">                        Text(<span class="string">'我是一些别的东西..例如广告'</span>, textScaleFactor: <span class="number">1.5</span>, style: TextStyle(color: Colors.red))</span><br><span class="line">                      ],</span><br><span class="line">                    ),</span><br><span class="line">                    Divider(height: <span class="number">2.0</span>, color: Colors.black54),</span><br><span class="line">                  ], mainAxisAlignment: MainAxisAlignment.spaceBetween),</span><br><span class="line">                  alignment: Alignment.center)),</span><br><span class="line">          <span class="comment">// SliverFixedExtentList 实现同 List.custom 实现类似</span></span><br><span class="line">          SliverFixedExtentList(</span><br><span class="line">              delegate: SliverChildBuilderDelegate(</span><br><span class="line">                  (_, index) =&gt; InkWell(</span><br><span class="line">                        child: Container(</span><br><span class="line">                          child: Text(letters[index] * <span class="number">10</span>,</span><br><span class="line">                              style: TextStyle(color: colors[index % colors.length], letterSpacing: <span class="number">2.0</span>),</span><br><span class="line">                              textScaleFactor: <span class="number">1.5</span>),</span><br><span class="line">                          alignment: Alignment.center,</span><br><span class="line">                        ),</span><br><span class="line">                        onTap: () &#123;&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                  childCount: letters.length),</span><br><span class="line">              itemExtent: <span class="number">60.0</span>)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看 custom_scroll_main.dart 文件</p><p>滑动部件其实还有好几个，但是以上介绍的在平时开发过程中够用了，如果后期发现还需要别的部件，我会继续补上。在结束前，我们再说下如何通过 ScrollController 来控制 Scrollable 的滚动位置。例如我们需要实现，当滚动的距离大于一定距离的时候显示一个回到顶部的按钮，有了 ScrollController 就能够非常方便的实现</p><h3 id="ScrollController"><a href="#ScrollController" class="headerlink" title="ScrollController"></a>ScrollController</h3><p>因为需要根据滑动的距离显示回到顶部按钮，那么就需要通过一个状态位来控制按钮显隐</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollControllerDemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScrollControllerDemoPageState createState() =&gt; _ScrollControllerDemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScrollControllerDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ScrollControllerDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _scrollController = ScrollController();</span><br><span class="line">  <span class="keyword">var</span> _showBackTop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 scrollController 进行监听</span></span><br><span class="line">    _scrollController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// _scrollController.position.pixels 获取当前滚动部件滚动的距离</span></span><br><span class="line">      <span class="comment">// window.physicalSize.height 获取屏幕高度</span></span><br><span class="line">      <span class="comment">// 当滚动距离大于 800 后，显示回到顶部按钮</span></span><br><span class="line">      setState(() =&gt; _showBackTop = _scrollController.position.pixels &gt;= <span class="number">800</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 记得销毁对象</span></span><br><span class="line">    _scrollController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'ScrollController Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: ListView(</span><br><span class="line">        controller: _scrollController,</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            <span class="number">20</span>, (index) =&gt; Container(height: <span class="number">50.0</span>, alignment: Alignment.center, child: Text(<span class="string">'Item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>))),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: _showBackTop <span class="comment">// 当需要显示的时候展示按钮，不需要的时候隐藏，设置 null</span></span><br><span class="line">          ? FloatingActionButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                <span class="comment">// scrollController 通过 animateTo 方法滚动到某个具体高度</span></span><br><span class="line">                <span class="comment">// duration 表示动画的时长，curve 表示动画的运行方式，flutter 在 Curves 提供了许多方式</span></span><br><span class="line">                _scrollController.animateTo(<span class="number">0.0</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), curve: Curves.decelerate);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Icon(Icons.vertical_align_top),</span><br><span class="line">            )</span><br><span class="line">          : <span class="keyword">null</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/a1.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的小节基本上讲完了常用的部件和容器部件，也可以完成很多的界面，但是又一个问题，假如我们要显示一段文字，比如将 一段又臭又长的文字 在界面上显示 1000 次，不难完成吧&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ..省略一些无关代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;body: Text(&lt;span class=&quot;string&quot;&gt;&#39;一段又臭又长的文字&#39;&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;, softWrap: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很简单，运行到手机…「诶诶诶，**，怎么只显示了一部分，剩下的怎么画不下去」&lt;/p&gt;
&lt;p&gt;日常开发中，会遇到很多这种情况，许多界面不是一页就能够显示完的。那么这里提下可滑动的容器部件&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(六)路由</title>
    <link href="http://yoursite.com/posts/b89d6378.html"/>
    <id>http://yoursite.com/posts/b89d6378.html</id>
    <published>2019-04-25T08:49:46.000Z</published>
    <updated>2019-05-22T03:02:57.042Z</updated>
    
    <content type="html"><![CDATA[<p>上一节撸了个界面，虽然比较简单，但是把前面讲的知识串联了下，但是界面之间的跳转一直没说，这节就讲下 Flutter 中的「路由」来管理界面。</p><h3 id="1、Navigator"><a href="#1、Navigator" class="headerlink" title="1、Navigator"></a>1、Navigator</h3><p>Flutter 通过 Navigator  来进行页面之间的跳转，分为 push 系列和 pop 系列操作，带 push 方法为入栈操作，带 pop 方法为出栈操作。Navigator 的 push 方法分两类，一类是带 Name 的，需要在 MaterialApp 下将 routers 属性进行注册，否则将会找不到该路由，还有一个是不带 Name 的，可以通过 Router 直接跳转。</p><p>说那么多相信还不如直接上代码和图来的更直接。因为需要展示所有的跳转至少需要 3 个页面，所以我们创建最简单的三个界面，通过文字来区别不同的页面，因为需要调用带有 Name 的方法，所以需要先在 MaterialApp 对路由进行注册。</p><a id="more"></a><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Learning Demo'</span>,</span><br><span class="line">      <span class="comment">// 在这里注册路由，关联 name 和界面</span></span><br><span class="line">      <span class="comment">// '/' 表示根页面，也就是 home 所对应的页面，这边就不需要配置 home 属性了</span></span><br><span class="line">      routes: &#123;<span class="string">'/'</span>: (_) =&gt; APage(), <span class="string">'/page_b'</span>: (_) =&gt; BPage(), <span class="string">'/page_c'</span>: (_) =&gt; CPage()&#125;,</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Page A，Button 的跳转事件等会进行修改，目前先空着</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Page A'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(child: RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'To Page B'</span>))),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Page B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Page B'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">        RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'To Page C'</span>)),</span><br><span class="line">        RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Back Page A'</span>))</span><br><span class="line">      ])),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Page C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Page C'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">              mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">              children: &lt;Widget&gt;[RaisedButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Back Last Page'</span>))])),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>push / pushNamed 方式跳转</strong></p><p>我们在 APage 的 RaiseButton 的 onPressed 方法加入如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage()));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushNamed(context, <span class="string">'/page_b'</span>);</span><br></pre></td></tr></table></figure><p>效果相同。跳转后，可以发现，在 BPage 的 AppBar 上有个返回按钮，点击可以返回 APage ，那么也就是说通过 push 或者 pushNamed 方式跳转的时候，界面堆栈的变化是直接在原来的堆栈上添加一个新的 page</p><p><strong>为了凸显堆栈的变化，所以绘制的图中，会比使用的实际页面多一个，下图同</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165301.png" alt=""></p><p><strong>pushReplacement / pushReplacementNamed / popAndPushNamed</strong></p><p>将 APage 中的跳转方式进行替换</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushReplacement(context, MaterialPageRoute(builder: (_) =&gt; BPage()));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushReplacementNamed(context, <span class="string">'/page_b'</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">/ 如果是第一个界面跳转到下个界面，勿用，`BPage` 会显示返回按钮，但是点击后，界面会变黑</span><br><span class="line"><span class="comment">// 因为 `APage` 已经不在堆栈中了，点击后堆栈就没有 `Page` 了，所以界面变黑</span></span><br><span class="line">Navigator.popAndPushNamed(context, <span class="string">'/page_b'</span>);</span><br></pre></td></tr></table></figure><p>效果相同，跳转后，可以发现 BPage 的返回按钮消失了，消失了，消失了，我们可以试下点击返回按键，发现 App 直接退出了，也就是说，BPage 替代了 APage 在堆栈中的位置。那么堆栈的变化图就是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165609.png" alt=""></p><p><strong>pushAndRemoveUntil / pushNamedAndRemoveUntil</strong></p><p><strong>CASE 1</strong></p><p>这个跳转方式需要通过 CPage 来协助完成，将 APage 的跳转方式修改为 push 方式，然后在 BPage 的第一个按钮加入如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushAndRemoveUntil(context, </span><br><span class="line">                   MaterialPageRoute(builder: (_) =&gt; CPage()), (Route router) =&gt; <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushNamedAndRemoveUntil(context, <span class="string">'/page_c'</span>, (Route router) =&gt; <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>效果相同，点击 BPage 的跳转 CPage 按钮后，界面来到 CPage，然后发现还是没有返回按钮，没有返回按钮，没有返回按钮，点击下返回按键，然后发现 App 直接退出了，退出了，退出了，那么堆栈变化如图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165652.png" alt=""></p><p><strong>CASE 2</strong></p><p>你以为这两个方法只是为了把堆栈都清空吗，那就太图样图森破了，这边展示另一种。修改跳转的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushAndRemoveUntil(context, </span><br><span class="line">                MaterialPageRoute(builder: (_) =&gt; CPage()), ModalRoute.withName(<span class="string">'/'</span>));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pushNamedAndRemoveUntil(context, <span class="string">'/page_c'</span>, ModalRoute.withName(<span class="string">'/'</span>));</span><br></pre></td></tr></table></figure><p>点击跳转 CPage 以后，发现返回按钮又回来了…就这么回来了…只是修改了一个参数，点击返回按钮，又回到了 APage，你可以在 APage 跳转 BPage 中加入DPage EPage 等等更多的界面，只要保证 BPage 跳转 CPage 的方式不变，点击 CPage 的返回按钮，又回到 APage 了，所以…堆栈的变化图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165739.png" alt=""></p><p><strong>SUMMARY</strong></p><p>为什么会这样变化呢，还记得在 MaterialApp 中注册的 router 么，APage 的 name 对应的为 ‘/‘，也就是说，该方法会把堆栈中在 ModalRoute.withName 所对应的 page 上的所有都 pop 出堆栈，如果把参数换成 /page_b，然后在跳转 CPage 之前加入更多的界面，点击 CPage 的返回按钮，就会回到 BPage</p><p><strong>pop</strong></p><p>在 BPage 的第二个按钮中加入 pop 操作</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.pop(context);</span><br></pre></td></tr></table></figure><p>跳转到 BPage 后点击该按钮，界面回到 APage，那么堆栈的变化很明显了，如图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165912.png" alt=""></p><p><strong>popUntil</strong></p><p>这个方法还需要借助 CPage ，在 CPage 的按钮中加入</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.popUntil(context, ModalRoute.withName(<span class="string">'/'</span>));</span><br></pre></td></tr></table></figure><p>点击返回按钮，界面跳过 BPage 回到了 APage，解释同 pushAndRemoveUntil 那么堆栈的变化也显而易见咯</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425165937.png" alt=""></p><h3 id="2、Navigator-传值"><a href="#2、Navigator-传值" class="headerlink" title="2、Navigator 传值"></a>2、Navigator 传值</h3><p><strong>CASE 1 传值给下个界面</strong></p><p>修改下 BPage 和 APage 的按钮点击事件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  BPage(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.message&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'passed value: $message'</span>);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// 省略相同代码</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// APage 跳转事件</span></span><br><span class="line">Navigator.push(context, MaterialPageRoute(builder: </span><br><span class="line">                                          (_) =&gt; BPage(message: <span class="string">'Message From Page A'</span>)));</span><br></pre></td></tr></table></figure><p>点击 APage 可以查看控制台有输出</p><blockquote><p>2019-03-17 00:04:06.854 12868-12888/com.kuky.demo.flutterartsdemosapp I/flutter: passed value: Message From Page A</p></blockquote><p>也就是成功把值传递过来了。<strong>但是，需要传递参数的话，之前在 MaterialApp 下注册的路由就需要去除了。</strong></p><p><strong>CASE 2 传值给上个界面</strong></p><p>这边可以查看下 pop 方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  <span class="comment">// pop 可以传入一个可选参数 result，这个 result 也就是回传给上个页面的参数值了</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> pop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, [ T result ]) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).pop&lt;T&gt;(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>既然知道 pop 如何传递值给上个界面，那么如何在上个界面接收这个参数呢，还是看下 push 方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  <span class="keyword">static</span> Future&lt;T&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, Route&lt;T&gt; route) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).push(route);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  Future&lt;T&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(Route&lt;T&gt; route) &#123;</span><br><span class="line">    <span class="comment">// ...省略无关代码</span></span><br><span class="line">    <span class="comment">// 这边返回一个 Future 值，`pop` 所传递的值会在这边返回</span></span><br><span class="line">    <span class="keyword">return</span> route.popped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The future completes with the value given to [Navigator.pop], if any.</span></span><br><span class="line">Future&lt;T&gt; <span class="keyword">get</span> popped =&gt; _popCompleter.future;</span><br></pre></td></tr></table></figure><p>官方的注释非常明白的指出，会在 Future 中携带 pop 传递的参数，那么我们对 APage跳转 BPage 以及 BPage 返回 APage 的逻辑进行修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// APage</span></span><br><span class="line">Navigator.push(context, MaterialPageRoute(builder: (_) </span><br><span class="line">                                          =&gt; BPage(message: <span class="string">'Message From Page A'</span>)))</span><br><span class="line">                    .then((value) =&gt; <span class="built_in">print</span>(<span class="string">'BACK MESSAGE =&gt; $value'</span>));</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/// BPage</span></span><br><span class="line">Navigator.pop(context, <span class="string">'Message back to PageA From BPage'</span>);</span><br></pre></td></tr></table></figure><p>点击返回后，能够在控制台发现有如下输入</p><blockquote><p>2019-03-17 16:35:53.820 13417-13442/com.kuky.demo.flutterartsdemosapp I/flutter: BACK MESSAGE =&gt; Message back to PageA From BPage</p></blockquote><p>上个页面成功接收到下个页面回传的数据。</p><p><strong>CASE 3 通过系统返回按钮传值</strong></p><p>在 CASE 2 情况下，通过按钮对返回事件进行监听，那加入我们需求没有这个按钮，只能通过系统默认的返回按钮，或者物理返回按键，那该如何传值呢，这里就需要用 WillpopScope 对系统的返回按钮进行监听。我们对 CPage 做下修改，在 Scaffold 外面包裹一个 WillpopScope</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> WillPopScope(</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Page C'</span>),</span><br><span class="line">          ),</span><br><span class="line">          body: Center(</span><br><span class="line">              child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">            RaisedButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.popUntil(context, ModalRoute.withName(<span class="string">'/'</span>));</span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">'Back Last Page'</span>))</span><br><span class="line">          ])),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 这里对系统返回按钮做监听..</span></span><br><span class="line">        <span class="comment">// 如果返回的是 `true` 则相当于 `pop` 操作，返回 `false` 则只执行上一步的 `pop` 操作</span></span><br><span class="line">        <span class="comment">// 例如双击返回退出，也是通过 `WillpopScope` 来进行监听</span></span><br><span class="line">        onWillPop: () <span class="keyword">async</span> &#123;</span><br><span class="line">          Navigator.pop(context, <span class="string">'Hello~'</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过返回按钮，BPage 会成功收到从 CPage 返回的 Hello~ 值</p><p>以上代码查看 router_main.dart 文件</p><h3 id="3、路由切换动画"><a href="#3、路由切换动画" class="headerlink" title="3、路由切换动画"></a>3、路由切换动画</h3><p>假如说我们不想用系统自带的切换动画，需要弄一些比较酷炫的效果该怎么办，那就需要用到自定义路由切换动画了。直接修改 BPage 跳转 CPage 的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    PageRouteBuilder(</span><br><span class="line">        <span class="comment">// 返回目标页面</span></span><br><span class="line">        pageBuilder: (context, anim, _) =&gt; CPage(),</span><br><span class="line">        <span class="comment">// 切换动画的切换时长</span></span><br><span class="line">        transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">        <span class="comment">// 切换动画的切换效果，系统自带的常用 Transition</span></span><br><span class="line">        <span class="comment">// ScaleTransition: 缩放  SlideTransition: 滑动</span></span><br><span class="line">        <span class="comment">// RotationTransition: 旋转  FadeTransition: 透明度</span></span><br><span class="line">        transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition(</span><br><span class="line">              <span class="comment">// Tween 是 flutter 的补间动画，等讲到动画的时候再提吧，这边先记住这么使用</span></span><br><span class="line">              scale: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">              <span class="comment">// 这个值必须记得要传，否则会不显示界面</span></span><br><span class="line">              child: child,</span><br><span class="line">            )));</span><br></pre></td></tr></table></figure><p>当再次点击跳转的时候，切换的动画就有开始自带的平滑效果变成缩放效果了。那如果要实现多个动画呢，例如边缩放，边改变透明度，也很容易实现，只需要将 child 替换成 Transition 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    PageRouteBuilder(</span><br><span class="line">        pageBuilder: (context, anim, _) =&gt; CPage(),</span><br><span class="line">        transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">        transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition(</span><br><span class="line">              scale: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">              <span class="comment">// 替换即可，如果要加入更多的动画，替换 `child` 属性就可以了</span></span><br><span class="line">              child: FadeTransition(</span><br><span class="line">                opacity: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">                child: child,</span><br><span class="line">              ),</span><br><span class="line">            )));</span><br></pre></td></tr></table></figure><p>当然，为了方便重复利用，需要进行封装，例如我们要封装上面的缩放动画效果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalePageRoute</span> <span class="keyword">extends</span> <span class="title">PageRouteBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget widget;</span><br><span class="line"></span><br><span class="line">  ScalePageRoute(<span class="keyword">this</span>.widget)</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">            transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">            pageBuilder: (context, anim, _) =&gt; widget,</span><br><span class="line">            transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition(</span><br><span class="line">                  scale: Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(anim),</span><br><span class="line">                  child: child,</span><br><span class="line">                ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接在 Navigator 跳转的时候调用该 Route 就可以了</p><p>该部分代码查看 custom_routes.dart 文件</p><p>还记得我们之前写的 demo 都是单个文件写一个入口的吗，现在我们就可以写一个统一管理的页面，对这些界面进行管理了，这个工作就交给大家伙自己了，当然我也在源码做了修改，可以查看 main.dart 文件</p><p>代码地址:</p><p><a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一节撸了个界面，虽然比较简单，但是把前面讲的知识串联了下，但是界面之间的跳转一直没说，这节就讲下 Flutter 中的「路由」来管理界面。&lt;/p&gt;
&lt;h3 id=&quot;1、Navigator&quot;&gt;&lt;a href=&quot;#1、Navigator&quot; class=&quot;headerlink&quot; title=&quot;1、Navigator&quot;&gt;&lt;/a&gt;1、Navigator&lt;/h3&gt;&lt;p&gt;Flutter 通过 Navigator  来进行页面之间的跳转，分为 push 系列和 pop 系列操作，带 push 方法为入栈操作，带 pop 方法为出栈操作。Navigator 的 push 方法分两类，一类是带 Name 的，需要在 MaterialApp 下将 routers 属性进行注册，否则将会找不到该路由，还有一个是不带 Name 的，可以通过 Router 直接跳转。&lt;/p&gt;
&lt;p&gt;说那么多相信还不如直接上代码和图来的更直接。因为需要展示所有的跳转至少需要 3 个页面，所以我们创建最简单的三个界面，通过文字来区别不同的页面，因为需要调用带有 Name 的方法，所以需要先在 MaterialApp 对路由进行注册。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(五)输入处理及登录界面实战</title>
    <link href="http://yoursite.com/posts/4b62f141.html"/>
    <id>http://yoursite.com/posts/4b62f141.html</id>
    <published>2019-04-25T08:40:00.000Z</published>
    <updated>2019-05-22T03:03:31.283Z</updated>
    
    <content type="html"><![CDATA[<p>前面提到基础部件的时候，忘了提输入内容处理部件，这里补上，然后顺带撸个实际的界面吧</p><h3 id="1、TextField"><a href="#1、TextField" class="headerlink" title="1、TextField"></a>1、TextField</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.controller, <span class="comment">// 定义一个 `TextEditingController` 实例，用来获取输入框内容等操作</span></span><br><span class="line">    <span class="keyword">this</span>.focusNode, <span class="comment">// 定义一个 `FocusNode` 实例，判断当前输入框是否获取到焦点等操作</span></span><br><span class="line">    <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(), <span class="comment">// 输入框样式，包括提醒字样，hint 等等</span></span><br><span class="line">    TextInputType keyboardType, <span class="comment">// 输入文本类型，例如 数字，email 等等</span></span><br><span class="line">    <span class="keyword">this</span>.textInputAction, <span class="comment">// 键盘确认按钮的事件类型</span></span><br><span class="line">    <span class="keyword">this</span>.textCapitalization = TextCapitalization.none,</span><br><span class="line">    <span class="keyword">this</span>.style, <span class="comment">// 文字样式</span></span><br><span class="line">    <span class="keyword">this</span>.textAlign = TextAlign.start, <span class="comment">// 对齐方式</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection, <span class="comment">// 文字方向</span></span><br><span class="line">    <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>, <span class="comment">// 是否自动获取焦点</span></span><br><span class="line">    <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>, <span class="comment">// 文字是否隐藏，多用于密码</span></span><br><span class="line">    <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>, </span><br><span class="line">    <span class="keyword">this</span>.maxLines = <span class="number">1</span>, <span class="comment">//</span></span><br><span class="line">    <span class="keyword">this</span>.maxLength, <span class="comment">// 最大长度</span></span><br><span class="line">    <span class="keyword">this</span>.maxLengthEnforced = <span class="keyword">true</span>, <span class="comment">// 设置最大长度后，输入内容超出后是否强制不给输入</span></span><br><span class="line">    <span class="keyword">this</span>.onChanged, <span class="comment">// 输入内容发生变化时候的回调</span></span><br><span class="line">    <span class="keyword">this</span>.onEditingComplete, <span class="comment">// 输入完毕的回调</span></span><br><span class="line">    <span class="keyword">this</span>.onSubmitted, <span class="comment">// 提交内容的回调</span></span><br><span class="line">    <span class="keyword">this</span>.inputFormatters, <span class="comment">// </span></span><br><span class="line">    <span class="keyword">this</span>.enabled, <span class="comment">// 是否可输入，false 不可输入</span></span><br><span class="line">    <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>, <span class="comment">// 游标宽度</span></span><br><span class="line">    <span class="keyword">this</span>.cursorRadius, <span class="comment">// 游标半径</span></span><br><span class="line">    <span class="keyword">this</span>.cursorColor, <span class="comment">// 游标颜色</span></span><br><span class="line">    <span class="keyword">this</span>.keyboardAppearance, <span class="comment">// 该属性只在 iOS 设备有效</span></span><br><span class="line">    <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">    <span class="keyword">this</span>.enableInteractiveSelection,</span><br><span class="line">    <span class="keyword">this</span>.onTap, <span class="comment">// 点击事件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>那么，简单的来个输入框示例吧，然后通过 Text 展示结果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 可以传入初始值</span></span><br><span class="line">  TextEditingController _editController = TextEditingController();</span><br><span class="line">  FocusNode _editNode = FocusNode();</span><br><span class="line">  <span class="comment">// 保存按钮点击后的输入内容值</span></span><br><span class="line">  <span class="built_in">String</span> _content = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 监听输入内容变化的内容值</span></span><br><span class="line">  <span class="built_in">String</span> _spyContent = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 当输入框获取到焦点或者失去焦点的时候回调用</span></span><br><span class="line">    _editNode.addListener(() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'edit has focus? =&gt; <span class="subst">$&#123;_editNode.hasFocus&#125;</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 记得销毁，防止内存溢出</span></span><br><span class="line">    _editController.dispose();</span><br><span class="line">    _editNode.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Input Content'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              TextField(</span><br><span class="line">                controller: _editController,</span><br><span class="line">                focusNode: _editNode,</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                    icon: Icon(Icons.phone_iphone, color: Theme.of(context).primaryColor),</span><br><span class="line">                    labelText: <span class="string">'请输入手机号'</span>,</span><br><span class="line">                    helperText: <span class="string">'手机号'</span>,</span><br><span class="line">                    hintText: <span class="string">'手机号...在这儿输入呢'</span>),</span><br><span class="line">                keyboardType: TextInputType.number,</span><br><span class="line">                <span class="comment">// 输入类型为数字类型</span></span><br><span class="line">                textInputAction: TextInputAction.done,</span><br><span class="line">                style: TextStyle(color: Colors.redAccent, fontSize: <span class="number">18.0</span>),</span><br><span class="line">                textDirection: TextDirection.ltr,</span><br><span class="line">                maxLength: <span class="number">11</span>, <span class="comment">// 最大长度为 11</span></span><br><span class="line">                maxLengthEnforced: <span class="keyword">true</span>, <span class="comment">// 超过长度的不显示</span></span><br><span class="line">                onChanged: (v) &#123; <span class="comment">// 输入的内容发生改变会调用</span></span><br><span class="line">                  setState(() =&gt; _spyContent = v);</span><br><span class="line">                &#125;,</span><br><span class="line">                onSubmitted: (s) &#123; <span class="comment">// 点击确定按钮时候会调用</span></span><br><span class="line">                  setState(() =&gt; _spyContent = _editController.value.text);</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              Padding(</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">                  child: RaisedButton(</span><br><span class="line">                      onPressed: () &#123; </span><br><span class="line">                        <span class="comment">// 获取输入的内容</span></span><br><span class="line">                        setState(() =&gt; _content = _editController.value.text);</span><br><span class="line">                        <span class="comment">// 清理输入内容</span></span><br><span class="line">                        _editController.clear();</span><br><span class="line">                        setState(() =&gt; _spyContent = <span class="string">''</span>);</span><br><span class="line">                      &#125;,</span><br><span class="line">                      child: Text(<span class="string">'获取输入内容'</span>))),</span><br><span class="line">              <span class="comment">// 展示输入的内容，点击按钮会显示</span></span><br><span class="line">              Text(_content.isNotEmpty ? <span class="string">'获取到输入内容: $_content'</span> : <span class="string">'还未获取到任何内容...'</span>),</span><br><span class="line">              Padding(</span><br><span class="line">                padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">                <span class="comment">// 监听输入内容的变化，会跟随输入的内容进行改变</span></span><br><span class="line">                child: Text(<span class="string">'我是文字内容监听：$_spyContent'</span>),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边需要提下的是 setState 方法，该方法只有 StatefulWidget 才有，当需要修改某个值的内容的时候，通过该方法进行修改，最后的效果图如下，当输入框文字发生变化的时候，监听的 Text 内容会随之改变，获取内容的 Text 当点击按钮了才发生变化</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164133.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164145.png" alt=""></p><p>该部分代码查看 text_field_main.dart 文件</p><p>那么如果有个需求，在点击按钮的时候需要对输入的内容的合理性进行检测，当然可以通过 TextEditingController 的结果进行检测，但是还有个更加方便的方法，可以直接使用部件 TextFormField 来实现，不过需要我们在外层加一个 Form 部件，接下来，就要准备通过 TextFormField 来撸一个登录界面，但是这之前，前面有个坑需要先解决下</p><h3 id="2、导入自定义的图标"><a href="#2、导入自定义的图标" class="headerlink" title="2、导入自定义的图标"></a>2、导入自定义的图标</h3><p>在这之前，涉及到 Icon 部件，都是使用的系统自带的图标，那么如何导入第三方自定义图标呢，马上为你揭晓答案，首先我们需要打开「阿里妈妈」也就是 iconfont，不知道的小伙伴通过链接打开，然后需要注册个账户，也可以直接通过 Github 等三方登录，然后就可以搜索我们需要的图标了，接下来需要撸一个登录，那我们就找一个 用户  和 密码 的图标吧，选择喜欢的图标，然后鼠标放到图标会出现三个按钮，直接点击 购物车 那个按钮，然后就可以通过顶部的 购物车 按钮查看添加的图标，点击下载代码，把资源文件下载到本地。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164358.png" alt=""></p><p>解压后，需要用到的文件有两个，别的可以忽略</p><ol><li>demo_index.html 这边用来查看图标的 unicode</li><li>iconfont.ttf 这边就是图标资源文件了</li></ol><p>回到项目，创建一个文件夹 fonts ，和 images 同级，将 iconfont.ttf 文件放到该文件夹下，然后打开 pubspec.ymal 文件，注册下导入的资源，可以自己命名 iconfont.ttf 文件名，便于自己发现就行，例如我命名为 third_part_icon.ttf，在注册图片下面继续添加</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">fonts:</span><br><span class="line">  - family: ThirdPartIcons</span><br><span class="line">    fonts:</span><br><span class="line">    - asset: fonts/third_part_icon.ttf</span><br></pre></td></tr></table></figure><p>注册完了记得点击 Package get，否则会找不到资源。接着新建个 third_icons.dart文件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdIcons</span> </span>&#123;</span><br><span class="line">  <span class="comment">// codePoint 值通过打开 `demo_index.html` 获取</span></span><br><span class="line">  <span class="comment">// 会在相应 icon 下带有相应的 code，把 `&amp;#` 替换成 `0`，然后去掉最后的 `;` 即可</span></span><br><span class="line">  <span class="comment">// 例如 &amp;#xe672; 对应我们需要的图标就是 0xe672</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData username = ThirdIconData(<span class="number">0xe672</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData password = ThirdIconData(<span class="number">0xe62f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdIconData</span> <span class="keyword">extends</span> <span class="title">IconData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// fontFamily 就是我们在 `pubspec.yaml` 中注册的 family 值</span></span><br><span class="line">  <span class="keyword">const</span> ThirdIconData(<span class="built_in">int</span> codePoint) : <span class="keyword">super</span>(codePoint, fontFamily: <span class="string">'ThirdPartIcons'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以通过该类导入需要的第三方图标了。</p><h3 id="3、导入第三方插件"><a href="#3、导入第三方插件" class="headerlink" title="3、导入第三方插件"></a>3、导入第三方插件</h3><p>其实 Flutter 中缺少很多功能，需要通过导入第三方插件来实现功能，插件就是 Flutter 和原生交互的桥梁，也就是说，要写 Flutter 的插件，需要写 Android 和 iOS 两端代码才可，否则只有在其中一个端能够实现功能。好在有很多现成的插件已经开源，可以通过 FlutterPackage 搜索到，例如等会我们会需要用到 FlutterToast 这个插件，用来做提醒用，在 FlutterPackage 中搜索到插件后，打开项目中的 pubspec.ymal 文件，在 dependencies 类目下将 fluttertoast 插件引入，如图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164504.png" alt=""></p><p>然后点击 Package get 让其导入即可，别的插件也是这样导入。做好准备工作，我们就可以撸一个登录界面了~</p><h3 id="4、撸一个登录界面"><a href="#4、撸一个登录界面" class="headerlink" title="4、撸一个登录界面"></a>4、撸一个登录界面</h3><p>在开撸之前，我们先看下最终的效果图吧，虽然是比较常用的界面</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164542.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164604.png" alt=""></p><p>因为两个界面比较相似，所以这边只贴外层的代码和登录的代码，具体的代码，可以查看源码，已经推到 Github</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(LoginApp());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">    <span class="keyword">var</span> style = SystemUiOverlayStyle(statusBarColor: Colors.transparent);</span><br><span class="line">    SystemChrome.setSystemUIOverlayStyle(style);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 外层界面，包裹登录界面和注册界面，使用的都是前面讲过的，忘记可以查看之前的章节</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Login Demo'</span>,</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      theme: ThemeData(primarySwatch: Colors.lightBlue),</span><br><span class="line">      home: LoginHomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LoginHomePageState createState() =&gt; _LoginHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginHomePage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  TabController _tabController;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _pageIndicators = [<span class="string">'登录'</span>, <span class="string">'注册'</span>];</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; _pages = [];</span><br><span class="line">  <span class="built_in">int</span> _position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _tabController = TabController(length: _pageIndicators.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将登录界面和注册界面添加到列表，用于放到 IndexStack 的 children 属性</span></span><br><span class="line">    _pages..add(LoginPage())..add(RegisterPage());</span><br><span class="line"></span><br><span class="line">    _tabController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// 当 tab 切换的时候，联动 IndexStack 的 child 页面也进行修改，通过 setState 来修改值</span></span><br><span class="line">      <span class="keyword">if</span> (_tabController.indexIsChanging) setState(() =&gt; _position = _tabController.index);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 先忽略...</span></span><br><span class="line">    <span class="keyword">return</span> Theme(</span><br><span class="line">        data: ThemeData(primarySwatch: Colors.pink, iconTheme: IconThemeData(color: Colors.pink)),</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          body: Container(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">            alignment: Alignment.center,</span><br><span class="line">            decoration:</span><br><span class="line">                BoxDecoration(image: DecorationImage(image: AssetImage(<span class="string">'images/login_bg.png'</span>), fit: BoxFit.cover)),</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 先忽略...下面会讲，主要是解决软键盘弹出的时候，界面内容会溢出的问题</span></span><br><span class="line">            child: SingleChildScrollView(</span><br><span class="line">              child: SafeArea(</span><br><span class="line">                  child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 顶部页面切换指示器，代码可以参考 `app_bar_main.dart` 文件</span></span><br><span class="line">                TabBar(</span><br><span class="line">                    indicatorSize: TabBarIndicatorSize.label,</span><br><span class="line">                    controller: _tabController,</span><br><span class="line">                    indicatorWeight: <span class="number">4.0</span>,</span><br><span class="line">                    indicatorColor: Colors.white,</span><br><span class="line">                    <span class="comment">// 返回 tab 列表</span></span><br><span class="line">                    tabs: _pageIndicators</span><br><span class="line">                        .map((v) =&gt; Text(v, style: TextStyle(color: Colors.white, fontSize: <span class="number">24.0</span>)))</span><br><span class="line">                        .toList()),</span><br><span class="line">                Padding(</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">30.0</span>),</span><br><span class="line">                    child: SizedBox(</span><br><span class="line">                        <span class="comment">// 切换界面列表</span></span><br><span class="line">                        child: IndexedStack(children: _pages, index: _position),</span><br><span class="line">                        <span class="comment">// 指定高度</span></span><br><span class="line">                        height: MediaQuery.of(context).size.height / <span class="number">2</span>))</span><br><span class="line">              ])),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 登录界面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LoginPageState createState() =&gt; _LoginPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 用于后面判断表单内容是否有效</span></span><br><span class="line">  GlobalKey&lt;FormState&gt; _formKey = GlobalKey();</span><br><span class="line">  <span class="comment">// 用于获取输入框的内容</span></span><br><span class="line">  TextEditingController _usernameController = TextEditingController();</span><br><span class="line">  TextEditingController _passwordController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 防止内存溢出，记得销毁..销毁..销毁</span></span><br><span class="line">    _usernameController.dispose();</span><br><span class="line">    _passwordController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _login() &#123;</span><br><span class="line">    <span class="comment">// 取消焦点</span></span><br><span class="line">    FocusScope.of(context).requestFocus(FocusNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断表单是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (_formKey.currentState.validate()) &#123;</span><br><span class="line">      <span class="comment">// 获取输入框内容</span></span><br><span class="line">      <span class="keyword">var</span> username = _usernameController.value.text;</span><br><span class="line">      <span class="keyword">var</span> password = _passwordController.value.text;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断登录条件</span></span><br><span class="line">      <span class="keyword">if</span> (username == <span class="string">'kuky'</span> &amp;&amp; password == <span class="string">'123456'</span>)</span><br><span class="line">        <span class="comment">// 引入的三方插件方法，`Flutter` 没有自带的 `Taost`</span></span><br><span class="line">        Fluttertoast.showToast(msg: <span class="string">'登录成功'</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        Fluttertoast.showToast(msg: <span class="string">'登录失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Form(</span><br><span class="line">        <span class="comment">// 将 key 设置给表单，用于判断表单是否有效</span></span><br><span class="line">        key: _formKey,</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>),</span><br><span class="line">              <span class="comment">// 表单输入框，参数同 TextField 基本类似</span></span><br><span class="line">              child: TextFormField(</span><br><span class="line">                controller: _usernameController,</span><br><span class="line">                style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>),</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                    icon: Icon(ThirdIcons.username, size: <span class="number">24.0</span>, color: Colors.white),</span><br><span class="line">                    labelText: <span class="string">'请输入用户名'</span>,</span><br><span class="line">                    labelStyle: TextStyle(color: Colors.white),</span><br><span class="line">                    helperStyle: TextStyle(color: Colors.white)),</span><br><span class="line">                <span class="comment">// 有效条件(为空不通过，返回提示语，通过返回 null)</span></span><br><span class="line">                validator: (value) =&gt; value.trim().isEmpty ? <span class="string">'用户名不能为空'</span> : <span class="keyword">null</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">4.0</span>),</span><br><span class="line">              child: TextFormField(</span><br><span class="line">                obscureText: <span class="keyword">true</span>,</span><br><span class="line">                controller: _passwordController,</span><br><span class="line">                style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>),</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                    icon: Icon(ThirdIcons.password, size: <span class="number">24.0</span>, color: Colors.white),</span><br><span class="line">                    labelText: <span class="string">'请输入密码'</span>,</span><br><span class="line">                    labelStyle: TextStyle(color: Colors.white),</span><br><span class="line">                    helperStyle: TextStyle(color: Colors.white)),</span><br><span class="line">                validator: (value) =&gt; value.trim().length &lt; <span class="number">6</span> ? <span class="string">'密码长度不能小于6位'</span> : <span class="keyword">null</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">              child: SizedBox(</span><br><span class="line">                <span class="comment">// 主要用于使 RaisedButton 和上层容器同宽</span></span><br><span class="line">                width: MediaQuery.of(context).size.width,</span><br><span class="line">                child: RaisedButton(</span><br><span class="line">                    color: Colors.pink,</span><br><span class="line">                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(<span class="number">4.0</span>))),</span><br><span class="line">                    onPressed: _login,</span><br><span class="line">                    child: Text(</span><br><span class="line">                      <span class="string">'登录'</span>,</span><br><span class="line">                      style: TextStyle(color: Colors.white, fontSize: <span class="number">20.0</span>),</span><br><span class="line">                    )),</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撸完界面后，可以试下登录效果，如果输入框的内容，和 TextFormField 的 validator的条件不符合，则会显示错误文字的提示</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425164811.png" alt=""></p><p>如果按照条件用户名为 kuky 密码为 123456 (条件可以根据自己进行修改)则会显示登录成功的逻辑</p><p>以上代码查看 login_home_page.dart 文件</p><p>注册界面的逻辑和登录界面的逻辑几乎一样，算是第一次实战了，望小伙伴能够好好的写一遍</p><p>代码地址:</p><p><a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面提到基础部件的时候，忘了提输入内容处理部件，这里补上，然后顺带撸个实际的界面吧&lt;/p&gt;
&lt;h3 id=&quot;1、TextField&quot;&gt;&lt;a href=&quot;#1、TextField&quot; class=&quot;headerlink&quot; title=&quot;1、TextField&quot;&gt;&lt;/a&gt;1、TextField&lt;/h3&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; TextField(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.controller, &lt;span class=&quot;comment&quot;&gt;// 定义一个 `TextEditingController` 实例，用来获取输入框内容等操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.focusNode, &lt;span class=&quot;comment&quot;&gt;// 定义一个 `FocusNode` 实例，判断当前输入框是否获取到焦点等操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.decoration = &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; InputDecoration(), &lt;span class=&quot;comment&quot;&gt;// 输入框样式，包括提醒字样，hint 等等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TextInputType keyboardType, &lt;span class=&quot;comment&quot;&gt;// 输入文本类型，例如 数字，email 等等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textInputAction, &lt;span class=&quot;comment&quot;&gt;// 键盘确认按钮的事件类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textCapitalization = TextCapitalization.none,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.style, &lt;span class=&quot;comment&quot;&gt;// 文字样式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textAlign = TextAlign.start, &lt;span class=&quot;comment&quot;&gt;// 对齐方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textDirection, &lt;span class=&quot;comment&quot;&gt;// 文字方向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.autofocus = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 是否自动获取焦点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.obscureText = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 文字是否隐藏，多用于密码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.autocorrect = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxLines = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxLength, &lt;span class=&quot;comment&quot;&gt;// 最大长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxLengthEnforced = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 设置最大长度后，输入内容超出后是否强制不给输入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onChanged, &lt;span class=&quot;comment&quot;&gt;// 输入内容发生变化时候的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onEditingComplete, &lt;span class=&quot;comment&quot;&gt;// 输入完毕的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onSubmitted, &lt;span class=&quot;comment&quot;&gt;// 提交内容的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.inputFormatters, &lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.enabled, &lt;span class=&quot;comment&quot;&gt;// 是否可输入，false 不可输入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cursorWidth = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 游标宽度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cursorRadius, &lt;span class=&quot;comment&quot;&gt;// 游标半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cursorColor, &lt;span class=&quot;comment&quot;&gt;// 游标颜色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyboardAppearance, &lt;span class=&quot;comment&quot;&gt;// 该属性只在 iOS 设备有效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.scrollPadding = &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; EdgeInsets.all(&lt;span class=&quot;number&quot;&gt;20.0&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.enableInteractiveSelection,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.onTap, &lt;span class=&quot;comment&quot;&gt;// 点击事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(四)常用布局</title>
    <link href="http://yoursite.com/posts/14587b6a.html"/>
    <id>http://yoursite.com/posts/14587b6a.html</id>
    <published>2019-04-25T08:23:54.000Z</published>
    <updated>2019-05-22T03:02:46.524Z</updated>
    
    <content type="html"><![CDATA[<p>上节填完了 Scaffold 留下的坑，这节继续填坑，之前留下关于 Layout 的坑，又是一堆部件袭来</p><h3 id="1、Container"><a href="#1、Container" class="headerlink" title="1、Container"></a>1、Container</h3><p>为了让我们的界面更容易被扩展，通常会在最外层包裹一层 Container，其构造函数也不是很难理解</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.alignment, <span class="comment">// child 的对齐方式，包括左对齐，居中，右对齐，左上对齐..等等</span></span><br><span class="line">    <span class="keyword">this</span>.padding, <span class="comment">// child 和 Container 的边距</span></span><br><span class="line">    Color color, <span class="comment">// Container 的背景色</span></span><br><span class="line">    Decoration decoration, <span class="comment">// 样式，可以设置背景图，圆角等属性</span></span><br><span class="line">    <span class="keyword">this</span>.foregroundDecoration, <span class="comment">// child 的样式</span></span><br><span class="line">    <span class="built_in">double</span> width, <span class="comment">// 宽度</span></span><br><span class="line">    <span class="built_in">double</span> height, <span class="comment">// 高度</span></span><br><span class="line">    BoxConstraints constraints, <span class="comment">// 默认使用 BoxConstraints.tightFor，可以手动传入</span></span><br><span class="line">    <span class="keyword">this</span>.margin, <span class="comment">// Container 同上层容器的边距</span></span><br><span class="line">    <span class="keyword">this</span>.transform, <span class="comment">// 是个 Matrix4 矩阵，(嗯..这个参数基本很少用，没怎么了解 /捂脸)</span></span><br><span class="line">    <span class="keyword">this</span>.child, <span class="comment">// 需要展示的内容</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> BoxConstraints.tightFor(&#123;</span><br><span class="line">    <span class="built_in">double</span> width,</span><br><span class="line">    <span class="built_in">double</span> height</span><br><span class="line">  &#125;): minWidth = width != <span class="keyword">null</span> ? width : <span class="number">0.0</span>,</span><br><span class="line">      maxWidth = width != <span class="keyword">null</span> ? width : <span class="built_in">double</span>.infinity,</span><br><span class="line">      minHeight = height != <span class="keyword">null</span> ? height : <span class="number">0.0</span>,</span><br><span class="line">      maxHeight = height != <span class="keyword">null</span> ? height : <span class="built_in">double</span>.infinity;</span><br></pre></td></tr></table></figure><a id="more"></a><p>让我们写个圆角矩形的外层，内层值显示白色文字</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        <span class="comment">// 宽，高度同上层容器相同</span></span><br><span class="line">        width: MediaQuery.of(context).size.width,</span><br><span class="line">        height: MediaQuery.of(context).size.height,</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">        <span class="comment">// Container 的样式</span></span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            borderRadius: BorderRadius.circular(<span class="number">20.0</span>),</span><br><span class="line">            color: Colors.red,</span><br><span class="line"><span class="comment">//            shape: BoxShape.circle, // 该属性不可同 borderRadius 一起使用</span></span><br><span class="line">            backgroundBlendMode: BlendMode.colorDodge, <span class="comment">// 背景图片和颜色混合模式</span></span><br><span class="line">            image: DecorationImage(image: AssetImage(<span class="string">'images/ali.jpg'</span>), fit: BoxFit.cover)),</span><br><span class="line">        child: Text(<span class="string">'Container Text'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line"><span class="comment">//        color: Theme.of(context).primaryColor, // 该属性不可和 decoration 一起使用</span></span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163312.png" alt=""></p><p>该部分代码查看 column_main.dart 文件</p><p>看到这，应该很多小伙伴注意到 margin 和 padding 属性用来和别的部件保持间距，那…那我就是不用 Container 呢(专门来挑事的…)，当然没问题，有个专门用来设置间距的部件 Padding，看名字就可以看出来作用了，修改下 child 部分代码，这边先提前用下接下来会讲的部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'Container Text'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Padding(</span><br><span class="line">                <span class="comment">// 需要传入一个间隔值，`Flutter` 提供了很多 EdgeInsets 来设置间隔，</span></span><br><span class="line">                <span class="comment">// 参数也很明确，可以一一尝试</span></span><br><span class="line">                padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">12.0</span>),</span><br><span class="line">                <span class="comment">// 传入需要间隔的部件</span></span><br><span class="line">                child: Text(<span class="string">'Container Text'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)))</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>效果就不展示了，接下来就要开始我的填坑之旅了….</p><h3 id="2、Flex，Row，Column"><a href="#2、Flex，Row，Column" class="headerlink" title="2、Flex，Row，Column"></a>2、Flex，Row，Column</h3><p>写 Android 的小伙伴应该比较常用 LinearLayout，在 Flutter 中用两个部件，Row Column来代替 Android 中的 LinearLayout，其中 Row 是横向布局，Column 是垂直布局，因为 Row 和 Column 都是继承于 Flex 部件，Flex 比他们多了 direction 属性用来指定方向，所以主要拿 Column 来讲解，Flex 、Row 用法相同</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Column(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 对齐方式，对于 `Column` start 为顶部，对于 `Row` 需要分语言，和语言同向</span></span><br><span class="line">    <span class="comment">// 3 种比较特殊的对齐方式，前端的小伙伴会了解，</span></span><br><span class="line">    <span class="comment">// spaceAround 两个部件之间的间隔是部件和上层容器间隔的两倍</span></span><br><span class="line">    <span class="comment">// spaceBetween 两侧部件同上层容器间隔为 0，部件之间的间隔相等</span></span><br><span class="line">    <span class="comment">// spaceEvenly 部件之间的间隔同两侧部件与上层容器间隔</span></span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, </span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max, <span class="comment">// 主轴的大小</span></span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, <span class="comment">// 副轴对齐方式</span></span><br><span class="line">    TextDirection textDirection, <span class="comment">// 文字方向，决定 start</span></span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down, <span class="comment">// 垂直方向</span></span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[], <span class="comment">// 内部子部件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Row 和 Column 都有主轴和副轴，如何区分呢，布局平行方向为主轴，垂直方向为副轴，我们把 Container 的 child 修改成 Column，然后把 Text 放到 Column 中，多放几个，然后自己设置 mainAxisAlignment 属性，查看布局的变化</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 省略相同代码</span></span><br><span class="line">child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'Container Text 1'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 2'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 3'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 4'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">            Text(<span class="string">'Container Text 5'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>最后的效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163435.png" alt=""></p><p>这边 Column 内部的子部件因为高度相同，如果不同还需要等分空间的话，就不可以通过设置 mainAxisAlignment 属性来实现了，这里介绍一个等分的部件 Expanded</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">int</span> flex = <span class="number">1</span>, <span class="comment">// 所占比例</span></span><br><span class="line">    <span class="meta">@required</span> Widget child, <span class="comment">// 子部件</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>直接给 Text 外层加一个 Expanded 即可实现效果，当然可以按照需求来设置 flex 来修改比例值。</p><p>当然，在使用过程中也会遇到那么些坑，我们修改下代码，把 child 的代码修改成如下</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)),</span><br><span class="line">            Text(<span class="string">'ABC'</span> * <span class="number">5</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>))</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>然后运行下，你的屏幕就提示你 RIGHT OVERFLOWED BY XXX PIXELS 「<strong>,  ***</strong>」我猜你内心肯定这样的，冷静冷静</p><p>既然遇到问题，当然要解决，不然和产品去撕逼吗..？这边，我们把 Row 换成另一个布局 Wrap 然后再运行，Prefect，Wrap 和 Row 的参数基本类似</p><h3 id="3、Wrap"><a href="#3、Wrap" class="headerlink" title="3、Wrap"></a>3、Wrap</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Wrap(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.direction = Axis.horizontal,</span><br><span class="line">    <span class="keyword">this</span>.alignment = WrapAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.spacing = <span class="number">0.0</span>, <span class="comment">// 两个子部件之间的间隔，默认 0.0，如果值过大，可能导致原来同行的两个部件分行</span></span><br><span class="line">    <span class="keyword">this</span>.runAlignment = WrapAlignment.start, </span><br><span class="line">    <span class="keyword">this</span>.runSpacing = <span class="number">0.0</span>, <span class="comment">// 排布方向上 两个子部件的间隔</span></span><br><span class="line">    <span class="keyword">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当然，很多时候只有以上的布局是不行的，比如我们需要实现一个圆形头像，然后一段文字在其上面 ，例如下面的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163555.png" alt=""></p><p>接下来介绍一个堆叠的部件 Stack，源码比较简单，就不贴了，直接上效果代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Stack(</span><br><span class="line">        <span class="comment">// 内部子部件的对齐方式</span></span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 圆形头像，指定半径，指定背景图为头像即可</span></span><br><span class="line">          CircleAvatar(backgroundImage: AssetImage(<span class="string">'images/ali.jpg'</span>), radius: <span class="number">100.0</span>),</span><br><span class="line">          Text(</span><br><span class="line">            <span class="string">'Kuky'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">34.0</span>)),</span><br><span class="line">        ],</span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要第三个部件，底部距离圆形头像10px，那么只靠 alignment 是不可能实现了</p><p>所以，另外一个灰常流弊的部件就出来了 Positioned，其源码也比较简单，我还是不贴了吧~，还是直接上代码，直接修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">          child: Stack(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          CircleAvatar(backgroundImage: AssetImage(<span class="string">'images/ali.jpg'</span>), radius: <span class="number">100.0</span>),</span><br><span class="line">          Text(</span><br><span class="line">            <span class="string">'Kuky'</span>,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: <span class="number">34.0</span>),</span><br><span class="line">          ),</span><br><span class="line">          Positioned(child: Text(<span class="string">'另外一段文字'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">20.0</span>)), bottom: <span class="number">10.0</span>), <span class="comment">// left, right, top, bottom 分别表示和 stack 的间距</span></span><br><span class="line">        ],</span><br><span class="line">      )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163821.png" alt=""></p><p>很好，今天填了布局的这个大坑，而且讲的部件貌似还挺多的，虽然还是比较简单，剩下的就给小伙伴们慢慢消化今天的内容。</p><p>下节，除了有常用的部件外，我会尽量加上实战内容</p><p>代码地址:</p><p><a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节填完了 Scaffold 留下的坑，这节继续填坑，之前留下关于 Layout 的坑，又是一堆部件袭来&lt;/p&gt;
&lt;h3 id=&quot;1、Container&quot;&gt;&lt;a href=&quot;#1、Container&quot; class=&quot;headerlink&quot; title=&quot;1、Container&quot;&gt;&lt;/a&gt;1、Container&lt;/h3&gt;&lt;p&gt;为了让我们的界面更容易被扩展，通常会在最外层包裹一层 Container，其构造函数也不是很难理解&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Container(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.alignment, &lt;span class=&quot;comment&quot;&gt;// child 的对齐方式，包括左对齐，居中，右对齐，左上对齐..等等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.padding, &lt;span class=&quot;comment&quot;&gt;// child 和 Container 的边距&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Color color, &lt;span class=&quot;comment&quot;&gt;// Container 的背景色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Decoration decoration, &lt;span class=&quot;comment&quot;&gt;// 样式，可以设置背景图，圆角等属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.foregroundDecoration, &lt;span class=&quot;comment&quot;&gt;// child 的样式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; width, &lt;span class=&quot;comment&quot;&gt;// 宽度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; height, &lt;span class=&quot;comment&quot;&gt;// 高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BoxConstraints constraints, &lt;span class=&quot;comment&quot;&gt;// 默认使用 BoxConstraints.tightFor，可以手动传入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.margin, &lt;span class=&quot;comment&quot;&gt;// Container 同上层容器的边距&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.transform, &lt;span class=&quot;comment&quot;&gt;// 是个 Matrix4 矩阵，(嗯..这个参数基本很少用，没怎么了解 /捂脸)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.child, &lt;span class=&quot;comment&quot;&gt;// 需要展示的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; BoxConstraints.tightFor(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; width,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt; height&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;): minWidth = width != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? width : &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      maxWidth = width != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? width : &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt;.infinity,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      minHeight = height != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? height : &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      maxHeight = height != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? height : &lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt;.infinity;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(三)快速搭建界面</title>
    <link href="http://yoursite.com/posts/5c762cf7.html"/>
    <id>http://yoursite.com/posts/5c762cf7.html</id>
    <published>2019-04-25T08:00:21.000Z</published>
    <updated>2019-05-22T03:03:14.079Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲完 Flutter 中的一些基本部件，这篇就先填完上篇留下的没写的 AppBar 的坑，以及 Scaffold 其他参数的使用，在开始前，先补一张缩略版的脑图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425155737.png" alt=""></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160120.png" alt=""></p><h3 id="1、AppBar"><a href="#1、AppBar" class="headerlink" title="1、AppBar"></a>1、AppBar</h3><p>这一部分，我们只关注 Scaffold 中的 AppBar 剩下的还是埋坑【坑4】(<img src="https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_05.png?wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img">，居然已经埋了那么多坑了，坑虽多，代码还是要继续的)，因为稍后会用到 StatefulWidget 的属性，所以就直接先使用了，和 StatelessWidget 区别用法可以这么记 需要数据更新的界面用 StatefulWidget，当然也不是绝对的，就是之前留的【坑1】所说的状态管理</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _abs = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'S'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>, <span class="comment">// 标题内容居中</span></span><br><span class="line">        automaticallyImplyLeading: <span class="keyword">false</span>, <span class="comment">// 不使用默认</span></span><br><span class="line">        leading: Icon(Icons.menu, color: Colors.red, size: <span class="number">30.0</span>), <span class="comment">// 左侧按钮</span></span><br><span class="line">        flexibleSpace: Image.asset(<span class="string">'images/app_bar_hor.jpg'</span>, fit: BoxFit.cover), <span class="comment">// 背景</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)), <span class="comment">// 标题内容</span></span><br><span class="line">        <span class="comment">// 末尾的操作按钮列表</span></span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图，未点击右侧按钮如左侧所示，点击右侧按钮会弹出相应的 mune</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160332.png" alt=""></p><p>该部分代码查看 app_bar_main.dart 文件</p><p>看到效果图，相信很多小伙伴会吐槽，「**，上面那层半透明的啥玩意，那么丑」，接下来我们来解决这个问题，修改 void main 方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(DemoApp());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加如下代码，使状态栏透明</span></span><br><span class="line">  <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">    <span class="keyword">var</span> style = SystemUiOverlayStyle(statusBarColor: Colors.transparent);</span><br><span class="line">    SystemChrome.setSystemUIOverlayStyle(style);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭后重新运行，就可以看到那层丑丑的「半透明蒙层」没有了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160534.png" alt=""></p><p>接着介绍下 PopupMenuButton 这个部件，还是按照惯例看构造函数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// itemBuilder</span></span><br><span class="line"><span class="keyword">typedef</span> PopupMenuItemBuilder&lt;T&gt; = <span class="built_in">List</span>&lt;PopupMenuEntry&lt;T&gt;&gt; <span class="built_in">Function</span>(BuildContext context);</span><br><span class="line"><span class="comment">// onSelected</span></span><br><span class="line"><span class="keyword">typedef</span> PopupMenuItemSelected&lt;T&gt; = <span class="keyword">void</span> <span class="built_in">Function</span>(T value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PopupMenuButton(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.itemBuilder, <span class="comment">// 用于定义 menu 列表，需要传入 List&lt;PopupMenuEntry&lt;T&gt;&gt;</span></span><br><span class="line">    <span class="keyword">this</span>.initialValue, <span class="comment">// 初始值，是个泛型 T，也就是类型和你传入的值有关</span></span><br><span class="line">    <span class="keyword">this</span>.onSelected, <span class="comment">// 选中 item 的回调函数，返回 T value，例如选中 `s` 则返回 s</span></span><br><span class="line">    <span class="keyword">this</span>.onCanceled, <span class="comment">// 未选择任何 menu，直接点击外侧使 mune 列表关闭的回调</span></span><br><span class="line">    <span class="keyword">this</span>.tooltip, <span class="comment">// 长按时的提示</span></span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">8.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.padding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">    <span class="keyword">this</span>.child, <span class="comment">// 用于自定义按钮的内容</span></span><br><span class="line">    <span class="keyword">this</span>.icon, <span class="comment">// 按钮的图标</span></span><br><span class="line">    <span class="keyword">this</span>.offset = Offset.zero, <span class="comment">// 展示时候的便宜，Offset 需要传入 x,y 轴偏移量，会根据传入值平移</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="2、AppBar-bottom"><a href="#2、AppBar-bottom" class="headerlink" title="2、AppBar - bottom"></a>2、AppBar - bottom</h3><p>AppBar 还有个 bottom 属性没讲，因为 bottom 这个属性和图片背景一起使用会比较丑，所以就单独拎出来讲，我们直接在原来的代码上修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里需要用 with 引入 `SingleTickerProviderStateMixin` 这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _abs = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'S'</span>];</span><br><span class="line">  TabController _tabController; <span class="comment">// TabBar 必须传入这个参数</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 引入 `SingleTickerProviderStateMixin` 类主要是因为 _tabController 需要传入 vsync 参数</span></span><br><span class="line">    _tabController = TabController(length: _abs.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 需要在界面 dispose 之前把 _tabController dispose，防止内存泄漏</span></span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line">        automaticallyImplyLeading: <span class="keyword">false</span>,</span><br><span class="line">        leading: Icon(Icons.menu, color: Colors.red, size: <span class="number">30.0</span>),</span><br><span class="line"><span class="comment">//        flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover),</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              offset: Offset(<span class="number">50.0</span>, <span class="number">100.0</span>),</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">            labelColor: Colors.red, <span class="comment">// 选中时的颜色</span></span><br><span class="line">            unselectedLabelColor: Colors.white, <span class="comment">// 未选中颜色</span></span><br><span class="line">            controller: _tabController,</span><br><span class="line">            isScrollable: <span class="keyword">false</span>, <span class="comment">// 是否固定，当超过一定数量的 tab 时，如果一行排不下，可设置 true</span></span><br><span class="line">            indicatorColor: Colors.yellow, <span class="comment">// 导航的颜色</span></span><br><span class="line">            indicatorSize: TabBarIndicatorSize.tab, <span class="comment">// 导航样式，还有个选项是 TabBarIndicatorSize.label tab 时候，导航和 tab 同宽，label 时候，导航和 icon 同宽</span></span><br><span class="line">            indicatorWeight: <span class="number">5.0</span>, <span class="comment">// 导航高度</span></span><br><span class="line">            tabs: <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), <span class="comment">// 导航内容列表</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果图如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425160654.png" alt=""></p><h3 id="3、PageView-TabBar"><a href="#3、PageView-TabBar" class="headerlink" title="3、PageView + TabBar"></a>3、PageView + TabBar</h3><p>那么如何通过 TabBar 切换界面呢，这边我们需要用到 PageView 这个部件，当然还有别的部件，例如 IndexStack 等，小伙伴可以自己尝试使用别的，这边通过 PageView 和 TabBar 进行关联，带动页面切换，PageViede 的属性参数相对比较简单，这边就不贴啦。最终的效果我们目前只展示一个文字即可，我们先定义一个通用的切换界面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabChangePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要传入的参数</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> content;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TabChangePage(this.content); 不推荐这样写构造方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 推荐用这样的构造方法，key 可以作为唯一值查找</span></span><br><span class="line">  TabChangePage(&#123;Key key, <span class="keyword">this</span>.content&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 仅展示传入的内容</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">        alignment: Alignment.center, child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义通用界面后，就可以作为 PageView 的子界面传入并展示</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _abs = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'S'</span>];</span><br><span class="line">  TabController _tabController;</span><br><span class="line">  <span class="comment">// 用于同 TabBar 进行联动</span></span><br><span class="line">  PageController _pageController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _tabController = TabController(length: _abs.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">    _pageController = PageController(initialPage: <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    _tabController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// 判断 TabBar 是否切换位置了，如果切换了，则修改 PageView 的显示</span></span><br><span class="line">      <span class="keyword">if</span> (_tabController.indexIsChanging) &#123;</span><br><span class="line">        <span class="comment">// PageView 的切换通过 controller 进行滚动</span></span><br><span class="line">        <span class="comment">// duration 表示切换滚动的时长，curve 表示滚动动画的样式，</span></span><br><span class="line">        <span class="comment">// flutter 已经在 Curves 中定义许多样式，可以自行切换查看效果</span></span><br><span class="line">        _pageController.animateToPage(_tabController.index,</span><br><span class="line">            duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>), curve: Curves.decelerate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line">        automaticallyImplyLeading: <span class="keyword">false</span>,</span><br><span class="line">        leading: Icon(Icons.menu, color: Colors.red, size: <span class="number">30.0</span>),</span><br><span class="line"><span class="comment">//        flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover),</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              offset: Offset(<span class="number">50.0</span>, <span class="number">100.0</span>),</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">            labelColor: Colors.red,</span><br><span class="line">            unselectedLabelColor: Colors.white,</span><br><span class="line">            controller: _tabController,</span><br><span class="line">            isScrollable: <span class="keyword">false</span>,</span><br><span class="line">            indicatorColor: Colors.yellow,</span><br><span class="line">            indicatorSize: TabBarIndicatorSize.tab,</span><br><span class="line">            indicatorWeight: <span class="number">5.0</span>,</span><br><span class="line">            tabs: <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 通过 body 来展示内容，body 可以传入任何 Widget，里面就是你需要展示的界面内容</span></span><br><span class="line">      <span class="comment">// 所以前面留下 Scaffold 中 body 部分的坑就解决了</span></span><br><span class="line">      body: PageView(</span><br><span class="line">        controller: _pageController,</span><br><span class="line">        children:</span><br><span class="line">            _abs.map((str) =&gt; TabChangePage(content: str)).toList(), <span class="comment">// 通过 Map 转换后再通过 toList 转换成列表，效果同 List.generate</span></span><br><span class="line">        onPageChanged: (position) &#123;</span><br><span class="line">          <span class="comment">// PageView 切换的监听，这边切换 PageView 的页面后，TabBar 也需要随之改变</span></span><br><span class="line">          <span class="comment">// 通过 tabController 来改变 TabBar 的显示位置</span></span><br><span class="line">          _tabController.index = position;</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果图就不贴了，可以发现滑动 PageView 或者点击切换 TabBar 的位置，界面显示的内容都会随之改变，同时，解决前面 Scaffold 留下 body 属性没讲的一个坑，就剩下 drawer 、 bottomNavigationBar 属性没讲了，在解决这两个坑之前，我们先处理下另一个问题</p><p>Scaffold 能够使我们快速去搭建一个界面，但是，并不是所有的界面都需要 AppBar 这个标题，那么我们就不会传入 appBar 的属性，我们注释 _HomePageState 中 Scaffold 的 appBar 传入值，把 body 传入的 PageView 修改成单个 TabChangePage ，然后把 TabChangePage 这个类做下修改，把 Container 的 aligment 属性也注释了，这样显示的内容就会显示在左上角</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _HomePageState</span></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(body: TabChangePage(content: <span class="string">'Content'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabChangePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> content;</span><br><span class="line">    </span><br><span class="line">  TabChangePage(&#123;Key key, <span class="keyword">this</span>.content&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行下，「**，文字怎么被状态栏给挡了…」<br>不要慌，静下心喝杯茶，眺望下远方，这里就需要用 SafeArea 来处理了，在 TabChangePage 的 Container 外层加一层 SafeArea</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SafeArea(</span><br><span class="line">        child:</span><br><span class="line">            Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>))));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后重新运行，一切正常，SafeArea 的用途可以看下源码的解释</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A widget that insets its child by sufficient padding to avoid intrusions by</span></span><br><span class="line"><span class="comment">/// the operating system.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// For example, this will indent the child by enough to avoid the status bar at</span></span><br><span class="line"><span class="comment">/// the top of the screen.</span></span><br></pre></td></tr></table></figure><p>翻译过来大概就是「给子部件和系统点击无效区域留有足够空间，比如状态栏和系统导航栏」，SafeArea 可以很好解决刘海屏覆盖页面内容的问题，那么到目前为止，AppBar 的一些坑就说的差不多了，就要解决剩下的坑了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425161326.png" alt=""></p><h3 id="4、Scaffold-Drawer"><a href="#4、Scaffold-Drawer" class="headerlink" title="4、Scaffold - Drawer"></a>4、Scaffold - Drawer</h3><p>drawer 同 endDrawer 属性是一样的，除了滑动的方向，Drawer 这个组件也相对比较简单，只要传入一个 child 即可，在展示之前，先对 appBar 做下处理，设置 leading 为系统默认，点击 leading 的时候 Drawer 就可以滑出来了，当然手动滑也可以</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">//        automaticallyImplyLeading: false,</span></span><br><span class="line"><span class="comment">//        leading: Icon(Icons.menu, color: Colors.red, size: 30.0),</span></span><br><span class="line"><span class="comment">//        flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover),</span></span><br><span class="line">        title: Text(<span class="string">'AppBar Demo'</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          PopupMenuButton(</span><br><span class="line">              offset: Offset(<span class="number">50.0</span>, <span class="number">100.0</span>),</span><br><span class="line">              onSelected: (val) =&gt; <span class="built_in">print</span>(<span class="string">'Selected item is $val'</span>),</span><br><span class="line">              icon: Icon(Icons.more_vert, color: Colors.red),</span><br><span class="line">              itemBuilder: (context) =&gt;</span><br><span class="line">                  <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index]))))</span><br><span class="line">        ],</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">            labelColor: Colors.red,</span><br><span class="line">            unselectedLabelColor: Colors.white,</span><br><span class="line">            controller: _tabController,</span><br><span class="line">            isScrollable: <span class="keyword">false</span>,</span><br><span class="line">            indicatorColor: Colors.yellow,</span><br><span class="line">            indicatorSize: TabBarIndicatorSize.tab,</span><br><span class="line">            indicatorWeight: <span class="number">5.0</span>,</span><br><span class="line">            tabs: <span class="built_in">List</span>.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// body ....</span></span><br><span class="line">      drawer: Drawer(</span><br><span class="line">        <span class="comment">// 记得要先添加 `SafeArea` 防止视图顶到状态栏下面</span></span><br><span class="line">        child: SafeArea(</span><br><span class="line">            child: Container(</span><br><span class="line">          child: Text(<span class="string">'Drawer'</span>, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: <span class="number">30.0</span>)),</span><br><span class="line">        )),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    return Scaffold(body: TabChangePage(content: 'Content'));</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终的效果图也不贴了，当手势从左侧滑出或者点击 leading 图标，抽屉就出来了</p><h3 id="5、AppBar-bottomNavigationBar"><a href="#5、AppBar-bottomNavigationBar" class="headerlink" title="5、AppBar - bottomNavigationBar"></a>5、AppBar - bottomNavigationBar</h3><p>bottomNavigarionBar 可以传入一个 BottomNavigationBar 实例，BottomNavigationBar 需要传入 BottomNavigationBarItem 列表作为 items ，但是这边为了实现一个 bottomNavigationBar 和 floatingActionButton 一个特殊的组合效果，我们不使用 BottomNavigationBar，换做 BottomAppBar，直接上代码吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">/// 一样的代码省略....</span></span><br><span class="line">      bottomNavigationBar: BottomAppBar(</span><br><span class="line">        shape: CircularNotchedRectangle(),</span><br><span class="line">        child: Row(</span><br><span class="line">          mainAxisSize: MainAxisSize.max,</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            IconButton(icon: Icon(Icons.android, size: <span class="number">30.0</span>, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;),</span><br><span class="line">            IconButton(icon: Icon(Icons.people, size: <span class="number">30.0</span>, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton:</span><br><span class="line">          FloatingActionButton(onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'Add'</span>), child: Icon(Icons.add, color: Colors.white)),</span><br><span class="line">      <span class="comment">// FAB 的位置，一共有 7 中位置可以选择，centerDocked, endDocked, centerFloat, endFloat, endTop, startTop, miniStartTop，这边选择悬浮在 dock</span></span><br><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>最终的效果图</p><p><img src="/Users/zm/Library/Application Support/typora-user-images/image-20190425161447777.png" alt="image-20190425161447777"></p><p>既然提到了 StatefulWidget，顺带提下两种比较简单的部件，也算是基础部件吧。CheckBox、CheckboxListTile，Switch、SwitchListTile 因为比较简单，就直接上代码了，里面都有完整的注释</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckSwitchDemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CheckSwitchDemoPageState createState() =&gt; _CheckSwitchDemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CheckSwitchDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CheckSwitchDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _isChecked = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">var</span> _isTitleChecked = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">var</span> _isOn = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">var</span> _isTitleOn = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Check Switch Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(children: &lt;Widget&gt;[</span><br><span class="line">        Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Checkbox(</span><br><span class="line">              <span class="comment">// 是否开启三态</span></span><br><span class="line">              tristate: <span class="keyword">true</span>,</span><br><span class="line">              <span class="comment">// 控制当前 checkbox 的开启状态</span></span><br><span class="line">              value: _isChecked,</span><br><span class="line">              <span class="comment">// 不设置该方法，处于不可用状态</span></span><br><span class="line">              onChanged: (checked) &#123;</span><br><span class="line">                <span class="comment">// 管理状态值</span></span><br><span class="line">                setState(() =&gt; _isChecked = checked);</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="comment">// 选中时的颜色</span></span><br><span class="line">              activeColor: Colors.pink,</span><br><span class="line">              <span class="comment">// 这个值有 padded 和 shrinkWrap 两个值，</span></span><br><span class="line">              <span class="comment">// padded 时候所占有的空间比 shrinkWrap 大，别的原谅我没看出啥</span></span><br><span class="line">              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,</span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 点击无响应</span></span><br><span class="line">            Checkbox(value: _isChecked, onChanged: <span class="keyword">null</span>, tristate: <span class="keyword">true</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Switch(</span><br><span class="line">                <span class="comment">// 开启时候，那个条的颜色</span></span><br><span class="line">                activeTrackColor: Colors.yellow,</span><br><span class="line">                <span class="comment">// 关闭时候，那个条的颜色</span></span><br><span class="line">                inactiveTrackColor: Colors.yellow[<span class="number">200</span>],</span><br><span class="line">                <span class="comment">// 设置指示器的图片，当然也有 color 可以设置</span></span><br><span class="line">                activeThumbImage: AssetImage(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">                inactiveThumbImage: AssetImage(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">                <span class="comment">// 开始时候的颜色，貌似会被 activeTrackColor 顶掉</span></span><br><span class="line">                activeColor: Colors.pink,</span><br><span class="line">                materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,</span><br><span class="line">                value: _isOn,</span><br><span class="line">                onChanged: (onState) &#123;</span><br><span class="line">                  setState(() =&gt; _isOn = onState);</span><br><span class="line">                &#125;),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 点击无响应</span></span><br><span class="line">            Switch(value: _isOn, onChanged: <span class="keyword">null</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        CheckboxListTile(</span><br><span class="line">          <span class="comment">// 描述选项</span></span><br><span class="line">          title: Text(<span class="string">'Make this item checked'</span>),</span><br><span class="line">          <span class="comment">// 二级描述</span></span><br><span class="line">          subtitle: Text(<span class="string">'description...description...\ndescription...description...'</span>),</span><br><span class="line">          <span class="comment">// 和 checkbox 对立边的部件，例如 checkbox 在头部，则 secondary 在尾部</span></span><br><span class="line">          secondary: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">30.0</span>, height: <span class="number">30.0</span>),</span><br><span class="line">          value: _isTitleChecked,</span><br><span class="line">          <span class="comment">// title 和 subtitle 是否为垂直密集列表中一员，最明显就是部件会变小</span></span><br><span class="line">          dense: <span class="keyword">true</span>,</span><br><span class="line">          <span class="comment">// 是否需要使用 3 行的高度，该值为 true 时候，subtitle 不可为空</span></span><br><span class="line">          isThreeLine: <span class="keyword">true</span>,</span><br><span class="line">          <span class="comment">// 控制 checkbox 选择框是在前面还是后面</span></span><br><span class="line">          controlAffinity: ListTileControlAffinity.leading,</span><br><span class="line">          <span class="comment">// 是否将主题色应用到文字或者图标</span></span><br><span class="line">          selected: <span class="keyword">true</span>,</span><br><span class="line">          onChanged: (checked) &#123;</span><br><span class="line">            setState(() =&gt; _isTitleChecked = checked);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        SwitchListTile(</span><br><span class="line">            title: Text(<span class="string">'Turn On this item'</span>),</span><br><span class="line">            subtitle: Text(<span class="string">'description...description...\ndescription...description...'</span>),</span><br><span class="line">            secondary: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">30.0</span>, height: <span class="number">30.0</span>),</span><br><span class="line">            isThreeLine: <span class="keyword">true</span>,</span><br><span class="line">            value: _isTitleOn,</span><br><span class="line">            selected: <span class="keyword">true</span>,</span><br><span class="line">            onChanged: (onState) &#123;</span><br><span class="line">              setState(() =&gt; _isTitleOn = onState);</span><br><span class="line">            &#125;)</span><br><span class="line">      ]),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/1.gif" alt=""></p><p><em>该部分代码查看 checkbox_swicth_main.dart 文件</em></p><p>终于这节把 <code>Scaffold</code> 留下的坑都填完了，然后又讲了两种基础部件，下节要填留下的别的坑了，目测还留了 2 个大坑，那就等以后继续解决吧~</p><p>最后代码的地址还是要的：</p><ol><li>文章中涉及的代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_arts_demos_app" target="_blank" rel="noopener">demos</a></li><li>基于郭神 <code>cool weather</code> 接口的一个项目，实现 <code>BLoC</code> 模式，实现状态管理：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather" target="_blank" rel="noopener">flutter_weather</a></li><li>一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_shop" target="_blank" rel="noopener">flutter_shop</a></li></ol><p>作者：Kuky_xs</p><p>链接：<a href="https://www.jianshu.com/p/9119a1c1a123" target="_blank" rel="noopener">https://www.jianshu.com/p/9119a1c1a123</a></p><p>来源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇讲完 Flutter 中的一些基本部件，这篇就先填完上篇留下的没写的 AppBar 的坑，以及 Scaffold 其他参数的使用，在开始前，先补一张缩略版的脑图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425155737.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(二)基础部件</title>
    <link href="http://yoursite.com/posts/88b946ec.html"/>
    <id>http://yoursite.com/posts/88b946ec.html</id>
    <published>2019-04-24T09:17:10.000Z</published>
    <updated>2019-05-22T03:02:25.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要包括 MaterialApp、Scaffold、Text、Image、Icon、Button 以及 AppBar 部分内容，准备出发~</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162620.png" alt=""></p><p>​                            看完这篇文章你就在知道怎么写以上效果了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162652.png" alt=""></p><a id="more"></a><h3 id="1、Flutter-runApp"><a href="#1、Flutter-runApp" class="headerlink" title="1、Flutter runApp"></a>1、Flutter runApp</h3><p>新建 flutter 项目后，可以看到 lib 下的 main.dart 中 void main() =&gt; runApp(MyApp());这句就是程序的入口了。这里可以简单看下源码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///....</span></span><br><span class="line"><span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">  <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">    WidgetsFlutterBinding();</span><br><span class="line">  <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///....</span></span><br><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">    container: renderView,</span><br><span class="line">    debugShortDescription: <span class="string">'[root]'</span>,</span><br><span class="line">    child: rootWidget</span><br><span class="line">  ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会创建一个 WidgetsBinding 单例对象，然后把传入的 App 添加到 rootWidget中，scheduleWarmUpFrame 方法比较长，这边看下对该方法的注释第一句就能了解方法的主要功能了</p><p><code>Schedule a frame to run as soon as possible</code></p><p>「安排框架尽快运行起来」(原谅我这渣英语，只能看懂不会翻译..大概就是「快速启动框架」的意思吧)</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162708.png" alt=""></p><h3 id="2、Flutter-App"><a href="#2、Flutter-App" class="headerlink" title="2、Flutter App"></a>2、Flutter App</h3><p>接着看下 MyApp 这个类，继承自 StatelessWidget 并在 build 方法返回一个 MaterialApp 实例，(偷偷讲下，其实这边还可以返回 CupertinoApp，这是一个 iOS 风格的 widget，基本上你看到部件带 「Cupertino」的都是 iOS 风格的 widget，这里先不讲 iOS 风格的部件，目前 flutter 对 Cupertino 系列的 widget 支持不是很好，包括部件的广度，多语言的支持等等方面都不是很友好，所以我们还是继续看 MD 风格的 Android 部件吧~)，这里先看下 MaterialApp 的构造函数，介绍一些常用的参数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialApp(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">    <span class="keyword">this</span>.home, <span class="comment">// 主界面的内容 widget</span></span><br><span class="line">    <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;, <span class="comment">// 带 router 和路由跳转有关</span></span><br><span class="line">    <span class="keyword">this</span>.initialRoute,</span><br><span class="line">    <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">    <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">    <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[], </span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">''</span>, <span class="comment">// *类似标题</span></span><br><span class="line">    <span class="keyword">this</span>.onGenerateTitle, <span class="comment">// 主要用于多语言情况下，需要根据当前语言替换 title，需要使用该值</span></span><br><span class="line">    <span class="keyword">this</span>.color, <span class="comment">// 主题色，如果该值未设置，取 theme.primaryColor,未设置 theme 则取蓝色</span></span><br><span class="line">    <span class="keyword">this</span>.theme, <span class="comment">// App 的主题风格，包括主题色，按钮默认颜色等等</span></span><br><span class="line">    <span class="keyword">this</span>.locale, <span class="comment">// 带 locale 的和多语言适配相关</span></span><br><span class="line">    <span class="keyword">this</span>.localizationsDelegates,</span><br><span class="line">    <span class="keyword">this</span>.localeListResolutionCallback,</span><br><span class="line">    <span class="keyword">this</span>.localeResolutionCallback,</span><br><span class="line">    <span class="keyword">this</span>.supportedLocales = <span class="keyword">const</span> &lt;Locale&gt;[Locale(<span class="string">'en'</span>, <span class="string">'US'</span>)],</span><br><span class="line">    <span class="keyword">this</span>.debugShowMaterialGrid = <span class="keyword">false</span>, </span><br><span class="line">    <span class="keyword">this</span>.showPerformanceOverlay = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.checkerboardRasterCacheImages = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.checkerboardOffscreenLayers = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.showSemanticsDebugger = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.debugShowCheckedModeBanner = <span class="keyword">true</span>, <span class="comment">// debug 模式下，是否显示 DEBUG 标示横幅</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>MaterialApp 继承自 StatefulWidget，它和 MyApp 所继承的类 StatelessWidget，就是日常开发中，自定义部件通常继承的抽象类了。</p><ul><li>StatelessWidget 是状态不可变部件，通过其构建的部件一般用来展示固定内容，例如需要展示固定的功能按钮列表，不需要根据不同界面状态进行修改其展示内容</li><li>StatefulWidget 是可改变状态的部件，比如我们需要通过网络或者数据库获取数据，然后修改部件锁展示的数据内容，则需要通过 StatefulWidget 来构建。当然，不是说 StatelessWidget 不能实现修改界面数据的功能，这就需要涉及到 状态管理 的概念了，后面有机会再讲，这边先埋坑【坑1】</li></ul><h3 id="3、Flutter-Scaffold"><a href="#3、Flutter-Scaffold" class="headerlink" title="3、Flutter Scaffold"></a>3、Flutter Scaffold</h3><p>进入 App 后就需要构建界面了，Flutter 提供了 Scaffold 来快速构建一个 MaterialDesign 风格的界面，还是先看下 Scaffold 的构造函数吧，了解几个比较常用的部分。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scaffold(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.appBar, <span class="comment">// 界面顶部的那条栏，这边需要返回一个 AppBar 实例</span></span><br><span class="line">    <span class="keyword">this</span>.body, <span class="comment">// 界面的内容部分</span></span><br><span class="line">    <span class="keyword">this</span>.floatingActionButton, <span class="comment">// 悬浮部分，可以通过 floatingActionButtonLocation 设置位置</span></span><br><span class="line">    <span class="keyword">this</span>.floatingActionButtonLocation,</span><br><span class="line">    <span class="keyword">this</span>.floatingActionButtonAnimator,</span><br><span class="line">    <span class="keyword">this</span>.persistentFooterButtons,</span><br><span class="line">    <span class="keyword">this</span>.drawer, <span class="comment">// 侧滑抽屉部分，从左侧滑出(应该和语言有关，和文字方向同向)</span></span><br><span class="line">    <span class="keyword">this</span>.endDrawer, <span class="comment">// 侧滑抽屉部分，从右侧滑出</span></span><br><span class="line">    <span class="keyword">this</span>.bottomNavigationBar, <span class="comment">// 底部导航栏，就是通常看到的底部 TAB 切换部件</span></span><br><span class="line">    <span class="keyword">this</span>.bottomSheet, <span class="comment">// 展示从底部弹出的，起到提示作用的，通过 showModalBottomSheet 展示</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor, <span class="comment">// 界面的背景色</span></span><br><span class="line">    <span class="keyword">this</span>.resizeToAvoidBottomPadding = <span class="keyword">true</span>, <span class="comment">// 避免 body 被底部弹出部件填充，例如输入法键盘</span></span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>, <span class="comment">// 当前的 Scaffold 是否需要被展示在屏幕最上层</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>来张图吧，简洁明了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162756.png" alt=""></p><p>了解完 Scaffold 的整体构造后，我们从上到下，通过构造函数来了解下各个 Widget的使用方法</p><h3 id="4、AppBar"><a href="#4、AppBar" class="headerlink" title="4、AppBar"></a>4、AppBar</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.leading, <span class="comment">// 用于设置 AppBar 前置的按钮，例如设置返回我们需要的返回按钮等</span></span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>, <span class="comment">// 是否使用系统默认生成的按钮，如果替换 leading 的默认按钮，最好将该属性设置成 false</span></span><br><span class="line">    <span class="keyword">this</span>.title, <span class="comment">// AppBar 所需要展示的组件，传入一个 Widget 实例，通常使用 Text 展示一个标题</span></span><br><span class="line">    <span class="keyword">this</span>.actions, <span class="comment">// AppBar 末尾悬浮的一些操作组件，例如常见的会在末尾设置一个「...」按钮，点击弹出一个 menue 提供给用户操作选择</span></span><br><span class="line">    <span class="keyword">this</span>.flexibleSpace, <span class="comment">// AppBar 的背景，可以设置颜色，背景图等等 </span></span><br><span class="line">    <span class="keyword">this</span>.bottom, <span class="comment">// bottom 用于展示顶部导航 TAB</span></span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">4.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor, <span class="comment">// AppBar 的背景色，如果只需要修改颜色，可以不通过 flexibleSpace 修改</span></span><br><span class="line">    <span class="keyword">this</span>.brightness,</span><br><span class="line">    <span class="keyword">this</span>.iconTheme, <span class="comment">// 按钮的默认样式</span></span><br><span class="line">    <span class="keyword">this</span>.textTheme, <span class="comment">// 文字的默认样式</span></span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.centerTitle, <span class="comment">// 是否将展示的 title 居中</span></span><br><span class="line">    <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing, <span class="comment">// AppBar title 两侧的空白间隔</span></span><br><span class="line">    <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在展示 AppBar 的 demo 之前，我们先学习几个基本的组件 Text、Image、Icon、Button 分布用于展示文字，图片，图标，按钮</p><h3 id="5、Text"><a href="#5、Text" class="headerlink" title="5、Text"></a>5、Text</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text(<span class="keyword">this</span>.data, &#123; <span class="comment">// Text 需要展示的文字</span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.style, <span class="comment">// 文字的样式，包括颜色，大小，间距等等属性，这边就不继续展示 TextStyle 构造函数了，不然我怕大家都不想继续看了，稍后通过例子来说明</span></span><br><span class="line">    <span class="keyword">this</span>.textAlign, <span class="comment">// 文字的对齐方式，包括左对齐，右对齐，居中等，详见 TextAlign 类</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection, <span class="comment">// 文字方向，ltr(left to right) 或者 rtl(right to left)</span></span><br><span class="line">    <span class="keyword">this</span>.locale, </span><br><span class="line">    <span class="keyword">this</span>.softWrap, <span class="comment">// 当文字一行显示不完是否换行</span></span><br><span class="line">    <span class="keyword">this</span>.overflow, <span class="comment">// 如果超出限制的行数，以哪种方式省略未展示的内容</span></span><br><span class="line">    <span class="keyword">this</span>.textScaleFactor, <span class="comment">// 文字缩放比例</span></span><br><span class="line">    <span class="keyword">this</span>.maxLines, <span class="comment">// 最多展示的行数</span></span><br><span class="line">    <span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>说了那么多，相信很多小伙伴都要急着撸代码了吧，接着来展示一些 Text 的示例，接下来的例子都会直接替换 HomePage 内的展示内容，其余都是相同的，接下来请关注 Text 别的部件先忽略，后面会介绍，这边先埋坑【坑2】</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(DemoApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      theme: ThemeData(primarySwatch: Colors.lightBlue),</span><br><span class="line">      home: HomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(),</span><br><span class="line">        body: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">10.0</span>),</span><br><span class="line">          child: Center(</span><br><span class="line">              child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(<span class="string">'绿色背景黑色文字展示'</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                      color: Colors.black, <span class="comment">// 设置文字颜色，不可和 foreground 同时设置</span></span><br><span class="line">                      fontSize: <span class="number">24.0</span>, <span class="comment">// 字体大小</span></span><br><span class="line">                      letterSpacing: <span class="number">2.0</span>, <span class="comment">// 每个字符之间的间隔</span></span><br><span class="line">                      background: Paint()..color = Colors.green)), <span class="comment">// 背景色</span></span><br><span class="line">              Text(<span class="string">'这是一个带红色下划线的文字展示'</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                      color: Colors.black,</span><br><span class="line">                      fontSize: <span class="number">24.0</span>,</span><br><span class="line">                      <span class="comment">// 文字装饰线，除了 underline 还有 overline, lineThrough，</span></span><br><span class="line">                      <span class="comment">// 不同的样式小伙伴可以通过自己修改代码来查看</span></span><br><span class="line">                      decoration: TextDecoration.underline,</span><br><span class="line">                      <span class="comment">// 文字装饰线的类型，除了 solid 还有 double,dotted,dashed,wavy 可选</span></span><br><span class="line">                      decorationStyle: TextDecorationStyle.solid,</span><br><span class="line">                      <span class="comment">// 装饰线的颜色</span></span><br><span class="line">                      decorationColor: Colors.red))</span><br><span class="line">            ],</span><br><span class="line">          )),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看源码 text_main.dart 文件</p><p>最后的展示效果如下图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162845.png" alt=""></p><h3 id="6、Image"><a href="#6、Image" class="headerlink" title="6、Image"></a>6、Image</h3><p>按照惯例，我们还是先看下 Image 的构造函数吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Image(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 一个 ImageProvider 实例，但是 ImageProvider 是一个抽象类，Flutter 已经给我们提供如下</span></span><br><span class="line">    <span class="comment">// AssetImage，NetworkImage，FileImage，MemoryImage 这四种图片加载器，为了方便调用</span></span><br><span class="line">    <span class="comment">// 我们可以直接通过 Image.asset, Image.network, Image.file, Image.memory 简化，</span></span><br><span class="line">    <span class="comment">// 通过方法名，可以看出分别从 asset 文件，网络，文件，内存中加载图片</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.image, </span><br><span class="line">    <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">    <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.width, <span class="comment">// 图片宽度</span></span><br><span class="line">    <span class="keyword">this</span>.height, <span class="comment">// 图片高度</span></span><br><span class="line">    <span class="keyword">this</span>.color, <span class="comment">// 图片背景色</span></span><br><span class="line">    <span class="keyword">this</span>.colorBlendMode, <span class="comment">// color 和图片的混合模式(这个值比较多，可以一个个尝试)</span></span><br><span class="line">    <span class="keyword">this</span>.fit, <span class="comment">// 图片填充方式 fill, cover, contain, fillWidth, fillHeight, scaleDown, none</span></span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center, <span class="comment">// 对齐方式</span></span><br><span class="line">    <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat, <span class="comment">// 若未填充满空间，重复展示的方式</span></span><br><span class="line">    <span class="keyword">this</span>.centerSlice,</span><br><span class="line">    <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>好了好了，我知道你们又想自己写代码尝试下了，在这之前，需要你先准备一张本地图片，然后在项目的根目录，也就是 lib 文件夹同层，创建一个新的文件夹，命名为 images，把你准备好的图片放到这个目录下。放好之后打开 pubspec.yaml 把图片资源文件注册下</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># The following section <span class="keyword">is</span> specific to Flutter.</span><br><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font <span class="keyword">is</span></span><br><span class="line">  # included <span class="keyword">with</span> your application, so that you can use the icons <span class="keyword">in</span></span><br><span class="line">  # the material Icons <span class="class"><span class="keyword">class</span>.</span></span><br><span class="line"><span class="class">  <span class="title">uses</span>-<span class="title">material</span>-<span class="title">design</span>: <span class="title">true</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  # 这边注册资源文件，以后有图片文件也可以只注册 <span class="title">images</span> 文件夹，会自动读取内部的文件</span></span><br><span class="line"><span class="class">  <span class="title">assets</span>:</span></span><br><span class="line"><span class="class">    - <span class="title">images</span>/<span class="title">ali</span>.<span class="title">jpg</span></span></span><br></pre></td></tr></table></figure><p>注册完成后，就可以继续愉快的撸代码了~</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _assetAli = <span class="string">'images/ali.jpg'</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _picUrl =</span><br><span class="line">      <span class="string">'https://timg05.bdimg.com/timg?wapbaike&amp;quality=60&amp;size=b1440_952&amp;cut_x=143&amp;cut_y=0&amp;cut_w=1633&amp;'</span></span><br><span class="line">      <span class="string">'cut_h=1080&amp;sec=1349839550&amp;di=cbbc175a45ccec5482ce2cff09a3ae34&amp;'</span></span><br><span class="line">      <span class="string">'src=http://imgsrc.baidu.com/baike/pic/item/4afbfbedab64034f104872baa7c379310b551d80.jpg'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(),</span><br><span class="line">        body: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">10.0</span>),</span><br><span class="line">          child: Center(</span><br><span class="line">              child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              <span class="comment">// 这种展示图片方式和下一种会有相同的效果</span></span><br><span class="line">              Image(image: AssetImage(_assetAli), width: <span class="number">80.0</span>, height: <span class="number">80.0</span>),</span><br><span class="line">              <span class="comment">// 接下来加载图片都会使用这些比较方便的方法</span></span><br><span class="line">              Image.asset(_assetAli, width: <span class="number">80.0</span>, height: <span class="number">80.0</span>),</span><br><span class="line">              <span class="comment">// 加载一张网络图片</span></span><br><span class="line">              Image.network(_picUrl,</span><br><span class="line">                  height: <span class="number">80.0</span>,</span><br><span class="line">                  <span class="comment">// 横向重复</span></span><br><span class="line">                  repeat: ImageRepeat.repeatX,</span><br><span class="line">                  <span class="comment">// MediaQuery.of(context).size 获取到的为上层容器的宽高</span></span><br><span class="line">                  width: MediaQuery.of(context).size.width),</span><br><span class="line">              <span class="comment">// 通过设置混合模式，可以看到图片展示的样式已经修改</span></span><br><span class="line">              Image.asset(_assetAli,</span><br><span class="line">                  width: <span class="number">80.0</span>, height: <span class="number">80.0</span>, color: Colors.green, colorBlendMode: BlendMode.colorDodge),</span><br><span class="line">              <span class="comment">// 会优先加载指定的 asset 图片，然后等网络图片读取成功后加载网络图片，会通过渐隐渐现方式展现</span></span><br><span class="line">              <span class="comment">// cover 方式按照较小的边布满，较大的给切割</span></span><br><span class="line">              <span class="comment">// contain 会按照最大的边布满，较小的会被留白</span></span><br><span class="line">              <span class="comment">// fill 会把较大的一边压缩</span></span><br><span class="line">              <span class="comment">// fitHeight, fitWidth 分别按照长宽来布满</span></span><br><span class="line">              FadeInImage.assetNetwork(</span><br><span class="line">                  placeholder: _assetAli, image: _picUrl, width: <span class="number">120.0</span>, height: <span class="number">120.0</span>, fit: BoxFit.cover),</span><br><span class="line">              <span class="comment">// Icon 相对属性少了很多，需要传入一个 IconData 实例，flutter 提供了很多图标，</span></span><br><span class="line">              <span class="comment">// 但是实际情况我们需要加入我们自己的图标，这边再埋坑【坑3】</span></span><br><span class="line">              <span class="comment">// size 为图标显示的大小，color 为图标的颜色，这边通过 Theme 获取主题色调</span></span><br><span class="line">              Icon(Icons.android, size: <span class="number">40.0</span>, color: Theme.of(context).primaryColorDark)</span><br><span class="line">            ],</span><br><span class="line">          )),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看源码 image_main.dart 文件</p><p>最后的效果如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162908.png" alt=""></p><h3 id="7、Button"><a href="#7、Button" class="headerlink" title="7、Button"></a>7、Button</h3><p>Flutter 提供了各种类型的 Button 几乎是大同小异的，这边就抽取一些比较常用的展示下效果，常用的主要有 RaisedButton 、FlatButton、IconButton、OutlineButton、MaterialButton、FloatActionButton、FloatingActionButton.extended</p><p>Button 都有一个 onPress 参数，是 VoidCallback 类型的参数，通过查看源码可以知道 VoidCallback 是无参无返回值的一种类型参数。如果该参数传入的值为 null 那么这个按钮的就不可点击状态，无点击效果，等会可以在例子中查看。还有就是 child 参数，这里就是传入你需要展示的内容，比如 Text、Icon 等等。别的参数基本可以通过参数名了解，这边不扩展了(再看源码我怕你们都不想继续看下去了…)</p><p><code>Talk is cheap, show me the code</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">10.0</span>),</span><br><span class="line">        child: Center(</span><br><span class="line">            child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'This is a Rased Button can be clicked'</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">'Raised Enable'</span>),</span><br><span class="line">            ),</span><br><span class="line">            RaisedButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Raised Disable'</span>)),</span><br><span class="line">            FlatButton(</span><br><span class="line">              onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'This is a Flat Button can be clicker'</span>),</span><br><span class="line">              child: Text(<span class="string">'Flat Enable'</span>),</span><br><span class="line">            ),</span><br><span class="line">            FlatButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Flat Disable'</span>)),</span><br><span class="line">            IconButton(icon: Icon(Icons.android), onPressed: () &#123;&#125;),</span><br><span class="line">            IconButton(icon: Icon(Icons.android), onPressed: <span class="keyword">null</span>),</span><br><span class="line">            MaterialButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Material Enable'</span>)),</span><br><span class="line">            MaterialButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Material Disable'</span>)),</span><br><span class="line">            OutlineButton(onPressed: () &#123;&#125;, child: Text(<span class="string">'Outline Enable'</span>)),</span><br><span class="line">            OutlineButton(onPressed: <span class="keyword">null</span>, child: Text(<span class="string">'Outline Enable'</span>)),</span><br><span class="line">          ],</span><br><span class="line">        )),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton:</span><br><span class="line">          FloatingActionButton.extended(onPressed: () &#123;&#125;, icon: Icon(Icons.android), label: Text(<span class="string">'Android'</span>)),</span><br><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分代码查看源码 button_main.dart 部分</p><p>最终的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163010.png" alt=""></p><p>这篇终于到末尾了，最后留了 3 个坑等以后解决</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425163039.png" alt=""></p><p>文章 demo 的地址：<a href="https://github.com/kukyxs/flutter_arts_demos_app" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_arts_demos_app</a></p><p>一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：<a href="https://github.com/kukyxs/flutter_shop" target="_blank" rel="noopener">https://github.com/kukyxs/flutter_shop</a></p><p>如果对你有帮助的话，记得给个 Star，先谢过，你的认可就是支持我继续写下去的动力~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要包括 MaterialApp、Scaffold、Text、Image、Icon、Button 以及 AppBar 部分内容，准备出发~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162620.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                            看完这篇文章你就在知道怎么写以上效果了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190425162652.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(一)Dart</title>
    <link href="http://yoursite.com/posts/6114f592.html"/>
    <id>http://yoursite.com/posts/6114f592.html</id>
    <published>2019-04-24T08:22:52.000Z</published>
    <updated>2019-05-22T03:02:05.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近 Flutter 真心火爆到不要不要的，随大流，学一波，在这之前，对于语言的语法还是需要有些必要的了解的，<strong>Dart</strong> 这门语言，说实话对于会 Java 这类面向对象的语言的小伙伴们来说，真的灰常灰常简单，这边我总结了一些 Dart 和 Java 的一些语法差异，当然，只是部分，但是，按照我目前的学习进度来说，了解了这些对于写 Flutter 项目绝对够了。小伙伴也可以自己查看，我这边提供一个自己学习的网址 <strong>Dart</strong> 快速入门：<a href="http://dart.goodev.org/guides/language" target="_blank" rel="noopener">http://dart.goodev.org/guides/language</a></p><p>温馨提示：本篇文章没有图，没有图，没有图，可能会造成部分不适，请注意，请注意，请注意，系好安全带，我们要「开车了」……</p><a id="more"></a><h3 id="1、Variables"><a href="#1、Variables" class="headerlink" title="1、Variables"></a>1、Variables</h3><p><strong>Dart</strong> 变量类型可以通过具体的赋值进行推导，例如：var name = ‘kuky’ 则定义了一个 String 类型对象 name，也可以通过指定具体的类型 String name = ‘kuky’，如果没有初始化变量，则默认值为 null，类型为数字的变量默认值同为 null（同 java 不同，java 中 int 默认为 0.）如果需要定义常量，可以通过 final 和 const 进行定义，final 变量只能赋值一次，const 是编译时常量。</p><h3 id="2、Build-in-types"><a href="#2、Build-in-types" class="headerlink" title="2、Build-in-types"></a>2、Build-in-types</h3><p>Dart 内置类型包括 ：</p><ul><li><strong>Numbers</strong>    包括 int[-2^53 ~ 2^53]， double[64-bit 浮点数]</li><li><strong>Strings </strong>   Dart 字符串是 UTF-16 编码的字符序列， 可以使用单引号或者双引号来创建字符串。</li><li>通过 <strong>==</strong> 判断两个字符串是否相同</li><li>通过三对单引号’’’aaa’’’或者双引号”””aaa”””可以创建多行字符串对象</li><li>使用前缀 r 创建 raw string，字符串内不会进行转义，例如：var a = r’haha \n breakLine’ 打印 a 对象则会按照输入的输出，不会进行换行</li><li><strong>Booleans</strong>    Dart 中，只有 true 对象才被认为是 true， 所有其他的值都是 false</li><li><strong>Lists</strong>    列表，例如：var list = [1, 2, 3, 4]</li><li>通过 <strong>const</strong> 关键词可以定义一个不可变列表 var list = const [1, 2, 3, 4]</li><li>参数化定义<strong>var</strong> name = <string>[‘Jone’, ‘Jack’]</string></li><li><strong>Maps</strong>    键值对，例如：var map = {‘one’: 1, ‘two’: 2}</li><li>如果键值对需要添加新的键值对，直接指定即可，map[‘three’] = 3，若查找的键不存在，返回 null</li><li>参数化定义 var map = &lt;String, int&gt;{‘one’: 1, ‘two’: 2}</li><li><strong>Runes</strong>    代表字符串的 UTF-32 code points，通常使用 \uXXXX 的方式来表示 Unicode code point， XXXX 是4个 16 进制的数，例如 \u2665 返回心形符号 ()</li><li><strong>Symbols</strong>    代表 Dart 程序中声明的操作符或者标识符，几乎不使用</li></ul><h3 id="3、Function"><a href="#3、Function" class="headerlink" title="3、Function"></a>3、Function</h3><p>函数方法的可选参数通过在参数列表中用 {} 指定，例如：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> say(<span class="built_in">String</span> name, &#123;<span class="built_in">String</span> word = <span class="string">'hello'</span>&#125;)&#123;    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">'$name say $word'</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过（可选参数名 + :）进行可选参数的赋值</span></span><br><span class="line">main()&#123;    </span><br><span class="line">say(<span class="string">'zm'</span>, word: <span class="string">'Hello World'</span>); <span class="comment">// kuky say Hello World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>word 参数为可选参数，默认值为 hello</p><h3 id="4、Operators"><a href="#4、Operators" class="headerlink" title="4、Operators"></a>4、Operators</h3><p>操作符几乎和别的语言类似，提个比较特殊的赋值操作符 ??= 和 ?.操作符</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b ?? = a; <span class="comment">// 如果 b 的值是 null 则将 a 赋值给 b，否则保持不变</span></span><br><span class="line"><span class="keyword">var</span> c = size?.x; <span class="comment">// 如果 size 为 null 则返回 null，否则返回 size.a 的值</span></span><br></pre></td></tr></table></figure><h3 id="5、Conditional-Expressions"><a href="#5、Conditional-Expressions" class="headerlink" title="5、Conditional Expressions"></a>5、Conditional Expressions</h3><p>Dart 可以通过两个特殊的操作符替换 if(){} else{} 表达式</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// condition? expr1: expr2 同 java 三目运算符</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">if</span>(a &lt; <span class="number">0</span>) -a : a</span><br><span class="line"><span class="comment">/// expr1 ?? expr2 </span></span><br><span class="line"><span class="built_in">String</span> toString() =&gt; msg ?? <span class="keyword">super</span>.toString() <span class="comment">// 如果 expr1 不为 null 则返回 expr1 否则返回 expr</span></span><br></pre></td></tr></table></figure><h3 id="6、Cascade-Notaion"><a href="#6、Cascade-Notaion" class="headerlink" title="6、Cascade Notaion(..)"></a>6、Cascade Notaion(..)</h3><p>级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span></span>&#123;</span><br><span class="line">    <span class="built_in">double</span> x;</span><br><span class="line">    <span class="built_in">double</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Size&#123;x: $x, y: $y&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size = Size();</span><br><span class="line"><span class="comment">/// 通过级联操作符进行赋值，可以更加简洁，!!如果函数返回值为 void 则不能进行级联!!</span></span><br><span class="line"><span class="built_in">print</span>(size</span><br><span class="line">      ..x = <span class="number">10</span></span><br><span class="line">      ..y = <span class="number">100</span></span><br><span class="line">      ..toString()); <span class="comment">/// 输出 Size&#123;x: 10.0, y: 100.0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="7、foreach"><a href="#7、foreach" class="headerlink" title="7、foreach"></a>7、foreach</h3><p>通过 foreach 循环遍历一个实现 Iterable 接口的对象</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> maps = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">items.where((i) =&gt; i &gt; <span class="number">2</span>).forEach((i) =&gt; <span class="built_in">print</span>(i));  <span class="comment">// 3, 4, 5</span></span><br><span class="line">maps.forEach((key, value) =&gt; <span class="built_in">print</span>(<span class="string">'$key =&gt; $value'</span>)); <span class="comment">// a =&gt; 1, b =&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="8、Switch-and-case"><a href="#8、Switch-and-case" class="headerlink" title="8、Switch and case"></a>8、Switch and case</h3><p>如果需要实现继续到下一个 case 语句中继续执行，则可以 使用 continue 语句跳转到对应的标签处继续执行</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'Close'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command.toLowerCase()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'close'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'close'</span>);</span><br><span class="line">    <span class="keyword">continue</span> open;</span><br><span class="line">        </span><br><span class="line">  open: <span class="comment">// 这是个标签</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'open'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'open'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、Assert"><a href="#9、Assert" class="headerlink" title="9、Assert"></a>9、Assert</h3><p>如果条件表达式结果不满足需要，则可以使用 assert 语句俩打断代码的执行，例如：assert(a == 1);</p><h3 id="10、Exceptions"><a href="#10、Exceptions" class="headerlink" title="10、Exceptions"></a>10、Exceptions</h3><p>所有的 Dart 异常是非检查异常。捕捉 exceptions 的时候可以通过 on 指定 exceptions 类型，再使用 catch 捕获</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: $e'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e, s) &#123; <span class="comment">// 函数 catch 可以带有一个或两个参数，第一个参数为抛出的异常对象，第二个为堆栈信息</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Something really unknown: $e'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Stack trace:\n $s'</span>);</span><br><span class="line">  <span class="keyword">rethrow</span>; <span class="comment">// 通过 rethrow 可以将异常重新抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、Classes"><a href="#11、Classes" class="headerlink" title="11、Classes"></a>11、Classes</h3><p>Dart 中的类都是单继承，但是同时支持 mixin 的继承机制（除 Object 类，每个类都只有一个超类），所有的类都继承于 Object，通过调用 runtimeType 判断实例的类型。每个实例变量都会自动生成一个 getter 方法（隐含的）， Non-final 实例变量还会自动生成一个 setter 方法。</p><p><strong>Constructors</strong></p><p>Dart 的构造函数同 Java 类似</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Size(<span class="built_in">num</span> nx, <span class="built_in">num</span> y)&#123;</span><br><span class="line">    x = nx;</span><br><span class="line">    <span class="keyword">this</span>.y = y; <span class="comment">// this 关键字只有当名字冲突时候使用，否则 Dart 推荐省略 this</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  Size(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y); <span class="comment">// Dart 通过语法糖省略了构造函数的赋值过程，效果同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有定义构造函数，则会有个默认构造函数。默认构造函数没有参数，并且会调用超类的 没有参数的构造函数。子类不会继承超类的构造函数，子类如果没有定义构造函数，则只有一个默认构造函数。</p><p>Dart 通过命名构造函数为类创建多个构造函数，同时指明意图</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Size(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Size.fromJson(<span class="built_in">Map</span> json)&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = json[<span class="string">'x'</span>];</span><br><span class="line">    <span class="keyword">this</span>.y = json[<span class="string">'y'</span>];</span><br><span class="line">  &#125; <span class="comment">// 因为构造函数不能继承，如果希望子类也有超类一样的命名构造函数，必须在子类中实现该构造函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造函数体执行之前除了可以调用超类构造函数之外，还可以初始化实例参数</span></span><br><span class="line">  <span class="comment">// 初始化列表非常适合用来设置 final 变量的值</span></span><br><span class="line">  Size.fromJsonInit(<span class="built_in">Map</span> json)</span><br><span class="line">      : <span class="keyword">this</span>.x = json[<span class="string">'x'</span>],</span><br><span class="line">        <span class="keyword">this</span>.y = json[<span class="string">'y'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量构造函数（如果类需要提供一个状态不变的对象，通过 const 构造函数实现）</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstPoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ConstPoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法构造函数（如果一个类不需要每次都提供一个新的对象，通过 factory 构造函数实现）</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpCore</span> </span>&#123;</span><br><span class="line">  HttpCore._internal();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> HttpCore() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) _instance = HttpCore._internal();</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> HttpCore _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> HttpCore <span class="keyword">get</span> instance =&gt; HttpCore();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _request()&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类都隐式的定义了一个包含所有实例成员的接口， 并且这个类实现了这个接口，通过抽象类实现类似 Java 接口的功能。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">print</span>(<span class="built_in">String</span> msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">print</span>(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mixins  Dart | 什么是Mixin：<a href="https://www.jianshu.com/p/a578bd2c42aa" target="_blank" rel="noopener">https://www.jianshu.com/p/a578bd2c42aa</a></p><h3 id="12、Asynchrony-support"><a href="#12、Asynchrony-support" class="headerlink" title="12、Asynchrony support"></a>12、Asynchrony support</h3><p><strong>Future</strong></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">loopIntegers() &#123;</span><br><span class="line">  <span class="comment">// 通过 then 进行获取到 Future 对象后的操作</span></span><br><span class="line">  getListDelay().then((ints) =&gt; ints.forEach((i) =&gt; <span class="built_in">print</span>(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个 Future 对象</span></span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; getListDelay() &#123;</span><br><span class="line">  <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () =&gt; <span class="built_in">List</span>.generate(<span class="number">10</span>, (delta) =&gt; delta));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 async await 简化 Future 操作</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">runUsingFuture() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  findEntrypoint().then((entrypoint) &#123;</span><br><span class="line">    <span class="keyword">return</span> runExecutable(entrypoint, args);</span><br><span class="line">  &#125;).then(flushThenExit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化了 then</span></span><br><span class="line">runUsingAsyncAwait() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line">  <span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line">  <span class="keyword">await</span> flushThenExit(exitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候要求调用很多异步方法，并且等待 所有方法完成后再继续执行，通过使用 Future.wait() 进行管理</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future deleteDone = deleteLotsOfFiles();</span><br><span class="line">Future copyDone = copyLotsOfFiles();</span><br><span class="line">Future checksumDone = checksumLotsOfOtherFiles();</span><br><span class="line"></span><br><span class="line">Future.wait([deleteDone, copyDone, checksumDone])</span><br><span class="line">    .then((<span class="built_in">List</span> values) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Done with all the long steps'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Stream Dart|什么是 Stream：<a href="https://www.jianshu.com/p/a5d7758938ef" target="_blank" rel="noopener">https://www.jianshu.com/p/a5d7758938ef</a></p><p>大概了解了 Dart 的语法，下节就开始写 Flutter 啦~，环境的安装具体查看官网，很详细 Flutter 环境安装 记得一定要<strong>配置镜像，配置镜像，配置镜像</strong></p><p><a href="https://flutterchina.club/get-started/install/" target="_blank" rel="noopener">https://flutterchina.club/get-started/install/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近 Flutter 真心火爆到不要不要的，随大流，学一波，在这之前，对于语言的语法还是需要有些必要的了解的，&lt;strong&gt;Dart&lt;/strong&gt; 这门语言，说实话对于会 Java 这类面向对象的语言的小伙伴们来说，真的灰常灰常简单，这边我总结了一些 Dart 和 Java 的一些语法差异，当然，只是部分，但是，按照我目前的学习进度来说，了解了这些对于写 Flutter 项目绝对够了。小伙伴也可以自己查看，我这边提供一个自己学习的网址 &lt;strong&gt;Dart&lt;/strong&gt; 快速入门：&lt;a href=&quot;http://dart.goodev.org/guides/language&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dart.goodev.org/guides/language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;温馨提示：本篇文章没有图，没有图，没有图，可能会造成部分不适，请注意，请注意，请注意，系好安全带，我们要「开车了」……&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter开发环境搭建Mac版</title>
    <link href="http://yoursite.com/posts/3223dff5.html"/>
    <id>http://yoursite.com/posts/3223dff5.html</id>
    <published>2019-04-24T03:07:40.000Z</published>
    <updated>2019-05-28T04:10:50.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统环境要求"><a href="#系统环境要求" class="headerlink" title="系统环境要求"></a>系统环境要求</h3><p>Flutter因为是新出的框架，所以对系统还是有一定的要求的。</p><ul><li>MacOS （64-bit）</li><li>磁盘空间：大于700M，如果算上Android Studio等编辑工具，尽量大于3G。</li><li>命令号工具：bash、mkdir、rm、git、curl、unzip、which、brew 这些命令在都可以使用。</li></ul><p>注意：一般你会在brew这个命令下载坑，很多mac系统都没有安装这个，你可以进行安装，因为这个和本知识关系性不大，所以我就不写流程了，如果你出现问题，直接点击链接学习安装就可以了。</p><p>学习安装brew：<a href="https://segmentfault.com/a/1190000013317511" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013317511</a></p><h3 id="下载Flutter-SDK包"><a href="#下载Flutter-SDK包" class="headerlink" title="下载Flutter SDK包"></a>下载Flutter SDK包</h3><p>这里推荐去官网下载就好，我挂了梯子，速度并不慢。</p><p>网址：<a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=macos" target="_blank" rel="noopener">https://flutter.dev/docs/development/tools/sdk/releases?tab=macos</a></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190528111109.png" alt=""></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>压缩包下载好以后，找个位置进行解压。这个位置很重要，因为下面配置环境变量的时候要用到。比如你配置到了根目录下的app文件夹。</p><p>1.打开终端工具（这个我就不用写了吧），使用vim进行配置环境变量，命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure><p>在打开的文件里增加一行代码，意思是配置flutter命令在任何地方都可以使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/app/flutter/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>提示：这行命令你要根据你把压缩包解压的位置来进行编写，写的是你的路径，很有可能不跟文章一样。</p><p>配置完成后，需要用<code>source</code>命令重新加载一下 ，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>完成这部以后，就算我们flutter的安装工作完成了，但是这还不能进行开发。可以使用命令来检测一下，是否安装完成了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flutter -h</span><br></pre></td></tr></table></figure><h3 id="检查开发环境"><a href="#检查开发环境" class="headerlink" title="检查开发环境"></a>检查开发环境</h3><p>到上边为止，我们安装好了Flutter，但是还不具备开发环境。开发还需要很多软件和插件的支持，那到底需要哪些插件和软件那？我们可以使用Flutter为我们提供的命令来进行检查：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190528111601.png" alt=""></p><p>如果你英文很好，你应该可以很容易读出上面的检测结果，有很多条目都没有通过。需要我们安装检测结果一条条进行安装，直到满足开发环境。（如果有[!]x标志，表示本行检测没有通过，就需要我们设置或者安装相应的软件了。）</p><p>如果你有安装，那么第一步要作的是允许协议（android-licenses）。允许方法就是在终端运行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flutter doctor --android-licenses</span><br></pre></td></tr></table></figure><p>然后让你输入Y/N的时候，一路Y就可以了（至于什么意思，我也没仔细看，大概就和安装软件的下一步下一步是一样的，你按N是不能成功的）。</p><p>这不完成后，我们再使用<code>flutter doctor</code>进行检测后，会看到还是有很多x。</p><p>其实大概意思就是我们需要这些软件，Flutter推荐你用brew命令进行安装。</p><p>我们可以直接在终端里输入下列命令（每输完一个都要等一会，等待软件包安装完成）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --HEAD libimobiledevice</span><br><span class="line">brew install ideviceinstaller</span><br><span class="line">brew install ios-deploy</span><br><span class="line">brew install cocoapods</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure><p>安装完这些，我们还需要为Android Studio安装一下Flutter插件（这个有可能你安装过，如果出现下面的提示，说明你还没有安装）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br></pre></td></tr></table></figure><p>打开Android Stuido 软件，然后找到Plugin的配置，搜索Flutter插件。</p><p>点中间的<code>Search in repositories</code>,然后点击安装。</p><p>安装完成后，你需要重新启动一下Android Studio软件。</p><h3 id="Pub源的配置"><a href="#Pub源的配置" class="headerlink" title="Pub源的配置"></a>Pub源的配置</h3><p>如果你没有梯子，一个人人都知道的原因，你还需要在环境变量里配置一下Pub源，不然你是无法进行使用的。</p><p>运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure><p>增加两行配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>重新加载环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="Android-studio新建Flutter项目"><a href="#Android-studio新建Flutter项目" class="headerlink" title="Android studio新建Flutter项目"></a>Android studio新建Flutter项目</h3><p>打开Andorid Studio ，会出现下面的界面，我们选择第二项，新建Flutter项目。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190528113518.png" alt=""></p><p>打开第二个窗口后，选择第一个选项<code>Flutter Application</code>(flutter应用)。</p><p>这步完成后，系统就会自动为我们创建一个Flutter项目</p><h3 id="安装AVD虚拟机"><a href="#安装AVD虚拟机" class="headerlink" title="安装AVD虚拟机"></a>安装AVD虚拟机</h3><ol><li><p>现在需要一个虚拟机来运行我们的程序，可以点击Android Studio中的上方菜单<code>tool</code> -<code>AVD Manager</code>选项。</p></li><li><p>出现新建菜单，选择<code>Create Virtual Device.....</code>,如果你一个虚拟机也没建过，这个选项在对话框的中间<img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190528113803.png" alt=""></p></li><li><p>选择虚拟机类型，这个你随意选就好，我选择的是<code>Nexus 5x</code>。（如果你屏幕小，就选择一个小屏幕的虚拟机）<img src="/Users/zhangmiao/Library/Application Support/typora-user-images/image-20190528113941915.png" alt="image-20190528113941915"></p></li><li><p>选择系统，这里尽量选择最新的，我选择了<code>Android 9.0</code>系统，选择好后，又是一个漫长的等待过程。</p></li><li><p>安装好后，点击开始按钮，运行虚拟机了（第一次运行，需要安装系统，会慢一些），运行起来后，如下图。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190528115821.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190528115944.png" alt=""></p></li></ol><h3 id="让Flutter跑起来"><a href="#让Flutter跑起来" class="headerlink" title="让Flutter跑起来"></a>让Flutter跑起来</h3><p>虚拟机运行以后，可以点击<code>debug</code>按钮，让Flutter程序跑起来。如果你幸运的话，你的Flutter程序经过编译后，就会跑起来了。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190528120632.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系统环境要求&quot;&gt;&lt;a href=&quot;#系统环境要求&quot; class=&quot;headerlink&quot; title=&quot;系统环境要求&quot;&gt;&lt;/a&gt;系统环境要求&lt;/h3&gt;&lt;p&gt;Flutter因为是新出的框架，所以对系统还是有一定的要求的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MacOS （64-bit）&lt;/li&gt;
&lt;li&gt;磁盘空间：大于700M，如果算上Android Studio等编辑工具，尽量大于3G。&lt;/li&gt;
&lt;li&gt;命令号工具：bash、mkdir、rm、git、curl、unzip、which、brew 这些命令在都可以使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：一般你会在brew这个命令下载坑，很多mac系统都没有安装这个，你可以进行安装，因为这个和本知识关系性不大，所以我就不写流程了，如果你出现问题，直接点击链接学习安装就可以了。&lt;/p&gt;
&lt;p&gt;学习安装brew：&lt;a href=&quot;https://segmentfault.com/a/1190000013317511&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000013317511&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载Flutter-SDK包&quot;&gt;&lt;a href=&quot;#下载Flutter-SDK包&quot; class=&quot;headerlink&quot; title=&quot;下载Flutter SDK包&quot;&gt;&lt;/a&gt;下载Flutter SDK包&lt;/h3&gt;&lt;p&gt;这里推荐去官网下载就好，我挂了梯子，速度并不慢。&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://flutter.dev/docs/development/tools/sdk/releases?tab=macos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://flutter.dev/docs/development/tools/sdk/releases?tab=macos&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android面试笔记</title>
    <link href="http://yoursite.com/posts/e9998381.html"/>
    <id>http://yoursite.com/posts/e9998381.html</id>
    <published>2019-04-23T07:02:25.000Z</published>
    <updated>2019-05-16T07:44:23.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p><strong>注册方式：</strong></p><p>1、静态注册 ，在Manifest文件的<code>application</code>节点中配置广播接收者</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyBroadCastReceiver"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">actionandroid:name="android.provider.Telephony.SMS_RECEIVED"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、动态注册，通过<code>Context</code>对象的<code>registerReceiver</code>方法注册广播</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new出上边定义好的BroadcastReceiver</span></span><br><span class="line">MyBroadCastReceiver yBroadCastReceiver = <span class="keyword">new</span> MyBroadCastReceiver();</span><br><span class="line"><span class="comment">//实例化过滤器并设置要过滤的广播  </span></span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>);</span><br><span class="line"><span class="comment">//注册广播   </span></span><br><span class="line">myContext.registerReceiver(smsBroadCastReceiver,intentFilter, </span><br><span class="line">             <span class="string">"android.permission.RECEIVE_SMS"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>区别：静态注册的为常驻型广播，即使应用程序关闭了，如果又信息广播来，程序也会被系统调用执行。而动态注册的广播不是常驻型，广播被取消注册或者应用程序关闭后都不能接收</p></blockquote><p><strong> 广播的两种类型：</strong></p><p>1、有序广播：按照优先级，一级一级向下传递，接收者可以修改广播数据，也可以终止广播事件。</p><p>2、无序广播：所有接收者都会接收事件，不能被拦截跟修改。</p><a id="more"></a><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p><strong>启动</strong></p><p>1、使用<code>Context</code>的<code>startService</code>方法启动</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; onCreate()`---&gt;`onStartCommand()`---&gt;`onDestroy()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>2、使用<code>Context</code>的<code>bindService</code>方法启动</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; onCreate()`---&gt;`onBind()`---&gt;`onUnBind()`---&gt;`onDestroy()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>停止</strong></p><p>1、在外部使用<code>stopService</code>方法，如果使用<code>bindService</code>的方式启动，则使用<code>unbindService</code>方法停止</p><p>2、在<code>Service</code>内部（<code>onStartCommand</code>方法内）使用<code>stopSelf</code></p><p><strong><code>onStartCommand</code></strong>方法的返回值</p><p>1、<code>START_NOT_STICKY</code>：“非粘性的”。使用这个返回值时，如果在执行完<code>onStartCommand</code>方法后，服务被异常kill掉，系统不会自动重启该服务</p><p>2、<code>START_STICKY</code>：如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。</p><p>3、<code>START_REDELIVER_INTENT</code>：重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>继承于<code>Service</code>，启动方式与<code>Service</code>的传统启动方式一样，不同点在于内部有一个线程来处理耗时操作，当任务执行完成时服务会自动停止。</p><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><ul><li><code>standard</code>：标准模式，默认的启动模式，不管是否已经存在实例都会生成新的实例</li><li><code>singleTop</code>：栈顶复用模式，如果发现有对应Activity的实例正位于栈顶，则直接打开此页面，不再生成新的实例，同时<code>onNewIntent</code>方法会被执行，<code>onCreate</code>跟<code>onStart</code>方法都不会执行。否则跟<code>standard</code>模式一样继续生成新的实例。</li><li><code>singleTask</code>：站内复用模式，如果栈内存在对应Activity的实例就会复用这个Activity，复用时会将它上面的Activity全部出栈，同时<code>onNewIntent</code>方法也会被执行。</li><li><code>singleInstance</code>：单例模式，该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</li></ul><h2 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h2><p>app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。</p><blockquote><ol><li><code>Luncher.startActivitySafely()</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class">&gt; <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>, </span></span><br><span class="line"><span class="class">&gt;                     <span class="title">OnLongClickListener</span>, </span></span><br><span class="line"><span class="class">&gt;                     <span class="title">LauncherModel</span>.<span class="title">Callbacks</span>, </span></span><br><span class="line"><span class="class">&gt;                     <span class="title">AllAppsView</span>.<span class="title">Watcher</span> </span>&#123;</span><br><span class="line">&gt;                         </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;         </span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">startActivitySafely</span><span class="params">(Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">&gt; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; startActivity(intent);</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;                         </span><br><span class="line">&gt;     ......</span><br><span class="line">&gt;         </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="2"><li><code>Activity.startActivity</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></span><br><span class="line"><span class="class">&gt; <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks</span> </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">&gt; startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="3"><li><code>Activity.startActivityForResult</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></span><br><span class="line"><span class="class">&gt; <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">&gt; <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks</span> </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; Instrumentation.ActivityResult ar =</span><br><span class="line">&gt; mInstrumentation.execStartActivity(</span><br><span class="line">&gt; <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">&gt; intent, requestCode);</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="4"><li><code>Instrumentation.execStartActivity</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">&gt; IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">&gt; <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">&gt; .startActivity(whoThread, intent,</span><br><span class="line">&gt; intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">&gt; <span class="keyword">null</span>, <span class="number">0</span>, token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">&gt; requestCode, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&gt; ......</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这里的<code>ActivityManagerNative.getDefault</code>返回<code>ActivityManagerService</code>的远程接口，即<code>ActivityManagerProxy</code>接口</p><ol start="5"><li><code>ActivityManagerProxy.startActivity</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span></span><br><span class="line"><span class="class">&gt; </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; String resolvedType, Uri[] grantedUriPermissions, <span class="keyword">int</span> grantedMode,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; IBinder resultTo, String resultWho,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; <span class="keyword">int</span> requestCode, <span class="keyword">boolean</span> onlyIfNeeded,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; <span class="keyword">boolean</span> debug)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">&gt; Parcel data = Parcel.obtain();</span><br><span class="line">&gt; Parcel reply = Parcel.obtain();</span><br><span class="line">&gt; data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">&gt; data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">&gt; intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">&gt; data.writeString(resolvedType);</span><br><span class="line">&gt; data.writeTypedArray(grantedUriPermissions, <span class="number">0</span>);</span><br><span class="line">&gt; data.writeInt(grantedMode);</span><br><span class="line">&gt; data.writeStrongBinder(resultTo);</span><br><span class="line">&gt; data.writeString(resultWho);</span><br><span class="line">&gt; data.writeInt(requestCode);</span><br><span class="line">&gt; data.writeInt(onlyIfNeeded ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&gt; data.writeInt(debug ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&gt; mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">&gt; reply.readException();</span><br><span class="line">&gt; <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">&gt; reply.recycle();</span><br><span class="line">&gt; data.recycle();</span><br><span class="line">&gt; <span class="keyword">return</span> result;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; ......</span><br><span class="line">&gt;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="6"><li><code>ActivityManagerService.startActivity</code></li></ol></blockquote><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context是一个抽象基类，翻译为上下文，也可以理解为环境，提供一些程序运行基础信息。</p><p>Context有两个子类，<code>ContextWrapper</code>是上下文功能的封装类，而 <code>ContextImpl</code> 则是上下文功能的实现类。而 <code>ContextWrapper</code> 又有三个直接的子类， <code>ContextThemeWrapper</code>、<code>Service</code>和<code>Application</code>。其中，<code>ContextThemeWrapper</code>是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由<code>ContextImpl</code>类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p><h2 id="Activity、Window、View三者之间的关系"><a href="#Activity、Window、View三者之间的关系" class="headerlink" title="Activity、Window、View三者之间的关系"></a>Activity、Window、View三者之间的关系</h2><ol><li><code>Activity</code> 构造的时候会初始化一个Window( <code>PhoneWindw</code> )</li><li><code>PhoneWindow</code> 有一个 <code>RootView</code> ，这个<code>RootView</code> 是一个ViewGroup，是最初始的根视图</li><li><code>RootView</code> 通过 <code>addView</code> 方法来一个个添加 <code>View</code></li></ol><h2 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h2><p>View的绘制流程：<code>onMeasure</code> -&gt; <code>onLayout</code> -&gt; <code>onDraw</code></p><p>第一步：<code>onMeasure</code> 测量视图大小，从顶层父View到子View递归调用 <code>measure</code> 方法，<code>measure</code> 方法又回调 <code>onMeasure</code>方法。</p><p>第二步：<code>onLayout</code> 确定View位置，进行页面布局。从顶层父View向子View递归调用 <code>layout</code> 方法的过程，即父View根据上一步 <code>measure</code> 得到的布局大小和布局参数，将子View放在合适的位置上。</p><p>第三步：<code>onDraw</code> 绘制视图。主要步骤为①：绘制背景，②：绘制自己，③：绘制子View，④：绘制滚动条</p><h2 id="View、ViewGroup事件分发"><a href="#View、ViewGroup事件分发" class="headerlink" title="View、ViewGroup事件分发"></a>View、ViewGroup事件分发</h2><p>ViewGroup 包含 <code>dispatchTouchEvent</code> 、<code>onInterceptTouchEvent</code> 、<code>onTouchEvent</code>三个相关方法，View包含 <code>dispatchTouchEvent</code>、<code>onTouchEvent</code>两个相关方法。</p><ol><li>当 <code>Activity</code> 接收到Touch事件时，将遍历子View进行Down事件分发，分发的目的是为了找到真正处理本次完整触摸事件的View，这个View会在 <code>onTouchEvent</code> 返回true。</li><li>当某个子View返回true时，就终止事件分发，并同时在ViewGroup中记录该View，接下来的move事件跟up事件都由该子View直接进行处理。</li><li>当ViewGroup所有子View都不捕获Down事件时，将触发ViewGroup自身的 <code>onTouchEvent</code> 事件。触发的方式是调用 <code>super.dispatchTouchEvent</code>函数，即调用父View的<code>dispatchTouchEvent</code>方法。</li></ol><h2 id="Handler实现原理"><a href="#Handler实现原理" class="headerlink" title="Handler实现原理"></a>Handler实现原理</h2><p>Android的主线程不能进行耗时操作，子线程不能进行更新UI，所以就有了Handler，它的作用就是实现线程之间的通信。</p><p>Handler整个流程中主要有四个对象：<code>Handler</code>、<code>Message</code>、<code>MessageQueue</code>、<code>Looper</code>。通过将要传递的消息放在<code>Message</code>中，<code>Handler</code>通过 <code>sendMessage</code> 方法将消息放入 <code>MessageQueue</code> 中，<code>Looper</code> 对象会不断的调用<code>loop()</code> 方法不断从 <code>MessageQueue</code> 中取出 <code>Message</code> 交给 <code>Handler</code>进行处理。</p><h2 id="Android内存泄露"><a href="#Android内存泄露" class="headerlink" title="Android内存泄露"></a>Android内存泄露</h2><ol><li><p>内存泄漏跟内存溢出的区别：</p><ul><li>内存泄漏：指程序在申请内存后，无法释放已经申请的内存空间</li><li>内存溢出：指程序在申请内存时，没有足够的内存空间供其使用</li></ul></li><li><p>内存泄漏的原因：</p><ul><li><p>Handler引起的内存泄漏：</p><p>将Handler声明为静态内部类，就不会持有外部类的引用，其生命周期就跟外部类无关。如果Handler内部要使用Context，则可以使用弱引用的方式。</p></li><li><p>单例模式引起的内存泄漏：</p><p>Context是ApplicationCotnext，ApplicationCotnext的生命周期与app一致，不会导致内存泄漏.</p></li><li><p>非静态内部类创建实例引起的：</p><p>创建为静态实例</p></li><li><p>非静态匿名内部类引起的：</p><p>将匿名内部类修改为静态的</p></li><li><p>注册/反注册未成对使用引起的内存泄漏</p><p>注册广播接受器、EventBus等，记得解绑</p></li><li><p>资源对象没有关闭引起的内存泄漏</p><p>在这些资源不使用的时候，记得调用相应的类似close()、destroy()、recycler()、release()等方法释放</p></li><li><p>集合对象没有及时清理引起的内存泄漏</p><p>通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用</p></li></ul></li><li><p>内存泄漏检测：LeakCanary</p></li></ol><h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><p>ANR全名”Application not responding”，即应用无响应。产生的原因：</p><ul><li>5s内无法响应用户输入事件</li><li>广播在10s内无法结束</li><li>Service在20s内无法结束</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;广播&quot;&gt;&lt;a href=&quot;#广播&quot; class=&quot;headerlink&quot; title=&quot;广播&quot;&gt;&lt;/a&gt;广播&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注册方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、静态注册 ，在Manifest文件的&lt;code&gt;application&lt;/code&gt;节点中配置广播接收者&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;receiver&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;.MyBroadCastReceiver&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:priority&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;20&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;actionandroid:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;receiver&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2、动态注册，通过&lt;code&gt;Context&lt;/code&gt;对象的&lt;code&gt;registerReceiver&lt;/code&gt;方法注册广播&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//new出上边定义好的BroadcastReceiver&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyBroadCastReceiver yBroadCastReceiver = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyBroadCastReceiver();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//实例化过滤器并设置要过滤的广播  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IntentFilter intentFilter = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IntentFilter(&lt;span class=&quot;string&quot;&gt;&quot;android.provider.Telephony.SMS_RECEIVED&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//注册广播   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myContext.registerReceiver(smsBroadCastReceiver,intentFilter, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&quot;android.permission.RECEIVE_SMS&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;区别：静态注册的为常驻型广播，即使应用程序关闭了，如果又信息广播来，程序也会被系统调用执行。而动态注册的广播不是常驻型，广播被取消注册或者应用程序关闭后都不能接收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; 广播的两种类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、有序广播：按照优先级，一级一级向下传递，接收者可以修改广播数据，也可以终止广播事件。&lt;/p&gt;
&lt;p&gt;2、无序广播：所有接收者都会接收事件，不能被拦截跟修改。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>android和java泛型扫盲</title>
    <link href="http://yoursite.com/posts/c4ef6275.html"/>
    <id>http://yoursite.com/posts/c4ef6275.html</id>
    <published>2019-04-23T06:51:54.000Z</published>
    <updated>2019-05-16T07:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android、Java泛型扫盲"><a href="#Android、Java泛型扫盲" class="headerlink" title="Android、Java泛型扫盲"></a>Android、Java泛型扫盲</h1><p>首先我们定义A、B、C、D四个类，他们的关系如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="不指明泛型类型"><a href="#不指明泛型类型" class="headerlink" title="不指明泛型类型"></a>不指明泛型类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码均编译通过</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//不指明泛型类型，泛型默认为Object类型，故能往里面添加任意实例对象</span></span><br><span class="line">list.add(<span class="keyword">new</span> A());</span><br><span class="line">list.add(<span class="keyword">new</span> B());</span><br><span class="line">list.add(<span class="keyword">new</span> C());</span><br><span class="line"><span class="comment">//取出则默认为Object类型</span></span><br><span class="line">Object o = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这个好理解，因为所有的类都继承与Object，故能往list里面添加任意实例对象</p><a id="more"></a><h3 id="无边界通配符-？"><a href="#无边界通配符-？" class="headerlink" title="无边界通配符 ？"></a>无边界通配符 <code>？</code></h3><p>首先我们要明白一个概念，通配符<code>？</code>意义就是它是一个未知的符号，可以是代表任意的类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们发现，这样写编译不通过，原因很简单，泛型不匹配，虽然B继承A</span></span><br><span class="line">List&lt;A&gt; listA = <span class="keyword">new</span> ArrayList&lt;B&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//以下5行代码均编译通过</span></span><br><span class="line">List&lt;?&gt; list;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;A&gt;();</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;B&gt;();</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;C&gt;();</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;D&gt;();</span><br><span class="line"></span><br><span class="line">Object o = list.get(<span class="number">0</span>); <span class="comment">//编译通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> A());      <span class="comment">//编译不通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> B());      <span class="comment">//编译不通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> C());      <span class="comment">//编译不通过</span></span><br><span class="line">list.add(<span class="keyword">new</span> D());      <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p><code>知识点</code></p><ul><li>无边界通配符 <code>？</code> 能取不能存。这个好理解，因为编译器不知道<code>?</code>具体是啥类型，故不能存；但是任意类型都继承于Object，故能取，但取出默认为Object对象。</li></ul><h3 id="上边界符-？extends"><a href="#上边界符-？extends" class="headerlink" title="上边界符 ？extends"></a>上边界符 <code>？extends</code></h3><p>继续上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends C&gt; listC;</span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;A&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;B&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;C&gt;(); <span class="comment">//编译通过</span></span><br><span class="line">listC = <span class="keyword">new</span> ArrayList&lt;D&gt;(); <span class="comment">//编译通过</span></span><br><span class="line"></span><br><span class="line">C c = listC.get(<span class="number">0</span>); <span class="comment">//编译通过</span></span><br><span class="line">listC.add(<span class="keyword">new</span> C()); <span class="comment">//编译不通过</span></span><br><span class="line">listC.add(<span class="keyword">new</span> D()); <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong></p><ol><li>上边界符 <code>? extends</code> 只是限定了赋值给它的实例类型(这里为赋值给listC的实例类型)，且边界包括自身。</li><li>上边界符 <code>? extends</code> 跟 <code>？</code> 一样能取不能存，道理是一样的，虽然限定了上边界，但编译器依然不知道 <code>?</code> 是啥类型，故不能存；但是限定了上边界，故取出来的对象类型默认为上边界的类型</li></ol><h3 id="下边界符-？super"><a href="#下边界符-？super" class="headerlink" title="下边界符 ？super"></a>下边界符 <code>？super</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> B&gt; listB;</span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;A&gt;(); <span class="comment">//编译通过</span></span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;B&gt;(); <span class="comment">//编译通过</span></span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;C&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line">listB = <span class="keyword">new</span> ArrayList&lt;D&gt;(); <span class="comment">//编译不通过</span></span><br><span class="line"></span><br><span class="line">Object o = listB.get(<span class="number">0</span>); <span class="comment">//编译通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> A()); <span class="comment">//编译不通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> B()); <span class="comment">//编译通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> C()); <span class="comment">//编译通过</span></span><br><span class="line">listB.add(<span class="keyword">new</span> D()); <span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong></p><ol><li>下边界符 <code>？super</code>，跟上边界符一样，只是限定了赋值给它的实例类型，也包括边界自身</li><li>下边界符 <code>？super</code> 能存能取，因为设定了下边界，故我们能存下边界以下的类型，当然也包括边界自身；然而取得时候编译器依然不知道 <code>?</code> 具体是什么类型，故取出默认为Object类型。</li></ol><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>首先我们要明白一点：Java 的泛型在编译期有效，在运行期会被删除 我们来看一段代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这两个方法写在同一个类里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List&lt;A&gt; listA)</span> </span>&#123;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List&lt;B&gt; listB)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会有问题吗？显然是有的，编译器报错，提示如下信息： <code>list(List&lt;A&gt;) clashed with list(List&lt;B&gt;) ; both methods have same erasure</code> 翻译过来就是，在类型擦除后，两个方法具有相同的签名，我们来看看类型擦除后是什么样子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List listA)</span> </span>&#123;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(List listB)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看出，两个方法签名完全一致，故编译不通过。 明白了类型擦除，我们还需要明白一个概念</p><ul><li>泛型类并没有自己独有的Class类对象</li></ul><p>比如并不存在List<a>.class或是List<b>.class，而只有List.class 接下来这个案例就好理解了</b></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;A&gt; listA = <span class="keyword">new</span> ArrayList&lt;A&gt;();</span><br><span class="line">List&lt;B&gt; listB = <span class="keyword">new</span> ArrayList&lt;B&gt;();</span><br><span class="line">System.out.println(listA.getClass() == listB.getClass());  <span class="comment">//输出true</span></span><br></pre></td></tr></table></figure><h3 id="泛型传递"><a href="#泛型传递" class="headerlink" title="泛型传递"></a>泛型传递</h3><p>现实开发中，我们经常会用到泛型传递，例如我们经常需要对Http请求返回的结果做反序列化操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String result, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(result, type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们传进去是什么类型，就会返回自动该类型的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result=<span class="string">"xxx"</span>;</span><br><span class="line">A a = fromJson(result, A.class);</span><br><span class="line">B b = fromJson(result, B.class);</span><br><span class="line">C c = fromJson(result, C.class);</span><br><span class="line">D d = fromJson(result, D.class);</span><br><span class="line">Integer integer = fromJson(result, Integer.class);</span><br><span class="line">String str = fromJson(result, String.class);</span><br><span class="line">Boolean boo = fromJson(result, Boolean.class);</span><br></pre></td></tr></table></figure><p>那如果我们想返回一个集合呢，如<code>List&lt;A&gt;</code>，下面这样明显是不对的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译报错，前面类型擦除时，我们讲过，不存List&lt;A&gt;.class这种类型</span></span><br><span class="line">ArrayList&lt;A&gt; list = fromJson(result, ArrayList&lt;A&gt;.class)；</span><br></pre></td></tr></table></figure><p>那我们该怎么做呢？首先，我们对<code>fromJson</code>改造一下，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type为一个数组类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">fromJson</span><span class="params">(String result, Class&lt;T[]&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T[] arr = <span class="keyword">new</span> Gson().fromJson(result, type);<span class="comment">//首先拿到数组</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(arr); <span class="comment">//数组转集合</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们就可以这么做了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result=<span class="string">"xxx"</span>;</span><br><span class="line">List&lt;A&gt; listA = fromJson(result, A[].class);</span><br><span class="line">List&lt;B&gt; listB = fromJson(result, B[].class);</span><br><span class="line">List&lt;C&gt; listC = fromJson(result, C[].class);</span><br><span class="line">List&lt;D&gt; listD = fromJson(result, D[].class);</span><br><span class="line">List&lt;Integer&gt; listInt = fromJson(result, Integer[].class);</span><br><span class="line">List&lt;String&gt; listStr = fromJson(result, String[].class);</span><br><span class="line">List&lt;Boolean&gt; listBoo = fromJson(result, Boolean[].class);</span><br></pre></td></tr></table></figure><p>ok，我在再来，相信大多数Http接口返回的数据格式是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">//省略get/set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这种我们又该如何传递呢？显然用前面的两个<code>fromJson</code>方法都行不通，我们再来改造一下，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我们直接传递一个Type类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String result, Type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(result, type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Type是什么鬼？点进去看看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦，原来就是一个接口，并且只有一个方法，我们再来看看它的实现类</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428180503.png" alt=""></p><p>发现有5个实现类，其中4个是接口，另外一个是Class类，我们再来看看Class类的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">                              <span class="comment">//省略内部代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有没有明白点，现在我们重点来关注下<code>Type</code>接口的其中一个实现接口<code>ParameterizedType</code>，我们来看下它的内部代码，里面就只有3个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如:</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list; 则返回 &#123;String.class&#125;</span></span><br><span class="line"><span class="comment">     * Map&lt;String,Long&gt; map; 则返回 &#123;String.class,Long.class&#125;</span></span><br><span class="line"><span class="comment">     * Map.Entry&lt;String,Long&gt; entry; 则返回 &#123;String.class,Long.class&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 以数组的形式返回所有的泛型类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如:</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list; 则返回 List.class</span></span><br><span class="line"><span class="comment">     * Map&lt;String,Long&gt; map; 则返回 Map.class</span></span><br><span class="line"><span class="comment">     * Map.Entry&lt;String,Long&gt; entry; 则返回 Entry.class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回泛型类的真实类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如:</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list; 则返回 null</span></span><br><span class="line"><span class="comment">     * Map&lt;String,Long&gt; map; 则返回 null</span></span><br><span class="line"><span class="comment">     * Map.Entry&lt;String,Long&gt; entry; 则返回 Map.class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回泛型类持有者的类型，这里可以简单理解为返回外部类的类型，如果没有外部类，则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，<code>ParameterizedType</code> 代表一个参数化类型。</p><p>这个时候我们来自定义一个类，并实现ParameterizedType接口，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedTypeImpl</span> <span class="keyword">implements</span> <span class="title">ParameterizedType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Type rawType;<span class="comment">//真实类型</span></span><br><span class="line">    <span class="keyword">private</span> Type actualType;<span class="comment">//泛型类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseType</span><span class="params">(Type rawType,Type actualType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType;</span><br><span class="line">        <span class="keyword">this</span>.actualType = actualType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Type[] getActualTypeArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Type[]&#123;actualType&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getRawType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rawType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getOwnerType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次贴出<code>fromJson</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我们直接传递一个Type类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String result, Type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(result, type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们想得到<code>Response&lt;T&gt;</code>对象，就可以这样写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response&lt;A&gt; responseA = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, A.class));</span><br><span class="line">Response&lt;B&gt; responseB = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, B.class));</span><br><span class="line">Response&lt;C&gt; responseC = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, C.class));</span><br></pre></td></tr></table></figure><p>想得到<code>List&lt;T&gt;</code>对象，也可以通过<code>ParameterizedTypeImpl</code>得到，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;A&gt; listA = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(List.class, A.class));</span><br><span class="line">List&lt;B&gt; listB = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(List.class, B.class));</span><br><span class="line">List&lt;C&gt; listC = fromJson(result, <span class="keyword">new</span> ParameterizedTypeImpl(List.class, C.class));</span><br></pre></td></tr></table></figure><p>然而，如果我们想得到<code>Response&lt;List&lt;T&gt;&gt;</code>对象，又该如何得到呢？ <code>ParameterizedTypeImpl</code>一样能够实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，创建List&lt;T&gt;对象对应的Type类型</span></span><br><span class="line">Type listAType = <span class="keyword">new</span> ParameterizedTypeImpl(List.class, A.class);</span><br><span class="line">Type listBType = <span class="keyword">new</span> ParameterizedTypeImpl(List.class, B.class);</span><br><span class="line">Type listCType = <span class="keyword">new</span> ParameterizedTypeImpl(List.class, C.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型</span></span><br><span class="line">Type responseListAType = <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, listAType);</span><br><span class="line">Type responseListBType = <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, listBType);</span><br><span class="line">Type responseListCType = <span class="keyword">new</span> ParameterizedTypeImpl(Response.class, listCType);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象</span></span><br><span class="line">Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);</span><br><span class="line">Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);</span><br><span class="line">Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType);</span><br></pre></td></tr></table></figure><p>然后，能不能再简单一点呢？可以，我们对<code>ParameterizedTypeImpl</code>改造一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User: ljx</span></span><br><span class="line"><span class="comment"> * Date: 2018/10/23</span></span><br><span class="line"><span class="comment"> * Time: 09:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedTypeImpl</span> <span class="keyword">implements</span> <span class="title">ParameterizedType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type   rawType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type   ownerType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type[] actualTypeArguments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适用于单个泛型参数的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterizedTypeImpl</span><span class="params">(Type rawType, Type actualType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, rawType, actualType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适用于多个泛型参数的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterizedTypeImpl</span><span class="params">(Type ownerType, Type rawType, Type... actualTypeArguments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rawType = rawType;</span><br><span class="line">        <span class="keyword">this</span>.ownerType = ownerType;</span><br><span class="line">        <span class="keyword">this</span>.actualTypeArguments = actualTypeArguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本方法仅使用于单个泛型参数的类</span></span><br><span class="line"><span class="comment">     * 根据types数组，确定具体的泛型类型</span></span><br><span class="line"><span class="comment">     * List&lt;List&lt;String&gt;&gt;  对应  get(List.class, List.class, String.class)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> types Type数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ParameterizedTypeImpl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterizedTypeImpl <span class="title">get</span><span class="params">(@NonNull Type rawType, @NonNull Type... types)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = types.length;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Type parameterizedType = <span class="keyword">new</span> ParameterizedTypeImpl(types[length - <span class="number">2</span>], types[length - <span class="number">1</span>]);</span><br><span class="line">            Type[] newTypes = Arrays.copyOf(types, length - <span class="number">1</span>);</span><br><span class="line">            newTypes[newTypes.length - <span class="number">1</span>] = parameterizedType;</span><br><span class="line">            <span class="keyword">return</span> get(rawType, newTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(rawType, types[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适用于多个泛型参数的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParameterizedTypeImpl <span class="title">getParameterized</span><span class="params">(@NonNull Type rawType, @NonNull Type... actualTypeArguments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(<span class="keyword">null</span>, rawType, actualTypeArguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Type[] getActualTypeArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> actualTypeArguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getOwnerType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ownerType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getRawType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rawType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们就可以这样写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，直接创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型</span></span><br><span class="line">Type responseListAType = ParameterizedTypeImpl.get(Response.class, List.class, A.class);</span><br><span class="line">Type responseListBType = ParameterizedTypeImpl.get(Response.class, List.class, B.class)</span><br><span class="line">Type responseListCType = ParameterizedTypeImpl.get(Response.class, List.class, C.class)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象</span></span><br><span class="line">Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);</span><br><span class="line">Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);</span><br><span class="line">Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType);</span><br></pre></td></tr></table></figure><p>现实开发中，我们还可能遇到这样的数据结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"totalPage"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"list"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>Response&lt;T&gt;</code> 里面的泛型传List肯定是不能正常解析的，我们需要再定一个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageList</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> totalPage;</span><br><span class="line">   <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">   <span class="comment">//省略get/set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以这样解析数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，直接创建Response&lt;PageList&lt;T&gt;&gt;对象对应的Type类型</span></span><br><span class="line">Type responsePageListAType = ParameterizedTypeImpl.get(Response.class, PageList.class, A.class);</span><br><span class="line">Type responsePageListBType = ParameterizedTypeImpl.get(Response.class, PageList.class, B.class)</span><br><span class="line">Type responsePageListCType = ParameterizedTypeImpl.get(Response.class, PageList.class, C.class)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，通过Type对象，获取对应的Response&lt;PageList&lt;T&gt;&gt;对象</span></span><br><span class="line">Response&lt;PageList&lt;A&gt;&gt; responsePageListA = fromJson(result, responsePageListAType);</span><br><span class="line">Response&lt;PageList&lt;B&gt;&gt; responsePageListB = fromJson(result, responsePageListBType);</span><br><span class="line">Response&lt;PageList&lt;C&gt;&gt; responsePageListC = fromJson(result, responsePageListCType);</span><br></pre></td></tr></table></figure><p>注：<code>ParameterizedTypeImpl get(Type... types)</code>仅仅适用于单个泛型参数的时候，如Map等，有两个泛型参数以上的不要用此方法获取Type类型。如果需要获取Map等两个泛型参数以上的Type类型。可调用<code>getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments)</code>构造方法获取，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 Map&lt;String,String&gt; 对应的Type类型</span></span><br><span class="line">Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, String.classs, String.class)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Map&lt;A,B&gt; 对应的Type类型</span></span><br><span class="line">Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, A.classs, B.class)</span><br></pre></td></tr></table></figure><p>到这，泛型相关知识点讲解完毕，如有疑问，请留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android、Java泛型扫盲&quot;&gt;&lt;a href=&quot;#Android、Java泛型扫盲&quot; class=&quot;headerlink&quot; title=&quot;Android、Java泛型扫盲&quot;&gt;&lt;/a&gt;Android、Java泛型扫盲&lt;/h1&gt;&lt;p&gt;首先我们定义A、B、C、D四个类，他们的关系如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;不指明泛型类型&quot;&gt;&lt;a href=&quot;#不指明泛型类型&quot; class=&quot;headerlink&quot; title=&quot;不指明泛型类型&quot;&gt;&lt;/a&gt;不指明泛型类型&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以下代码均编译通过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//不指明泛型类型，泛型默认为Object类型，故能往里面添加任意实例对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; B());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; C());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//取出则默认为Object类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object o = list.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个好理解，因为所有的类都继承与Object，故能往list里面添加任意实例对象&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
