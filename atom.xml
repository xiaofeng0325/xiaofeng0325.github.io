<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2019-09-29T08:52:10.928Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于RecyclerView的解析</title>
    <link href="https://zhangmiao.cc/posts/e545b7b2.html"/>
    <id>https://zhangmiao.cc/posts/e545b7b2.html</id>
    <published>2019-09-29T08:42:22.000Z</published>
    <updated>2019-09-29T08:52:10.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在日常开发中，大伙或多或少都会接触到 RecyclerView，但通常，也就是写写 adapter，用个系统提供的 LayoutManager，写写点击事件，处理处理复杂的 item 布局。</p><p>也就是说，大部分场景下，我们其实并不会去接触到 RecyclerView 的大部分其他功能，比如自定义 LayoutManager ，自定义 Item 动画，自定义边界样式，自定义滑动效果，自定义回收策略等等之类的功能。</p><p>那么，本篇就专门来试用下这些功能，力求将 RecyclerView 支持的所有功能都试一遍，只有清楚了这个控件都支持哪些功能效果，那么分析起它的架构、原理才会有一个比较清晰的脉络。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。</p><p>另外，由于有些平台可能不支持 `` 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。</p><blockquote><p>1.<strong>LayoutManager</strong></p><p>1.1 <strong>LinearLayoutManager</strong></p><ul><li>基本效果介绍</li><li>findFirstCompletelyVisibleItemPosition()</li><li>findFirstVisibleItemPosition()</li><li>findLastCompletelyVisibleItemPosition()</li><li>findLastVisibleItemPosition()</li><li>setRecycleChildrenOnDetach()</li></ul><p>1.2 <strong>GridLayoutManager</strong></p><ul><li>基本效果介绍</li><li>setSpanSizeLookUp()</li></ul><p>1.3 <strong>StaggeredGridLayoutManager</strong></p><ul><li>基本效果介绍</li><li>setFullSpan()</li><li>findXXX() 系列方法介绍</li></ul><p>2.<strong>ViewHolder</strong></p><ul><li>getAdapterPosition()</li><li>getLayoutPosition()</li><li>setIsRecyclable()</li></ul><p>3.<strong>LayoutParams</strong></p><p>4.<strong>Adapter</strong></p><ul><li>基本用法介绍</li><li>onViewRecycled()</li><li>onViewAttachedFromWindow()</li><li>onViewDetachedFromWindow()</li><li>onAttachedToRecyclerView()</li><li>onDetachedFromRecyclerView()</li><li>registerAdapterDataObserver()</li><li>unregisterAdapterDataObserver()</li></ul><p>5.<strong>RecyclerView</strong></p><ul><li>addOnItemTouchListener()</li><li>addOnScrollListener()</li><li>setHasFixedSize()</li><li>setLayoutFrozen()</li><li>setPreserveFocusAfterLayout()</li><li>findChildViewUnder()</li><li>findContainingItemView()</li><li>findContainingViewHolder()</li><li>findViewHolderXXX()</li></ul><p>6.<strong>Recycler</strong></p><ul><li>setItemViewCacheSize()</li><li>setViewCacheExtension()</li><li>setRecycledViewPool()</li><li>setRecyclerListener()</li></ul><p>7.<strong>ItemAnimator</strong></p><ul><li><p>SimpleItemAnimator</p></li><li><p>DefaultItemAnimator</p></li></ul><p>8.<strong>ItemDecoration</strong></p><ul><li><p>DividerItemDecoration</p></li><li><p>ItemTouchHelper</p></li><li><p>FastScroller</p></li></ul><p>9.<strong>OnFlingListener</strong></p><ul><li><p>SnapHelper</p></li><li><p>LinearSnapHelper</p></li><li><p>PagerSnapHelper</p></li></ul></blockquote><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>阅读须知：</p><ul><li>本篇力求列举 RecyclerView 所有功能的使用示例，由于篇幅原因，并不会将实现代码全部贴出，只贴出关键部分的代码。</li><li>本篇所使用的 RecyclerView 的版本是 26.0.0。</li><li>下列标题中，但凡是斜体字，表示该知识点目前暂时没理清楚，留待后续继续补充。</li></ul><h3 id="1-LayoutManager"><a href="#1-LayoutManager" class="headerlink" title="1. LayoutManager"></a>1. LayoutManager</h3><p>RecyclerView 的 support 包里默认提供了三个 LayoutManager，分别是下列三个，可用于实现大部分场景的布局需求：线性布局、网格布局、瀑布流布局等等。</p><h4 id="1-1-LinearLayoutManager"><a href="#1-1-LinearLayoutManager" class="headerlink" title="1.1 LinearLayoutManager"></a>1.1 LinearLayoutManager</h4><p>线性布局，用它可以来实现横竖自由切换的线性布局，先来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">LayoutManager</span> <span class="keyword">implements</span> <span class="title">ItemTouchHelper</span>.<span class="title">ViewDropHandler</span>, <span class="title">RecyclerView</span>.<span class="title">SmoothScroller</span>.<span class="title">ScrollVectorProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, VERTICAL, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> orientation, <span class="keyword">boolean</span> reverseLayout)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总共三个，我们分别来看看它们各自的使用场景：</p><ul><li><strong>第一个构造函数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法(在Activity里初始化控件后)：</span></span><br><span class="line">LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(layoutManager);</span><br></pre></td></tr></table></figure><p>很简单，这种时候默认就是竖直方向的线性布局，效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-8ad93d1d803f9c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="竖直LinearLayoutManager示例.png"></p><p>在 Tv 应用中，这种竖直方向的 LinearLayoutManager 使用场景大多都是用于显示菜单项，使用频率并不是特别高，但在手机应用中，这种的使用频率算是特别高的了，几乎每个 app 都会有竖直方向的滑动列表控件。</p><ul><li><strong>第二个构造函数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法(在Activity里初始化控件后)：</span></span><br><span class="line"><span class="comment">//第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式</span></span><br><span class="line">LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(layoutManager);</span><br></pre></td></tr></table></figure><p>第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式，来看看效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-3076dcee4df3758e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平LinearLayoutManager.png"></p><p>在 Tv 应用中，这种布局就比较常见了，常见的还有网格布局，多行布局等等；而在手机应用中，水平滑动的列表控件也还是有，但会比竖直的少见一些。</p><ul><li><strong>第三个构造函数</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//xml文件：</span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/recycler_main"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layoutManager</span>=<span class="string">"LinearLayoutManager"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式基本没见过吧，我也是看了 LinearLayoutManager 源码的构造函数，才发现，原来还有这种方式，可以直接在 xml 布局文件中指定 RecyclerView 的 LayoutManager，这时候，android:orientation 就是用来指定 LinearLayoutManager 的布局方向了。</p><p>那么使用这种 xml 方式时，还有哪些属性可以配置呢？直接去看对应的 LayoutManager 的源码就清楚了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor used when layout manager is set in XML by RecyclerView attribute</span></span><br><span class="line"><span class="comment"> * "layoutManager". Defaults to vertical orientation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_android_orientation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_reverseLayout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_stackFromEnd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//上面是源码的注释，当在 xml 中通过 app:layoutManager="LinearLayoutManager" 之后，那么此时就还可以再使用三个属性来配置 LinearLayoutManager,如下：</span></span><br><span class="line"><span class="comment">//android:orientation="horizontal"</span></span><br><span class="line"><span class="comment">//app:reverseLayout="false"</span></span><br><span class="line"><span class="comment">//app:stackFromEnd="false"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    Properties properties = getProperties(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    setOrientation(properties.orientation);</span><br><span class="line">    setReverseLayout(properties.reverseLayout);</span><br><span class="line">    setStackFromEnd(properties.stackFromEnd);</span><br><span class="line">    setAutoMeasureEnabled(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外两个 LayoutManager 同理。</p><p>以上，仅仅就是 LinearLayoutManager 支持的布局样式，我们只需要设置布局方向后，其他都不用管了。那么，LinearLayoutManager 是否还有提供其他一些可选功能来让我们使用呢？接下去就一起再看看：</p><ul><li><strong>setOrientation()</strong></li></ul><p>用于设置布局方向，如果不通过构造函数来指定，也可以通过该方法指定，就两个值：<br>LinearLayoutManager.HORIZONTAL<br>LinearLayoutManager.VERTICAL</p><ul><li><strong>findFirstCompletelyVisibleItemPosition()</strong></li><li><strong>findFirstVisibleItemPosition()</strong></li><li><strong>findLastCompletelyVisibleItemPosition()</strong></li><li><strong>findLastVisibleItemPosition()</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-0d420ec9bbfc29c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="findItem示例.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-09a7678bb91a7d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="findItem日志.png"></p><p>上述四个方法作用从方法命名就可以很直观的理解了，但有些<strong>细节需要注意</strong>一下：</p><p>两个查找全部可见的 item 方法并不是我们正常意义上的全部可见，而是指在布局方向上是否已全部可见。说得白点，如果是 HORIZONTAL 水平样式，如上图，那么它只会去计算左右方向上是否全部可见来判定，比如我们特意在代码中通过 layout_marginTop=”-100dp” 来将控件移出屏幕一部分，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-7fa0f3a1efeb3c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="部分可见.png"></p><p>此时，按照我们正常意义上来理解是没有一个 item 处于全部可见的，因为每个 item 的上半部分都被移出屏幕了。但是调用那两个查找全部可见的 item 方法，仍然会返回 0 和 4，因为它只去判断水平方向是否全部可见。</p><p>findFirst 就是判断左边第一个 item 的左边界是否可见，findLast 就是判断右边最后一个 item 的右边界是否可见。如果布局方向是竖直的，那么同样的道理。这点细节需要注意一下。</p><p>还有另外两个查找第一个或最后一个可见的 item 方法也有个细节需要注意一下，如果这个 item 是有设置了 ItemDecoration，那么如果 ItemDecoration 这部分区域是可见的，也会判定该 item 是可见的。</p><ul><li><strong>setRecycleChildrenOnDetach()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set whether LayoutManager will recycle its children when it is detached from</span></span><br><span class="line"><span class="comment"> * RecyclerView.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If you are using a &#123;<span class="doctag">@link</span> RecyclerView.RecycledViewPool&#125;, it might be a good idea to set</span></span><br><span class="line"><span class="comment"> * this flag to &lt;code&gt;true&lt;/code&gt; so that views will be available to other RecyclerViews</span></span><br><span class="line"><span class="comment"> * immediately.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that, setting this flag will result in a performance drop if RecyclerView</span></span><br><span class="line"><span class="comment"> * is restored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recycleChildrenOnDetach Whether children should be recycled in detach or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRecycleChildrenOnDetach</span><span class="params">(<span class="keyword">boolean</span> recycleChildrenOnDetach)</span> </span>&#123;</span><br><span class="line">    mRecycleChildrenOnDetach = recycleChildrenOnDetach;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看源码注释，注释里说了，这个方法是用来设置，当它（LinearLayoutManager）从 RecyclerView 上面 detached 时是否要回收所有的 item。而且，它还建议我们，如果我们项目里有复用 RecyclerViewPool 的话，那么开启这个功能会是一个很好的辅助，它可以将这些 item 回收起来给其他 RecyclerView 用。最后，还指明了一点，开启这个功能的话，当 RecyclerView 恢复时，也就是从 detached 又变回 attached，那么会消耗一定的性能来绘制。</p><p>有<strong>两种场景</strong>会导致 LinearLayoutManager 从 RecyclerView 上被 detached，一种是：<code>setLayoutManager()</code>，而另外一种是：RecyclerView 从视图树上被 remove 掉。</p><p>但经过测试（你也可以去看源码），<code>setLayoutManager()</code> 时，如果之前有设置过 LayoutManger，那么内部会自动先去将之前 LayoutManager 的所有 item 回收，然后再给新的 LayoutManager 复用。此时，这个方法并没有什么卵用。</p><p>也就是说，上面说了有两种场景会触发到该方法开启的回收工作，但实际上，第一种场景内部默认的工作中就包含了回收工作，那么有没有通过这个方法来开启并没有任何影响。只有第二种场景下，要不要去处理回收工作才是由该方法来控制。</p><p>所以我怀疑是不是 Google 工程师太懒了，没有同步更新这个方法的注释。注释的第一句 when 后面应该改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set whether LayoutManager will recycle its children when RecyclerView is detached from Window.</span><br></pre></td></tr></table></figure><p>我觉得这样才比较合理一点，但纯属个人观点哈，也许是我某个地方理解错了。</p><p><strong>那么这个方法开启的回收工作到底有什么使用场景呢？</strong></p><p>这类场景还是有的，我举个例子，比如当前页面是通过 ViewPager + Fragment 来实现的，每个 Fragment 里又有 RecyclerView 控件，那么如果当页面布局信息需要更新时，有时候是直接暴力的通过 ViewPager 的 <code>setAdapter()</code> 来刷新，那么此时，旧的 fragment 其实就全被移除掉了，然后 new 了新的 fragment 绘制新的布局信息。</p><p>这样，新的 fragment 里新的 RecyclerView 的 item 就又需要全部重新创建了，如果用这个方法开启了回收工作，那么当旧的 fragment 被移除时会触发到 RecyclerView 的 detachedFromWindow 的回调，那么此时这个回收工作就会去将 item 回收到 RecyclerViewPool 中，如果新的 fragment 里的 RecyclerView 复用了这个 RecyclerViewPool，就可以省掉重新创建 item 的消耗，达到直接复用 item 的效果。</p><p>小结一下，其实也就是 RecyclerView 有更换新的实例对象时，这个方法开启的回收工作是有一定的好处的。但如果同一个 RecyclerView 实例对象存在从 attached 到 detached 又到 attached 的场景，默认没有开启回收工作时，由于 item 一直都附着在 RecyclerView 上，所以当重新 attached 时就可以直接显示出来了。但如果用该方法开启了回收工作，等于是要重新在 onBind 一次了，这点也是在注释中有提到的。</p><p>所以，这是一把双刃剑，有好有坏，有符合的场景下再去开启使用吧。</p><ul><li><strong>RecyclerView 内嵌 RecyclerView</strong></li></ul><p>另外，LayoutManager 里还有许多 public 的接口，这些方法涉及的方面是 RecyclerView 内嵌 RecyclerView 的场景，比如：<br><code>collectInitialPrefetchPositions()</code><br><code>setInitialPrefetchItemCount()</code><br>等等，但目前还没搞懂这些相关方法的用法及效果，等待后续补充。</p><h4 id="1-2-GridLayoutManager"><a href="#1-2-GridLayoutManager" class="headerlink" title="1.2 GridLayoutManager"></a>1.2 GridLayoutManager</h4><p>网格样式的布局管理器，同样，先来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意看，GridLayoutManager 是继承的 LinearLayoutManger 的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GridLayoutManager</span> <span class="keyword">extends</span> <span class="title">LinearLayoutManager</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> spanCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        setSpanCount(spanCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> spanCount, <span class="keyword">int</span> orientation, <span class="keyword">boolean</span> reverseLayout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, orientation, reverseLayout);</span><br><span class="line">        setSpanCount(spanCount);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GridLayoutManager 继承自 LinearLayoutManager， 并在它的继承上补充了 spanCount 的概念，也就是说 LinearLayoutManager 是只支持线性布局，要么一行，要么一列。而 GridLayoutManager 补充了 spanCount 概念后，支持多行或者多列，这就是网格布局了。</p><p>使用方面跟 LinearLayoutManager 基本一样，只是在构造函数内需要多传一个 spanCount 参数，来指定多少行或多少列，来看看效果图：</p><ul><li>2 行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">2</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-5df7cee852f08ce6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两行.png"></p><ul><li>4 列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">4</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-f4decf7689865af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列.png"></p><p>这种网格布局不管是 Tv 应用还是手机应用都挺常见的，Tv 上经常需要有多行或多列的形式来展示各个卡位信息，而手机上一些类似于九宫格之类的布局也可以用这个实现。</p><p>但有一些<strong>细节同样需要注意</strong>一下：</p><p>如果指定 HORIZONTAL 样式，即以多行形式进行布局，那么 item 布局的顺序则是以竖直方向来进行，如上图中标注的 item 序号，并且，此时的 RecyclerView 只支持水平方向的滑动，不支持竖直方向。如果指定 VERTICAL 样式，则相反。</p><p>其实想想也很容易理解，GridLayoutManager 是继承自 LinearLayoutManager，只是在它基础上补充了 spanCount 概念，滑动的实现还是延用 LinearLayoutManager 的逻辑，那么如果指定水平样式，自然就只有水平方向可滑动。</p><p>当设置成水平样式，水平方向可滑动的话，那么水平方向的长度自然就是可根据 item 数量动态增加的，此时自然要按照竖直方向来进行 item 布局，否则还以行为优先的话，哪里知道尽头是哪里，什么时候该换行布局了。</p><p>还有一点细节需要注意，当使用 GridLayoutManager 时，RecyclerView 的宽高在 match_parent 和 wrap_content 两种情况下的表现完全不一样，具体表现怎样，有兴趣的可以去试一下，这里就简单举个例子给大伙有个直观印象：</p><ul><li>4 列，RecycerView 宽高为 wrap_content 模式，item 设置具体宽高数值</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-f4decf7689865af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列.png"></p><ul><li>4 列，RecyclerView 宽高为 match_parent 模式，item 设置具体宽高数值</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-afe2db4b56586054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列2.png"></p><p>简单点说，就是在 match_parent 模式下，如果指定了水平样式，那么在竖直方向上，GridLayoutManager 会保证让所有行都显示出来，如果 item 指定了具体宽高，全部显示出来还不足以铺满 RecyclerView，那么会自动将剩余空间平均分配到每个 item 之间的间隙。</p><p>如果 RecyclerView 高度不足以让所有行都显示出来，那么就会出现 item 重叠现象。这就是在 match_parent 下的表现，至于 wrap_content 则完全根据 item 设定的宽高来考虑了，不会再有自动分配剩余空间或者 Item 重叠之类的工作了。</p><p>所以，使用 GridLayoutManager 时，RecyclerView 的宽高模式需要注意一下。</p><ul><li><strong>setSpanCount()</strong></li></ul><p>通过构造函数指定了 spanCount 后也还可以继续通过该方法进行修改</p><ul><li><strong>LinearLayoutManager 的方法</strong></li></ul><p>由于是继承关系，所有 LinearLayoutManager 中的四个 <strong>findFirstCompletelyVisibleItemPosition()</strong> 方法一样可以使用，但在 LinearLayoutManager 一节中对这四个方法所讲的注意事项在这里就更加明显了，使用时需要注意一下。</p><ul><li><strong>setSpanSizeLookup()</strong></li></ul><p>通常情况下，网格布局样式下，每个小格的大小基本都是一样的，但如果我们想实现如下的效果呢：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-cbb3595bd767d01a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网格示例.png"></p><p>区别于常见的网格布局，这里有的小格就占据了多个网格，这种效果就可以通过该方法来实现了。</p><p>上述布局是设定了 HORIZONTAL 水平方向的 GridLayoutManager，并且设定为 3 行，默认情况下每个 item 占据一个小格，按照竖直方向依次布局。</p><p>通过 <code>setSpanSizeLookup()</code> 方法就可以自定义为每个 item 指定它在竖直方向要占据多少个小格，最多不超过设定的行数，上述例子中每个 item 最多就只能占据 3 行的高度。如果在该列的剩余空间不足 item 设定占据的行数，那么会将该列剩余的空间空闲出来，将该 item 移到下列进行布局。</p><p>同样的道理，当设定为 VERTICAL 竖直方向的样式时，那么可以自定义为每个 item 设定要占据的列数，最多不超过指定的列数。</p><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">3</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//自定义item占据的小格大小时需要重写 getSpanSize()，返回值就是占据的小格数量</span></span><br><span class="line">gridLayoutManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//以下代码仅为上图示例为写，具体场景中应该根据需求具体编写</span></span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个方法也很重要，但我还没搞清楚它的具体效果，从注释上来看，该方法是用于指定 item 在该行或该列上具体哪个位置，比如将GridLayoutManager设置为3行水平样式，那么第1个卡位就是在第一列的 0 位置，第2个卡位 1，一次类推。但该方法具体被调用的场景还没理清</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanIndex</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> spanCount)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.getSpanIndex(position, spanCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//官方建议说，如果延用默认的 getSpanIndxe() 的实现逻辑的话，那么建议调用下述方法来进行优化，否则每次布局计算时会很耗性能。 </span></span><br><span class="line">gridLayoutManager.getSpanSizeLookup().setSpanIndexCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure><p>虽然提供了该方法让网格布局可以更加多样化布局，但仍然<strong>无法满足一些场景</strong>，比如当设定为多行的样式时，此时就只支持自定义每个 item 占据的行数，只有行数！也就是说，所有的卡位顶多只会在高度方面不一样，同一列的卡位的宽度都是一样的。那么，如果需求是五花八门的网格布局，每个卡位都有可能占据多行的情况下又占据多列，用这个就没法实现了。</p><h4 id="1-3-StaggeredGridLayoutManager"><a href="#1-3-StaggeredGridLayoutManager" class="headerlink" title="1.3 StaggeredGridLayoutManager"></a>1.3 StaggeredGridLayoutManager</h4><p>英文直译过来是：交错式的网格布局管理者，不过我还是喜欢网上大伙的说法：瀑布流。</p><p>首先，也还是来看看它的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaggeredGridLayoutManager</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">LayoutManager</span> <span class="keyword">implements</span> <span class="title">RecyclerView</span>.<span class="title">SmoothScroller</span>.<span class="title">ScrollVectorProvider</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaggeredGridLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaggeredGridLayoutManager</span><span class="params">(<span class="keyword">int</span> spanCount, <span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有两个构造方法，第一个跟 LinearLayoutManager 一样，用于在 xml 布局文件中直接指定 LayoutManager 时用的。</p><p>第二个构造方法才是我们经常使用它的入口，两个参数，说白点就是用来设置成多行的瀑布流或者多列的瀑布流样式。</p><p>这里顺便提一点不怎么重要的，注意到没有，这里的构造方法是不需要 Context，那么为啥另外两个 LayoutManager 却需要呢？它们之间有什么不同么？</p><p>哈哈哈，答案是没啥不同，LinearLayoutManager 实际上也是不需要 Context 的，看看它的源码就会发现它根本没使用这个参数，可能是早期版本有需要用到，然后新版不需要了，为了让开发者兼容旧代码，就一直留着的吧。</p><ul><li><strong>竖直方向瀑布流</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StaggeredGridLayoutManager staggeredGridLayoutManager = <span class="keyword">new</span> StaggeredGridLayoutManager(<span class="number">3</span>, StaggeredGridLayoutManager.VERTICAL);</span><br><span class="line">mRecyclerView.setLayoutManager(staggeredGridLayoutManager);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-c73aef159fb6e264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="瀑布流.png"></p><p>瀑布流的样式在手机应用上比较常见，尤其图片查看相关的应用，在 Tv 应用上这种瀑布流布局就比较少见了。</p><p>瀑布流的方向可以选择水平或者竖直，两者只是方向上的区别而已，水平方向的效果图就不贴了。</p><p>有点<strong>细节需要注意</strong>一下，瀑布流样式在布局 item 时，并不是说一定按照某个方向某个顺序来布局。当设定为竖直方向时，以水平方向为顺序，寻找水平方向上最靠近顶端的位置来布局 item，所以并不是说一定按照第 1 列、第 2 列、第 3 列这种顺序来布局。</p><ul><li><strong>瀑布流样式和网格样式的区别</strong></li></ul><p>也许有人会疑惑，瀑布流就是设置下几行或者几列，然后设定下方向而已。网格样式时不也一样是设置下几行或几列，也一样是要再设置个方向。那么为什么瀑布流不可以直接用网格样式来实现呢？它们两者有什么区别么？</p><p>有去尝试过的就清楚了，这是两种完全不一样的布局样式。下面以两者都设置为竖直方向多列的样式来区分：</p><ol><li>网格样式每一行中的所有 item 高度是一致的，不同行可以不一样，但同行的都是一样的，因此它就实现不了瀑布流的样式了；瀑布流所有的 item 高度都允许不一样，所有能实现瀑布流样式。</li><li>网格样式支持 item 占据多列的宽度；瀑布流支持 item 占据总列数的宽度，不支持只占据其中几列。</li><li>当设置为水平方向样式时，以上结论中行列对调，宽度高度对调。</li></ol><ul><li><strong>setFullSpan()</strong></li></ul><p>该方法是 StaggeredGridLayoutManager 内部类 LayoutParams 的方法，用这个方法可以设置 item 是否要占据总宽度或总高度，当瀑布流中有某个 item 需要横穿的场景时，可以使用这个方法，效果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-453cb36deed55957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="瀑布流示例.png"></p><ul><li><strong>setOrientation()</strong></li><li><strong>setSpanCount()</strong></li></ul><p>不解释，上面两个 LayoutManager 中介绍过了。</p><ul><li><strong>findFirstCompletelyVisibleItemPositions()</strong></li><li><strong>findFirstVisibleItemPositions()</strong></li><li><strong>findLastCompletelyVisibleItemPositions()</strong></li><li><strong>findLastVisibleItemPositions()</strong></li></ul><p>作用跟 LinearLayoutManager 的一样，但有些许区别，因为这里需要传入 int[] 类型的参数，返回的结果也是 int[] 类型的。</p><p>就以上上图的布局为例，来看下打出来的日志：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-d1df0bab15cb2e0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志.png"></p><p>得到的结果是个数组，数组的大小就是构造方法中传入的 spanCount。</p><p>简单点说，上面四个方法的作用，是以每行或每列为单位来寻找相对应的首个（末个）可见或完全可见的 item。</p><p><strong>为什么要这么做呢？</strong></p><p>我想了想，还是想不出比较合理的解释，大概硬套了下，感觉也许是因为瀑布流的布局下是没办法确定 item 的大小的，如果还像 LinearLayoutManager 只寻找首个或末个完全可见的 item 时，也许它并不是处于当前屏的最顶部或最底部，就像上图日志中的 position=7 的 item，它虽然是最后完全可见的 item，但并不是位于最底部，最底部是 6 的 item。</p><p>在这种场景下，如果我们的需求是要找到处于最底部的 item 时，如果还只是像 LinearLayoutManager 只寻找最后完全可见的 item 时，就没办法做到了。那么，如果你想说，那干脆将寻找最后一个完全可见 item 改成寻找位于最底部的完全可见的 item，不就好了。那如果这时我的需求是要寻找最后一个 item 而不是最底部的呢？</p><p>所以，瀑布流它直接以每行或每列为单位，将该行/列的首（末）个可见或完全可见的 item 信息都全部给我们，我们需要哪些数据，是最后一个，还是最底部一个，就自行去处理这些信息好了。</p><p>以上，纯属个人观点。</p><ul><li><strong>setGapStrategy()</strong></li><li><strong>invalidateSpanAssignments()</strong></li></ul><p>这两个方法还没理清它们是干嘛用的，网上有资料说是用于解决滑动时 item 自动变换位置以及顶部留白问题，但我不是很清楚，后续有时间再继续查证。</p><h3 id="2-ViewHolder"><a href="#2-ViewHolder" class="headerlink" title="2. ViewHolder"></a>2. ViewHolder</h3><p>ViewHolder 大伙也不陌生了，但没想到我会单独开个小节来讲吧，也是，平时使用时顶多就是继承它，然后重写一下构造方法而已，但其实，它本身携带着很多信息，利用得当的话，可以方便我们处理很多事情。</p><ul><li><strong>getAdapterPosition()</strong></li><li><strong>getLayoutPosition()</strong></li></ul><p>将这两个放在一起讲，因为这两个很类似，不理清它们之间的区别的话，很容易搞乱，源码中的注释其实已经说得很清楚了。</p><p>在大部分场景下，这两个的值都是一样的，但在涉及到刷新时，由于 Android 是每隔 16.6 ms 刷新一次屏幕，如果在某一帧开始时，adapter 关联的数据源发生的变化，item 被移除或者新增了，我们一般都会调用 <code>notifyDataSetChanged()</code> 或者 <code>notifyItem系列()</code> 方法来刷新，但 RecyclerView 会直到下个帧来的时候才会去刷新界面。</p><p>那么，从调用了 <code>notifyDataSetChanged()</code> 到界面刷新这之间就会存在一定的时间差，在这段时间内，数据源与界面呈现的 Item 就不是一致性的了，如果这时候有需要区分实际数据源的 Item 和界面呈现 Item 的需求，那么这两个方法就派上用场了。</p><p><code>getLayoutPosition()</code>：返回的一直是界面上呈现的 Item 的位置信息，即使某个 Item 已经从数据源中被移除。</p><p><code>getAdapterPosition()</code>：当数据源发生变化，且界面已经刷新过后即 <code>onBindViewHolder()</code> 已经被调用了后，返回的值跟 <code>getLayoutPosition()</code> 一致；但当数据源发生变化，且在 <code>onBindViewHolder()</code> 被调用之前，如果调用了 <code>notifyDataSetChanged()</code>, 那么将返回无效的位置标志 -1；如果调用了 <code>notifyItem系列()</code>，那么将返回 Item 在数据源中的位置信息。</p><p><strong>示例场景：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mDataList.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//1. 场景1</span></span><br><span class="line">mAdapter.notifyDataSetChanged();</span><br><span class="line">logPosition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 场景2</span></span><br><span class="line">mAdapter.notifyItemRemove(<span class="number">0</span>);</span><br><span class="line">logPosition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 场景3</span></span><br><span class="line">mAdapter.notifyItemRemove(<span class="number">0</span>);</span><br><span class="line">mRecyclerView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mRecyclerView.getChildCount(); i++) &#123;</span><br><span class="line">        View view = mRecyclerView.getChildAt(i);</span><br><span class="line">        <span class="keyword">int</span> layPosi = mRecyclerView.findContainingViewHolder(view).getLayoutPosition();</span><br><span class="line">        <span class="keyword">int</span> adapterPosi = mRecyclerView.findContainingViewHolder(view).getAdapterPosition();</span><br><span class="line">        <span class="keyword">int</span> oldPosi = mRecyclerView.findContainingViewHolder(view).getOldPosition();</span><br><span class="line">        LogUtils.d(TAG, <span class="string">"getLayoutPosition = "</span> + layPosi);</span><br><span class="line">        LogUtils.d(TAG, <span class="string">"getAdapterPosition = "</span> + adapterPosi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景1：</strong>由于数据源发生变化后，调用了 <code>notifyDataSetChanged()</code>，在这之后马上去遍历界面上的 Item 元素，分别输出 ViewHolder 的几个方法，那么打日志的时间点肯定是在界面刷新之前，所以可以看到这些方法的区别：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-e61bb62656167372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景1日志.png"></p><p>0 position 的 Item 明明已经从数据源中被移除掉了，但由于日志打印的时机是在界面刷新之前，因此可以看到通过 <code>getLayoutPosition()</code> 获取到的是界面上还未刷新之前的 Item 的信息，而由于是调用了 <code>notifyDataSetChanged()</code> 去通知，因此 <code>getAdapterPosition()</code> 对于所有 Item 都返回无效的位置标志 -1。</p><p><strong>场景2：</strong>同理，这次也是在数据源发生变化，界面刷新之前就去打印日志了，但是是通过 <code>notifyItemRemove()</code> 通知，这个时候 <code>getAdapterPosition()</code> 方法返回的值跟上面就有所差别了：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-9ffe280f22db0d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景2日志.png"></p><p>由于这次是通过 <code>notifyItemRemove()</code> 方法来通知的，因此，此时可以通过 <code>getAdapterPositon()</code> 来获取到界面还未刷新之前的 Item 的实际在数据源中的 position 信息。position = 0 的 Item 由于已经从数据源中移除，因此返回 -1，之后的所有 Item 位置自动向前移 1 位。</p><p><strong>场景3：</strong>上面讲解时一直强调说，只有在数据源发生变化且界面刷新之前，这两个方法才会有所区别，所以场景 3 就来模拟一下，通过 <code>mRecyclerView.post()</code> 的工作由于消息队列的同步屏障机制会被延迟到下一帧的屏幕刷新之后才执行（详情翻看我的历史博客），所以可以来比较下两次日志的区别，你就清楚了：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-0733bf5c3aa038d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景3日志.png"></p><p>左边的日志是场景 2 所打的日志，右边的日志是场景 3 下的日志。由于场景 3 将日志的执行时机延迟到下一帧的界面刷新之后，所有，可以看到，界面刷新之后，原本的第一个 Item 就被移除掉了。既然界面已经刷新了，那么数据源和界面的呈现其实就是一致的了，所以 <code>getLayoutPosition()</code> 返回的值就跟 <code>getAdapterPosition()</code> 是一致的了。</p><p><strong>小结：</strong>说得白点，<code>getLayoutPosition()</code> 会返回 Item 在界面上呈现的位置信息，不管数据源有没有发生变化，界面是否已刷新，总之你在界面上看到的 Item 在哪个位置，这个方法就会返回那个位置信息，注释里也说了，我们大部分场景下，使用这个方法即可。</p><p><code>getAdapterPosition()</code> 的使用场景是，当数据源发生变化，且界面刷新之前，你又需要获取 Item 在数据源中的实际位置时才需要考虑使用该方法。另外，使用该方法时，还要注意你是用哪种 notifyXXX 来通知刷新。这个方法的实际应用场景我还没遇到过，后续有用到再继续补充。</p><ul><li><strong>getOldPosition()</strong></li></ul><p>这个看注释说是用于处理动画时用的，但还没找到相关的场景，也没理解具体有啥样，后续再继续研究。</p><ul><li><strong>getItemId()</strong></li></ul><p>返回在 adapter 中通过 <code>getItemId(int position)</code> 为该 item 生成的 id，没有在 adapter 重写那个方法的话，就返回 RecyclerView.NO_ID。</p><p>用途在 adapter 一节讲解。</p><ul><li><strong>getItemViewType()</strong></li></ul><p>返回在 adapter 中通过 <code>getItemViewType()</code> 为该 item 设定的 type，没有在 adapter 重写那个方法的话，默认就是单一类型的 item type。</p><p>item type 是用于实现不同 item 样式。</p><ul><li><strong>setIsRecyclable()</strong></li></ul><p>RecyclerView 最大的特性就是它内部实现了一套高效的回收复用机制，而回收复用是以 ViewHolder 为单位进行管理的，每个 item 都会对应一个 ViewHolder，默认都是会参与进回收复用机制中。</p><p>但可以通过该方法来标志该 ViewHolder 不会被回收</p><h3 id="3-LayoutParams"><a href="#3-LayoutParams" class="headerlink" title="3. LayoutParams"></a>3. LayoutParams</h3><p>RecyclerView 自定义了 LayoutParams 内部类，在每个 Item 的 LayoutParams 携带了一些额外的信息，需要的话，我们也可以通过这里来获取这些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">ViewGroup</span>.<span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">viewNeedsUpdate</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewInvalid</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemRemoved</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemChanged</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewLayoutPosition</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewAdapterPosition</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公开的接口有以上几个，也就是说，我们可以通过 LayoutParams 获取到 item 的 position 信息、状态信息，是否需要刷新，是否被移除等等。</p><p>更多的应用场景留待后续补充。</p><h3 id="4-Adapter"><a href="#4-Adapter" class="headerlink" title="4. Adapter"></a>4. Adapter</h3><p>adapter 大伙肯定是最熟悉的了，写 RecyclerView 打交道最多的也就是 adapter 了，所以一些基本知识我就一笔带过了，本节着重介绍各种可选功能。</p><ul><li><strong>onCreateViewHolder()</strong></li><li><strong>onBindViewHolder()</strong></li><li><strong>getItemCount()</strong></li><li><strong>RecyclerView.ViewHolder</strong></li></ul><p>以上是写一个 adapter 时必须实现的四点，它们决定了 item 长啥样，填充啥数据，以及有多少个 item，有了这些信息，一个 RecyclerView 列表也就出来了。</p><ul><li><strong>notifyDataSetChanged()</strong></li><li><strong>notifyItemChanged()</strong></li><li><strong>notifyItemXXX() 系列</strong></li></ul><p>以上是用于刷新 item，当数据源发生变化时，我们手动去刷新 item。官方说了， item 的更新分两种，一种是数据需要更新，这类刷新不涉及到 item 的位置变化；而另一种属于结构刷新，就是涉及到 item 的位置变化。</p><p>使用 <strong>notifyDataSetChanged()</strong> 时，它不管你分哪种形式的刷新，强制所有 item 重新绑定数据，重新布局操作。</p><p>以上都属于常用的基本功能，一句话带过，下面介绍一些可选功能：</p><ul><li><strong>onViewRecycled()</strong></li><li><strong>onViewAttachedFromWindow()</strong></li><li><strong>onViewDetachedFromWindow()</strong></li><li><strong>onAttachedToRecyclerView()</strong></li><li><strong>onDetachedFromRecyclerView()</strong></li></ul><p>这些方法基本都是 item 或 adapter 的一些生命周期的回调，所以分别来看看每个方法都是什么时候会被回调的，可以用来处理什么场景，做些啥工作：</p><p><strong>onViewRecycled()</strong>：当 ViewHolder 已经确认被回收，且要放进 RecyclerViewPool 中前，该方法会被回调。</p><p>首先需要明确，RecyclerView 的回收机制在工作时，会先将移出屏幕的 ViewHolder 放进一级缓存中，当一级缓存空间已满时，才会考虑将一级缓存中已有的 ViewHolder 移到 RecyclerViewPool 中去。所以，并不是所有刚被移出屏幕的 ViewHoder 都会回调该方法。</p><p>另外，注释中也说了，该方法的回调是在 ViewHolder 放进 RecyclerViewPool 中前，而 ViewHolder 在放进 Pool 中时会被 reset，因为上一节中也说过，其实 ViewHolder 本身携带着很多信息。那么，在该方法回调时，这些信息还没被重置掉，官方建议我们可以在这里释放一些耗内存资源的工作，如 bitmap 的释放。</p><p><strong>onViewAttachedFromWindow()</strong><br><strong>onViewDetachedFromWindow()</strong>：</p><p>RecyclerView 本质上也是一个 ViewGroup，那么它的 Item 要显示出来，自然要 <code>addView()</code> 进来，移出屏幕时，自然要 <code>removeView()</code> 出去，对应的就是这两个方法的回调。</p><p>所以，当 Item 移出屏幕时，<code>onViewRecycled()</code> 不一定会回调，但 <code>onViewDetachedFromWindow()</code> 肯定会回调。相反，当 Item 移进屏幕内时，另一个方法则会回调。</p><p>那么，其实，在一定场景下，可以通过这两个回调来处理一些 Item 移出屏幕，移进屏幕所需要的工作。为什么说一定场景下呢，因为如果调用了 <code>notifyDataSetChanged()</code> 的话，会触发所有 Item 的 detached 回调先触发再触发 onAttached 回调。</p><p><strong>onAttachedToRecyclerView()</strong><br><strong>onDetachedFromRecyclerView()</strong>：</p><p>这两个回调则是当 RecyclerView 调用了 <code>setAdapter()</code> 时会触发，旧的 adapter 回调 onDetached，新的 adapter 回调 onAttached。</p><p>我们同样可以在这里来做一些资源回收工作，更多其他应用场景留待后续补充。</p><ul><li><strong>registerAdapterDataObserver()</strong></li><li><strong>unregisterAdapterDataObserver()</strong></li></ul><p>用于注册监听 <code>notifyXXX()</code> 系列方法的事件，当调用了 <code>notifyXXX()</code> 系列的方法时，注册监听后就可以接收到回调。</p><ul><li><strong>setHasStableIds()</strong></li><li><strong>getItemId()</strong></li></ul><p>这两方法看注释是说用于回收复用机制中，给 ViewHoler 设置一个唯一的标识符，但具体的使用场景还不清楚，后续有用到，再补充。</p><p>另，<code>setHasStableIds()</code> 必须在 <code>setAdapter()</code> 方法之前调用，否则会抛异常。</p><h3 id="5-RecyclerView"><a href="#5-RecyclerView" class="headerlink" title="5. RecyclerView"></a>5. RecyclerView</h3><h4 id="5-1-addOnItemTouchListener"><a href="#5-1-addOnItemTouchListener" class="headerlink" title="5.1 addOnItemTouchListener()"></a>5.1 addOnItemTouchListener()</h4><p>咋一看到这个方法，我还以为 RecyclerView 也把 item 的点击事件封装好了，终于不用我们自己去写了呢。看了下源码注释才发现，这个方法的作用是用于根据情况是否拦截触屏事件的分发。先看一下它的参数类型：OnItemTouchListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemTouchListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRequestDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉接口里的方法很熟悉，没错，就是触屏事件分发流程中的拦截和处理的两个方法。</p><p>通常我们都说在自定义 View 中重写这几个方法来将触屏事件拦截，交由自己处理。RecyclerView 也是一个 View，如果你有 RecyclerView 需要拦截触屏事件自己处理的需求，那么你可以选择继承 RecyclerView，也可以选择调用这个方法。</p><h4 id="5-2-addOnScrollListener"><a href="#5-2-addOnScrollListener" class="headerlink" title="5.2 addOnScrollListener()"></a>5.2 addOnScrollListener()</h4><p>RecyclerView 是一个列表控件，自然会涉及到滑动，所以它提供了滑动状态的监听接口，当我们需要在滑动状态变化时相对应的工作时，可以调用该方法注册滑动监听。来看看它的参数：OnScrollListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnScrollListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Callback method to be invoked when RecyclerView's scroll state changes.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> recyclerView The RecyclerView whose scroll state has changed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newState     The updated scroll state. One of &#123;<span class="doctag">@link</span> #SCROLL_STATE_IDLE&#125;,</span></span><br><span class="line"><span class="comment">    *                     &#123;<span class="doctag">@link</span> #SCROLL_STATE_DRAGGING&#125; or &#123;<span class="doctag">@link</span> #SCROLL_STATE_SETTLING&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onScrolled()</code>：滑动的实现本质上就是每一帧时要么通过动画，要么通过修改属性，一帧帧内处理一小段滑动，整个过程连起来就是一个流畅的滑动效果。这个方法就是每帧内处理的滑动距离，理想状态下，每帧都会回调一次，直到滑动结束。</p><p>如果想得到滑动的距离，方向的话，可以在这个方法里做。</p><p><code>onScrollStateChanged()</code>：该方法则是滑动状态变化时的回调，一共设置了三种状态：</p><ul><li>SCROLL_STATE_IDLE：停止滑动时的状态</li><li>SCROLL_STATE_DRAGGING：手指拖动时的状态</li><li>SCROLL_STATE_SETTLING：惯性滑动时的状态（这是我的理解）</li></ul><p>在手机应用上和 Tv 应用上，这些状态的回调还是有所区别的，所以分开来说一下：</p><ul><li>手机应用：</li></ul><p>手机上的 RecyclerView 列表控件，通常都是通常手指拖动来触发滑动的，因此在手指触摸并拖动的那个时刻，这个方法会被回调，参数传入 SCROLL_STATE_DRAGGING 表示进入拖动状态。</p><p>当手指放开的时候，分两种情况，一是手指放开后 RecyclerView 又根据惯性滑动了一段距离，只要有稍微滑动就算，那么这个时候进入惯性滑动时该方法会被回调，参数传入 SCROLL_STATE_SETTLING 表示进入了惯性滑动状态。当最终停止滑动后，该方法还会被回调，参数传入 SCROLL_STATE_IDLE。</p><p>另外一种情况是，手指放开后，RecyclerView 并没有任何滑动了，通常是手指很慢的拖动情况下放开，这时候该方法就会只回调一次，参数传入 SCROLL_STATE_IDLE，因为在手指还没放开前就已经停止滑动了，放开后更不会滑动，所以直接进入停止滑动状态。</p><p>所以，在手机应用上，ReyclerView 的滑动状态变化有两种，一是从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_SETTLING 再到 SCROLL_STATE_IDLE；另外一种是直接从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_IDLE。</p><ul><li>Tv 应用：</li></ul><p>由于 Tv 应用没有触摸事件，只有遥控器事件，因此 RecyclerView 滑动的触发都是由遥控器方向键操作后由于焦点的变化来触发的，所以在 Tv 应用上不会有 SCROLL_STATE_DRAGGING 这个状态。</p><p>每次滑动都是从 SCROLL_STATE_SETTLING 到 SCROLL_STATE_IDLE。</p><p>两者有所区别，需要注意一下，如果从事 Tv 应用开发的话。</p><h4 id="5-3-setHasFixedSize"><a href="#5-3-setHasFixedSize" class="headerlink" title="5.3 setHasFixedSize()"></a>5.3 setHasFixedSize()</h4><p>看方法注释，它是说，当你能够确定后续通过 <code>notifyItemXXX()</code> 系列方法来刷新界面时，RecyclerView 控件的宽高不会因为 item 而发生变化，那么这时候可以通过该方法来让 ReyclerView 每次刷新界面时不用去重新计算它本身的宽高。</p><p>从代码层面上来看，也就是说，当调用该方法设置了后，之后通过 <code>notifyItemXXX()</code> 系列方法刷新界面时，RecyclerView 的 <code>onMeasure()</code>, <code>onLayout()</code> 就不会被调用了，而是直接调用 LayoutManager 的 <code>onMeasure()</code>。</p><p>但这样做具体有什么好处，提高性能一点，但其他的就不清楚了。想了想，当 ReyclerView 控件的宽高模式是 match_parent 时，其实这个方法可以使用，因为此时它的宽高就不会受到 item 的因素影响了。如果模式为 wrap_content，那这个方法就不要用了。</p><h4 id="5-4-setLayoutFrozen"><a href="#5-4-setLayoutFrozen" class="headerlink" title="5.4 setLayoutFrozen()"></a>5.4 setLayoutFrozen()</h4><p>这方法可以禁掉 RecyclerView 的布局请求操作，而 RecyclerView 的滑动，item 的添加或移除本质上都会触发 RecyclerView 的重新测量、布局操作。</p><p>所以，调用该方法，其实等效于关闭了 ReyclerView 的刷新，不管数据源发生了何种变化，不管用户滑动了多长距离，都不会去刷新界面，看起来就像是不响应一样，但等到再次调用该方法参数传入 false 后，就会立马去根据变化后的数据源来刷新界面了。</p><p>使用场景还是有的，假如有些场景暂时不想让 RecyclerView 去刷新，比如此时有其他动画效果正在执行中，RecyclerView 刷新多少会有些耗时，万一导致了当前动画的卡顿，那么体验就不好了。所以，这个时候可以暂时将 ReyclerView 的刷新关闭掉，但后面记得要重新开启。</p><h4 id="5-5-setPreserveFocusAfterLayout"><a href="#5-5-setPreserveFocusAfterLayout" class="headerlink" title="5.5 setPreserveFocusAfterLayout()"></a>5.5 <em>setPreserveFocusAfterLayout()</em></h4><p>这个还没搞清它的应用场景是什么，注释是说，当在进行布局工作时，有些时候，会由于 item 的状态发生改变，或者由于动画等原因，导致焦点丢失。通过该方法可以再这些工作之后，再继续保持之前 item 的焦点状态。这个方法默认就是开启的。</p><p>但我测试了下，不管有没有开启这个方法，<code>notifyDataSetChanged()</code> 时，焦点仍然会乱飘，后续再继续查证。</p><h4 id="5-6-findChildViewUnder"><a href="#5-6-findChildViewUnder" class="headerlink" title="5.6 findChildViewUnder()"></a>5.6 findChildViewUnder()</h4><p>方法参数是 (float x, float y)，作用是查找指定坐标点 (x, y) 落于 RecyclerView 的哪个子 View 上面，这里的坐标点是以 RecyclerView 控件作为坐标轴，并不是以屏幕左上角作为坐标原点。</p><p>具体应用场景，目前还没遇到过，后续补充。</p><h4 id="5-7-findContainingItemView"><a href="#5-7-findContainingItemView" class="headerlink" title="5.7 findContainingItemView()"></a>5.7 findContainingItemView()</h4><p>该方法参数是 （View view），作用正如命名上的理解，查找含有指定 View 的 ItemView，而 ItemView 是指 RecyclerView 的直接子 View。</p><p>通常，RecyclerView 的 Item 布局都不会简单到直接就是一个具体的 TextView，往往都挺复杂的，比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-45b91396cbc6db60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Item布局.png"></p><p>Item 布局的结构至少如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种 item 已经算是很简单的了，那么如果我们当前拿到的是 TextView 对象，通过该方法就可以找到这个 TextView 的根布局，即 RecyclerView 的直接子 View，这里是 RelativeLayout 对象。</p><p><strong>应用场景：</strong></p><p>我想到一种应用场景，通常我们点击事件都是作用于具体的某个 View，比如上面的 TextView，那我们在点击事件的回调中就只能拿到 TextView 对象而已。而通过这个方法，我们可以拿到这个 TextView 所属的 ItemView。拿到 ItemView 之后可以做些什么呢？</p><p>看需求场景，反正总有些场景是需要用到根布局的。还有一点就是，RecyclerView 内部其实自定义了一个 LayoutParams，作用于它的直接子 View。所以只要我们可以拿到 RecyclerView 的直接子 View，就可以拿到它对应的 LayoutParams，那么就可以通过 LayoutParams 拿到一些这个 item 的信息，比如 position 等等。</p><h4 id="5-8-findContainingViewHolder"><a href="#5-8-findContainingViewHolder" class="headerlink" title="5.8 findContainingViewHolder()"></a>5.8 findContainingViewHolder()</h4><p>该方法参数是 （View view），作用跟上述方法类似，用于查找含有指定 View 的 ItemView 所对应的 ViewHolder。</p><p>这里就不展开介绍了，该方法跟上述的方法基本一模一样，区别就仅仅是一个用于查找 ItemView，一个用于查找 ItemView 对应的 ViewHoler。</p><p>至于应用场景，拿到 ViewHolder 能做的事就更多了，而是 LayoutParams 提供的信息其实内部也是去 ViewHolder 中拿的，所以实际上 Item 携带的各种信息基本都在 ViewHolder 上面了。</p><h4 id="5-9-findViewHolderXXX"><a href="#5-9-findViewHolderXXX" class="headerlink" title="5.9 findViewHolderXXX()"></a>5.9 findViewHolderXXX()</h4><p>既然 ViewHolder 携带着大量 Item 的相关信息，RecyclerView 自然也就提供了各种方式来获取 ViewHolder，这个系列的方法如下：</p><ul><li><strong>findViewHolderForAdapterPosition()</strong></li><li><strong>findViewHolderForLayoutPosition()</strong></li><li><strong>findViewHolderForItemId()</strong></li><li><strong>findContainingViewHolder()</strong></li></ul><p>通过 position, id, view 都可以获取到对应的 ViewHolder 对象。</p><h3 id="6-Recycler"><a href="#6-Recycler" class="headerlink" title="6. Recycler"></a>6. Recycler</h3><p>Recycler 是 RecyclerView 的一个内部类，主要职责就是处理回收复用相关工作的。</p><p>回收复用的单位是 ViewHolder，至于 Item 移出屏幕是怎样回收，回收到哪里，Item 移进屏幕时是怎样复用，整个流程是先复用再回收，还是先回收再复用，还是两边同时进行等等一系列的工作都是交由 Recycler 来处理。</p><p>关于回收复用机制的部分原理，基于滑动场景解析RecyclerView的回收复用机制原理](<a href="https://www.jianshu.com/p/9306b365da57)，感兴趣的可以先去看看。" target="_blank" rel="noopener">https://www.jianshu.com/p/9306b365da57)，感兴趣的可以先去看看。</a></p><p>本篇侧重点是介绍各个接口的含义和使用场景，至于回收复用机制，后续肯定还会继续深入去分析，敬请期待。</p><h4 id="6-1-setItemViewCacheSize"><a href="#6-1-setItemViewCacheSize" class="headerlink" title="6.1 setItemViewCacheSize()"></a>6.1 setItemViewCacheSize()</h4><p>有看到上面链接那篇文章的应该就清楚，当 item 被移出屏幕外时，其实这个 item 的 ViewHolder 会被回收掉，而 Recycler 里有一种分级缓存的概念。</p><p>分级缓存，说得白点，就是不同的容器，容器之间有优先级，回收时先将 ViewHolder 缓存到高优先级的容器中，容器满了的话，那就将容器腾出个位置来，被腾出来的 ViewHolder 这时就可以放到优先级较低的容器中。分级缓存的概念就是这样。</p><p>移出屏幕的 ViewHolder 会被缓存到两个容器中，按优先级高到低分别是：<strong>mCachedViews</strong> 和 <strong>mRecyclerPool</strong></p><p>该方法就是用于设置 <strong>mCachedViews</strong> 容器的大小，默认值为 2，可通过该方法随时改变缓存容器的大小。</p><p><strong>应用场景</strong>：</p><p>要搞清楚应用场景，那得先明白 <strong>mCachedViews</strong> 这一级的缓存有什么作用，建议还是到上面给出的链接的那篇文章看一看，就明白了。</p><p>这里大概说一下，个人对于 <strong>mCachedViews</strong> 这一级缓存的理解：这一级的缓存仅仅就只是用来缓存而已，里面存储的 ViewHolder 并没有通用的能力。换句话说也就是，只有原来位置的 Item 可复用这级容器里的 ViewHolder，其他位置的 Item 没办法使用。效果就好像是 ViewPager 之类的缓存一样，所以我才说它仅仅只有缓存的功能。</p><p>这样能达到的效果就是：当某个 Item 刚被移出屏幕外，下一步又立马移进屏幕时，此时并不会去触发到 Adapter 的 onBindXXX 的调用，也就是说，这一级缓存里的 ViewHolder 可直接 addView 到 RecyclerView 上面，不需要重新去设置数据，因为它原本携带的数据都还处于正常状态，并没有被重置掉。</p><h4 id="6-2-setViewCacheExtension"><a href="#6-2-setViewCacheExtension" class="headerlink" title="6.2 setViewCacheExtension()"></a>6.2 setViewCacheExtension()</h4><p>当 Item 要被移进屏幕时，Recycler 会先去那些不需要重新调用 onBindViewHolder() 的缓存容器中寻找是否有可直接复用的 Item，如果没找到，那么会接着调用开发者自定义扩展的复用工作，如果在这里也没找到，那么才会去 RecyclerViewPool 中根据 type 来寻找可复用的，再没找到最后就直接调用 onCreateViewHolder() 新建一个来使用。</p><p>先来看看开发者要怎么自定义扩展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我删了一些注释，留下一些困惑的点</span></span><br><span class="line"><span class="comment"> * 1. Note that, Recycler never sends Views to this method to be cached. It is developers</span></span><br><span class="line"><span class="comment"> * responsibility to decide whether they want to keep their Views in this custom cache</span></span><br><span class="line"><span class="comment"> * or let the default recycling policy handle it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCacheExtension</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.This method should not create a new View. Instead, it is expected to return</span></span><br><span class="line"><span class="comment">     * an already created View that can be re-used for the given type and position.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">getViewForPositionAndType</span><span class="params">(Recycler recycler, <span class="keyword">int</span> position, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着好像很简单是吧，就只需要实现一个方法，返回指定 position 和 type 下的 Item 的 View 即可，网上所有分析到回收复用机制时也全部都是这么一笔带过。</p><p><strong>但实际上，存在很多困惑点，这个到底该怎么用？</strong></p><p>注释 1 里说了，Recycler 永远也不会将 ItemView 发送到这个类里来缓存，然后还说由开发者自行决定是要自己维护这些缓存还说交由 Recycler 来处理。</p><p><strong>困惑1：</strong>交由 Recycler 来处理我能理解，毕竟 Recycler 只在复用的过程中开了个接口给开发者扩展使用，但回收的过程并没有开任何接口给开发者扩展。也正是基于这点，我就不理解官方说的让开发者自行维护，怎么维护？</p><p>注释 2 中，官方告诉我们在这个方法中，不要去新建一个新的 ItemView，而是直接从旧的里面拿一个复用。</p><p><strong>困惑2：</strong>我又不知道怎么自己去维护 ViewHolder，那不新建一个 ItemView 又该如何使用，直接借助 Recycler？但 Recycler 不是只开放了 getViewForPosition()？本来内部在复用时就是自己调了这个方法，我们在这个方法内部走到开发者扩展自定义扩展的流程时再重新调一下？那不是就陷入嵌套循环里了？有什么意义或者应用场景么？</p><p>最最困惑的一点，国内居然找不到任何一篇讲解如何使用这个自定义缓存的相关文章！？</p><p>不清楚是由于他们文章的标题太过抽象没加入我的关键词过滤中，还是我关键词提取太烂，总之就是找不到任何一篇相关文章。所以，这小节先埋个坑，我打算后续抽时间自己来研究一下，到底应该如何使用自定义 RecyclerView 的缓存策略，到底都有哪些应用场景。</p><h4 id="6-3-setRecycledViewPool"><a href="#6-3-setRecycledViewPool" class="headerlink" title="6.3 setRecycledViewPool()"></a>6.3 setRecycledViewPool()</h4><p>最后一级缓存就是 RecyclerViewPool，这个容器有三个特性：</p><ul><li>缓存到 RecyclerViewPool 中的 ViewHolder，携带的信息都会被重置，因此从这个容器中取 ViewHolder 去复用时，都会触发 <code>onBindViewHolder()</code> 重新绑定数据。</li><li>多个 RecyclerView 可共用同一个 RecyclerViewPool 容器。</li><li>该容器以 Item 的 type 区分缓存，每种 type 的默认存储容量为 5。</li></ul><p>一般当我们需要修改这个缓存容器的大小，或者需要设置多个 RecyclerView 共用一个 RecyclerViewPool 时才需要调用到该方法。并且，官方在注释中也给出一种应用场景：使用 ViewPager 时各页面中的 RecyclerView 有相同的 Item 布局结构。</p><p><strong>应用场景：</strong></p><p>我们来举个例子，就不用官方给的例子了，我额外补充一种场景：界面上存在多行可分别左右滑动的列表控件，即每行是一个 RecyclerView，每行里的 Item 布局样式一致，这时候就可以让每一行的 RecyclerView 共用一个 RecyclerViewPool 缓存池了，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-9e528ee638e837a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多行可局部滑动.png"></p><p>以上布局的实现是外层一个竖直方向的 RecyclerView，它的每一个 Item 都是占据一行的水平方向的 RecyclerView，也就是嵌套 RecyclerView 的方式，实现可上下滑动且每一行均可左右滑动的效果。</p><p>这里的每一行的 RecyclerView 里的每个 Item 项的样式均一致，那么这种场景下，可以让每一行的 RecyclerView 都共用同一个 RecyclerViewPool 缓存池。这样的好处是，当某一行被移出屏幕时，可以将这一行的每个卡位都回收起来，供其他行使用，而不至于每一行每次都是重新创建。</p><p>但有些<strong>注意事项</strong>：</p><ul><li>外层 RecyclerView 缓存复用的应该仅仅是每一行的 RecyclerView 控件而已，不应该包括每一行 RecyclerView 内部的卡位控件，因为各行卡位的个数并不一定相同。</li><li>对于外层 RecyclerView 来说，它的 Item 是每一行的 RecyclerView 控件，所以当某一行被移出屏幕时，它仅仅是将这一行的 RecyclerView 控件从它本身 remove 掉，并回收起来。因此，此时这一行的 RecyclerView 还是携带着它的卡位子 View 的，所以需要我们手动去将这些卡位回收、并从父控件上 remove 掉。</li><li>这个操作可以在外层 RecyclerView 的 adapter 的 <code>onViewRecycled()</code> 回调中进行，也可以在内层每个 RecyclerView 的 adapter 的 <code>onViewDetachedFromWindow()</code> 回调中进行。</li><li>移除并回收卡位可通过 <code>setAdapter(null)</code> 配合 RecyclerView 本身的 <code>removeAllView()</code> 或者 LayoutManager 的 <code>removeAllView()</code> 实现 。或者直接使用 LinearLayoutManager 的 <code>setRecycleChildrenOnDetach()</code> 功能。</li></ul><h4 id="6-4-setRecyclerListener"><a href="#6-4-setRecyclerListener" class="headerlink" title="6.4 setRecyclerListener()"></a>6.4 setRecyclerListener()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RecyclerView$Recycler#</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchViewRecycled</span><span class="params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRecyclerListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRecyclerListener.onViewRecycled(holder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAdapter.onViewRecycled(holder);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这个方法设置的监听 Item 的回收，回调的时机跟 adapter 的 onViewRecycled() 一模一样，都是在 mCachedViews 容器满了之后，放入 RecyclerViewPool 之前被回调。</p><h3 id="7-ItemAnimator"><a href="#7-ItemAnimator" class="headerlink" title="7. ItemAnimator"></a>7. ItemAnimator</h3><p>RecyclerView 是支持对每个 item 做各种各样动画的，那么什么时候才该去执行这些 item 动画呢？说白了，也就是 adapter 数据源发生变化的时候，那么变化的方式无外乎就是四种：add, remove, change, move。相对应的，也就是这些状态时的 item 动画。</p><p>所以当要自定义实现 ItemAnimator 时，需要实现的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateDisappearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animatePersistence</span><span class="params">(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateChange</span><span class="params">(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">runPendingAnimations</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">(ViewHolder item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endAnimations</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>看起来，要实现一个自定义的 Item 好像很复杂，要实现这么多方法。网上这方面的文章已经非常多了，也都跟你说清了每个方法的含义是什么，在这里写些什么，甚至流程都帮你列出来了。</p><p>但大伙会不会好奇，这帮牛人是咋这么清楚的呢？</p><p>其实，Google 内部已经封装好了一个默认动画的实现，有时间大伙可以自己过一下源码，看看默认动画是怎么做的，理解清楚了后，举一反三下，其实也就懂了。</p><p>我目前也不懂，但我就是带着这么一种想法，也是打算这么去做的。虽然跟着大神的文章，最后确实能实现想要的效果，但其实掌握并不是很牢，并不大清楚为什么需要这么写，只是因为大神说这里这么写，然后就这么写了。</p><p>所以，有时间有精力，还是建议深入源码中去学习，自己梳理出来的知识终归是自己的。</p><h4 id="7-1-SimpleItemAnimator"><a href="#7-1-SimpleItemAnimator" class="headerlink" title="7.1 SimpleItemAnimator"></a>7.1 SimpleItemAnimator</h4><p>当 adapter 数据源发生变化，通知了 RecyclerView 去刷新界面时，RecyclerView 会去通知 ItemAnimaotr 此时相应的动画行为。</p><p>比如 add 了一个 Item，那么就会去触发 ItemAnimator 的 <code>animateAppearance()</code> 方法，并将这个 ItemView 在刷新前后不同的信息，如默认携带的信息是 RecyclerView 内部类 ItemHolderInfo，这个类里有关于这个 Item 的坐标信息。</p><p>那么，开发者就可以在这些回调方法里自行判断刷新前后的 Item 的不同信息来决定是否需要进行相对应的动画。</p><p><strong>而 SimpleItemAnimator 其实就是帮忙处理这件事，也就是说，它在四个回调中，如 animateAppearance() 中，根据 Item 前后的坐标信息来判断该 Item 需要进行的动画类型</strong>。</p><p>比如 <code>animateAppearance()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLayoutInfo != <span class="keyword">null</span> &amp;&amp; (preLayoutInfo.left != postLayoutInfo.left</span><br><span class="line">        || preLayoutInfo.top != postLayoutInfo.top)) &#123;</span><br><span class="line">         <span class="comment">// slide items in if before/after locations differ</span></span><br><span class="line">         <span class="keyword">return</span> animateMove(viewHolder, preLayoutInfo.left, preLayoutInfo.top,</span><br><span class="line">                postLayoutInfo.left, postLayoutInfo.top);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> animateAdd(viewHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 RecyclerView 回调了 <code>animateAppearance()</code> 方法后，SimpleItemAnimator 内部对其进行的分类，根据参数判断，最终是要执行 <code>animateMove()</code> 类型的动画，还是执行 <code>animateAdd()</code> 类型的动画。</p><p>同理，对于另外三个回调方法，SimpleItemAnimator 内部同样对其进行了封装处理，简单的通过刷新前后 Item 的坐标信息来进行动画类型的区分。</p><p>所以，这个类并没有实现任何动画的逻辑，它只是将动画的准备工作做好，简化开发者开发。所以，如果想要自定义 ItemAnimator，其实没必要从零开始继承自 ItemAnimator 自己写，是可以借助 SimpleItemAnimator 这个类的。</p><h4 id="7-2-DefaultItemAnimator"><a href="#7-2-DefaultItemAnimator" class="headerlink" title="7.2 DefaultItemAnimator"></a>7.2 DefaultItemAnimator</h4><p>RecyclerView 默认有提供 Item 的动画，而 SimpleItemAnimator 只是处理跟动画无关的准备工作，那么具体的默认动画的实现就是在 DefaultItemAnimator 这个类中实现的了。</p><p>先看一下这个类的结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-06de56724562ea79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DefaultItemAnimagtor结构.png"></p><p>它是继承自 SimpleItemAnimator 的，我们如果想要自定义实现一些 Item 动画，需要写的东西，大概就跟上图类似。</p><p>想要自定义 Item 动画，真的可以来参考、借鉴这个类的实现，能学到的东西很多。</p><p>我也还没深入去仔细学习，大概过了一眼，这里就大概说下：</p><p>这个类用了很多集合来维护各种不同类型的动画，在四个 <code>animateXXX()</code> 方法中通过集合记录相对应类型的动画和做了动画的初始化工作。</p><p>然后在 <code>runPendingAnimations()</code> 方法中，依次遍历这些集合，将记录的动画取出来执行，动画的实现方式是通过 <code>View.animate()</code> 方式实现，这种方式的动画本质上是借助了 ValueAnimator 机制，在每帧的回调过程中手动调用 <code>setXXX()</code> 来实现的动画效果。具体分析可参考一篇文章：<a href="https://www.jianshu.com/p/b43cf452afc1" target="_blank" rel="noopener">View.animate()动画ViewPropertyAnimator原理解析</a>。</p><p>大体上的流程原理就是这样，当然，这个类做的事肯定不止这些，还包括了集合的清理维护工作，动画的维护等等，所以很值得去借鉴学习一番。但这里就只给出大概的流程，本篇重点不在这里。</p><p>下面就来列举下，默认实现的各类型的动画分别是什么：</p><p><strong>animateAdd</strong> -&gt; 透明度 0 ~ 1 的动画，默认动画时长 120 ms</p><p><strong>animateChange</strong> -&gt; 涉及两个 ItemView，旧的跟新的，默认动画时长 250ms</p><p>旧 ItemView：透明度从原有值 ~ 0，位置从原坐标移动到新 ItemView 坐标的动画组合</p><p>新 ItemView：透明度从 0 ~ 1，位置从旧 ItemView 坐标移动到新坐标的动画组合</p><p><strong>animateMove</strong> -&gt; 从原坐标位置移动到新坐标位置的移动动画，默认动画时长 250 ms</p><p><strong>animateRemove</strong> -&gt; 从原有透明度 ~ 0 的动画，默认动画时长 120 ms</p><p>所以，RecyclerView 默认的 Item 动画其实也就透明度和移动动画两种，而且大多数情况下都只是单一的动画，只有 change 类型时才会是组合动画。</p><p><strong>效果展示：</strong></p><p>首先，可通过下列方式修改动画时长，这里将动画时长延长，方便查看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.getItemAnimator().setAddDuration(1000);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-baf6b6217218ae9f.gif?imageMogr2/auto-orient/strip" alt="20180702_162126.gif"></p><p>可以看到，动画基本就只有透明度动画跟移动动画两种。</p><p>另外，只有通过 <code>notifyItemXXX()</code> 方式更新数据源时才会触发动画行为，如果是通过 <code>notifyDataSetChange()</code> 方式，则不会触发动画。</p><h3 id="8-ItemDecoration"><a href="#8-ItemDecoration" class="headerlink" title="8. ItemDecoration"></a>8. ItemDecoration</h3><p>RecyclerView 支持为每个 Item 之间自定义间隔样式，是要空段距离，还是要以分割线隔开，还是要唯美唯幻的边框，想长啥样都行，自己写得出来就可以了，它给我们提供了这个接口。</p><p>本节就先介绍下系统内置的几种样式，内置里一共有三个类继承该类，分别是 DividerItemDecoration，ItemTouchHelper，FastScroller。前两个都是 public 权限，最后一个包权限，下面分别看看它们都有哪些效果，最后再来看看如何自定义。</p><h4 id="8-1-DividerItemDecoration"><a href="#8-1-DividerItemDecoration" class="headerlink" title="8.1 DividerItemDecoration"></a>8.1 DividerItemDecoration</h4><p>看一下这个类的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DividerItemDecoration is a &#123;<span class="doctag">@link</span> RecyclerView.ItemDecoration&#125; that can be used as a divider</span></span><br><span class="line"><span class="comment"> * between items of a &#123;<span class="doctag">@link</span> LinearLayoutManager&#125;. It supports both &#123;<span class="doctag">@link</span> #HORIZONTAL&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #VERTICAL&#125; orientations.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     mDividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(),</span></span><br><span class="line"><span class="comment"> *             mLayoutManager.getOrientation());</span></span><br><span class="line"><span class="comment"> *     recyclerView.addItemDecoration(mDividerItemDecoration);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DividerItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the &#123;<span class="doctag">@link</span> Drawable&#125; for this divider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawable Drawable that should be used as a divider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawable</span><span class="params">(@NonNull Drawable drawable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (drawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Drawable cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mDivider = drawable;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么用，类注释也给我们示例了，有点可惜的是，它只能用于 LinearLayoutManager 这种布局，而 GridLayoutManager 继承自 LinearLayoutManager，所以它也可以用，但需要注意的是，它只有一个方向会生效。来看看如何使用和效果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DividerItemDecoration itemDecoration = <span class="keyword">new</span> DividerItemDecoration(mContext, LinearLayoutManager.HORIZONTAL);</span><br><span class="line">itemDecoration.setDrawable(getResources().getDrawable(R.drawable.divider_space));</span><br><span class="line">mRecyclerView.addItemDecoration(itemDecoration);</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.drawable.divider_space</span></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;shape xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;size android:width=<span class="string">"20dp"</span> android:height=<span class="string">"20dp"</span>/&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure><p>我们在 xml 中写宽度为 20dp 的空隙，然后调用 <code>setDrawable()</code> 应用，看看效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-02ae65a7f2cce81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="空隙示例.png"></p><p>这样就可以达到将 item 隔离开的效果了，中间这个空隙的样式你可以自己通过 xml 写，也可以直接使用图片，都可以，只要是 Drawable 类型的即可。</p><p>虽然说，RecyclerView 不像 ListView 只要设置个属性就可以达到设置 Item 之间空隙的样式，但它也内置了基本的实现，其实也已经方便了我们的使用。</p><h4 id="8-2-ItemTouchHelper"><a href="#8-2-ItemTouchHelper" class="headerlink" title="8.2 ItemTouchHelper"></a>8.2 <em>ItemTouchHelper</em></h4><p>这是一个工具类，也是 Google 为了方便开发人员实现 item 的拖拽和移动等等效果所提供的一个辅助工具类。借助这个类可以很容易实现 item 的侧滑删除、长按拖拽等功能。</p><p>由于这部分我没有研究过，日常也较少接触，所以暂时先从网上搜索一篇文章，以下的效果图来自大神的博客，会给出链接，侵权删。后续有接触相关需求时再自行来研究一番。</p><p><a href="https://blog.csdn.net/wuyuxing24/article/details/78985026" target="_blank" rel="noopener">推荐博客： ItemTouchHelper源码分析</a></p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-470540d87bab3787.gif?imageMogr2/auto-orient/strip" alt="20180105202851329.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-36ecbcb6385c86cc.gif?imageMogr2/auto-orient/strip" alt="20180105202823469.gif"></p><h4 id="8-3-FastScroller"><a href="#8-3-FastScroller" class="headerlink" title="8.3 FastScroller"></a>8.3 <em>FastScroller</em></h4><p>这个类也是继承自 ItemDecoration，但它的类权限只是包权限，不开放给外部使用，稍微看了下注释，说是用来处理动画以及快速滑动相关的支持，具体原理是什么，如何生效，留待后续深入研究时再来分析。</p><h4 id="8-4-自定义ItemDecoration"><a href="#8-4-自定义ItemDecoration" class="headerlink" title="8.4 自定义ItemDecoration"></a>8.4 自定义ItemDecoration</h4><p>上面说过系统默认提供的 DividerItemDecoration 只支持用于 LinearLayoutManager，而如果用于 GridLayoutManager 时，只有一个方向会生效，那么下面我们就以 GridLayoutManager 为例，来看看，如何自定义写 ItemDecoration。</p><p>用 GridLayoutManager 实现一个四列的布局，然后让除了四个边的 Item 外，内部的每个 Item 之间相互间隔 20 dp 的空隙。为了能更明显看出，将 20dp 的空隙用红色绘制出来。</p><p>先来看下效果：</p><ul><li>4 列布局 &amp; 2 行布局</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-4c6b0f5f95f53602.gif?imageMogr2/auto-orient/strip" alt="20180619_200035.gif"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> spanCount;<span class="comment">//几行或几列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orientation;<span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> itemSpace;<span class="comment">//空隙大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Rect mBounds = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;<span class="comment">//用来将空隙绘制成红色的画笔</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyItemDecoration</span><span class="params">(GridLayoutManager gridLayoutManager)</span> </span>&#123;</span><br><span class="line">        spanCount = gridLayoutManager.getSpanCount();</span><br><span class="line">        orientation = gridLayoutManager.getOrientation();</span><br><span class="line">        initPaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">        mPaint.setColor(Color.RED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemSpace</span><span class="params">(<span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">        itemSpace = space;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        c.save();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = parent.getChildAt(i);</span><br><span class="line">            parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds);</span><br><span class="line">            c.drawRect(mBounds, mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">        c.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前view的layoutPosition</span></span><br><span class="line">        <span class="keyword">int</span> itemPosition = parent.getChildLayoutPosition(view);</span><br><span class="line">        <span class="comment">//计算该View位于哪一行哪一列</span></span><br><span class="line">        <span class="keyword">int</span> positionOfGroup = itemPosition % spanCount;</span><br><span class="line">        <span class="keyword">int</span> itemGroup = itemPosition / spanCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据不同方向进行不同处理，最终效果都要实现除四周的View 外，内部的View之间横竖都以相同空隙间隔开</span></span><br><span class="line">        <span class="comment">//实现方式，以水平方向为例：</span></span><br><span class="line">        <span class="comment">//每个view的left和bottom都设置相同间隙</span></span><br><span class="line">        <span class="comment">//去掉第1列的left，和最后一行的bottom，也就实现了除四周外内部view都以相同间隙空隔开</span></span><br><span class="line">        <span class="keyword">if</span> (orientation == LinearLayoutManager.HORIZONTAL) &#123;</span><br><span class="line">            outRect.set(itemSpace, <span class="number">0</span>, <span class="number">0</span>, itemSpace);</span><br><span class="line">            <span class="keyword">if</span> (itemGroup == <span class="number">0</span>) &#123;</span><br><span class="line">                outRect.left = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positionOfGroup == (spanCount - <span class="number">1</span>)) &#123;</span><br><span class="line">                outRect.bottom = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == LinearLayoutManager.VERTICAL) &#123;</span><br><span class="line">            outRect.set(<span class="number">0</span>, itemSpace, itemSpace, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (itemGroup == <span class="number">0</span>) &#123;</span><br><span class="line">                outRect.top = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positionOfGroup == (spanCount - <span class="number">1</span>)) &#123;</span><br><span class="line">                outRect.right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：由于 GridLayoutManager 会根据设置的 Orientation 方向，默认为 VERTICAL 数值方向，以及 RecyclerView 的宽高模式来决定是否自动将某一方向的空隙平均分配给各 Item，这点需要注意一下。</p><p>以上的例子想说明，如果要自定义写 Iiem 间的空隙，那么关键点在于重写两个方法：</p><ul><li><code>getItemOffsets()</code></li><li><code>onDraw()</code></li></ul><p>第 1 个方法会携带很多参数，最重要的是 outRect 这个参数，它是一个 Rect 类型的对象，重写这个方法并设置了这个 outRect 的 left, top, right, bottom，就相当于设置了对应这个 view 的四周分别有多大的空隙。</p><p>其他的参数是用来给我们辅助使用，如果不需要区分对待，每个 item 的四周都是同样的间隔空隙，那直接设置 outRect 即可。</p><p>如果需要像上述例子那样，要求四周的 Item 的间隙要区别于内部 item 的间隙，那么就需要判断出这个 View 的位置，因此可以通过其他参数辅助配合实现。</p><p><code>onDraw()</code> 这个方法就是用于绘制，注意这个方法参数只给了 RecyclerView，而绘制 item 的 Decoration 是针对于每个 item 而言的，所以内部需要通过遍历子 View 来对每个 item 进行绘制操作。</p><p>当然，我这里写得很粗糙，考虑到性能优化方面，绘制过度方面等等因素，通常是需要使用到 canvas.clipRect()。这部分代码建议可以参考 DividerItemDecoration 内部的实现。</p><h3 id="9-OnFlingListener"><a href="#9-OnFlingListener" class="headerlink" title="9. OnFlingListener"></a>9. <em>OnFlingListener</em></h3><p>RecyclerView 是可滑动控件，在平常使用过程中，我们可能就是上滑，下滑，左边滑滑，右边滑滑，能够刷新更多列表即可，通常都没太过去注意到滑动的细节。</p><p>但其实，滑动策略也是支持多样化的。</p><p>比如，如果想要实现不管以多大的加速度滑动，滑多长距离，最终停下来时都系统有个 ItemView 是居中显示的效果。</p><p>再比如，只希望翻页滑动，当手指滑动距离小于翻页时，自动滑回原位进行翻页等等。</p><p>这些滑动策略其实就可以直接借助内置的两个类来实现：LinearSnapHelper 和 PagerSnapHelper</p><p><strong>ps：本来以为这种滑动策略也是支持由焦点触发的滑动行为的，最后测试时才发现，原来只支持手指触摸式的滑动行为。由于我是搞 Tv 应用开发的，Tv 应用没有触摸事件，只有遥控器事件，滑动是由于焦点的变化触发的滑动行为。而在 Tv 上，Item 居中的需求也非常常见，但利用这个是无法实现的。所以，我就先不打算深入了解这块了，后续有时间再来慢慢研究。附上鸿神公众号中的一篇文章，大伙看这篇就行了。</strong></p><p><a href="https://www.jianshu.com/p/ef3a3b8d0a77" target="_blank" rel="noopener">Android中使用RecyclerView + SnapHelper实现类似ViewPager效果</a></p><p><img src="https://upload-images.jianshu.io/upload_images/3513995-aafe6c4113148c23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><h4 id="9-1-SnapHelper"><a href="#9-1-SnapHelper" class="headerlink" title="9.1 SnapHelper"></a>9.1 <em>SnapHelper</em></h4><h4 id="9-2-LinearSnapHelper"><a href="#9-2-LinearSnapHelper" class="headerlink" title="9.2 LinearSnapHelper"></a>9.2 <em>LinearSnapHelper</em></h4><h4 id="9-3-PagerSnapHelper"><a href="#9-3-PagerSnapHelper" class="headerlink" title="9.3 PagerSnapHelper"></a>9.3 <em>PagerSnapHelper</em></h4>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;虽然在日常开发中，大伙或多或少都会接触到 RecyclerView，但通常，也就是写写 adapter，用个系统提供的 LayoutManager，写写点击事件，处理处理复杂的 item 布局。&lt;/p&gt;
&lt;p&gt;也就是说，大部分场景下，我们其实并不会去接触到 RecyclerView 的大部分其他功能，比如自定义 LayoutManager ，自定义 Item 动画，自定义边界样式，自定义滑动效果，自定义回收策略等等之类的功能。&lt;/p&gt;
&lt;p&gt;那么，本篇就专门来试用下这些功能，力求将 RecyclerView 支持的所有功能都试一遍，只有清楚了这个控件都支持哪些功能效果，那么分析起它的架构、原理才会有一个比较清晰的脉络。&lt;/p&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;p&gt;由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。&lt;/p&gt;
&lt;p&gt;另外，由于有些平台可能不支持 `` 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.&lt;strong&gt;LayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.1 &lt;strong&gt;LinearLayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;findFirstCompletelyVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findFirstVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findLastCompletelyVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findLastVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;setRecycleChildrenOnDetach()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.2 &lt;strong&gt;GridLayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;setSpanSizeLookUp()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.3 &lt;strong&gt;StaggeredGridLayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;setFullSpan()&lt;/li&gt;
&lt;li&gt;findXXX() 系列方法介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;strong&gt;ViewHolder&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getAdapterPosition()&lt;/li&gt;
&lt;li&gt;getLayoutPosition()&lt;/li&gt;
&lt;li&gt;setIsRecyclable()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;strong&gt;LayoutParams&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;Adapter&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本用法介绍&lt;/li&gt;
&lt;li&gt;onViewRecycled()&lt;/li&gt;
&lt;li&gt;onViewAttachedFromWindow()&lt;/li&gt;
&lt;li&gt;onViewDetachedFromWindow()&lt;/li&gt;
&lt;li&gt;onAttachedToRecyclerView()&lt;/li&gt;
&lt;li&gt;onDetachedFromRecyclerView()&lt;/li&gt;
&lt;li&gt;registerAdapterDataObserver()&lt;/li&gt;
&lt;li&gt;unregisterAdapterDataObserver()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.&lt;strong&gt;RecyclerView&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;addOnItemTouchListener()&lt;/li&gt;
&lt;li&gt;addOnScrollListener()&lt;/li&gt;
&lt;li&gt;setHasFixedSize()&lt;/li&gt;
&lt;li&gt;setLayoutFrozen()&lt;/li&gt;
&lt;li&gt;setPreserveFocusAfterLayout()&lt;/li&gt;
&lt;li&gt;findChildViewUnder()&lt;/li&gt;
&lt;li&gt;findContainingItemView()&lt;/li&gt;
&lt;li&gt;findContainingViewHolder()&lt;/li&gt;
&lt;li&gt;findViewHolderXXX()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6.&lt;strong&gt;Recycler&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setItemViewCacheSize()&lt;/li&gt;
&lt;li&gt;setViewCacheExtension()&lt;/li&gt;
&lt;li&gt;setRecycledViewPool()&lt;/li&gt;
&lt;li&gt;setRecyclerListener()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7.&lt;strong&gt;ItemAnimator&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SimpleItemAnimator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DefaultItemAnimator&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;8.&lt;strong&gt;ItemDecoration&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DividerItemDecoration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ItemTouchHelper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FastScroller&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9.&lt;strong&gt;OnFlingListener&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SnapHelper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LinearSnapHelper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PagerSnapHelper&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="RecyclerView" scheme="https://zhangmiao.cc/tags/RecyclerView/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android判断当前应用是否开启消息通知</title>
    <link href="https://zhangmiao.cc/posts/7299f542.html"/>
    <id>https://zhangmiao.cc/posts/7299f542.html</id>
    <published>2019-09-28T10:48:43.000Z</published>
    <updated>2019-09-28T10:51:55.192Z</updated>
    
    <content type="html"><![CDATA[<p>当APP有推送功能时，需要判断当前app在手机中是否开启了允许消息推送，否则即使添加了推送代码仍然收不到通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotificationEnabled</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> isOpened = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           isOpened = NotificationManagerCompat.from(context).areNotificationsEnabled();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           isOpened = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> isOpened;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Api24以上，NotificationManagerCompat中提供了areNotificationsEnabled()方法。该方法中已经对API19以下，API19-24，API24以上，这三种情况做了判断。直接使用其返回值即可。</p><p>该方法如果返回true表示打开了消息通知，如果返回false则没有打开。没有打开则跳转设置界面。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gotoSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">    <span class="comment">// android 8.0引导</span></span><br><span class="line">    intent.setAction(<span class="string">"android.settings.APP_NOTIFICATION_SETTINGS"</span>);</span><br><span class="line">      intent.putExtra(<span class="string">"android.provider.extra.APP_PACKAGE"</span>, getPackageName());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">    <span class="comment">// android 5.0-7.0</span></span><br><span class="line">    intent.setAction(<span class="string">"android.settings.APP_NOTIFICATION_SETTINGS"</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"app_package"</span>, getPackageName());</span><br><span class="line">    intent.putExtra(<span class="string">"app_uid"</span>, getApplicationInfo().uid);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他</span></span><br><span class="line">    intent.setAction(<span class="string">"android.settings.APPLICATION_DETAILS_SETTINGS"</span>);</span><br><span class="line">    intent.setData(Uri.fromParts(<span class="string">"package"</span>, getPackageName(), <span class="keyword">null</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">  startActivity(intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以在Activity的onCreate中进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断该app是否打开了通知，如果没有的话就打开手机设置页面</span></span><br><span class="line"><span class="keyword">if</span> (!isNotificationEnabled()) &#123;</span><br><span class="line"> gotoSet();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">//当前app允许消息通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当APP有推送功能时，需要判断当前app在手机中是否开启了允许消息推送，否则即使添加了推送代码仍然收不到通知&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isNotificationEnabled&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isOpened = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           isOpened = NotificationManagerCompat.from(context).areNotificationsEnabled();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           isOpened = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isOpened;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Api24以上，NotificationManagerCompat中提供了areNotificationsEnabled()方法。该方法中已经对API19以下，API19-24，API24以上，这三种情况做了判断。直接使用其返回值即可。&lt;/p&gt;
&lt;p&gt;该方法如果返回true表示打开了消息通知，如果返回false则没有打开。没有打开则跳转设置界面。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;gotoSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	  Intent intent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= &lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// android 8.0引导&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setAction(&lt;span class=&quot;string&quot;&gt;&quot;android.settings.APP_NOTIFICATION_SETTINGS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      intent.putExtra(&lt;span class=&quot;string&quot;&gt;&quot;android.provider.extra.APP_PACKAGE&quot;&lt;/span&gt;, getPackageName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// android 5.0-7.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setAction(&lt;span class=&quot;string&quot;&gt;&quot;android.settings.APP_NOTIFICATION_SETTINGS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.putExtra(&lt;span class=&quot;string&quot;&gt;&quot;app_package&quot;&lt;/span&gt;, getPackageName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.putExtra(&lt;span class=&quot;string&quot;&gt;&quot;app_uid&quot;&lt;/span&gt;, getApplicationInfo().uid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// 其他&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setAction(&lt;span class=&quot;string&quot;&gt;&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setData(Uri.fromParts(&lt;span class=&quot;string&quot;&gt;&quot;package&quot;&lt;/span&gt;, getPackageName(), &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	startActivity(intent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们可以在Activity的onCreate中进行判断：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//判断该app是否打开了通知，如果没有的话就打开手机设置页面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isNotificationEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	gotoSet();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;comment&quot;&gt;//当前app允许消息通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android调用系统分享</title>
    <link href="https://zhangmiao.cc/posts/c19f18fd.html"/>
    <id>https://zhangmiao.cc/posts/c19f18fd.html</id>
    <published>2019-09-27T05:54:31.000Z</published>
    <updated>2019-09-27T06:04:36.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取Android系统分享列表"><a href="#获取Android系统分享列表" class="headerlink" title="获取Android系统分享列表"></a>获取Android系统分享列表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;AppInfoVo&gt; <span class="title">getShareApps</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        PackageManager packageManager = context.getPackageManager();</span><br><span class="line">        List&lt;AppInfoVo&gt; appInfoVos = <span class="keyword">new</span> ArrayList&lt;AppInfoVo&gt;();</span><br><span class="line">        List&lt;ResolveInfo&gt; resolveInfos = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND, <span class="keyword">null</span>);</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">        intent.setType(<span class="string">"*/*"</span>);</span><br><span class="line">        PackageManager pManager = context.getPackageManager();</span><br><span class="line">        resolveInfos = pManager.queryIntentActivities(intent, PackageManager</span><br><span class="line">                .COMPONENT_ENABLED_STATE_DEFAULT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resolveInfos.size(); i++) &#123;</span><br><span class="line">            AppInfoVo appInfoVo = <span class="keyword">new</span> AppInfoVo();</span><br><span class="line">            ResolveInfo resolveInfo = resolveInfos.get(i);</span><br><span class="line">            appInfoVo.setAppName(resolveInfo.loadLabel(packageManager).toString());</span><br><span class="line">            appInfoVo.setIcon(resolveInfo.loadIcon(packageManager));</span><br><span class="line">            appInfoVo.setPackageName(resolveInfo.activityInfo.packageName);</span><br><span class="line">            appInfoVo.setLauncherName(resolveInfo.activityInfo.name);</span><br><span class="line">            appInfoVos.add(appInfoVo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appInfoVos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分享文本信息"><a href="#分享文本信息" class="headerlink" title="分享文本信息"></a>分享文本信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT,<span class="string">"This is a text"</span>);</span><br><span class="line">startActivity(Intent.createChooser(intent,<span class="string">"Share"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享单张图片"><a href="#分享单张图片" class="headerlink" title="分享单张图片"></a>分享单张图片</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".png"</span>);<span class="comment">//这里test.png是sd卡根目录下的一个图片文件</span></span><br><span class="line">Uri imageUri = Uri.fromFile(file);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, imageUri);</span><br><span class="line">startActivity(Intent.createChooser(intent, <span class="string">"Share"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享视频"><a href="#分享视频" class="headerlink" title="分享视频"></a>分享视频</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".mp4"</span>);</span><br><span class="line">Uri audioUri = Uri.fromFile(file);</span><br><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mobileqq"</span>, <span class="string">"com.tencent.mobileqq.activity.JumpActivity"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">shareIntent.putExtra(Intent.EXTRA_STREAM, audioUri);</span><br><span class="line">shareIntent.setType(<span class="string">"audio/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享视频"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享多个文件"><a href="#分享多个文件" class="headerlink" title="分享多个文件"></a>分享多个文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Uri&gt; imageUris = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".png"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path, <span class="string">"test2"</span> + <span class="string">".png"</span>);</span><br><span class="line">Uri imageUri = Uri.fromFile(file);</span><br><span class="line">Uri imageUri2 = Uri.fromFile(file2);</span><br><span class="line">imageUris.add(imageUri);</span><br><span class="line">imageUris.add(imageUri2);</span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND_MULTIPLE);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,imageUris);</span><br><span class="line">startActivity(Intent.createChooser(intent, <span class="string">"Share"</span>));</span><br></pre></td></tr></table></figure><h2 id="指定分享到微信朋友"><a href="#指定分享到微信朋友" class="headerlink" title="指定分享到微信朋友"></a>指定分享到微信朋友</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mm"</span>, <span class="string">"com.tencent.mm.ui.tools.ShareImgUI"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);            </span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);</span><br><span class="line">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class="line">shareIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享多张图片"</span>));</span><br></pre></td></tr></table></figure><h2 id="指定分享到微信朋友圈"><a href="#指定分享到微信朋友圈" class="headerlink" title="指定分享到微信朋友圈"></a>指定分享到微信朋友圈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mm"</span>, <span class="string">"com.tencent.mm.ui.tools.ShareToTimeLineUI"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);   </span><br><span class="line">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class="line">shareIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享多张图片"</span>));</span><br></pre></td></tr></table></figure><h2 id="指定分享到QQ好友"><a href="#指定分享到QQ好友" class="headerlink" title="指定分享到QQ好友"></a>指定分享到QQ好友</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mobileqq"</span>, <span class="string">"com.tencent.mobileqq.activity.JumpActivity"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);  </span><br><span class="line">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class="line">shareIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享多张图片"</span>));</span><br></pre></td></tr></table></figure><h2 id="视频指定分享到QQ空间"><a href="#视频指定分享到QQ空间" class="headerlink" title="视频指定分享到QQ空间"></a>视频指定分享到QQ空间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".mp4"</span>);</span><br><span class="line">Uri audioUri = Uri.fromFile(file);</span><br><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.qzone"</span>, <span class="string">"com.qzonex.module.maxvideo.activity.QzonePublishVideoActivity"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">shareIntent.putExtra(Intent.EXTRA_STREAM, audioUri);</span><br><span class="line">shareIntent.setType(<span class="string">"video/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享视频"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享到指定程序"><a href="#分享到指定程序" class="headerlink" title="分享到指定程序"></a>分享到指定程序</h2><p>只要获得包名和相应Activity即可</p><h3 id="微信朋友圈"><a href="#微信朋友圈" class="headerlink" title="微信朋友圈"></a>微信朋友圈</h3><p>“com.tencent.mm”<br>“com.tencent.mm.ui.tools.ShareToTimeLineUI”</p><h3 id="微信朋友"><a href="#微信朋友" class="headerlink" title="微信朋友"></a>微信朋友</h3><p>“com.tencent.mm”<br>“com.tencent.mm.ui.tools.ShareImgUI”</p><h3 id="QQ好友"><a href="#QQ好友" class="headerlink" title="QQ好友"></a>QQ好友</h3><p>“com.tencent.mobileqq”<br>“com.tencent.mobileqq.activity.JumpActivity”</p><h3 id="QQ空间分享视频"><a href="#QQ空间分享视频" class="headerlink" title="QQ空间分享视频"></a>QQ空间分享视频</h3><p>“com.qzone”<br>“com.qzonex.module.maxvideo.activity.QzonePublishVideoActivity”</p><h3 id="QQ空间分享图片、文字"><a href="#QQ空间分享图片、文字" class="headerlink" title="QQ空间分享图片、文字"></a>QQ空间分享图片、文字</h3><p>“com.qzone”<br>“com.qzonex.module.operation.ui.QZonePublishMoodActivity”</p><h3 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h3><p>“com.sina.weibo”<br>“com.sina.weibo.composerinde.ComposerDispatchActivity”</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;获取Android系统分享列表&quot;&gt;&lt;a href=&quot;#获取Android系统分享列表&quot; class=&quot;headerlink&quot; title=&quot;获取Android系统分享列表&quot;&gt;&lt;/a&gt;获取Android系统分享列表&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;AppInfoVo&amp;gt; &lt;span class=&quot;title&quot;&gt;getShareApps&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PackageManager packageManager = context.getPackageManager();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;AppInfoVo&amp;gt; appInfoVos = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;AppInfoVo&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;ResolveInfo&amp;gt; resolveInfos = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;ResolveInfo&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Intent intent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_SEND, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        intent.addCategory(Intent.CATEGORY_DEFAULT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        intent.setType(&lt;span class=&quot;string&quot;&gt;&quot;*/*&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PackageManager pManager = context.getPackageManager();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resolveInfos = pManager.queryIntentActivities(intent, PackageManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .COMPONENT_ENABLED_STATE_DEFAULT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; resolveInfos.size(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AppInfoVo appInfoVo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AppInfoVo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ResolveInfo resolveInfo = resolveInfos.get(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setAppName(resolveInfo.loadLabel(packageManager).toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setIcon(resolveInfo.loadIcon(packageManager));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setPackageName(resolveInfo.activityInfo.packageName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setLauncherName(resolveInfo.activityInfo.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVos.add(appInfoVo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; appInfoVos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="代码片段" scheme="https://zhangmiao.cc/categories/Android/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="分享" scheme="https://zhangmiao.cc/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>大神进阶之路自定义View</title>
    <link href="https://zhangmiao.cc/posts/37e124c4.html"/>
    <id>https://zhangmiao.cc/posts/37e124c4.html</id>
    <published>2019-09-20T07:22:51.000Z</published>
    <updated>2019-09-23T03:11:48.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是自定义View"><a href="#什么是自定义View" class="headerlink" title="什么是自定义View"></a>什么是自定义View</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在Android系统中，界面中所有能看到的元素都是View。默认情况下，Android系统为开发者提供了很多View，比如用于展示文本信息的TextView，用于展示图片的ImageView等等。但有时，这并不能满足开发者的需求，例如，开发者想要用一个饼状图来展示一组数据，这时如果用系统提供的View就不能实现了，只能通过自定义View来实现。那到底什么是自定义View呢？</p><p>自定义View就是通过继承View或者View的子类，并在新的类里面实现相应的处理逻辑（重写相应的方法），以达到自己想要的效果。</p><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><p>Android中的所有UI元素都是View的子类：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100323.png" alt></p><p>PS：由于涉及的类太多，如果将所有涉及到的类全部加到类图里面，类图将十分大，所以此处只列出了View的直接子类。</p><a id="more"></a><h3 id="视图体系用到的设计模式"><a href="#视图体系用到的设计模式" class="headerlink" title="视图体系用到的设计模式"></a>视图体系用到的设计模式</h3><p>Android View体系如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100354.png" alt></p><p>仔细观察，你会发现，Android View的体系结构和设计模式中的组合模式的结构如出一辙：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100406.png" alt></p><p>Android View体系结构中的ViewGroup对应于组合模式中抽象构件（Component和Composite），Android View体系结构中的View对应于组合模式中的叶子构件（Leaf）：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100421.png" alt></p><h2 id="为什么要自定义View"><a href="#为什么要自定义View" class="headerlink" title="为什么要自定义View"></a>为什么要自定义View</h2><p>大多数情况下，开发者常常会因为下面四个原因去自定义View：</p><ol><li>让界面有特定的显示风格、效果</li><li>让控件具有特殊的交互方式</li><li>优化布局</li><li>封装</li></ol><h3 id="让界面有特定的显示风格、效果"><a href="#让界面有特定的显示风格、效果" class="headerlink" title="让界面有特定的显示风格、效果"></a>让界面有特定的显示风格、效果</h3><p>默认情况下，Android系统为开发者提供了很多控件，但有时，这并不能满足开发者的需求。例如，开发者想要用一个饼状图来展示一组数据，这时如果用系统提供的View就不能实现了，只能通过自定义View来实现。</p><h3 id="让控件具有特殊的交互方式"><a href="#让控件具有特殊的交互方式" class="headerlink" title="让控件具有特殊的交互方式"></a>让控件具有特殊的交互方式</h3><p>默认情况下，Android系统为开发者提供的控件都有属于它们自己的特定的交互方式，但有时，控件的默认交互方式并不能满足开发者的需求。例如，开发者想要缩放ImageView中的图片内容，这时如果用系统提供的ImageView就不能实现了，只能通过自定义ImageView来实现。</p><h3 id="优化布局"><a href="#优化布局" class="headerlink" title="优化布局"></a>优化布局</h3><p>有时，有些布局如果用系统提供的控件实现起来相当复杂，需要各种嵌套，虽然最终也能实现了想要的效果，但性能极差，此时就可以通过自定义View来减少嵌套层级、优化布局。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>有些控件可能在多个地方使用，如大多数App里面的底部Tab，像这样的经常被用到的控件就可以通过自定义View将它们封装起来，以便在多个地方使用。</p><h2 id="如何自定义View"><a href="#如何自定义View" class="headerlink" title="如何自定义View"></a>如何自定义View</h2><p>在说「如何自定义View？」之前，我们需要知道「自定义View都包括哪些内容」？</p><p>自定义View包括三部分内容：</p><ol><li>布局（Layout）</li><li>绘制（Drawing）</li><li>触摸反馈（Event Handling）</li></ol><p>布局阶段：确定View的位置和尺寸。</p><p>绘制阶段：绘制View的内容。</p><p>触摸反馈：确定用户点击了哪里。</p><p>其中布局阶段包括测量（measure）和布局（layout）两个过程，另外，布局阶段是为绘制和触摸反馈阶段做支持的，它并没有什么直接作用。正是因为在布局阶段确定了 View 的尺寸和位置，绘制阶段才知道往哪里绘制，触摸反馈阶段才知道用户点的是哪里。</p><p>在自定义View和自定义ViewGroup中，布局和绘制流程虽然整体上都是一样的，但在细节方面，自定义View和自定义ViewGroup还是不一样的，所以，接下来分两类进行讨论：</p><ul><li>自定义View布局、绘制流程</li><li>自定义ViewGroup布局、绘制流程</li></ul><h3 id="自定义View布局、绘制流程"><a href="#自定义View布局、绘制流程" class="headerlink" title="自定义View布局、绘制流程"></a>自定义View布局、绘制流程</h3><p>「自定义 View 布局、绘制」主要包括三个阶段：</p><ol><li>测量阶段（measure）</li><li>布局阶段（layout）</li><li>绘制阶段（draw）</li></ol><h4 id="自定义View测量阶段"><a href="#自定义View测量阶段" class="headerlink" title="自定义View测量阶段"></a>自定义View测量阶段</h4><p>在View的测量阶段会执行两个方法（在测量阶段，View的父View会通过调用 View 的measure()方法将父View对View尺寸要求传进来。紧接着View的measure()方法会做一些前置和优化工作，然后调用View的onMeasure()方法，并通过onMeasure()方法将父View对View的尺寸要求传入。在自定义View中，只有需要修改View的尺寸的时候才需要重写onMeasure()方法。在onMeasure()方法中根据业务需求进行相应的逻辑处理，并在最后通过调用setMeasuredDimension()方法告知父View自己的期望尺寸）：</p><ul><li>measure()</li><li>onMeasure()</li></ul><p>measure()：调度方法，主要做一些前置和优化工作，并最终会调用onMeasure()方法执行实际的测量工作；</p><p>onMeasure()：实际执行测量任务的方法，主要用与测量View尺寸和位置。在自定义View的onMeasure()方法中，View根据自己的特性和父View对自己的尺寸要求算出自己的期望尺寸，并通过setMeasuredDimension()方法告知父View自己的期望尺寸。</p><p>onMeasure()计算View期望尺寸方法如下：</p><p>参考父View的对View的尺寸要求和实际业务需求计算出View的期望尺寸：</p><ul><li>解析widthMeasureSpec</li><li>解析heightMeasureSpec</li><li>将「根据实际业务需求计算出View的尺寸」根据「父View的对View的尺寸要求」进行相应的修正得出View的期望尺寸（通过调用resolveSize()方法）</li></ul><p>通过setMeasuredDimension()保存View的期望尺寸（实际上是通过setMeasuredDimension()告知父View自己的期望尺寸）;</p><p>注意：</p><p>多数情况下，这里的期望尺寸就是View的最终尺寸。不过最终View的期望尺寸和实际尺寸是不是一样还要看它的父View会不会同意。View的父View最终会通过调用View的layout()方法告知View的实际尺寸，并且在layout()方法中View需要将这个实际尺寸保存下来，以便绘制阶段和触摸反馈阶段使用，这也是View需要在layout()方法中保存自己实际尺寸的原因——因为绘制阶段和触摸反馈阶段要使用啊！</p><h4 id="自定义View布局阶段"><a href="#自定义View布局阶段" class="headerlink" title="自定义View布局阶段"></a>自定义View布局阶段</h4><p>在View的布局阶段会执行两个方法（在布局阶段，View的父View会通过调用View的layout()方法将View的实际尺寸（父View根据View的期望尺寸确定的View的实际尺寸）传给View，View需要在layout()方法中将自己的实际尺寸保存（通过调用View的setFrame()方法保存，在setFrame()方法中，又会通过调用onSizeChanged()方法告知开发者View的尺寸修改了）以便在绘制和触摸反馈阶段使用。保存View的实际尺寸之后，View的layout()方法又会调用View的onLayout()方法，不过View的onLayout()方法是一个空实现，因为它没有子View）：</p><ul><li>layout()</li><li>onLayout()</li></ul><p>layout()：保存View的实际尺寸。调用setFrame()方法保存View的实际尺寸，调用onSizeChanged()通知开发者View的尺寸更改了，并最终会调用onLayout()方法让子View布局（如果有子View的话。因为自定义View中没有子View，所以自定义View的onLayout()方法是一个空实现）；</p><p>onLayout()：空实现，什么也不做，因为它没有子View。如果是ViewGroup的话，在onLayout()方法中需要调用子View的layout()方法，将子View的实际尺寸传给它们，让子View保存自己的实际尺寸。因此，在自定义View中，不需重写此方法，在自定义ViewGroup中，需重写此方法。</p><p>注意：</p><p>layout()&amp;onLayout()并不是「调度」与「实际做事」的关系，layout()和onLayout()均做事，只不过职责不同。</p><h4 id="自定义View绘制阶段"><a href="#自定义View绘制阶段" class="headerlink" title="自定义View绘制阶段"></a>自定义View绘制阶段</h4><p>在View的绘制阶段会执行一个方法——draw()，draw()是绘制阶段的总调度方法，在其中会调用绘制背景的方法drawBackground()、绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()。</p><p>draw()：绘制阶段的总调度方法，在其中会调用绘制背景的方法drawBackground()、绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()；</p><p>drawBackground()：绘制背景的方法，不能重写，只能通过xml布局文件或者setBackground()来设置或修改背景；</p><p>onDraw()：绘制View主体内容的方法，通常情况下，在自定义View的时候，只用实现该方法即可；</p><p>dispatchDraw()：绘制子View的方法。同onLayout()方法一样，在自定义View中它是空实现，什么也不做。但在自定义ViewGroup中，它会调用ViewGroup.drawChild()方法，在ViewGroup.drawChild()方法中又会调用每一个子View的View.draw()让子View进行自我绘制；</p><p>onDrawForeground()：绘制View前景的方法，也就是说，想要在主体内容之上绘制东西的时候就可以在该方法中实现。</p><p>注意：</p><p>Android里面的绘制都是按顺序的，先绘制的内容会被后绘制的盖住。如，你在重叠的位置「先画圆再画方」和「先画方再画圆」所呈现出来的结果是不同的，具体表现为下表：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100451.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100504.png" alt></p><h4 id="自定义View布局、绘制流程时序图"><a href="#自定义View布局、绘制流程时序图" class="headerlink" title="自定义View布局、绘制流程时序图"></a>自定义View布局、绘制流程时序图</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100519.png" alt></p><h3 id="自定义ViewGroup布局、绘制流程"><a href="#自定义ViewGroup布局、绘制流程" class="headerlink" title="自定义ViewGroup布局、绘制流程"></a>自定义ViewGroup布局、绘制流程</h3><p>「自定义ViewGroup布局、绘制」主要包括三个阶段：</p><ol><li>测量阶段（measure）</li><li>布局阶段（layout）</li><li>绘制阶段（draw）</li></ol><h4 id="自定义ViewGroup测量阶段"><a href="#自定义ViewGroup测量阶段" class="headerlink" title="自定义ViewGroup测量阶段"></a>自定义ViewGroup测量阶段</h4><p>同自定义View一样，在自定义ViewGroup的测量阶段会执行两个方法：</p><ul><li>measure()</li><li>onMeasure()</li></ul><p>measure()：调度方法，主要做一些前置和优化工作，并最终会调用onMeasure()方法执行实际的测量工作；</p><p>onMeasure() ：实际执行测量任务的方法，与自定义View不同，在自定义ViewGroup的 onMeasure() 方法中，ViewGroup会递归调用子View的measure()方法，并通过measure()将ViewGroup对子View的尺寸要求（ViewGroup会根据开发者对子View的尺寸要求、自己的父View（ViewGroup的父View） 对自己的尺寸要求和自己的可用空间计算出自己对子View的尺寸要求）传入，对子View进行测量，并把测量结果临时保存，以便在布局阶段使用。测量出子View的实际尺寸之后，ViewGroup会根据子View的实际尺寸计算出自己的期望尺寸，并通过setMeasuredDimension()方法告知父View（ViewGroup 的父 View）自己的期望尺寸。</p><p>具体流程如下：</p><ol><li>运行前，开发者在xml中写入对ViewGroup和ViewGroup子View的尺寸要求layout_xxx</li><li>ViewGroup在自己的onMeasure()方法中，根据开发者在xml中写的对ViewGroup子View的尺寸要求、自己的父View（ViewGroup的父View） 对自己的尺寸要求和自己的可用空间计算出自己对子View的尺寸要求，并调用每个子View的measure()将ViewGroup对子View的尺寸要求传入，测量子View尺寸</li><li>ViewGroup在子View计算出期望尺寸之后（在ViewGroup的onMeasure()方法中，ViewGroup递归调用每个子View的measure()方法，子View在自己的onMeasure()方法中会通过调用setMeasuredDimension()方法告知父View（ViewGroup）自己的期望尺寸），得出子View的实际尺寸和位置，并暂时保存计算结果，以便布局阶段使用</li><li>ViewGroup根据子View的尺寸和位置计算自己的期望尺寸，并通过setMeasuredDimension()方法告知父View自己的期望尺寸。如果想要做的更好，可以在「ViewGroup根据子View的尺寸和位置计算出自己的期望尺寸」之后，再结合ViewGroup的父View对ViewGroup的尺寸要求进行修正（通过resolveSize()方法），这样得出的ViewGroup的期望尺寸更符合ViewGroup的父View对ViewGroup的尺寸要求</li></ol><h4 id="自定义ViewGroup布局阶段"><a href="#自定义ViewGroup布局阶段" class="headerlink" title="自定义ViewGroup布局阶段"></a>自定义ViewGroup布局阶段</h4><p>同自定义 View 一样，在自定义 ViewGroup 的布局阶段会执行两个方法：</p><ul><li>layout()</li><li>onLayout()</li></ul><p>layout()：保存ViewGroup的实际尺寸。调用setFrame()方法保存ViewGroup的实际尺寸，调用onSizeChanged()通知开发者ViewGroup的尺寸更改了，并最终会调用onLayout()方法让子View布局；</p><p>onLayout()：ViewGroup会递归调用每个子View的layout()方法，把测量阶段计算出的子View的实际尺寸和位置传给子View，让子View保存自己的实际尺寸和位置。</p><h4 id="自定义ViewGroup绘制阶段"><a href="#自定义ViewGroup绘制阶段" class="headerlink" title="自定义ViewGroup绘制阶段"></a>自定义ViewGroup绘制阶段</h4><p>同自定义View一样，在自定义ViewGroup的绘制阶段会执行一个方法——draw()。draw()是绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法onDraw()、绘制子View的方法 dispatchDraw()和绘制前景的方法onDrawForeground()：</p><p>draw()：绘制阶段的总调度方法，在其中会调用绘制背景的方法drawBackground()、绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()；</p><p>在ViewGroup中，你也可以重写绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()。但大多数情况下，自定义ViewGroup是不需要重写任何绘制方法的。因为通常情况下，ViewGroup的角色是容器，一个透明的容器，它只是用来盛放子View的。</p><h4 id="自定义ViewGroup布局、绘制流程时序图"><a href="#自定义ViewGroup布局、绘制流程时序图" class="headerlink" title="自定义ViewGroup布局、绘制流程时序图"></a>自定义ViewGroup布局、绘制流程时序图</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100658.png" alt></p><h3 id="自定义View步骤"><a href="#自定义View步骤" class="headerlink" title="自定义View步骤"></a>自定义View步骤</h3><ol><li>自定义属性的声明与获取</li><li>重写测量阶段相关方法（onMeasure()）</li><li>重写布局阶段相关方法（onLayout()（仅ViewGroup需要重写））</li><li>重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground() 绘制前景）</li><li>onTouchEvent()</li><li>onInterceptTouchEvent()（仅ViewGroup有此方法）</li></ol><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><h3 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a><strong>自定义View</strong></h3><p>自定义View的绘制内容</p><p>自定义View，它的内容是「三个半径不同、颜色不同的同心圆」，效果图如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100803.png" alt></p><p>自定义属性的声明与获取</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在 xml 中自定义 View 属性</span><br><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--CircleView--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"CircleView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"circle_radius"</span> <span class="attr">format</span>=<span class="string">"dimension"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"outer_circle_color"</span> <span class="attr">format</span>=<span class="string">"reference|color"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"middle_circle_color"</span> <span class="attr">format</span>=<span class="string">"reference|color"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"inner_circle_color"</span> <span class="attr">format</span>=<span class="string">"reference|color"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 View 构造函数中获取自定义 View 属性</span></span><br><span class="line">TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView);</span><br><span class="line">mRadius = typedArray.getDimension(R.styleable.CircleView_circle_radius, getResources().getDimension(R.dimen.avatar_size));</span><br><span class="line">mOuterCircleColor = typedArray.getColor(R.styleable.CircleView_outer_circle_color, getResources().getColor(R.color.purple_500));</span><br><span class="line">mMiddleCircleColor = typedArray.getColor(R.styleable.CircleView_middle_circle_color, getResources().getColor(R.color.purple_500));</span><br><span class="line">mInnerCircleColor = typedArray.getColor(R.styleable.CircleView_inner_circle_color, getResources().getColor(R.color.purple_500));</span><br><span class="line">typedArray.recycle();</span><br></pre></td></tr></table></figure><p><strong>重写测量阶段相关方法（onMeasure()）</strong></p><p>由于不需要自定义View的尺寸，所以，不用重写该方法。</p><p><strong>重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写））</strong></p><p>由于没有子View需要布局，所以，不用重写该方法。</p><p><strong>重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground()绘制前景）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写 onDraw() 方法，自定义 View 内容</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    mPaint.setColor(mOuterCircleColor);</span><br><span class="line">    canvas.drawCircle(mRadius, mRadius, mRadius, mPaint);</span><br><span class="line">    mPaint.setColor(mMiddleCircleColor);</span><br><span class="line">    canvas.drawCircle(mRadius, mRadius, mRadius * <span class="number">2</span>/<span class="number">3</span>, mPaint);</span><br><span class="line">    mPaint.setColor(mInnerCircleColor);</span><br><span class="line">    canvas.drawCircle(mRadius, mRadius, mRadius/<span class="number">3</span>, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>onTouchEvent()</strong></p><p>由于View不需要和用户交互，所以，不用重写该方法。</p><p><strong>onInterceptTouchEvent()（仅ViewGroup有此方法）</strong></p><p>ViewGroup的方法。</p><p>最终效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923110647.png" alt></p><p>此时，即使你在xml中将CircleView的宽、高声明为「match_parent」，你会发现最终的显示效果都是一样的。</p><p>主要原因是：默认情况下，View的onMeasure()方法在通过setMeasuredDimension()告知父View自己的期望尺寸时，会调用getDefaultSize()方法。在getDefaultSize()方法中，又会调用getSuggestedMinimumWidth()和getSuggestedMinimumHeight()获取建议的最小宽度和最小高度，并根据最小尺寸和父View对自己的尺寸要求进行修正。</p><p>最主要的是，在getDefaultSize()方法中修正的时候，会将MeasureSpec.AT_MOST和MeasureSpec.EXACTLY一视同仁，直接返回父View对View的尺寸要求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 默认 onMeasure 的处理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. getSuggestedMinimumWidth()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. getSuggestedMinimumHeight()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. getDefaultSize()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="comment">//MeasureSpec.AT_MOST、MeasureSpec.EXACTLY 一视同仁</span></span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正是因为在getDefaultSize()方法中处理的时候，将MeasureSpec.AT_MOST和MeasureSpec.EXACTLY一视同仁，所以才有了上面「在xml中应用CircleView的时候，无论将CircleView的尺寸设置为match_parent还是wrap_content效果都一样」的现象。</p><p>具体分析如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923110724.png" alt></p><p>注：</p><p>上表中，「View的父View对View的尺寸要求」是View的父View根据「开发者对子View的尺寸要求」、「自己的父View（View的父View的父View） 对自己的尺寸要求」和「自己的可用空间」计算出自己对子View的尺寸要求。</p><p>另外，由执行结果可知，上表中的specSize实际上等于View的尺寸：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-08-13 17:28:26.855 16024-16024/com.smart.a03_view_custom_view_example E/TAG: Width（getWidth()）:  1080  Height（getHeight()）:  1584</span><br></pre></td></tr></table></figure><p>自定义View的尺寸和绘制内容</p><p>自定义View，它的内容是「三个半径不同、颜色不同的同心圆」，效果图如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923110750.png" alt></p><p><strong>自定义属性的声明与获取</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在 xml 中自定义 View 属性</span><br><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--CircleView--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"CircleView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"circle_radius"</span> <span class="attr">format</span>=<span class="string">"dimension"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"outer_circle_color"</span> <span class="attr">format</span>=<span class="string">"reference|color"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"middle_circle_color"</span> <span class="attr">format</span>=<span class="string">"reference|color"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"inner_circle_color"</span> <span class="attr">format</span>=<span class="string">"reference|color"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 View 构造函数中获取自定义 View 属性</span></span><br><span class="line">TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView);</span><br><span class="line">mRadius = typedArray.getDimension(R.styleable.CircleView_circle_radius, getResources().getDimension(R.dimen.avatar_size));</span><br><span class="line">mOuterCircleColor = typedArray.getColor(R.styleable.CircleView_outer_circle_color, getResources().getColor(R.color.purple_500));</span><br><span class="line">mMiddleCircleColor = typedArray.getColor(R.styleable.CircleView_middle_circle_color, getResources().getColor(R.color.purple_500));</span><br><span class="line">mInnerCircleColor = typedArray.getColor(R.styleable.CircleView_inner_circle_color, getResources().getColor(R.color.purple_500));</span><br><span class="line">typedArray.recycle();</span><br></pre></td></tr></table></figure><p><strong>重写测量阶段相关方法（onMeasure()）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onMeasure()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.1 根据 View 特点或业务需求计算出 View 的尺寸</span></span><br><span class="line">    mWidth = (<span class="keyword">int</span>)(mRadius * <span class="number">2</span>);</span><br><span class="line">    mHeight = (<span class="keyword">int</span>)(mRadius * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 通过 resolveSize() 方法修正结果</span></span><br><span class="line">    mWidth = resolveSize(mWidth, widthMeasureSpec);</span><br><span class="line">    mHeight = resolveSize(mHeight, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 通过 setMeasuredDimension() 保存 View 的期望尺寸（通过 setMeasuredDimension() 告知父 View 的期望尺寸）</span></span><br><span class="line">    setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重写布局阶段相关方法（onLayout()（仅ViewGroup需要重写））</strong></p><p>由于没有子View需要布局，所以，不用重写该方法。</p><p><strong>重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground()绘制前景）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 onDraw() 方法，自定义 View 内容</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    mPaint.setColor(mOuterCircleColor);</span><br><span class="line">    canvas.drawCircle(mRadius, mRadius, mRadius, mPaint);</span><br><span class="line">    mPaint.setColor(mMiddleCircleColor);</span><br><span class="line">    canvas.drawCircle(mRadius, mRadius, mRadius * <span class="number">2</span>/<span class="number">3</span>, mPaint);</span><br><span class="line">    mPaint.setColor(mInnerCircleColor);</span><br><span class="line">    canvas.drawCircle(mRadius, mRadius, mRadius/<span class="number">3</span>, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>onTouchEvent()</strong></p><p>由于View不需要和用户交互，所以，不用重写该方法。</p><p><strong>onInterceptTouchEvent()（仅 ViewGroup 有此方法）</strong></p><p>ViewGroup的方法。</p><p>最终效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923110841.png" alt></p><p>当在xml中将MeasuredCircleView的宽、高声明为「match_parent」时，显示效果跟CircleView显示效果一样。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923110912.png" alt></p><p>但是，当在xml中将MeasuredCircleView的宽、高声明为「wrap_content」时，显示效果是下面这个样子：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923110936.png" alt></p><p>其实，也很好理解：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923110950.png" alt></p><h3 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a><strong>自定义ViewGroup</strong></h3><p>自定义ViewGroup，标签布局，效果图如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923111014.png" alt></p><p>无论是自定义View还是自定义ViewGroup，大致的流程都是一样的：</p><ol><li>自定义属性的声明与获取</li><li>重写测量阶段相关方法（onMeasure()）</li><li>重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写））</li><li>重写绘制阶段相关方法（onDraw() 绘制主体、dispatchDraw() 绘制子 View 和 onDrawForeground() 绘制前景）</li><li>onTouchEvent()</li><li>onInterceptTouchEvent()（仅 ViewGroup 有此方法）</li></ol><p>只不过，大多数情况下，ViewGroup不需要「自定义属性」和「重写绘制阶段相关方法」，但有些时候还是需要的，如，开发者想在ViewGroup的所有子View上方绘制一些内容，就可以通过重写ViewGroup的onDrawForeground()来实现。</p><p><strong>自定义属性的声明与获取</strong></p><p>在自定义ViewGroup中「自定义属性的声明与获取」的方法与在自定义View中「自定义属性的声明与获取」的方法一样，且因为大多数情况下，在自定义ViewGroup中是不需要自定义属性的，所以，在这里就不自定义属性了。</p><p><strong>重写测量阶段相关方法（onMeasure()）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 重写测量阶段相关方法（onMeasure()）；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1 解析 ViewGroup 的父 View 对 ViewGroup 的尺寸要求</span></span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 ViewGroup 根据「开发者在 xml 中写的对 ViewGroup 子 View 的尺寸要求」、「自己的父 View（ViewGroup 的父 View）对自己的尺寸要求」和</span></span><br><span class="line">    <span class="comment">//「自己的可用空间」计算出自己对子 View 的尺寸要求，并将该尺寸要求通过子 View 的 measure() 方法传给子 View，让子 View 测量自己（View）的期望尺寸</span></span><br><span class="line">    <span class="comment">//具体代码查看原文...</span></span><br><span class="line">        <span class="comment">//2.3 ViewGroup 暂时保存子 View 的尺寸，以便布局阶段和绘制阶段使用</span></span><br><span class="line">        Rect childBound;</span><br><span class="line">        <span class="keyword">if</span>(mChildrenBounds.size() &lt;= i)&#123;</span><br><span class="line">            childBound = <span class="keyword">new</span> Rect();</span><br><span class="line">            mChildrenBounds.add(childBound);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            childBound = mChildrenBounds.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处不能用 child.getxxx() 获取子 View 的尺寸值，因为子 View 只是量了尺寸，还没有布局，这些值都是 0</span></span><br><span class="line"><span class="comment">//            childBound.set(child.getLeft(), child.getTop(), child.getRight(), child.getBottom());</span></span><br><span class="line">        childBound.set(lineWidthUsed, heightUsed, lineWidthUsed + child.getMeasuredWidth(), heightUsed + child.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        lineWidthUsed += child.getMeasuredWidth() + mItemSpace;</span><br><span class="line">        widthUsed = Math.max(lineWidthUsed, widthUsed);</span><br><span class="line">        lineHeight = Math.max(lineHeight, child.getMeasuredHeight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.4 ViewGroup 将「根据子 View 的实际尺寸计算出的自己（ViewGroup）的尺寸」结合「自己父 View 对自己的尺寸要求」进行修正，并通</span></span><br><span class="line">    <span class="comment">//过 setMeasuredDimension() 方法告知父 View 自己的期望尺寸</span></span><br><span class="line">    <span class="keyword">int</span> measuredWidth = resolveSize(widthUsed, widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> measuredHeight = resolveSize((heightUsed + lineHeight + getPaddingBottom()), heightMeasureSpec);</span><br><span class="line">    setMeasuredDimension(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写generateLayoutParams()</span></span><br><span class="line"><span class="comment">//2.2.1 在自定义 ViewGroup 中调用 measureChildWithMargins() 方法计算 ViewGroup 对子 View 的尺寸要求时，</span></span><br><span class="line"><span class="comment">//必须在 ViewGroup 中重写 generateLayoutParams() 方法，因为 measureChildWithMargins() 方法中用到了 MarginLayoutParams，</span></span><br><span class="line"><span class="comment">//如果不重写 generateLayoutParams() 方法，那调用 measureChildWithMargins() 方法时，MarginLayoutParams 就为 null，</span></span><br><span class="line"><span class="comment">//所以在自定义 ViewGroup 中调用 measureChildWithMargins() 方法时，必须重写 generateLayoutParams() 方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重写布局阶段相关方法（onLayout()（仅ViewGroup需要重写））</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写））；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">        <span class="comment">//应用测量阶段计算出的子 View 的尺寸值布局子 View</span></span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        Rect childBound = mChildrenBounds.get(i);</span><br><span class="line">        child.layout(childBound.left, childBound.top, childBound.right, childBound.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground()绘制前景）</strong></p><p>默认情况下，自定义ViewGroup时是不需要重写任何绘制阶段的方法的，因为ViewGroup的角色是容器，一个透明的容器，它只是用来盛放子View的。</p><p>注意：</p><ul><li>默认情况下，系统会自动调用View Group的dispatchDraw()方法，所以不需要重写该方法</li><li>出于效率的考虑，ViewGroup默认会绕过draw()方法，换而直接执行dispatchDraw()，以此来简化绘制流程。所以如果你自定义了一个ViewGroup，并且需要在它的除dispatchDraw()方法以外的任何一个绘制方法内绘制内容，你可能会需要调用View.setWillNotDraw(false)方法来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些ViewGroup是已经调用过setWillNotDraw(false)了的，例如ScrollView）。除了可以通过调用View.setWillNotDraw(false)方法来切换到完整的绘制流程之外，你还可以通过给ViewGroup设置背景来切换到完整的绘制流程</li></ul><p><strong>onTouchEvent()</strong></p><p>由于ViewGroup不需要和用户交互，所以，不用重写该方法。</p><p><strong>onInterceptTouchEvent()（仅ViewGroup有此方法）</strong></p><p>由于ViewGroup不需要和用户交互且ViewGroup不需要拦截子View的MotionEvent，所以，不用重写该方法。</p><p>最终效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923111114.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自定义View包括三部分内容：</p><ul><li>布局（Layout）</li><li>绘制（Drawing）</li><li>触摸反馈（Event Handling）</li></ul><p>其中布局阶段确定了View的位置和尺寸，该阶段主要是为了后面的绘制和触摸反馈做支持；绘制阶段主要用于绘制View的内容（大多数情况下，只用实现OnDraw方法（Where）方法、按照指定顺序调用相关API（How）即可实现自定义绘制（What））；触摸反馈阶段确定了用户点击了哪里，三者相辅相成，缺一不可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是自定义View&quot;&gt;&lt;a href=&quot;#什么是自定义View&quot; class=&quot;headerlink&quot; title=&quot;什么是自定义View&quot;&gt;&lt;/a&gt;什么是自定义View&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;在Android系统中，界面中所有能看到的元素都是View。默认情况下，Android系统为开发者提供了很多View，比如用于展示文本信息的TextView，用于展示图片的ImageView等等。但有时，这并不能满足开发者的需求，例如，开发者想要用一个饼状图来展示一组数据，这时如果用系统提供的View就不能实现了，只能通过自定义View来实现。那到底什么是自定义View呢？&lt;/p&gt;
&lt;p&gt;自定义View就是通过继承View或者View的子类，并在新的类里面实现相应的处理逻辑（重写相应的方法），以达到自己想要的效果。&lt;/p&gt;
&lt;h3 id=&quot;继承结构&quot;&gt;&lt;a href=&quot;#继承结构&quot; class=&quot;headerlink&quot; title=&quot;继承结构&quot;&gt;&lt;/a&gt;继承结构&lt;/h3&gt;&lt;p&gt;Android中的所有UI元素都是View的子类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190923100323.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;PS：由于涉及的类太多，如果将所有涉及到的类全部加到类图里面，类图将十分大，所以此处只列出了View的直接子类。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>从0到1优雅实现沉浸式状态栏</title>
    <link href="https://zhangmiao.cc/posts/d649dac6.html"/>
    <id>https://zhangmiao.cc/posts/d649dac6.html</id>
    <published>2019-09-17T08:38:29.000Z</published>
    <updated>2019-09-17T09:45:41.108Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164145.png" alt></p><h2 id="ImmersionStatusBar"><a href="#ImmersionStatusBar" class="headerlink" title="ImmersionStatusBar"></a><a href="https://github.com/zhangmiaocc/ImmersionStatusBar" target="_blank" rel="noopener">ImmersionStatusBar</a></h2><a id="more"></a><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>现在市面上绝大多数APP都实现了沉浸式状态栏的效果，该效果可以极大地提升用户的使用体验。但是，APP默认的情况下只是设定一个固定的状态栏颜色，那么就需要我们通过代码去动态修改状态栏颜色的。那么，如何去实现呢？</p><p>首先来说，从Android 4.4开始才能实现沉浸式状态栏的，所以如果您的APP也支持Android 4.4以下版本，那还需要对Android 4.4以下版本做“不支持沉浸式状态栏”处理。</p><p>那么，从Android 4.4开始，大概可以分成三个阶段来实现沉浸式状态栏：</p><ul><li><strong>Android4.4(API 19) - Android 5.0(API 21)</strong>：这个阶段的实现方式为：通过<code>FLAG_TRANSLUCENT_STATUS</code>设置状态栏为透明并且为全屏模式，然后通过添加一个与StatusBar一样大小的View，将View的背景设置为要设置的颜色，从而实现沉浸式。</li><li><strong>Android 5.0(API 21) - Android 6.0(API 23)</strong>： 从Android 5.0开始，加入了一个重要的属性<code>android:statusBarColor</code>和方法<code>setStatusBarColor()</code>，通过这个方法我们就可以轻松实现沉浸式状态栏。但是在Android 6.0以下版本官方不支持设置状态栏的文字和图标颜色，目前只有小米和魅族的ROM提供了支持。</li><li><strong>Android 6.0(API 23)以上版本</strong>：其实Android 6.0以上的实现方式和Android 5.0+ 是一样的，区别是从Android 6.0开始，官方支持改变状态栏的文字和图标的颜色。</li></ul><h2 id="2-实现方案"><a href="#2-实现方案" class="headerlink" title="2. 实现方案"></a>2. 实现方案</h2><h3 id="2-1-前期工作"><a href="#2-1-前期工作" class="headerlink" title="2.1 前期工作"></a>2.1 前期工作</h3><p>为了实现沉浸式状态栏的效果，我们需要做一些前期工作，如下：</p><h4 id="2-1-1-修改应用主题"><a href="#2-1-1-修改应用主题" class="headerlink" title="2.1.1 修改应用主题"></a>2.1.1 修改应用主题</h4><p>为了更好地演示沉浸式状态栏的效果，我们修改应用的主题，使其不要显示Android默认的标题栏。</p><p>打开<code>styles.xml</code>文件，可以改成如下代码，并且将<code>colorPrimary</code>等颜色设置删掉：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-获取状态栏高度"><a href="#2-1-2-获取状态栏高度" class="headerlink" title="2.1.2 获取状态栏高度"></a>2.1.2 获取状态栏高度</h4><p>新建一个<code>StatusBarUtils.java</code>文件，在里面添加一个获取状态栏高度的方法，以后我们都会用的到这个方法。之后我们的核心代码也在这个工具类里实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusBarUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> statusBarHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> resourceId = context.getResources().getIdentifier(<span class="string">"status_bar_height"</span>, <span class="string">"dimen"</span>,</span><br><span class="line">                    <span class="string">"android"</span>);</span><br><span class="line">            <span class="keyword">if</span> (resourceId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                statusBarHeight = context.getResources().getDimensionPixelSize(resourceId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> statusBarHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就按照从高版本到低版本的顺序来讲解如何更优雅地实现沉浸式状态栏。</p><h3 id="2-2-Android-5-0"><a href="#2-2-Android-5-0" class="headerlink" title="2.2 Android 5.0+"></a>2.2 Android 5.0+</h3><h4 id="2-2-1-设置状态栏颜色"><a href="#2-2-1-设置状态栏颜色" class="headerlink" title="2.2.1 设置状态栏颜色"></a>2.2.1 设置状态栏颜色</h4><p>在<code>StatusBarUtils</code>类里添加如下方法，实现设置状态栏颜色的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(@NonNull Window window, @ColorInt <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">        window.setStatusBarColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改状态栏颜色的功能其实就是对<code>Window</code>进行操作，而该Window可以是Activity或Dialog等持有的Window，所以我们就封装了一个传递Window的方法。</p><p>为了便于对Activity直接操作，可以再增加一个如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Context context, @ColorInt <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">        setColor(((Activity) context).getWindow(), color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面测试一下，新建一个Activity，将其布局背景设置为某个颜色，例如主题色，布局代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/colorPrimaryDark"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在没设置状态栏颜色时，展示效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164612.png" alt></p><p>接下来在Activity的<code>onCreate()</code>方法里调用设置状态栏颜色的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_color);</span><br><span class="line">    StatusBarUtils.setColor(<span class="keyword">this</span>, getResources().getColor(R.color.colorPrimaryDark));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164636.png" alt></p><p>这样状态栏和内容的颜色就可以一样啦！</p><h4 id="2-2-2-设置状态栏文字颜色"><a href="#2-2-2-设置状态栏文字颜色" class="headerlink" title="2.2.2 设置状态栏文字颜色"></a>2.2.2 设置状态栏文字颜色</h4><p>下面我们把背景和状态栏颜色改成纯绿色（#00FF00），看看效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164713.png" alt></p><p>发现颜色好亮啊，状态栏里的文字都看不清了。在这种情况下，我们是可以将状态栏文字的颜色改成深色的，官方也仅支持设置状态栏文字和图标的深色模式和浅色模式，但是官方仅在Android 6.0以上版本提供支持。设置代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTextDark</span><span class="params">(Window window, <span class="keyword">boolean</span> isDark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123;</span><br><span class="line">        View decorView = window.getDecorView();</span><br><span class="line">        <span class="keyword">int</span> systemUiVisibility = decorView.getSystemUiVisibility();</span><br><span class="line">        <span class="keyword">if</span> (isDark) &#123;</span><br><span class="line">            decorView.setSystemUiVisibility(systemUiVisibility | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decorView.setSystemUiVisibility(systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样再增加一个对Activity的支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTextDark</span><span class="params">(Context context, <span class="keyword">boolean</span> isDark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">        setTextDark(((Activity) context).getWindow(), isDark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够根据状态栏背景颜色的深浅而自动设置文字的颜色，我们再新增一个判断颜色深浅的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDarkColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorUtils.calculateLuminance(color) &lt; <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>setColor()</code>方法里新增一行设置状态栏文字颜色的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(@NonNull Window window, @ColorInt <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">        window.setStatusBarColor(color);</span><br><span class="line">        setTextDark(window, !isDarkColor(color));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，就可以看到效果了：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164749.png" alt></p><p>上面是Android 6.0以上版本的实现，那么对于Android 6.0以下的手机怎么办呢？目前Android 5.0-6.0的手机只有小米MIUI和魅族Flyme系统提供了支持。小米MIUI的设置方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMIUIDark</span><span class="params">(Window window, <span class="keyword">boolean</span> isDark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;? extends Window&gt; clazz = window.getClass();</span><br><span class="line">        <span class="keyword">int</span> darkModeFlag;</span><br><span class="line">        Class&lt;?&gt; layoutParams = Class.forName(<span class="string">"android.view.MiuiWindowManager$LayoutParams"</span>);</span><br><span class="line">        Field field = layoutParams.getField(<span class="string">"EXTRA_FLAG_STATUS_BAR_DARK_MODE"</span>);</span><br><span class="line">        darkModeFlag = field.getInt(layoutParams);</span><br><span class="line">        Method extraFlagField = clazz.getMethod(<span class="string">"setExtraFlags"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        extraFlagField.invoke(window, isDark ? darkModeFlag : <span class="number">0</span>, darkModeFlag);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>魅族Flyme的设置方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFlymeDark</span><span class="params">(Window window, <span class="keyword">boolean</span> isDark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (window != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WindowManager.LayoutParams lp = window.getAttributes();</span><br><span class="line">            Field darkFlag = WindowManager.LayoutParams.class</span><br><span class="line">                    .getDeclaredField(<span class="string">"MEIZU_FLAG_DARK_STATUS_BAR_ICON"</span>);</span><br><span class="line">            Field meizuFlags = WindowManager.LayoutParams.class</span><br><span class="line">                    .getDeclaredField(<span class="string">"meizuFlags"</span>);</span><br><span class="line">            darkFlag.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            meizuFlags.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">int</span> bit = darkFlag.getInt(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> value = meizuFlags.getInt(lp);</span><br><span class="line">            <span class="keyword">if</span> (isDark) &#123;</span><br><span class="line">                value |= bit;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value &amp;= ~bit;</span><br><span class="line">            &#125;</span><br><span class="line">            meizuFlags.setInt(lp, value);</span><br><span class="line">            window.setAttributes(lp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>setTextDark()</code>方法中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTextDark</span><span class="params">(Window window, <span class="keyword">boolean</span> isDark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123;</span><br><span class="line">        View decorView = window.getDecorView();</span><br><span class="line">        <span class="keyword">int</span> systemUiVisibility = decorView.getSystemUiVisibility();</span><br><span class="line">        <span class="keyword">if</span> (isDark) &#123;</span><br><span class="line">            decorView.setSystemUiVisibility(systemUiVisibility | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decorView.setSystemUiVisibility(systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (OSUtils.getRomType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MIUI:</span><br><span class="line">                setMIUIDark(window, isDark);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Flyme:</span><br><span class="line">                setFlymeDark(window, isDark);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android 6.0以下运行效果同上，我就不给大家截图了。</p><h4 id="2-2-3-设置状态栏透明"><a href="#2-2-3-设置状态栏透明" class="headerlink" title="2.2.3 设置状态栏透明"></a>2.2.3 设置状态栏透明</h4><p>当我们APP的背景是一张图片时，未设置沉浸式状态栏的效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164855.png" alt></p><p>这时一般我们需要将图片顶到状态栏里，也就是整个内容布局顶到状态栏里，并设置状态栏的颜色透明，才能实现沉浸式状态栏的效果。</p><p>那么，在我们的<code>StatusBarUtils</code>类里添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTransparent</span><span class="params">(@NonNull Window window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);</span><br><span class="line">        window.setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样针对Activity，增加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTransparent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">        setTransparent(((Activity) context).getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在Activity的<code>onCreate()</code>方法里设置一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_transparent);</span><br><span class="line">    StatusBarUtils.setTransparent(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，显示效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164943.png" alt></p><p>针对这种情况，大家在实现布局时不要忘了把状态栏的高度也考虑进去。</p><p>以上就是Android 5.0以上沉浸式状态栏的实现了。</p><h3 id="2-3-Android-4-4"><a href="#2-3-Android-4-4" class="headerlink" title="2.3 Android 4.4+"></a>2.3 Android 4.4+</h3><p>下面针对Android 4.4-5.0的手机进行实现。实现原理是将内容布局设为全屏，然后在布局的顶部添加一个和状态栏一样高度的View，将该View的背景设置成我们想要的颜色。当需要将状态栏设置纯颜色时，为了和Android 5.0以上版本保持一致，我们对内容布局的上边设置一个padding，大小为状态栏的高度。</p><p>为了能复用这个View，我们新增一个自定义的ID，在<code>values</code>文件夹下新建<code>ids.xml</code>文件，新增代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"fake_status_bar_view"</span> <span class="attr">type</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在<code>StatusBarUtils</code>类里添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FAKE_STATUS_BAR_VIEW_ID = R.id.fake_status_bar_view;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.KITKAT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(@NonNull Window window, @ColorInt <span class="keyword">int</span> color,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> isTransparent)</span> </span>&#123;</span><br><span class="line">    Context context = window.getContext();</span><br><span class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">    ViewGroup decorView = (ViewGroup) window.getDecorView();</span><br><span class="line">    View contentView = decorView.findViewById(android.R.id.content);</span><br><span class="line">    <span class="keyword">if</span> (contentView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        contentView.setPadding(<span class="number">0</span>, isTransparent ? <span class="number">0</span> : getHeight(context), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    View fakeStatusBarView = decorView.findViewById(FAKE_STATUS_BAR_VIEW_ID);</span><br><span class="line">    <span class="keyword">if</span> (fakeStatusBarView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fakeStatusBarView.setBackgroundColor(color);</span><br><span class="line">        <span class="keyword">if</span> (fakeStatusBarView.getVisibility() == View.GONE) &#123;</span><br><span class="line">            fakeStatusBarView.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 绘制一个和状态栏一样高的矩形</span></span><br><span class="line">        View statusBarView = <span class="keyword">new</span> View(context);</span><br><span class="line">        FrameLayout.LayoutParams layoutParams =</span><br><span class="line">                <span class="keyword">new</span> FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                        getHeight(context));</span><br><span class="line">        statusBarView.setLayoutParams(layoutParams);</span><br><span class="line">        statusBarView.setBackgroundColor(color);</span><br><span class="line">        statusBarView.setId(FAKE_STATUS_BAR_VIEW_ID);</span><br><span class="line">        decorView.addView(statusBarView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-1-设置状态栏颜色"><a href="#2-3-1-设置状态栏颜色" class="headerlink" title="2.3.1 设置状态栏颜色"></a>2.3.1 设置状态栏颜色</h4><p>在设置纯颜色时，我们还需要将该颜色与黑色进行1:1的混合。为什么要这么设置呢？因为状态栏的文字和图标颜色默认是白色的，并且在Android 5.0以下是不能修改的，所以如果修改成较浅的颜色，就会导致状态栏文字看不清的现象，因此做一个比较暗的浮层效果更好一些。</p><p>那么将<code>setColor()</code>方法改成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(@NonNull Window window, @ColorInt <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">        window.setStatusBarColor(color);</span><br><span class="line">        setTextDark(window, !isDarkColor(color));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        setColor(window, ColorUtils.blendARGB(Color.TRANSPARENT, color, <span class="number">0.5f</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917165046.png" alt></p><h4 id="2-3-2-设置状态栏透明"><a href="#2-3-2-设置状态栏透明" class="headerlink" title="2.3.2 设置状态栏透明"></a>2.3.2 设置状态栏透明</h4><p>在设置状态栏透明时，为了也能清楚地看清状态栏的文字，我们直接设置状态栏的颜色为50%透明度的黑色。</p><p>于是，修改<code>setTransparent()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTransparent</span><span class="params">(@NonNull Window window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);</span><br><span class="line">        window.setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        setColor(window, <span class="number">0x80000000</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917165128.png" alt></p><p>这样，Android 4.4以上的手机就适配完毕了。</p><h2 id="3-特殊场景"><a href="#3-特殊场景" class="headerlink" title="3. 特殊场景"></a>3. 特殊场景</h2><p>现在来针对一些特殊场景进行适配，比如启动页、刘海屏和弹窗等等。</p><h3 id="3-1-启动页"><a href="#3-1-启动页" class="headerlink" title="3.1 启动页"></a>3.1 启动页</h3><p>对于启动页，一般都会把状态栏收上去，这需要适配刘海屏，否则刘海区域会显示黑的一片。其实Android P以上提供了适配刘海屏的方法，在启动页Activity添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_splash);</span><br><span class="line">    StatusBarUtils.setTransparent(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 适配刘海屏</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">        WindowManager.LayoutParams layoutParams = getWindow().getAttributes();</span><br><span class="line">        layoutParams.layoutInDisplayCutoutMode =</span><br><span class="line">                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;</span><br><span class="line">        getWindow().setAttributes(layoutParams);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一些手机厂商的刘海屏手机系统版本是低于Android P的，不过也都提供了适配的方法。适配方式是在<code>AndroidManifest.xml</code>文件里的<code>application</code>标签下添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 允许绘制到小米刘海屏机型的刘海区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"notch.config"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"portrait"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 允许绘制到华为刘海屏机型的刘海区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.notch_support"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 允许绘制到oppo、vivo刘海屏机型的刘海区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.max_aspect"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"2.2"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>另外，对于Android 5.0以下的手机，适配完刘海屏后会在顶部多一块黑色半透明的View，那我们将其改成全透明的，修改<code>onCreate()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_splash);</span><br><span class="line">    StatusBarUtils.setTransparent(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 适配刘海屏</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">        WindowManager.LayoutParams layoutParams = getWindow().getAttributes();</span><br><span class="line">        layoutParams.layoutInDisplayCutoutMode =</span><br><span class="line">                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;</span><br><span class="line">        getWindow().setAttributes(layoutParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 适配Android 4.4</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        StatusBarUtils.setColor(getWindow(), Color.TRANSPARENT, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，启动页的效果就适配好了，效果如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917165208.png" alt></p><h3 id="3-2-弹窗"><a href="#3-2-弹窗" class="headerlink" title="3.2 弹窗"></a>3.2 弹窗</h3><p>对于弹窗，只有全屏弹窗才能修改状态栏文字的颜色。详见<a href="https://www.jianshu.com/p/88e9e889932c" target="_blank" rel="noopener">Android非全屏的Window无法设置SYSTEM_UI_FLAG_LIGHT_STATUS_BAR问题分析</a>。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><ul><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5989ded56fb9a03c3b6c8bde" target="_blank" rel="noopener">Android关于沉浸式状态栏总结</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mi.com%2Fconsole%2Fdoc%2Fdetail%3FpId%3D1159" target="_blank" rel="noopener">MIUI 9 &amp; 10“状态栏黑色字符”实现方法变更通知</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fopen-wiki.flyme.cn%2Fdoc-wiki%2Findex%23id%3F79" target="_blank" rel="noopener">魅族开放平台 - 状态栏变色</a></li><li><a href="https://www.jianshu.com/p/c9e710a9fa35" target="_blank" rel="noopener">简洁明了的刘海屏适配方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190917164145.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;ImmersionStatusBar&quot;&gt;&lt;a href=&quot;#ImmersionStatusBar&quot; class=&quot;headerlink&quot; title=&quot;ImmersionStatusBar&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/zhangmiaocc/ImmersionStatusBar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ImmersionStatusBar&lt;/a&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="沉浸式状态栏" scheme="https://zhangmiao.cc/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android对于有时间戳和token验证的网络请求的处理</title>
    <link href="https://zhangmiao.cc/posts/86cc3f20.html"/>
    <id>https://zhangmiao.cc/posts/86cc3f20.html</id>
    <published>2019-09-16T09:40:49.000Z</published>
    <updated>2019-09-16T09:43:56.058Z</updated>
    
    <content type="html"><![CDATA[<p>有些项目为了提高安全性，设计接口时增加了时间戳和token效验，如下所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916174259.png" alt></p><a id="more"></a><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>上表中的参数时间戳必须与服务器当前时间对应，前后不能超过10秒，超过则请求失败：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916174321.png" alt></p><p>你肯定想问，如果手机系统时间不正确，比服务器快了或慢了10秒以上，那不每次都会请求失败吗？别着急，这样的接口设计，肯定会有一个获取服务器时间戳的接口：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916174309.png" alt></p><p>思路是这样的，每次APP启动的时候获取一次服务器时间戳，然后与手机本地时间相减，计算出差额，并保存；当其他的网络请求需要传入时间戳参数时，用保存的时间差额加上手机当前时间，就可以得到正确的时间戳了：</p><p>时间差 = 获取的服务器时间戳 - 手机当前时间</p><p>时间戳 = 手机当前时间 + 时间差</p><p>当然，现在的手机大部分都是联网获取时间，很少会出现比标准时间差10秒以上的情况，服务器的时间也是标准时间，因此，只传入手机的当前时间也能符合90%的情况。</p><p>那剩下的情况是什么呢？</p><p>​    1、网速慢的时候，请求时间和读取时间会比较长，很可能会超过10秒；</p><p>​    2、出国用户或国外用户，不在一个时区；</p><p>​    3、用户主动或被动调整了手机系统时间。</p><p>这些情况下，如果只传入手机的当前时间，是无法请求到正确的数据的，所以还是要计算时间差。</p><p>至于每次APP启动的时候获取一次服务器时间戳，这个时机对不对呢？</p><p>用户在使用App的过程中，很少会出现系统时间的调整，如果恰巧赶上，可以在接收到时间戳超期的错误码后，提示用户退出APP重新启动一次。当然也可以注册时间调整的广播接收者，接收到时间调整后，重新计算一次时间差。</p><p>至于网速慢的情况还是不能解决，加上提示用户重启APP和注册广播接收者这些不太优雅的操作，我们要寻找其他的思路。</p><p>怎么能彻底并且优雅的解决时间戳超期的问题呢？</p><p>其实我们不必每次APP启动都请求一次服务器时间戳，只有收到时间戳超期的错误之后，才有必要获取，此时计算出时间差，并保存，以后所有的请求都可以用这个时间差了，直到下一次再收到时间戳超期的错误，再获取一次即可。至于这个错误的请求，可以在计算出时间差之后，再重新请求一次。</p><p>跟着上述的思路，我们自然而然想到在请求回调基类里筛选这个时间戳超期错误，筛选出这个错误后，同步请求一次服务器时间戳，再进行一次之前的请求。想想就很困难，因为要保证在子线程里完成，还要记住之前的请求是什么，这条路走不通。</p><p>不卖关子了，okhttp的拦截器可以解决以上问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Interceptor interceptor = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Response response= chain.proceed(request);</span><br><span class="line">    </span><br><span class="line">        ResponseBody body = response.body();</span><br><span class="line">    </span><br><span class="line">        BufferedSource source = body.source();</span><br><span class="line">        source.request(Long.MAX_VALUE);</span><br><span class="line">        Buffer buffer = source.buffer();</span><br><span class="line">    </span><br><span class="line">        Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">        String json = buffer.clone().readString(charset);</span><br><span class="line">    </span><br><span class="line">        BaseBean baseBean = gson.fromJson(json, BaseBean.class);</span><br><span class="line">        String code = baseBean.getCode();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (code.equals(<span class="string">"0210"</span>)) &#123;<span class="comment">// 时间戳超期</span></span><br><span class="line">            <span class="comment">// 同步请求时间戳</span></span><br><span class="line">            Request timeRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                    .url(<span class="string">"http://uc.hivoice.cn:80/timestamp.jsp"</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            Response timeResponse = chain.proceed(timeRequest);</span><br><span class="line">            <span class="keyword">int</span> timeCode = timeResponse.code();</span><br><span class="line">            <span class="keyword">if</span> (timeCode == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算时间差</span></span><br><span class="line">                String timestamp = timeResponse.body().string().trim();</span><br><span class="line">                <span class="keyword">long</span> dTime = System.currentTimeMillis() / <span class="number">1000</span> - Long.parseLong(timestamp);</span><br><span class="line">                SpUtil.setDTime(dTime);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构建新的请求</span></span><br><span class="line">                FormBody.Builder builder = <span class="keyword">new</span> FormBody.Builder();</span><br><span class="line">                FormBody formBody = (FormBody) request.body();</span><br><span class="line"></span><br><span class="line">                List&lt;String&gt; param = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; formBody.size(); i++) &#123;</span><br><span class="line">                    String name = formBody.encodedName(i);</span><br><span class="line">                    <span class="keyword">if</span> (name.equals(<span class="string">"timestamp"</span>)) &#123;</span><br><span class="line">                        builder.add(<span class="string">"timestamp"</span>, timestamp);</span><br><span class="line">                        param.add(timestamp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(<span class="string">"signature"</span>)) &#123;</span><br><span class="line">                        String value = formBody.encodedValue(i);</span><br><span class="line">                        param.add(value);</span><br><span class="line">                        builder.add(name, value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String signature = SignUtil.getSignature(param);</span><br><span class="line">                builder.add(<span class="string">"signature"</span>, signature);</span><br><span class="line"></span><br><span class="line">                Request newRequest = request.newBuilder().method(<span class="string">"POST"</span>, builder.build()).build();</span><br><span class="line">                response = chain.proceed(newRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">OkHttpClient httpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .addInterceptor(interceptor)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>上述是针对post请求，考虑到这类请求多少post请求就没有区分，实际项目中如果有get请求也会发生时间戳超时问题，必须要做区分。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>token也是这样，往往是APP启动的时候获取一次，保存下来，后面的请求传入这个参数即可。</p><p>但是有些情况下，会错过这个获取时机：</p><p>​    1、APP启动时手机没有联网，启动以后才联网；</p><p>​    2、用户启动APP以后一直没有退出，直到token过期。</p><p>对于第一种情况，有人说可以注册广播接收者，监测手机的网络状态，如果启动的时候没有网络则用户联网以后再获取token，这个思路是对的，但是有一种情况是监测不到网络变化的，即用户用安全管家之类的软件禁了APP的网络的情况。</p><p>当然，可以提示用户退出APP，重新进入。但是前面说过，这样做不太优雅，而且主流APP也没有发现过这种情况。</p><p>综上所述，token验证失败的处理也应该用okhttp的拦截器处理，思路和步骤与时间戳一致，不再重复。</p><h2 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h2><p>有人可能会担心性能问题，肯定会有影响，但是影响极其有限，因为官方出品的日志拦截器也是这么做的，看不出有什么影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些项目为了提高安全性，设计接口时增加了时间戳和token效验，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916174259.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="时间戳超期" scheme="https://zhangmiao.cc/tags/%E6%97%B6%E9%97%B4%E6%88%B3%E8%B6%85%E6%9C%9F/"/>
    
      <category term="token效验失败" scheme="https://zhangmiao.cc/tags/token%E6%95%88%E9%AA%8C%E5%A4%B1%E8%B4%A5/"/>
    
  </entry>
  
  <entry>
    <title>设计模式二十一之桥接模式</title>
    <link href="https://zhangmiao.cc/posts/bf1f23e5.html"/>
    <id>https://zhangmiao.cc/posts/bf1f23e5.html</id>
    <published>2019-09-16T06:38:33.000Z</published>
    <updated>2019-09-16T06:53:59.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习桥接模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>桥接模式（BridgePattern）也称为桥梁模式，是结构型模式之一。在现实生活中大家都知道 ”桥梁“ 是连接河道两岸的主要交通枢纽，简而言之其作用就是连接河的两边，而我们的桥接模式与现实中的情况很相似，也是承担着连接 ”两边“ 的作用，那么具体是哪两边呢？这里先不着急，我们先来看看定义吧。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将抽象部分与实现部分分离，使它们都可以独立地进行变化。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>从模式的定义中我们大致可以了解到，这里的 ”桥梁“ 的作用其实就是连接 ”抽象部分“ 与 “实现部分”，但是事实上，任何多维度变化类或者说多个树状类之间的耦合都可以使用桥接模式来实现解耦。</p><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916145241.png" alt></p><a id="more"></a><ul><li>Abstraction: 抽象部分</li><li>RefinedAbstraction: 优化的抽象部分</li><li>Implementor: 实现部分</li><li>ConcreteImplementorA/B: 实现部分的具体实现。</li><li>Client: 客户类，客户端程序。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>需求背景:</strong> 我们去店里面买咖啡，对不同的咖啡不同的定义。</p><p><strong>咖啡抽象类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> CoffeeAdditives impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">coffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 制作什么得咖啡由子类决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大杯咖啡制作具体类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeCoffee</span>  <span class="keyword">extends</span> <span class="title">coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LargeCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"制作大杯咖啡-&gt;"</span> + impl.addSomething());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小杯咖啡制作具体类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallCoffee</span> <span class="keyword">extends</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmallCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"制作小杯咖啡"</span>+ impl.addSomething());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>咖啡加糖/原味抽象类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeAdditives</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>咖啡加糖/原味具体类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ordinary</span> <span class="keyword">implements</span> <span class="title">CoffeeAdditives</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"原味"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">implements</span> <span class="title">CoffeeAdditives</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"加糖"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBridge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//原味</span></span><br><span class="line">    CoffeeAdditives coffeeAdditives = <span class="keyword">new</span> Ordinary();</span><br><span class="line">    <span class="comment">//加糖</span></span><br><span class="line">    CoffeeAdditives coffeeAdditives1 = <span class="keyword">new</span> Sugar();</span><br><span class="line">    <span class="comment">//大杯原味</span></span><br><span class="line">    LargeCoffee largeCoffee = <span class="keyword">new</span> LargeCoffee(coffeeAdditives);</span><br><span class="line">    largeCoffee.makeCoffee();</span><br><span class="line">    <span class="comment">//小杯原味</span></span><br><span class="line">    SmallCoffee smallCoffee = <span class="keyword">new</span> SmallCoffee(coffeeAdditives);</span><br><span class="line">    smallCoffee.makeCoffee();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大杯加糖</span></span><br><span class="line">    LargeCoffee largeCoffee2 = <span class="keyword">new</span> LargeCoffee(coffeeAdditives1);</span><br><span class="line">    largeCoffee2.makeCoffee();</span><br><span class="line">    <span class="comment">//小杯加糖</span></span><br><span class="line">    SmallCoffee smallCoffee3 = <span class="keyword">new</span> SmallCoffee(coffeeAdditives1);</span><br><span class="line">    smallCoffee3.makeCoffee();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">制作大杯咖啡-&gt;原味</span><br><span class="line">制作小杯咖啡原味</span><br><span class="line">制作大杯咖啡-&gt;加糖</span><br><span class="line">制作小杯咖啡加糖</span><br></pre></td></tr></table></figure><p>从上面代码可以知道，不管 Coffee 变化了还是 CoffeeAdditives 变化了，其相对于对方而言都是独立的没有什么过多的交集，两者之间唯一的联系就是 Coffee 中保持的对 Coffeeadditives 的引用，就是开头介绍所说的枢纽，这就是桥接模式的简单示例。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>优点:</strong></p><ul><li>分离抽象与实现、灵活的扩展。</li></ul><p><strong>缺点:</strong></p><ul><li>不容易设计。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习桥接模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;桥接模式（BridgePattern）也称为桥梁模式，是结构型模式之一。在现实生活中大家都知道 ”桥梁“ 是连接河道两岸的主要交通枢纽，简而言之其作用就是连接河的两边，而我们的桥接模式与现实中的情况很相似，也是承担着连接 ”两边“ 的作用，那么具体是哪两边呢？这里先不着急，我们先来看看定义吧。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将抽象部分与实现部分分离，使它们都可以独立地进行变化。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;从模式的定义中我们大致可以了解到，这里的 ”桥梁“ 的作用其实就是连接 ”抽象部分“ 与 “实现部分”，但是事实上，任何多维度变化类或者说多个树状类之间的耦合都可以使用桥接模式来实现解耦。&lt;/p&gt;
&lt;h2 id=&quot;UML-类图&quot;&gt;&lt;a href=&quot;#UML-类图&quot; class=&quot;headerlink&quot; title=&quot;UML 类图&quot;&gt;&lt;/a&gt;UML 类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916145241.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥接模式" scheme="https://zhangmiao.cc/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式二十之外观模式</title>
    <link href="https://zhangmiao.cc/posts/3b61575f.html"/>
    <id>https://zhangmiao.cc/posts/3b61575f.html</id>
    <published>2019-09-16T06:38:25.000Z</published>
    <updated>2019-09-16T06:53:59.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习外观模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>外观模式 (Facade) 在开发过程中的运用评率非常高，尤其是在现阶段，各种第三方 SDK “充斥” 在我们周边，而这些 SDK 大多会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装 API 的常用手段，例如，网路模块、图片模块，可能你已经在开发中运用无数次外观模式，只是没有在理论中认识它，下面我们就来学习它。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>为一个复杂子系统提供一个简单接口。子系统往往因为不断演化而变得越来越复杂，甚至可能被替换。大多数模式使用时都会产生更多、更小的类，这使子系统更具可重用性的同时也更容易对子系统进行定制、修改，这种易变性使得隐藏子系统的具体实现变得尤为重要。Facade 可以提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化。</li><li>当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过 Facade 接口进行通信，从而简化了它们之间的依赖关系。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916145005.png" alt></p><ul><li>Facade: 系统对外的统一接口，系统内部系统地工作。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>需求背景:</strong>手机的外观模式（电话功能，短信功能，GPS, 拍照）</p><p><strong>手机抽象类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMobile</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个打电话功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Phone phone = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个拍照功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ICamera camera = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractMobile</span><span class="params">(Phone phone, ICamera camera)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.camera = camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">videoChat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手机实现类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobilePhone</span> <span class="keyword">extends</span> <span class="title">AbstractMobile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MobilePhone</span><span class="params">(Phone phone, ICamera camera)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(phone, camera);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.dail();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">videoChat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"视频聊天呼叫中..."</span>);</span><br><span class="line">        camera.openCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.hangup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        camera.takePicture();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        camera.stop();</span><br><span class="line">        phone.hangup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能接口类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 挂断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICamera</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开相机预览</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拍照</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭相机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能实现类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraImpl</span> <span class="keyword">implements</span> <span class="title">ICamera</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开相机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭相机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneImpl</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挂断电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFacade</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Phone phone = <span class="keyword">new</span> PhoneImpl();</span><br><span class="line">    ICamera camera = <span class="keyword">new</span> CameraImpl();</span><br><span class="line">    MobilePhone mobilePhone = <span class="keyword">new</span> MobilePhone(phone,camera);</span><br><span class="line"></span><br><span class="line">    mobilePhone.dail();</span><br><span class="line">    mobilePhone.videoChat();</span><br><span class="line">    mobilePhone.takePicture();</span><br><span class="line">    mobilePhone.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打电话</span><br><span class="line">视频聊天呼叫中...</span><br><span class="line">打开相机</span><br><span class="line">拍照</span><br><span class="line">关闭相机</span><br><span class="line">挂断电话</span><br></pre></td></tr></table></figure><p>从上述代码可以看到，外观模式就是统一接口封装。将子系统的逻辑、交互隐藏起来，为用户提供一个高层次的接口，是的系统更加易用，同时也对外隐藏了具体的实现，这样即使具体的子系统发生了变化，用户也不会知道，因为用户使用的是 Facade 高层次接口，内部的变化对于用户来说并不可见。这样一来就将变化隔离开来，使得系统更为灵活。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>外观模式是一个使用频率较高的设计模式，它的精髓就在于 ”封装“ 二字。通过一个高层次结构为用户提供统一的 API 入口，使得用户通过一个类型就基本能够操作整个系统，这样减少了用户的成本，也能够提升系统的灵活性。</p><p><strong>优点:</strong></p><ol><li>对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。</li><li>外观类对子系统的接口封装，使得系统更易于使用。</li></ol><p><strong>缺点:</strong></p><ol><li>外观类接口膨胀。由于子系统的接口都有外观类统一对外暴露，使得外观类的 API 接口较多，在一定程度上增加了用户使用成本。</li><li>外观类没有遵循开闭原则，当业务出现更换时，可能需要直接修改外观类。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习外观模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;外观模式 (Facade) 在开发过程中的运用评率非常高，尤其是在现阶段，各种第三方 SDK “充斥” 在我们周边，而这些 SDK 大多会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装 API 的常用手段，例如，网路模块、图片模块，可能你已经在开发中运用无数次外观模式，只是没有在理论中认识它，下面我们就来学习它。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为一个复杂子系统提供一个简单接口。子系统往往因为不断演化而变得越来越复杂，甚至可能被替换。大多数模式使用时都会产生更多、更小的类，这使子系统更具可重用性的同时也更容易对子系统进行定制、修改，这种易变性使得隐藏子系统的具体实现变得尤为重要。Facade 可以提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化。&lt;/li&gt;
&lt;li&gt;当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过 Facade 接口进行通信，从而简化了它们之间的依赖关系。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="外观模式" scheme="https://zhangmiao.cc/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十九之享元模式</title>
    <link href="https://zhangmiao.cc/posts/7a00ed5e.html"/>
    <id>https://zhangmiao.cc/posts/7a00ed5e.html</id>
    <published>2019-09-16T06:38:06.000Z</published>
    <updated>2019-09-16T06:53:59.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习享元模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>享元模式是对象池的一种实现，享元模式用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能、避免内存移除等。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用共享对象可以有效地支持大量的细粒度的对象。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>系统中存在大量的相似对象。</li><li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li><li>需要缓冲池的场景。</li></ul><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916144721.png" alt></p><ul><li>Flyweiget : 享元对象抽象基类或者接口</li><li>ConcreteFlyweiget: 具体的享元对象。</li><li>FlyweigetFactory: 享元工厂，负责管理享元对象池和创建享元对象。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>需求背景:</strong> 过年回家买车票，如果在并发 1W 人次同时 http 请求数据，如果后台每次都重新创建一个查询的车票结果，那么必然会造成大量重复对象的创建、销毁、使得 GC 任务繁重、内存高居不下。</p><p><strong>展示车票信息接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>展示车票具体实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTicket</span> <span class="keyword">implements</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String from;</span><br><span class="line">    <span class="keyword">public</span> String to;</span><br><span class="line">    <span class="keyword">public</span> String bunk;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        bunk = info;</span><br><span class="line">        price = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"购买从"</span> + from + <span class="string">" -&gt; "</span> + to + <span class="string">"的 "</span> + bunk + <span class="string">" 火车票 ，价格："</span> + price);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>车票信息管理:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Ticket&gt; sTicketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticket <span class="title">getTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        String key = from + <span class="string">"-"</span> + to;</span><br><span class="line">        <span class="keyword">if</span> (sTicketMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">//使用已经存在的对象</span></span><br><span class="line">            System.out.println(<span class="string">"使用存在的对象 = ["</span> + from + <span class="string">"], to = ["</span> + to + <span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">return</span> sTicketMap.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"创建对象 = ["</span> + from + <span class="string">"], to = ["</span> + to + <span class="string">"]"</span>);</span><br><span class="line">            TrainTicket trainTicket = <span class="keyword">new</span> TrainTicket(from, to);</span><br><span class="line">            sTicketMap.put(key, trainTicket);</span><br><span class="line">            <span class="keyword">return</span> trainTicket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFlaweiget</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Ticket ticket1 = TicketFactory.getTicket(<span class="string">"北京"</span>, <span class="string">"上海"</span>);</span><br><span class="line">    ticket1.showTicketInfo(<span class="string">"上铺"</span>);</span><br><span class="line">    Ticket ticket7 = TicketFactory.getTicket(<span class="string">"北京"</span>, <span class="string">"上海"</span>);</span><br><span class="line">    ticket7.showTicketInfo(<span class="string">"下铺"</span>);</span><br><span class="line">    Ticket ticket2 = TicketFactory.getTicket(<span class="string">"北京"</span>, <span class="string">"上海"</span>);</span><br><span class="line">    ticket2.showTicketInfo(<span class="string">"上铺"</span>);</span><br><span class="line">    Ticket ticket3 = TicketFactory.getTicket(<span class="string">"北京"</span>, <span class="string">"上海"</span>);</span><br><span class="line">    ticket3.showTicketInfo(<span class="string">"上铺"</span>);</span><br><span class="line">    Ticket ticket4 = TicketFactory.getTicket(<span class="string">"北京"</span>, <span class="string">"成都"</span>);</span><br><span class="line">    ticket4.showTicketInfo(<span class="string">"下铺"</span>);</span><br><span class="line">    Ticket ticket5 = TicketFactory.getTicket(<span class="string">"北京"</span>, <span class="string">"上海"</span>);</span><br><span class="line">    ticket5.showTicketInfo(<span class="string">"上铺"</span>);</span><br><span class="line">    Ticket ticket6 = TicketFactory.getTicket(<span class="string">"北京"</span>, <span class="string">"上海"</span>);</span><br><span class="line">    ticket6.showTicketInfo(<span class="string">"上铺"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建对象 = [北京], to = [上海]</span><br><span class="line">购买从北京 -&gt; 上海的 上铺 火车票 ，价格：<span class="number">36</span></span><br><span class="line">使用存在的对象 = [北京], to = [上海]</span><br><span class="line">购买从北京 -&gt; 上海的 下铺 火车票 ，价格：<span class="number">261</span></span><br><span class="line">使用存在的对象 = [北京], to = [上海]</span><br><span class="line">购买从北京 -&gt; 上海的 上铺 火车票 ，价格：<span class="number">100</span></span><br><span class="line">使用存在的对象 = [北京], to = [上海]</span><br><span class="line">购买从北京 -&gt; 上海的 上铺 火车票 ，价格：<span class="number">247</span></span><br><span class="line">创建对象 = [北京], to = [成都]</span><br><span class="line">购买从北京 -&gt; 成都的 下铺 火车票 ，价格：<span class="number">224</span></span><br><span class="line">使用存在的对象 = [北京], to = [上海]</span><br><span class="line">购买从北京 -&gt; 上海的 上铺 火车票 ，价格：<span class="number">262</span></span><br><span class="line">使用存在的对象 = [北京], to = [上海]</span><br><span class="line">购买从北京 -&gt; 上海的 上铺 火车票 ，价格：<span class="number">114</span></span><br></pre></td></tr></table></figure><p>从上面的查询结果得知，如果已经查询了就使用缓存，没有就创建对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>享元模式是实现比较简单，但是它的作用在某些场景确实极其重要的。它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p><p>享元模式的有点在于大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的。</p><ul><li>享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li><li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习享元模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;享元模式是对象池的一种实现，享元模式用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能、避免内存移除等。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;使用共享对象可以有效地支持大量的细粒度的对象。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;系统中存在大量的相似对象。&lt;/li&gt;
&lt;li&gt;细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。&lt;/li&gt;
&lt;li&gt;需要缓冲池的场景。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="享元模式" scheme="https://zhangmiao.cc/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十八之装饰模式</title>
    <link href="https://zhangmiao.cc/posts/9cdd1e4f.html"/>
    <id>https://zhangmiao.cc/posts/9cdd1e4f.html</id>
    <published>2019-09-16T06:37:19.000Z</published>
    <updated>2019-09-16T06:53:59.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习装饰模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>装饰模式 (也称为 Decorator Pattern) 也称为包装模式，属于结构型模式之一，其使用一种对客户端透明的方式来动态的扩展对象的功能，同时它也是继承关系的一种替代方案之一。在现实生活中你也看见很多装饰模式的例子，或者可以大胆地说装饰模式无处不在，就拿人来说，人需要各式各样的衣着，不管你穿着怎么，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层 “遮羞物” 而已，这就是装饰模式。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态的给一个对象田爱军一些额外的职责。就是增加功能来说，装饰模式生成子类更为灵活。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要透明且动态地扩展类的功能时。</p><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916144814.png" alt></p><ul><li>Component: 抽象组件，可以试一个接口或者抽象类，其充当的就是被装饰的原始对象。</li><li>ConcreteComponent: 组件具体实现类，该类是 Component 类的基本实现，也是我们装饰的具体对象。</li><li>Decorator: 抽象装饰者。</li><li>ConcreteDecorator: 装饰者具体实现类</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>业务背景:</strong> 为 boy 穿衣</p><p><strong>定义一个抽象的穿衣行为:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Person 下有一个穿着的抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明一个具体行为实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"男孩穿着内裤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义一个用来装饰具体行为的抽象:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonCloth</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Person person</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonCloth</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.dressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体装饰实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveCloth</span> <span class="keyword">extends</span> <span class="title">PersonCloth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpensiveCloth</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.dressed();</span><br><span class="line">        <span class="comment">//穿短袖</span></span><br><span class="line">        dressShirt();</span><br><span class="line">        <span class="comment">//穿皮衣</span></span><br><span class="line">        dressLeather();</span><br><span class="line">        <span class="comment">//穿牛仔裤</span></span><br><span class="line">        dressJean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressShirt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿上短袖"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressLeather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿上皮衣"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressJean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿上牛仔裤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheapCloth</span> <span class="keyword">extends</span> <span class="title">PersonCloth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheapCloth</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.dressed();</span><br><span class="line">        dressShorts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressShorts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿条短裤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDecorator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先得有一个男孩</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Boy();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//先穿上便宜的衣服</span></span><br><span class="line">    PersonCloth cheapCloth = <span class="keyword">new</span> CheapCloth(person);</span><br><span class="line">    cheapCloth.dressed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者在穿上有点档次的衣服</span></span><br><span class="line">    PersonCloth personCloth = <span class="keyword">new</span> ExpensiveCloth(person);</span><br><span class="line">    personCloth.dressed();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">男孩穿着内裤</span><br><span class="line">穿条短裤</span><br><span class="line"></span><br><span class="line">男孩穿着内裤</span><br><span class="line">穿上短袖</span><br><span class="line">穿上皮衣</span><br><span class="line">穿上牛仔裤</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装饰模式和我们前面讲的 <a href="https://zhangmiao.cc/posts/6e2d1f5e.html">代理模式</a> 有点类似，有时候甚至容易混淆，倒不是说会把代理当成装饰，而是常常会是将装饰看作代理，装饰模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有的对象的引用。装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习装饰模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;装饰模式 (也称为 Decorator Pattern) 也称为包装模式，属于结构型模式之一，其使用一种对客户端透明的方式来动态的扩展对象的功能，同时它也是继承关系的一种替代方案之一。在现实生活中你也看见很多装饰模式的例子，或者可以大胆地说装饰模式无处不在，就拿人来说，人需要各式各样的衣着，不管你穿着怎么，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层 “遮羞物” 而已，这就是装饰模式。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;动态的给一个对象田爱军一些额外的职责。就是增加功能来说，装饰模式生成子类更为灵活。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;需要透明且动态地扩展类的功能时。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰模式" scheme="https://zhangmiao.cc/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十七之适配器模式</title>
    <link href="https://zhangmiao.cc/posts/16194dff.html"/>
    <id>https://zhangmiao.cc/posts/16194dff.html</id>
    <published>2019-09-16T06:37:03.000Z</published>
    <updated>2019-09-16T06:53:59.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习适配器模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>适配器模式在我们开发中使用率极高，从最早的 ListView、GridView 到现在的 RecyclerView 都需要使用 Adapter ，并且在开发中我们遇到的优化问题，出错概率较大的地方也基本都出在 Adapter,这是一个让人又爱又恨的角色。</p><p>说到底，适配器是将两个不兼容的类融合到一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要两个没有关系的类型之间进行交互，第一个解决方案是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时怎么办？这种情况我们往往会使用一个 Adapter,在这两种接口之间创建一个 “混血儿” 接口，这个 Adapter 会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容。</li><li>想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。</li><li>需要统一的输出接口，而输入端的类型不可预知。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916144248.png" alt></p><ul><li>Target: 目标角色，也就是所期待得到的接口。注意：由于这里讨论的是类适配器，因此目标不可以是类。</li><li>Adaptee: 现在需要适配的接口。</li><li>Adapter: 适配器角色，也是本模式的核心。适配器把源接口换成目标接口，当然，这一角色不可以是接口，而必须是具体类。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>适配器模分为两种，即类适配器和对象适配器，我们先来看类适配器。</p><p><strong>业务背景</strong>: 用电源接口做例子，笔记本电脑的电源一般是 5V 电压，但是我们生活中的电线电压一般都是 220V 。这个时候就出现了不匹配的状况，在软件开发中我们称为接口不兼容，此时就需要适配器来进行一个接口转换。在软件开发中有一句话正好体现了这点：任何问题都可以加一个中间层来解决。这个层我们可以理解为这里的 Apapter 层，通过这层来进行一个接口转换就达到了兼容的目的。</p><p>在上述电源接口这个示例中， 5V 电压就是 Target  接口，220V 电压就是 Adapter 类，而将电压从 220V 转换到 5V 就是 Adapter。</p><p>类适配器:</p><p><strong>target:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FiveVolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Adapter 角色，需要被转换的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volt220</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Adapter 角色，将 220 -&gt; 5 V 的电压:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">extends</span> <span class="title">Volt220</span> <span class="keyword">implements</span> <span class="title">FiveVolt</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdapter1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    VoltAdapter voltAdapter = <span class="keyword">new</span> VoltAdapter();</span><br><span class="line">    System.out.println(<span class="string">"voltAdapter:"</span>+voltAdapter.getVolt5());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">voltAdapter:<span class="number">5</span></span><br></pre></td></tr></table></figure><p>Target 角色给出了需要的目标接口，而 Adapter 类则是需要被转换的对象。Adapter 则是将 Volt220 转换成 Target 的接口。对应的 Target 的目标是要获取 5V 的输出电压，而 Adapter 真正输出电压是 220V ，此时就需要电源适配器类将 220V 电压转换为 5V 电压，解决接口不兼容的问题。</p><p>对象适配器:</p><p>我们只需要变换下 Adapter 对象，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">extends</span> <span class="title">Volt220</span> <span class="keyword">implements</span> <span class="title">FiveVolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Volt220 mVolt220;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltAdapter</span><span class="params">(Volt220 mVolt220)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVolt220 = mVolt220;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt220</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mVolt220.getVolt220();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test / output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> VoltAdapter voltAdapter = <span class="keyword">new</span> VoltAdapter(<span class="keyword">new</span> Volt220());</span><br><span class="line"> System.out.println(<span class="string">"voltAdapter:"</span>+voltAdapter.getVolt5());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voltAdapter:<span class="number">5</span></span><br></pre></td></tr></table></figure><p>这种实现方式直接将要被适配的对象传递到 Adapter 中，使用组合的形式是吸纳接口兼容的效果。这比类适配器方式更为灵活，它的另一个好处是被适配的对象中的方法不会暴露出来，而类适配由于继承了被适配对象，因此，被适配对象类的函数在 Adapter 类中也都含有，这使得 Adapter 类出现了一些奇怪的接口，用户使用成本较高，因此，对象适配器模式更加灵活、实用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Adapter 模式的经典实现在于将原本不兼容的接口融合在一起，使之能够很好的进行合作。但是，在实际开发中，Adapter 模式也有一些灵活的实现。例如 ListView 中的隔离变化，使得整个 UI 架构变得更灵活，能够拥抱变化。Adapter 模式在开发中运用非常广泛，因此，掌握 Adapter 模式是非常必要的。</p><p><strong>优点:</strong></p><ol><li>更好的复用性，系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li><li>更好的扩展性，在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li></ol><p><strong>缺点:</strong></p><ol><li>过多地使用适配器，会让系统非常凌乱，不易整体把握。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习适配器模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;适配器模式在我们开发中使用率极高，从最早的 ListView、GridView 到现在的 RecyclerView 都需要使用 Adapter ，并且在开发中我们遇到的优化问题，出错概率较大的地方也基本都出在 Adapter,这是一个让人又爱又恨的角色。&lt;/p&gt;
&lt;p&gt;说到底，适配器是将两个不兼容的类融合到一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要两个没有关系的类型之间进行交互，第一个解决方案是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时怎么办？这种情况我们往往会使用一个 Adapter,在这两种接口之间创建一个 “混血儿” 接口，这个 Adapter 会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容。&lt;/li&gt;
&lt;li&gt;想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。&lt;/li&gt;
&lt;li&gt;需要统一的输出接口，而输入端的类型不可预知。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十六之组合模式</title>
    <link href="https://zhangmiao.cc/posts/f6bae352.html"/>
    <id>https://zhangmiao.cc/posts/f6bae352.html</id>
    <published>2019-09-16T06:31:58.000Z</published>
    <updated>2019-09-16T06:35:10.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习组合模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>组合模式（Composite Pattern）也称为部分整体模式 (Part Whole Pattern) ，属于结构性设计模式，组合模式比较简单，它将一组相似的对象看做一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略掉对象与对象集合之间的差别。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将对象组合成树形结构以表示 ”部分-整体“ 的层次结构，使得用户对整个对象和组合对象的使用具有一致性。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>表示对象的 ”部分-整体“ 层次结构时。</li><li>从一个整体中能够独立出部分模块或功能的场景。</li></ul><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916143324.png" alt></p><ul><li>Component: 抽象根节点，为组合中的对象声明接口。在适当的情况下，实现所有类共有接口的缺省行为。声明一个接口用于访问和管理 Component 的子节点。可在递归结构中定义一个接口，用于访问一个父节点，并在合适的情况下实现它。</li><li>Composite: 定义有子节点的那些枝干节点的行为，存储子节点，在 Component 接口中实现与子节点有关的操作。</li><li>Leaf: 在组合中表示叶子节点对象，叶子节点没有子节点，在组合中定义节点对象的行为。</li><li>Client: 通过 Component 接口操纵组合节点的对象。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><strong>抽象根节点:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的逻辑方法由子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> component</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component component)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> component</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component component)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枝干节点:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储节点的容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; mLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">        <span class="keyword">if</span> (mLists != <span class="keyword">null</span> &amp;&amp; mLists.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Component component : mLists) &#123;</span><br><span class="line">                component.doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        mLists.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        mLists.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLists.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>叶子节点:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造一个根节点</span></span><br><span class="line">    Component root = <span class="keyword">new</span> Composite(<span class="string">"Root"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造枝干节点</span></span><br><span class="line">    Component branchA = <span class="keyword">new</span> Composite(<span class="string">"branchA"</span>);</span><br><span class="line">    Component branchB = <span class="keyword">new</span> Composite(<span class="string">"branchB"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造叶子节点</span></span><br><span class="line">    Component leafA = <span class="keyword">new</span> Leaf(<span class="string">"leafA"</span>);</span><br><span class="line">    Component leafB = <span class="keyword">new</span> Leaf(<span class="string">"LeafB"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将叶子节点添加至枝干节点中</span></span><br><span class="line">    branchA.addChild(leafA);</span><br><span class="line">    branchB.addChild(leafB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将枝干节点添加进跟节点</span></span><br><span class="line">    root.addChild(branchA);</span><br><span class="line">    root.addChild(branchB);</span><br><span class="line"></span><br><span class="line">    root.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name: Root</span><br><span class="line">name: branchA</span><br><span class="line">name: leafA</span><br><span class="line">name: branchB</span><br><span class="line">name: LeafB</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916143413.png" alt></p><p><em>业务背景:</em> 用代码表示文件夹跟文件的组合关系;</p><p><strong>文件和文件夹抽象类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dir</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明一个 List 成员变量存储文件夹下面所有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Dir&gt; mDirs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前文件或文件夹名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dir</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个文件或文件夹</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Dir dir)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除一个文件或文件夹</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeDir</span><span class="params">(Dir dir)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空文件夹下面所有的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出文件夹下目录结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件夹下所有的文件或子文件夹</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Dir&gt; <span class="title">getFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件或文件夹名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体文件夹类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">Dir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line">        mDirs.add(dir);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line">        mDirs.remove(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDirs.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(getName() + <span class="string">" ("</span>);</span><br><span class="line">        Iterator&lt;Dir&gt; iterator = mDirs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Dir dir = iterator.next();</span><br><span class="line">            dir.print();</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.print(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dir&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDirs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体文件类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Dir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dir&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"文件对象不支持该操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testComponent2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造一个目录对象表示 sdcard 盘跟目录</span></span><br><span class="line">    Dir diskSdcard = <span class="keyword">new</span> Folder(<span class="string">"sdcard"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sdcard 下有一个文件</span></span><br><span class="line">    diskSdcard.addDir(<span class="keyword">new</span> File(<span class="string">"bug.log"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sdcard 下还有一个子目录  android</span></span><br><span class="line">    Dir android =  <span class="keyword">new</span> Folder(<span class="string">"android"</span>);</span><br><span class="line">    <span class="comment">//android 目录下有一个目录</span></span><br><span class="line">    Dir data = <span class="keyword">new</span> Folder(<span class="string">"data"</span>);</span><br><span class="line">    data.addDir(<span class="keyword">new</span> File(<span class="string">"2019-09-14.log"</span>));</span><br><span class="line">    android.addDir(data);</span><br><span class="line">    diskSdcard.addDir(android);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sdcard 下还有一个子目录 baidu</span></span><br><span class="line">    Dir baidu =  <span class="keyword">new</span> Folder(<span class="string">"baidu"</span>);</span><br><span class="line">    <span class="comment">//android 目录下有一个目录</span></span><br><span class="line">    Dir cache = <span class="keyword">new</span> Folder(<span class="string">"cache"</span>);</span><br><span class="line">    cache.addDir(<span class="keyword">new</span> File(<span class="string">"offline.baidu"</span>));</span><br><span class="line">    baidu.addDir(cache);</span><br><span class="line">    diskSdcard.addDir(baidu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sdcard 下还有一个子目录 downloads</span></span><br><span class="line">    Dir downloads =  <span class="keyword">new</span> Folder(<span class="string">"downloads"</span>);</span><br><span class="line">    <span class="comment">//android 目录下有一个目录</span></span><br><span class="line">    Dir f360 = <span class="keyword">new</span> Folder(<span class="string">"360"</span>);</span><br><span class="line">    f360.addDir(<span class="keyword">new</span> File(<span class="string">"360.log"</span>));</span><br><span class="line">    downloads.addDir(f360);</span><br><span class="line">    diskSdcard.addDir(downloads);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印文件结构</span></span><br><span class="line">    diskSdcard.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sdcard (</span><br><span class="line">  <span class="comment">//文件</span></span><br><span class="line">  name: bug.log, </span><br><span class="line">  <span class="comment">//文件夹</span></span><br><span class="line">  android (data (name: <span class="number">2019</span>-<span class="number">09</span>-<span class="number">14</span>.log)),</span><br><span class="line">  baidu (cache (name: offline.baidu)), </span><br><span class="line">  downloads (<span class="number">360</span> (name: <span class="number">360</span>.log))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们以括号作为一个文件夹的内容范围，如上输出所以 adcard 下文件夹有 3 个子文件夹 Android、baidu、downloads 子文件夹，以及一个 bug.log 文件，而在 3 个子文件夹中还各自包含子文件夹和文件，一个典型的树状嵌套解耦，这就是一个组合模式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点:</strong></p><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让高层模块忽略了层次的差异，方便对整个层次结构进行控制。</li><li>高层模块可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了高层模块的代码。</li><li>在组合模式中增加了新的枝干构件和叶子构件都很方便，无须对现有类库进行任何修改，符合 “开闭原则”。</li><li>组合模式为树状结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和树干对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><p><strong>缺点:</strong></p><p>早新增构件时不好对树干中的构件类型进行限制，不能依赖类型系统来施加这些约束，因为在大多数情况下，它们都来自于想听的抽象层，此时，必须进行类型检查来实现，这个实现过程较为复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习组合模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;组合模式（Composite Pattern）也称为部分整体模式 (Part Whole Pattern) ，属于结构性设计模式，组合模式比较简单，它将一组相似的对象看做一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略掉对象与对象集合之间的差别。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将对象组合成树形结构以表示 ”部分-整体“ 的层次结构，使得用户对整个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;表示对象的 ”部分-整体“ 层次结构时。&lt;/li&gt;
&lt;li&gt;从一个整体中能够独立出部分模块或功能的场景。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="组合模式" scheme="https://zhangmiao.cc/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十五之代理模式</title>
    <link href="https://zhangmiao.cc/posts/6e2d1f5e.html"/>
    <id>https://zhangmiao.cc/posts/6e2d1f5e.html</id>
    <published>2019-09-16T06:29:28.000Z</published>
    <updated>2019-09-16T06:35:10.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习代理模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>代理模式 (Proxy Pattren) 也称为委托模式，是属于结构型设计模式，其重要性不言而喻，相信在看过本篇文章之后会发现不少设计模式中都有代理模式的影子。那么何为代理模式？其实代理在我们日常生活中并不少见，对于程序员来说最常接触的莫过于代理上网了，连上代理服务器地址，就可以轻松畅游全世界的网络；总而言之，也许你并不留意，但是代理是无处不在，现实生活如此，我们的 Code 世界里也是如此！既然这样，我们来探究下代理模式倒是有多普遍。下面首先看下代理模式的定义吧。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为其它对象提供一种代理以控制对这个对象的访问。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当无法或不想直接访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。</p><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916143011.png" alt></p><ul><li>Subject: 抽象主题类；该类的主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个抽象类也可以是一个接口。</li><li>RealSubject: 真实主题类；该类也称为被委托类或被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题中定义的方法。</li><li>ProxySubject: 代理类；该类也称为委托类或代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。</li><li>Client: 客户类，即使用代理类的类型。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>代理模式可以大致分为两大部分，一是静态代理，而是动态代理。静态代理是只有具体的代理对象，而动态代理则与静态代理相反，通过反射机制动态地生成代理者的对象，也就是说我们在 code 阶段压根不需要知道代理对象是谁，代理谁将会在执行阶段决定。下面我们就来看下吧</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p><strong>业务背景:</strong> X 程序员在公司上班时，遇见了公司拖欠工资甚至克扣工资的情况，这种情况下 X 程序员还是通过法律途径来解决问题，这个时候就需要请一个律师来作为自己的诉讼代理人，先看下面的代码示例吧</p><p><strong>诉讼接口类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILawsuit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交申请</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 举行举证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始辩护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 诉讼完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体诉讼人（X程序员）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XProgrammer</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老板欠 X 程序员工资，申请仲裁!"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是合同书和过去一年的银行工资流水"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"证据确凿！不需要再说什么了！"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"诉讼成功！判决老板即日起 7 天内结算工资！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>X程序员请的律师（代理对象）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyLawyer</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个具体被代理者的引用，这里就是 X 程序员，也可以是其它 Y 程序员 只是具体说明。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ILawsuit mLawsuit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyLawyer</span><span class="params">(ILawsuit lawsuit)</span> </span>&#123;</span><br><span class="line">        mLawsuit = lawsuit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLawsuit.submit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLawsuit.burden();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLawsuit.defend();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLawsuit.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//X 程序员</span></span><br><span class="line">    ILawsuit lawsuit = <span class="keyword">new</span> XProgrammer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序员请的律师，把自己的事务交于律师来处理</span></span><br><span class="line">    ILawsuit proxyLawyer = <span class="keyword">new</span> ProxyLawyer(lawsuit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//律师开始处理</span></span><br><span class="line">    proxyLawyer.submit();</span><br><span class="line">    proxyLawyer.burden();</span><br><span class="line">    proxyLawyer.defend();</span><br><span class="line">    proxyLawyer.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">老板欠 X 程序员工资，申请仲裁!</span><br><span class="line">这是合同书和过去一年的银行工资流水</span><br><span class="line">证据确凿！不需要再说什么了！</span><br><span class="line">诉讼成功！判决老板即日起 <span class="number">7</span> 天内结算工资！</span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理其实也很简单，Java 给我们提供了一个很便捷的动态代理接口 InvocationHandler ,实现该接口需要重写其调用方法 invoke。</p><p>下面我们就上面的示例来稍加改动一下:</p><p><strong>动态代理类(这里可以理解为律师对象)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理者的引用（这里可以理解为 X 程序员）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射调用其代理者的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(object,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDynamicProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//X 程序员</span></span><br><span class="line">    ILawsuit lawsuit = <span class="keyword">new</span> XProgrammer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个动态代理对象（程序员请的律师，把自己的事务交于律师来处理）</span></span><br><span class="line">    DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(lawsuit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到代理者身上的 ClassLoader</span></span><br><span class="line">    ClassLoader classLoader = lawsuit.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态的构造一个代理者律师出来</span></span><br><span class="line">    ILawsuit proxyLawyer = (ILawsuit) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;ILawsuit.class&#125;, dynamicProxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//律师开始处理</span></span><br><span class="line">    proxyLawyer.submit();</span><br><span class="line">    proxyLawyer.burden();</span><br><span class="line">    proxyLawyer.defend();</span><br><span class="line">    proxyLawyer.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">老板欠 X 程序员工资，申请仲裁!</span><br><span class="line">这是合同书和过去一年的银行工资流水</span><br><span class="line">证据确凿！不需要再说什么了！</span><br><span class="line">诉讼成功！判决老板即日起 <span class="number">7</span> 天内结算工资！</span><br></pre></td></tr></table></figure><p>运行结果和静态代理一样，由此可见动态代理通过一个代理类来代理 N 多个被代理类，其本质是对代理者与被代理者进行解耦，使两者没有直接的耦合关系。相对而言静态代理则是能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同的代理类，最为复杂，但是静态代理更符合面向对象原则。在开发时具体使用哪种方式来实现代理，就看自己的偏好了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代理模式应用广泛，在后面的结构型模式中，你都可以看到代理模式的影子，有些模式单独作为一种设计模式，倒不如说是对代理模式的一种针对性优化。而且代理模式几乎没有缺点可言，它是细分化至很小的一种模式，如果非得说一个缺点的话，那么就是设计模式的通病，对类的增加。不过在这种孰优孰劣的局势下，就算对类的稍微增加又有什么问题呢，是吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习代理模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;代理模式 (Proxy Pattren) 也称为委托模式，是属于结构型设计模式，其重要性不言而喻，相信在看过本篇文章之后会发现不少设计模式中都有代理模式的影子。那么何为代理模式？其实代理在我们日常生活中并不少见，对于程序员来说最常接触的莫过于代理上网了，连上代理服务器地址，就可以轻松畅游全世界的网络；总而言之，也许你并不留意，但是代理是无处不在，现实生活如此，我们的 Code 世界里也是如此！既然这样，我们来探究下代理模式倒是有多普遍。下面首先看下代理模式的定义吧。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;为其它对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;当无法或不想直接访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="https://zhangmiao.cc/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十四之中介者模式</title>
    <link href="https://zhangmiao.cc/posts/386c7d9.html"/>
    <id>https://zhangmiao.cc/posts/386c7d9.html</id>
    <published>2019-09-16T06:25:53.000Z</published>
    <updated>2019-09-16T06:35:10.698Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习中介者模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>中介者模式 (Mediator Pattern) 也称为调解者模式或调停者模式，Mediator 本身就有调停者和调解者的意思。在日常生活中调停者或调解者这个角色我们见得比较多的是 ”和事佬“，也就是说调解两个有争端的人的角色。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立变化。中介者模式将多对多的相互作用转化为一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及修改很多其他对象的行为，可采用中介者模式来解决紧耦合问题。该模式将对象之间的多对多变成一对多关系，中介者对象将系统从网状结构变成以调解者为中心的星形结构，达到降低系统的复杂性，提高可扩展性的作用。</p><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190916142711.png" alt></p><ul><li>Mediator: 抽象中介者角色，定义了同事对象到中介者对象的接口，一般以抽象类的方式实现。</li><li>ConcreteMediator: 具体中介者角色，继承于抽象中介者，实现了父类定义的方法，它从具体的同事对象接收消息，向具体同事对象发出命令。</li><li>Colleague: 抽象同事类角色，定义了中介者对象的接口，它只知道中介者而不知道其它的同事对象。</li><li>ConcreteColleagueA/B: 具体同事类角色，继承于抽象同事类，每个具体同事类都知道本身在小范围内的行为，而不知道它在大范围内的目的。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><strong>中介抽象类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体同事类 A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleagueA concreteColleagueA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体同事类 B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleagueB concreteColleagueB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象中介方法、子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConcreteColleagueA</span><span class="params">(ConcreteColleagueA concreteColleagueA)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.concreteColleagueA = concreteColleagueA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConcreteColleagueA</span><span class="params">(ConcreteColleagueB concreteColleagueB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.concreteColleagueB = concreteColleagueB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体中介者:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        concreteColleagueA.action();</span><br><span class="line">        concreteColleagueB.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>抽象同事:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Colleague &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 中介者对象</span><br><span class="line">     */</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同事角色具体行为，由子类实现</span><br><span class="line">     */</span><br><span class="line">    public abstract void  action();</span><br><span class="line"></span><br><span class="line">    public Colleague(Mediator mediator) &#123;</span><br><span class="line">        this.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体同事实现类A/B</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueA</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueA</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteColleagueA 将信息递交给中介者处理"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueB</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueB</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteColleagueB 将信息递交给中介者处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMediator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcreteMediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">    mediator.setConcreteColleagueA(<span class="keyword">new</span> ConcreteColleagueA(mediator));</span><br><span class="line">    mediator.setConcreteColleagueB(<span class="keyword">new</span> ConcreteColleagueB(mediator));</span><br><span class="line">    mediator.method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConcreteColleagueA 将信息递交给中介者处理</span><br><span class="line">ConcreteColleagueB 将信息递交给中介者处理</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><em>需求:</em> 用代码演示电脑中的主板怎么把 CPU、内存、显卡、IO 设备 等组合在一起的,并控制他们播放音视频数据？用中介者模式</p><p><strong>抽象中介类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同事对象改变时通知中介者的方法</span></span><br><span class="line"><span class="comment">     * 在同事对象改变时由中介者去通知其它同事对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(Colleague c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体抽象中介类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainBoard</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 光驱设备</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CDDevice cdDevice;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声卡设备</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SoundCard soundCard;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 光驱设备</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> GraphicsCard graphicsCard;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(Colleague c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是光驱读取了数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == cdDevice)&#123;</span><br><span class="line">            handleCD((CDDevice)c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果 CPU 处理完数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == cpu)&#123;</span><br><span class="line">            handleCPU((CPU)c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 CPU 读取数据后与其它设备的交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cpu</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCPU</span><span class="params">(CPU cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.soundCard.soundPlay(cpu.getDataSound());</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard.videoPlay(cpu.getDataVideo());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理光驱读取数据后与其它设备的交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cdDevice</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCD</span><span class="params">(CDDevice cdDevice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu.decodeData(cdDevice.read());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">setCPU</span><span class="params">(CPU cpu)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 CD</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setCdDevice</span><span class="params">(CDDevice cdDevice)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cdDevice = cdDevice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置声卡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSoundCard</span><span class="params">(SoundCard soundCard)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.soundCard = soundCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置显卡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGraphicsCard</span><span class="params">(GraphicsCard graphicsCard)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = graphicsCard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象同事:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDDevice</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String videoData;<span class="comment">//视频数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDDevice</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取视频数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> videoData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载视频数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">        videoData = <span class="string">"视频数据,音频数据"</span>;</span><br><span class="line">        mediator.changed(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cpu、GraphicsCard,SoundCard, 这几个实现都差不多就不在贴代码了。</p><p><strong>操作类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMediator2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造主板对象--也就是中介者</span></span><br><span class="line">    MainBoard mainBoard = <span class="keyword">new</span> MainBoard();</span><br><span class="line">    <span class="comment">//分别构造零部件</span></span><br><span class="line">    CPU cpu = <span class="keyword">new</span> CPU(mainBoard);</span><br><span class="line"></span><br><span class="line">    CDDevice cdDevice = <span class="keyword">new</span> CDDevice(mainBoard);</span><br><span class="line"></span><br><span class="line">    GraphicsCard graphicsCard = <span class="keyword">new</span> GraphicsCard(mainBoard);</span><br><span class="line"></span><br><span class="line">    SoundCard soundCard = <span class="keyword">new</span> SoundCard(mainBoard);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将各个零部件安装到主板身上</span></span><br><span class="line">    mainBoard.setCdDevice(cdDevice);</span><br><span class="line">    mainBoard.setCPU(cpu);</span><br><span class="line">    mainBoard.setGraphicsCard(graphicsCard);</span><br><span class="line">    mainBoard.setSoundCard(soundCard);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安装完成后，开始播放视频。</span></span><br><span class="line">    cdDevice.load();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">音频 = [音频数据]</span><br><span class="line">视频 = [视频数据]</span><br></pre></td></tr></table></figure><p>从上述程序演示中大家可以明白，中介者模式就是用来协调多个对象之间的交互，就像上面实例中的主板，如果没有主板这个中介者，那么计算机里的没一个零部件都要与其它零部件建立关联，比如 CPU 要与内存交互、CPU 要与显卡交互、CPU 要与 IO 设备交互等，这么一来就会构成一个错综复杂的网状图，而中介者模式的出现则是将这一个错综复杂的网状图编程一个结构清晰的星状图，其中心就是中介者。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在面向对象的编程语言里，一个类必然会与其他类产生依赖关系，如果这种依赖关系如网状般错综复杂，那么必然会影响我们的代码执行效率，适当的使用中介者模式可以对这种依赖关系解耦使逻辑结构清晰，但是，如果几个类之间的依赖关系并不复杂，使用中介者模式反而使得原本不复杂的逻辑结构变得复杂，所以，我们在决定使用中介者模式之前要多考虑权衡利弊。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习中介者模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;中介者模式 (Mediator Pattern) 也称为调解者模式或调停者模式，Mediator 本身就有调停者和调解者的意思。在日常生活中调停者或调解者这个角色我们见得比较多的是 ”和事佬“，也就是说调解两个有争端的人的角色。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立变化。中介者模式将多对多的相互作用转化为一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及修改很多其他对象的行为，可采用中介者模式来解决紧耦合问题。该模式将对象之间的多对多变成一对多关系，中介者对象将系统从网状结构变成以调解者为中心的星形结构，达到降低系统的复杂性，提高可扩展性的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="中介者模式" scheme="https://zhangmiao.cc/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十三之访问者模式</title>
    <link href="https://zhangmiao.cc/posts/fa7c7db8.html"/>
    <id>https://zhangmiao.cc/posts/fa7c7db8.html</id>
    <published>2019-09-13T07:35:46.000Z</published>
    <updated>2019-09-16T06:29:05.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习访问者模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>访问者模式是一种将数据操作与数据结构分离的设计模式，它是 《设计模式》中较为复杂的一个，但它的使用频率并不高，正如《设计模式》的作者 GOF 对访问者模式的描述：大多数情况下，你并不需要使用访问者模式，但是当你一旦需要使用它时，那你就是真正的需要它了。</p><p>访问者模式的基本思想是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个 visit 方法，这个方法对访问到的对象结构中不同类型的元素做出不同的处理。在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，在每一个元素的 accept 方法中会调动访问者的 visit 方法，从而使访问者得到以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>对象结构比较稳定，但经常需要在此对象进行很多不同的并且不相关的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作 “污染” 这些对象的类，也不希望在增加新操作时修改这些类。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913153750.png" alt></p><ul><li>Visitor：接口或者抽象类，它定义了对每一个元素 (Element) 访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素个数是一样的，因此，访问者模式要求元素的类族要稳定，如果经常添加、移除元素类，必然会导致频繁地修改 Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。</li><li>ConcreteVisitor: 具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。</li><li>ElementA、ElementB: 具体的元素类，它提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li>ObjectStructure: 定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>访问者模式是一个结构、概念都较为复杂的模式，使用频率也不高，但是并不代表可以将它的作用忽略，当有合适的场景时，访问者模式会带来意向不到的灵活性，下面我们就以一个简单的示例说明下：</li></ul><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><strong>需求</strong>: 公司的领导层年底对员工进行绩效考核，但是每个领导对于员工的关注点不同，所以要不同的访问处理。</p><p><em>员工抽象类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String  name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 员工 kpi</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kpi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Staff</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        kpi = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受公司领导层对员的访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> visitor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Staff 类定义了员工的基本信息及一个 accept 方法，表示接受公司领导的访问，由子类具体实现，下面来看看，具体实现。</p><p><em>程序员：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engineer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工程师这一年写的代码量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCodeLines</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span> * <span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>经理:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一年做的产品数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProducts</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序员、经理类中添加了各自的实现，因为他们的差异性才能使得访问者模式发挥它的工作。Staff、Engineer、Manager 这 3 个类就是对象结构，这些类相对稳定，不会发生变化。</p><p><em>员工报表:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinesssReport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Staff&gt; mStaff = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinesssReport</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mStaff.add(<span class="keyword">new</span> Manager(<span class="string">"DevYK 经理"</span>));</span><br><span class="line">        mStaff.add(<span class="keyword">new</span> Engineer(<span class="string">"IOS 工程师"</span>));</span><br><span class="line">        mStaff.add(<span class="keyword">new</span> Engineer(<span class="string">"Android 工程师"</span>));</span><br><span class="line">        mStaff.add(<span class="keyword">new</span> Engineer(<span class="string">"Java 工程师"</span>));</span><br><span class="line">        mStaff.add(<span class="keyword">new</span> Engineer(<span class="string">"C++ 工程师"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为访问者展示报表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showReport</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Staff staff : mStaff) &#123;</span><br><span class="line">            staff.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>公司领导层抽象访问者封装:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问工程师类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问经理类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager leader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>CEO 访问员工实现:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"engineer = ["</span> + <span class="string">"name: "</span> + engineer.name + <span class="string">" kpi: "</span> + engineer.kpi + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager leader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"leader = ["</span> + <span class="string">"name: "</span> + leader.name + <span class="string">" kpi: "</span> + leader.kpi + <span class="string">" 产品数量："</span> + leader.getProducts() + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>CTO 访问员工实现</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CTOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"engineer = ["</span> + engineer.name + <span class="string">" 代码行数："</span>+engineer.getCodeLines()+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager leader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"leader = ["</span> + leader.name + <span class="string">" 产品数量："</span>+leader.getProducts()+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Client 客户端代码 –》年总进行访问</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">textVisitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建报表</span></span><br><span class="line">    BusinesssReport businesssReport = <span class="keyword">new</span> BusinesssReport();</span><br><span class="line">    <span class="comment">//给 CEO 汇报的报表</span></span><br><span class="line">    System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CEO 汇报的报表"</span>);</span><br><span class="line">    businesssReport.showReport(<span class="keyword">new</span> CEOVisitor());</span><br><span class="line">    <span class="comment">//给 CTO 汇报的报表</span></span><br><span class="line">    System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CTO 汇报的报表"</span>);</span><br><span class="line">    businesssReport.showReport(<span class="keyword">new</span> CTOVisitor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码中，首先构建了一个报表对象，该对象中维护了所有员工的集合，然后通过报表类的 showReport 函数为 Visitor 对象提供一个访问接口，在这个函数中查看所有员工信息，然后调用员工的 accept 函数接受公司领导层的访问，每个访问者对不同职位的员工调用对应的 visit 函数实现不同的操作。绩效如下：</p><p><em>ouput:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CEO 汇报的报表</span><br><span class="line">leader = [name: DevYK 经理 kpi: <span class="number">6</span> 产品数量：<span class="number">6</span>]</span><br><span class="line">engineer = [name: IOS 工程师 kpi: <span class="number">3</span>]</span><br><span class="line">engineer = [name: Android 工程师 kpi: <span class="number">1</span>]</span><br><span class="line">engineer = [name: Java 工程师 kpi: <span class="number">3</span>]</span><br><span class="line">engineer = [name: C++ 工程师 kpi: <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CTO 汇报的报表</span><br><span class="line">leader = [DevYK 经理 产品数量：<span class="number">4</span>]</span><br><span class="line">engineer = [IOS 工程师 代码行数：<span class="number">81491</span>]</span><br><span class="line">engineer = [Android 工程师 代码行数：<span class="number">25627</span>]</span><br><span class="line">engineer = [Java 工程师 代码行数：<span class="number">61337</span>]</span><br><span class="line">engineer = [C++ 工程师 代码行数：<span class="number">51714</span>]</span><br></pre></td></tr></table></figure><p>在上述示例中， Staff 扮演了 Element 角色，而 Engineer 和 Manager 都是 ConcreteElement; CEOVisitor 和 CTOVisitor 都是具体的访问者 Visitor 对象实现；而 BusinessReport 就是 ObjectStructure; Client 就是客户端代码，详细结构可以下下面的 UML 类图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913153858.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><em>优点:</em></p><ul><li>各自角色职责分明，符合单一职责原则；</li><li>具有优秀的可扩展性；</li><li>使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。</li><li>灵活性。</li></ul><p><em>缺点：</em></p><ul><li>具体元素对访问者公布细节，违反了迪米特原则；</li><li>具体元素变更时导致修改成本大；</li><li>违反了依赖导致原则，为了达到 “区别对待” 而依赖了具体类，没有依赖抽象；</li></ul><p>在使用该模式之前，我们应该明确它的使用场景、它能解决什么问题等，以此来避免滥用设计模式。所以，在学习设计模式时，一定要理解模式的适用性及优缺点。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习访问者模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;访问者模式是一种将数据操作与数据结构分离的设计模式，它是 《设计模式》中较为复杂的一个，但它的使用频率并不高，正如《设计模式》的作者 GOF 对访问者模式的描述：大多数情况下，你并不需要使用访问者模式，但是当你一旦需要使用它时，那你就是真正的需要它了。&lt;/p&gt;
&lt;p&gt;访问者模式的基本思想是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个 visit 方法，这个方法对访问到的对象结构中不同类型的元素做出不同的处理。在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，在每一个元素的 accept 方法中会调动访问者的 visit 方法，从而使访问者得到以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对象结构比较稳定，但经常需要在此对象进行很多不同的并且不相关的操作。&lt;/li&gt;
&lt;li&gt;需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作 “污染” 这些对象的类，也不希望在增加新操作时修改这些类。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="访问者模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十二之模板方法模式</title>
    <link href="https://zhangmiao.cc/posts/afa4869b.html"/>
    <id>https://zhangmiao.cc/posts/afa4869b.html</id>
    <published>2019-09-13T07:31:58.000Z</published>
    <updated>2019-09-13T07:39:27.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习模板方法模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在面向对象开发过程中，通常会遇到这样的一个问题，我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的，例如，执行程序的流程大致如下:</p><ol><li>检查代码的正确性；</li><li>链接相关的类库；</li><li>编译相关代码；</li><li>执行程序；</li></ol><p>对于不同的程序设计语言，上述 4 个步骤都是不一样的，但是，它们的执行流程是固定的，这类问题的解决方案就是这们这篇的主要内容 - 模板方法模式。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个操作中算法的框架，将一些步骤交于子类具体实现，使得子类可以改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个子类有公有的方法，并且逻辑基本相同时。</li><li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li><li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913153323.png" alt></p><ul><li>AbsTemplate: 抽象类，定义了一套算法框架。</li><li>ConcreteImplA: 具体实现类 A。</li><li>ConcreteImpleB: 具体实现类 B。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>模板方法模式实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换，下面就就以简单示例来说明一下。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><em>需求：</em> 用代码简要描述开机过程</p><p><strong>定义抽象的模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启电源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启电源"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 硬件检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHardware</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"硬件检查"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载系统</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加载系统"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 屏幕显示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">showScreen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"屏幕显示"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"密码验证成功，进入主页面。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动计算机方法，步骤固定为开启电源、硬件检查、加载系统、屏幕显示、登录。设计为 final 防止被重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------&gt;&gt;&gt;&gt;&gt;&gt;&gt;   startup  "</span>);</span><br><span class="line">        powerOn();</span><br><span class="line">        checkHardware();</span><br><span class="line">        loadSystem();</span><br><span class="line">        showScreen();</span><br><span class="line">        login();</span><br><span class="line">        System.out.println(<span class="string">"------&gt;&gt;&gt;&gt;&gt;&gt;&gt;   Successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象模板实现 A</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoderComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"密码输入完成，交于系统检查。"</span>);</span><br><span class="line">        <span class="keyword">super</span>.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象模板实现 B</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilitaryComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHardware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.checkHardware();</span><br><span class="line">        System.out.println(<span class="string">"检查防火墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"视网膜扫描 \n 视网膜验证成功"</span>);</span><br><span class="line">        <span class="keyword">super</span>.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    AbstractComputer abstractComputerA = <span class="keyword">new</span> CoderComputer();</span><br><span class="line">    abstractComputerA.startUp();</span><br><span class="line"></span><br><span class="line">    AbstractComputer abstractComputerB = <span class="keyword">new</span> MilitaryComputer();</span><br><span class="line">    abstractComputerB.startUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>output</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">程序员电脑启动流程</span><br><span class="line">------&gt;&gt;&gt;&gt;&gt;&gt;&gt;   startup  </span><br><span class="line">开启电源</span><br><span class="line">硬件检查</span><br><span class="line">加载系统</span><br><span class="line">屏幕显示</span><br><span class="line">密码输入完成，交于系统检查。</span><br><span class="line">密码验证成功，进入主页面。</span><br><span class="line">------&gt;&gt;&gt;&gt;&gt;&gt;&gt;   Successful</span><br><span class="line"></span><br><span class="line">军用电脑启动流程</span><br><span class="line">------&gt;&gt;&gt;&gt;&gt;&gt;&gt;   startup  </span><br><span class="line">开启电源</span><br><span class="line">硬件检查</span><br><span class="line">检查防火墙</span><br><span class="line">加载系统</span><br><span class="line">屏幕显示</span><br><span class="line">视网膜扫描 </span><br><span class="line">视网膜验证成功</span><br><span class="line">密码验证成功，进入主页面。</span><br><span class="line">------&gt;&gt;&gt;&gt;&gt;&gt;&gt;   Successful</span><br></pre></td></tr></table></figure><p>通过上面的模板例子可以看到 ，在 startUp 方法中有一些固定的执行顺序，但是，不同的场景执行实现的步骤各不相同，因此子类需要复写相应的方法来进行自定义处理，这里需要注意的是 startUp 为 final 方法，这样就可以保证模板的执行顺序不被外部更改，子类更改某一时刻执行的具体实现，这样就保证了整个逻辑流程的稳定性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板方法模式用 4 个字概括就是：流程封装。也就是把某个固定的流程封装到一个 final 函数中，并让子类能够定制这个流程中的某些或者所有步骤，这就要求父类提取共用的代码，提升代码复用率，同时也带来了更好的可扩展性。</p><p><strong>优点:</strong></p><ol><li>封装不变部分，扩展可变部分。</li><li>提取公共部分代码，便于维护。</li></ol><p><strong>缺点:</strong></p><ol><li>模板方法会带来代码阅读的难度，会让用户觉得难以理解。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习模板方法模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在面向对象开发过程中，通常会遇到这样的一个问题，我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的，例如，执行程序的流程大致如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查代码的正确性；&lt;/li&gt;
&lt;li&gt;链接相关的类库；&lt;/li&gt;
&lt;li&gt;编译相关代码；&lt;/li&gt;
&lt;li&gt;执行程序；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于不同的程序设计语言，上述 4 个步骤都是不一样的，但是，它们的执行流程是固定的，这类问题的解决方案就是这们这篇的主要内容 - 模板方法模式。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;定义一个操作中算法的框架，将一些步骤交于子类具体实现，使得子类可以改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;多个子类有公有的方法，并且逻辑基本相同时。&lt;/li&gt;
&lt;li&gt;重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。&lt;/li&gt;
&lt;li&gt;重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板方法模式" scheme="https://zhangmiao.cc/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十一之迭代器模式</title>
    <link href="https://zhangmiao.cc/posts/1cfae984.html"/>
    <id>https://zhangmiao.cc/posts/1cfae984.html</id>
    <published>2019-09-13T07:24:31.000Z</published>
    <updated>2019-09-13T07:35:15.976Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习迭代器模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>迭代器模式 (Iterator Pattern) 又称为游标 (Cursor) 模式 ，是行为型设计模式之一。迭代器模式算是一个比较古老的设计模式，其源于对容器的访问，比如 Java 的 List 、Map 、数组等，我们知道对容器对象的访问必然会设计遍历算法，我们可以将遍历的方法封装在容器中，或者不提供遍历方法。如果我们将遍历的方法封装到容器中，那么对于容器类来说就承担了过多的功能，容器类不仅仅要维护自身内部的数据元素而且还要对外提供遍历的接口方法，因为遍历状态的存储问题还不能对同一个容器同时进行多个遍历操作，如果我们不提供遍历方法而让使用者自己去实现，又会让容器内部细节暴露无遗，正因于此，迭代模式应运而生，在客户访问类与容器体之间插入了一个第三者 - 迭代器，很好地解决了上面所述的弊端。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>遍历一个容器对象时。</p><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913152616.png" alt></p><ul><li>Iterator: 迭代器接口。迭代器接口负责定义、访问和遍历元素的接口。</li><li>Concrete Iterator: 具体迭代器类。具体迭代器类的目的主要是实现迭代器接口，并记录遍历的当前位置。</li><li>Aggregate: 容器接口。容器接口负责提供创建具体迭代器角色的接口。</li><li>Concrete Aggregate: 具体容器类。具体迭代器角色与该容器相关联。</li><li>Client: 客户类。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><em>迭代器接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  是否还有下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示有，false 表示没有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前位置的元素并将位置移动到下一位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>具体迭代器类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用一个 List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; mList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mList = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != mList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个临时变量</span></span><br><span class="line">        T obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = <span class="keyword">this</span>.mList.get(cursor++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>容器接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取容器的迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>具体容器类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟具体容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; mLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        mLists.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        mLists.remove(t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;T&gt;(mLists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>客户类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建容器</span></span><br><span class="line">    Aggregate&lt;String&gt; aggregate = <span class="keyword">new</span> ConcreteAggregate&lt;&gt;();</span><br><span class="line">    aggregate.add(<span class="string">"1"</span>);</span><br><span class="line">    aggregate.add(<span class="string">"2"</span>);</span><br><span class="line">    aggregate.add(<span class="string">"3"</span>);</span><br><span class="line">    aggregate.add(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到容器迭代器，使用迭代器遍历</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = aggregate.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Aggregate: "</span> + iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Output:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Aggregate: <span class="number">1</span></span><br><span class="line">Aggregate: <span class="number">2</span></span><br><span class="line">Aggregate: <span class="number">3</span></span><br><span class="line">Aggregate: <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于迭代器模式来说，其自身优点很明显也很单一，支持以不同的方式去遍历一个容器对象，也可以有多个遍历，弱化了容器类与遍历算法之间的关系，其缺点就是对类文件的增加。</p><p>大家也可能会想到其他语言，如 C++、Python 、PHP 等，他们内部也有众多容器体的定义，当然，也有相应的迭代器。迭代器模式发展至今，几乎每一种高级语言都有相应的内置实现，对于开发者而言，已经极少会去自己实现迭代器了，因此，对于迭代器模式在于了解而非应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习迭代器模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;迭代器模式 (Iterator Pattern) 又称为游标 (Cursor) 模式 ，是行为型设计模式之一。迭代器模式算是一个比较古老的设计模式，其源于对容器的访问，比如 Java 的 List 、Map 、数组等，我们知道对容器对象的访问必然会设计遍历算法，我们可以将遍历的方法封装在容器中，或者不提供遍历方法。如果我们将遍历的方法封装到容器中，那么对于容器类来说就承担了过多的功能，容器类不仅仅要维护自身内部的数据元素而且还要对外提供遍历的接口方法，因为遍历状态的存储问题还不能对同一个容器同时进行多个遍历操作，如果我们不提供遍历方法而让使用者自己去实现，又会让容器内部细节暴露无遗，正因于此，迭代模式应运而生，在客户访问类与容器体之间插入了一个第三者 - 迭代器，很好地解决了上面所述的弊端。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;遍历一个容器对象时。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://zhangmiao.cc/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式十之备忘录模式</title>
    <link href="https://zhangmiao.cc/posts/6afac2a.html"/>
    <id>https://zhangmiao.cc/posts/6afac2a.html</id>
    <published>2019-09-13T07:18:51.000Z</published>
    <updated>2019-09-13T07:24:50.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习备忘录模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>备忘录模式</code>属于行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时口头禅 ”有没有后悔药“ 。备忘录模式实现的方式需要保证被保存的对象状态不能被对象外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象恢复到原先保存的状态。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要保存一个对象在某一个时刻的状态或部分状态。</li><li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913151959.png" alt></p><ul><li>Originator: 负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。</li><li>Memento: 备忘录角色，用于存储 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memento。</li><li>Caretaker: 负责存储备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其它对象。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>需求:</strong>  开发一款简单记事本, 包括撤销、重做功能。</p><p><strong>代码:</strong></p><p>负责管理记事本的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteCaretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大存储容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 50 个容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Memorandum&gt; mMemorandumLists = <span class="keyword">new</span> ArrayList&lt;&gt;(MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存档位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存备忘录到记录列表中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemorandum</span><span class="params">(Memorandum memorandum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMemorandumLists.size() &gt; MAX)&#123;</span><br><span class="line">            mMemorandumLists.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mMemorandumLists.add(memorandum);</span><br><span class="line">        mIndex = mMemorandumLists.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个存档信息，相当于撤销功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memorandum <span class="title">getPrevMemorandum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIndex = mIndex &gt; <span class="number">0</span> ? --mIndex : mIndex;</span><br><span class="line">        <span class="keyword">return</span> mMemorandumLists.get(mIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个存档信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memorandum <span class="title">getNextMemorandum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIndex = mIndex &lt; mMemorandumLists.size() - <span class="number">1</span>? ++mIndex : mIndex;</span><br><span class="line">        <span class="keyword">return</span> mMemorandumLists.get(mIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NodeCaretaker 中会维护一个备忘录列表，然后使用 mIndex 标识编辑器当前所在的记录点，通过 getPrev getNext 分别获取上一个、下一个记录点的备忘录，以此来达到撤销、重做的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeEditText</span> <span class="keyword">extends</span> <span class="title">EditText</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeEditText</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeEditText</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeEditText</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建备忘录对象，即存储编辑器的指定数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memorandum <span class="title">createMemorandum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Memorandum memorandum = <span class="keyword">new</span> Memorandum();</span><br><span class="line">        memorandum.text = getText().toString().trim();</span><br><span class="line">        memorandum.cursor = getSelectionStart();</span><br><span class="line">        <span class="keyword">return</span> memorandum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从备忘录中恢复数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Memorandum memorandum)</span></span>&#123;</span><br><span class="line">        setText(memorandum.text);</span><br><span class="line">        setSelection(memorandum.cursor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义一个记事本编辑器，添加2个函数，分别是 createMemorandum 、restore 函数。createMemorandum 函数是创建一个存储了编辑器文本，光标位置数据的 Memorandum 对象，并且返回给客户端；restore 函数是从 Memorandum 对象中恢复编辑器的文本和光标位置。</p><p>备忘录模式就介绍到这里了，主要还是要明确每个类的职责，遵从面向对象六大原则开发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点：</p><ul><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态。</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li></ul><p>缺点：</p><ul><li>消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习备忘录模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;备忘录模式&lt;/code&gt;属于行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时口头禅 ”有没有后悔药“ 。备忘录模式实现的方式需要保证被保存的对象状态不能被对象外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;需要保存一个对象在某一个时刻的状态或部分状态。&lt;/li&gt;
&lt;li&gt;如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="备忘录模式" scheme="https://zhangmiao.cc/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式九之观察者模式</title>
    <link href="https://zhangmiao.cc/posts/871a12ed.html"/>
    <id>https://zhangmiao.cc/posts/871a12ed.html</id>
    <published>2019-09-13T07:13:25.000Z</published>
    <updated>2019-09-13T07:24:50.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习观察者模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅-发布，因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得她们之间的依赖性更小，甚至做到毫无依赖。以 GUI 系统来说，应用的 UI 具有易变性，尤其是前期随着业务的改变或者产品的需求更改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时， GUI 系统需要一套机制来应对这种情况，使得 UI 层与具体的业务逻辑解耦，观察者模式此时就派上用场了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象间一种 1 对 N 的关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是 “组合” 关系。</li><li>事件多级触发场景。</li><li>跨系统的消息交换场景，如消息队列、事件总线的消息机制。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913151436.png" alt></p><ul><li><p>Subject : 抽象主题，也就是被观察者的角色，抽象主题角色把所有观察者</p><p>对象的引用保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p></li><li><p>ConcreteSubject: 具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发出通知，具体主题角色又叫做具体被观察者角色。</p></li><li><p>Observer: 抽象观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的状态发生变化时更新自身的状态。</p></li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>需求：订阅某网站技术文章，有更新就推送。</p><p>定义一个观察者对象 - 用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有更新将执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"o = ["</span> + o + <span class="string">"], arg = ["</span> + name + <span class="string">" "</span> + (String) arg + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Coder&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义被观察者对象 - 技术网站</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JueJ</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推送</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        <span class="comment">//标识状态或者内容需要发生改变</span></span><br><span class="line">        setChanged();</span><br><span class="line">        <span class="comment">//通知所有订阅者</span></span><br><span class="line">        notifyObservers(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建被观察者--》技术网站</span></span><br><span class="line">    JueJ jueJ = <span class="keyword">new</span> JueJ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建观察者</span></span><br><span class="line">    Coder coderA = <span class="keyword">new</span> Coder(<span class="string">"A"</span>);</span><br><span class="line">    Coder coderB = <span class="keyword">new</span> Coder(<span class="string">"B"</span>);</span><br><span class="line">    Coder coderC = <span class="keyword">new</span> Coder(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生订阅关系，加入被观察者列表中，有更新就推送给它们</span></span><br><span class="line">    jueJ.addObserver(coderA);</span><br><span class="line">    jueJ.addObserver(coderB);</span><br><span class="line">    jueJ.addObserver(coderC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有更新了，通知观察者们</span></span><br><span class="line">    jueJ.post(<span class="string">"Dev_YK: 更新了一篇设计模式文章，点击进行查看。"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o = [com.devyk.android_dp_code.observer.JueJ@<span class="number">48533e64</span>], arg = [C Dev_YK: 更新了一篇设计模式文章，点击进行查看。]</span><br><span class="line">o = [com.devyk.android_dp_code.observer.JueJ@<span class="number">48533e64</span>], arg = [B Dev_YK: 更新了一篇设计模式文章，点击进行查看。]</span><br><span class="line">o = [com.devyk.android_dp_code.observer.JueJ@<span class="number">48533e64</span>], arg = [A Dev_YK: 更新了一篇设计模式文章，点击进行查看。]</span><br></pre></td></tr></table></figure><p>可以看到所有订阅了某技术网站的用户都收到了通知更新，一对多的订阅-发布系统就完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>观察者模式主要的作用就是解耦，将观察者与被观察者完全隔离，只依赖于 Observe 和 Observable 抽象。</p><p><strong>优点：</strong></p><ul><li>观察者和被观察者之间是抽象耦合，应对业务变化。</li><li>增强系统灵活性，可扩展性。</li></ul><p><strong>缺点：</strong></p><ul><li>在应用观察者模式时需要考虑一下开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调试等内容会比较复杂，而且在 Java 中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这个情况下，一般考虑使用异步方式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习观察者模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅-发布，因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得她们之间的依赖性更小，甚至做到毫无依赖。以 GUI 系统来说，应用的 UI 具有易变性，尤其是前期随着业务的改变或者产品的需求更改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时， GUI 系统需要一套机制来应对这种情况，使得 UI 层与具体的业务逻辑解耦，观察者模式此时就派上用场了。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;定义对象间一种 1 对 N 的关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;关联行为场景，需要注意的是，关联行为是可拆分的，而不是 “组合” 关系。&lt;/li&gt;
&lt;li&gt;事件多级触发场景。&lt;/li&gt;
&lt;li&gt;跨系统的消息交换场景，如消息队列、事件总线的消息机制。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="https://zhangmiao.cc/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式八之责任链模式</title>
    <link href="https://zhangmiao.cc/posts/61fa11d3.html"/>
    <id>https://zhangmiao.cc/posts/61fa11d3.html</id>
    <published>2019-09-13T07:10:24.000Z</published>
    <updated>2019-09-13T07:24:50.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习责任链模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>责任链模式 (Iterator Pattern) ,属于行为型设计模式之一。什么是 “链” ？<code>我们将多个节点首尾相连所构成的模型称为链</code> 。就好比生活中一个个铁圆环一个连这一个环环相扣一样。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到处理为止。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个对象可以处理同一个请求，但是具体由哪个对象处理则在运行时动态决定。</li><li>在请求处理者不明确的情况下向多个对象中的一个提交一个请求。</li><li>需要动态指定一组对象处理请求。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913151119.png" alt></p><ul><li>Handler : 抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点 Handler 的引用。</li><li>ConcreteHandler: 具体处理角色，对请求进行处理，如果不能处理则将该请求转发给下一个请求。</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><strong>简单示例1：</strong></p><p>定义抽象处理者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String  TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点来负责处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始处理请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(HandlerRequest handlerRequest)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getHandlerRequestLevel() == handlerRequest.getRequestLevel())&#123;</span><br><span class="line">            handler(handlerRequest);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextHandler.handlerRequest(handlerRequest);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(TAG,<span class="string">"当前事件"</span>+handlerRequest.getRequestLevel() + <span class="string">"都不处理"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体处理方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handlerRequest</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(HandlerRequest handlerRequest)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取处理对象的处理级别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getHandlerRequestLevel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象请求者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerRequest</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取处理对象内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>  <span class="title">getRequestLevel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体处理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(HandlerRequest handlerRequest)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handlerRequest = ["</span> +TAG + <span class="string">" "</span> + (String) handlerRequest.getContent() + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getHandlerRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(HandlerRequest handlerRequest)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handlerRequest = ["</span> + TAG + <span class="string">" "</span> +(String) handlerRequest.getContent() + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getHandlerRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体请求者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestA</span> <span class="keyword">extends</span> <span class="title">HandlerRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestA</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestB</span> <span class="keyword">extends</span> <span class="title">HandlerRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestB</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function">        <span class="title">super</span><span class="params">(obj)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Client 测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造处理对象</span></span><br><span class="line">    Handler handlerA = <span class="keyword">new</span> HandlerA();</span><br><span class="line">    Handler handlerB = <span class="keyword">new</span> HandlerB();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交给下一个节点处理</span></span><br><span class="line">    handlerA.nextHandler = handlerB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造请求对象</span></span><br><span class="line">    HandlerRequest handlerRequestA = <span class="keyword">new</span> RequestA(<span class="string">"A"</span>);</span><br><span class="line">    HandlerRequest handlerRequestB = <span class="keyword">new</span> RequestB(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发起请求</span></span><br><span class="line">    handlerA.handlerRequest(handlerRequestA);</span><br><span class="line">    handlerA.handlerRequest(handlerRequestB);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handlerRequest = [HandlerA A]</span><br><span class="line">handlerRequest = [HandlerB B]</span><br></pre></td></tr></table></figure><p>从测试代码可以看到 ，我们的 handlerA 的下一个请求交给了 handlerB，那么在发起请求的时候内部就会判断，如果当前发起请求的级别跟处理事件的级别不符合的话 ，就交给下一个节点来判断，如果都没有找到就报空。</p><p><strong>实战示例2：</strong></p><p>在 Android 中我们知道 Broadcast 可以分为 2 种，一种是普通广播，一种是有序广播，普通广播是异步的，发出时可以被所有的接收者收到；而有序广播则是根据优先级依次传播的，直到接收者将其处理，是不是觉得有序广播跟我们的责任链模式很相似，通过广播也能达到实现责任链事件的处理，下面先看代码：</p><p>先动态注册 3 个广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerOrderBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filter.addAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    filter.setPriority(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    IntentFilter filterB = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filterB.addAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    filterB.setPriority(<span class="number">500</span>);</span><br><span class="line">    registerReceiver(<span class="keyword">new</span> ReceiverB(),filterB);</span><br><span class="line"></span><br><span class="line">    IntentFilter filterC = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filterC.addAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    filterC.setPriority(<span class="number">100</span>);</span><br><span class="line">    registerReceiver(<span class="keyword">new</span> ReceiverC(),filterC);</span><br><span class="line">    registerReceiver(<span class="keyword">new</span> ReceiverA(),filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverA</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (limit == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intent.getStringExtra(<span class="string">"MEG"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.i(<span class="string">"ReceiverA"</span>,<span class="string">"我处理了"</span>);</span><br><span class="line">                Toast.makeText(context,intent.getStringExtra(<span class="string">"MEG"</span>),Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理事件，终止广播</span></span><br><span class="line">            abortBroadcast();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(<span class="string">"ReceiverA"</span>,<span class="string">"我不处理，分发下去"</span>);</span><br><span class="line">            <span class="comment">//添加信息，继续分发，直到任务处理</span></span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle.putInt(<span class="string">"limit"</span>,<span class="number">1000</span>);</span><br><span class="line">            bundle.putString(<span class="string">"MEG"</span>,<span class="string">"中午啦，该吃饭了！"</span>);</span><br><span class="line">            setResultExtras(bundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…其它 2 个广播省略 内部代码只有 limit == ? 不一样</p><p>发送一个有序广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"limit"</span>,<span class="number">1000</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"MEG"</span>,<span class="string">"中午了，该吃饭了"</span>);</span><br><span class="line">    sendOrderedBroadcast(intent,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">08</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41.551</span> <span class="number">28992</span>-<span class="number">28992</span>/com.devyk.android_dp_code I/ReceiverA: 我不处理，分发下去</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">08</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41.557</span> <span class="number">28992</span>-<span class="number">28992</span>/com.devyk.android_dp_code I/ReceiverB: 我不处理，分发下去</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">08</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41.574</span> <span class="number">28992</span>-<span class="number">28992</span>/com.devyk.android_dp_code I/ReceiverC: 我处理了</span><br></pre></td></tr></table></figure><p>这里我们动态注册了 3 个广播，优先级越高越先收到 A，B 都不符合要求，所以下发下去，最后在 C 接收者里面处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点：</strong></p><p>可以对请求者和处理者关系解耦，提高代码灵活性。</p><p><strong>缺点：</strong></p><p>对链中请求处理者的遍历，如果处理者太多，那么遍历会影响一定的性能，特别是在一些递归调用中，要慎用。</p><p>但总体来说，优点是大于缺点的，缺点相对于优点来说还是可控的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习责任链模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;责任链模式 (Iterator Pattern) ,属于行为型设计模式之一。什么是 “链” ？&lt;code&gt;我们将多个节点首尾相连所构成的模型称为链&lt;/code&gt; 。就好比生活中一个个铁圆环一个连这一个环环相扣一样。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到处理为止。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;多个对象可以处理同一个请求，但是具体由哪个对象处理则在运行时动态决定。&lt;/li&gt;
&lt;li&gt;在请求处理者不明确的情况下向多个对象中的一个提交一个请求。&lt;/li&gt;
&lt;li&gt;需要动态指定一组对象处理请求。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="责任链模式" scheme="https://zhangmiao.cc/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
