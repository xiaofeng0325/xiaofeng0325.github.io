<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2020-09-19T02:23:52.963Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin泛型</title>
    <link href="https://zhangmiao.cc/posts/6f6a6f9c.html"/>
    <id>https://zhangmiao.cc/posts/6f6a6f9c.html</id>
    <published>2020-09-19T02:21:33.000Z</published>
    <updated>2020-09-19T02:23:52.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-泛型"><a href="#Kotlin-泛型" class="headerlink" title="Kotlin 泛型"></a>Kotlin 泛型</h1><p>泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</p><p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p><p>声明一个泛型类:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t: T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类的实例时我们需要指定类型参数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box: Box&lt;<span class="built_in">Int</span>&gt; = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">val</span> box = Box(<span class="number">1</span>) <span class="comment">// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure><p>以下实例向泛型类 Box 传入整型数据和字符串：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t : T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> boxInt = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> boxString = Box&lt;String&gt;(<span class="string">"Runoob"</span>)</span><br><span class="line"></span><br><span class="line">    println(boxInt.value)</span><br><span class="line">    println(boxString.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><p>定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。</p><p>Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">boxIn</span><span class="params">(value: <span class="type">T</span>)</span></span> = Box(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都是合法语句</span></span><br><span class="line"><span class="keyword">val</span> box4 = boxIn&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> box5 = boxIn(<span class="number">1</span>)     <span class="comment">// 编译器会进行类型推断</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。</p><p>以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">23</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"runoob"</span></span><br><span class="line">    <span class="keyword">val</span> bool = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    doPrintln(age)    <span class="comment">// 整型</span></span><br><span class="line">    doPrintln(name)   <span class="comment">// 字符串</span></span><br><span class="line">    doPrintln(bool)   <span class="comment">// 布尔型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">doPrintln</span><span class="params">(content: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (content) &#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">"整型数字为 <span class="variable">$content</span>"</span>)</span><br><span class="line">        <span class="keyword">is</span> String -&gt; println(<span class="string">"字符串转换为大写：<span class="subst">$&#123;content.toUpperCase()&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"T 不是整型，也不是字符串"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">整型数字为 <span class="number">23</span></span><br><span class="line">字符串转换为大写：RUNOOB</span><br><span class="line">T 不是整型，也不是字符串</span><br></pre></td></tr></table></figure><hr><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p><p>Kotlin 中使用 : 对泛型的类型上限进行约束。</p><p>最常见的约束是上界(upper bound)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Comparable 的子类型可以替代 T。 例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span></span><br></pre></td></tr></table></figure><p>默认的上界是 Any?。</p><p>对于多个上界约束条件，可以用 where 子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;String&gt;</span><br><span class="line">    where T : CharSequence,</span><br><span class="line">          T : Comparable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h2><p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。</p><h3 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h3><p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p><p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个支持协变的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>&lt;<span class="type">out A</span>&gt;</span>(<span class="keyword">val</span> a: A) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: A &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strCo: Runoob&lt;String&gt; = Runoob(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">var</span> anyCo: Runoob&lt;Any&gt; = Runoob&lt;Any&gt;(<span class="string">"b"</span>)</span><br><span class="line">    anyCo = strCo</span><br><span class="line">    println(anyCo.foo())   <span class="comment">// 输出 a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个支持逆变的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>&lt;<span class="type">in A</span>&gt;</span>(a: A) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">A</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strDCo = Runoob(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">var</span> anyDCo = Runoob&lt;Any&gt;(<span class="string">"b"</span>)</span><br><span class="line">    strDCo = anyDCo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h2><p>有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓”安全地使用”是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。</p><p>对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection):</p><ul><li>假如类型定义为 Foo<out t> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo&lt;<em>&gt; 等价于 Foo<out tupper> . 它表示, 当 T 未知时, 你可以安全地从 Foo&lt;</out></em>&gt; 中 读取TUpper 类型的值.</out></li><li>假如类型定义为 Foo<in t> , 其中 T 是一个反向协变的类型参数, Foo&lt;<em>&gt; 等价于 Foo<innothing> . 它表示, 当 T 未知时, 你不能安全地向 Foo&lt;</innothing></em>&gt; 写入 任何东西.</in></li><li>假如类型定义为 Foo<t> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo&lt;*&gt; 等价于 Foo<out tupper> , 对于写入值的场合, 等价于 Foo<in nothing> .</in></out></t></li></ul><p>如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function&lt;in T, out U&gt; , 那么可以出现以下几种星号投射:</p><ol><li>Function&lt;*, String&gt; , 代表 Function&lt;in Nothing, String&gt; ;</li><li>Function&lt;Int, *&gt; , 代表 Function&lt;Int, out Any?&gt; ;</li><li>Function&lt;<em>,</em> &gt; , 代表 Function&lt;in Nothing, out Any?&gt; .</li></ol><p>注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>关于星号投射，其实就是*代指了所有类型，相当于Any?</p><p>给文中补个例子方便理解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> t: T, <span class="keyword">val</span> t2 : T, <span class="keyword">val</span> t3 : T)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>(<span class="keyword">var</span> name : String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用类    </span></span><br><span class="line">    <span class="keyword">val</span> a1: A&lt;*&gt; = A(<span class="number">12</span>, <span class="string">"String"</span>, Apple(<span class="string">"苹果"</span>))</span><br><span class="line">    <span class="keyword">val</span> a2: A&lt;Any?&gt; = A(<span class="number">12</span>, <span class="string">"String"</span>, Apple(<span class="string">"苹果"</span>))   <span class="comment">//和a1是一样的</span></span><br><span class="line">    <span class="keyword">val</span> apple = a1.t3    <span class="comment">//参数类型为Any</span></span><br><span class="line">    println(apple)</span><br><span class="line">    <span class="keyword">val</span> apple2 = apple <span class="keyword">as</span> Apple   <span class="comment">//强转成Apple类</span></span><br><span class="line">    println(apple2.name)</span><br><span class="line">    <span class="comment">//使用数组</span></span><br><span class="line">    <span class="keyword">val</span> l:ArrayList&lt;*&gt; = arrayListOf(<span class="string">"String"</span>,<span class="number">1</span>,<span class="number">1.2</span>f,Apple(<span class="string">"苹果"</span>))</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> l)&#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-泛型&quot;&gt;&lt;a href=&quot;#Kotlin-泛型&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 泛型&quot;&gt;&lt;/a&gt;Kotlin 泛型&lt;/h1&gt;&lt;p&gt;泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。&lt;/p&gt;
&lt;p&gt;与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。&lt;/p&gt;
&lt;p&gt;声明一个泛型类:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Box&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;(t: T) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;创建类的实例时我们需要指定类型参数:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box: Box&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt; = Box&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box = Box(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&amp;lt;Int&amp;gt;。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以下实例向泛型类 Box 传入整型数据和字符串：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Box&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;(t : T) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; boxInt = Box&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; boxString = Box&amp;lt;String&amp;gt;(&lt;span class=&quot;string&quot;&gt;&quot;Runoob&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(boxInt.value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(boxString.value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runoob&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。&lt;/p&gt;
&lt;p&gt;Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;boxIn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value: &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; = Box(value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下都是合法语句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box4 = boxIn&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box5 = boxIn(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)     &lt;span class=&quot;comment&quot;&gt;// 编译器会进行类型推断&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin数据类与密封类</title>
    <link href="https://zhangmiao.cc/posts/2fd9bfca.html"/>
    <id>https://zhangmiao.cc/posts/2fd9bfca.html</id>
    <published>2020-09-19T02:16:45.000Z</published>
    <updated>2020-09-19T02:19:49.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>Kotlin 可以创建一个只包含数据的类，关键字为 <strong>data</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：</p><ul><li><code>equals()</code> / <code>hashCode()</code></li><li><code>toString()</code> 格式如 <code>&quot;User(name=John, age=42)&quot;</code></li><li><code>componentN() functions</code> 对应于属性，按声明顺序排列</li><li><code>copy()</code> 函数</li></ul><p>如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。</p><p>为了保证生成代码的一致性以及有意义，数据类需要满足以下条件：</p><ul><li>主构造函数至少包含一个参数。</li><li>所有的主构造函数的参数必须标识为<code>val</code> 或者 <code>var</code> ;</li><li>数据类不可以声明为 <code>abstract</code>, <code>open</code>, <code>sealed</code> 或者 <code>inner</code>;</li><li>数据类不能继承其他类 (但是可以实现接口)。</li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, age: <span class="type">Int</span> = this.age)</span></span> = User(name, age)</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用 copy 类复制 User 数据类，并修改 age 属性:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jack = User(name = <span class="string">"Jack"</span>, age = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br><span class="line">    println(jack)</span><br><span class="line">    println(olderJack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User(name=Jack, age=<span class="number">1</span>)</span><br><span class="line">User(name=Jack, age=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="数据类以及解构声明"><a href="#数据类以及解构声明" class="headerlink" title="数据类以及解构声明"></a>数据类以及解构声明</h3><p>组件函数允许数据类在解构声明中使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jane = User(<span class="string">"Jane"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="keyword">val</span> (name, age) = jane</span><br><span class="line">println(<span class="string">"<span class="variable">$name</span>, <span class="variable">$age</span> years of age"</span>) <span class="comment">// prints "Jane, 35 years of age"</span></span><br></pre></td></tr></table></figure><h3 id="标准数据类"><a href="#标准数据类" class="headerlink" title="标准数据类"></a>标准数据类</h3><p>标准库提供了 <strong>Pair</strong> 和 <strong>Triple</strong> 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。</p><hr><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。</p><p>声明一个密封类，使用 <strong>sealed</strong> 修饰类，密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。</p><p>sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用密封类的关键好处在于使用 when 表达式 的时候，如果能够 验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    Expr.NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// 不再需要 `else` 子句，因为我们已经覆盖了所有的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>我的理解密封类就是一种专门用来配合 when 语句使用的类，举个例子，假如在 Android 中我们有一个 view，我们现在想通过 when 语句设置针对 view 进行两种操作：显示和隐藏，那么就可以这样做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> Show: UiOp()</span><br><span class="line">    <span class="keyword">object</span> Hide: UiOp()</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(view: <span class="type">View</span>, op: <span class="type">UiOp</span>)</span></span> = <span class="keyword">when</span> (op) &#123;</span><br><span class="line">    UiOp.Show -&gt; view.visibility = View.VISIBLE</span><br><span class="line">    UiOp.Hide -&gt; view.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上功能其实完全可以用枚举实现，但是如果我们现在想加两个操作：水平平移和纵向平移，并且还要携带一些数据，比如平移了多少距离，平移过程的动画类型等数据，用枚举显然就不太好办了，这时密封类的优势就可以发挥了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> Show: UiOp()</span><br><span class="line">    <span class="keyword">object</span> Hide: UiOp()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TranslateX</span></span>(<span class="keyword">val</span> px: <span class="built_in">Float</span>): UiOp()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TranslateY</span></span>(<span class="keyword">val</span> px: <span class="built_in">Float</span>): UiOp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(view: <span class="type">View</span>, op: <span class="type">UiOp</span>)</span></span> = <span class="keyword">when</span> (op) &#123;</span><br><span class="line">    UiOp.Show -&gt; view.visibility = View.VISIBLE</span><br><span class="line">    UiOp.Hide -&gt; view.visibility = View.GONE</span><br><span class="line">    <span class="keyword">is</span> UiOp.TranslateX -&gt; view.translationX = op.px <span class="comment">// 这个 when 语句分支不仅告诉 view 要水平移动，还告诉 view 需要移动多少距离，这是枚举等 Java 传统思想不容易实现的</span></span><br><span class="line">    <span class="keyword">is</span> UiOp.TranslateY -&gt; view.translationY = op.px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，TranslateX 是一个类，它可以携带多于一个的信息，比如除了告诉 view 需要水平平移之外，还可以告诉 view 平移多少像素，甚至还可以告诉 view 平移的动画类型等信息，我想这大概就是密封类出现的意义吧。</p><p>除此之外，如果 when 语句的分支不需要携带除“显示或隐藏view之外的其它信息”时（即只需要表明 when 语句分支，不需要携带额外数据时），用 object 关键字创建单例就可以了，并且此时 when 子句不需要使用 is 关键字。只有需要携带额外信息时才定义密封类的子类，而且使用了密封类就不需要使用 else 子句，每当我们多增加一个密封类的子类或单例，编译器就会在 when 语句中给出提示，可以在编译阶段就及时发现错误，这也是以往 switch-case 语句和枚举不具备的功能。</p><p>最后，我们甚至可以把这一组操作封装成一个函数，以便日后调用，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先封装一个UI操作列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui</span></span>(<span class="keyword">val</span> uiOps: List = emptyList()) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(uiOp: <span class="type">UiOp</span>)</span></span> = Ui(uiOps + uiOp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一组操作</span></span><br><span class="line"><span class="keyword">val</span> ui = Ui() +</span><br><span class="line">        UiOp.Show +</span><br><span class="line">        UiOp.TranslateX(<span class="number">20</span>f) +</span><br><span class="line">        UiOp.TranslateY(<span class="number">40</span>f) +</span><br><span class="line">        UiOp.Hide</span><br><span class="line"><span class="comment">// 定义调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">(view: <span class="type">View</span>, ui: <span class="type">Ui</span>)</span></span> &#123;</span><br><span class="line">    ui.uiOps.forEach &#123; execute(view, it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(view, ui) <span class="comment">// 最终调用</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据类&quot;&gt;&lt;a href=&quot;#数据类&quot; class=&quot;headerlink&quot; title=&quot;数据类&quot;&gt;&lt;/a&gt;数据类&lt;/h2&gt;&lt;p&gt;Kotlin 可以创建一个只包含数据的类，关键字为 &lt;strong&gt;data&lt;/strong&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name: String, &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; age: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals()&lt;/code&gt; / &lt;code&gt;hashCode()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toString()&lt;/code&gt; 格式如 &lt;code&gt;&amp;quot;User(name=John, age=42)&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;componentN() functions&lt;/code&gt; 对应于属性，按声明顺序排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy()&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。&lt;/p&gt;
&lt;p&gt;为了保证生成代码的一致性以及有意义，数据类需要满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主构造函数至少包含一个参数。&lt;/li&gt;
&lt;li&gt;所有的主构造函数的参数必须标识为&lt;code&gt;val&lt;/code&gt; 或者 &lt;code&gt;var&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;数据类不可以声明为 &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;sealed&lt;/code&gt; 或者 &lt;code&gt;inner&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;数据类不能继承其他类 (但是可以实现接口)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;复制&quot;&gt;&lt;a href=&quot;#复制&quot; class=&quot;headerlink&quot; title=&quot;复制&quot;&gt;&lt;/a&gt;复制&lt;/h3&gt;&lt;p&gt;复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; = this.name, age: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; = this.age)&lt;/span&gt;&lt;/span&gt; = User(name, age)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h3&gt;&lt;p&gt;使用 copy 类复制 User 数据类，并修改 age 属性:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name: String, &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; age: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; jack = User(name = &lt;span class=&quot;string&quot;&gt;&quot;Jack&quot;&lt;/span&gt;, age = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; olderJack = jack.copy(age = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(jack)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(olderJack)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;User(name=Jack, age=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;User(name=Jack, age=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin扩展</title>
    <link href="https://zhangmiao.cc/posts/36cafa9f.html"/>
    <id>https://zhangmiao.cc/posts/36cafa9f.html</id>
    <published>2020-09-18T06:45:30.000Z</published>
    <updated>2020-09-18T06:48:58.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-扩展"><a href="#Kotlin-扩展" class="headerlink" title="Kotlin 扩展"></a>Kotlin 扩展</h1><p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。</p><p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p><hr><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> receiverType.<span class="title">functionName</span><span class="params">(params)</span></span>&#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>receiverType：表示函数的接收者，也就是函数扩展的对象</li><li>functionName：扩展函数的名称</li><li>params：扩展函数的参数，可以为NULL</li></ul><p>以下实例扩展 User 类 ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**扩展函数**/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(<span class="string">"用户名 <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = User(<span class="string">"Runoob"</span>)</span><br><span class="line">    user.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名 Runoob</span><br></pre></td></tr></table></figure><p>下面代码为 MutableList 添加一个swap 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展函数 swap,调换不同位置的值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1]     <span class="comment">//  this 对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> l = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 位置 0 和 2 的值做了互换</span></span><br><span class="line">    l.swap(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">// 'swap()' 函数内的 'this' 将指向 'l' 的值</span></span><br><span class="line"></span><br><span class="line">    println(l.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>this关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。</p><hr><a id="more"></a><h2 id="扩展函数是静态解析的"><a href="#扩展函数是静态解析的" class="headerlink" title="扩展函数是静态解析的"></a>扩展函数是静态解析的</h2><p>扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span>   <span class="comment">// 扩展函数 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span>   <span class="comment">// 扩展函数 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">    println(c.foo())  <span class="comment">// 类型是 C 类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    printFoo(D())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure><p>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"成员函数"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"扩展函数"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = C()</span><br><span class="line">    c.foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成员函数</span><br></pre></td></tr></table></figure><h3 id="扩展一个空对象"><a href="#扩展一个空对象" class="headerlink" title="扩展一个空对象"></a>扩展一个空对象</h3><p>在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="comment">// 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()</span></span><br><span class="line">    <span class="comment">// 解析为 Any 类的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="literal">null</span></span><br><span class="line">    println(t.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><hr><p>扩展属性</p><p>除了函数，Kotlin 也支持属性对属性进行扩展:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span> <span class="comment">// 错误：扩展属性不能有初始化器</span></span><br></pre></td></tr></table></figure><p>扩展属性只能被声明为 val。</p><hr><h2 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h2><p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。</p><p>伴生对象通过”类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;  <span class="comment">// 将被称为 "Companion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"伴随对象的扩展函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> MyClass.Companion.no: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"no:<span class="subst">$&#123;MyClass.no&#125;</span>"</span>)</span><br><span class="line">    MyClass.foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">no:<span class="number">10</span></span><br><span class="line">伴随对象的扩展函数</span><br></pre></td></tr></table></figure><hr><h2 id="扩展的作用域"><a href="#扩展的作用域" class="headerlink" title="扩展的作用域"></a>扩展的作用域</h2><p>通常扩展函数或属性定义在顶级包下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Baz.<span class="title">goo</span><span class="params">()</span></span> &#123; …… &#125;</span><br></pre></td></tr></table></figure><p>要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.usage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.bar.goo <span class="comment">// 导入所有名为 goo 的扩展</span></span><br><span class="line">                   <span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> foo.bar.*   <span class="comment">// 从 foo.bar 导入一切</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">usage</span><span class="params">(baz: <span class="type">Baz</span>)</span></span> &#123;</span><br><span class="line">    baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="扩展声明为成员"><a href="#扩展声明为成员" class="headerlink" title="扩展声明为成员"></a>扩展声明为成员</h2><p>在一个类内部你可以为另一个类声明扩展。</p><p>在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"D bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123; println(<span class="string">"C baz"</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar()   <span class="comment">// 调用 D.bar</span></span><br><span class="line">        baz()   <span class="comment">// 调用 C.baz</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: C = C()</span><br><span class="line">    <span class="keyword">val</span> d: D = D()</span><br><span class="line">    c.caller(d)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D bar</span><br><span class="line">C baz</span><br></pre></td></tr></table></figure><p>在 C 类内，创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。</p><p>假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"D bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"C bar"</span>) &#125;  <span class="comment">// 与 D 类 的 bar 同名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar()         <span class="comment">// 调用 D.bar()，扩展接收者优先</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@C</span>.bar()  <span class="comment">// 调用 C.bar()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: C = C()</span><br><span class="line">    <span class="keyword">val</span> d: D = D()</span><br><span class="line">    c.caller(d)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D bar</span><br><span class="line">C bar</span><br></pre></td></tr></table></figure><p>以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> : <span class="type">D</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> : <span class="type">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    C().caller(D())   <span class="comment">// 输出 "D.foo in C"</span></span><br><span class="line">    C1().caller(D())  <span class="comment">// 输出 "D.foo in C1" —— 分发接收者虚拟解析</span></span><br><span class="line">    C().caller(D1())  <span class="comment">// 输出 "D.foo in C" —— 扩展接收者静态解析</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D.foo <span class="keyword">in</span> C</span><br><span class="line">D.foo <span class="keyword">in</span> C1</span><br><span class="line">D.foo <span class="keyword">in</span> C</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-扩展&quot;&gt;&lt;a href=&quot;#Kotlin-扩展&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 扩展&quot;&gt;&lt;/a&gt;Kotlin 扩展&lt;/h1&gt;&lt;p&gt;Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。&lt;/p&gt;
&lt;p&gt;扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;扩展函数&quot;&gt;&lt;a href=&quot;#扩展函数&quot; class=&quot;headerlink&quot; title=&quot;扩展函数&quot;&gt;&lt;/a&gt;扩展函数&lt;/h2&gt;&lt;p&gt;扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; receiverType.&lt;span class=&quot;title&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(params)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;receiverType：表示函数的接收者，也就是函数扩展的对象&lt;/li&gt;
&lt;li&gt;functionName：扩展函数的名称&lt;/li&gt;
&lt;li&gt;params：扩展函数的参数，可以为NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下实例扩展 User 类 ：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name:String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**扩展函数**/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; User.&lt;span class=&quot;title&quot;&gt;Print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;用户名 &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg:&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; user = User(&lt;span class=&quot;string&quot;&gt;&quot;Runoob&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    user.Print()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;实例执行输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;用户名 Runoob&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;下面代码为 MutableList 添加一个swap 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 扩展函数 swap,调换不同位置的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; MutableList&lt;span class=&quot;type&quot;&gt;&amp;lt;Int&amp;gt;&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(index1: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, index2: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; tmp = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index1]     &lt;span class=&quot;comment&quot;&gt;//  this 对应该列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index1] = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index2] = tmp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; l = mutableListOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 位置 0 和 2 的值做了互换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    l.swap(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// &#39;swap()&#39; 函数内的 &#39;this&#39; 将指向 &#39;l&#39; 的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(l.toString())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;实例执行输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;this关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin接口</title>
    <link href="https://zhangmiao.cc/posts/404317d3.html"/>
    <id>https://zhangmiao.cc/posts/404317d3.html</id>
    <published>2020-09-18T06:38:03.000Z</published>
    <updated>2020-09-18T06:43:08.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-接口"><a href="#Kotlin-接口" class="headerlink" title="Kotlin 接口"></a>Kotlin 接口</h1><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>    <span class="comment">// 未实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;  <span class="comment">//已实现</span></span><br><span class="line">      <span class="comment">// 可选的方法体</span></span><br><span class="line">      println(<span class="string">"foo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类或者对象可以实现一个或多个接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可选的方法体</span></span><br><span class="line">        println(<span class="string">"foo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">        println(<span class="string">"bar"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c =  Child()</span><br><span class="line">    c.foo();</span><br><span class="line">    c.bar();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h3><p>接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="comment">//name 属性, 抽象的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImpl</span>:<span class="type">MyInterface&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: String = <span class="string">"runoob"</span> <span class="comment">//重写属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="comment">//name 属性, 抽象的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可选的方法体</span></span><br><span class="line">        println(<span class="string">"foo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: String = <span class="string">"runoob"</span> <span class="comment">//重写属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">        println(<span class="string">"bar"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c =  Child()</span><br><span class="line">    c.foo();</span><br><span class="line">    c.bar();</span><br><span class="line">    println(c.name)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><hr><h2 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h2><p>实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如:</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;   <span class="comment">// 已实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>                  <span class="comment">// 未实现，没有方法体，是抽象的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125;   <span class="comment">// 已实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125; <span class="comment">// 已实现</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;   <span class="comment">// 重写</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">A</span>, <span class="type">B &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.foo()</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> d =  D()</span><br><span class="line">    d.foo();</span><br><span class="line">    d.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABbar</span><br></pre></td></tr></table></figure><p>实例中接口 A 和 B 都定义了方法 foo() 和 bar()， 两者都实现了 foo(), B 实现了 bar()。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。</p><p>然而，如果我们从 A 和 B 派生 D，我们需要实现多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则 既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-接口&quot;&gt;&lt;a href=&quot;#Kotlin-接口&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 接口&quot;&gt;&lt;/a&gt;Kotlin 接口&lt;/h1&gt;&lt;p&gt;Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;// 未实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;  &lt;span class=&quot;comment&quot;&gt;//已实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 可选的方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      println(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;实现接口&quot;&gt;&lt;a href=&quot;#实现接口&quot; class=&quot;headerlink&quot; title=&quot;实现接口&quot;&gt;&lt;/a&gt;实现接口&lt;/h3&gt;&lt;p&gt;一个类或者对象可以实现一个或多个接口。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;MyInterface &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 可选的方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;MyInterface &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; c =  Child()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c.foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c.bar();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin继承</title>
    <link href="https://zhangmiao.cc/posts/8ca7e9b.html"/>
    <id>https://zhangmiao.cc/posts/8ca7e9b.html</id>
    <published>2020-09-17T07:07:37.000Z</published>
    <updated>2020-09-17T07:22:56.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-继承"><a href="#Kotlin-继承" class="headerlink" title="Kotlin 继承"></a>Kotlin 继承</h1><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> // 从 <span class="title">Any</span> 隐式继承</span></span><br></pre></td></tr></table></figure><p>Any 默认提供了三个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">equals()</span><br><span class="line"></span><br><span class="line">hashCode()</span><br><span class="line"></span><br><span class="line">toString()</span><br></pre></td></tr></table></figure><p>注意：Any 不是 java.lang.Object。</p><p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)           <span class="comment">// 定义基类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="子类有主构造函数"><a href="#子类有主构造函数" class="headerlink" title="子类有主构造函数"></a>子类有主构造函数</h3><p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name : String, <span class="keyword">var</span> age : <span class="built_in">Int</span>)&#123;<span class="comment">// 基类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name : String, age : <span class="built_in">Int</span>, <span class="keyword">var</span> no : String, <span class="keyword">var</span> score : <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s =  Student(<span class="string">"Runoob"</span>, <span class="number">18</span>, <span class="string">"S12346"</span>, <span class="number">89</span>)</span><br><span class="line">    println(<span class="string">"学生名： <span class="subst">$&#123;s.name&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"年龄： <span class="subst">$&#123;s.age&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"学生号： <span class="subst">$&#123;s.no&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"成绩： <span class="subst">$&#123;s.score&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学生名： Runoob</span><br><span class="line">年龄： <span class="number">18</span></span><br><span class="line">学生号： S12346</span><br><span class="line">成绩： <span class="number">89</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="子类没有主构造函数"><a href="#子类没有主构造函数" class="headerlink" title="子类没有主构造函数"></a>子类没有主构造函数</h3><p>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx,attrs) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**用户基类**/</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name:String)&#123;</span><br><span class="line">    <span class="comment">/**次级构造函数**/</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        println(<span class="string">"-------基类次级构造函数---------"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**子类继承 Person 类**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:<span class="type">Person&#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**次级构造函数**/</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,no:String,score:<span class="built_in">Int</span>):<span class="keyword">super</span>(name,age)&#123;</span><br><span class="line">        println(<span class="string">"-------继承类次级构造函数---------"</span>)</span><br><span class="line">        println(<span class="string">"学生名： <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">        println(<span class="string">"年龄： <span class="subst">$&#123;age&#125;</span>"</span>)</span><br><span class="line">        println(<span class="string">"学生号： <span class="subst">$&#123;no&#125;</span>"</span>)</span><br><span class="line">        println(<span class="string">"成绩： <span class="subst">$&#123;score&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s =  Student(<span class="string">"Runoob"</span>, <span class="number">18</span>, <span class="string">"S12345"</span>, <span class="number">89</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-------基类次级构造函数---------</span><br><span class="line">-------继承类次级构造函数---------</span><br><span class="line">学生名： Runoob</span><br><span class="line">年龄： <span class="number">18</span></span><br><span class="line">学生号： S12345</span><br><span class="line">成绩： <span class="number">89</span></span><br></pre></td></tr></table></figure><hr><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**用户基类**/</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span>&#123;       <span class="comment">// 允许子类重写</span></span><br><span class="line">        println(<span class="string">"我毕业了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**子类继承 Person 类**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span>&#123;    <span class="comment">// 重写方法</span></span><br><span class="line">        println(<span class="string">"我在读大学"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s =  Student()</span><br><span class="line">    s.study();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我在读大学</span><br></pre></td></tr></table></figure><p>如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span> <span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123; print(<span class="string">"a"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125; <span class="comment">//接口的成员变量默认是 open 的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123; print(<span class="string">"b"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>() : A() , B&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.f()<span class="comment">//调用 A.f()</span></span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.f()<span class="comment">//调用 B.f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c =  C()</span><br><span class="line">    c.f();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。</p><p>输出结果为:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure><hr><h2 id="属性重写"><a href="#属性重写" class="headerlink" title="属性重写"></a>属性重写</h2><p>属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span> : <span class="type">Foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以用一个var属性重写一个val属性，但是反过来不行。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法</p><p>你可以在主构造函数中使用 override 关键字作为属性声明的一部分:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span>) : Foo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar2</span> : <span class="type">Foo &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-继承&quot;&gt;&lt;a href=&quot;#Kotlin-继承&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 继承&quot;&gt;&lt;/a&gt;Kotlin 继承&lt;/h1&gt;&lt;p&gt;Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt; // 从 &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt; 隐式继承&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Any 默认提供了三个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;equals()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hashCode()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意：Any 不是 java.lang.Object。&lt;/p&gt;
&lt;p&gt;如果一个类要被继承，可以使用 open 关键字进行修饰。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&lt;/span&gt;(p: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)           &lt;span class=&quot;comment&quot;&gt;// 定义基类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Derived&lt;/span&gt;&lt;/span&gt;(p: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) : Base(p)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;h3 id=&quot;子类有主构造函数&quot;&gt;&lt;a href=&quot;#子类有主构造函数&quot; class=&quot;headerlink&quot; title=&quot;子类有主构造函数&quot;&gt;&lt;/a&gt;子类有主构造函数&lt;/h3&gt;&lt;p&gt;如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name : String, &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; age : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)&amp;#123;&lt;span class=&quot;comment&quot;&gt;// 基类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student&lt;/span&gt;&lt;/span&gt;(name : String, age : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; no : String, &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; score : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) : Person(name, age) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 测试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; s =  Student(&lt;span class=&quot;string&quot;&gt;&quot;Runoob&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;S12346&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;学生名： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.name&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;年龄： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.age&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;学生号： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.no&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;成绩： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.score&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;学生名： Runoob&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;年龄： &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;学生号： S12346&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;成绩： &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin类和对象</title>
    <link href="https://zhangmiao.cc/posts/e6f2df3b.html"/>
    <id>https://zhangmiao.cc/posts/e6f2df3b.html</id>
    <published>2020-09-17T06:41:27.000Z</published>
    <updated>2020-09-17T07:05:47.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。</p><p>Kotlin 中使用关键字 <strong>class</strong> 声明类，后面紧跟类名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;  <span class="comment">// 类名为 Runoob</span></span><br><span class="line">    <span class="comment">// 大括号内是类体构成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以定义一个空类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br></pre></td></tr></table></figure><p>可以在类中定义成员函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"Foo"</span>) &#125; <span class="comment">// 成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h3><p>类的属性可以用关键字 <strong>var</strong> 声明为可变的，否则使用只读关键字 <strong>val</strong> 声明为不可变。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = ……</span><br><span class="line">    <span class="keyword">var</span> url: String = ……</span><br><span class="line">    <span class="keyword">var</span> city: String = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以像使用普通函数那样使用构造函数创建类实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字</span></span><br></pre></td></tr></table></figure><p>要使用一个属性，只要用名称引用它即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site.name           <span class="comment">// 使用 . 号来引用</span></span><br><span class="line">site.url</span><br></pre></td></tr></table></figure><p>Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><p>属性声明的完整语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><p>getter 和 setter 都是可选</p><p>如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allByDefault: <span class="built_in">Int</span>? <span class="comment">// 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法</span></span><br><span class="line"><span class="keyword">var</span> initialized = <span class="number">1</span>    <span class="comment">// 类型为 Int, 默认实现了 getter 和 setter</span></span><br><span class="line"><span class="keyword">val</span> simple: <span class="built_in">Int</span>?       <span class="comment">// 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化</span></span><br><span class="line"><span class="keyword">val</span> inferredType = <span class="number">1</span>   <span class="comment">// 类型为 Int 类型,默认实现 getter</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例定义了一个 Person 类，包含两个可变变量 lastName 和 no，lastName 修改了 getter 方法，no 修改了 setter 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">"zhang"</span></span><br><span class="line">        <span class="keyword">get</span>() = field.toUpperCase()   <span class="comment">// 将变量赋值后转换为大写</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">        <span class="keyword">get</span>() = field                <span class="comment">// 后端变量</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">                field = value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                field = <span class="number">-1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> heiht: <span class="built_in">Float</span> = <span class="number">145.4</span>f</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person: Person = Person()</span><br><span class="line"></span><br><span class="line">    person.lastName = <span class="string">"wang"</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">"lastName:<span class="subst">$&#123;person.lastName&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    person.no = <span class="number">9</span></span><br><span class="line">    println(<span class="string">"no:<span class="subst">$&#123;person.no&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    person.no = <span class="number">20</span></span><br><span class="line">    println(<span class="string">"no:<span class="subst">$&#123;person.no&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lastName:WANG</span><br><span class="line">no:<span class="number">9</span></span><br><span class="line">no:<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>Kotlin 中类不能有字段。提供了 Backing Fields(后端变量) 机制,备用字段使用field关键字声明,field 关键词只能用于属性的访问器，如以上实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">        <span class="keyword">get</span>() = field                <span class="comment">// 后端变量</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">                field = value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                field = <span class="number">-1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>非空属性必须在定义的时候初始化,kotlin提供了一种可以延迟初始化的方案,使用 <strong>lateinit</strong> 关键字描述属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject = TestSubject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.method()  <span class="comment">// dereference directly</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h2><p>主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"FirstName is <span class="variable">$firstName</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：主构造器的参数可以在初始化代码段中使用，也可以在类主体n定义的属性初始化代码中使用。 一种简洁语法，可以通过主构造器来定义属性并初始化属性值（可以是var或val）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>创建一个 Runoob类，并通过构造函数传入网站名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>  <span class="keyword">constructor</span></span>(name: String) &#123;  <span class="comment">// 类名为 Runoob</span></span><br><span class="line">    <span class="comment">// 大括号内是类体构成</span></span><br><span class="line">    <span class="keyword">var</span> url: String = <span class="string">"http://www.runoob.com"</span></span><br><span class="line">    <span class="keyword">var</span> country: String = <span class="string">"CN"</span></span><br><span class="line">    <span class="keyword">var</span> siteName = name</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"初始化网站名: <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"我是类的函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runoob =  Runoob(<span class="string">"菜鸟教程"</span>)</span><br><span class="line">    println(runoob.siteName)</span><br><span class="line">    println(runoob.url)</span><br><span class="line">    println(runoob.country)</span><br><span class="line">    runoob.printTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化网站名: 菜鸟教程</span><br><span class="line">菜鸟教程</span><br><span class="line">http:<span class="comment">//www.runoob.com</span></span><br><span class="line">CN</span><br><span class="line">我是类的函数</span><br></pre></td></tr></table></figure><hr><h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>类也可以有二级构造函数，需要加前缀 constructor:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name: String, age:<span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="comment">// 初始化...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontCreateMe</span> <span class="keyword">private</span> <span class="keyword">constructor</span> </span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> customerName: String = <span class="string">""</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>  <span class="keyword">constructor</span></span>(name: String) &#123;  <span class="comment">// 类名为 Runoob</span></span><br><span class="line">    <span class="comment">// 大括号内是类体构成</span></span><br><span class="line">    <span class="keyword">var</span> url: String = <span class="string">"http://www.runoob.com"</span></span><br><span class="line">    <span class="keyword">var</span> country: String = <span class="string">"CN"</span></span><br><span class="line">    <span class="keyword">var</span> siteName = name</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"初始化网站名: <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 次构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span> (name: String, alexa: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        println(<span class="string">"Alexa 排名 <span class="variable">$alexa</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"我是类的函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runoob =  Runoob(<span class="string">"菜鸟教程"</span>, <span class="number">10000</span>)</span><br><span class="line">    println(runoob.siteName)</span><br><span class="line">    println(runoob.url)</span><br><span class="line">    println(runoob.country)</span><br><span class="line">    runoob.printTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化网站名: 菜鸟教程</span><br><span class="line">Alexa 排名 <span class="number">10000</span></span><br><span class="line">菜鸟教程</span><br><span class="line">http:<span class="comment">//www.runoob.com</span></span><br><span class="line">CN</span><br><span class="line">我是类的函数</span><br></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。</p><p>注意：无需对抽象类或抽象成员标注open注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>我们可以把类嵌套在其他类中，看以下实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;                  <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;             <span class="comment">// 嵌套类</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer.Nested().foo() <span class="comment">// 调用格式：外部类.嵌套类.嵌套类方法/属性</span></span><br><span class="line">    println(demo)    <span class="comment">// == 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类使用 <code>inner</code> 关键字来表示。</p><p>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"成员属性"</span></span><br><span class="line">    <span class="comment">/**嵌套内部类**/</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">innerTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> o = <span class="keyword">this</span><span class="symbol">@Outer</span> <span class="comment">//获取外部类的成员变量</span></span><br><span class="line">            println(<span class="string">"内部类可以引用外部类的成员，例如："</span> + o.v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer().Inner().foo()</span><br><span class="line">    println(demo) <span class="comment">//   1</span></span><br><span class="line">    <span class="keyword">val</span> demo2 = Outer().Inner().innerTest()   </span><br><span class="line">    println(demo2)   <span class="comment">// 内部类可以引用外部类的成员，例如：成员属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label 是一个 代指 this 来源的标签。</p><hr><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用对象表达式来创建匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"成员属性"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setInterFace</span><span class="params">(test: <span class="type">TestInterFace</span>)</span></span> &#123;</span><br><span class="line">        test.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestInterFace</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> test = Test()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用对象表达式来创建接口对象，即匿名内部类的实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    test.setInterFace(<span class="keyword">object</span> : TestInterFace &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"对象表达式创建匿名内部类的实例"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>类的修饰符包括 classModifier 和<em>accessModifier</em>:</p><ul><li><p>classModifier: 类属性修饰符，标示类本身特性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>    <span class="comment">// 抽象类  </span></span><br><span class="line"><span class="keyword">final</span>       <span class="comment">// 类不可继承，默认属性</span></span><br><span class="line"><span class="keyword">enum</span>        <span class="comment">// 枚举类</span></span><br><span class="line"><span class="keyword">open</span>        <span class="comment">// 类可继承，类默认是final的</span></span><br><span class="line"><span class="keyword">annotation</span>  <span class="comment">// 注解类</span></span><br></pre></td></tr></table></figure></li><li><p>accessModifier: 访问权限修饰符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>    <span class="comment">// 仅在同一个文件中可见</span></span><br><span class="line"><span class="keyword">protected</span>  <span class="comment">// 同一个文件中或子类可见</span></span><br><span class="line"><span class="keyword">public</span>     <span class="comment">// 所有调用的地方都可见</span></span><br><span class="line"><span class="keyword">internal</span>   <span class="comment">// 同一个模块中可见</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：example.kt</span></span><br><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 在 example.kt 内可见</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// 该属性随处可见</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span>    <span class="comment">// 相同模块内可见</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; title=&quot;类定义&quot;&gt;&lt;/a&gt;类定义&lt;/h2&gt;&lt;p&gt;Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。&lt;/p&gt;
&lt;p&gt;Kotlin 中使用关键字 &lt;strong&gt;class&lt;/strong&gt; 声明类，后面紧跟类名：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runoob&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;span class=&quot;comment&quot;&gt;// 类名为 Runoob&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 大括号内是类体构成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们也可以定义一个空类：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Empty&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以在类中定义成员函数：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runoob&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123; print(&lt;span class=&quot;string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;) &amp;#125; &lt;span class=&quot;comment&quot;&gt;// 成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&quot;类的属性&quot;&gt;&lt;a href=&quot;#类的属性&quot; class=&quot;headerlink&quot; title=&quot;类的属性&quot;&gt;&lt;/a&gt;类的属性&lt;/h2&gt;&lt;h3 id=&quot;属性定义&quot;&gt;&lt;a href=&quot;#属性定义&quot; class=&quot;headerlink&quot; title=&quot;属性定义&quot;&gt;&lt;/a&gt;属性定义&lt;/h3&gt;&lt;p&gt;类的属性可以用关键字 &lt;strong&gt;var&lt;/strong&gt; 声明为可变的，否则使用只读关键字 &lt;strong&gt;val&lt;/strong&gt; 声明为不可变。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runoob&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: String = ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; url: String = ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; city: String = ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们可以像使用普通函数那样使用构造函数创建类实例：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; site = Runoob() &lt;span class=&quot;comment&quot;&gt;// Kotlin 中没有 new 关键字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要使用一个属性，只要用名称引用它即可&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;site.name           &lt;span class=&quot;comment&quot;&gt;// 使用 . 号来引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;site.url&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;&lt;/span&gt;(firstName: String) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;(firstName: String) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin循环控制</title>
    <link href="https://zhangmiao.cc/posts/e596bfcf.html"/>
    <id>https://zhangmiao.cc/posts/e596bfcf.html</id>
    <published>2020-09-16T06:17:46.000Z</published>
    <updated>2020-09-16T06:21:05.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><p>for 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</span><br></pre></td></tr></table></figure><p>循环体可以是一个代码块:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item: <span class="built_in">Int</span> <span class="keyword">in</span> ints) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，for 可以循环遍历任何提供了迭代器的对象。</p><p>如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    print(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。</p><p>或者你可以用库函数 withIndex：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>对集合进行迭代：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> items = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>)</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> items.indices) &#123;</span><br><span class="line">        println(<span class="string">"item at <span class="variable">$index</span> is <span class="subst">$&#123;items[index]&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">kiwi</span><br><span class="line">item at <span class="number">0</span> <span class="keyword">is</span> apple</span><br><span class="line">item at <span class="number">1</span> <span class="keyword">is</span> banana</span><br><span class="line">item at <span class="number">2</span> <span class="keyword">is</span> kiwi</span><br></pre></td></tr></table></figure><hr><h2 id="while-与-do…while-循环"><a href="#while-与-do…while-循环" class="headerlink" title="while 与 do…while 循环"></a>while 与 do…while 循环</h2><p>while是最基本的循环，它的结构为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">  <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"----while 使用-----"</span>)</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        println( x--)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"----do...while 使用-----"</span>)</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">5</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        println(y--)</span><br><span class="line">    &#125; <span class="keyword">while</span>(y&gt;<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">----<span class="keyword">do</span>...<span class="keyword">while</span> 使用-----</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h2><p>Kotlin 有三种结构化跳转表达式：</p><ul><li><em>return</em>。默认从最直接包围它的函数或者匿名函数返回。</li><li><em>break</em>。终止最直接包围它的循环。</li><li><em>continue</em>。继续下一次最直接包围它的循环。</li></ul><p>在循环中 Kotlin 支持传统的 break 和 continue 操作符。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">3</span>) <span class="keyword">continue</span>  <span class="comment">// i 为 3 时跳过当前循环，继续下一次循环</span></span><br><span class="line">        println(i)</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">5</span>) <span class="keyword">break</span>   <span class="comment">// i 为 6 时 跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Break-和-Continue-标签"><a href="#Break-和-Continue-标签" class="headerlink" title="Break 和 Continue 标签"></a>Break 和 Continue 标签</h3><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以用标签限制 break 或者continue：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。</p><h3 id="标签处返回"><a href="#标签处返回" class="headerlink" title="标签处返回"></a>标签处返回</h3><p>Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach <span class="symbol">lit@</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@lit</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun foo() &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        if (it == 0) return@forEach</span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        print(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当要返一个回值的时候，解析器优先选用标签限制的 return，即</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="symbol">@a</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>意为”从标签 @a 返回 1”，而不是”返回一个标签标注的表达式 (@a 1)”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;For-循环&quot;&gt;&lt;a href=&quot;#For-循环&quot; class=&quot;headerlink&quot; title=&quot;For 循环&quot;&gt;&lt;/a&gt;For 循环&lt;/h2&gt;&lt;p&gt;for 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; collection) print(item)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;循环体可以是一个代码块:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (item: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; ints) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ……&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如上所述，for 可以循环遍历任何提供了迭代器的对象。&lt;/p&gt;
&lt;p&gt;如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array.indices) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(array[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。&lt;/p&gt;
&lt;p&gt;或者你可以用库函数 withIndex：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ((index, value) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array.withIndex()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;the element at &lt;span class=&quot;variable&quot;&gt;$index&lt;/span&gt; is &lt;span class=&quot;variable&quot;&gt;$value&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin条件控制</title>
    <link href="https://zhangmiao.cc/posts/7370c7df.html"/>
    <id>https://zhangmiao.cc/posts/7370c7df.html</id>
    <published>2020-09-16T06:13:01.000Z</published>
    <updated>2020-09-16T06:16:21.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IF-表达式"><a href="#IF-表达式" class="headerlink" title="IF 表达式"></a>IF 表达式</h2><p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统用法</span></span><br><span class="line"><span class="keyword">var</span> max = a </span><br><span class="line"><span class="keyword">if</span> (a &lt; b) max = b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 else </span></span><br><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    max = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 作为表达式</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>我们也可以把 IF 表达式的结果赋值给一个变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">"Choose a"</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"Choose b"</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (condition) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        println(<span class="string">"x 大于 0"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">        println(<span class="string">"x 等于 0"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        println(<span class="string">"x 小于 0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> c = <span class="keyword">if</span> (a&gt;=b) a <span class="keyword">else</span> b</span><br><span class="line">    println(<span class="string">"c 的值为 <span class="variable">$c</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x 等于 <span class="number">0</span></span><br><span class="line">c 的值为 <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="使用区间"><a href="#使用区间" class="headerlink" title="使用区间"></a>使用区间</h3><p>使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 <strong>x..y</strong> ：</p><p>实例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">val</span> y = <span class="number">9</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.8</span>) &#123;</span><br><span class="line">        println(<span class="string">"x 在区间内"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 在区间内</span><br></pre></td></tr></table></figure><hr><h2 id="When-表达式"><a href="#When-表达式" class="headerlink" title="When 表达式"></a>When 表达式</h2><p>when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。</p><p>when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。</p><p>when 类似其他语言的 switch 操作符。其最简单的形式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">"x 不是 1 ，也不是 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支。</p><p>如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10.</span><span class="number">.20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPrefix</span><span class="params">(x: <span class="type">Any</span>)</span></span> = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span> -&gt; println(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"otherwise"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; println(<span class="string">"x == 1"</span>)</span><br><span class="line">        <span class="number">2</span> -&gt; println(<span class="string">"x == 2"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">            println(<span class="string">"x 不是 1 ，也不是 2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span> -&gt; println(<span class="string">"x 在该区间范围内"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"x 不在该区间范围内"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x == <span class="number">0</span> or x == <span class="number">1</span></span><br><span class="line">x 不是 <span class="number">1</span> ，也不是 <span class="number">2</span></span><br><span class="line">x 在该区间范围内</span><br></pre></td></tr></table></figure><p>when 中使用 <strong>in</strong> 运算符来判断集合内是否包含某实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> items = setOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>)</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        <span class="string">"orange"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"juicy"</span>)</span><br><span class="line">        <span class="string">"apple"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"apple is fine too"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apple <span class="keyword">is</span> fine too</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IF-表达式&quot;&gt;&lt;a href=&quot;#IF-表达式&quot; class=&quot;headerlink&quot; title=&quot;IF 表达式&quot;&gt;&lt;/a&gt;IF 表达式&lt;/h2&gt;&lt;p&gt;一个 if 语句包含一个布尔表达式和一条或多条语句。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 传统用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; max = a &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;lt; b) max = b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 else &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; max: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;gt; b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    max = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    max = b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 作为表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; max = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;gt; b) a &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们也可以把 IF 表达式的结果赋值给一个变量。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; max = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;gt; b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;Choose a&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;Choose b&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; c = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (condition) a &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android_Material组件使用详解</title>
    <link href="https://zhangmiao.cc/posts/389c1508.html"/>
    <id>https://zhangmiao.cc/posts/389c1508.html</id>
    <published>2020-09-11T02:34:32.000Z</published>
    <updated>2020-09-12T02:34:21.619Z</updated>
    
    <content type="html"><![CDATA[<p>Android官方为开发者提供了许多丰富的UI控件，Material 组件就是包含了这些控件的一套工具，多数时候使用它可以满足我们日常开发UI的需求，提高效率。目前Android Material 组件已经更新了1.2.0稳定版，赶紧来了解一波。</p><p>导入依赖，就可以开始了。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.android.material:material:1.2.0'</span></span><br></pre></td></tr></table></figure><h2 id="MaterialButton"><a href="#MaterialButton" class="headerlink" title="MaterialButton"></a>MaterialButton</h2><p>我们平时写布局，当遇到按钮需要圆角、或者描边等，通常的方法是新建一个xml文件，在shape标签下写，然后通过android:background或setBackground(drawable)设置。</p><p>这本来没什么问题，但是UI设计师会喜欢看起来和别人不一样的效果，也许是为了审（zhuang）美（bi），例如这个页面用4dp的圆角，那个页面用10dp的圆角，要有描边，颜色还不太一样……如果我们每个界面都新建个xml写shape，那么后期项目大了，维护起来就像无底洞……</p><p>那么有没有这样一个控件，能在xml直接配置圆角、描边属性，满足平时开发的基本UI需求？当然有，GitHub上第三方的库大把。不过Google官方在SDK28的时候也推出了一个新控件 —— MaterialButton，但是我发现很多人还不知道，今天就来安利下。</p><p>先来看一波效果图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105633.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105706.png" alt></p><a id="more"></a><p>按压水波纹，支持设置波纹颜色。</p><p>MaterialButton继承AppCompatButton，在原来Button的基础上做了一些扩展，如圆角、描边、前置和后置icon（icon支持设置Size、Tint、Padding、Gravity等），还支持按压水波纹并且设置color，基本能满足日常的需求。</p><p>公开属性如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200912103257.png" alt></p><h2 id="关于background"><a href="#关于background" class="headerlink" title="关于background"></a><strong>关于background</strong></h2><p>在1.2版本以前，MaterialButton只能通过app:backgroundTint属性设置背景色，该属性接收color state list。不能通过android:background设置自定义drawable。</p><p>1.2版本后，官方已修复此问题。如果未设置自定义背景，则 MaterialShapeDrawable 仍将用作默认背景。</p><p>也就是说，如果按钮背景是纯色，可以通过app:backgroundTint指定；如果按钮背景是渐变色，则需要自己定义drawable，然后通过android:background设置。</p><p>注意：如果要使用android:background设置背景，则需要将backgroundTint设置为@empty，否则background不会生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">”@drawable/custom_background”</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:backgroundTint</span>=<span class="string">”@empty”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>指定@empty后，Android Studio会出现红色警告，可以正常运行，忽略就好。不过既然已经自定义drawable，就没必要使用MaterialButton，直接用普通的Button甚至用TextView就好了。</p><h2 id="关于insetTop、insetBottom"><a href="#关于insetTop、insetBottom" class="headerlink" title="关于insetTop、insetBottom"></a><strong>关于insetTop、insetBottom</strong></h2><p>看下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/btn1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"150dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>xml预览图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105730.png" alt></p><p>有没有感觉怪怪的？貌似button上下多了一个padding！咦！代码里面明明没有设置padding啊！</p><p>看了源码发现，MaterialButton默认在style指定了insetTop和insetBottom为6dp，使得height看起来并没有Button实际设置值一样高，可以在xml将MaterialButton的insetTop和insetBottom都设置为0dp，这样MaterialButton的高度就和实际设置的高度一致了。</p><h2 id="关于阴影"><a href="#关于阴影" class="headerlink" title="关于阴影"></a><strong>关于阴影</strong></h2><p>MD组件默认都是自带阴影的，MaterialButton也不例外。但是有时候我们并不想要按钮有阴影，那么这时候可以指定style为<br>style=”@style/Widget.MaterialComponents.Button.UnelevatedButton”，这样就能去掉阴影，让视图看起来扁平化。</p><h2 id="关于theme"><a href="#关于theme" class="headerlink" title="关于theme"></a><strong>关于theme</strong></h2><p>在MDC1.1.0以后，使用MaterialButton可能会出现闪退的问题，原因就是使用了MD控件，但是未将them设置为MaterialComponents。解决方法可以有几种：</p><p>先在style.xml自定义MaterialComponents_Theme</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"MaterialComponents_Theme"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">       <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法一：</strong><br>AndroidManifest里application节点下配置，作用域为整个应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        ...</span><br><span class="line">        android:theme=&quot;@style/MaterialComponents_Theme&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong><br>只在当前activity配置，作用域为当前activity</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/MaterialComponents_Theme"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法三：</strong><br>为每个在使用到MD控件的地方配置，作用域只针对当前控件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/Theme.MaterialComponents.Light.NoActionBar"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关于在Android-Studio中预览"><a href="#关于在Android-Studio中预览" class="headerlink" title="关于在Android Studio中预览"></a><strong>关于在Android Studio中预览</strong></h2><p>如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_send"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"@style/Widget.MaterialComponents.Button.UnelevatedButton"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"@dimen/dp_80"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"@dimen/dp_30"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">"@dimen/dp_12"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:insetTop</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:insetBottom</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/dispatch_room_text_upper_mic"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"@dimen/font_12"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:backgroundTint</span>=<span class="string">"@color/c_6D56FF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cornerRadius</span>=<span class="string">"@dimen/dp_15"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"@id/iv_head"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"@id/iv_head"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>xml预览</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105742.png" alt></p><p>可以看到xml预览效果和代码是不匹配的，这时候可以将预览的主题指定为MaterialComponents</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105759.png" alt></p><p>这样效果就和xml代码一致了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110109.png" alt></p><h2 id="ShapeableImageView"><a href="#ShapeableImageView" class="headerlink" title="ShapeableImageView"></a>ShapeableImageView</h2><p>来波效果图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110129.png" alt></p><p>以往我们实现图片圆角、描边等需求，多数时候是使用第三方或者自定义，Glide也有个扩展库，能很轻松帮我们实现。不过在MDC1.2.0中，已经有了一套官方的实现方案。那就是ShapeableImageView。</p><p>ShapeableImageView继承自ImageView，可以为image添加描边大小、颜色，以及圆角、裁切等，这得益于它新增了一个属性shapeAppearance，具体实现在ShapeAppearanceModel，可以通过style来配置，也可以通过代码实现。</p><h2 id="style配置："><a href="#style配置：" class="headerlink" title="style配置："></a><strong>style配置：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;StyleShapeAppearanceImage&quot; parent=&quot;&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;cornerFamily&quot;&gt;rounded&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;cornerSize&quot;&gt;16dp&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;cornerSizeTopRight&quot;&gt;10dp&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;cornerSizeBottomRight&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;com.google.android.material.imageview.ShapeableImageView</span><br><span class="line">    app:shapeAppearance=&quot;@style/StyleShapeAppearanceImage&quot;</span><br><span class="line">    ...</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><h2 id="代码设置："><a href="#代码设置：" class="headerlink" title="代码设置："></a><strong>代码设置：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">imageView?.shapeAppearanceModel = ShapeAppearanceModel.builder()</span><br><span class="line">            .setAllCorners(CornerFamily.ROUNDED,20f)</span><br><span class="line">            .setTopLeftCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setTopRightCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setBottomRightCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setBottomLeftCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setAllCornerSizes(ShapeAppearanceModel.PILL)</span><br><span class="line">            .setTopLeftCornerSize(20f)</span><br><span class="line">            .setTopRightCornerSize(RelativeCornerSize(0.5f))</span><br><span class="line">            .setBottomLeftCornerSize(10f)</span><br><span class="line">            .setBottomRightCornerSize(AbsoluteCornerSize(30f))</span><br><span class="line">            .build()</span><br></pre></td></tr></table></figure><p>代码接收一个ShapeAppearanceModel，通过构建者模式实现，setTopLeft表示处理左上角，其他同理。</p><p>cornerSize表示设置的大小，有RelativeCornerSize和AbsoluteCornerSize，RelativeCornerSize构造方法接收一个百分比，范围0-1；AbsoluteCornerSize构造方法接收一个具体数值，这个数值就是圆角的数值。</p><p>这里还有个CornerFamily，它表示处理的方式，有ROUNDED和CUT两种，ROUNDED是圆角，CUT是直接将圆角部分裁切掉。setAllCornerSizes(ShapeAppearanceModel.PILL)可以直接实现圆形效果。</p><h2 id="关于Stroke"><a href="#关于Stroke" class="headerlink" title="关于Stroke"></a><strong>关于Stroke</strong></h2><p>ShapeableImageView指定strokeWidth描边的时候，其描边会被覆盖掉一半，如strokeWidth=4dp，上下左右会被覆盖，实际的效果是只有2dp被显示。如图，</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110147.png" alt></p><p>github有人反馈了类似问题(<em><a href="https://github.com/material-components/material-components-android/issues/1489" target="_blank" rel="noopener">https://github.com/material-components/material-components-android/issues/1489</a></em>)，我的处理方法是在设置了strokeWidth的同时，设置相应的pading，这样描边就不会被覆盖了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.imageview.ShapeableImageView</span><br><span class="line">        ...</span><br><span class="line">        app:strokeWidth=&quot;4dp&quot;</span><br><span class="line">        android:padding=&quot;4dp&quot;</span><br></pre></td></tr></table></figure><h2 id="Slider-加强版的SeekBar"><a href="#Slider-加强版的SeekBar" class="headerlink" title="Slider(加强版的SeekBar)"></a>Slider(加强版的SeekBar)</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110158.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110241.png" alt></p><p>Slider的父类BaseSlider，直接继承View，重新实现逻辑。此外BaseSlider还有个子类RangeSlider，用它来实现图1效果2</p><p>Slider可以实现滑块头部数字变化效果，还可以实现类似刻度尺效果，比原生的SeekBar加强了不少。</p><p>常用属性如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200912103410.png" alt></p><p>其他属性还有haloColor、haloRadius、thumbColor等，用来配置一些外观</p><h2 id="BottomNavigationView"><a href="#BottomNavigationView" class="headerlink" title="BottomNavigationView"></a>BottomNavigationView</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110253.png" alt></p><p>BottomNavigationView相比之前要完善了很多，可以设置icon大小，添加红点和未读消息数，以及超过3个item，切换效果也不会出现问题，通过LabelVisibilityMode.LABEL_VISIBILITY_LABELED指定。</p><p>以上主要列举了几个常用的控件，基本可以满足一些UI开发了，更多关于MDC的内容，大家可以到github去了解</p><p>material-components-android：</p><blockquote><p><a href="https://github.com/material-components/material-components-android" target="_blank" rel="noopener">https://github.com/material-components/material-components-android</a></p></blockquote><p>参考文章：</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652063934&idx=1&sn=caeaec14e70b7569c06503b1bb04138b&scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PZD8RxrqP7_RAjXIo345aQ</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android官方为开发者提供了许多丰富的UI控件，Material 组件就是包含了这些控件的一套工具，多数时候使用它可以满足我们日常开发UI的需求，提高效率。目前Android Material 组件已经更新了1.2.0稳定版，赶紧来了解一波。&lt;/p&gt;
&lt;p&gt;导入依赖，就可以开始了。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;implementation &lt;span class=&quot;string&quot;&gt;&#39;com.google.android.material:material:1.2.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;MaterialButton&quot;&gt;&lt;a href=&quot;#MaterialButton&quot; class=&quot;headerlink&quot; title=&quot;MaterialButton&quot;&gt;&lt;/a&gt;MaterialButton&lt;/h2&gt;&lt;p&gt;我们平时写布局，当遇到按钮需要圆角、或者描边等，通常的方法是新建一个xml文件，在shape标签下写，然后通过android:background或setBackground(drawable)设置。&lt;/p&gt;
&lt;p&gt;这本来没什么问题，但是UI设计师会喜欢看起来和别人不一样的效果，也许是为了审（zhuang）美（bi），例如这个页面用4dp的圆角，那个页面用10dp的圆角，要有描边，颜色还不太一样……如果我们每个界面都新建个xml写shape，那么后期项目大了，维护起来就像无底洞……&lt;/p&gt;
&lt;p&gt;那么有没有这样一个控件，能在xml直接配置圆角、描边属性，满足平时开发的基本UI需求？当然有，GitHub上第三方的库大把。不过Google官方在SDK28的时候也推出了一个新控件 —— MaterialButton，但是我发现很多人还不知道，今天就来安利下。&lt;/p&gt;
&lt;p&gt;先来看一波效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105633.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105706.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基本数据类型</title>
    <link href="https://zhangmiao.cc/posts/83cba390.html"/>
    <id>https://zhangmiao.cc/posts/83cba390.html</id>
    <published>2020-09-08T03:50:03.000Z</published>
    <updated>2020-09-08T03:52:53.953Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。</p><table><thead><tr><th align="left">类型</th><th align="left">位宽度</th></tr></thead><tbody><tr><td align="left">Double</td><td align="left">64</td></tr><tr><td align="left">Float</td><td align="left">32</td></tr><tr><td align="left">Long</td><td align="left">64</td></tr><tr><td align="left">Int</td><td align="left">32</td></tr><tr><td align="left">Short</td><td align="left">16</td></tr><tr><td align="left">Byte</td><td align="left">8</td></tr></tbody></table><hr><h2 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h2><p>下面是所有类型的字面常量：</p><ul><li>十进制：123</li><li>长整型以大写的 L 结尾：123L</li><li>16 进制以 0x 开头：0x0F</li><li>2 进制以 0b 开头：0b00001011</li><li>注意：8进制不支持</li></ul><p>Kotlin 同时也支持传统符号表示的浮点数值：</p><ul><li>Doubles 默认写法: <code>123.5</code>, <code>123.5e10</code></li><li>Floats 使用 f 或者 F 后缀：<code>123.5f</code></li></ul><p>你可以使用下划线使数字常量更易读：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000</span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999</span>_99_9999L</span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF</span>_EC_DE_5E</span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0</span>b11010010_01101001_10010100_10010010</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h2><p>Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p><p>在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">    println(a === a) <span class="comment">// true，值相等，对象地址相等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过了装箱，创建了两个不同的对象</span></span><br><span class="line">    <span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虽然经过了装箱，但是值是相等的，都是10000</span></span><br><span class="line">    println(boxedA === anotherBoxedA) <span class="comment">//  false，值相等，对象地址不一样</span></span><br><span class="line">    println(boxedA == anotherBoxedA) <span class="comment">// true，值相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>我们可以代用其toInt()方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>每种数据类型都有下面的这些方法，可以转化为其它的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toByte(): <span class="built_in">Byte</span></span><br><span class="line">toShort(): <span class="built_in">Short</span></span><br><span class="line">toInt(): <span class="built_in">Int</span></span><br><span class="line">toLong(): <span class="built_in">Long</span></span><br><span class="line">toFloat(): <span class="built_in">Float</span></span><br><span class="line">toDouble(): <span class="built_in">Double</span></span><br><span class="line">toChar(): <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p>有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="number">1</span>L + <span class="number">3</span> <span class="comment">// Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure><hr><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>对于Int和Long类型，还有一系列的位操作符可以使用，分别是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shl(bits) – 左移位 (Java’s &lt;&lt;)</span><br><span class="line">shr(bits) – 右移位 (Java’s &gt;&gt;)</span><br><span class="line">ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</span><br><span class="line">and(bits) – 与</span><br><span class="line">or(bits) – 或</span><br><span class="line">xor(bits) – 异或</span><br><span class="line">inv() – 反向</span><br></pre></td></tr></table></figure><hr><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 <strong>‘</strong> 包含起来的。比如普通字符 ‘0’，’a’。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// 错误：类型不兼容</span></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\t、 \b、\n、\r、&#39;、&quot;、\ 和 $。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’。</p><p>我们可以显式把字符转换为 Int 数字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decimalDigitValue</span><span class="params">(c: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c !<span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Out of range"</span>)</span><br><span class="line">    <span class="keyword">return</span> c.toInt() - <span class="string">'0'</span>.toInt() <span class="comment">// 显式转换为数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。</p><hr><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>布尔用 Boolean 类型表示，它有两个值：true 和 false。</p><p>若需要可空引用布尔会被装箱。</p><p>内置的布尔运算有：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|| – 短路逻辑或</span><br><span class="line">&amp;&amp; – 短路逻辑与</span><br><span class="line">! - 逻辑非</span><br></pre></td></tr></table></figure><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。</p><p>数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//[1,2,3]</span></span><br><span class="line">    <span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//[0,2,4]</span></span><br><span class="line">    <span class="keyword">val</span> b = Array(<span class="number">3</span>, &#123; i -&gt; (i * <span class="number">2</span>) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数组内容</span></span><br><span class="line">    println(a[<span class="number">0</span>])    <span class="comment">// 输出结果：1</span></span><br><span class="line">    println(b[<span class="number">1</span>])    <span class="comment">// 输出结果：2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，[] 运算符代表调用成员函数 get() 和 set()。</p><p>注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。</p><p>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    println(text)   <span class="comment">// 输出有一些前置空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 可以通过 trimMargin() 方法来删除多余的空白。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |菜鸟教程</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |Runoob</span></span><br><span class="line"><span class="string">    """</span>.trimMargin()</span><br><span class="line">    println(text)    <span class="comment">// 前置空格删除了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。</p><hr><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"i = <span class="variable">$i</span>"</span> <span class="comment">// 求值结果为 "i = 10"</span></span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用花括号扩起来的任意表达式:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"runoob"</span></span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span> <span class="comment">// 求值结果为 "runoob.length is 6"</span></span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> price = <span class="string">"""</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    println(price)  <span class="comment">// 求值结果为 $9.99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;类型&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;位宽度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Double&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Float&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Long&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Int&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Short&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Byte&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&quot;字面常量&quot;&gt;&lt;a href=&quot;#字面常量&quot; class=&quot;headerlink&quot; title=&quot;字面常量&quot;&gt;&lt;/a&gt;字面常量&lt;/h2&gt;&lt;p&gt;下面是所有类型的字面常量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十进制：123&lt;/li&gt;
&lt;li&gt;长整型以大写的 L 结尾：123L&lt;/li&gt;
&lt;li&gt;16 进制以 0x 开头：0x0F&lt;/li&gt;
&lt;li&gt;2 进制以 0b 开头：0b00001011&lt;/li&gt;
&lt;li&gt;注意：8进制不支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kotlin 同时也支持传统符号表示的浮点数值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Doubles 默认写法: &lt;code&gt;123.5&lt;/code&gt;, &lt;code&gt;123.5e10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Floats 使用 f 或者 F 后缀：&lt;code&gt;123.5f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以使用下划线使数字常量更易读：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; oneMillion = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;_000_000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; creditCardNumber = &lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;_5678_9012_3456L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; socialSecurityNumber = &lt;span class=&quot;number&quot;&gt;999&lt;/span&gt;_99_9999L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; hexBytes = &lt;span class=&quot;number&quot;&gt;0xFF&lt;/span&gt;_EC_DE_5E&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; bytes = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;b11010010_01101001_10010100_10010010&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础语法</title>
    <link href="https://zhangmiao.cc/posts/a90cf00c.html"/>
    <id>https://zhangmiao.cc/posts/a90cf00c.html</id>
    <published>2020-08-31T06:10:48.000Z</published>
    <updated>2020-08-31T06:17:32.934Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 文件以 .kt 为后缀。</p><h2 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h2><p>代码文件的开头一般为包的声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。</p><p>以上例中 test() 的全名是 com.runoob.main.test、Runoob 的全名是 com.runoob.main.Runoob。</p><p>如果没有指定包，默认为 <strong>default</strong> 包。</p><h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>有多个包会默认导入到每个 Kotlin 文件中：</p><ul><li>kotlin.*</li><li>kotlin.annotation.*</li><li>kotlin.collections.*</li><li>kotlin.comparisons.*</li><li>kotlin.io.*</li><li>kotlin.ranges.*</li><li>kotlin.sequences.*</li><li>kotlin.text.*</li></ul><hr><a id="more"></a><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;   <span class="comment">// Int 参数，返回值 Int</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式作为函数体，返回类型自动推断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b   <span class="comment">// public 方法则必须明确写出返回类型</span></span><br></pre></td></tr></table></figure><p>无返回值的函数(类似Java中的void)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> &#123; </span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h3><p>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> v:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vt <span class="keyword">in</span> v)&#123;</span><br><span class="line">        print(vt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)  <span class="comment">// 输出12345</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h3><p>lambda表达式使用实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sumLambda: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x,y -&gt; x+y&#125;</span><br><span class="line">    println(sumLambda(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment">// 输出 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="定义常量与变量"><a href="#定义常量与变量" class="headerlink" title="定义常量与变量"></a>定义常量与变量</h2><p>可变变量定义：var 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure><p>不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure><p>常量与变量都可以没有初始化值,但是在引用前必须初始化</p><p>编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">1</span>       <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span>      <span class="comment">// 如果不在声明时初始化则必须提供变量类型</span></span><br><span class="line">c = <span class="number">1</span>           <span class="comment">// 明确赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>        <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line">x += <span class="number">1</span>           <span class="comment">// 变量可修改</span></span><br></pre></td></tr></table></figure><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Kotlin 支持单行和多行注释，实例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个多行的</span></span><br><span class="line"><span class="comment">   块注释。 */</span></span><br></pre></td></tr></table></figure><p>与 Java 不同, Kotlin 中的块注释允许嵌套。</p><hr><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>$ 表示一个变量名或者变量值</p><p>$varName 表示变量值</p><p>${varName.fun()} 表示变量的方法返回值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// 模板中的简单名称：</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">"a is <span class="variable">$a</span>"</span> </span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="comment">// 模板中的任意表达式：</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="string">"<span class="subst">$&#123;s1.replace("is", "was")&#125;</span>, but now is <span class="variable">$a</span>"</span></span><br></pre></td></tr></table></figure><hr><h2 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h2><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型后面加?表示可为空</span></span><br><span class="line"><span class="keyword">var</span> age: String? = <span class="string">"23"</span> </span><br><span class="line"><span class="comment">//抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。</p><p>当 str 中的字符串内容不是一个整数时, 返回 null:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例演示如何使用一个返回值可为 null 的函数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (args.size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    print(<span class="string">"Two integers expected"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> x = parseInt(args[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">val</span> y = parseInt(args[<span class="number">1</span>])</span><br><span class="line">  <span class="comment">// 直接使用 `x * y` 会导致错误, 因为它们可能为 null.</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; y != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量</span></span><br><span class="line">    print(x * y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类型检测及自动类型转换"><a href="#类型检测及自动类型转换" class="headerlink" title="类型检测及自动类型转换"></a>类型检测及自动类型转换</h2><p>我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    <span class="comment">// 做过类型判断以后，obj会被系统自动转换为String类型</span></span><br><span class="line">    <span class="keyword">return</span> obj.length </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在这里还有一种方法，与Java中instanceof不同，使用!is</span></span><br><span class="line">  <span class="comment">// if (obj !is String)&#123;</span></span><br><span class="line">  <span class="comment">//   // XXX</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的obj仍然是Any类型的引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj !<span class="keyword">is</span> String)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 在这个分支中, `obj` 的类型会被自动转换为 `String`</span></span><br><span class="line">  <span class="keyword">return</span> obj.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至还可以</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String`</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String &amp;&amp; obj.length &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> obj.length</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>区间表达式由具有操作符形式 <strong>..</strong> 的 rangeTo 函数辅以 in 和 !in 形成。</p><p>区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(i) <span class="comment">// 输出“1234”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4.</span><span class="number">.1</span>) print(i) <span class="comment">// 什么都不输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123; <span class="comment">// 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 step 指定步长</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“13”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“42”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 until 函数排除结束元素</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) &#123;   <span class="comment">// i in [1, 10) 排除了 10</span></span><br><span class="line">     println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"循环输出："</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(i) <span class="comment">// 输出“1234”</span></span><br><span class="line">    println(<span class="string">"\n----------------"</span>)</span><br><span class="line">    print(<span class="string">"设置步长："</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“13”</span></span><br><span class="line">    println(<span class="string">"\n----------------"</span>)</span><br><span class="line">    print(<span class="string">"使用 downTo："</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“42”</span></span><br><span class="line">    println(<span class="string">"\n----------------"</span>)</span><br><span class="line">    print(<span class="string">"使用 until："</span>)</span><br><span class="line">    <span class="comment">// 使用 until 函数排除结束元素</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">4</span>) &#123;   <span class="comment">// i in [1, 4) 排除了 4</span></span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"\n----------------"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">循环输出：<span class="number">1234</span></span><br><span class="line">----------------</span><br><span class="line">设置步长：<span class="number">13</span></span><br><span class="line">----------------</span><br><span class="line">使用 downTo：<span class="number">42</span></span><br><span class="line">----------------</span><br><span class="line">使用 <span class="keyword">until</span>：<span class="number">123</span></span><br><span class="line">----------------</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 文件以 .kt 为后缀。&lt;/p&gt;
&lt;h2 id=&quot;包声明&quot;&gt;&lt;a href=&quot;#包声明&quot; class=&quot;headerlink&quot; title=&quot;包声明&quot;&gt;&lt;/a&gt;包声明&lt;/h2&gt;&lt;p&gt;代码文件的开头一般为包的声明：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.runoob.main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runoob&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。&lt;/p&gt;
&lt;p&gt;以上例中 test() 的全名是 com.runoob.main.test、Runoob 的全名是 com.runoob.main.Runoob。&lt;/p&gt;
&lt;p&gt;如果没有指定包，默认为 &lt;strong&gt;default&lt;/strong&gt; 包。&lt;/p&gt;
&lt;h3 id=&quot;默认导入&quot;&gt;&lt;a href=&quot;#默认导入&quot; class=&quot;headerlink&quot; title=&quot;默认导入&quot;&gt;&lt;/a&gt;默认导入&lt;/h3&gt;&lt;p&gt;有多个包会默认导入到每个 Kotlin 文件中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kotlin.*&lt;/li&gt;
&lt;li&gt;kotlin.annotation.*&lt;/li&gt;
&lt;li&gt;kotlin.collections.*&lt;/li&gt;
&lt;li&gt;kotlin.comparisons.*&lt;/li&gt;
&lt;li&gt;kotlin.io.*&lt;/li&gt;
&lt;li&gt;kotlin.ranges.*&lt;/li&gt;
&lt;li&gt;kotlin.sequences.*&lt;/li&gt;
&lt;li&gt;kotlin.text.*&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin使用命令行编译</title>
    <link href="https://zhangmiao.cc/posts/c0feb7da.html"/>
    <id>https://zhangmiao.cc/posts/c0feb7da.html</id>
    <published>2020-08-29T03:13:08.000Z</published>
    <updated>2020-08-31T06:14:16.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-使用命令行编译"><a href="#Kotlin-使用命令行编译" class="headerlink" title="Kotlin 使用命令行编译"></a>Kotlin 使用命令行编译</h1><p>Kotlin 命令行编译工具下载地址：<a href="https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为" target="_blank" rel="noopener">https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为</a> 1.1.2-2。</p><p>你可以选择一个最新的稳定版下载。</p><p>下载完成后，解压到指定目录，然后将 <strong>bin</strong> 目录添加到系统环境变量。bin 目录包含编译和运行 Kotlin 所需的脚本。</p><hr><h2 id="SDKMAN"><a href="#SDKMAN" class="headerlink" title="SDKMAN!"></a>SDKMAN!</h2><p>在 OS X、Linux、Cygwin、FreeBSD 和 Solaris 系统上也可以使用更简单的安装方法，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s https://get.sdkman.io | bash</span><br><span class="line"></span><br><span class="line">$ sdk install kotlin</span><br></pre></td></tr></table></figure><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>在 OS X 下，你可以使用 Homebrew 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">$ brew install kotlin</span><br></pre></td></tr></table></figure><h3 id="MacPorts"><a href="#MacPorts" class="headerlink" title="MacPorts"></a>MacPorts</h3><p>如果你是 MacPorts 用户，可以使用以下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port install kotlin</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="创建和运行第一个程序"><a href="#创建和运行第一个程序" class="headerlink" title="创建和运行第一个程序"></a>创建和运行第一个程序</h2><p>创建一个名为 hello.kt 文件，代码如下：</p><h2 id="hello-kt"><a href="#hello-kt" class="headerlink" title="hello.kt"></a>hello.kt</h2><p>fun main(args: Array<string>) {     println(“Hello, World!”) }</string></p><p>使用 Kotlin 编译器编译应用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc hello.kt -include-runtime -d hello.jar</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong>: 用来设置编译输出的名称，可以是 class 或 .jar 文件，也可以是目录。</li><li><strong>-include-runtime</strong> : 让 .jar 文件包含 Kotlin 运行库，从而可以直接运行。</li></ul><p>如果你想看所有的可用选项，运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc -help</span><br></pre></td></tr></table></figure><p>运行应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar hello.jar</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="编译成库"><a href="#编译成库" class="headerlink" title="编译成库"></a>编译成库</h3><p>若需要将生成的 jar 包供其他 Kotlin 程序使用，可无需包含 Kotlin 的运行库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc hello.kt -d hello.jar</span><br></pre></td></tr></table></figure><p>由于这样生成的 .jar 文件不包含 Kotlin 运行库，所以你应该确保当它被使用时，运行时在你的 classpath 上。</p><p>你也可以使用 kotlin 命令来运行 Kotlin 编译器生成的 .jar 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlin -classpath hello.jar HelloKt</span><br></pre></td></tr></table></figure><p>HelloKt 为编译器为 hello.kt 文件生成的默认类名。</p><hr><h2 id="运行-REPL（交互式解释器）"><a href="#运行-REPL（交互式解释器）" class="headerlink" title="运行 REPL（交互式解释器）"></a>运行 REPL（交互式解释器）</h2><p>我们可以运行如下命令得到一个可交互的 shell，然后输入任何有效的 Kotlin 代码，并立即看到结果</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495788947-5293-kotlin-shell.png" alt="img"></p><hr><h2 id="使用命令行执行脚本"><a href="#使用命令行执行脚本" class="headerlink" title="使用命令行执行脚本"></a>使用命令行执行脚本</h2><p>Kotlin 也可以作为一个脚本语言使用，文件后缀名为 .kts 。</p><p>例如我们创建一个名为 list_folders.kts，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File</span><br><span class="line"></span><br><span class="line">val folders = File(args[0]).listFiles &#123; file -&gt; file.isDirectory() &#125;</span><br><span class="line">folders?.forEach &#123; folder -&gt; println(folder) &#125;</span><br></pre></td></tr></table></figure><p>执行时通过 -script 选项设置相应的脚本文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc -script list_folders.kts &lt;path_to_folder&gt;</span><br><span class="line">$ kotlinc -script list_folders.kts</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-使用命令行编译&quot;&gt;&lt;a href=&quot;#Kotlin-使用命令行编译&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 使用命令行编译&quot;&gt;&lt;/a&gt;Kotlin 使用命令行编译&lt;/h1&gt;&lt;p&gt;Kotlin 命令行编译工具下载地址：&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为&lt;/a&gt; 1.1.2-2。&lt;/p&gt;
&lt;p&gt;你可以选择一个最新的稳定版下载。&lt;/p&gt;
&lt;p&gt;下载完成后，解压到指定目录，然后将 &lt;strong&gt;bin&lt;/strong&gt; 目录添加到系统环境变量。bin 目录包含编译和运行 Kotlin 所需的脚本。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;SDKMAN&quot;&gt;&lt;a href=&quot;#SDKMAN&quot; class=&quot;headerlink&quot; title=&quot;SDKMAN!&quot;&gt;&lt;/a&gt;SDKMAN!&lt;/h2&gt;&lt;p&gt;在 OS X、Linux、Cygwin、FreeBSD 和 Solaris 系统上也可以使用更简单的安装方法，命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl -s https://get.sdkman.io | bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sdk install kotlin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;Homebrew&quot;&gt;&lt;a href=&quot;#Homebrew&quot; class=&quot;headerlink&quot; title=&quot;Homebrew&quot;&gt;&lt;/a&gt;Homebrew&lt;/h3&gt;&lt;p&gt;在 OS X 下，你可以使用 Homebrew 安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ brew install kotlin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;MacPorts&quot;&gt;&lt;a href=&quot;#MacPorts&quot; class=&quot;headerlink&quot; title=&quot;MacPorts&quot;&gt;&lt;/a&gt;MacPorts&lt;/h3&gt;&lt;p&gt;如果你是 MacPorts 用户，可以使用以下命令安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo port install kotlin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin教程</title>
    <link href="https://zhangmiao.cc/posts/17a38a8.html"/>
    <id>https://zhangmiao.cc/posts/17a38a8.html</id>
    <published>2020-08-29T02:15:27.000Z</published>
    <updated>2020-08-29T03:23:18.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-教程"><a href="#Kotlin-教程" class="headerlink" title="Kotlin 教程"></a>Kotlin 教程</h1><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。</p><p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><hr><h2 id="Kotlin-程序"><a href="#Kotlin-程序" class="headerlink" title="Kotlin 程序"></a>Kotlin 程序</h2><p>Kotlin 程序文件以 <strong>.kt</strong> 结尾，如：hello.kt 、app.kt。</p><h2 id="最简版"><a href="#最简版" class="headerlink" title="最简版"></a>最简版</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello                      <span class="comment">//  可选的包头</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="comment">// 包级可见的函数，接受一个字符串数组作为参数</span></span><br><span class="line">   println(<span class="string">"Hello World!"</span>)         <span class="comment">// 分号可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span> &#123; </span><br><span class="line">      println(<span class="string">"Hello, <span class="variable">$name</span>"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">   Greeter(<span class="string">"World!"</span>).greet()          <span class="comment">// 创建一个对象不用 new 关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="为什么选择-Kotlin？"><a href="#为什么选择-Kotlin？" class="headerlink" title="为什么选择 Kotlin？"></a>为什么选择 Kotlin？</h2><ul><li>简洁: 大大减少样板代码的数量。</li><li>安全: 避免空指针异常等整个类的错误。</li><li>互操作性: 充分利用 JVM、Android 和浏览器的现有库。</li><li>工具友好: 可用任何 Java IDE 或者使用命令行构建。</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.kotlinlang.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://try.kotlinlang.org/" target="_blank" rel="noopener">官方示例</a></li><li><a href="https://www.kotlincn.net/" target="_blank" rel="noopener">官方网站 - 中文翻译</a></li><li><a href="https://play.kotlinlang.org/" target="_blank" rel="noopener">Kotlin 官方在线工具</a></li><li><a href="https://c.runoob.com/compile/2960" target="_blank" rel="noopener">Kotlin 在线工具</a></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-教程&quot;&gt;&lt;a href=&quot;#Kotlin-教程&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 教程&quot;&gt;&lt;/a&gt;Kotlin 教程&lt;/h1&gt;&lt;p&gt;Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。&lt;/p&gt;
&lt;p&gt;Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。&lt;/p&gt;
&lt;p&gt;在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Kotlin-程序&quot;&gt;&lt;a href=&quot;#Kotlin-程序&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 程序&quot;&gt;&lt;/a&gt;Kotlin 程序&lt;/h2&gt;&lt;p&gt;Kotlin 程序文件以 &lt;strong&gt;.kt&lt;/strong&gt; 结尾，如：hello.kt 、app.kt。&lt;/p&gt;
&lt;h2 id=&quot;最简版&quot;&gt;&lt;a href=&quot;#最简版&quot; class=&quot;headerlink&quot; title=&quot;最简版&quot;&gt;&lt;/a&gt;最简版&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; hello                      &lt;span class=&quot;comment&quot;&gt;//  可选的包头&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 包级可见的函数，接受一个字符串数组作为参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   println(&lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;)         &lt;span class=&quot;comment&quot;&gt;// 分号可以省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Greeter&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name: String) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      println(&lt;span class=&quot;string&quot;&gt;&quot;Hello, &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Greeter(&lt;span class=&quot;string&quot;&gt;&quot;World!&quot;&lt;/span&gt;).greet()          &lt;span class=&quot;comment&quot;&gt;// 创建一个对象不用 new 关键字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&quot;为什么选择-Kotlin？&quot;&gt;&lt;a href=&quot;#为什么选择-Kotlin？&quot; class=&quot;headerlink&quot; title=&quot;为什么选择 Kotlin？&quot;&gt;&lt;/a&gt;为什么选择 Kotlin？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简洁: 大大减少样板代码的数量。&lt;/li&gt;
&lt;li&gt;安全: 避免空指针异常等整个类的错误。&lt;/li&gt;
&lt;li&gt;互操作性: 充分利用 JVM、Android 和浏览器的现有库。&lt;/li&gt;
&lt;li&gt;工具友好: 可用任何 Java IDE 或者使用命令行构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://try.kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kotlincn.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方网站 - 中文翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://play.kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin 官方在线工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://c.runoob.com/compile/2960&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin 在线工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Flutter插件开发指南</title>
    <link href="https://zhangmiao.cc/posts/f946bb65.html"/>
    <id>https://zhangmiao.cc/posts/f946bb65.html</id>
    <published>2020-08-26T07:06:49.000Z</published>
    <updated>2020-08-26T07:42:13.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter插件开发"><a href="#Flutter插件开发" class="headerlink" title="Flutter插件开发"></a>Flutter插件开发</h2><h3 id="创建插件目录"><a href="#创建插件目录" class="headerlink" title="创建插件目录"></a>创建插件目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flutter create -i objc -a java --template=plugin demo</span><br><span class="line"></span><br><span class="line">-i, 表示指定iOS的语言, objc, swift</span><br><span class="line">-a, 表示指定安卓的语言, java, kotlin</span><br></pre></td></tr></table></figure><p>通过上面命令，创建一个名为<code>demo</code>的plugin模板, 并生成以下目录结构</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- android // 插件相关 Android 代码</span><br><span class="line">- ios // 插件相关 iOS 代码</span><br><span class="line">- lib // 插件相关 Dart 代码</span><br><span class="line">- example // 示例项目, 用于调试当前开发的插件</span><br><span class="line">- pubspec.yaml // 插件配置文件</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="example目录"><a href="#example目录" class="headerlink" title="example目录"></a>example目录</h4><p>example目录, 是一个示例项目, 用于调试当前开发的插件</p><p>在example/lib/main.dart中, 默认生成一些示例代码. 代码如下:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:demo/demo.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAppState createState() =&gt; _MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _platformVersion = <span class="string">'Unknown'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    initPlatformState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; initPlatformState() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> platformVersion;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      platformVersion = <span class="keyword">await</span> Demo.platformVersion;</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line">      platformVersion = <span class="string">'Failed to get platform version.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mounted) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _platformVersion = platformVersion;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">'Plugin example app'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(<span class="string">'Running on: $_platformVersion\n'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中的代码, <code>Demo.platformVersion</code>, 实际上是调用了lib目录中, <code>Demo</code>类的get方法<code>platformVersion</code>, 也就是我们写的插件代码</p><h3 id="lib目录"><a href="#lib目录" class="headerlink" title="lib目录"></a>lib目录</h3><p>lib目录, 主要用来存放, 开发的插件所需要的dart代码</p><p>在lib/demo.dart, 中可以找到默认生成的示例代码, 代码如下:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel =</span><br><span class="line">      <span class="keyword">const</span> MethodChannel(<span class="string">'demo'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Future&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> platformVersion <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> version = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">'getPlatformVersion'</span>);</span><br><span class="line">    <span class="keyword">return</span> version;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码, 创建了一个名字为<code>demo</code>的MethodChannel对象, 并提供一个<code>get platformVersion</code>方法, 在该方法中调用invokeMethod方法, 去调用原生代码中, 名字为<code>getPlatformVersion</code>的方法.</p><h4 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h4><p>flutter与原生的交互, 可以通过MethodChannel来实现, MethodChannel是双向的, 通过它可以在flutter中调用原生代码, 也可以在原生代码调用flutter代码</p><h3 id="ios目录"><a href="#ios目录" class="headerlink" title="ios目录"></a>ios目录</h3><p>ios目录, 主要用来存放, 开发的插件所需要的iOS代码</p><p>在ios目录中, ios/Classes/DemoPlugin.m, 中可以找到<code>getPlatformVersion</code>对应的原生代码, 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;DemoPlugin.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation DemoPlugin</span><br><span class="line">+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123;</span><br><span class="line">  FlutterMethodChannel* channel = [FlutterMethodChannel</span><br><span class="line">      methodChannelWithName:@&quot;demo&quot;</span><br><span class="line">            binaryMessenger:[registrar messenger]];</span><br><span class="line">  DemoPlugin* instance = [[DemoPlugin alloc] init];</span><br><span class="line">  [registrar addMethodCallDelegate:instance channel:channel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123;</span><br><span class="line">  if ([@&quot;getPlatformVersion&quot; isEqualToString:call.method]) &#123;</span><br><span class="line">    result([@&quot;iOS &quot; stringByAppendingString:[[UIDevice currentDevice] systemVersion]]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result(FlutterMethodNotImplemented);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="android目录"><a href="#android目录" class="headerlink" title="android目录"></a>android目录</h3><p>android目录, 主要用来存放, 开发的插件所需要的android代码</p><p>在android目录中, android/src/main/java/com/example/demo/DemoPlugin.java, 中可以找到<code>getPlatformVersion</code>对应的原生代码, 代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodCall;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel.MethodCallHandler;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel.Result;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.PluginRegistry.Registrar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** DemoPlugin */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPlugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Plugin registration. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MethodChannel channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">"demo"</span>);</span><br><span class="line">    channel.setMethodCallHandler(<span class="keyword">new</span> DemoPlugin());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (call.method.equals(<span class="string">"getPlatformVersion"</span>)) &#123;</span><br><span class="line">      result.success(<span class="string">"Android "</span> + android.os.Build.VERSION.RELEASE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.notImplemented();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原生代码"><a href="#原生代码" class="headerlink" title="原生代码"></a>原生代码</h4><p>原生代码中, 也都创建一个名为<code>demo</code>的MethodChannel对象. (与lib目中的dart代码中的MethodChannel名字一致).</p><p>通过注册, 监听该channel的回调. 在回调中通过判断call.method的值, 来区分flutter中调用的哪个方法.</p><p>如示例中判断是否等于<code>getPlatformVersion</code>, 并在当中执行对应的原生代码, 获取设备相关的系统版本.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>另外, 在flutter中, 如果想使用原生的视图, 需要使用flutter的UiKitView和AndroidView.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flutter插件开发&quot;&gt;&lt;a href=&quot;#Flutter插件开发&quot; class=&quot;headerlink&quot; title=&quot;Flutter插件开发&quot;&gt;&lt;/a&gt;Flutter插件开发&lt;/h2&gt;&lt;h3 id=&quot;创建插件目录&quot;&gt;&lt;a href=&quot;#创建插件目录&quot; class=&quot;headerlink&quot; title=&quot;创建插件目录&quot;&gt;&lt;/a&gt;创建插件目录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;flutter create -i objc -a java --template=plugin demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-i, 表示指定iOS的语言, objc, swift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-a, 表示指定安卓的语言, java, kotlin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;通过上面命令，创建一个名为&lt;code&gt;demo&lt;/code&gt;的plugin模板, 并生成以下目录结构&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- android // 插件相关 Android 代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- ios // 插件相关 iOS 代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- lib // 插件相关 Dart 代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- example // 示例项目, 用于调试当前开发的插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- pubspec.yaml // 插件配置文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter - 监视页面的切换(RouteObserver &amp; RouteAware)</title>
    <link href="https://zhangmiao.cc/posts/97bcffb.html"/>
    <id>https://zhangmiao.cc/posts/97bcffb.html</id>
    <published>2020-08-10T02:49:37.000Z</published>
    <updated>2020-08-10T03:02:32.183Z</updated>
    
    <content type="html"><![CDATA[<p>经常性的，我们需要监视页面的切换，用以在合适的时候对控件进行动画暂停或者资源释放。</p><p>举个栗子：<br>相机拍照是我们需要经常用到的功能，但是当我们在切换到相机配置页面时，需要暂停当前相机预览，这种情况下我们就需要监视页面的路由变化情况，又或者用户回到应用桌面，此时也需要对相机进行暂停，返回又恢复相机。</p><p>在这里主要关系到下面两个方面的：</p><ol><li>AppStateLifeRecycle - 今天我们不说这个；</li><li>RouteAware</li></ol><p>先看看RouteAware是如何定义的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/// An interface for objects that are aware of their current [Route].</span><br><span class="line">///</span><br><span class="line">/// This is used with [RouteObserver] to make a widget aware of changes to the</span><br><span class="line">/// [Navigator]&apos;s session history.</span><br><span class="line">abstract class RouteAware &#123;</span><br><span class="line">  /// Called when the top route has been popped off, and the current route</span><br><span class="line">  /// shows up.</span><br><span class="line">  void didPopNext() &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  /// Called when the current route has been pushed.</span><br><span class="line">  void didPush() &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  /// Called when the current route has been popped off.</span><br><span class="line">  void didPop() &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  /// Called when a new route has been pushed, and the current route is no</span><br><span class="line">  /// longer visible.</span><br><span class="line">  void didPushNext() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面提交到4个方法，分别都有什么用呢？<br>假如有3个页面，分别是A、B、C，跳转逻辑由A-&gt;B-&gt;C，而RouteAware使用with混淆在B中。</p><ul><li><strong>didPopNext</strong>：在C页面关闭后，B页面调起该方法；</li><li><strong>didPush</strong>: 当由A打开B页面时，B页面调起该方法；</li><li><strong>didPop</strong>: 当B页面关闭时，B页面调起该方法；</li><li><strong>didPushNext</strong>: 当从B页面打开C页面时，该方法被调起。</li></ul><blockquote><p>如何使用？</p></blockquote><ol><li>使用<strong>with</strong>关键字在State类中使用，使用前在<strong>MaterialApp</strong>中定义一个<strong>RouteObserver</strong>对象。<br>如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final RouteObserver&lt;PageRoute&gt; routeObserver = RouteObserver();</span><br><span class="line"> </span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    ... \\此处省略一些代码</span><br><span class="line"> </span><br><span class="line">    Widget _buildMaterialApp() =&gt; MaterialApp(</span><br><span class="line">      initialRoute: &apos;/&apos;,</span><br><span class="line">      navigatorObservers: [routeObserver], //添加路由观察者</span><br><span class="line">      onGenerateRoute: _onGenerateRoute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在B页面中混淆<strong>RouteAware</strong>, 并注册<strong>RouteObserver</strong><br>如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class B extends StatefulWidget &#123;</span><br><span class="line">     B(&#123;Key key&#125;) : super(key: key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class BState extends State&lt;B&gt;  with RouteAware &#123;</span><br><span class="line"> </span><br><span class="line">  @override</span><br><span class="line">  void didChangeDependencies() &#123;</span><br><span class="line">    routeObserver.subscribe(this, ModalRoute.of(context)); //订阅</span><br><span class="line">    super.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  @override</span><br><span class="line">  void didPush() &#123;</span><br><span class="line">    debugPrint(&quot;------&gt; didPush&quot;);</span><br><span class="line">    super.didPush();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  @override</span><br><span class="line">  void didPop() &#123;</span><br><span class="line">    debugPrint(&quot;------&gt; didPop&quot;);</span><br><span class="line">    super.didPop();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  @override</span><br><span class="line">  void didPopNext() &#123;</span><br><span class="line">    debugPrint(&quot;------&gt; didPopNext&quot;);</span><br><span class="line">    super.didPopNext();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">@override</span><br><span class="line">  void didPushNext() &#123;</span><br><span class="line">    debugPrint(&quot;------&gt; didPushNext&quot;);</span><br><span class="line">    super.didPushNext();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    routeObserver.unsubscribe(this); //取消订阅</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结 :</p></blockquote><ol><li>路由观察者添加订阅与取消订阅必须成对出现；</li><li>一些对象在使用后一定要记得及时释放资源。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常性的，我们需要监视页面的切换，用以在合适的时候对控件进行动画暂停或者资源释放。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;br&gt;相机拍照是我们需要经常用到的功能，但是当我们在切换到相机配置页面时，需要暂停当前相机预览，这种情况下我们就需要监视页面的路由变化情况，又或者用户回到应用桌面，此时也需要对相机进行暂停，返回又恢复相机。&lt;/p&gt;
&lt;p&gt;在这里主要关系到下面两个方面的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AppStateLifeRecycle - 今天我们不说这个；&lt;/li&gt;
&lt;li&gt;RouteAware&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先看看RouteAware是如何定义的？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/// An interface for objects that are aware of their current [Route].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;///&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// This is used with [RouteObserver] to make a widget aware of changes to the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// [Navigator]&amp;apos;s session history.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abstract class RouteAware &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /// Called when the top route has been popped off, and the current route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /// shows up.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void didPopNext() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /// Called when the current route has been pushed.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void didPush() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /// Called when the current route has been popped off.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void didPop() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /// Called when a new route has been pushed, and the current route is no&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /// longer visible.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void didPushNext() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>FlutterBoost混合开发实践与源码解析</title>
    <link href="https://zhangmiao.cc/posts/dd9d0434.html"/>
    <id>https://zhangmiao.cc/posts/dd9d0434.html</id>
    <published>2020-07-06T08:31:24.000Z</published>
    <updated>2020-07-06T08:32:43.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/alibaba/flutter_boost" target="_blank" rel="noopener">Flutter Boost</a> 是闲鱼团队开发的一个 Flutter 混合开发框架，项目背景可以看看闲鱼的这篇文章：<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU4MDUxOTI5NA%3D%3D%26mid%3D2247484367%26idx%3D1%26sn%3Dfcbc485f068dae5de9f68d52607ea08f%26chksm%3Dfd54d7deca235ec86249a9e3714ec18be8b2d6dc580cae19e4e5113533a6c5b44dfa5813c4c3%26scene%3D0%26subscene%3D131%26clicktime%3D1551942425%26ascene%3D7%26devicetype%3Dandroid-28%26version%3D2700033b%26nettype%3Dctnet%26abtest_cookie%3DBAABAAoACwASABMABAAklx4AVpkeAMSZHgDWmR4AAAA%3D%26lang%3Dzh_CN%26pass_ticket%3D1qvHqOsbLBHv3wwAcw577EHhNjg6EKXqTfnOiFbbbaw%3D%26wx_header%3D1" target="_blank" rel="noopener">码上用它开始Flutter混合开发——FlutterBoost</a>。</p><p>文章中主要讲述了多引擎存在一些实际问题，所以闲鱼目前采用的混合方案是共享同一个引擎的方案。而 Flutter Boost 的 Feature 如下：</p><ul><li>可复用通用型混合方案</li><li>支持更加复杂的混合模式，比如支持主页Tab这种情况</li><li>无侵入性方案：不再依赖修改Flutter的方案</li><li>支持通用页面生命周期</li><li>统一明确的设计概念</li></ul><p>Flutter Boost 采用共享引擎的模式来实现，主要思路是由 Native 容器 Container 通过消息驱动 Flutter 页面容器 Container，从而达到 Native Container 与 Flutter Container 的同步目的。简单的理解，闲鱼想做到把 Flutter 容器做成浏览器的感觉。填写一个页面地址，然后由容器去管理页面的绘制。在 Native 侧我们只需要关心如果初始化容器，然后设置容器对应的页面标志即可。</p><p>鉴于网上没有相关的接入文档和使用教程，我这几天也恰好抽空研究了一下，遂整理成文，仅供参考。由于篇幅原因，本文只研究 Android 端的接入与源码，iOS 的部分后续有机会则补充文章来讲解。</p><blockquote><p>注：本文接入的 Flutter Boost 版本为 1.12.13，对应支持的 Flutter SDK 版本为 1.12.13-hotfixes，是目前最新的版本。但 Flutter Boost 版本更新之后，接入方式和使用方式可能会有一些改变，故参考本文时请认准 1.12.13 版本。</p></blockquote><a id="more"></a><h2 id="2-接入"><a href="#2-接入" class="headerlink" title="2. 接入"></a>2. 接入</h2><h3 id="2-1-创建-Flutter-Module"><a href="#2-1-创建-Flutter-Module" class="headerlink" title="2.1 创建 Flutter Module"></a>2.1 创建 Flutter Module</h3><p>在开始之前，我们需要保证工程目录如下结构所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- flutter_hybrid</span><br><span class="line">        --- flutter_module</span><br><span class="line">--- FlutterHybridAndroid </span><br><span class="line">--- FlutterHybridiOS</span><br></pre></td></tr></table></figure><p>即，iOS 工程与 Android 工程与 flutter_module 目录在同一层级。如此，方便管理，同时也保证后续集成代码中路径的一致性。</p><p>接着，我们来创建 Flutter Module：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> flutter_hybrid</span><br><span class="line">flutter create -t module flutter_module</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要创建支持 Android X 的 flutter module，命令上需要加上 <code>--androidx</code> 参数，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --androidx -t module flutter_module</span><br></pre></td></tr></table></figure><p>注：如果安装依赖过慢，可以切换为国内的依赖镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>当然我们也可以通过新版的 Android Studio 来可视化创建一个 Flutter Module （需 3.6.1 以上版本，并给 IDE 装上 Flutter 与 Dart 插件），具体方法可以见官网介绍（<a href="https://link.zhihu.com/?target=https%3A//flutter.dev/docs/development/add-to-app/android/project-setup" target="_blank" rel="noopener">https://flutter.dev/docs/development/add-to-app/android/project-setup</a>），此处不再赘述。但个人建议使用本文介绍的更为通用的方法去创建并集成 Flutter Module。</p><h3 id="2-2-集成-Flutter-Module"><a href="#2-2-集成-Flutter-Module" class="headerlink" title="2.2 集成 Flutter Module"></a>2.2 集成 Flutter Module</h3><p>创建好 Flutter Module 之后，需要在 Native 工程中集成 flutter_module。具体有两种方式：</p><ol><li>源码依赖</li><li>arr 依赖</li></ol><h3 id="2-2-1-源码依赖集成"><a href="#2-2-1-源码依赖集成" class="headerlink" title="2.2.1 源码依赖集成"></a>2.2.1 源码依赖集成</h3><p>源码依赖的优点是开发、调试方便，也就是在 Android 工程的 <code>settings.gradle</code> 和 app 目录下的 <code>build.gradle</code> 文件中加入对 flutter_module 的依赖即可。</p><p>首先，在 <code>settings.gradle</code> 文件中，增加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:app&apos;                                     // 已存在的内容</span><br><span class="line"></span><br><span class="line">setBinding(new Binding([gradle: this]))                                </span><br><span class="line">evaluate(new File(                                                     </span><br><span class="line">  settingsDir.parentFile,                                               </span><br><span class="line">  &apos;flutter_module/.android/include_flutter.groovy&apos;                      </span><br><span class="line">))</span><br></pre></td></tr></table></figure><p><code>setBinding</code> 与 <code>evaluate</code> 增加之后我们就可以在 <code>app/build.gradle</code> 中增加 <code>:flutter</code> 依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation project(&apos;:flutter&apos;)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也需要在该文件中的 android() 配置指定一下编译时的 Java 版本为 Java 8，否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">  sourceCompatibility 1.8</span><br><span class="line">  targetCompatibility 1.8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后执行一下 gradle sync 下载依赖库。如果集成成功，会在左侧的项目目录中看到与项目同级的 flutter_module 文件夹。</p><h3 id="2-2-2-arr-依赖集成"><a href="#2-2-2-arr-依赖集成" class="headerlink" title="2.2.2 arr 依赖集成"></a>2.2.2 arr 依赖集成</h3><p>如果需要用远程打包，而远程的机器上没有 flutter 环境，就可以把 flutter 打包成 arr 文件进行依赖。生成 aar 文件之后再在主工程里引用，flutter aar 中包含了 flutter sdk 的代码，所以这种方式是不需要flutter 环境的，也适合第三方快速接入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .android/</span><br><span class="line">./gradlew flutter:assembleDebug</span><br></pre></td></tr></table></figure><h3 id="2-3-添加-Flutter-Boost-依赖"><a href="#2-3-添加-Flutter-Boost-依赖" class="headerlink" title="2.3 添加 Flutter Boost 依赖"></a>2.3 添加 Flutter Boost 依赖</h3><p>首先在 Flutter Module 项目中加入 flutter-boost 依赖，即在 pubspec.yaml 文件中的 dev_dependencies 配置增加 flutter-boost 依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line"><span class="attr">  flutter_boost:</span></span><br><span class="line"><span class="attr">     git:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">'https://github.com/alibaba/flutter_boost.git'</span></span><br><span class="line"><span class="attr">        ref:</span> <span class="string">'1.12.13'</span></span><br></pre></td></tr></table></figure><p>以上 flutter boost 支持 AndroidX，如果想支持 support，则需要切换分支：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter_boost:</span></span><br><span class="line"><span class="attr">    git:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">'https://github.com/alibaba/flutter_boost.git'</span></span><br><span class="line"><span class="attr">        ref:</span> <span class="string">'task/task_v1.12.13_support_hotfixes'</span></span><br></pre></td></tr></table></figure><p>编辑完之后在 flutter_module 目录下执行以下命令安装依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure><p>之后在 Android 工程中的 app 目录下的 build.gradle 文件中增加 <code>:flutter_boost</code> 依赖，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation project(&apos;:flutter&apos;)</span><br><span class="line">    implementation project(&apos;:flutter_boost&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Flutter Boost 是以 Flutter Plugin 的形式集成到我们的项目中来的，所以我们还需要做一些工作，首先在 app 目录下的 build.gradle 文件的头部增加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def localProperties = new Properties()</span><br><span class="line">def localPropertiesFile = rootProject.file(&apos;local.properties&apos;)</span><br><span class="line">if (localPropertiesFile.exists()) &#123;</span><br><span class="line">    localPropertiesFile.withReader(&apos;UTF-8&apos;) &#123; reader -&gt;</span><br><span class="line">        localProperties.load(reader)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def flutterRoot = localProperties.getProperty(&apos;flutter.sdk&apos;)</span><br><span class="line">if (flutterRoot == null) &#123;</span><br><span class="line">    throw new GradleException(&quot;Flutter SDK not found. Define location with flutter.sdk in the local.properties file.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def flutterVersionCode = localProperties.getProperty(&apos;flutter.versionCode&apos;)</span><br><span class="line">if (flutterVersionCode == null) &#123;</span><br><span class="line">    flutterVersionCode = &apos;1&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def flutterVersionName = localProperties.getProperty(&apos;flutter.versionName&apos;)</span><br><span class="line">if (flutterVersionName == null) &#123;</span><br><span class="line">    flutterVersionName = &apos;1.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这需要我们在 Android 工程下的 local.properties 文件中指定以下我们本地的 Flutter SDK 的位置（没有改文件就新建一个）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter.sdk = /Users/airing/flutter</span><br></pre></td></tr></table></figure><p>最后再在工程目录下的 settings.gradle 中增加以下代码引入 flutter-plugin：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def flutterProjectRoot = rootProject.projectDir.parentFile.toPath()</span><br><span class="line"></span><br><span class="line">def plugins = new Properties()</span><br><span class="line">def pluginsFile = new File(flutterProjectRoot.toFile(), &apos;.flutter-plugins&apos;)</span><br><span class="line">if (pluginsFile.exists()) &#123;</span><br><span class="line">    pluginsFile.withReader(&apos;UTF-8&apos;) &#123; reader -&gt; plugins.load(reader) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins.each &#123; name, path -&gt;</span><br><span class="line">    def pluginDirectory = flutterProjectRoot.resolve(path).resolve(&apos;android&apos;).toFile()</span><br><span class="line">    include &quot;:$name&quot;</span><br><span class="line">    project(&quot;:$name&quot;).projectDir = pluginDirectory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，修改完 Android 工程的依赖之后，需要 gradle sync 一下。</p><p>至此，Flutter Boost 集成成功。接下来，我们使用 Flutter Boost 进行混合开发。而混合开发，主要涉及到两个场景：</p><ol><li>在 Native 项目中加入 Flutter 页面，即 Add a single Flutter screen。</li><li>在 Native 页面中嵌入 Flutter 模块，即 Add a Flutter Fragment。</li></ol><p>这两种方式在 Flutter 的官网上都有实践讲解，我们这里主要看看如果使用 Flutter boost 究竟要如何实现的，并顺便探究一下其实现原理。</p><h2 id="3-混合开发1：-Flutter-View"><a href="#3-混合开发1：-Flutter-View" class="headerlink" title="3. 混合开发1： Flutter View"></a>3. 混合开发1： Flutter View</h2><p><img src="https://pic3.zhimg.com/80/v2-0b258f4732ef0c884a9e831d04853302_720w.jpg" alt="img"></p><h3 id="3-1-在-Flutter-Module-中使用-Flutter-Boost"><a href="#3-1-在-Flutter-Module-中使用-Flutter-Boost" class="headerlink" title="3.1 在 Flutter Module 中使用 Flutter Boost"></a>3.1 在 Flutter Module 中使用 Flutter Boost</h3><p>首先引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter_boost/flutter_boost.dart&apos;;</span><br></pre></td></tr></table></figure><p>随后在 main 方法中运行的 rootWidget 中注册两个新的页面，以便 Native 工程可以跳转过来。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_boost/flutter_boost.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'simple_page_widgets.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAppState createState() =&gt; _MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    FlutterBoost.singleton.registerPageBuilders(&#123;</span><br><span class="line">      <span class="string">'first'</span>: (pageName, params, _) =&gt; FirstRouteWidget(),</span><br><span class="line">      <span class="string">'second'</span>: (pageName, params, _) =&gt; SecondRouteWidget(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Flutter Boost example'</span>,</span><br><span class="line">        builder: FlutterBoost.init(),</span><br><span class="line">        home: Container(</span><br><span class="line">            color:Colors.white</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单：</p><ol><li>在 initState 的时候使用 <code>FlutterBoost.singleton.registerPageBuilders</code> 注册页面</li><li>在 bulider 中初始化 FlutterBoost。</li></ol><h3 id="3-2-在-Android-工程中使用-Flutter-Boost"><a href="#3-2-在-Android-工程中使用-Flutter-Boost" class="headerlink" title="3.2 在 Android 工程中使用 Flutter Boost"></a>3.2 在 Android 工程中使用 Flutter Boost</h3><p>在 Android 项目中增加一个 Flutter 页面，即是添加一个 Flutter Activity（iOS 即是添加一个新的 FlutterViewController，这里不再花篇幅去讲解 iOS 的实现了，有兴趣的同学可以自己去阅读 Flutter Boost 的示例代码和源码）。</p><p>这里我们在 AndroidManifest.xml 的 Application 配置中添加一个 Flutter Boost Activity：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">"com.idlefish.flutterboost.containers.BoostFlutterActivity"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustResize"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"io.flutter.embedding.android.SplashScreenDrawable"</span> <span class="attr">android:resource</span>=<span class="string">"@drawable/page_loading"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除此之外还需要在 AndroidManifest.xml 中添加 flutterEmbedding 版本设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"flutterEmbedding"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:value</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着要进行初始化 FlutterBoost 的工作，建议在 Application 的 onCreate 方法中初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        INativeRouter router = <span class="keyword">new</span> INativeRouter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openContainer</span><span class="params">(Context context, String url, Map&lt;String, Object&gt; urlParams, <span class="keyword">int</span> requestCode, Map&lt;String, Object&gt; exts)</span> </span>&#123;</span><br><span class="line">               String  assembleUrl=Utils.assembleUrl(url,urlParams);</span><br><span class="line">                PageRouter.openPageByUrl(context,assembleUrl, urlParams);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FlutterBoost.BoostLifecycleListener boostLifecycleListener= <span class="keyword">new</span> FlutterBoost.BoostLifecycleListener()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCreateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEngineCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginsRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEngineDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Platform platform = <span class="keyword">new</span> FlutterBoost</span><br><span class="line">                .ConfigBuilder(<span class="keyword">this</span>,router)</span><br><span class="line">                .isDebug(<span class="keyword">true</span>)</span><br><span class="line">                .whenEngineStart(FlutterBoost.ConfigBuilder.ANY_ACTIVITY_CREATED)</span><br><span class="line">                .renderMode(FlutterView.RenderMode.texture)</span><br><span class="line">                .lifecycleListener(boostLifecycleListener)</span><br><span class="line">                .build();</span><br><span class="line">        FlutterBoost.instance().init(platform);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlutterBoost 在 Android 工程中初始化需要进行 4 步工作：</p><ol><li>注册路由跳转方法（后续会说 PageRouter 的实现）</li><li>增加 flutter boost 的生命周期监听函数，可以在 Flutter Engine 创建之前、创建之后、销毁之后与 Flutter Plugin 注册之后回调事件。</li><li>声明 Flutter boost 配置，把路由和生命周期函数配置上。</li><li>初始化 Flutter boost。</li></ol><p>接着要在 Android 工程中实现一个页面路由的工具类 PageRouter，这里直接摆上 Flutter Boost 示例代码中的实现了，比较全面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, String&gt; pageName = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line"></span><br><span class="line">        put(<span class="string">"first"</span>, <span class="string">"first"</span>);</span><br><span class="line">        put(<span class="string">"second"</span>, <span class="string">"second"</span>);</span><br><span class="line">        put(<span class="string">"tab"</span>, <span class="string">"tab"</span>);</span><br><span class="line">        put(<span class="string">"sample://flutterPage"</span>, <span class="string">"flutterPage"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NATIVE_PAGE_URL = <span class="string">"sample://nativePage"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLUTTER_PAGE_URL = <span class="string">"sample://flutterPage"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLUTTER_FRAGMENT_PAGE_URL = <span class="string">"sample://flutterFragmentPage"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">openPageByUrl</span><span class="params">(Context context, String url, Map params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> openPageByUrl(context, url, params, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">openPageByUrl</span><span class="params">(Context context, String url, Map params, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String path = url.split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Log.i(<span class="string">"openPageByUrl"</span>,path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pageName.containsKey(path)) &#123;</span><br><span class="line">                Intent intent = BoostFlutterActivity.withNewEngine().url(pageName.get(path)).params(params)</span><br><span class="line">                        .backgroundMode(BoostFlutterActivity.BackgroundMode.opaque).build(context);</span><br><span class="line">                <span class="keyword">if</span>(context <span class="keyword">instanceof</span> Activity)&#123;</span><br><span class="line">                    Activity activity=(Activity)context;</span><br><span class="line">                    activity.startActivityForResult(intent,requestCode);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    context.startActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.startsWith(FLUTTER_FRAGMENT_PAGE_URL)) &#123;</span><br><span class="line">                context.startActivity(<span class="keyword">new</span> Intent(context, FlutterFragmentPageActivity.class));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.startsWith(NATIVE_PAGE_URL)) &#123;</span><br><span class="line">                context.startActivity(<span class="keyword">new</span> Intent(context, NativePageActivity.class));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-在-Native-项目中打开-Flutter-页面"><a href="#3-3-在-Native-项目中打开-Flutter-页面" class="headerlink" title="3.3 在 Native 项目中打开 Flutter 页面"></a>3.3 在 Native 项目中打开 Flutter 页面</h3><p>调用比较简单，在 Native 页面上的按钮绑定上 onClick 监听来实现点击打开我们注册的 Flutter 中的 first 页面，还可以顺便传上一个 map 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    Map params = <span class="keyword">new</span> HashMap();</span><br><span class="line">    params.put(<span class="string">"test1"</span>,<span class="string">"v_test1"</span>);</span><br><span class="line">    params.put(<span class="string">"test2"</span>,<span class="string">"v_test2"</span>);</span><br><span class="line"></span><br><span class="line">    PageRouter.openPageByUrl(<span class="keyword">this</span>, <span class="string">"first"</span>, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们回顾一下我们在 3.1 中 Flutter 中注册页面的代码，发现有一个 params 参数，没错那就是 Native 打开 Flutter 时传过来的参数，我们可以打印出来或者传给 widget 做额外的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FlutterBoost.singleton.registerPageBuilders(&#123;</span><br><span class="line">      <span class="string">'first'</span>: (pageName, params, _) =&gt; &#123;</span><br><span class="line">        print(<span class="string">"flutterPage params:$params"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FirstRouteWidget(params:params);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'second'</span>: (pageName, params, _) =&gt; SecondRouteWidget(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-4-在-Flutter-页面中打开-Native-页面"><a href="#3-4-在-Flutter-页面中打开-Native-页面" class="headerlink" title="3.4 在 Flutter 页面中打开 Native 页面"></a>3.4 在 Flutter 页面中打开 Native 页面</h3><p>同样的，我们可能还会遇到一种场景，在 Native 中打开 Flutter 页面之后，我们 Flutter 中的业务又需要再打开一个新的 Native 页面，那需要怎么做？在 Flutter 中使用 <code>FlutterBoost.singleton.open</code> 即可，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后面的参数会在native的IPlatform.startActivity方法回调中拼接到url的query部分。</span></span><br><span class="line"><span class="comment">// 例如：sample://nativePage?aaa=bbb</span></span><br><span class="line">onTap: () =&gt; FlutterBoost.singleton</span><br><span class="line">     .open(<span class="string">"sample://nativePage"</span>, urlParams: &lt;<span class="keyword">dynamic</span>,<span class="keyword">dynamic</span>&gt;&#123;</span><br><span class="line">      <span class="string">"query"</span>: &#123;<span class="string">"aaa"</span>: <span class="string">"bbb"</span>&#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>当然，这个方法不单单支持打开 Native 页面，也可以打开一个新的 Flutter 页面，只需要写好路由名就好，这里不再赘述。</p><blockquote><p>注：得益于 Flutter 的 JIT 编译模式，我们可以通过 flutter attach 命令来实现 hot reload 功能，在开发 Flutter 页面时无需重新编译工程。</p></blockquote><h2 id="4-混合开发2：Flutter-Fragment"><a href="#4-混合开发2：Flutter-Fragment" class="headerlink" title="4. 混合开发2：Flutter Fragment"></a>4. 混合开发2：Flutter Fragment</h2><p><img src="https://pic4.zhimg.com/80/v2-6c9bd1112d2cf2e32e0dbd448d8daf37_720w.jpg" alt="img"></p><p>我们假设工程中存在一个 Activity，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:name</span>=<span class="string">".FlutterFragmentPageActivity"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustResize"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"io.flutter.embedding.android.SplashScreenDrawable"</span> <span class="attr">android:resource</span>=<span class="string">"@drawable/page_loading"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而对应 layout 中我们要加入一个 FrameLayout 组件作为占位符：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/fragment_stub"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后，在代码中拿到对应 url 的 Flutter widget，塞到占位组件里即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    FlutterFragment mFragment = <span class="keyword">new</span> FlutterFragment.NewEngineFragmentBuilder().url(<span class="string">"flutterFragment"</span>).build();</span><br><span class="line">    getSupportFragmentManager()</span><br><span class="line">        .beginTransaction()</span><br><span class="line">        .replace(R.id.fragment_stub, mFragment)</span><br><span class="line">        .commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Flutter-Boost-源码解析"><a href="#5-Flutter-Boost-源码解析" class="headerlink" title="5. Flutter Boost 源码解析"></a>5. Flutter Boost 源码解析</h2><p>本节主要简单分析一下 Flutter Boost 的原理，只有知根知底才能用得得心应手。由于篇幅问题，不可能全部的源码都分析一遍，本节只分析具有代表性的源码，其余的原理基本一致，留给读者自行阅读。</p><p>那本节就从 Dart 端切入，关注其中两个 api，一个是注册页面的 registerPageBuilders，另一个是打开页面的 open，看看 Flutter Boost 是如何实现它们的。</p><h3 id="5-1-注册页面"><a href="#5-1-注册页面" class="headerlink" title="5.1 注册页面"></a>5.1 注册页面</h3><p>我们在使用 Flutter Boost 的流程中，第一步是要在 Flutter 中注册页面，调用了 registerPageBuilders 函数，那我们来看一下这个函数是如何实现的。</p><p>在 flutter_boost.dart 文件中，我们很容易就找到了这个函数的入口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///Register a map builders</span></span><br><span class="line"><span class="keyword">void</span> registerPageBuilders(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, PageBuilder&gt; builders) &#123;</span><br><span class="line">  ContainerCoordinator.singleton.registerPageBuilders(builders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了 ContainerCoordinator 单例的 registerPageBuilders，那我们接着看 container_coordinator.dart 文件中这个函数的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, PageBuilder&gt; _pageBuilders = &lt;<span class="built_in">String</span>, PageBuilder&gt;&#123;&#125;;</span><br><span class="line">  PageBuilder _defaultPageBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Register page builder for a key.</span></span><br><span class="line"><span class="keyword">void</span> registerPageBuilder(<span class="built_in">String</span> pageName, PageBuilder builder) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pageName != <span class="keyword">null</span> &amp;&amp; builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    _pageBuilders[pageName] = builder;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 PageBuilder 我们可以找到定义，是一个 Widget，那么这个函数其实就将我们注册的 Widget 塞到一个 Map 里，而我们指定的路由名，就是它的 key。那我们接着要关注的是 _pageBuilders 定义好之后会怎么被使用？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BoostContainerSettings _createContainerSettings(</span><br><span class="line">      <span class="built_in">String</span> name, <span class="built_in">Map</span> params, <span class="built_in">String</span> pageId) &#123;</span><br><span class="line">    Widget page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BoostContainerSettings routeSettings = BoostContainerSettings(</span><br><span class="line">        uniqueId: pageId,</span><br><span class="line">        name: name,</span><br><span class="line">        params: params,</span><br><span class="line">        builder: (BuildContext ctx) &#123;</span><br><span class="line">          <span class="comment">//Try to build a page using keyed builder.</span></span><br><span class="line">          <span class="keyword">if</span> (_pageBuilders[name] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            page = _pageBuilders[name](name, params, pageId);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//Build a page using default builder.</span></span><br><span class="line">          <span class="keyword">if</span> (page == <span class="keyword">null</span> &amp;&amp; _defaultPageBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            page = _defaultPageBuilder(name, params, pageId);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">assert</span>(page != <span class="keyword">null</span>);</span><br><span class="line">          Logger.log(<span class="string">'build widget:$page for page:$name($pageId)'</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> page;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> routeSettings;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以发现，它在 _createContainerSettings 中 build widget 之后返回一个 routeSetting，该变量在 _nativeContainerWillShow 中被 pushContainer 调用，而 _nativeContainerWillShow 会在 _onMethodCall 中被调用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> _nativeContainerWillShow(<span class="built_in">String</span> name, <span class="built_in">Map</span> params, <span class="built_in">String</span> pageId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FlutterBoost.containerManager?.containsContainer(pageId) != <span class="keyword">true</span>) &#123;</span><br><span class="line">      FlutterBoost.containerManager</span><br><span class="line">          ?.pushContainer(_createContainerSettings(name, params, pageId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">dynamic</span>&gt; _onMethodCall(MethodCall call) &#123;</span><br><span class="line">    Logger.log(<span class="string">"onMetohdCall <span class="subst">$&#123;call.method&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (call.method) &#123;</span><br><span class="line">      <span class="comment">// 省略无关代码</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">"willShowPageContainer"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">String</span> pageName = call.arguments[<span class="string">"pageName"</span>];</span><br><span class="line">          <span class="built_in">Map</span> params = call.arguments[<span class="string">"params"</span>];</span><br><span class="line">          <span class="built_in">String</span> uniqueId = call.arguments[<span class="string">"uniqueId"</span>];</span><br><span class="line">          _nativeContainerWillShow(pageName, params, uniqueId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两段代码的作用是当 Dart 端监听到来自 Native 的通信之后，如果 Native 传递了一个要打开一个页面容器的信息（willShowPageContainer）之后，FlutterBoost 的容器管理器就会根据用户注册配置的路由页面去打开一个新的容器。而这里的 pushContainer 主要做一些路由管理和绑定监听等操作，我们就不再细看这部分的逻辑了，主要还是看看 _onMethodCall 的 Native 与 Dart 的互相通信。</p><h3 id="5-2-通信"><a href="#5-2-通信" class="headerlink" title="5.2 通信"></a>5.2 通信</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ContainerCoordinator(BoostChannel channel) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_instance == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    channel.addEventListener(<span class="string">"lifecycle"</span>,</span><br><span class="line">        (<span class="built_in">String</span> name, <span class="built_in">Map</span> arguments) =&gt; _onChannelEvent(arguments));</span><br><span class="line"></span><br><span class="line">    channel.addMethodHandler((MethodCall call) =&gt; _onMethodCall(call));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Flutter Boost 中负责通信的是 BoostChannel，它的本质上是 MethodChannel 的一层封装，而 MethodChannel 是 Native 与 Flutter 通信的方案之一，有兴趣的同学可以自己查阅 MethodChannel 相关的资料加以了解。</p><p><img src="https://pic4.zhimg.com/80/v2-31df6b737954e158dabe0f573c34eaab_720w.jpg" alt="img"></p><blockquote><p>可以阅读 Flutter 官网对 MethodChannel 的介绍：<a href="https://link.zhihu.com/?target=https%3A//flutter.dev/docs/development/platform-integration/platform-channels" target="_blank" rel="noopener">https://flutter.dev/docs/development/platform-integration/platform-channels</a></p></blockquote><h3 id="5-3-打开页面"><a href="#5-3-打开页面" class="headerlink" title="5.3 打开页面"></a>5.3 打开页面</h3><p>最后我们再来看一个打开页面的函数 open，它的实现在库中也容易找到：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">Map</span>&lt;<span class="keyword">dynamic</span>, <span class="keyword">dynamic</span>&gt;&gt; open(<span class="built_in">String</span> url,</span><br><span class="line">      &#123;<span class="built_in">Map</span>&lt;<span class="keyword">dynamic</span>, <span class="keyword">dynamic</span>&gt; urlParams, <span class="built_in">Map</span>&lt;<span class="keyword">dynamic</span>, <span class="keyword">dynamic</span>&gt; exts&#125;) &#123;</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="keyword">dynamic</span>, <span class="keyword">dynamic</span>&gt; properties = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="keyword">dynamic</span>, <span class="keyword">dynamic</span>&gt;();</span><br><span class="line">    properties[<span class="string">"url"</span>] = url;</span><br><span class="line">    properties[<span class="string">"urlParams"</span>] = urlParams;</span><br><span class="line">    properties[<span class="string">"exts"</span>] = exts;</span><br><span class="line">    <span class="keyword">return</span> channel.invokeMethod&lt;<span class="built_in">Map</span>&lt;<span class="keyword">dynamic</span>, <span class="keyword">dynamic</span>&gt;&gt;(<span class="string">'openPage'</span>, properties);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以发现，它的工作其实就是包装好参数后把 openPage 的消息发送给 Native。那我们再来看看 Native 侧接受到这个消息之后作何处理吧！在 Android 侧的 Flutter Boost 源码中可以找到 FlutterBoostPlugin.java 这个文件，其中有 MethodChannel 的逻辑来监听 Dart 侧的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoostMethodHandler</span> <span class="keyword">implements</span> <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall methodCall, <span class="keyword">final</span> MethodChannel.Result result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            FlutterViewContainerManager mManager = (FlutterViewContainerManager) FlutterBoost.instance().containerManager();</span><br><span class="line">            <span class="keyword">switch</span> (methodCall.method) &#123;</span><br><span class="line">                <span class="comment">// 省略无关的分支</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"openPage"</span>: &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Map&lt;String, Object&gt; params = methodCall.argument(<span class="string">"urlParams"</span>);</span><br><span class="line">                        Map&lt;String, Object&gt; exts = methodCall.argument(<span class="string">"exts"</span>);</span><br><span class="line">                        String url = methodCall.argument(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line">                        mManager.openContainer(url, params, exts, <span class="keyword">new</span> FlutterViewContainerManager.OnResult() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Map&lt;String, Object&gt; rlt)</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    result.success(rlt);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        result.error(<span class="string">"open page error"</span>, t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    result.notImplemented();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在收到来自 Dart 的 openPage 消息后，Android 侧的容器管理器（FlutterViewContainerMananger）会根据 Dart 侧携带来的配置数据打开一个容器，而这个 openContainer 通过阅读源码，可以发现它最后是一个抽象方法，需要我们自己在业务侧实现。回看我们在 3.2 节中在 Android 中初始化 Flutter Boost 第一步工作，做的就是实现这个 openContainer，而它最后交由我们封装的 PageRouter 工具类来实现了，即 context.startActivity()。</p><p>至此，我们在 Android 工程中集成了 Flutter Boost 来实现 Flutter 在 Android 项目中的混合开发。本文只是初步分析了下 Flutter Boost 的源码，后续有机会会补上详细的分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/alibaba/flutter_boost&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Boost&lt;/a&gt; 是闲鱼团队开发的一个 Flutter 混合开发框架，项目背景可以看看闲鱼的这篇文章：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU4MDUxOTI5NA%3D%3D%26mid%3D2247484367%26idx%3D1%26sn%3Dfcbc485f068dae5de9f68d52607ea08f%26chksm%3Dfd54d7deca235ec86249a9e3714ec18be8b2d6dc580cae19e4e5113533a6c5b44dfa5813c4c3%26scene%3D0%26subscene%3D131%26clicktime%3D1551942425%26ascene%3D7%26devicetype%3Dandroid-28%26version%3D2700033b%26nettype%3Dctnet%26abtest_cookie%3DBAABAAoACwASABMABAAklx4AVpkeAMSZHgDWmR4AAAA%3D%26lang%3Dzh_CN%26pass_ticket%3D1qvHqOsbLBHv3wwAcw577EHhNjg6EKXqTfnOiFbbbaw%3D%26wx_header%3D1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;码上用它开始Flutter混合开发——FlutterBoost&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;文章中主要讲述了多引擎存在一些实际问题，所以闲鱼目前采用的混合方案是共享同一个引擎的方案。而 Flutter Boost 的 Feature 如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可复用通用型混合方案&lt;/li&gt;
&lt;li&gt;支持更加复杂的混合模式，比如支持主页Tab这种情况&lt;/li&gt;
&lt;li&gt;无侵入性方案：不再依赖修改Flutter的方案&lt;/li&gt;
&lt;li&gt;支持通用页面生命周期&lt;/li&gt;
&lt;li&gt;统一明确的设计概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flutter Boost 采用共享引擎的模式来实现，主要思路是由 Native 容器 Container 通过消息驱动 Flutter 页面容器 Container，从而达到 Native Container 与 Flutter Container 的同步目的。简单的理解，闲鱼想做到把 Flutter 容器做成浏览器的感觉。填写一个页面地址，然后由容器去管理页面的绘制。在 Native 侧我们只需要关心如果初始化容器，然后设置容器对应的页面标志即可。&lt;/p&gt;
&lt;p&gt;鉴于网上没有相关的接入文档和使用教程，我这几天也恰好抽空研究了一下，遂整理成文，仅供参考。由于篇幅原因，本文只研究 Android 端的接入与源码，iOS 的部分后续有机会则补充文章来讲解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：本文接入的 Flutter Boost 版本为 1.12.13，对应支持的 Flutter SDK 版本为 1.12.13-hotfixes，是目前最新的版本。但 Flutter Boost 版本更新之后，接入方式和使用方式可能会有一些改变，故参考本文时请认准 1.12.13 版本。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>FlutterUnit开源篇</title>
    <link href="https://zhangmiao.cc/posts/d75d6183.html"/>
    <id>https://zhangmiao.cc/posts/d75d6183.html</id>
    <published>2020-04-24T09:36:43.000Z</published>
    <updated>2020-06-03T10:30:01.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FlutterUnit-下载体验"><a href="#FlutterUnit-下载体验" class="headerlink" title="FlutterUnit 下载体验:"></a>FlutterUnit 下载体验:</h3><table><thead><tr><th>FlutterUnit.apk 下载</th><th>FlutterUnit mac版 下载</th><th>Github仓库地址</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/5/10/171fc4325dbf90b0?w=300&h=390&f=png&s=23688" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/5/4/171e051a0d2cbf37?w=300&h=390&f=png&s=24001" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/5/4/171e051a0cd9efd7?w=300&h=390&f=png&s=7596" alt></td></tr></tbody></table><ul><li><p>Android下载链接: <a href="http://photo.toly1994.com/release/FlutterUnit.apk" target="_blank" rel="noopener">http://photo.toly1994.com/release/FlutterUnit.apk</a></p></li><li><p>Mac下载链接: <a href="http://photo.toly1994.com/release$flutter_unit_mac.zip" target="_blank" rel="noopener">http://photo.toly1994.com/release$flutter_unit_mac.zip</a></p></li><li><p>✨ <a href="https://github.com/toly1994328/FlutterUnit/tree/flutter_unit_mac" target="_blank" rel="noopener">Flutter Unit mac版支持 </a></p></li></ul><hr><blockquote><p>当前Flutter 版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1@toly ~ % flutter --version</span><br><span class="line">Flutter 1.17.0 • channel stable • https://github.com/flutter/flutter.git</span><br><span class="line">Framework • revision e6b34c2b5c (5 days ago) • 2020-05-02 11:39:18 -0700</span><br><span class="line">Engine • revision 540786dd51</span><br><span class="line">Tools • Dart 2.8.1</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Flutter-Unit-周边"><a href="#Flutter-Unit-周边" class="headerlink" title="Flutter Unit 周边"></a>Flutter Unit 周边</h4><ul><li>🔥 <a href="http://king.toly1994.com/FlutterUnit_update.html" target="_blank" rel="noopener">Flutter Unit 更新记录 </a></li></ul><hr><h3 id="一、组件的展示页面"><a href="#一、组件的展示页面" class="headerlink" title="一、组件的展示页面"></a>一、组件的展示页面</h3><h4 id="1-210-组件收录"><a href="#1-210-组件收录" class="headerlink" title="1. 210+组件收录"></a>1. <code>210+组件收录</code></h4><blockquote><p>Flutter源码中的可用的组件一共350个左右，纷繁复杂，也没有明确的分类标准<br>FlutterUnit 对<code>大大小小，常用不常用</code>的组件能收的尽量收录。并<code>根据个人感觉进行评星</code><br><code>目前收录组件213个</code>，每个都有至少一个演示展现和代码展示。</p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175af35f63c8fb?w=1080&h=2340&f=jpeg&s=158267" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175b0c1c92a004?w=1080&h=2340&f=jpeg&s=161619" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175b0a95d5c549?w=1080&h=2340&f=jpeg&s=150406" alt></td></tr><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175af9b09f76f6?w=1080&h=2340&f=jpeg&s=153575" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175b0766ed455b?w=1080&h=2340&f=jpeg&s=166128" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175af6b9523083?w=1080&h=2340&f=jpeg&s=163290" alt></td></tr></tbody></table><hr><h4 id="2-组件详情页"><a href="#2-组件详情页" class="headerlink" title="2. 组件详情页"></a>2. 组件详情页</h4><blockquote><p><code>213个组件</code>全部都有详情页。对于重要的组件会详细展现<br>一般都会有某个演示对应的组件和属性,尽量做到细致，如果有需要补充，欢迎联系我。<br><code>最重要的是: 所有的演示展现都是Flutter的组件形成的，而非图片，这就意味着可操作性更高。</code></p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175c3f21476fc5?w=1080&h=2340&f=jpeg&s=67728" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175c44a1cfa94c?w=1080&h=2340&f=jpeg&s=92664" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175c4a7cd90126?w=1080&h=2340&f=jpeg&s=114306" alt></td></tr><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175c5171d0373f?w=1080&h=2340&f=jpeg&s=159437" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175c56ce136676?w=1080&h=2340&f=jpeg&s=87311" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175c61623c6462?w=1080&h=2340&f=jpeg&s=108215" alt></td></tr></tbody></table><hr><h4 id="3-组件的可操作性"><a href="#3-组件的可操作性" class="headerlink" title="3. 组件的可操作性"></a>3. 组件的可操作性</h4><blockquote><p>对一些操作交互的组件或有可操作性的某些组件，<code>提供操作演示</code></p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175df98f83e05c?w=362&h=724&f=gif&s=1061771" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175dcce9022ddc?w=362&h=724&f=gif&s=232124" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175de9b348a26a?w=362&h=724&f=gif&s=946647" alt></td></tr></tbody></table><hr><h4 id="4-相关组件的关联切换"><a href="#4-相关组件的关联切换" class="headerlink" title="4. 相关组件的关联切换"></a>4. 相关组件的关联切换</h4><blockquote><p><code>相关组件通过link to 可以进行切换, 满足你的探索欲。</code><br>如果有的关联未加入，欢迎联系我，对我来说，加个数字就行了。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175ea0ea610669?w=610&h=226&f=png&s=37961" alt></p><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175e8c2a46e1f3?w=362&h=724&f=gif&s=471182" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175e921dfc5c81?w=362&h=724&f=gif&s=658708" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17175e968c4f68e4?w=362&h=724&f=gif&s=300803" alt></td></tr></tbody></table><hr><h4 id="5-代码的查看和分享"><a href="#5-代码的查看和分享" class="headerlink" title="5. 代码的查看和分享"></a>5. 代码的查看和分享</h4><blockquote><p>激动人心的是，你可以通过右侧的图标<code>展开/隐藏 实现下面效果的代码</code><br>并且<code>支持分享</code>，如果你想亲自体验，so，easy ! 而且<code>代码高亮样式可以自定义</code>。</p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171760369b9ae9d6?w=362&h=724&f=gif&s=1207409" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717603ad9119f2a?w=362&h=724&f=gif&s=1064037" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717604b10154271?w=362&h=724&f=gif&s=2849830" alt></td></tr></tbody></table><hr><h3 id="二、全局配置"><a href="#二、全局配置" class="headerlink" title="二、全局配置"></a>二、全局配置</h3><h4 id="1-颜色主题"><a href="#1-颜色主题" class="headerlink" title="1. 颜色主题"></a>1. 颜色主题</h4><blockquote><p>只提供八种颜色，可在<code>右滑菜单页</code>的<code>我的主题</code>配置,<code>可以拓展</code></p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171760c51633383d?w=1080&h=2340&f=jpeg&s=94977" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171760cbc7d0ddba?w=1080&h=2340&f=jpeg&s=89001" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171760b8c24c188f?w=1080&h=2340&f=jpeg&s=168263" alt></td></tr></tbody></table><hr><h4 id="2-字体配置"><a href="#2-字体配置" class="headerlink" title="2.字体配置"></a>2.字体配置</h4><blockquote><p>支持全局字体设置,<code>可以拓展</code></p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717615741f8d2e3?w=1080&h=2340&f=png&s=167438" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171761667bbf6051?w=1080&h=2340&f=png&s=808002" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717617b8ab59421?w=1080&h=2340&f=png&s=796618" alt></td></tr></tbody></table><hr><h4 id="3-item样式设置"><a href="#3-item样式设置" class="headerlink" title="3.item样式设置"></a>3.item样式设置</h4><blockquote><p>支持item样式设置，<code>可以拓展，支持征集</code>，详见<code>Flutter Unit 1.0 征集方案</code></p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717620037fd9a50?w=1080&h=2340&f=jpeg&s=105051" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717620161fa89ec?w=1080&h=2340&f=jpeg&s=158327" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171762026eb8656d?w=1080&h=2340&f=jpeg&s=146688" alt></td></tr></tbody></table><hr><h4 id="4-代码面板风格设置"><a href="#4-代码面板风格设置" class="headerlink" title="4.代码面板风格设置"></a>4.代码面板风格设置</h4><blockquote><p>支持代码风格设置，<code>可以拓展，支持征集</code>，详见<code>Flutter Unit 1.0 征集方案</code></p></blockquote><table><thead><tr><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717628b5fe1591c?w=1080&h=759&f=png&s=105023" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717629001ade9b0?w=1080&h=773&f=png&s=102672" alt></td></tr></tbody></table><hr><h3 id="三、搜索与收藏功能"><a href="#三、搜索与收藏功能" class="headerlink" title="三、搜索与收藏功能"></a>三、搜索与收藏功能</h3><h4 id="1-搜索功能"><a href="#1-搜索功能" class="headerlink" title="1.搜索功能"></a>1.搜索功能</h4><blockquote><p>由于Flutter中Widget比较杂乱，不太好分类，所以搜索是非常重要的<br>另外可以根据星级进行过滤，支持多选。目前正在考虑根据功能分类，之后会有所完善。</p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171775fc594e4605?w=1080&h=2340&f=png&s=265281" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171775fd99268a78?w=1080&h=2340&f=png&s=424599" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171775fefef50fb9?w=1080&h=2340&f=png&s=414437" alt></td></tr></tbody></table><hr><h4 id="2-搜藏功能"><a href="#2-搜藏功能" class="headerlink" title="2.搜藏功能"></a>2.搜藏功能</h4><blockquote><p>搜藏页做得比较简陋，后面打算做收藏夹，可以自己创建的那种。</p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17177668aa7fd135?w=1080&h=2340&f=png&s=640245" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/17177665c53256b4?w=1080&h=2340&f=png&s=797902" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/1717765ec688731c?w=1080&h=2340&f=png&s=272421" alt></td></tr></tbody></table><blockquote><p><code>FlutterUnit 1.0</code>目前基本就是这么多功能，可以在Github中下载打包后的apk玩玩<br>希望能对你的Flutter学习有所帮助。</p></blockquote><hr><h4 id="3-关于我与项目"><a href="#3-关于我与项目" class="headerlink" title="3.关于我与项目"></a>3.关于我与项目</h4><blockquote><p>不多说，都在图里。</p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171777c67ed0c205?w=1080&h=2340&f=png&s=1272888" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171777c8ccfce16b?w=1080&h=2340&f=png&s=1105006" alt></td><td><img src="https://user-gold-cdn.xitu.io/2020/4/14/171777caed85b26a?w=1080&h=2340&f=png&s=1190414" alt></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="Flutter-Unit-Bug-Feature"><a href="#Flutter-Unit-Bug-Feature" class="headerlink" title="Flutter Unit  Bug - Feature"></a>Flutter Unit  Bug - Feature</h3><ul><li><code>2020-4-16</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed &quot;     修改样式无法点击的问题。</span><br><span class="line">fixed &quot;     一些已知文案的错误。</span><br><span class="line">fixed &quot;     hero动画闪现不同步问题。</span><br></pre></td></tr></table></figure><hr><ul><li><code>2020-4-17</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fixed &quot;     进入收藏页，再回到首页，顶部显示不同步的问题。</span><br><span class="line">fixed &quot;     主页item双击黑屏问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">feature &quot;   支持详情页【相关链接的栈管理】,</span><br><span class="line">        &quot;   即: 点击多个链接，不直接返回主页.</span><br></pre></td></tr></table></figure><hr><ul><li><code>2020-4-18</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feature &quot;   小彩蛋: 【长按】底部栏【最左侧按钮】,打开左边菜单栏</span><br><span class="line">        &quot;   【长按】底部栏【最右侧按钮】,打开右边菜单栏</span><br><span class="line"></span><br><span class="line">fixed &quot;     收藏集的AppBar背景色同主页选中色。</span><br></pre></td></tr></table></figure><hr><ul><li><code>2020-4-19</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimize &quot;   添加收录【LayoutBuilder】组件</span><br><span class="line">optimize &quot;   添加收录【IgnorePointer】组件</span><br><span class="line">optimize &quot;   添加收录【AbsorbPointer】组件</span><br><span class="line">optimize &quot;   添加收录【BackdropFilter】组件</span><br></pre></td></tr></table></figure><p>作者：张风捷特烈</p><p>链接：<a href="https://juejin.im/post/5e94e4d3f265da480836b943" target="_blank" rel="noopener">https://juejin.im/post/5e94e4d3f265da480836b943</a></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;FlutterUnit-下载体验&quot;&gt;&lt;a href=&quot;#FlutterUnit-下载体验&quot; class=&quot;headerlink&quot; title=&quot;FlutterUnit 下载体验:&quot;&gt;&lt;/a&gt;FlutterUnit 下载体验:&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;FlutterUnit.apk 下载&lt;/th&gt;
&lt;th&gt;FlutterUnit mac版 下载&lt;/th&gt;
&lt;th&gt;Github仓库地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/10/171fc4325dbf90b0?w=300&amp;h=390&amp;f=png&amp;s=23688&quot; alt&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/4/171e051a0d2cbf37?w=300&amp;h=390&amp;f=png&amp;s=24001&quot; alt&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/4/171e051a0cd9efd7?w=300&amp;h=390&amp;f=png&amp;s=7596&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Android下载链接: &lt;a href=&quot;http://photo.toly1994.com/release/FlutterUnit.apk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://photo.toly1994.com/release/FlutterUnit.apk&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mac下载链接: &lt;a href=&quot;http://photo.toly1994.com/release$flutter_unit_mac.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://photo.toly1994.com/release$flutter_unit_mac.zip&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;✨ &lt;a href=&quot;https://github.com/toly1994328/FlutterUnit/tree/flutter_unit_mac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Unit mac版支持 &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;当前Flutter 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a1@toly ~ % flutter --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Flutter 1.17.0 • channel stable • https://github.com/flutter/flutter.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Framework • revision e6b34c2b5c (5 days ago) • 2020-05-02 11:39:18 -0700&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Engine • revision 540786dd51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Tools • Dart 2.8.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>flutter ListView取消头部空白</title>
    <link href="https://zhangmiao.cc/posts/c3648888.html"/>
    <id>https://zhangmiao.cc/posts/c3648888.html</id>
    <published>2020-04-18T10:08:25.000Z</published>
    <updated>2020-04-18T10:09:32.557Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ListView头部有一段空白区域，是因为当ListView没有和AppBar一起使用时，头部会有一个padding，为了去掉padding，可以使用MediaQuery.removePadding:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Widget _rubbishList()&#123;</span><br><span class="line">    <span class="keyword">return</span> MediaQuery.removePadding(</span><br><span class="line">        removeTop: <span class="keyword">true</span>,</span><br><span class="line">        context:  context,</span><br><span class="line">        child: Container(</span><br><span class="line">            margin: EdgeInsets.only(left: <span class="number">20</span>,right: <span class="number">20</span>),</span><br><span class="line">            height: ScreenUtil().setHeight(<span class="number">700</span>),</span><br><span class="line">            child: ListView.builder(</span><br><span class="line">                itemCount: rubbishList.length,</span><br><span class="line">                itemBuilder: (context,index)&#123;</span><br><span class="line">                  <span class="keyword">return</span> _cardItem(index);</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ListView头部有一段空白区域，是因为当ListView没有和AppBar一起使用时，头部会有一个padding，为了去掉padding，可以使用MediaQuery.removePadding:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Widget _rubbishList()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; MediaQuery.removePadding(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        removeTop: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        context:  context,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        child: Container(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            margin: EdgeInsets.only(left: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,right: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            height: ScreenUtil().setHeight(&lt;span class=&quot;number&quot;&gt;700&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            child: ListView.builder(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                itemCount: rubbishList.length,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                itemBuilder: (context,index)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _cardItem(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter常见数据类型及数据类型转换</title>
    <link href="https://zhangmiao.cc/posts/87ca1d5.html"/>
    <id>https://zhangmiao.cc/posts/87ca1d5.html</id>
    <published>2020-04-08T03:06:08.000Z</published>
    <updated>2020-04-08T03:32:08.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>既然 Dart 是一门语言，那么就和我们所知道语言一样，有基本的数据类型以及常见的流程处理语法，那么我们就来了解下。</p><p>Dart 的所有东西都是对象，包括数字，函数等。它们都继承自 Object ，默认是都是 null（包括数字），所以数字，字符串都可以调用各种方法。</p><h2 id="常亮与变量"><a href="#常亮与变量" class="headerlink" title="常亮与变量"></a>常亮与变量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用 var 声明变量，可赋予不同类型的值；未初始化时，默认值为 null ；使用 final 声明一个只能赋值一次的变量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 声明一个变量 a</span></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">print</span>(a);   <span class="comment">// 打印 a 的值，显示为 null</span></span><br><span class="line"> </span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">print</span>(a);   <span class="comment">//  打印出来的结果为 10</span></span><br><span class="line"> </span><br><span class="line">  a = <span class="string">"测试字符串"</span>;</span><br><span class="line">  <span class="built_in">print</span>(a);   <span class="comment">// 打印出来的结果为 测试字符串</span></span><br><span class="line"> </span><br><span class="line">  a = <span class="number">30</span>;</span><br><span class="line">  <span class="built_in">print</span>(a);   <span class="comment">//  打印出来的结果为 30</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> b = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>; <span class="comment">// 这个会报错，有提示： [dart] 'b', a final variable, can only be set once.</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在 dart 中使用 const 声明常量；使用 const 声明的必须是编译期常量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">const</span> a  = <span class="number">10</span>;</span><br><span class="line">  a = <span class="number">20</span>;   <span class="comment">// 这里也会报错：[dart] Constant variables can't be assigned a value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>　　<p>在上面我们可以看到 dart 的一些简单的语法。其实和 js 蛮像，声明的变量的数据类型是随便去改变的，没有一个固定的数据类型（例如：java 这种语言）。其次就是 final 和 const 都可以声明变量，并且声明了变量之后都不能修改。</p><p>这里简单的说下 final 与 const 的区别：</p><p>final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 const 要求在声明时初始化，并且赋值必需为编译时常量。</p><h2 id="Dart中的内置类型"><a href="#Dart中的内置类型" class="headerlink" title="Dart中的内置类型"></a>Dart中的内置类型</h2><p>在Dart 有几种内置的数据类型：数值型-Number、布尔型-boolean、键值对-Map、字符串-String、列表-List、其他类型-Runes、Symbols</p><h2 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h2><p>Dart 中只提供了两种类型：</p><p>num<br>1、整形int<br>2、浮点型double</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">num</span> a = <span class="number">10</span>;   <span class="comment">// 整形</span></span><br><span class="line">  a = <span class="number">20.1</span>;     <span class="comment">// 浮点型</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">  i = <span class="number">10.1</span>;     <span class="comment">// 这个地方会报错，因为将 int 型的数据改为 double 型</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">double</span> d = <span class="number">20.1</span>;</span><br><span class="line">  d = <span class="number">20</span>;       <span class="comment">// 这个地方会报错，因为将 double 型的数据改为 int 型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><p>从上面可以看到如果是使用 num 声明的变量，可以随意的转换类型，但是如果是使用了int 或者 double 明确的声明，那么就不能转换了</p><h2 id="数值型的操作"><a href="#数值型的操作" class="headerlink" title="数值型的操作"></a>数值型的操作</h2><p>运算符： +、 - 、* 、/ 、 ~/ 、 %</p><p>常用属性： isNaN、isEven、isOdd</p><p>常用方法：abs()、round()、floorl()、ceil()、toInt()、toDouble()</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于常用的方法在其他语言中都有，就不过去的赘述，下面列出一些特殊的</span></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">double</span> d = <span class="number">20.1</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">print</span>(i/d);   <span class="comment">// 0.49751243781094523</span></span><br><span class="line">  <span class="built_in">print</span>(i~/d);  <span class="comment">// 0  这个操作是取整</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">print</span>( i.isOdd );   <span class="comment">// 判断是奇数</span></span><br><span class="line">  <span class="built_in">print</span>( i.isEven );  <span class="comment">// 判断是偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些常见的转换"><a href="#一些常见的转换" class="headerlink" title="一些常见的转换"></a>一些常见的转换</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">assert</span>(one == <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">'1.1'</span>);</span><br><span class="line"><span class="keyword">assert</span>(onePointOne == <span class="number">1.1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"><span class="keyword">assert</span>(oneAsString == <span class="string">'1'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(piAsString == <span class="string">'3.14'</span>);</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="在-dart-中居然可以使用-单引号-和-双引号声明字符串。这两种方式都可以。"><a href="#在-dart-中居然可以使用-单引号-和-双引号声明字符串。这两种方式都可以。" class="headerlink" title="在 dart 中居然可以使用 单引号 和 双引号声明字符串。这两种方式都可以。"></a>在 dart 中居然可以使用 单引号 和 双引号声明字符串。这两种方式都可以。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">String</span> string = <span class="string">'单引号声明字符串'</span>;</span><br><span class="line">  <span class="built_in">String</span> string1 = <span class="string">"双引号声明字符串"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-String-中单、双引号互相嵌套的情况"><a href="#在-String-中单、双引号互相嵌套的情况" class="headerlink" title="在 String 中单、双引号互相嵌套的情况"></a>在 String 中单、双引号互相嵌套的情况</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">String</span> str = <span class="string">'单引号中的"双引号"'</span>;</span><br><span class="line">  <span class="built_in">String</span> str1 = <span class="string">"双引号中的'单引号'"</span>;</span><br><span class="line">  <span class="built_in">print</span>(str);</span><br><span class="line">  <span class="built_in">print</span>(str1);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">String</span> str2 = <span class="string">'单引号中的 \'单引号\' '</span>;</span><br><span class="line">  <span class="built_in">String</span> str3 = <span class="string">"双引号中的 \"双引号\" "</span>;</span><br><span class="line">  <span class="built_in">print</span>(str2);</span><br><span class="line">  <span class="built_in">print</span>(str3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串拼接的方式"><a href="#字符串拼接的方式" class="headerlink" title="字符串拼接的方式"></a>字符串拼接的方式</h3><h3 id="下面列出-dart-中拼接字符串的各种骚操作（黑魔法）。"><a href="#下面列出-dart-中拼接字符串的各种骚操作（黑魔法）。" class="headerlink" title="下面列出 dart 中拼接字符串的各种骚操作（黑魔法）。"></a>下面列出 dart 中拼接字符串的各种骚操作（黑魔法）。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="comment">// 使用的是空格拼接，多个空格也可以</span></span><br><span class="line">  <span class="built_in">String</span> str1 = <span class="string">'单引号空格字符串'</span> <span class="string">'拼接'</span>        <span class="string">'~'</span>;    <span class="comment">// 单引号字符串空格拼接~</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 使用换行符以及空格</span></span><br><span class="line">  <span class="built_in">String</span> str2 = <span class="string">'单引号符串'</span></span><br><span class="line">    <span class="string">'换行了'</span> <span class="string">'再加空格'</span> <span class="string">'拼接'</span>;       <span class="comment">// 单引号符串换行了再加空格拼接</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 单双引号 空格拼接</span></span><br><span class="line">  <span class="built_in">String</span> str3 = <span class="string">"单双引号空格字符串"</span> <span class="string">'拼接'</span>        <span class="string">"~"</span>;    <span class="comment">// 单双引号字符串空格拼接~</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 单双引号 换行符以及空格</span></span><br><span class="line">  <span class="built_in">String</span> str4 = <span class="string">"单双引号符串"</span></span><br><span class="line">    <span class="string">'换行了'</span> <span class="string">'再加空格'</span> <span class="string">'拼接'</span>;       <span class="comment">// 单双引号符串换行了再加空格拼接</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">String</span> str5 = <span class="string">'''</span></span><br><span class="line"><span class="string">    使用3个单引号、</span></span><br><span class="line"><span class="string">    看到我使用了么</span></span><br><span class="line"><span class="string">  '''</span>;</span><br><span class="line">           </span><br><span class="line"> </span><br><span class="line">  <span class="built_in">String</span> str6 = <span class="string">"""</span></span><br><span class="line"><span class="string">    使用3个双引号、</span></span><br><span class="line"><span class="string">    看到我使用了么</span></span><br><span class="line"><span class="string">  """</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">String</span> str7 = <span class="string">"算了，还是正常一点"</span> + <span class="string">"，使用 + 来拼接"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从上面可以看到-dart-中可以使用空格来做为拼接。所以我们继续研究下。"><a href="#从上面可以看到-dart-中可以使用空格来做为拼接。所以我们继续研究下。" class="headerlink" title="从上面可以看到 dart 中可以使用空格来做为拼接。所以我们继续研究下。"></a>从上面可以看到 dart 中可以使用空格来做为拼接。所以我们继续研究下。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 拼接字符串， 输出：单引号空格 或者 双引号空格</span></span><br><span class="line">  <span class="built_in">String</span> blockStr = <span class="string">'单引号'</span><span class="string">'空格'</span>;</span><br><span class="line">  <span class="built_in">String</span> blockStr1 = <span class="string">'单引号'</span> <span class="string">'空格'</span>;</span><br><span class="line">  <span class="built_in">String</span> blockStr2 = <span class="string">"双引号"</span><span class="string">"空格"</span>;</span><br><span class="line">  <span class="built_in">String</span> blockStr3 = <span class="string">"双引号"</span> <span class="string">"空格"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 下面这两种情况会报错</span></span><br><span class="line">  <span class="comment">// String blockStr4 = '单引号''''空格';</span></span><br><span class="line">  <span class="comment">// String blockStr5 = "双引号""""空格";</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 测试中间添加字符</span></span><br><span class="line">  <span class="built_in">String</span> blockStr6 = <span class="string">'单引号'</span><span class="string">'_'</span><span class="string">'空格'</span>;   <span class="comment">// 输出：单引号_空格</span></span><br><span class="line">  <span class="built_in">String</span> blockStr7 = <span class="string">"双引号"</span><span class="string">"#"</span><span class="string">"空格"</span>;   <span class="comment">// 注意不能使用 $，$会报错, 输出：单引号#空格</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 单双引号混合使用</span></span><br><span class="line">  <span class="built_in">String</span> blockStr8 = <span class="string">'单""""引号'</span>;        <span class="comment">// 输出：单""""引号</span></span><br><span class="line">  <span class="built_in">String</span> blockStr9 = <span class="string">'单""_""引号'</span>;       <span class="comment">// 输出：单""_""引号</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 单双引号混合使用</span></span><br><span class="line">  <span class="built_in">String</span> blockStr10 = <span class="string">"双''''引号"</span>;        <span class="comment">// 输出：双''''引号</span></span><br><span class="line">  <span class="built_in">String</span> blockStr11 = <span class="string">"双''_''引号"</span>;       <span class="comment">// 输出：双''_''引号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达式-的使用"><a href="#表达式-的使用" class="headerlink" title="${表达式}的使用"></a>${表达式}的使用</h3><p>类似于JS中 ES6 上面的表达式的使用，感觉是相通的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">"测试字符串"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我们来验证字符串：<span class="subst">$&#123;str&#125;</span>"</span> <span class="string">"然后看看我们的 flag：<span class="subst">$&#123;flag&#125;</span>"</span>);</span><br><span class="line">  <span class="comment">// 最后输出的结果为：我们来验证字符串：测试字符串然后看看我们的 flag：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>assert 是语言内置的断言函数，仅在检查模式下有效<br>在开发过程中， 除非条件为真，否则会引发异常。(断言失败则程序立刻终止)。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否为空</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">assert</span>(fullName.isEmpty);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为0检查</span></span><br><span class="line"><span class="keyword">var</span> hitPoints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(hitPoints &lt;= <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检查是否为 null.</span></span><br><span class="line"><span class="keyword">var</span> unicorn;</span><br><span class="line"><span class="keyword">assert</span>(unicorn == <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检查是否为 NaN.</span></span><br><span class="line"><span class="keyword">var</span> iMeantToDoThis = <span class="number">0</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure><h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><h3 id="实例化-List-的方法如下"><a href="#实例化-List-的方法如下" class="headerlink" title="实例化 List 的方法如下"></a>实例化 List 的方法如下</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 使用构造创建</span></span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//创建一个int类型的list</span></span><br><span class="line">  <span class="built_in">List</span> intlist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建一个常量List， 不可以改变的List</span></span><br><span class="line">  <span class="built_in">List</span> constList = <span class="keyword">const</span>[<span class="number">10</span>, <span class="number">7</span>, <span class="number">23</span>];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dart-中数组常用的方法"><a href="#dart-中数组常用的方法" class="headerlink" title="dart 中数组常用的方法"></a>dart 中数组常用的方法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//  在数组中可以存放多个不同类型的对象</span></span><br><span class="line">  <span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'Flutter'</span>, <span class="keyword">true</span>];</span><br><span class="line">  <span class="built_in">print</span>(list);      <span class="comment">// 输出的结果：[1, 2, 3, Flutter, true]</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 修改数组下标为2 的值</span></span><br><span class="line">  list[<span class="number">2</span>] = <span class="string">'Dart'</span>;</span><br><span class="line">  <span class="built_in">print</span>(list);      <span class="comment">// 输出的结果：[1, 2, Dart, Flutter, true]</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取数组的长度</span></span><br><span class="line">  <span class="built_in">print</span>(list.length);   <span class="comment">// 输出的结果：5</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 向数组中添加元素</span></span><br><span class="line">  list.add(<span class="string">"value"</span>);</span><br><span class="line">  <span class="built_in">print</span>(list);        <span class="comment">// 输出的结果：[1, 2, Dart, Flutter, true, value]</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 向数组中的指定位置添加元素</span></span><br><span class="line">  list.insert(<span class="number">1</span>, <span class="string">'element'</span>); </span><br><span class="line">  <span class="built_in">print</span>(list);      <span class="comment">// 输出的结果：[1, element, 2, Dart, Flutter, true, value]</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 移除数组中的元素</span></span><br><span class="line">  list.remove(<span class="string">"value"</span>);</span><br><span class="line">  <span class="built_in">print</span>(list);      <span class="comment">// 输出的结果：[1, element, 2, Dart, Flutter, true]</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 移除数组中指定的元素</span></span><br><span class="line">  list.removeAt(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(list);      <span class="comment">// 输出的结果：[1, 2, Dart, Flutter, true]</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断数组中是否有某个元素</span></span><br><span class="line">  <span class="built_in">print</span>(list.indexOf(<span class="string">"element"</span>));   <span class="comment">// 输出结果：-1</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 可以使用 sort() 函数来排序, 但是由于我们使用定义的数组类型不一样，就不能使用</span></span><br><span class="line">  <span class="keyword">var</span> intlist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span> ,<span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 根据语法提示： List.sort([(int, int) → int compare]) → void</span></span><br><span class="line">  intlist.sort( (a, b) =&gt;  a.compareTo(b) );</span><br><span class="line">  <span class="built_in">print</span>(intlist);   <span class="comment">// 输出结果：[1, 2, 3, 5, 6]</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-集合"><a href="#map-集合" class="headerlink" title="map 集合"></a>map 集合</h2><h3 id="创建-Map-集合"><a href="#创建-Map-集合" class="headerlink" title="创建 Map 集合"></a>创建 Map 集合</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建Map</span></span><br><span class="line">  <span class="keyword">var</span> language = &#123;<span class="string">'fisrt'</span>: <span class="string">'dart'</span>, <span class="string">'second'</span>: <span class="string">'java'</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建不可变的 Map</span></span><br><span class="line">  <span class="keyword">var</span> constLanguage = <span class="keyword">const</span> &#123;<span class="string">'fisrt'</span>: <span class="string">'dart'</span>, <span class="string">'second'</span>: <span class="string">'java'</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过构造器创建</span></span><br><span class="line">  <span class="keyword">var</span> initLanguage = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-中常用的方法"><a href="#Map-中常用的方法" class="headerlink" title="Map 中常用的方法"></a>Map 中常用的方法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建Map</span></span><br><span class="line">  <span class="keyword">var</span> map = &#123;<span class="string">'fisrt'</span>: <span class="string">'dart'</span>, <span class="string">'second'</span>: <span class="string">'java'</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取长度</span></span><br><span class="line">  <span class="built_in">print</span>(map.length);    <span class="comment">// 输出结果：2</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断是否为空</span></span><br><span class="line">  <span class="built_in">print</span>(map.isEmpty);     <span class="comment">// 输出结果：false</span></span><br><span class="line">  <span class="built_in">print</span>(map.isNotEmpty);  <span class="comment">// 输出结果：true</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取到所有的 key</span></span><br><span class="line">  <span class="built_in">print</span>(map.keys);        <span class="comment">// 输出结果：(fisrt, second)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取到所有的 values</span></span><br><span class="line">  <span class="built_in">print</span>(map.values);      <span class="comment">// 输出结果：(dart, java)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断是否包含某个key</span></span><br><span class="line">  <span class="built_in">print</span>(map.containsKey(<span class="string">"key"</span>));    <span class="comment">// 输出结果：false</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断是否包含某个value</span></span><br><span class="line">  <span class="built_in">print</span>(map.containsValue(<span class="string">"key"</span>));    <span class="comment">// 输出结果：false</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 添加一个新的元素进去</span></span><br><span class="line">  map[<span class="string">'third'</span>] = <span class="string">'key'</span>;</span><br><span class="line">  <span class="built_in">print</span>(map);         <span class="comment">// 输出结果：&#123;fisrt: dart, second: java, third: key&#125;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 循环打印 代码提示：Map.forEach((String, String) → void f) → void</span></span><br><span class="line">  map.forEach( (key, value) =&gt;  getMap(key, value) );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> getMap(key, value)&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"key:<span class="subst">$&#123;key&#125;</span>, value:<span class="subst">$&#123;value&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="dynamic-关键字"><a href="#dynamic-关键字" class="headerlink" title="dynamic 关键字"></a>dynamic 关键字</h2><p>这个关键字就类似定义我们在 JS 中定义变量的情况。先看下面的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="comment">// a 的数据类型可以随意改变，这种类型就是 dynamic</span></span><br><span class="line">  <span class="keyword">var</span> a ;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  a = <span class="string">"dart"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 这里我们使用 dynamic 声明</span></span><br><span class="line">  <span class="keyword">dynamic</span> d = <span class="number">10</span>;</span><br><span class="line">  d = <span class="string">'dart'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;既然 Dart 是一门语言，那么就和我们所知道语言一样，有基本的数据类型以及常见的流程处理语法，那么我们就来了解下。&lt;/p&gt;
&lt;p&gt;Dart 的所有东西都是对象，包括数字，函数等。它们都继承自 Object ，默认是都是 null（包括数字），所以数字，字符串都可以调用各种方法。&lt;/p&gt;
&lt;h2 id=&quot;常亮与变量&quot;&gt;&lt;a href=&quot;#常亮与变量&quot; class=&quot;headerlink&quot; title=&quot;常亮与变量&quot;&gt;&lt;/a&gt;常亮与变量&lt;/h2&gt;&lt;h3 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h3&gt;&lt;p&gt;使用 var 声明变量，可赋予不同类型的值；未初始化时，默认值为 null ；使用 final 声明一个只能赋值一次的变量&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 声明一个变量 a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(a);   &lt;span class=&quot;comment&quot;&gt;// 打印 a 的值，显示为 null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(a);   &lt;span class=&quot;comment&quot;&gt;//  打印出来的结果为 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a = &lt;span class=&quot;string&quot;&gt;&quot;测试字符串&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(a);   &lt;span class=&quot;comment&quot;&gt;// 打印出来的结果为 测试字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(a);   &lt;span class=&quot;comment&quot;&gt;//  打印出来的结果为 30&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 这个会报错，有提示： [dart] &#39;b&#39;, a final variable, can only be set once.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;　　&lt;/p&gt;
&lt;h3 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h3&gt;&lt;p&gt;在 dart 中使用 const 声明常量；使用 const 声明的必须是编译期常量。&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; a  = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 这里也会报错：[dart] Constant variables can&#39;t be assigned a value.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>flutter抓包</title>
    <link href="https://zhangmiao.cc/posts/832de89a.html"/>
    <id>https://zhangmiao.cc/posts/832de89a.html</id>
    <published>2020-04-05T06:34:26.000Z</published>
    <updated>2020-04-05T06:36:53.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flutter抓包"><a href="#flutter抓包" class="headerlink" title="flutter抓包"></a>flutter抓包</h2><p>查看dio文档发现需要设置代理</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(dio.httpClientAdapter <span class="keyword">as</span> DefaultHttpClientAdapter).onHttpClientCreate = (HttpClient client) &#123;</span><br><span class="line">       client.findProxy = (uri) &#123;</span><br><span class="line">         <span class="comment">//proxy all request to localhost:8888</span></span><br><span class="line">         <span class="keyword">return</span> <span class="string">"PROXY 192.168.8.84:8888"</span>;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// 你也可以自己创建一个新的HttpClient实例返回。</span></span><br><span class="line">       <span class="comment">// return new HttpClient(SecurityContext);</span></span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flutter抓包&quot;&gt;&lt;a href=&quot;#flutter抓包&quot; class=&quot;headerlink&quot; title=&quot;flutter抓包&quot;&gt;&lt;/a&gt;flutter抓包&lt;/h2&gt;&lt;p&gt;查看dio文档发现需要设置代理&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(dio.httpClientAdapter &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; DefaultHttpClientAdapter).onHttpClientCreate = (HttpClient client) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       client.findProxy = (uri) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//proxy all request to localhost:8888&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;PROXY 192.168.8.84:8888&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;// 你也可以自己创建一个新的HttpClient实例返回。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;// return new HttpClient(SecurityContext);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
</feed>
