<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2021-05-18T02:48:01.582Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android12上全新的应用启动画面</title>
    <link href="https://zhangmiao.cc/posts/8c53fca7.html"/>
    <id>https://zhangmiao.cc/posts/8c53fca7.html</id>
    <published>2021-05-18T02:39:24.000Z</published>
    <updated>2021-05-18T02:48:01.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>早期的Android上App的启动速度常为人诟病，如今的启动表现已不逊iOS。Google针对系统的不断优化绝对功不可没，从8.0独立出来的<code>SplashWindow</code>，到12上推出的全新<code>SplashScreen</code>。</p></blockquote><p>在App的主要内容展示之前，按照需求的不同，或多或少会先展示这样几个画面。</p><table><thead><tr><th>画面</th><th>用途</th></tr></thead><tbody><tr><td>Splash Screen</td><td>展示品牌Logo或Slogan</td></tr><tr><td>Advertisement Screen</td><td>展示节日活动或日常广告</td></tr><tr><td>Guide Screen</td><td>演示重点功能，一般只展示一次</td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8140f612d4174f01b1b5791d85908ca2~tplv-k3u1fbpfcp-zoom-1.image" alt="启动过程示意图"></p><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>我们常常花费精力去打造引导画面或广告画面，而作为第一印象的启动画面却容易被忽视。回想下以前都是怎么处理这个画面的：</p><ol><li>一般通过设置<code>windowSplashscreenContent</code>属性来展示UI提供的启动图，系统将为它创建专门的Window</li><li>假使忘记设置这个属性的话，默认的白色背景将导致启动过程中会有个白画面一闪而过</li><li>要去掉这个突兀的白画面可不能简单地设置Background为null，不然一闪而过的又会变成黑画面</li><li>最终发现<code>windowDisablePreview</code>属性可以彻底关闭这个画面，这样一来确实没有任何突兀的画面一闪而过了</li></ol><p>但这又会带来启动”变慢”的副作用，因为用来过渡的启动画面被关闭之后，App描画前屏幕几乎没有什么变化。即便App性能没有劣化，但为了留住用户，我们还是得好好对待这个启动画面。</p><p>然而现有的<code>windowSplashscreenContent</code>可供定制的空间着实有限。也许官方也注意到了这点，便精心设计了<code>Splash Screen</code>  API，并在<code>Android 12</code>里重磅推出。</p><p>有了这个全新特性的帮助，启动画面的定制将更加自由、方便。先来看下采用SplashScreen API 快速定制的启动效果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa147a6e37654221aad6b9c0e2dc6c15~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>下面将逐步演示全新SplashScreen可供定制的各个方面。</p><h2 id="2-定制进入效果"><a href="#2-定制进入效果" class="headerlink" title="2 定制进入效果"></a>2 定制进入效果</h2><p>采用xml即可快速定制各式进入效果。</p><h3 id="2-1-默认的启动效果"><a href="#2-1-默认的启动效果" class="headerlink" title="2.1 默认的启动效果"></a>2.1 默认的启动效果</h3><p>默认情况下启动画面将展示白色背景和Launcher上的<code>Adaptive Icon</code>，也是不错的，比以前的白画面要好很多。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15646fcb27b44852b5cd11542b8f2273~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2-2-自定义静态Icon"><a href="#2-2-自定义静态Icon" class="headerlink" title="2.2 自定义静态Icon"></a>2.2 自定义静态Icon</h3><p>替换Icon为Adaptive Icon的前景图，背景色微调为米黄色。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSplashScreenBackground"</span>&gt;</span>@color/newSplashScreenColor<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSplashScreenAnimatableIcon"</span>&gt;</span>@drawable/ic_kotlin_hero_new<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97d0d1d5b80474f94035489c3a74156~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2-3-自定义Icon背景"><a href="#2-3-自定义Icon背景" class="headerlink" title="2.3 自定义Icon背景"></a>2.3 自定义Icon背景</h3><p>Icon色调和画面背景色的对比不够明显的情况下，可以添加Icon背景色加强辨识度。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">”android:windowSplashScreenIconBackground”</span>&gt;</span>@color/newSplashIconMaskColor<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185e7d837b7744f591f65c89242b8bcb~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2-4-自定义品牌Logo"><a href="#2-4-自定义品牌Logo" class="headerlink" title="2.4 自定义品牌Logo"></a>2.4 自定义品牌Logo</h3><p>添加品牌Logo可以展示企业形象或Slogan，使得启动画面更为完整和精细。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">”android:windowSplashScreenBrandingImage”</span>&gt;</span>@drawable/ic_tm_brand_newer<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76f3d841738346e59f7572bf803f9133~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2-5-自定义动画Icon"><a href="#2-5-自定义动画Icon" class="headerlink" title="2.5 自定义动画Icon"></a>2.5 自定义动画Icon</h3><p>动画形式的Icon可以增添设计和创意，使得启动流程更加流畅和有趣。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSplashScreenAnimatableIcon"</span>&gt;</span>@drawable/ic_kotlin_hero_new_animated_rotate<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSplashScreenAnimationDuration"</span>&gt;</span>@integer/icon_animator_duration<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>比如让机器人图标旋转起来。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd239d0b1c04df18facac58f140fef6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>再比如让机器人在Kotlin上侧滑。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a334fb8b87104fde8b455d94087be1c0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>或者让几何图案拼凑出字母K之后和机器人汇合，象征着<code>Android</code>和<code>Kotlin</code>的强强联合。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7598d3b251e4e1bae551f435cdec373~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><strong>注意：</strong></p><ul><li>动画Icon的时长上限为<code>1000ms</code>。</li><li>图标的进入动画可以定制，但由系统控制，不可以被监听和额外处理。</li></ul><h3 id="2-6-延长启动画面"><a href="#2-6-延长启动画面" class="headerlink" title="2.6 延长启动画面"></a>2.6 延长启动画面</h3><blockquote><p>The splash screen is dismissed as soon as your app draws its first frame. If you need to load a small amount of data such as in-app theme settings from a local disk asynchronously, you can use ViewTreeObserver.OnPreDrawListener to suspend the app to draw its first frame.</p></blockquote><p>后台数据的加载难免耗时，启动画面结束了主要内容仍未加载好的话，体验不是太好。能够控制启动画面的持续时时长就好了。</p><p>现有的ViewTreeObserver的<code>OnPreDrawListener</code>回调是可以挂起描画的，如果我们在数据准备好之后再放行描画，就可以间接地延长启动画面的显示。</p><p>比如Activity初始化2s后才放行描画。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplashActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        keepSplashScreenLonger()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">keepSplashScreenLonger</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 监听Content View的描画时机</span></span><br><span class="line">        <span class="keyword">val</span> content: View = findViewById(android.R.id.content)</span><br><span class="line">        content.viewTreeObserver.addOnPreDrawListener(</span><br><span class="line">            <span class="keyword">object</span> : ViewTreeObserver.OnPreDrawListener &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreDraw</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                    <span class="comment">// 准备好了描画放行，反之挂起</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">if</span> (viewModel.isDataReady()) &#123;</span><br><span class="line">                        content.viewTreeObserver.removeOnPreDrawListener(<span class="keyword">this</span>)</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(application: Application): AndroidViewModel(application) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        const <span class="keyword">val</span> WORK_DURATION = <span class="number">2000</span>L</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> initTime = SystemClock.uptimeMillis()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isDataReady</span><span class="params">()</span></span> = SystemClock.uptimeMillis() - initTime &gt; WORK_DURATION</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看一下效果，发现启动画面的展示时间确实变长了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e6b5b723882498caa23a399b5187124~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h2 id="3-定制退出效果"><a href="#3-定制退出效果" class="headerlink" title="3 定制退出效果"></a>3 定制退出效果</h2><p>当App的第一帧开始描画，<code>SplashScreen</code>将会退出展示。为了丰富退出环节的体验，系统也开放了相应的入口，即画面退出的回调。在这个回调里可以开始退出效果的定制，包括整体的退出动画和图标的退出动画。</p><h3 id="3-1-监听启动画面的退出"><a href="#3-1-监听启动画面的退出" class="headerlink" title="3.1 监听启动画面的退出"></a>3.1 监听启动画面的退出</h3><p>向SplashScreen注册OnExitAnimationListener接口即可监听启动画面的退出。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    customizeSplashScreenExit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">customizeSplashScreenExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    splashScreen.setOnExitAnimationListener &#123; splashScreenView -&gt;</span><br><span class="line">        Log.d(<span class="string">"Splash"</span>, <span class="string">"SplashScreen#onSplashScreenExit view:<span class="variable">$splashScreenView</span>"</span>)</span><br><span class="line">        sleep(<span class="number">1000</span>)</span><br><span class="line">        Log.d(<span class="string">"Splash"</span>, <span class="string">"SplashScreen#remove after sleeping"</span>)</span><br><span class="line">        splashScreenView.remove()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到启动画面展示之后，不作定制的默认情况下就是全屏一下再消失。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/075b09771c974bf6bccbab4b742657de~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Splash  : Activity:com.example.splash.MainActivity<span class="meta">@f</span>70c0d0 Activity:com.example.splash.MainActivity<span class="meta">@f</span>70c0d0 onCreate</span><br><span class="line">Splash  : Activity:com.example.splash.MainActivity<span class="meta">@f</span>70c0d0 onStart</span><br><span class="line">Splash  : Activity:com.example.splash.MainActivity<span class="meta">@f</span>70c0d0 onResume</span><br><span class="line">Splash  : SplashScreen#onSplashScreenExit view:android.window.SplashScreenView&#123;18339d5 V.E...... ........ 0,0-1080,2280&#125;</span><br><span class="line">Splash  : SplashScreen#remove after sleeping</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>一定记得调用remove及时移除启动画面，否则SplashScreen会长时间盖在主画面上，大概在5s左右。</strong></p><p>另外，回调的注册需要放在<code>Activity#onResume</code>前，不然监听不到。</p><h3 id="3-2-定制整体的退出动画"><a href="#3-2-定制整体的退出动画" class="headerlink" title="3.2 定制整体的退出动画"></a>3.2 定制整体的退出动画</h3><p>可以给启动画面的整体设置<code>TRANSLATE</code>、<code>SCALE</code>、<code>ROTATE</code>、<code>ALPHA</code>等各种动画，使得退出更加自然。</p><p>比如给SplashScreen加上一个缩小出屏幕的动画。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">customizeSplashScreenExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    splashScreen.setOnExitAnimationListener &#123; splashScreenView -&gt;</span><br><span class="line">        showSplashExitAnimator(splashScreenView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showSplashExitAnimator</span><span class="params">(splashScreenView: <span class="type">SplashScreenView</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> path = Path()</span><br><span class="line">    path.moveTo(<span class="number">1.0</span>f, <span class="number">1.0</span>f)</span><br><span class="line">    path.lineTo(<span class="number">0</span>f, <span class="number">0</span>f)</span><br><span class="line">    <span class="keyword">val</span> scaleOut = ObjectAnimator.ofFloat(</span><br><span class="line">        splashScreenView,</span><br><span class="line">        View.SCALE_X,</span><br><span class="line">        View.SCALE_Y,</span><br><span class="line">        path</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">    scaleOut.doOnEnd &#123;</span><br><span class="line">        splashScreenView.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    scaleOut.start()</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a839b5840e4d23a553db2c40fdc01e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>又或者从上方平移出屏幕的动画。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showSplashExitAnimator</span><span class="params">(splashScreenView: <span class="type">SplashScreenView</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> slideUp = ObjectAnimator.ofFloat(</span><br><span class="line">        splashScreenView,</span><br><span class="line">        View.TRANSLATION_Y,</span><br><span class="line">        <span class="number">0</span>f,</span><br><span class="line">        -splashScreenView.height.toFloat()</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">    slideUp.start()</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ffc9abaab9b416e82fe2fb69a62d165~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="3-3-定制图标的退出动画"><a href="#3-3-定制图标的退出动画" class="headerlink" title="3.3 定制图标的退出动画"></a>3.3 定制图标的退出动画</h3><p>当然也可以给图标单独加上动画，比如将Icon上滑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">customizeSplashScreenExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    splashScreen.setOnExitAnimationListener &#123; splashScreenView -&gt;</span><br><span class="line">        showSplashIconExitAnimator(splashScreenView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showSplashIconExitAnimator</span><span class="params">(splashScreenView: <span class="type">SplashScreenView</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> iconView = splashScreenView.iconView ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> slideUp = ObjectAnimator.ofFloat(</span><br><span class="line">        splashScreenView.iconView,</span><br><span class="line">        View.TRANSLATION_Y,</span><br><span class="line">        <span class="number">0</span>f,</span><br><span class="line">        -iconView.height * <span class="number">2.</span>toFloat()</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">    slideUp.start()</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c17496c976754fd795c7015c265386e8~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="3-4-退出动画的适当时长"><a href="#3-4-退出动画的适当时长" class="headerlink" title="3.4 退出动画的适当时长"></a>3.4 退出动画的适当时长</h3><p>针对退出动画的定制官方还有一段补充说明。</p><blockquote><p>By the start of this callback, the animated vector drawable on the splash screen has begun. Depending on the duration of the app launch, the drawable might be in the middle of its animation. Use <code>SplashScreenView.getIconAnimationStart</code> to know when the animation started. You can calculate the remaining duration of the icon animation.</p></blockquote><p>简言之，退出画面回调的时候Icon动画可能进行到了一半，最好计算Icon动画的剩余时长来执行退出动画。</p><p>原因在于设备性能会影响App描画的早晚，而第一帧描画的时候上述的退出回调将被执行。也就是说，性能的优劣会影响启动画面退出的回调时机。</p><ul><li>性能好的话，画面退出的回调较早。此时Icon动画尚在进行当中，可以将Icon动画的预设时长的剩余时间交接给退出效果来执行</li><li>性能差的话，画面退出的回调稍晚。Icon动画早已经结束，为了让用户尽早看到画面内容，就不该再执行退出效果了而是直接退出</li></ul><p><strong>不能为了展示效果而让用户久等，否则会弄巧成拙。</strong></p><p>借助SplashScreenView的<code>iconAnimationStartMillis</code>和<code>iconAnimationDurationMillis</code>方法可以推算出Icon动画的剩余时长。</p><p>*模拟器上运行的缘故，大部分时候我的Demo在启动画面退出的时候Icon动画都结束了，少部分情况下动画还剩余一点时间，可能实机的情况会不一样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showSplashIconExitAnimator</span><span class="params">(splashScreenView: <span class="type">SplashScreenView</span>)</span></span> &#123;</span><br><span class="line">    slideUp.duration = getRemainingDuration(splashScreenView)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRemainingDuration</span><span class="params">(splashScreenView: <span class="type">SplashScreenView</span>)</span></span>: <span class="built_in">Long</span>  &#123;</span><br><span class="line">    <span class="comment">// 取得Icon动画的时长</span></span><br><span class="line">    <span class="keyword">val</span> animationDuration = splashScreenView.iconAnimationDurationMillis</span><br><span class="line">    <span class="comment">// 取得Icon动画的开始时刻</span></span><br><span class="line">    <span class="keyword">val</span> animationStart = splashScreenView.iconAnimationStartMillis</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再结合当前时间计算出Icon动画的剩余时长</span></span><br><span class="line">    <span class="comment">// 1. 时长为负则固定为0ms即直接退出</span></span><br><span class="line">    <span class="comment">// 2. 时长为正则采用该时长执行退出动画</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (animationDuration != <span class="literal">null</span> &amp;&amp; animationStart != <span class="literal">null</span>) &#123;</span><br><span class="line">        (animationDuration - SystemClock.uptimeMillis() + animationStart)</span><br><span class="line">        .coerceAtLeast(<span class="number">0</span>L)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">0</span>L</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="4-SplashScreen相关API"><a href="#4-SplashScreen相关API" class="headerlink" title="4 SplashScreen相关API"></a>4 SplashScreen相关API</h2><h3 id="4-1-类和接口"><a href="#4-1-类和接口" class="headerlink" title="4.1 类和接口"></a>4.1 类和接口</h3><table><thead><tr><th>类/接口</th><th>作用</th></tr></thead><tbody><tr><td>SplashScreen</td><td>启动画面管理接口，通过Activity#getSplashScreen取得</td></tr><tr><td>OnExitAnimationListener</td><td>启动画面退出的回调接口，通过SplashScreen#setOnExitAnimationListener注册</td></tr><tr><td>SplashScreenView</td><td>启动画面包含的视图，用以定制整体或Icon的退出动画</td></tr></tbody></table><h3 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2 属性"></a>4.2 属性</h3><table><thead><tr><th>attr</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>splashScreenTheme</td><td>指定SplashScreen相关的Style</td><td>存在一点问题比如brand图片会不显示</td></tr><tr><td>windowSplashScreenBackground</td><td>定制启动画面的背景</td><td>默认从windowBackground里读取</td></tr><tr><td>windowSplashScreenBrandingImage</td><td>指定启动画面底部的品牌图标</td><td>-</td></tr><tr><td>windowSplashScreenAnimatedIcon</td><td>指定Icon，支持静态或动画Drawable</td><td>-</td></tr><tr><td>windowSplashScreenAnimationDuration</td><td>指定动画Icon时长</td><td>上限1000ms</td></tr><tr><td>windowSplashScreenIconBackgroundColor</td><td>补充Icon背景色</td><td>-</td></tr></tbody></table><p>注意：<code>windowSplashscreenContent</code>是8.0版本新增的定制启动画面的属性，自12开始废弃了，使用<code>windowSplashscreenAnimatedIcon</code>替代</p><h3 id="4-3-SplashScreen的构成"><a href="#4-3-SplashScreen的构成" class="headerlink" title="4.3 SplashScreen的构成"></a>4.3 SplashScreen的构成</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6579c39d65d54b5bbf34949a8d21e87b~tplv-k3u1fbpfcp-zoom-1.image" alt="构成示意图"></p><h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5 注意"></a>5 注意</h2><p>需要尝鲜SplashScreen的话，需要在Android 12上开发，并做如下必要配置。</p><ul><li>compileSdkVersion和targetSdkVersion声明为<code>S</code></li><li><code>android:exported=&quot;true&quot;</code>，明示声明启动画面的可见性，否则会安装失败</li></ul><p>另外启动页的Icon无论是静态的还是动画效果的，都应遵循<code>Adaptive Icon</code>的规范，不然Icon会发生变形。</p><h2 id="6-结语"><a href="#6-结语" class="headerlink" title="6 结语"></a>6 结语</h2><p>Android 12上全新的<code>SplashScreen</code> API非常简单清晰，整个定制过程非常流畅！</p><p>相信在全新的API加持下，APP的启动画面可以迸发出更多特色的、好玩的创意。</p><p><strong>快快尝试起来，给你的用户留下第一眼的好印象~</strong></p><h2 id="本文DEMO"><a href="#本文DEMO" class="headerlink" title="本文DEMO"></a>本文DEMO</h2><p><a href="https://github.com/ellisonchan/SplashScreen" target="_blank" rel="noopener">github.com/ellisonchan…</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/jILRvRTrc/article/details/116035700" target="_blank" rel="noopener">欢迎体验 | Android 12 开发者预览版 3</a></p><p><a href="https://developer.android.google.cn/about/versions/12/features/splash-screen" target="_blank" rel="noopener">SplashScreen的官方文档</a></p><p><a href="https://developer.android.google.cn/reference/android/window/SplashScreen" target="_blank" rel="noopener">SplashScreen API</a></p><p><a href="https://developer.android.google.cn/reference/android/R.attr#windowSplashScreenBackground" target="_blank" rel="noopener">SplashScreen相关attr</a></p><p>转自TechMerger <a href="https://juejin.cn/post/6962706834889113614" target="_blank" rel="noopener">https://juejin.cn/post/6962706834889113614</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;早期的Android上App的启动速度常为人诟病，如今的启动表现已不逊iOS。Google针对系统的不断优化绝对功不可没，从8.0独立出来的&lt;code&gt;SplashWindow&lt;/code&gt;，到12上推出的全新&lt;code&gt;SplashScreen&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在App的主要内容展示之前，按照需求的不同，或多或少会先展示这样几个画面。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;画面&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Splash Screen&lt;/td&gt;
&lt;td&gt;展示品牌Logo或Slogan&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Advertisement Screen&lt;/td&gt;
&lt;td&gt;展示节日活动或日常广告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Guide Screen&lt;/td&gt;
&lt;td&gt;演示重点功能，一般只展示一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8140f612d4174f01b1b5791d85908ca2~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;启动过程示意图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>代码实例展示Java和Kotlin有哪些区别</title>
    <link href="https://zhangmiao.cc/posts/24470fc.html"/>
    <id>https://zhangmiao.cc/posts/24470fc.html</id>
    <published>2021-05-17T10:06:47.000Z</published>
    <updated>2021-05-18T02:27:25.383Z</updated>
    
    <content type="html"><![CDATA[<p>自从谷歌 I/O 2017宣布将支持 Kotlin 作为 Android 开发的 First-Class 语言，相信各位程序员的朋友圈都被Kotlin的消息轰炸了吧，支持Java的“守旧派”认为Java将稳坐霸主地位不动摇，支持Kotlin的“维新派”认为Kotlin很可能会把Java拉下马。其实，笔者认为新语言的出现对于程序员来说并不是一件新鲜事儿，程序员始终践行着“活到老，学到老”，真正能够对程序员产生影响的新语言的使用和性能。</p><h2 id="易用性。"><a href="#易用性。" class="headerlink" title="易用性。"></a>易用性。</h2><ol><li>在语法糖的加持下，kotlin能够用更短的代码实现更多的功能。这是java 无法比拟的。所谓代码量越少，出bug的可能性就越低。</li><li>kotlin特有的扩展属性，不再需要java工具类，对开发更加友好。<br> 比如我们想实现字符串判空操作，在java中需要写一个StringUtil类，这样其他开发同学想实现该功能的时候，可能并不知道已经有人实现了该功能，存在重复造轮子的可能。通过扩展属性，我们可以很方便的看出String类都存在哪些方法。</li><li>java中的bean类总是需要使用插件生成setter getter方法。kotlin中的data关键字可以解决这类问题，data类在编译期自动生成getter setter方法。</li></ol><h2 id="规范性。"><a href="#规范性。" class="headerlink" title="规范性。"></a>规范性。</h2><p>工程项目都是需要指定开发规范的。比如变量命名等。在java中，方法重载的时候会生成@Override注解，但是这并不是强制约束的。kotlin的方法采用override关键字进行了强制约束。<br> 再比如TODO。java中的TODO是以注释的形式存在，即使没有实现TODO处的代码，也没什么运行时问题。kotlin的TODO形式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    TODO()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin TODO的实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">TODO</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> = <span class="keyword">throw</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>可以看到运行时会抛出异常。<br> 思考：这里为什么不在编译期抛出异常呢？</p><h2 id="安全性。"><a href="#安全性。" class="headerlink" title="安全性。"></a>安全性。</h2><p>java中虽然有@Nullable @NotNull等注解。但是不会在编译期起作用，而是在运行期抛出异常。kotlin在声明变量的时候，可以指定变量是否为空，调用可为空对象时，需要进行空判断。</p><h2 id="跨平台。"><a href="#跨平台。" class="headerlink" title="跨平台。"></a>跨平台。</h2><p>java在jvm的协助下虽然也是跨平台语言，但是不能像kotlin一样可以既可以编译成class字节码，又可以编译成js。</p><h2 id="编译速度。"><a href="#编译速度。" class="headerlink" title="编译速度。"></a>编译速度。</h2><p>只有全量编译下，kotlin比java慢。增量编译下，两者几乎没有差距。</p><h2 id="其他kotlin特性。"><a href="#其他kotlin特性。" class="headerlink" title="其他kotlin特性。"></a>其他kotlin特性。</h2><p>懒加载、高阶函数、协程、inline操作符、运算符重载、默认参数等。</p><p>GitHub 用户amitshekhariitbhu在GitHub上贴图<a href="https://github.com/MindorksOpenSource/from-java-to-kotlin/blob/master/README.md" target="_blank" rel="noopener">分享了</a>Java和Kotlin的语法区别，下面我们就一起来看一下吧!</p><a id="more"></a><h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">System.out.print(<span class="string">"Hello Word"</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello Word"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">print(<span class="string">"Hello Word"</span>)</span><br><span class="line">println(<span class="string">"Hello Word"</span>)</span><br></pre></td></tr></table></figure><h2 id="定义变量和常量"><a href="#定义变量和常量" class="headerlink" title="定义变量和常量"></a>定义变量和常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">String name = <span class="string">"Hello Word"</span>;</span><br><span class="line"><span class="keyword">final</span> String name = <span class="string">"Hello Word"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Hello Word"</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">"Hello Word"</span></span><br></pre></td></tr></table></figure><h2 id="null声明"><a href="#null声明" class="headerlink" title="null声明"></a>null声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">String otherName;</span><br><span class="line">otherName = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">var</span> otherName : String?</span><br><span class="line">otherName = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> length = text.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line">text?.let &#123;</span><br><span class="line">    <span class="keyword">val</span> length = text.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">String firstName = <span class="string">"Android"</span>;</span><br><span class="line">String lastName = <span class="string">"ZM"</span>;</span><br><span class="line">String message = <span class="string">"My name is: "</span> + firstName + <span class="string">" "</span> + lastName;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">val</span> firstName = <span class="string">"Android"</span></span><br><span class="line"><span class="keyword">val</span> lastName = <span class="string">"ZM"</span></span><br><span class="line"><span class="keyword">val</span> message = <span class="string">"My name is: <span class="variable">$firstName</span> <span class="variable">$lastName</span>"</span></span><br></pre></td></tr></table></figure><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">String text = <span class="string">"First Line\n"</span> +</span><br><span class="line">              <span class="string">"Second Line\n"</span> +</span><br><span class="line">              <span class="string">"Third Line"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">        |First Line</span></span><br><span class="line"><span class="string">        |Second Line</span></span><br><span class="line"><span class="string">        |Third Line</span></span><br><span class="line"><span class="string">        """</span>.trimMargin()</span><br></pre></td></tr></table></figure><h2 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">String text = x &gt; <span class="number">5</span> ? <span class="string">"x &gt; 5"</span> : <span class="string">"x &lt;= 5"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">val</span> text = <span class="keyword">if</span> (x &gt; <span class="number">5</span>)</span><br><span class="line">              <span class="string">"x &gt; 5"</span></span><br><span class="line">           <span class="keyword">else</span> <span class="string">"x &lt;= 5"</span></span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> andResult = a &amp; b;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> orResult = a | b;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> xorResult a ^ b;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> rightShift = a &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> leftShift = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> unsignedRightShift = a &gt;&gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> andResult = a and b;</span><br><span class="line"><span class="keyword">val</span> orResult = a or b;</span><br><span class="line"><span class="keyword">val</span> xorResult a xor b;</span><br><span class="line"><span class="keyword">val</span> rightShift = a shr <span class="number">2</span>;</span><br><span class="line"><span class="keyword">val</span> leftShift = a shl <span class="number">2</span>;</span><br><span class="line"><span class="keyword">val</span> unsignedRightShift = a ushr <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="类型判断和转换-声明式"><a href="#类型判断和转换-声明式" class="headerlink" title="类型判断和转换(声明式)"></a>类型判断和转换(声明式)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">Car car = (Car) object;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">object</span> <span class="keyword">as</span> Car</span><br></pre></td></tr></table></figure><h2 id="类型判断和转换-隐式"><a href="#类型判断和转换-隐式" class="headerlink" title="类型判断和转换(隐式)"></a>类型判断和转换(隐式)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> Car) &#123;</span><br><span class="line">   Car car = (Car) object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">object</span> <span class="keyword">is</span> Car) &#123;</span><br><span class="line">   <span class="keyword">var</span> car = <span class="keyword">object</span> <span class="comment">// smart casting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重条件"><a href="#多重条件" class="headerlink" title="多重条件"></a>多重条件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">300</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">if</span> (score <span class="keyword">in</span> <span class="number">0.</span><span class="number">.300</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="更灵活的case语句"><a href="#更灵活的case语句" class="headerlink" title="更灵活的case语句"></a>更灵活的case语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">int</span> score = <span class="comment">// some score;</span></span><br><span class="line">String grade;</span><br><span class="line"><span class="keyword">switch</span> (score) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">grade = <span class="string">"Excellent"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">grade = <span class="string">"Good"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">grade = <span class="string">"Ok"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">grade = <span class="string">"Fail"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    grade = <span class="string">"Fail"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">var</span> score = <span class="comment">// some score</span></span><br><span class="line"><span class="keyword">var</span> grade = <span class="keyword">when</span> (score) &#123;</span><br><span class="line"><span class="number">9</span>, <span class="number">10</span> -&gt; <span class="string">"Excellent"</span> </span><br><span class="line"><span class="keyword">in</span> <span class="number">6.</span><span class="number">.8</span> -&gt; <span class="string">"Good"</span></span><br><span class="line"><span class="number">4</span>, <span class="number">5</span> -&gt; <span class="string">"Ok"</span></span><br><span class="line"><span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span> -&gt; <span class="string">"Fail"</span></span><br><span class="line"><span class="keyword">else</span> -&gt; <span class="string">"Fail"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> ; i++) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span> ; i--) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i+=<span class="number">2</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span> ; i-=<span class="number">2</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : collection) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span> step <span class="number">2</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="更方便的集合操作"><a href="#更方便的集合操作" class="headerlink" title="更方便的集合操作"></a>更方便的集合操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; listOfNumber = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;Integer, String&gt; keyValue = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"Amit"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"Ali"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"Mindorks"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 9</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; listOfNumber = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;Integer, String&gt; keyValue = Map.of(<span class="number">1</span>, <span class="string">"Amit"</span>,</span><br><span class="line">                                             <span class="number">2</span>, <span class="string">"Ali"</span>,</span><br><span class="line">                                             <span class="number">3</span>, <span class="string">"Mindorks"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin </span></span><br><span class="line"><span class="keyword">val</span> listOfNumber = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> keyValue = mapOf(<span class="number">1</span> to <span class="string">"Amit"</span>,</span><br><span class="line">                     <span class="number">2</span> to <span class="string">"Ali"</span>,</span><br><span class="line">                     <span class="number">3</span> to <span class="string">"Mindorks"</span>)</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="comment">// Java 7 and below</span></span><br><span class="line"><span class="keyword">for</span> (Car car : cars) &#123;</span><br><span class="line">  System.out.println(car.speed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8+</span></span><br><span class="line">cars.forEach(car -&gt; System.out.println(car.speed));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 7 and below</span></span><br><span class="line"><span class="keyword">for</span> (Car car : cars) &#123;</span><br><span class="line">  <span class="keyword">if</span> (car.speed &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    System.out.println(car.speed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8+</span></span><br><span class="line">cars.stream().filter(car -&gt; car.speed &gt; <span class="number">100</span>).forEach(car -&gt; System.out.println(car.speed));</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line">cars.forEach &#123;</span><br><span class="line">    println(it.speed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cars.filter &#123; it.speed &gt; <span class="number">100</span> &#125;</span><br><span class="line">      .forEach &#123; println(it.speed)&#125;</span><br></pre></td></tr></table></figure><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// logic here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span>... numbers)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// logic here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">vararg</span> numbers: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">// logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带返回值的方法"><a href="#带返回值的方法" class="headerlink" title="带返回值的方法"></a>带返回值的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// logic here</span></span><br><span class="line">   <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">   <span class="comment">// logic here</span></span><br><span class="line">   <span class="keyword">return</span> score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as a single-expression function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">()</span></span>: <span class="built_in">Int</span> = score</span><br></pre></td></tr></table></figure><h2 id="无结束符号"><a href="#无结束符号" class="headerlink" title="无结束符号"></a>无结束符号</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// logic here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">   <span class="comment">// logic here</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span> * value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as a single-expression function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="number">2</span> * value</span><br></pre></td></tr></table></figure><h2 id="constructor构造器"><a href="#constructor构造器" class="headerlink" title="constructor构造器"></a>constructor构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="comment">// This utility class is not publicly instantiable </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * value</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other way is also there</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Utils &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Get-Set构造器"><a href="#Get-Set构造器" class="headerlink" title="Get Set构造器"></a>Get Set构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Developer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Developer developer = (Developer) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != developer.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(developer.name) : developer.name == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Developer&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Developer</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="comment">// This utility class is not publicly instantiable </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">triple</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = Utils.triple(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">triple</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span> * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">3.</span>triple()</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Direction &#123;</span><br><span class="line">        NORTH(<span class="number">1</span>),</span><br><span class="line">        SOUTH(<span class="number">2</span>),</span><br><span class="line">        WEST(<span class="number">3</span>),</span><br><span class="line">        EAST(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> direction;</span><br><span class="line"></span><br><span class="line">        Direction(<span class="keyword">int</span> direction) &#123;</span><br><span class="line">            <span class="keyword">this</span>.direction = direction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> direction;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span></span>(<span class="keyword">val</span> direction: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    NORTH(<span class="number">1</span>),</span><br><span class="line">    SOUTH(<span class="number">2</span>),</span><br><span class="line">    WEST(<span class="number">3</span>),</span><br><span class="line">    EAST(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义未初始化的对象"><a href="#定义未初始化的对象" class="headerlink" title="定义未初始化的对象"></a>定义未初始化的对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">Person person;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> person: Person</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">List&lt;Profile&gt; profiles = loadProfiles(context);</span><br><span class="line">Collections.sort(profiles, <span class="keyword">new</span> Comparator&lt;Profile&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Profile profile1, Profile profile2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (profile1.getAge() &gt; profile2.getAge()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (profile1.getAge() &lt; profile2.getAge()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">val</span> profile = loadProfiles(context)</span><br><span class="line">profile.sortedWith(Comparator(&#123; profile1, profile2 -&gt;</span><br><span class="line">    <span class="keyword">if</span> (profile1.age &gt; profile2.age) <span class="keyword">return</span><span class="symbol">@Comparator</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (profile1.age &lt; profile2.age) <span class="keyword">return</span><span class="symbol">@Comparator</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@Comparator</span> <span class="number">0</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"> AsyncTask&lt;Void, Void, Profile&gt; task = <span class="keyword">new</span> AsyncTask&lt;Void, Void, Profile&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Profile <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fetch profile from API or DB</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">val</span> task = <span class="keyword">object</span> : AsyncTask&lt;<span class="built_in">Void</span>, <span class="built_in">Void</span>, Profile&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInBackground</span><span class="params">(<span class="keyword">vararg</span> voids: <span class="type">Void</span>)</span></span>: Profile? &#123;</span><br><span class="line">        <span class="comment">// fetch profile from API or DB</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreExecute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPreExecute()</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#123;  <span class="comment">//Initialization block</span></span><br><span class="line">        System.out.println(<span class="string">"Init block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        init &#123; <span class="comment">// Initialization block</span></span><br><span class="line">            println(<span class="string">"Init block"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从谷歌 I/O 2017宣布将支持 Kotlin 作为 Android 开发的 First-Class 语言，相信各位程序员的朋友圈都被Kotlin的消息轰炸了吧，支持Java的“守旧派”认为Java将稳坐霸主地位不动摇，支持Kotlin的“维新派”认为Kotlin很可能会把Java拉下马。其实，笔者认为新语言的出现对于程序员来说并不是一件新鲜事儿，程序员始终践行着“活到老，学到老”，真正能够对程序员产生影响的新语言的使用和性能。&lt;/p&gt;
&lt;h2 id=&quot;易用性。&quot;&gt;&lt;a href=&quot;#易用性。&quot; class=&quot;headerlink&quot; title=&quot;易用性。&quot;&gt;&lt;/a&gt;易用性。&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在语法糖的加持下，kotlin能够用更短的代码实现更多的功能。这是java 无法比拟的。所谓代码量越少，出bug的可能性就越低。&lt;/li&gt;
&lt;li&gt;kotlin特有的扩展属性，不再需要java工具类，对开发更加友好。&lt;br&gt; 比如我们想实现字符串判空操作，在java中需要写一个StringUtil类，这样其他开发同学想实现该功能的时候，可能并不知道已经有人实现了该功能，存在重复造轮子的可能。通过扩展属性，我们可以很方便的看出String类都存在哪些方法。&lt;/li&gt;
&lt;li&gt;java中的bean类总是需要使用插件生成setter getter方法。kotlin中的data关键字可以解决这类问题，data类在编译期自动生成getter setter方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;规范性。&quot;&gt;&lt;a href=&quot;#规范性。&quot; class=&quot;headerlink&quot; title=&quot;规范性。&quot;&gt;&lt;/a&gt;规范性。&lt;/h2&gt;&lt;p&gt;工程项目都是需要指定开发规范的。比如变量命名等。在java中，方法重载的时候会生成@Override注解，但是这并不是强制约束的。kotlin的方法采用override关键字进行了强制约束。&lt;br&gt; 再比如TODO。java中的TODO是以注释的形式存在，即使没有实现TODO处的代码，也没什么运行时问题。kotlin的TODO形式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TODO()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;kotlin TODO的实现&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@kotlin&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt;.InlineOnly&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TODO&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;Nothing&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; NotImplementedError()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看到运行时会抛出异常。&lt;br&gt; 思考：这里为什么不在编译期抛出异常呢？&lt;/p&gt;
&lt;h2 id=&quot;安全性。&quot;&gt;&lt;a href=&quot;#安全性。&quot; class=&quot;headerlink&quot; title=&quot;安全性。&quot;&gt;&lt;/a&gt;安全性。&lt;/h2&gt;&lt;p&gt;java中虽然有@Nullable @NotNull等注解。但是不会在编译期起作用，而是在运行期抛出异常。kotlin在声明变量的时候，可以指定变量是否为空，调用可为空对象时，需要进行空判断。&lt;/p&gt;
&lt;h2 id=&quot;跨平台。&quot;&gt;&lt;a href=&quot;#跨平台。&quot; class=&quot;headerlink&quot; title=&quot;跨平台。&quot;&gt;&lt;/a&gt;跨平台。&lt;/h2&gt;&lt;p&gt;java在jvm的协助下虽然也是跨平台语言，但是不能像kotlin一样可以既可以编译成class字节码，又可以编译成js。&lt;/p&gt;
&lt;h2 id=&quot;编译速度。&quot;&gt;&lt;a href=&quot;#编译速度。&quot; class=&quot;headerlink&quot; title=&quot;编译速度。&quot;&gt;&lt;/a&gt;编译速度。&lt;/h2&gt;&lt;p&gt;只有全量编译下，kotlin比java慢。增量编译下，两者几乎没有差距。&lt;/p&gt;
&lt;h2 id=&quot;其他kotlin特性。&quot;&gt;&lt;a href=&quot;#其他kotlin特性。&quot; class=&quot;headerlink&quot; title=&quot;其他kotlin特性。&quot;&gt;&lt;/a&gt;其他kotlin特性。&lt;/h2&gt;&lt;p&gt;懒加载、高阶函数、协程、inline操作符、运算符重载、默认参数等。&lt;/p&gt;
&lt;p&gt;GitHub 用户amitshekhariitbhu在GitHub上贴图&lt;a href=&quot;https://github.com/MindorksOpenSource/from-java-to-kotlin/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分享了&lt;/a&gt;Java和Kotlin的语法区别，下面我们就一起来看一下吧!&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android Branch deferred deep link 深度链接</title>
    <link href="https://zhangmiao.cc/posts/4f2dc96b.html"/>
    <id>https://zhangmiao.cc/posts/4f2dc96b.html</id>
    <published>2020-12-05T01:52:10.000Z</published>
    <updated>2020-12-05T01:54:49.275Z</updated>
    
    <content type="html"><![CDATA[<p>Branch 实现Android端 deferred deep link</p><p>官网sdk文档地址：<a href="https://docs.branch.io/apps/android/" target="_blank" rel="noopener">https://docs.branch.io/apps/android/</a><br><strong>1. Configure Branch（配置Branch）</strong><br><img src="https://img-blog.csdnimg.cn/20191028150246601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd4aW5neGluZw==,size_16,color_FFFFFF,t_70" alt="用户设备未安装app，跳转至某一下载链接"><br><img src="https://img-blog.csdnimg.cn/20191028150712837.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd4aW5neGluZw==,size_16,color_FFFFFF,t_70" alt="用户未安装app，跳转至Google Play时"></p><a id="more"></a><p><strong>2. Install Branch</strong></p><ul><li>Import the Branch SDK to your build.gradle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// required for all Android apps</span></span><br><span class="line">    implementation <span class="string">'io.branch.sdk.android:library:3.+'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// required if your app is in the Google Play Store</span></span><br><span class="line">    implementation <span class="string">'com.google.android.gms:play-services-appindexing:9.+'</span> <span class="comment">// App indexing</span></span><br><span class="line">    implementation <span class="string">'com.google.android.gms:play-services-ads:9+'</span> <span class="comment">// GAID matching</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p><strong>3.Configure app</strong></p><ul><li>Add Branch to your AndroidManifest.xml</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">"com.eneff.branch.example.android"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        android:allowBackup=<span class="string">"true"</span></span><br><span class="line">        android:name=<span class="string">"com.eneff.branch.example.android.CustomApplicationClass"</span></span><br><span class="line">        android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">        android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">        android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">        android:theme=<span class="string">"@style/AppTheme"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Launcher Activity to handle incoming Branch intents --&gt;</span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name=<span class="string">".LauncherActivity"</span></span><br><span class="line">            android:launchMode=<span class="string">"singleTask"</span></span><br><span class="line">            android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">            android:theme=<span class="string">"@style/AppTheme.NoActionBar"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">&lt;activity android:name=<span class="string">".intelsports.ShareShowActivity"</span>&gt;</span><br><span class="line">        &lt;!-- <span class="function">Branch App <span class="title">Links</span> <span class="params">(optional)</span> --&gt;</span></span><br><span class="line"><span class="function">        &lt;intent-filter android:autoVerify</span>=<span class="string">"true"</span>&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span><br><span class="line">            &lt;data android:scheme=<span class="string">"olp"</span> android:host=<span class="string">"sports.app.link"</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Branch init --&gt;</span><br><span class="line">        &lt;meta-data android:name=<span class="string">"io.branch.sdk.BranchKey"</span> android:value=<span class="string">"key_live_kaFuWw8WvY7yn1d9yYiP8gokwqjV0Sw"</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- <span class="function">Branch install referrer <span class="title">tracking</span> <span class="params">(optional)</span> --&gt;</span></span><br><span class="line"><span class="function">        &lt;receiver android:name</span>=<span class="string">"io.branch.referral.InstallListener"</span> android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"com.android.vending.INSTALL_REFERRER"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/receiver&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span></span><br></pre></td></tr></table></figure><ul><li><p>Replace the following with values from your Branch Dashboard <a href="https://dashboard.branch.io/account-settings/app" target="_blank" rel="noopener">App settings</a> and <a href="https://dashboard.branch.io/link-settings/general" target="_blank" rel="noopener">Link settings</a></p><p>example.app.link<br>key_live_kaFuWw8WvY7yn1d9yYiP8gokwqjV0Sw</p><p><img src="https://img-blog.csdnimg.cn/20191028153344821.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd4aW5neGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019102816093830.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd4aW5neGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191028153014365.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd4aW5neGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上是Branch的配置信息设置，接下来进行Branch的初始化工作</p></li></ul><p><strong>4.Initialize Branch</strong></p><ul><li>Add Branch to your LauncherActivity.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LauncherActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_launcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Branch init</span></span><br><span class="line">        Branch.getInstance().initSession(<span class="keyword">new</span> Branch.BranchReferralInitListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInitFinished</span><span class="params">(JSONObject referringParams, BranchError error)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.i(<span class="string">"BRANCH SDK"</span>, referringParams.toString());</span><br><span class="line">                    <span class="comment">// Retrieve deeplink keys from 'referringParams' and evaluate the values to determine where to route the user</span></span><br><span class="line">                    <span class="comment">// Check '+clicked_branch_link' before deciding whether to use your Branch routing logic</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.i(<span class="string">"BRANCH SDK"</span>, error.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">this</span>.getIntent().getData(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre></td></tr></table></figure><p><strong>5.Load Branch</strong></p><ul><li>Add Branch to your CustomApplicationClass.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomApplicationClass</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Branch logging for debugging</span></span><br><span class="line">        Branch.enableDebugMode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Branch object initialization</span></span><br><span class="line">        Branch.getAutoInstance(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p><strong>6.Test deep link</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BranchUniversalObject buo = <span class="keyword">new</span> BranchUniversalObject();</span><br><span class="line">    </span><br><span class="line">LinkProperties lp = <span class="keyword">new</span> LinkProperties()</span><br><span class="line">    .addControlParameter(<span class="string">"custom1"</span>, <span class="string">"data1"</span>)    <span class="comment">//传入自定义数据</span></span><br><span class="line">    .addControlParameter(<span class="string">"custom2"</span>, <span class="string">"data2"</span>);</span><br><span class="line"></span><br><span class="line">buo.generateShortUrl(<span class="keyword">this</span>, lp, <span class="keyword">new</span> Branch.BranchLinkCreateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLinkCreate</span><span class="params">(String url, BranchError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//得到短链接，用于分享</span></span><br><span class="line">            Log.i(<span class="string">"BRANCH SDK"</span>, <span class="string">"got my Branch link to share: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><p>使用第三方分享或系统自带分享工具，将以上短链接url分享即可。</p><p><strong>7.Read deep link(读取depplink中携带的数据)</strong></p><ul><li>在要启动的ShareShowActivity或LauncherActivity onStart方法中实现。即可读取出JSONObject中相应数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listener (within Main Activity's onStart)</span></span><br><span class="line">Branch.getInstance().initSession(<span class="keyword">new</span> Branch.BranchReferralInitListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInitFinished</span><span class="params">(JSONObject referringParams, BranchError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.i(<span class="string">"BRANCH SDK"</span>, referringParams.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(<span class="string">"BRANCH SDK"</span>, error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">this</span>.getIntent().getData(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// latest</span></span><br><span class="line">JSONObject sessionParams = Branch.getInstance().getLatestReferringParams();</span><br><span class="line"></span><br><span class="line"><span class="comment">// first 若设备未安装app，用户安装app后第一次启动即可获取deep link中的数据</span></span><br><span class="line">JSONObject installParams = Branch.getInstance().getFirstReferringParams();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Branch 实现Android端 deferred deep link&lt;/p&gt;
&lt;p&gt;官网sdk文档地址：&lt;a href=&quot;https://docs.branch.io/apps/android/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.branch.io/apps/android/&lt;/a&gt;&lt;br&gt;&lt;strong&gt;1. Configure Branch（配置Branch）&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028150246601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd4aW5neGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;用户设备未安装app，跳转至某一下载链接&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028150712837.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd4aW5neGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;用户未安装app，跳转至Google Play时&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack ViewModel</title>
    <link href="https://zhangmiao.cc/posts/837f0209.html"/>
    <id>https://zhangmiao.cc/posts/837f0209.html</id>
    <published>2020-10-19T07:43:53.000Z</published>
    <updated>2021-06-06T16:44:18.590Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">官方文档</a></p><h1 id="ViewModel概览"><a href="#ViewModel概览" class="headerlink" title="ViewModel概览"></a>ViewModel概览</h1><p><code>ViewModel</code>类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续存在。</p><p>Android 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。</p><p>如果系统销毁或重新创建界面控制器，则存储在其中的任何临时性界面相关数据都会丢失。例如，应用的某个 Activity 中可能包含用户列表。因配置更改而重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 <code>onSaveInstanceState()</code> 方法从 <code>onCreate()</code> 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。</p><p>另一个问题是，界面控制器经常需要进行异步调用，这些调用可能需要一些时间才能返回结果。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄露。此项管理需要大量的维护工作，并且在因配置更改而重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。</p><p>诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。</p><p>从界面控制器逻辑中分离出视图数据所有权的做法更易行且更高效。</p><a id="more"></a><h1 id="实现ViewModel"><a href="#实现ViewModel" class="headerlink" title="实现ViewModel"></a>实现ViewModel</h1><p>架构组件为界面控制器提供了 <code>ViewModel</code> 辅助程序类，该类负责为界面准备数据。 在配置更改期间会自动保留 <code>ViewModel</code> 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。例如，如果您需要在应用中显示用户列表，请确保将获取和保留该用户列表的责任分配给 <code>ViewModel</code>，而不是 Activity 或 Fragment，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">        <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">            <span class="keyword">if</span> (users == <span class="keyword">null</span>) &#123;</span><br><span class="line">                users = <span class="keyword">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class="line">                loadUsers();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> users;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><p>然后，您可以从 Activity 访问该列表，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">            <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">            MyViewModel model = ViewModelProviders.of(<span class="keyword">this</span>).get(MyViewModel.class);</span><br><span class="line">            model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">                <span class="comment">// update UI</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>如果重新创建了该 Activity，它接收的 <code>MyViewModel</code> 实例与第一个 Activity 创建的实例相同。当所有者 Activity 完成时，框架会调用 <code>ViewModel</code> 对象的 <code>onCleared()</code> 方法，以便它可以清理资源。</p><blockquote><p>注意：ViewModel 绝不能引用视图、Lifecycle 或可能存储对 Activity 上下文的引用的任何类。</p></blockquote><p><code>ViewModel</code> 对象存在的时间比视图或 <code>LifecycleOwners</code> 的特定实例存在的时间更长。这还意味着，您可以更轻松地编写涵盖 <code>ViewModel</code> 的测试，因为它不了解视图和 <code>Lifecycle</code> 对象。<code>ViewModel</code> 对象可以包含 <code>LifecycleObservers</code>，如 <code>LiveData</code> 对象。但是，<code>ViewModel</code> 对象绝不能观察对生命周期感知型可观察对象（如 <code>LiveData</code> 对象）的更改。 如果 <code>ViewModel</code> 需要 <code>Application</code> 上下文（例如，为了查找系统服务），它可以扩展 <code>AndroidViewModel</code> 类并设置用于接收 <code>Application</code> 的构造函数，因为 <code>Application</code> 类会扩展 <code>Context</code>。</p><h1 id="ViewModel的生命周期"><a href="#ViewModel的生命周期" class="headerlink" title="ViewModel的生命周期"></a>ViewModel的生命周期</h1><p><code>ViewModel</code> 对象存在的时间范围是获取 <code>ViewModel</code> 时传递给 <code>ViewModelProvider</code> 的 <code>Lifecycle</code>。<code>ViewModel</code> 将一直留在内存中，直到限定其存在时间范围的 <code>Lifecycle</code> 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。</p><p>图 1 说明了 Activity 经历屏幕旋转而后结束的过程中所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 <code>ViewModel</code> 的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。<br><img src="https://img-blog.csdnimg.cn/20200323185652422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMzNzkw,size_16,color_FFFFFF,t_70#pic_center" alt="图1"><br>您通常在系统首次调用 Activity 对象的 <code>onCreate()</code> 方法时请求 <code>ViewModel</code>。系统可能会在 Activity 的整个生命周期内多次调用 <code>onCreate()</code>，如在旋转设备屏幕时。<code>ViewModel</code> 存在的时间范围是从您首次请求 <code>ViewModel</code> 直到 Activity 完成并销毁。</p><h1 id="在-Fragment-之间共享数据"><a href="#在-Fragment-之间共享数据" class="headerlink" title="在 Fragment 之间共享数据"></a>在 Fragment 之间共享数据</h1><p>Activity 中的两个或更多 Fragment 需要相互通信是一种很常见的情况。想象一下主从 Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。</p><p>可以使用 <code>ViewModel</code> 对象解决这一常见的难点。这两个 Fragment 可以使用其 Activity 范围共享 ViewModel 来处理此类通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">            selected.setValue(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> selected;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">            itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">                model.select(item);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">            model.getSelected().observe(<span class="keyword">this</span>, &#123; item -&gt;</span><br><span class="line">               <span class="comment">// Update the UI.</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></td></tr></table></figure><p>此方法具有以下优势：</p><ul><li>Activity 不需要执行任何操作，也不需要对此通信有任何了解。</li><li>除了 SharedViewModel 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。</li><li>每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。</li></ul><h1 id="将加载器替换为-ViewModel"><a href="#将加载器替换为-ViewModel" class="headerlink" title="将加载器替换为 ViewModel"></a>将加载器替换为 ViewModel</h1><p>诸如 <code>CursorLoader</code> 之类的加载器类经常用于使应用界面中的数据与数据库保持同步。您可以将 <code>ViewModel</code> 与一些其他类一起使用来替换加载器。使用 <code>ViewModel</code> 可将界面控制器与数据加载操作分离，这意味着类之间的强引用更少。</p><p>在使用加载器的一种常见方法中，应用可能会使用 <code>CursorLoader</code> 观察数据库的内容。当数据库中的值发生更改时，加载器会自动触发数据的重新加载并更新界面：<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20201019154523.png" alt><br><code>ViewModel</code> 与 <code>Room</code> 和 <code>LiveData</code> 一起使用可替换加载器。<code>ViewModel</code> 确保数据在设备配置更改后仍然存在。<code>Room</code> 在数据库发生更改时通知 <code>LiveData</code>，<code>LiveData</code> 进而使用修订后的数据更新界面。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20201019154533.png" alt></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><a href="https://github.com/android/architecture-components-samples/tree/master/BasicSample" target="_blank" rel="noopener">官方示例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/viewmodel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ViewModel概览&quot;&gt;&lt;a href=&quot;#ViewModel概览&quot; class=&quot;headerlink&quot; title=&quot;ViewModel概览&quot;&gt;&lt;/a&gt;ViewModel概览&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ViewModel&lt;/code&gt;类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续存在。&lt;/p&gt;
&lt;p&gt;Android 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。&lt;/p&gt;
&lt;p&gt;如果系统销毁或重新创建界面控制器，则存储在其中的任何临时性界面相关数据都会丢失。例如，应用的某个 Activity 中可能包含用户列表。因配置更改而重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 方法从 &lt;code&gt;onCreate()&lt;/code&gt; 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。&lt;/p&gt;
&lt;p&gt;另一个问题是，界面控制器经常需要进行异步调用，这些调用可能需要一些时间才能返回结果。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄露。此项管理需要大量的维护工作，并且在因配置更改而重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。&lt;/p&gt;
&lt;p&gt;诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。&lt;/p&gt;
&lt;p&gt;从界面控制器逻辑中分离出视图数据所有权的做法更易行且更高效。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://zhangmiao.cc/categories/Android/Jetpack/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
      <category term="Jetpack" scheme="https://zhangmiao.cc/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack</title>
    <link href="https://zhangmiao.cc/posts/f1035a2c.html"/>
    <id>https://zhangmiao.cc/posts/f1035a2c.html</id>
    <published>2020-10-19T07:36:23.000Z</published>
    <updated>2020-10-19T07:38:35.530Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码地工作并简化复杂任务，以便将精力集中放在所需代码上。</p><p>Jetpack包含与平台API解除捆绑地<code>androidx.*</code>软件包库。这意味着，它可以提供向后兼容性，且比Android平台地更新频率更高，一次确保您始终可以获取最新且最好地Jetpack组件版本。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20201019153720.png" alt></p><h1 id="Android-Jetpack组件"><a href="#Android-Jetpack组件" class="headerlink" title="Android Jetpack组件"></a>Android Jetpack组件</h1><p>Android Jetpack组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用Kotlin语言功能帮助您提高工作效率，可全部使用，也可混合搭配！<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20201019153732.png" alt></p><a id="more"></a><h2 id="基础（Foundation）"><a href="#基础（Foundation）" class="headerlink" title="基础（Foundation）"></a>基础（Foundation）</h2><p>基础组件可提供横向功能，例入向后兼容性、测试和Kotlin语言支持。</p><ul><li><strong>Android KTX</strong><br>编写更简洁、惯用的kotlin代码</li><li><strong>AppCompat</strong><br>在较低版本的Android系统上恰当地降级</li><li><strong>Auto</strong><br>有助于开发Android Auto应用地组件</li><li><strong>检测</strong><br>从Android Studio中快速检测基于Kotlin或Java的代码</li><li><strong>多Dex处理</strong><br>为具有多个dex文件的应用提供支持</li><li><strong>安全</strong><br>按照安全最佳做法读写加密文件和共享偏好设置</li><li><strong>测试</strong><br>用于单元和运行时界面测试的Android测试框架</li><li><strong>TV</strong><br>有助于开发Android TV应用的组件</li><li><strong>Wear OS by Google谷歌</strong><br>有助于开发Wear应用的组件</li></ul><h2 id="架构（Architecture）"><a href="#架构（Architecture）" class="headerlink" title="架构（Architecture）"></a>架构（Architecture）</h2><p><strong>架构组件</strong>可帮助您设计文件、可测试且易维护的应用。</p><ul><li><strong>数据绑定</strong><br>以声明方法将可观察数据绑定到界面元素</li><li><strong>Lifecycles</strong><br>管理您的Activity和Fragment生命周期</li><li><strong>LiveData</strong><br>在底层数据库更改时通知视图</li><li><strong>Navigaton</strong><br>处理应用内导航所需的一切</li><li><strong>Paging</strong><br>逐步从您的数据源按需加载信息</li><li><strong>Room</strong><br>流畅地访问SQLite数据库</li><li><a href="https://blog.csdn.net/qq_40833790/article/details/105054936" target="_blank" rel="noopener"><strong>ViewModel</strong></a><br>以注重生命周期地方式管理界面相关的数据</li><li><strong>WorkManager</strong></li></ul><p>管理您的Android后台作业</p><h2 id="行为（Behavior）"><a href="#行为（Behavior）" class="headerlink" title="行为（Behavior）"></a>行为（Behavior）</h2><p>行为组件可帮助您的应用与标准Android服务（如通知、权限、分享和Google助理）相集成。</p><ul><li><strong>CameraX</strong><br>轻松地向应用中添加相机功能</li><li><strong>下载管理器</strong><br>安排和管理大量下载任务</li><li><strong>媒体和播放</strong><br>用于媒体播放和路由（包括Google Cast）地向后兼容API</li><li><strong>通知</strong><br>提供向后兼容的通知API，支持Wear和Auto</li><li><strong>权限</strong><br>用于检查和请求应用权限的兼容性API</li><li><strong>偏好设置</strong><br>创建交互式设置屏幕</li><li><strong>共享</strong><br>提供适合应用操作栏的共享操作</li><li><strong>切片</strong><br>创建可在应用外部显示应用数据的灵活界面元素</li></ul><h2 id="界面（UI）"><a href="#界面（UI）" class="headerlink" title="界面（UI）"></a>界面（UI）</h2><p>界面组件可提供微件和辅助程序，让您的应用不仅简单易用，还能带来愉悦体验。了解有助于简化界面开发的<strong>Jetpack Compose</strong>。</p><ul><li><strong>动画和过渡</strong><br>移动微件和在屏幕之间过渡</li><li><strong>表情符号</strong><br>在旧版平台上启用最新的表情符号字体</li><li><strong>Fragment</strong><br>组件化界面的基本单位</li><li><strong>布局</strong><br>使用不同的算法布置微件</li><li><strong>调色板</strong><br>从调色板中提取有用的信息</li></ul><p>- </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jetpack是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码地工作并简化复杂任务，以便将精力集中放在所需代码上。&lt;/p&gt;
&lt;p&gt;Jetpack包含与平台API解除捆绑地&lt;code&gt;androidx.*&lt;/code&gt;软件包库。这意味着，它可以提供向后兼容性，且比Android平台地更新频率更高，一次确保您始终可以获取最新且最好地Jetpack组件版本。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20201019153720.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;Android-Jetpack组件&quot;&gt;&lt;a href=&quot;#Android-Jetpack组件&quot; class=&quot;headerlink&quot; title=&quot;Android Jetpack组件&quot;&gt;&lt;/a&gt;Android Jetpack组件&lt;/h1&gt;&lt;p&gt;Android Jetpack组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用Kotlin语言功能帮助您提高工作效率，可全部使用，也可混合搭配！&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20201019153732.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://zhangmiao.cc/categories/Android/Jetpack/"/>
    
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
      <category term="Jetpack" scheme="https://zhangmiao.cc/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin入门</title>
    <link href="https://zhangmiao.cc/posts/749a22ae.html"/>
    <id>https://zhangmiao.cc/posts/749a22ae.html</id>
    <published>2020-09-26T03:03:51.000Z</published>
    <updated>2021-05-18T02:45:22.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02ae1fd55784c0593e53afa00fd1fec~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210116114509401"></p><p><strong>注意： Kotlin 现作为 Android 第一开发语言，AndroidStudio 作为 Google 的亲儿子，对 Kotlin 进行了完美的支持，开发提示应有尽有，因此下面所有的演示代码都是跑在 AndroidStudio 上的</strong></p><a id="more"></a><h2 id="Kotlin-介绍"><a href="#Kotlin-介绍" class="headerlink" title="Kotlin 介绍"></a>Kotlin 介绍</h2><p>官网对 Kotlin 的介绍：A modern programming languagethat makes developers happier. 翻译过来就是：<strong>Kotlin 是一门让开发者更开心的现代程序设计语言 。</strong> 由 JetBrains 公司开发和设计，它也是一门基于 JVM 的静态语言。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在学习 Kotlin 的时候我心里会有一些疑问🤔️ ？</p><p>1、Android 操作系统是由 Google 开发出来的，为啥 JetBrains 作为一个第三方公司，却能设计出一门语言来开发 Android 应用程序？</p><p>因为 Java 虚拟机（Android 中叫 ART，一种基于 Java 虚拟机优化的虚拟机）并不直接和你编写的这门语言的源代码打交道，而是和你编译之后的 class 字节码文件打交道。基于 JVM 的语言，如 Kotlin，Groovy等，它们都会有各自的编译器，把源文件编译成 class 字节码文件，Java 虚拟机不关心 class 字节码文件是从哪里编译而来，只要符合规格的 class 字节码文件，它都能识别，正是因为这个原因，JetBrains 才能以一个第三方公司设计出一门来开发 Android 应用程序的编程语言</p><p>2、为啥有了 Java 来开发 Android 应用程序，Google 还要推荐使用 Kotlin 来开发？</p><p>原因有很多，列举主要的几点：</p><ul><li>1）、Kotlin 语法更加简洁，使用 Kotlin 开发的代码量可能会比 Java 开发的减少 50% 甚至更多</li><li>2）、Kotlin 的语法更加高级，相比于 Java 老旧的语法，Kotlin 增加了很多现代高级语言的语法特性，大大提升了我们的开发效率</li><li>3）、Kotlin 和 Java 是 100% 兼容的，Kotlin 可以直接调用 Java 编写的代码，也可以无缝使用 Java 第三方开源库，这使得 Kotlin 在加入了诸多新特性的同时，还继承了 Java 的全部财富</li></ul><p>3、为啥 Kotlin 中要显示的去声明一个非抽象类可继承，而不像 Java 那样定义的类默认可继承？</p><p>因为一个类默认可被继承的话，它无法预知子类会如何去实现，因此存在一些未知的风险。类比 val 关键字是同样的道理，在 Java 中，除非你主动给变量声明 final 关键字，否则这个变量就是可变的，随着项目复杂度增加，多人协作开发，你永远不知道一个可变的变量会在什么时候被谁修改了，即使它原本不应该修改，也很难去排查问题。因此 Kotlin 这样的设计是为了让程序更加的健壮，也更符合高质量编码的规范</p><p>下面我们就正式进入到 Kotlin 的学习</p><h2 id="一、变量和函数"><a href="#一、变量和函数" class="headerlink" title="一、变量和函数"></a>一、变量和函数</h2><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><p>1）、使用 val（value 的简写）关键字来声明一个不可变的变量，也就是只读变量，这种变量初始赋值后就不能重新赋值了，对应 Java 中的 final 变量</p><p>2）、使用 var （variable 的简写）关键字用来声明一个可变的变量，也就是可读写变量，这种变量初始赋初值后仍然可以重新被赋值，对应 Java 中的非 final 变量</p><p>3）、Kotlin 中的每一行代码都不用加 ；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 Java 中，我们会这么定义</span></span><br><span class="line">int a = <span class="number">10</span>;</span><br><span class="line">boolean b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 Kotlin 中，我们可以这么定义，当给变量赋值后，Kotlin 编译器会进行类型推导</span></span><br><span class="line"><span class="comment">//定义一个不可变的变量 a </span></span><br><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="comment">//定义一个可变的变量 b</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们显示的给变量指定类型，Kotlin 就不会进行类型推导了</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="built_in">Boolean</span> = <span class="string">"erdai"</span></span><br></pre></td></tr></table></figure><p>如果你观察的仔细会发现，上述代码 Kotlin 定义变量给变量显示的指定类型时，使用的都是首字母大小的 Int，Boolean，而在 Java 中都是小写的 int，boolean，这表明： <strong>Kotlin 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。</strong> 下面给出一个 Java 和 Kotlin 数据类型对照表：</p><table><thead><tr><th>Java 基本数据类型</th><th>Kotlin 对象数据类型</th><th>数据类型说明</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>字节型</td></tr><tr><td>short</td><td>Short</td><td>短整型</td></tr><tr><td>int</td><td>Int</td><td>整型</td></tr><tr><td>long</td><td>Long</td><td>长整型</td></tr><tr><td>float</td><td>Float</td><td>单精度浮点数</td></tr><tr><td>double</td><td>Double</td><td>双精度浮点数</td></tr><tr><td>char</td><td>Char</td><td>字符型</td></tr><tr><td>boolean</td><td>Boolean</td><td>布尔型</td></tr></tbody></table><h3 id="2、常量"><a href="#2、常量" class="headerlink" title="2、常量"></a>2、常量</h3><p>Kotlin 中定义一个常量需要满足三个条件</p><p>1）、使用 const val 来修饰，并初始化</p><p>2）、修饰的类型只能是字符串和基础对象类型</p><p>3）、只能修饰顶层的常量，object 修饰的成员，companion object 的成员，这些概念后面还会讲到</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个顶层的常量，这个常量不放在任何的类中</span></span><br><span class="line">const <span class="keyword">val</span> CONSTANT = <span class="string">"This is a constant"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个 object 修饰的单例类，类中定义一个常量</span></span><br><span class="line"><span class="keyword">object</span> SingeTon &#123;</span><br><span class="line">    const <span class="keyword">val</span> CONSTANT = <span class="string">"This is a constant"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinPractice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个 companion object 修饰的伴生对象，里面定义一个常量</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        const <span class="keyword">val</span> CONSTANT = <span class="string">"This is a constant"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><p>1）、函数和方法是同一个概念，在 Java 中我们习惯叫方法 (method)，但是 Kotlin 中就需要叫函数 (function)</p><p>2）、函数是运行代码的载体,像我们使用过的 main 函数就是一个函数</p><p>Kotlin 中定义语法的规则：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这两个方法效果是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName1</span><span class="params">(params: <span class="type">Int</span>,params2: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName1</span><span class="params">(params: <span class="type">Int</span>,params2: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数语法解释：</p><ul><li>fun ( function 的缩写 ) 是定义一个函数的关键字，无论你定义什么函数，都要用 fun 来声明</li><li>函数名称可以随便取，就像 Java 里面定义函数名一样</li><li>函数名里面的参数可以有任意多个，参数的声明格式为：”参数名”：”参数类型”</li><li>参数名后面这部分代表返回值，我们这返回的是一个 Int 类型的值，这部分是可选的，如果不定义，默认返回值为 Unit，且 Unit 可省略</li></ul><p>实践一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number1 = <span class="number">15</span></span><br><span class="line">    <span class="keyword">val</span> number2 = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> maxNumber = largeNumber(number1,number2)</span><br><span class="line">    println(maxNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(number1: <span class="type">Int</span>,number2: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="comment">//调用顶层 max 函数计算两者中的最大值</span></span><br><span class="line">    <span class="keyword">return</span> max(number1,number2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>Kotlin 语法糖：当一个函数体中只有一行代码的时候，我们可以不编写函数体，可以将唯一的一行代码写在函数定义的尾部，中间用 = 连接即可</strong></p><p>那么上述 largeNumber 这个函数我们改造一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据上述语法糖，我们省略了函数体的 &#123;&#125; 和 return 关键字，增减的 = 连接</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(number1: <span class="type">Int</span>,number2: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = max(number1,number2)</span><br><span class="line"><span class="comment">//根据 Kotlin 类型推导机制，我们还可以把函数的返回值给省略，最终变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(number1: <span class="type">Int</span>,number2: <span class="type">Int</span>)</span></span> = max(number1,number2)</span><br></pre></td></tr></table></figure><h2 id="二、程序的逻辑控制"><a href="#二、程序的逻辑控制" class="headerlink" title="二、程序的逻辑控制"></a>二、程序的逻辑控制</h2><h3 id="1、if-条件语句"><a href="#1、if-条件语句" class="headerlink" title="1、if 条件语句"></a>1、if 条件语句</h3><p>1）、Kotlin 中的 if 条件语句除了继承了 Java 中 if 条件语句的所有特性，且可以把每一个条件中的最后一行代码作为返回值</p><p>我们改造一下上述 largeNumber 函数的内部实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin 中把每一个条件中的最后一行代码作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(number1: <span class="type">Int</span>,number2: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span>(number1 &gt; number2)&#123;</span><br><span class="line">      number1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      number2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据上面学习的语法糖和 Kotlin 类型推导机制，我们还可以简写 largeNumber 函数，最终变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(number1: <span class="type">Int</span>,number2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span>(number1 &gt; number2) number1 <span class="keyword">else</span> number <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="2、when-条件语句"><a href="#2、when-条件语句" class="headerlink" title="2、when 条件语句"></a>2、when 条件语句</h3><p>类比 Java 中的 Switch 语句学习，Java 中的 Switch 并不怎么好用：</p><p>1）、Switch 语句只能支持一些特定的类型，如整型，短于整型，字符串，枚举类型。如果我们使用的并非这几种类型，Switch 并不可用</p><p>2）、Switch 语句的 case 条件都要在最后加上一个 break</p><p>这些问题在 Kotlin 中都得到了解决，而且 Kotlin 还加入了许多强大的新特性：</p><p>1）、when 条件语句也是有返回值的，和 if 条件语句类似，条件中的最后一行代码作为返回值</p><p>2）、when 条件语句允许传入任意类型的参数</p><p>3）、when 条件体中条件格式：匹配值 -&gt; { 执行逻辑 }</p><p>4）、when 条件语句和 if 条件语句一样，当条件体里面只有一行代码的时候，条件体的 {} 可省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//when 中有参数的情况</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (name) &#123;</span><br><span class="line">    <span class="string">"tom"</span> -&gt; <span class="number">99</span></span><br><span class="line">    <span class="string">"jim"</span> -&gt; <span class="number">80</span></span><br><span class="line">    <span class="string">"lucy"</span> -&gt; <span class="number">70</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//when 中无参数的情况，Kotin 中判断字符串或者对象是否相等，直接使用 == 操作符即可</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    name == <span class="string">"tom"</span> -&gt; <span class="number">99</span></span><br><span class="line">    name == <span class="string">"jim"</span> -&gt; <span class="number">80</span></span><br><span class="line">    name ==<span class="string">"lucy"</span> -&gt; <span class="number">70</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、循环语句"><a href="#3、循环语句" class="headerlink" title="3、循环语句"></a>3、循环语句</h3><p>主要有以下两种循环：</p><p>1）、while 循环，这种循环和 Java 没有任何区别</p><p>2）、for 循环，Java 中常用的循环有：for-i，for-each，Kotlin 中主要是：for-in</p><p><strong>区间</strong></p><p>1）、使用 .. 表示创建两端都是闭区间的升序区间</p><p>2）、使用 until 表示创建左端是闭区间右端是开区间的升序区间</p><p>3）、使用 downTo 表示创建两端都是闭区间的降序区间</p><p>4）、在区间的后面加上 step ，表示跳过几个元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意: Kotlin 中可以使用字符串内嵌表达式，也就是在字符串中可以引用变量，后续还会讲到</span></span><br><span class="line"><span class="comment">//情况1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用 .. 表示创建两端都是闭区间的升序区间</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>)&#123;</span><br><span class="line">        print(<span class="string">"<span class="variable">$i</span> "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用 until 表示创建左端是闭区间右端是开区间的升序区间</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span>)&#123;</span><br><span class="line">        print(<span class="string">"<span class="variable">$i</span> "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况3</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用 downTo 表示创建两端都是闭区间的降序区间</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">0</span>)&#123;</span><br><span class="line">        print(<span class="string">"<span class="variable">$i</span> "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况4</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用 downTo 表示创建两端都是闭区间的降序区间,每次在跳过3个元素</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">0</span> step <span class="number">3</span>)&#123;</span><br><span class="line">        print(<span class="string">"<span class="variable">$i</span> "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h2><p>对于面向对象编程的理解：面向对象的语言是可以创建类的，类是对事物一种的封装，例如人，汽车我们都可以把他们封装成类，类名通常是名词，类中有自己的字段和函数，字段表示该类拥有的属性，通常也是名词，就像人可以拥有姓名和年龄，汽车可以拥有品牌和价格，函数表示该类拥有那些行为，一般为动词，就像人需要吃饭睡觉，汽车可以驾驶和保养，通过这种类的封装，我们就可以在适当的地方创建这些类，然后调用他们的字段和函数来满足实际的编程需求，这就是面向对象编程最基本的思想</p><h3 id="1、类与对象"><a href="#1、类与对象" class="headerlink" title="1、类与对象"></a>1、类与对象</h3><p>我们使用 AndroidStudio 创建一个 Person 类，在弹出的对话框中输入 Person ，选择Class，对话框默认情况下自动选中的是创建一个File，File 通常是用于编写 Kotlin 顶层函数和扩展函数等，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d1af4be3224b1c8bc6e8b0264aa18b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210316190225365"></p><p>1）、当我们在类中创建属性的时候，Kotlin 会自动帮我们创建 get 和 set 方法</p><p>2）、Kotlin 中实例化对象和 Java 类似，但是把 new 关键字给去掉了</p><p>3）、一般在类中，我们会用 var 关键字去定义一个属性，因为属性一般是可变的，如果你确定某个属性不需要改变，则用 val</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$name</span> is sleep, He is <span class="variable">$age</span> years old."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.name = <span class="string">"erdai"</span></span><br><span class="line">    person.age = <span class="number">20</span></span><br><span class="line">    person.sleep()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai <span class="keyword">is</span> sleep, He <span class="keyword">is</span> <span class="number">20</span> years old.</span><br></pre></td></tr></table></figure><h3 id="2、继承与构造函数"><a href="#2、继承与构造函数" class="headerlink" title="2、继承与构造函数"></a>2、继承与构造函数</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>1）、Kotlin 中规定，如果要声明一个非抽象类可继承，必须加上 open 关键字，否则不可继承，这点和 Java 中不同，Java 中的类默认是可被继承的，Effective Java 这本书中提到：如果一个类不是专门为继承而设计的，那么就应该主动将它加上 final 声明，禁止他可以被继承</p><p>2）、Kotlin中的继承和实现都是用 : 表示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明 Person 类可以被继承</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$name</span> is sleep, He is <span class="variable">$age</span> years old."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 Student 继承 Person 类</span></span><br><span class="line"><span class="comment">//为啥 Person 后面会有一个括号呢？因为子类的构造函数必须调用父类中的构造函数，在 Java 中，子类的构造函数会隐式的去调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>1）、主构造函数的特点是没有函数体，直接跟在类名的后面即可，如果需要在主构造函数里面做逻辑，复写 init 函数即可</p><p>2）、主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，如果不加，那么该字段的作用域仅限定在主构造函数中</p><p>3）、次构造函数是通过 constructor 关键字来定义的</p><p>4）、当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 ()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 Student 类，定义主构造函数，定义属性 sno 和 grade, 继承 Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">var</span> sno: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">        <span class="comment">//做一些初始化的逻辑</span></span><br><span class="line">  init &#123;</span><br><span class="line">        name = <span class="string">"erdai"</span></span><br><span class="line">        age = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明带一个参数的次构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(sno: String): <span class="keyword">this</span>(sno,<span class="number">8</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个无参的次构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(): <span class="keyword">this</span>(<span class="string">"123"</span>,<span class="number">7</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"I am <span class="variable">$name</span>, <span class="variable">$age</span> yeas old, sno: <span class="variable">$sno</span>, grade: <span class="variable">$grade</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student1 = Student()</span><br><span class="line">    <span class="keyword">val</span> student2 = Student(<span class="string">"456"</span>)</span><br><span class="line">    <span class="keyword">val</span> student3 = Student(<span class="string">"789"</span>,<span class="number">9</span>)</span><br><span class="line">    student1.printInfo()</span><br><span class="line">    student2.printInfo()</span><br><span class="line">    student3.printInfo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">I am erdai, <span class="number">20</span> yeas old, sno: <span class="number">123</span>, grade: <span class="number">7</span></span><br><span class="line">I am erdai, <span class="number">20</span> yeas old, sno: <span class="number">456</span>, grade: <span class="number">8</span></span><br><span class="line">I am erdai, <span class="number">20</span> yeas old, sno: <span class="number">789</span>, grade: <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一种特殊情况：当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 ()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person&#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">super</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h3><p>1）、Kotlin 和 Java 中定义接口没有任何区别</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口中的一系列的抽象行为 Kotlin 中增加了接口中定义的函数可以有默认实现，其实 Java 在 JDK1.8 之后也开始支持这个功能</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">     <span class="comment">//如果子类没有重写这个方法,那么就会调用这个方法的默认实现</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span>&#123;</span><br><span class="line">         println(<span class="string">"do homework default implementation"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个可被继承的 People 类，有 name 和 age 两个属性</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>(<span class="keyword">val</span> name: String,<span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个 Student 类，继承 People 类，实现 Study 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name: String, age: <span class="built_in">Int</span>) : People(name, age),Study&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$name</span> is read book"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的一个方法 然后在main函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span>&#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">"erdai"</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="comment">//这里student实现了Study接口,这种叫做面向接口编程,也可以称为多态</span></span><br><span class="line">    doStydy(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai <span class="keyword">is</span> read book</span><br><span class="line"><span class="keyword">do</span> homework <span class="keyword">default</span> implementation</span><br></pre></td></tr></table></figure><h3 id="4、函数的可见性修饰符"><a href="#4、函数的可见性修饰符" class="headerlink" title="4、函数的可见性修饰符"></a>4、函数的可见性修饰符</h3><table><thead><tr><th>修饰符</th><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr><td>public</td><td>所有类可见</td><td>所有类可见(默认)</td></tr><tr><td>private</td><td>当前类可见</td><td>当前类可见</td></tr><tr><td>protected</td><td>当前类,子类,同一个包下的可见</td><td>当前类和子类可见</td></tr><tr><td>default</td><td>同一个包下的可见(默认)</td><td>无</td></tr><tr><td>internal</td><td>无</td><td>同一个模块中的类可见</td></tr></tbody></table><h3 id="5、数据类与单例类"><a href="#5、数据类与单例类" class="headerlink" title="5、数据类与单例类"></a>5、数据类与单例类</h3><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>1）、在 Java 中，数据类通常需要重写 equals( )，hashCode( )，toString( ) 这几个方法，其中 equals( ) 方法用于判断两个数据类是否相等。hashCode( ) 方法作为 equals( ) 的配套方法，也需要一起重写，否则会导致 hash 相关的系统类无法正常工作，toString( ) 方法则用于提供更清晰的输入日志，否则一个数据类默认打印出来的是一行内存地址</p><p>2）、在 Kotlin 中，我们只需要使用 data 关键字去修饰一个类，Kotlin 就会自动帮我们生成 Java 需要重写的那些方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 Java 中，我们会这么写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cellphone</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String brand;</span><br><span class="line">    double price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean equals(Object o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Cellphone cellphone = (Cellphone) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Double</span>.compare(cellphone.price, price) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                Objects.equals(brand, cellphone.brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> int hashCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(brand, price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cellphone&#123;"</span> +</span><br><span class="line">                <span class="string">"brand='"</span> + brand + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 Kotlin 中，你会发现是如此的简洁</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Cellphone</span></span>(<span class="keyword">val</span> brand: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>)</span><br></pre></td></tr></table></figure><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>1）、Kotlin 中，我们只需要使用 object 关键字去替换 class 关键字就可以去定义一个单例类了</p><p>2）、调用单例类中的方法也比较简单，直接使用类名 . 上方法就可以了，类似于 Java 中的静态方法调用方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java中单例 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> static Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> synchronized static Singleton getInstace() &#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> void singleonTest()&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"singletonTest in Java is called."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin中的单例</span></span><br><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"singletonTest in Kotlin is called."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Singleton.singletonTest()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">singletonTest <span class="keyword">in</span> Kotlin <span class="keyword">is</span> called.</span><br></pre></td></tr></table></figure><h2 id="Lambda-编程"><a href="#Lambda-编程" class="headerlink" title="Lambda 编程"></a>Lambda 编程</h2><p>Kotlin 从第一个版本就开始支持了 Lambda 编程，并且 Kotlin 中的 Lambda 表达式极为强大，本章我们学习 Lambda 编程的一些基础知识：</p><p>1）、简单来说，Lambda 就是一段可以作为参数传递的代码，它可以作为函数的参数，返回值，同时也可以赋值给一个变量</p><p>2）、Lambda 完整的表达式的语法结构：{ 参数名1：参数类型，参数名2：参数类型 -&gt; 函数体 }</p><p>3）、很多时候，我们会使用简化形式的语法结构，直接就是一个函数体：{函数体}，这种情况是当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数</p><p>4）、Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</p><p>5）、Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</p><h3 id="1、集合的创建和遍历"><a href="#1、集合的创建和遍历" class="headerlink" title="1、集合的创建和遍历"></a>1、集合的创建和遍历</h3><p>1）、不可变集合：在集合初始化之后，我们不能对其进行增删改操作</p><p>2）、可变集合：在集合初始化之后，我们还能对其进行增删改操作</p><table><thead><tr><th>不可变集合</th><th>可变集合</th></tr></thead><tbody><tr><td>listOf</td><td>mutableListOf</td></tr><tr><td>setOf</td><td>mutableSetOf</td></tr><tr><td>mapOf</td><td>mutableMapOf</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List 集合 </span></span><br><span class="line"><span class="comment">//定义一个不可变 List 集合</span></span><br><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>,<span class="string">"Pear"</span>,<span class="string">"Grape"</span>)</span><br><span class="line"><span class="comment">//定义一个可变 List 集合</span></span><br><span class="line"><span class="keyword">val</span> list2 = mutableListOf(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>,<span class="string">"Pear"</span>,<span class="string">"Grape"</span>)</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list2.add(<span class="string">"Watermelon"</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> list2) &#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$i</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Apple Banana Orange Pear Grape Watermelon</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set 集合和 List 集合用法完全一样</span></span><br><span class="line"><span class="comment">//定义一个不可变 Set 集合</span></span><br><span class="line"><span class="keyword">val</span> set1 = setOf(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>,<span class="string">"Pear"</span>,<span class="string">"Grape"</span>)</span><br><span class="line"><span class="comment">//定义一个可变 Set 集合</span></span><br><span class="line"><span class="keyword">val</span> set2 = mutableSetOf(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>,<span class="string">"Pear"</span>,<span class="string">"Grape"</span>)</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">set2.add(<span class="string">"Watermelon"</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> set2) &#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$i</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Apple Banana Orange Pear Grape Watermelon</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map 集合</span></span><br><span class="line"><span class="comment">//定义一个不可变 Map 集合</span></span><br><span class="line"><span class="keyword">val</span> map1 = mapOf(<span class="string">"Apple"</span> to <span class="number">1</span>,<span class="string">"Banana"</span> to <span class="number">2</span>,<span class="string">"Orange"</span> to <span class="number">3</span>, <span class="string">"Pear"</span> to <span class="number">4</span>,<span class="string">"Grape"</span> to <span class="number">5</span>)</span><br><span class="line"><span class="comment">//定义一个可变 Map 集合</span></span><br><span class="line"><span class="keyword">val</span> map2 = mutableMapOf(<span class="string">"Apple"</span> to <span class="number">1</span>,<span class="string">"Banana"</span> to <span class="number">2</span>,<span class="string">"Orange"</span> to <span class="number">3</span>, <span class="string">"Pear"</span> to <span class="number">4</span>,<span class="string">"Grape"</span> to <span class="number">5</span>)</span><br><span class="line"><span class="comment">//当前 key 存在则修改元素，不存在则添加元素</span></span><br><span class="line">map1[<span class="string">"Watermelon"</span>] = <span class="number">6</span></span><br><span class="line"><span class="keyword">for</span> ((key,value) <span class="keyword">in</span> map1) &#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$key</span>: <span class="variable">$value</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Apple: <span class="number">1</span> Banana: <span class="number">2</span> Orange: <span class="number">3</span> Pear: <span class="number">4</span> Grape: <span class="number">5</span> Watermelon: <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="2、集合的函数式-API"><a href="#2、集合的函数式-API" class="headerlink" title="2、集合的函数式 API"></a>2、集合的函数式 API</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个不可变 List 集合</span></span><br><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>,<span class="string">"Pear"</span>,<span class="string">"Grape"</span>,<span class="string">"Watermelon"</span>)</span><br><span class="line"><span class="comment">//现在我想打印集合中英文名字最长的字符串，我们可以这么做</span></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">var</span> maxLengthFruit = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list1) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fruit.length &gt; maxLengthFruit.length)&#123;</span><br><span class="line">        maxLengthFruit = fruit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(maxLengthFruit)</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Watermelon</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是如果使用函数式 Api 将会变得更加简单, maxBy 函数会根据你的条件遍历得到符合条件的最大值</span></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list1.maxBy &#123;</span><br><span class="line">    it.length</span><br><span class="line">&#125;</span><br><span class="line">print(maxLengthFruit)</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Watermelon</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 maxBy 函数结合 Lambda 表达式语法结构，我们来剖析方式2这种写法的原理, 如下所示</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>,<span class="string">"Pear"</span>,<span class="string">"Grape"</span>,<span class="string">"Watermelon"</span>)</span><br><span class="line"><span class="keyword">val</span> lambda = &#123;fruit: String -&gt; fruit.length&#125;</span><br><span class="line"><span class="comment">//maxBy 函数实际上接收的是一个函数类型的参数，后续讲高阶函数的时候会讲到，也就是我们这里可以传入一个 Lambda 表达式</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list1.maxBy(lambda)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 替换 lambda</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list1.maxBy(&#123;fruit: String -&gt; fruit.length&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list1.maxBy()&#123;fruit: String -&gt; fruit.length&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list1.maxBy&#123;fruit: String -&gt; fruit.length&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5 当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list1.maxBy&#123; it.length &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过上面 1-&gt;2-&gt;3-&gt;4-&gt;5 这几个步骤，我们最终得到了 5 的这种写法</span></span><br></pre></td></tr></table></figure><p>集合中还有很多这样的函数式 Api，下面我们通过 list 集合来实践一下其他的一些函数式 Api：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>,<span class="string">"Pear"</span>,<span class="string">"Grape"</span>,<span class="string">"Watermelon"</span>)</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//通过 map 操作，把一个元素映射成一个新的元素</span></span><br><span class="line"><span class="keyword">val</span> newList = list.map&#123;</span><br><span class="line">  it.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (s <span class="keyword">in</span> newList) &#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$s</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">APPLE BANANA ORANGE PEAR GRAPE WATERMELON </span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//通过 filter 筛选操作，筛选长度小于等于5的字符串</span></span><br><span class="line"><span class="keyword">val</span> newList = list.filter &#123;</span><br><span class="line">    it.length &lt;= <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (s <span class="keyword">in</span> newList) &#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$s</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Apple Pear Grape</span><br></pre></td></tr></table></figure><h3 id="3、Java-函数式-API-的使用"><a href="#3、Java-函数式-API-的使用" class="headerlink" title="3、Java 函数式 API 的使用"></a>3、Java 函数式 API 的使用</h3><p>1）、Kotlin 中调用 Java 方法也可以使用函数式 Api ,但必须满足两个条件：1、得是用 Java 编写的接口 2、接口中只有一个待实现的方法</p><p>2)、Kotlin 中写匿名内部类和 Java 有一点区别，Kotlin 中因为抛弃了 new 关键字，改用 object 关键字就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java 中的匿名内部类</span></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> void run() &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin 中可以这么写</span></span><br><span class="line">Thread(<span class="keyword">object</span> : Runnable&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们接着来简化 Kotlin 中的写法</span></span><br><span class="line"><span class="comment"> * 因为 Runnable 类中只有一个待实现方法，即使这里没有显示的重写 run() 方法，</span></span><br><span class="line"><span class="comment"> * Kotlin 也能明白后面的 Lambda 表达式就是要在 run() 方法中实现的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Thread(Runnable&#123;</span><br><span class="line">  </span><br><span class="line">&#125;).start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为是单抽象方法接口，我们可以将接口名进行省略</span></span><br><span class="line">Thread(&#123;</span><br><span class="line">  </span><br><span class="line">&#125;).start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面</span></span><br><span class="line">Thread()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略</span></span><br><span class="line">Thread&#123;</span><br><span class="line">  </span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><h2 id="四、空指针检查"><a href="#四、空指针检查" class="headerlink" title="四、空指针检查"></a>四、空指针检查</h2><p>Android 系统上奔溃最高的异常就是空指针异常（NullPointerException），造成这种现象的主要原因是因为空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免，但即使在出色的程序员，也不可能将所有潜在的空指针异常都考虑到。但是这种情况在 Kotlin 上得到了很好的解决，Kotlin 把空指针异常提前到了编译期去检查，这样的做法几乎杜绝了空指针异常，但是这样子会导致代码变得比较难写，不过 Kotlin 提供了一系列的辅助工具，让我们能轻松的处理各种判空的情况，下面我们就来学习它</p><h3 id="1、可空类型系统和判空辅助工具"><a href="#1、可空类型系统和判空辅助工具" class="headerlink" title="1、可空类型系统和判空辅助工具"></a>1、可空类型系统和判空辅助工具</h3><p>1）、在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空</p><p>2）、在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做</p><p>3）、?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果</p><p>4）、在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常</p><p>5）、let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中</p><p><strong>情况1：</strong> 在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">domeHomework</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"do homework default implementation"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span>&#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.domeHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是不会出现空指针异常的，如果你尝试向 doStudy 这个方法传递一个 null ，编译器会报错：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3e0d4640674c8cbfb70c4cb81b0ef0~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210317101826003"></p><p>因此这种情况我们就可以使用可空类型，把 Study 改成 Study？，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aeed15a301b4de1b3c6b3f5c43eed42~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210317104058401"></p><p>你会发现虽然调用 doStudy 方法不报错了，但是 doStudy 内部的调用却报错了，因为此时 doStudy 接受一个可空的类型参数，可能会造成内部的空指针， Kotlin 编译器不允许这种情况存在，那么我们进行如下改造就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line">        study.domeHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>情况2：</strong> 在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做</p><p>针对上面的 doStudy 方法，我们还可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.domeHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>情况3：</strong> ?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平时我们可能写这样的代码</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">    b</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 ?: 操作符可以简化成这样</span></span><br><span class="line"><span class="keyword">val</span> a = b ?: c</span><br></pre></td></tr></table></figure><p><strong>情况4：</strong> 在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这段代码编译通不过，因为 printName 方法里的 name 并不知道你在外面做了非空判断</span></span><br><span class="line"><span class="keyword">val</span> name: String? = <span class="string">"erdai"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> upperCaseName = name.toUpperCase()</span><br><span class="line">    print(upperCaseName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(name != <span class="literal">null</span>)&#123;</span><br><span class="line">       printName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因此在上面这种明确不会为空的情况下，我们可以使用 !! 操作符，改造一下 printName 方法</span></span><br><span class="line"><span class="comment">//同时要提醒一下自己，是否存在更好的实现方式，因为使用这种操作符，还是会存在潜在的空指针异常</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> upperCaseName = name!!.toUpperCase()</span><br><span class="line">    print(upperCaseName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">ERDAI</span><br></pre></td></tr></table></figure><p><strong>情况5：</strong> let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是我们情况2 实现的方式，但是如果这种调用方式一多，会显得特别啰嗦，例如：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.domeHomework()</span><br><span class="line">    study?.a()</span><br><span class="line">    study?.b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面这种情况等同于如下代码:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">      study?.readBooks()</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">     study?.domeHomework()</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">     study?.a()</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">      study?.b()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个时候我们就可以使用 let 函数来操作了</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.let&#123;</span><br><span class="line">      it.readBooks()</span><br><span class="line">      it.domeHomework()</span><br><span class="line">      it.a()</span><br><span class="line">      it.b()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Kotlin中的小魔术"><a href="#五、Kotlin中的小魔术" class="headerlink" title="五、Kotlin中的小魔术"></a>五、Kotlin中的小魔术</h2><h3 id="1、字符串的内嵌表达式"><a href="#1、字符串的内嵌表达式" class="headerlink" title="1、字符串的内嵌表达式"></a>1、字符串的内嵌表达式</h3><p>1）、Kotlin 中，字符串里面可以使用 ${} 引用变量值和表达式，当 {} 里面只有一个变量，非表达式时，{}也可以去掉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="string">"erdai"</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="string">"666"</span></span><br><span class="line">    print(<span class="string">"<span class="variable">$a</span> <span class="subst">$&#123;a + b&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai erdai666</span><br></pre></td></tr></table></figure><h3 id="2、函数的参数默认值"><a href="#2、函数的参数默认值" class="headerlink" title="2、函数的参数默认值"></a>2、函数的参数默认值</h3><p>1）、定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数</p><p>2）、在我们调用一个函数时，我们可以使用 key value 的形式来传参</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1：定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(name: <span class="type">String</span>,age: <span class="type">Int</span> = <span class="number">20</span>)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"I am <span class="variable">$name</span>, <span class="variable">$age</span> years old."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printParams(<span class="string">"erdai"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">I am erdai, <span class="number">20</span> years old.</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然我们也可以选择覆盖默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printParams(<span class="string">"erdai"</span>,<span class="number">25</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">I am erdai, <span class="number">25</span> years old.</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：在我们调用一个函数时，我们可以使用 key value 的形式来传参</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//注意 printParams 方法的一个参数是 name ,第二个才是 age, 但是通过 key value 的形式来传参就不会出现参数顺序问题</span></span><br><span class="line">    printParams(age = <span class="number">19</span>,name = <span class="string">"erdai666"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">I am erdai666, <span class="number">19</span> years old.</span><br></pre></td></tr></table></figure><p><strong>小技巧：我们可以通过函数的参数默认值来代替次构造函数，使用主构造函数就好了</strong></p><h2 id="六、标准函数和静态方法"><a href="#六、标准函数和静态方法" class="headerlink" title="六、标准函数和静态方法"></a>六、标准函数和静态方法</h2><h3 id="1、标准函数let，also，with，run-和-apply"><a href="#1、标准函数let，also，with，run-和-apply" class="headerlink" title="1、标准函数let，also，with，run 和 apply"></a>1、标准函数let，also，with，run 和 apply</h3><p>1）、let 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，且最后一行代码作为返回值</p><p>2）、also 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，无法指定返回值，这个函数返回的是当前调用对象本身</p><p>3）、with 函数，接收两个参数，第一个为任意类型参数，第二个为 Lambda 表达式参数，Lambda 表达式中拥有第一个参数的上下文 this ，且最后一行代码作为返回值</p><p>4）、run 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，且最后一行代码作为返回值</p><p>5）、apply 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，无法指定返回值，这个函数返回的是当前调用对象本身</p><p><strong>注意：在Lambda 表达式中，拥有对象的上下文 this，和拥有该对象是一样的，只不过 this 可省略，而拥有该对象我们可以自定义参数名，如果不写该参数，默认会有个 it 参数</strong></p><p>下面通过代码来感受一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 情况1：let 函数</span></span><br><span class="line"><span class="comment"> * 1、创建一个 StringBuilder 对象调用 let 函数，Lambda 表达式中的参数为 StringBuilder 对象</span></span><br><span class="line"><span class="comment"> * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，返回值即为 Lambda 表达式中最后一行代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"erdai"</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> returnValue = StringBuilder().let &#123;</span><br><span class="line">        it.append(name).append(<span class="string">" "</span>).append(age)</span><br><span class="line">    &#125;</span><br><span class="line">    println(returnValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 情况2：also 函数</span></span><br><span class="line"><span class="comment"> * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中的参数为 StringBuilder 对象</span></span><br><span class="line"><span class="comment"> * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，无法指定返回值，返回调用对象本身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"erdai"</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> stringBuilder = StringBuilder().also &#123;</span><br><span class="line">        it.append(name).append(<span class="string">" "</span>).append(age)</span><br><span class="line">    &#125;</span><br><span class="line">    println(stringBuilder.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 情况3：with 函数</span></span><br><span class="line"><span class="comment"> * 1、接收两个参数，第一个参数为 StringBuilder 对象，第二个参数为 Lambda 表达式，</span></span><br><span class="line"><span class="comment"> * 2、Lambda 表达式中拥有 StringBuilder 对象的上下文 this, 返回值即为 Lambda 表达式中的最后一行代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"erdai"</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> returnValue = with(StringBuilder()) &#123;</span><br><span class="line">        append(name).append(<span class="string">" "</span>).append(age)</span><br><span class="line">    &#125;</span><br><span class="line">    println(returnValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 情况4：run 函数</span></span><br><span class="line"><span class="comment"> * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this</span></span><br><span class="line"><span class="comment"> * 2、返回值即为 Lambda 表达式中的最后一行代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"erdai"</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> returnValue = StringBuilder().run &#123;</span><br><span class="line">        append(name).append(<span class="string">" "</span>).append(age)</span><br><span class="line">    &#125;</span><br><span class="line">    println(returnValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 情况5：apply 函数</span></span><br><span class="line"><span class="comment"> * 1、创建一个 StringBuilder 对象调用 apply 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this</span></span><br><span class="line"><span class="comment"> * 2、无法指定返回值，返回调用对象本身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"erdai"</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stringBuilder = StringBuilder().apply &#123;</span><br><span class="line">        append(name).append(<span class="string">" "</span>).append(age)</span><br><span class="line">    &#125;</span><br><span class="line">    println(stringBuilder.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai <span class="number">20</span></span><br></pre></td></tr></table></figure><p>其实上面 5 个标准函数有很多相似的地方，我们需搞清楚它们差异之处，下面我们用一个图表来总结一下：</p><table><thead><tr><th>标准函数</th><th>函数参数</th><th>是否是扩展函数</th><th>返回值</th></tr></thead><tbody><tr><td>T.let</td><td>it</td><td>是</td><td>最后一行代码</td></tr><tr><td>T.also</td><td>it</td><td>是</td><td>对象本身</td></tr><tr><td>with</td><td>this</td><td>否</td><td>最后一行代码</td></tr><tr><td>T.run</td><td>this</td><td>是</td><td>最后一行代码</td></tr><tr><td>T.apply</td><td>this</td><td>是</td><td>对象本身</td></tr></tbody></table><h3 id="2、定义静态方法"><a href="#2、定义静态方法" class="headerlink" title="2、定义静态方法"></a>2、定义静态方法</h3><p>Kotlin 中没有直接提供定义为静态方法的关键字，但是提供了一些类似的语法特性来支持静态方法调用的写法</p><p>1）、使用 companion object 为一个类创建一个伴生类，然后调用这个伴生类的方法，这个方法不叫静态方法，但是可以当作静态方法调用</p><p>2）、使用 object 关键字定义一个单例类，通过单例类，去调用方法，这种方法也不叫静态方法，但是可以当作静态方法调用</p><p>3）、如果想定义真正的静态方法，Kotlin 中也提供了两种方式：1、使用 @JvmStatic 注解，且注解只能加在伴生类和单例类上的方法上面  2、定义顶层方法</p><p>4）、顶层方法就是不定义在任何类中的方法，顶层方法在任何位置都能被调用到，Kotlin 编译器会把所有的顶层方法编译成静态方法</p><p>5）、如果在 Java 中调用顶层方法，Java 默认是没有顶层方法的概念的，Kotlin 编译器会生成一个我们定义这个文件的 Java 类，例如我在 Kotlin 中的 Util.kt 文件中定义了一个顶层方法，那么就会生成一个 UtilKt 的 Java 类供在 Java 中调用</p><p>6）、在 Kotlin 中比较常用的是 单例，伴生类和顶层方法，@JvmStatic 注解用的比较少</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 Java 中我们可以这样定义一个静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> static void doAction()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin 中类似这样静态调用多种多样</span></span><br><span class="line"><span class="comment">//情况1：使用 companion object 为一个类创建一个伴生类</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   Util.doAction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"do something"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：使用 object 关键字定义一个单例类</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   Util.doAction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Util &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"do something"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="keyword">do</span> something</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况3：1、使用 @JvmStatic 注解 2、定义顶层方法</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//单例类</span></span><br><span class="line"><span class="keyword">object</span> Util &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"do something"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//伴生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"do something"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 使用 AndroidStudio 新建一个文件，在弹框中选择 File 即可，我们在这个 File 中编写一个顶层方法</span></span><br><span class="line"><span class="comment">//顶层方法在任何位置都能调用到</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"do something"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码大家可以将 Kotlin 文件转换成 Java 文件看一下，你就会发现定义真正的静态方法和非静态方法的区别</p><h2 id="七、延迟初始化和密封类"><a href="#七、延迟初始化和密封类" class="headerlink" title="七、延迟初始化和密封类"></a>七、延迟初始化和密封类</h2><h3 id="1、对变量延迟初始化"><a href="#1、对变量延迟初始化" class="headerlink" title="1、对变量延迟初始化"></a>1、对变量延迟初始化</h3><p>1）、使用 lateinit 关键字对一个变量延迟初始化</p><p>使用  lateinit 关键字注意事项：</p><p>1、只能作用于 var 属性，且该属性没有自定义 get 和 set 方法</p><p>2、该属性必须是非空类型，且不能是原生类型</p><p>2）、当你对一个变量使用了 lateinit 关键字，Kotlin 编译器就不会在去检查这个变量是否会为空了，此时你要确保它在被调用之前已经初始化了，否则程序运行的时候会报错，可以使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化</p><p>3）、使用 by lazy 对一个变量延迟初始化</p><p>使用 by lazy 注意事项：</p><p>1、只能作用于 val 属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1：使用 lateinit 关键字对一个变量延迟初始化</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   name = <span class="string">"erdai"</span></span><br><span class="line">   println(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2: 使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(::name.isInitialized)&#123;</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        println(<span class="string">"name not been initialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">name not been initialized</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况3: 使用 by lazy 对一个变量延迟初始化</span></span><br><span class="line"><span class="comment">//特点：该属性调用的时候才会初始化，且 lazy 后面的 Lambda 表达式只会执行一次</span></span><br><span class="line"><span class="keyword">val</span> name: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="string">"erdai"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai</span><br></pre></td></tr></table></figure><h3 id="2、使用密封类优化代码"><a href="#2、使用密封类优化代码" class="headerlink" title="2、使用密封类优化代码"></a>2、使用密封类优化代码</h3><p>密封类能使我们写出更加规范和安全的代码</p><p>1）、使用 sealed class 定义一个密封类</p><p>2）、密封类及其子类，只能定义在同一个文件的顶层位置</p><p>3）、密封类可被继承</p><p>4）、当我们使用条件语句的时候，需要实现密封类所有子类的情况，避免写出永远不会执行的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在使用密封类之前我们可能会写出这种代码</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Result</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Success</span> : <span class="type">Result</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure</span> : <span class="type">Result</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 那么此时如果我新增一个类实现 Result 接口，编译器并不会提示我们去新增新的条件分支</span></span><br><span class="line"><span class="comment"> * 如果我们没有新增相应的条件分支，那么就会出现执行 else 的情况</span></span><br><span class="line"><span class="comment"> * 其实这个 else 就是一个无用分支，这仅仅是为了满足编译器的要求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span> (result)&#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; <span class="string">"Success"</span></span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; <span class="string">"Failure"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用密封类之后</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Success</span> : <span class="type">Result</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure</span> : <span class="type">Result</span></span>()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此时我们就避免了写 else 分支，这个时候如果我新增一个类实现 Result 密封类</span></span><br><span class="line"><span class="comment"> * 编译器就会提示异常，需要 when 去新增相应的条件分支</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span> (result)&#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; <span class="string">"Success"</span></span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; <span class="string">"Failure"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、扩展函数和运算符"><a href="#八、扩展函数和运算符" class="headerlink" title="八、扩展函数和运算符"></a>八、扩展函数和运算符</h2><h3 id="1、大有用途的扩展函数"><a href="#1、大有用途的扩展函数" class="headerlink" title="1、大有用途的扩展函数"></a>1、大有用途的扩展函数</h3><p>扩展函数允许我们去扩展一个类的函数，这种特性是 Java 中所没有的</p><p>1）、扩展函数的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassName.<span class="title">methodName</span><span class="params">(params1: <span class="type">Int</span>, params2: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于普通的函数，扩展函数只需要在函数前面加上一个 ClassName. 的语法结构，就表示把该函数添加到指定的类中</p><p>2）、一般我们要定义哪个类的扩展函数，我们就定义一个同名的 Kotlin 文件，便于后续查找，虽然说也可以定义在任何一个类中，但是更推荐将它定义成顶层方法，这样可以让扩展方法拥有全局的访问域</p><p>3）、扩展函数默认拥有这个类的上下文环境</p><p>例如我们现在要给 String 这个类扩展一个 printString 方法，我们就可以新建一个 String.kt 的文件，然后在这个文件下面编写扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">printString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"erdai"</span></span><br><span class="line">    name.printString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">erdai</span><br></pre></td></tr></table></figure><h3 id="2、有趣的运算符重载"><a href="#2、有趣的运算符重载" class="headerlink" title="2、有趣的运算符重载"></a>2、有趣的运算符重载</h3><p>Kotlin 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作</p><p>1）运算符重载使用的是 operator 关键字，我们只需要在指定函数前面加上 operator 关键字，就可以实现运算符重载的功能了。</p><p>上面所说的指定函数有下面这些，如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df8ae50fc7cf4799bebe405014069ddd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210319102601471"></p><p>2）例如我现在要实现两个对象相加的功能，它的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(obj: <span class="type">Obj</span>)</span></span>: Obj&#123;</span><br><span class="line">     <span class="comment">//do something</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来实现一个金钱相加的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现运算符重载 Money + Money</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money.value</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现运算符重载 Money + Int</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Int</span>)</span></span>: Money&#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> money1 = Money(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">val</span> money2 = Money(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> money3 = money1 + money2</span><br><span class="line">    <span class="keyword">val</span> money4 = money3 + <span class="number">15</span></span><br><span class="line">    println(money3.value)</span><br><span class="line">    print(money4.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="九、高阶函数详解"><a href="#九、高阶函数详解" class="headerlink" title="九、高阶函数详解"></a>九、高阶函数详解</h2><p>高阶函数和 Lambda 表达式是密不可分的，在之前的章节，我们学习了一些 函数式 Api 的用法，你会发现，它们都会有一个共同的特点：需要传入一个 Lambda 表达式作为参数。像这种接收 Lambda 表达式的函数我们就可以称之为具有函数式编程风格的 Api，而如果你要定义自己的函数式 Api，那么就需要使用高阶函数来实现了</p><h3 id="1、定义高阶函数"><a href="#1、定义高阶函数" class="headerlink" title="1、定义高阶函数"></a>1、定义高阶函数</h3><p>1）高阶函数的定义：一个函数接收另外一个函数作为参数，或者返回值，那么就可以称之为高阶函数</p><p>Kotlin 中新增了函数类型，如果我们将这种函数类型添加到一个函数的参数声明或者返回值，那么这就是一个高阶函数</p><p>2）函数类型的语法规则如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(String,<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="comment">//或者如下</span></span><br><span class="line">() -&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><p>-&gt; 的左边声明函数接收什么类型的参数，-&gt; 的右边声明的是函数的返回值，现在我们来声明一个高阶函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(func: (<span class="type">String</span>,<span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）高阶函数的调用，我们只需要在参数名后面加上一对括号，传入对应类型的参数即可，例如以上面定义的这个高阶函数为例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(func: (<span class="type">String</span>,<span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="comment">//函数类型调用</span></span><br><span class="line">    func(<span class="string">"erdai"</span>,<span class="number">666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就来实践一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们使用高阶函数来获取两个数相加的和</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numberPlus</span><span class="params">(num1: <span class="type">Int</span>,num2: <span class="type">Int</span>,func: (<span class="type">Int</span>,<span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sum = func(num1,num2)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(num1: <span class="type">Int</span>,num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(num1: <span class="type">Int</span>,num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用高阶函数的两种方式</span></span><br><span class="line"><span class="comment">//方式1：成员引用，使用 ::plus，::minus这种写法引用一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numberPlus = numberPlus(<span class="number">10</span>, <span class="number">20</span>, ::plus)</span><br><span class="line">    <span class="keyword">val</span> numberMinus = numberPlus(<span class="number">10</span>, <span class="number">20</span>, ::minus)</span><br><span class="line">    println(numberPlus)</span><br><span class="line">    println(numberMinus)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">-10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：使用 Lambda 表达式的写法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numberPlus = numberPlus(<span class="number">10</span>, <span class="number">20</span>)&#123; num1,num2 -&gt;</span><br><span class="line">        num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> numberMinus = numberPlus(<span class="number">10</span>, <span class="number">20</span>)&#123; num1,num2 -&gt;</span><br><span class="line">        num1 - num2</span><br><span class="line">    &#125;</span><br><span class="line">    println(numberPlus)</span><br><span class="line">    println(numberMinus)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">-10</span></span><br></pre></td></tr></table></figure><p>其中使用 Lambda 表达式的写法是高阶函数中最普遍的调用方式</p><h3 id="2、内联函数的作用"><a href="#2、内联函数的作用" class="headerlink" title="2、内联函数的作用"></a>2、内联函数的作用</h3><p>1）内联函数可以消除 Lambda 表达式运行时带来的开销</p><p>Kotlin 代码最终还是会转换成 Java 字节码文件，举个🌰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numberPlus</span><span class="params">(num1: <span class="type">Int</span>,num2: <span class="type">Int</span>,func: (<span class="type">Int</span>,<span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sum = func(num1,num2)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> num1 = <span class="number">10</span></span><br><span class="line">  <span class="keyword">val</span> num2 = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt;</span><br><span class="line">        num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这些代码最终转换成 Java 代码大概会变成这样：</span></span><br><span class="line"><span class="keyword">public</span> static int numberPlus(int num1, int num2, Function operation)&#123;</span><br><span class="line">  int sum = (int) operation.invoke(num1,num2);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static void main()&#123;</span><br><span class="line">  int num1 = <span class="number">10</span>;</span><br><span class="line">  int num2 = <span class="number">20</span>;</span><br><span class="line">  int sum = numberPlus(num1,num2,new Function()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Integer invoke(Integer num1,Integer num2)&#123;</span><br><span class="line">          <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，转换之后，numberPlus 函数的第三个参数变成了一个 Function 接口，这是一种 Kotlin 的内置接口，里面有一个待实现的 invoke 函数，而 numberPlus 函数其实就是调用了 Function 接口的 invoke 函数，并把 num1 和 num2 传了进去。之前的 Lambda 表达式在这里变成了 Function 接口的匿名类实现，这就是 Lambda 表达式的底层转换逻辑，因此我们每调用一次 Lambda 表达式，都会创建一个新的匿名类实例，这样就会造成额外的内存和性能开销。但是我们使用内联函数，就可以很好的去解决这个问题</p><p>2）定义高阶函数时加上 inline 关键字修饰，我们就可以把这个函数称之为内联函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个内联函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">numberPlus</span><span class="params">(num1: <span class="type">Int</span>,num2: <span class="type">Int</span>,func: (<span class="type">Int</span>,<span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sum = func(num1,num2)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那这里我就会有个疑问，为啥内联函数能消除 Lambda 表达式运行时带来的开销呢？</strong></p><p>这个时候我们就需要去剖析一下内联函数的工作原理了，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">numberPlus</span><span class="params">(num1: <span class="type">Int</span>,num2: <span class="type">Int</span>,func: (<span class="type">Int</span>,<span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sum = func(num1,num2)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt;</span><br><span class="line">        num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步替换过程：Kotlin 编译器会把 Lambda 表达式中的代码替换到函数类型参数调用的地方</strong> ，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d72c3b1f9004f1f8fbea4f3f8353a3b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318103738396"></p><p>替换后代码变成了这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">numberPlus</span><span class="params">(num1: <span class="type">Int</span>,num2: <span class="type">Int</span>,func: (<span class="type">Int</span>,<span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sum = num1 + num2</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> numberPlus = numberPlus(num1, num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步替换过程：Kotlin 编译器会把内联函数中的全部代码替换到函数调用的地方</strong> ，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ed6033ee5354e8e8752ac4255fbb2ce~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318104214303"></p><p>替换后代码变成了这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> numberPlus = num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述步骤就是内联函数的一个工作流程：<strong>Kotlin 编译器会把内联函数中的代码在编译的时候自动替换到调用它的地方</strong> ，这样也就不存在运行时的开销了</p><p>3）使用 noinline 关键字修饰的函数类型参数，表示该函数类型参数不需要进行内联</p><p>一般使用 noinline 关键字，是在一个内联函数中存在多个函数类型的参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用内联函数定义的高阶函数，其里面的函数类型参数都会进行内联，因此这里使用 noinline 表示我这个函数类型参数不需要内联</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">inlineTest</span><span class="params">(block1: ()</span></span> -&gt; <span class="built_in">Unit</span>, <span class="keyword">noinline</span> block2: () -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们讲到，使用内联函数能减少运行时开销，为啥现在又要出来个 noinline 关键字定义不需要内联呢？原因如下：</p><p>1、内联函数在编译的时候会进行代码替换，因此它没有真正的参数属性，它的函数类型参数只能传递给另外一个内联函数，而非内联函数的函数类型参数可以自由的传递给其他任何函数</p><p>2、内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回，非内联函数所引用的 Lambda 表达式可以使用 return@Method 语法结构来进行局部返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1：非内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行局部返回</span></span><br><span class="line"><span class="comment">//定义一个非内联的高阶函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printString</span><span class="params">(str: <span class="type">String</span>, block: (<span class="type">String</span>)</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    println(<span class="string">"printString start..."</span>)</span><br><span class="line">    block(str)</span><br><span class="line">    println(<span class="string">"printString end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"main start..."</span>)</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">""</span></span><br><span class="line">    printString(str)&#123;</span><br><span class="line">        println(<span class="string">"lambda start..."</span>)</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1，非内联函数不能直接使用 return 关键字进行局部返回</span></span><br><span class="line"><span class="comment"> * 2，需要使用 return<span class="doctag">@printString</span> 进行局部返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty())<span class="keyword">return</span><span class="symbol">@printString</span></span><br><span class="line">        println(it)</span><br><span class="line">        println(<span class="string">"lambda end..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"main end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">main start...</span><br><span class="line">printString start...</span><br><span class="line">lambda start...</span><br><span class="line">printString end...</span><br><span class="line">main end...</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回</span></span><br><span class="line"><span class="comment">//定义一个非内联的高阶函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">printString</span><span class="params">(str: <span class="type">String</span>, block: (<span class="type">String</span>)</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    println(<span class="string">"printString start..."</span>)</span><br><span class="line">    block(str)</span><br><span class="line">    println(<span class="string">"printString end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"main start..."</span>)</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">""</span></span><br><span class="line">    printString(str)&#123;</span><br><span class="line">        println(<span class="string">"lambda start..."</span>)</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty())<span class="keyword">return</span></span><br><span class="line">        println(it)</span><br><span class="line">        println(<span class="string">"lambda end..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"main end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为内联函数会进行代码替换，因此这个 return 就相当于外层函数调用的一个返回，如下代码：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"main start..."</span>)</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">""</span></span><br><span class="line">    println(<span class="string">"printString start..."</span>)</span><br><span class="line">    println(<span class="string">"lambda start..."</span>)</span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty())<span class="keyword">return</span></span><br><span class="line">    println(str)</span><br><span class="line">    println(<span class="string">"lambda end..."</span>)</span><br><span class="line">    println(<span class="string">"printString end..."</span>)</span><br><span class="line">    println(<span class="string">"main end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">main start...</span><br><span class="line">printString start...</span><br><span class="line">lambda start...</span><br></pre></td></tr></table></figure><p>4）、使用 crossinline 关键字保证内联函数的 Lambda 表达式中一定不会使用 return 关键字，但是还是可以使用 return@Method 语法结构进行局部返回，其他方面和内联函数特性一致</p><p>举个使用 crossinline 场景的🌰 ：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7beec9bdbb4e789d1814381accc36f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318115342264"></p><p>上面图片中的代码报错了，编译器提示我们的大致原因是：这个地方不能使用 inline ,因为它可能包含非局部的 return 返回，添加 crossinline 修饰符去修饰这个函数类型的参数。</p><p>为啥呢？我们来分析一下：</p><p>我们创建了一个 Runnable 对象，在 Runnable 中的 Lambda 表达式中调用了函数类型参数，Lambda 表达式在编译的时候会被转换成匿名内部类的方式，内联函数允许我们在 Lambda 表达式中使用 return 关键字进行函数返回，但是由于我们是在匿名类中调用的函数类型参数，此时是不可能进行外层调用函数返回的，最多是在匿名函数中进行返回，因此这里就提示了错误，知道了原因那我们使用 crossinline 关键字来修改一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(<span class="keyword">crossinline</span> block: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    println(<span class="string">"runRunnable start..."</span>)</span><br><span class="line">    <span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    runnable.run()</span><br><span class="line">    println(<span class="string">"runRunnable end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"main start..."</span>)</span><br><span class="line">    runRunnable &#123;</span><br><span class="line">        println(<span class="string">"lambda start..."</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@runRunnable</span></span><br><span class="line">        println(<span class="string">"lambda end..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"main end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">main start...</span><br><span class="line">runRunnable start...</span><br><span class="line">lambda start...</span><br><span class="line">runRunnable end...</span><br><span class="line">main end...</span><br></pre></td></tr></table></figure><h2 id="十、泛型和委托"><a href="#十、泛型和委托" class="headerlink" title="十、泛型和委托"></a>十、泛型和委托</h2><h3 id="1、泛型的基本用法"><a href="#1、泛型的基本用法" class="headerlink" title="1、泛型的基本用法"></a>1、泛型的基本用法</h3><p>1）、首先我们解释下什么是泛型，泛型就是参数化类型，它允许我们在不指定具体类型的情况下进行编程。我们在定义一个类，方法，或者接口的时候，给他们加上一个类型参数，就是为这个类，方法，或者接口添加了一个泛型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、定义一个泛型类，在类名后面使用 &lt;T&gt; 这种语法结构就是为这个类定义一个泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(params: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型调用</span></span><br><span class="line"><span class="keyword">val</span> myClass = MyClass&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">myClass.method(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、定义一个泛型方法，在方法名的前面加上 &lt;T&gt; 这种语法结构就是为这个方法定义一个泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">method</span><span class="params">(params: <span class="type">T</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型调用</span></span><br><span class="line"><span class="keyword">val</span> myClass = MyClass()</span><br><span class="line">myClass.method&lt;<span class="built_in">Int</span>&gt;(<span class="number">12</span>)</span><br><span class="line"><span class="comment">//根据 Kotlin 类型推导机制，我们可以把泛型给省略</span></span><br><span class="line">myClass.method(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、定义一个泛型接口，在接口名后面加上 &lt;T&gt; 这种语法结构就是为这个接口定义一个泛型</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">interfaceMethod</span><span class="params">(params: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 T 不是固定的，可以是任意单词和字母，但是定义的泛型尽量做到见名知义</p><p>2）、为泛型指定上界，我们可以使用 <code>&lt;T : Class&gt;</code> 这种语法结构，如果不指定泛型的上界，默认为 Any? 类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">  <span class="comment">//我们指定了泛型的上界为 Number, 那么我们就只能传入数字类型的参数了</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Number&gt;</span> <span class="title">method</span><span class="params">(params: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、类委托和委托属性"><a href="#2、类委托和委托属性" class="headerlink" title="2、类委托和委托属性"></a>2、类委托和委托属性</h3><p>委托模式的意义：<strong>在于我们大部分方法实现可以调用辅助对象去实现，少部分方法的实现由自己来重写，甚至加入一些自己独有的方法，使我们这个类变成一个全新数据结构的类</strong></p><p>1）、类委托核心思想就是把一个类的具体实现委托给另外一个类，使用 by 关键字进行委托</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个 MySet 类，它里面的具体实现都委托给了 HashSet 这个类，这是是类委托</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = helperSet.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span> = helperSet.contains(element)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span> = helperSet.containsAll(elements)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = helperSet.isEmpty()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = helperSet.iterator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果我们使用 by 关键字，上面的代码将会变得非常整洁，同时我们可以对某个方法进行重写或者新增方法</span></span><br><span class="line"><span class="comment"> * 那么 MySet 就变成了一个全新的数据结构类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; <span class="keyword">by</span> helperSet&#123;</span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">helloWord</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）、属性委托的核心思想是将一个属性的具体实现委托给另一个类去完成</p><p>属性委托的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 by 关键字连接了左边的 p 属性和右边的 Delegate 实例</span></span><br><span class="line"><span class="comment">* 这种写法就代表着将 p 属性的具体实现委托给了 Delegate 去完成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> p <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面是一个被委托类的代码实现模版</span></span><br><span class="line"><span class="comment">* 一、getValue 方法和setValue 方法必须使用 operator 关键字修饰</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 二、getValue 方法主要接收两个参数：</span></span><br><span class="line"><span class="comment">* 1、第一个参数表明 Delegate 类的委托功能可以在什么类中使用</span></span><br><span class="line"><span class="comment">* 2、第二个参数 KProperty&lt;*&gt; 是 Kotlin 中的一个属性操作类，</span></span><br><span class="line"><span class="comment">*    可用于获取各种属性的相关值，&lt;*&gt;这种泛型的写法类似 Java 的</span></span><br><span class="line"><span class="comment">*    &lt;?&gt;，表示我不关心泛型的具体类型</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 三、setValue 方法也是相似的，接收三个参数：</span></span><br><span class="line"><span class="comment">* 1、前面两个参数和 getValue 是一样的</span></span><br><span class="line"><span class="comment">* 2、第三个参数表示具体要赋值给委托属性的值，这个参数的类型必须和</span></span><br><span class="line"><span class="comment">*    getValue 方法返回值的类型保持一致</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 一种特殊情况：用 val 定义的变量不需要实现 setValue 方法，因为 val</span></span><br><span class="line"><span class="comment">*             关键字声明的属性只可读，赋值之后就不能更改了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> propValue: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(any: <span class="type">Any</span>?,prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Any?&#123;</span><br><span class="line">       <span class="keyword">return</span> propValue</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(any: <span class="type">Any</span>?,prop: <span class="type">KProperty</span>&lt;*&gt;,value: <span class="type">Any</span>?)</span></span>&#123;</span><br><span class="line">       propValue = value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、使用-infix-函数构建更可读的语法"><a href="#十一、使用-infix-函数构建更可读的语法" class="headerlink" title="十一、使用 infix 函数构建更可读的语法"></a>十一、使用 infix 函数构建更可读的语法</h2><p>infix 函数语法结构可读性高，相比于调用一个函数，它更接近于使用英语 A to B 这样的语法结构</p><p>例如我们调用一个函数会使用： A.to(B) 这种结构，但是使用 infix 函数我们可以这么写：A to B，这种语法我们在讲 Map 的时候用过</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个不可变 Map 集合</span></span><br><span class="line"><span class="keyword">val</span> map1 = mapOf(<span class="string">"Apple"</span> to <span class="number">1</span>,<span class="string">"Banana"</span> to <span class="number">2</span>,<span class="string">"Orange"</span> to <span class="number">3</span>, <span class="string">"Pear"</span> to <span class="number">4</span>,<span class="string">"Grape"</span> to <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>1）、在函数前面加上 infix 关键字，就可以声明这是一个 infix 函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 String 增加一个扩展的 infix 函数，最终调用的还是 String 的 startsWith 函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">beginWith</span><span class="params">(string: <span class="type">String</span>)</span></span> = startsWith(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"erdai"</span></span><br><span class="line">    println(name beginWith <span class="string">"er"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们再来实现一个初始化 Map 时里面传入 A to B 这种 infix 函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是 A to B 的源码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们仿照它写一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A,B&gt;</span> A.<span class="title">with</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A,B&gt; = Pair(<span class="keyword">this</span>,that)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="string">"Apple"</span> with <span class="number">1</span>,<span class="string">"Banana"</span> with <span class="number">2</span>,<span class="string">"Orange"</span> with <span class="number">3</span>,<span class="string">"Pear"</span> with <span class="number">4</span>,<span class="string">"Grape"</span> with <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、使用-DSL-构建专有的语法结构"><a href="#十二、使用-DSL-构建专有的语法结构" class="headerlink" title="十二、使用 DSL 构建专有的语法结构"></a>十二、使用 DSL 构建专有的语法结构</h2><p>1）、DSL 介绍</p><p>DSL英文全称：<strong>domain specific language</strong>，中文翻译即领域特定语言，例如：HTML，XML等 DSL 语言</p><p><strong>特点</strong></p><ul><li>解决特定领域的专有问题</li><li>它与系统编程语言走的是两个极端，系统编程语言是希望解决所有的问题，比如 Java 语言希望能做 Android 开发，又希望能做后台开发，它具有横向扩展的特性。而 DSL 具有纵向深入解决特定领域专有问题的特性。</li></ul><p>总的来说，DSL 的<strong>核心思想</strong>就是：“求专不求全，解决特定领域的问题”。</p><p>2）Kotin DSL</p><p>首先介绍一下Gradle：Gradle 是一个开源的自动化构建工具，是一种基于 Groovy 或 Kotin 的 DSL。我们的 Android 应用就是使用 Gradle 构建的，因此后续写脚本，写插件，我们可以使用 Kotlin 去编写，而且 AndroidStudio 对 Kotlin 的支持很友好，各种提示，写起来很爽。</p><p>对于我们 Android 开发，在 build.gradle 文件里面添加依赖的方式很常见：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'androidx.core:core-ktx:1.3.2'</span></span><br><span class="line">    implementation <span class="string">'androidx.appcompat:appcompat:1.2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法是一种基于 Groovy 的 DSL，下面我们就使用 Kotlin 来实现一个类似的 DSL：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dependency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">implementation</span><span class="params">(lib: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">(block: <span class="type">Dependency</span>.()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    <span class="keyword">val</span> dependency = Dependency()</span><br><span class="line">    dependency.block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//因为 Groovy 和 Kotlin 语法不同，因此写法会有一点区别</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        implementation (<span class="string">"androidx.core:core-ktx:1.3.2"</span>)</span><br><span class="line">        implementation (<span class="string">"androidx.appcompat:appcompat:1.2.0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十三、Java-与-Kotlin-代码之间的转换"><a href="#十三、Java-与-Kotlin-代码之间的转换" class="headerlink" title="十三、Java 与 Kotlin 代码之间的转换"></a>十三、Java 与 Kotlin 代码之间的转换</h2><h3 id="Java-代码转-Kotlin-代码"><a href="#Java-代码转-Kotlin-代码" class="headerlink" title="Java 代码转 Kotlin 代码"></a>Java 代码转 Kotlin 代码</h3><p>方式有2：</p><p>1）、直接将 Java 代码复制到 Kotlin 文件中，AndroidStudio 会出来提示框询问你是否转换</p><p>2）、打开要转换的 Java 文件，在导航栏点击 Code -&gt; Convert Java File to Kotlin File</p><h3 id="Kotlin-代码转-Java-代码"><a href="#Kotlin-代码转-Java-代码" class="headerlink" title="Kotlin 代码转 Java 代码"></a>Kotlin 代码转 Java 代码</h3><p>打开当前需要转换的 Kotlin 文件，在导航栏点击 Tools -&gt; Kotlin -&gt;Show Kotlin Bytecode ，会出来如下界面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0008a17b27f4c8990ad726501654dbd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210318152946177"></p><p>点击 Decompile 就可以把 Kotlin 字节码文件反编译成 Java 代码了</p><h2 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h2><p>本篇文章很长，我们介绍了 Kotlin 大部分知识点，按照文章开头的思维导图，我们就只剩下 Kotlin 泛型高级特性和 Kotlin 携程没有讲了，这两部分相对来说比较难，咋们后续在来仔细分析。相信你如果从头看到这里，收获一定很多，如果觉得我写得还不错，请给我点个赞吧🤝</p><p>转发：<a href="https://juejin.cn/post/6942251919662383134" target="_blank" rel="noopener">https://juejin.cn/post/6942251919662383134</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02ae1fd55784c0593e53afa00fd1fec~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;image-20210116114509401&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意： Kotlin 现作为 Android 第一开发语言，AndroidStudio 作为 Google 的亲儿子，对 Kotlin 进行了完美的支持，开发提示应有尽有，因此下面所有的演示代码都是跑在 AndroidStudio 上的&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin5种单列模式</title>
    <link href="https://zhangmiao.cc/posts/44748309.html"/>
    <id>https://zhangmiao.cc/posts/44748309.html</id>
    <published>2020-09-25T03:15:57.000Z</published>
    <updated>2020-09-25T03:20:01.661Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Kotlin这门语言，在项目开发中，运用到了单例模式。因为其表达方式与Java是不同的。所以对不同单例模式的实现进行了分别探讨。主要单例模式实现如下：</p><ul><li>饿汉式</li><li>懒汉式</li><li>线程安全的懒汉式</li><li>双重校验锁式</li><li>静态内部类式</li></ul><p><strong>PS:该篇文章不讨论单例模式的运用场景与各种模式下的单例模式的优缺点。只讨论在Java下不同单例模式下的对应Kotlin实现。</strong></p><h4 id="一、饿汉式实现"><a href="#一、饿汉式实现" class="headerlink" title="一、饿汉式实现"></a><strong>一、饿汉式实现</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static SingletonDemo instance=new SingletonDemo();</span><br><span class="line">    <span class="keyword">private</span> SingletonDemo()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static SingletonDemo getInstance()&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin实现</span></span><br><span class="line"><span class="keyword">object</span> SingletonDemo</span><br></pre></td></tr></table></figure><p>这里很多小伙伴，就吃了一惊。我靠一个object 关键字就完成相同的功能？一行代码？</p><ul><li><h5 id="Kotlin的对象声明"><a href="#Kotlin的对象声明" class="headerlink" title="Kotlin的对象声明"></a><strong>Kotlin的对象声明</strong></h5></li></ul><p>学习了Kotlin的小伙伴肯定知道,在Kotlin中类没有静态方法。如果你需要写一个可以无需用一个类的实例来调用，但需要访问类内部的函数（例如，工厂方法,单例等），你可以把该类声明为一个对象。</p><p>该对象与其他语言的静态成员是类似的。如果你想了解Kotlin对象声明的更多内容。请点击- - - 传送门(<a href="https://www.kotlincn.net/docs/reference/object-declarations.html#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/object-declarations.html#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1</a>)</p><p>到这里，如果还是有很多小伙伴不是很相信一行代码就能解决这个功能，我们可以通过一下方式查看Kotlin的字节码。</p><a id="more"></a><ul><li><h5 id="查看Kotlin对应字节码"><a href="#查看Kotlin对应字节码" class="headerlink" title="查看Kotlin对应字节码"></a><strong>查看Kotlin对应字节码</strong></h5></li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200925111912.png" alt></p><p>我们进入我们的Android Studio选择Tools工具栏，选择”Kotlin”,选择“Show Kotlin Bytecode”</p><p>选择过后就会进入到下方界面：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200925111925.png" alt></p><p>点击<strong>“Decompile”</strong> 根据字节码得到以下代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> SingletonDemo INSTANCE;</span><br><span class="line">   <span class="keyword">private</span> SingletonDemo()&#123;&#125;</span><br><span class="line">   static &#123;</span><br><span class="line">      SingletonDemo var0 = new SingletonDemo();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们了解事实就是这个样子的，使用Kotlin”object”进行对象声明与我们的饿汉式单例的代码是相同的。</p><h4 id="二、懒汉式"><a href="#二、懒汉式" class="headerlink" title="二、懒汉式"></a><strong>二、懒汉式</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static SingletonDemo instance;</span><br><span class="line">    <span class="keyword">private</span> SingletonDemo()&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> static SingletonDemo getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance=new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kotlin实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDemo? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                    field = SingletonDemo()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> field</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: SingletonDemo&#123;</span><br><span class="line">        <span class="comment">//细心的小伙伴肯定发现了，这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字</span></span><br><span class="line">         <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们可以发现在Kotlin实现中，我们让其主构造函数私有化并自定义了其属性访问器，其余内容大同小异。</p><ul><li>如果有小伙伴不清楚Kotlin构造函数的使用方式。请点击 - - - 构造函数(<a href="https://www.kotlincn.net/docs/reference/classes.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/classes.html</a>)</li><li>不清楚Kotlin的属性与访问器，请点击 - - -属性和字段(<a href="https://www.kotlincn.net/docs/reference/properties.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/properties.html</a>)</li></ul><h4 id="三、线程安全的懒汉式"><a href="#三、线程安全的懒汉式" class="headerlink" title="三、线程安全的懒汉式"></a><strong>三、线程安全的懒汉式</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static SingletonDemo instance;</span><br><span class="line">    <span class="keyword">private</span> SingletonDemo()&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> static synchronized SingletonDemo getInstance()&#123;<span class="comment">//使用同步锁</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance=new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kotlin实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDemo? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                    field = SingletonDemo()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> field</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: SingletonDemo&#123;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家都知道在使用懒汉式会出现线程安全的问题，需要使用使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加<strong>@Synchronized</strong>注解。</p><h4 id="四、双重校验锁式（Double-Check"><a href="#四、双重校验锁式（Double-Check" class="headerlink" title="四、双重校验锁式（Double Check)"></a><strong>四、双重校验锁式（Double Check)</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> static SingletonDemo instance;</span><br><span class="line">    <span class="keyword">private</span> SingletonDemo()&#123;&#125; </span><br><span class="line">    <span class="keyword">public</span> static SingletonDemo getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (SingletonDemo.<span class="keyword">class</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=new SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: SingletonDemo <span class="keyword">by</span> lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">        SingletonDemo() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的延迟属性 Lazy。</p><p>Lazy是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托：第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</p><p>这里还有有两个额外的知识点。</p><ul><li>高阶函数，高阶函数是将函数用作参数或返回值的函数（我很纠结我到底讲不讲，哎）。大家还是看这个 —高阶函数(<a href="https://www.kotlincn.net/docs/reference/lambdas.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/lambdas.html</a>)</li><li>委托属性(<a href="https://www.kotlincn.net/docs/reference/delegated-properties.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/delegated-properties.html</a>)</li></ul><p>如果你了解以上知识点，我们直接来看Lazy的内部实现。</p><ul><li><h5 id="Lazy内部实现"><a href="#Lazy内部实现" class="headerlink" title="Lazy内部实现"></a><strong>Lazy内部实现</strong></h5></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: ()</span></span> -&gt; T): Lazy&lt;T&gt; =</span><br><span class="line">        <span class="keyword">when</span> (mode) &#123;</span><br><span class="line">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class="line">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class="line">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，因为我们传入的mode = <strong>LazyThreadSafetyMode.SYNCHRONIZED</strong>，<br>那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。</p><ul><li><h5 id="Lazy接口"><a href="#Lazy接口" class="headerlink" title="Lazy接口"></a><strong>Lazy接口</strong></h5></li></ul><h5 id="SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下："><a href="#SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：" class="headerlink" title="SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下："></a>SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lazy</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">//当前实例化对象，一旦实例化后，该对象不会再改变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</span><br><span class="line">    <span class="comment">//返回true表示，已经延迟实例化过了，false 表示，没有被实例化，</span></span><br><span class="line">    <span class="comment">//一旦方法返回true，该方法会一直返回true,且不会再继续实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看SynchronizedLazyImpl，具体实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;</span>(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</span><br><span class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line">    <span class="comment">// final field is required to enable safe publication of constructed instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> _v1 = _value</span><br><span class="line">            <span class="comment">//判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></span><br><span class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">val</span> _v2 = _value</span><br><span class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                    <span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span> (_v2 <span class="keyword">as</span> T)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> typedValue = initializer!!()<span class="comment">//调用高级函数获取其返回值</span></span><br><span class="line">                    _value = typedValue   <span class="comment">//将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值</span></span><br><span class="line">                    initializer = <span class="literal">null</span></span><br><span class="line">                    typedValue  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。</p><p>到里这里其实大家还是肯定有疑问，我这里<strong>只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢</strong>？。这里又涉及到了<strong>委托属性</strong>。</p><p>委托属性语法是：val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。</p><p>而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="comment">//返回初始化的值。</span></span><br><span class="line">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value</span><br></pre></td></tr></table></figure><h4 id="五、静态内部类式"><a href="#五、静态内部类式" class="headerlink" title="五、静态内部类式"></a><strong>五、静态内部类式</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> static SingletonDemo instance=new SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> SingletonDemo()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Singleton has loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static SingletonDemo getInstance()&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance = SingletonHolder.holder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> SingletonHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> holder= SingletonDemo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类的实现方式，也没有什么好说的。Kotlin与Java实现基本雷同。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h3><p>在该篇文章结束后，有很多小伙伴咨询，如何在Kotlin版的Double Check，给单例添加一个属性，这里我给大家提供了一个实现的方式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> property: <span class="built_in">Int</span>) &#123;<span class="comment">//这里可以根据实际需求发生改变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDemo? = <span class="literal">null</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(property: <span class="type">Int</span>)</span></span> =</span><br><span class="line">                instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                    instance ?: SingletonDemo(property).also &#123; instance = it &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关于?:操作符，如果 ?: 左侧表达式非空，就返回其左侧表达式，否则返回右侧表达式。请注意，当且仅当左侧为空时，才会对右侧表达式求值。</p><p>观察代码我们可以发现大致上和我们的Java中的Double check是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习Kotlin这门语言，在项目开发中，运用到了单例模式。因为其表达方式与Java是不同的。所以对不同单例模式的实现进行了分别探讨。主要单例模式实现如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;饿汉式&lt;/li&gt;
&lt;li&gt;懒汉式&lt;/li&gt;
&lt;li&gt;线程安全的懒汉式&lt;/li&gt;
&lt;li&gt;双重校验锁式&lt;/li&gt;
&lt;li&gt;静态内部类式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS:该篇文章不讨论单例模式的运用场景与各种模式下的单例模式的优缺点。只讨论在Java下不同单例模式下的对应Kotlin实现。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;一、饿汉式实现&quot;&gt;&lt;a href=&quot;#一、饿汉式实现&quot; class=&quot;headerlink&quot; title=&quot;一、饿汉式实现&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、饿汉式实现&lt;/strong&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Java实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonDemo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; static SingletonDemo instance=new SingletonDemo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SingletonDemo()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; static SingletonDemo getInstance()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Kotlin实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; SingletonDemo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里很多小伙伴，就吃了一惊。我靠一个object 关键字就完成相同的功能？一行代码？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h5 id=&quot;Kotlin的对象声明&quot;&gt;&lt;a href=&quot;#Kotlin的对象声明&quot; class=&quot;headerlink&quot; title=&quot;Kotlin的对象声明&quot;&gt;&lt;/a&gt;&lt;strong&gt;Kotlin的对象声明&lt;/strong&gt;&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习了Kotlin的小伙伴肯定知道,在Kotlin中类没有静态方法。如果你需要写一个可以无需用一个类的实例来调用，但需要访问类内部的函数（例如，工厂方法,单例等），你可以把该类声明为一个对象。&lt;/p&gt;
&lt;p&gt;该对象与其他语言的静态成员是类似的。如果你想了解Kotlin对象声明的更多内容。请点击- - - 传送门(&lt;a href=&quot;https://www.kotlincn.net/docs/reference/object-declarations.html#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.kotlincn.net/docs/reference/object-declarations.html#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;到这里，如果还是有很多小伙伴不是很相信一行代码就能解决这个功能，我们可以通过一下方式查看Kotlin的字节码。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin委托</title>
    <link href="https://zhangmiao.cc/posts/a7864737.html"/>
    <id>https://zhangmiao.cc/posts/a7864737.html</id>
    <published>2020-09-19T02:35:02.000Z</published>
    <updated>2020-09-19T02:38:19.369Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.runoob.com/w3cnote/delegate-mode.html" target="_blank" rel="noopener">委托模式</a>是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p><p>Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p><hr><h2 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h2><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p><p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现此接口的被委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过关键字 by 建立委托类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p><hr><h2 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h2><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p><p>属性委托语法格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;属性名&gt;: &lt;类型&gt; <span class="keyword">by</span> &lt;表达式&gt;</span><br></pre></td></tr></table></figure><ul><li>var/val：属性类型(可变/只读)</li><li>属性名：属性名称</li><li>类型：属性的数据类型</li><li>表达式：委托代理类</li></ul><p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</p><a id="more"></a><h3 id="定义一个被委托的类"><a href="#定义一个被委托的类" class="headerlink" title="定义一个被委托的类"></a>定义一个被委托的类</h3><p>该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"><span class="comment">// 定义包含属性委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="variable">$thisRef</span>, 这里委托了 <span class="subst">$&#123;property.name&#125;</span> 属性"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$thisRef</span> 的 <span class="subst">$&#123;property.name&#125;</span> 属性赋值为 <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> e = Example()</span><br><span class="line">    println(e.p)     <span class="comment">// 访问该属性，调用 getValue() 函数</span></span><br><span class="line"></span><br><span class="line">    e.p = <span class="string">"Runoob"</span>   <span class="comment">// 调用 setValue() 函数</span></span><br><span class="line">    println(e.p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Example@</span><span class="number">433</span>c675d, 这里委托了 p 属性</span><br><span class="line"><span class="symbol">Example@</span><span class="number">433</span>c675d 的 p 属性赋值为 Runoob</span><br><span class="line"><span class="symbol">Example@</span><span class="number">433</span>c675d, 这里委托了 p 属性</span><br></pre></td></tr></table></figure><hr><h2 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h2><p>Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。</p><h3 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h3><p>lazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <t> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</t></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">"computed!"</span>)     <span class="comment">// 第一次调用输出，第二次调用不执行</span></span><br><span class="line">    <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(lazyValue)   <span class="comment">// 第一次执行，执行两次输出表达式</span></span><br><span class="line">    println(lazyValue)   <span class="comment">// 第二次执行，只输出返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed!</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><hr><h2 id="可观察属性-Observable"><a href="#可观察属性-Observable" class="headerlink" title="可观察属性 Observable"></a>可观察属性 Observable</h2><p>observable 可以用于实现观察者模式。</p><p>Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。</p><p>在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"初始值"</span>) &#123;</span><br><span class="line">        prop, old, new -&gt;</span><br><span class="line">        println(<span class="string">"旧值：<span class="variable">$old</span> -&gt; 新值：<span class="variable">$new</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User()</span><br><span class="line">    user.name = <span class="string">"第一次赋值"</span></span><br><span class="line">    user.name = <span class="string">"第二次赋值"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旧值：初始值 -&gt; 新值：第一次赋值</span><br><span class="line">旧值：第一次赋值 -&gt; 新值：第二次赋值</span><br></pre></td></tr></table></figure><hr><h2 id="把属性储存在映射中"><a href="#把属性储存在映射中" class="headerlink" title="把属性储存在映射中"></a>把属性储存在映射中</h2><p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他”动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> url: String  <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数接受一个映射参数</span></span><br><span class="line">    <span class="keyword">val</span> site = Site(mapOf(</span><br><span class="line">        <span class="string">"name"</span> to <span class="string">"菜鸟教程"</span>,</span><br><span class="line">        <span class="string">"url"</span>  to <span class="string">"www.runoob.com"</span></span><br><span class="line">    ))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取映射值</span></span><br><span class="line">    println(site.name)</span><br><span class="line">    println(site.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure><p>如果使用 var 属性，需要把 Map 换成 MutableMap：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span>(<span class="keyword">val</span> map: MutableMap&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> url: String <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map:MutableMap&lt;String, Any?&gt; = mutableMapOf(</span><br><span class="line">            <span class="string">"name"</span> to <span class="string">"菜鸟教程"</span>,</span><br><span class="line">            <span class="string">"url"</span> to <span class="string">"www.runoob.com"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> site = Site(map)</span><br><span class="line"></span><br><span class="line">    println(site.name)</span><br><span class="line">    println(site.url)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"--------------"</span>)</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"Google"</span>)</span><br><span class="line">    map.put(<span class="string">"url"</span>, <span class="string">"www.google.com"</span>)</span><br><span class="line"></span><br><span class="line">    println(site.name)</span><br><span class="line">    println(site.url)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">--------------</span><br><span class="line">Google</span><br><span class="line">www.google.com</span><br></pre></td></tr></table></figure><hr><h2 id="Not-Null"><a href="#Not-Null" class="headerlink" title="Not Null"></a>Not Null</h2><p>notNull 适用于那些无法在初始化阶段就确定属性值的场合。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> notNullBar: String <span class="keyword">by</span> Delegates.notNull&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.notNullBar = <span class="string">"bar"</span></span><br><span class="line">println(foo.notNullBar)</span><br></pre></td></tr></table></figure><p>需要注意，如果属性在赋值前就被访问的话则会抛出异常。</p><hr><h2 id="局部委托属性"><a href="#局部委托属性" class="headerlink" title="局部委托属性"></a>局部委托属性</h2><p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(computeFoo: ()</span></span> -&gt; Foo) &#123;</span><br><span class="line">    <span class="keyword">val</span> memoizedFoo <span class="keyword">by</span> lazy(computeFoo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;</span><br><span class="line">        memoizedFoo.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p><hr><h2 id="属性委托要求"><a href="#属性委托要求" class="headerlink" title="属性委托要求"></a>属性委托要求</h2><p>对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数：</p><ul><li>thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li><li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型</li></ul><p>这个函数必须返回与属性相同的类型（或其子类型）。</p><p>对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数:</p><p>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型new value —— 必须和属性同类型或者是它的超类型。</p><hr><h2 id="翻译规则"><a href="#翻译规则" class="headerlink" title="翻译规则"></a>翻译规则</h2><p>在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段是由编译器生成的相应代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> prop$delegate = MyDelegate()</span><br><span class="line">    <span class="keyword">var</span> prop: Type</span><br><span class="line">        <span class="keyword">get</span>() = prop$delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">        <span class="keyword">set</span>(value: Type) = prop$delegate.setValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。</p><hr><h2 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h2><p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p><p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。</p><p>例如，如果要在绑定之前检查属性名称，可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span>&lt;<span class="type">T</span>&gt;</span>(id: ResourceID&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            thisRef: <span class="type">MyUI</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            prop: <span class="type">KProperty</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">        checkProperty(thisRef, prop.name)</span><br><span class="line">        <span class="comment">// 创建委托</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkProperty</span><span class="params">(thisRef: <span class="type">MyUI</span>, name: <span class="type">String</span>)</span></span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">bindResource</span><span class="params">(id: <span class="type">ResourceID</span>&lt;<span class="type">T</span>&gt;)</span></span>: ResourceLoader&lt;T&gt; &#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> image <span class="keyword">by</span> bindResource(ResourceID.image_id)</span><br><span class="line">    <span class="keyword">val</span> text <span class="keyword">by</span> bindResource(ResourceID.text_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provideDelegate 的参数与 getValue 相同：</p><ul><li>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li><li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。</li></ul><p>在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。</p><p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查属性名称而不使用“provideDelegate”功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> image <span class="keyword">by</span> bindResource(ResourceID.image_id, <span class="string">"image"</span>)</span><br><span class="line">    <span class="keyword">val</span> text <span class="keyword">by</span> bindResource(ResourceID.text_id, <span class="string">"text"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MyUI.<span class="title">bindResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        id: <span class="type">ResourceID</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        propertyName: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">   checkProperty(<span class="keyword">this</span>, propertyName)</span><br><span class="line">   <span class="comment">// 创建委托</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码是当“provideDelegate”功能可用时</span></span><br><span class="line"><span class="comment">// 由编译器生成的代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用“provideDelegate”来创建额外的“delegate”属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> prop$delegate = MyDelegate().provideDelegate(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">    <span class="keyword">val</span> prop: Type</span><br><span class="line">        <span class="keyword">get</span>() = prop$delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.runoob.com/w3cnote/delegate-mode.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;委托模式&lt;/a&gt;是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。&lt;/p&gt;
&lt;p&gt;Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类委托&quot;&gt;&lt;a href=&quot;#类委托&quot; class=&quot;headerlink&quot; title=&quot;类委托&quot;&gt;&lt;/a&gt;类委托&lt;/h2&gt;&lt;p&gt;类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。&lt;/p&gt;
&lt;p&gt;以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt; &lt;/span&gt;&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现此接口的被委托的类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseImpl&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; x: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) : Base &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123; print(x) &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过关键字 by 建立委托类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Derived&lt;/span&gt;&lt;/span&gt;(b: Base) : Base &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; b = BaseImpl(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Derived(b).print() &lt;span class=&quot;comment&quot;&gt;// 输出 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;属性委托&quot;&gt;&lt;a href=&quot;#属性委托&quot; class=&quot;headerlink&quot; title=&quot;属性委托&quot;&gt;&lt;/a&gt;属性委托&lt;/h2&gt;&lt;p&gt;属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。&lt;/p&gt;
&lt;p&gt;属性委托语法格式：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &amp;lt;属性名&amp;gt;: &amp;lt;类型&amp;gt; &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; &amp;lt;表达式&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;var/val：属性类型(可变/只读)&lt;/li&gt;
&lt;li&gt;属性名：属性名称&lt;/li&gt;
&lt;li&gt;类型：属性的数据类型&lt;/li&gt;
&lt;li&gt;表达式：委托代理类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin对象表达式和对象声明</title>
    <link href="https://zhangmiao.cc/posts/a056c2ad.html"/>
    <id>https://zhangmiao.cc/posts/a056c2ad.html</id>
    <published>2020-09-19T02:31:51.000Z</published>
    <updated>2020-09-19T02:38:19.363Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 用对象表达式和对象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类。</p><hr><h2 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h2><p>通过对象表达式实现一个匿名内部类的对象用于方法的参数中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对象可以继承于某个基类，或者实现其他接口:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(x: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> y: <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;……&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ab: A = <span class="keyword">object</span> : A(<span class="number">1</span>), B &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y = <span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔。</p><p>通过对象表达式可以越过类的定义直接得到一个对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> site = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> name: String = <span class="string">"菜鸟教程"</span></span><br><span class="line">        <span class="keyword">var</span> url: String = <span class="string">"www.runoob.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(site.name)</span><br><span class="line">    println(site.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有函数，所以其返回类型是匿名对象类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">"x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数，所以其返回类型是 Any</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">publicFoo</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">"x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x1 = foo().x        <span class="comment">// 没问题</span></span><br><span class="line">        <span class="keyword">val</span> x2 = publicFoo().x  <span class="comment">// 错误：未能解析的引用“x”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象表达中可以方便的访问到作用域中的其他变量:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="type">JComponent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> enterCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h2><p>Kotlin 使用 object 关键字来声明一个对象。</p><p>Kotlin 中我们可以方便的通过对象声明来获得一个单例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">DataProvider</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allDataProviders: Collection&lt;DataProvider&gt;</span><br><span class="line">        <span class="keyword">get</span>() = <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用该对象，我们直接使用其名称即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataProviderManager.registerDataProvider(……)</span><br></pre></td></tr></table></figure><p>当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data1 = DataProviderManager</span><br><span class="line"><span class="keyword">var</span> data2 = DataProviderManager</span><br><span class="line">data1.name = <span class="string">"test"</span></span><br><span class="line">print(<span class="string">"data1 name = <span class="subst">$&#123;data2.name&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例中，两个对象都输出了同一个 url 地址：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Site &#123;</span><br><span class="line">    <span class="keyword">var</span> url:String = <span class="string">""</span></span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">"菜鸟教程"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s1 =  Site</span><br><span class="line">    <span class="keyword">var</span> s2 = Site</span><br><span class="line">    s1.url = <span class="string">"www.runoob.com"</span></span><br><span class="line">    println(s1.url)</span><br><span class="line">    println(s2.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.runoob.com</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure><p>对象可以有超类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object DefaultListener : MouseAdapter() &#123;</span><br><span class="line">    override fun mouseClicked(e: MouseEvent) &#123;</span><br><span class="line">        // ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun mouseEntered(e: MouseEvent) &#123;</span><br><span class="line">        // ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"菜鸟教程"</span></span><br><span class="line">    <span class="keyword">object</span> DeskTop&#123;</span><br><span class="line">        <span class="keyword">var</span> url = <span class="string">"www.runoob.com"</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print&#123;<span class="string">"desk legs <span class="variable">$name</span>"</span>&#125; <span class="comment">// 错误，不能访问到外部类的方法和变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> site = Site()</span><br><span class="line">    site.DeskTop.url <span class="comment">// 错误，不能通过外部类的实例访问到该对象</span></span><br><span class="line">    Site.DeskTop.url <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> instance = MyClass.create()   <span class="comment">// 访问到对象的内部元素</span></span><br></pre></td></tr></table></figure><p>我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = MyClass.Companion</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。</p><p>请伴生对象的成员看起来像其他语言的静态成员，但在运行时他们仍然是真实对象的实例成员。例如还可以实现接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Factory&lt;MyClass&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h2><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方立即执行的</li><li>对象声明是在第一次被访问到时延迟初始化的</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 用对象表达式和对象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;对象表达式&quot;&gt;&lt;a href=&quot;#对象表达式&quot; class=&quot;headerlink&quot; title=&quot;对象表达式&quot;&gt;&lt;/a&gt;对象表达式&lt;/h2&gt;&lt;p&gt;通过对象表达式实现一个匿名内部类的对象用于方法的参数中：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;window.addMouseListener(&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; : MouseAdapter() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mouseClicked&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(e: &lt;span class=&quot;type&quot;&gt;MouseEvent&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mouseEntered&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(e: &lt;span class=&quot;type&quot;&gt;MouseEvent&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;对象可以继承于某个基类，或者实现其他接口:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;(x: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; y: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt; = x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;&amp;#123;……&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; ab: A = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; : A(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), B &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; y = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔。&lt;/p&gt;
&lt;p&gt;通过对象表达式可以越过类的定义直接得到一个对象：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; site = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: String = &lt;span class=&quot;string&quot;&gt;&quot;菜鸟教程&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; url: String = &lt;span class=&quot;string&quot;&gt;&quot;www.runoob.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(site.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(site.url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 私有函数，所以其返回类型是匿名对象类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; x: String = &lt;span class=&quot;string&quot;&gt;&quot;x&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 公有函数，所以其返回类型是 Any&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;publicFoo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; x: String = &lt;span class=&quot;string&quot;&gt;&quot;x&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; x1 = foo().x        &lt;span class=&quot;comment&quot;&gt;// 没问题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; x2 = publicFoo().x  &lt;span class=&quot;comment&quot;&gt;// 错误：未能解析的引用“x”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在对象表达中可以方便的访问到作用域中的其他变量:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;countClicks&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(window: &lt;span class=&quot;type&quot;&gt;JComponent&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; clickCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; enterCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    window.addMouseListener(&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; : MouseAdapter() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mouseClicked&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(e: &lt;span class=&quot;type&quot;&gt;MouseEvent&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clickCount++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mouseEntered&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(e: &lt;span class=&quot;type&quot;&gt;MouseEvent&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            enterCount++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ……&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin枚举类</title>
    <link href="https://zhangmiao.cc/posts/cfa629be.html"/>
    <id>https://zhangmiao.cc/posts/cfa629be.html</id>
    <published>2020-09-19T02:30:11.000Z</published>
    <updated>2020-09-19T02:38:19.366Z</updated>
    
    <content type="html"><![CDATA[<p>枚举类最基本的用法是实现一个类型安全的枚举。</p><p>枚举常量用逗号分隔,每个枚举常量都是一个对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    RED,BLACK,BLUE,GREEN,WHITE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举初始化"><a href="#枚举初始化" class="headerlink" title="枚举初始化"></a>枚举初始化</h3><p>每一个枚举都是枚举类的实例，它们可以被初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    RED(<span class="number">0xFF0000</span>),</span><br><span class="line">    GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">    BLUE(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认名称为枚举字符名，值从0开始。若需要指定值，则可以使用其构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>(value:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    ovel(<span class="number">100</span>),</span><br><span class="line">    rectangle(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举还支持以声明自己的匿名类及相应的方法、以及覆盖基类的方法。如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolState</span> </span>&#123;</span><br><span class="line">    WAITING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = TALKING</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    TALKING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = WAITING</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span>: ProtocolState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开</p><a id="more"></a><h2 id="使用枚举常量"><a href="#使用枚举常量" class="headerlink" title="使用枚举常量"></a>使用枚举常量</h2><p>Kotlin 中的枚举类具有合成方法，允许遍历定义的枚举常量，并通过其名称获取枚举常数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnumClass.valueOf(value: String): EnumClass  <span class="comment">// 转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentException</span></span><br><span class="line">EnumClass.values(): Array&lt;EnumClass&gt;        <span class="comment">// 以数组的形式，返回枚举值</span></span><br></pre></td></tr></table></figure><p>获取枚举相关信息：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String <span class="comment">//获取枚举名称</span></span><br><span class="line"><span class="keyword">val</span> ordinal: <span class="built_in">Int</span> <span class="comment">//获取枚举值在所有枚举数组中定义的顺序</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    RED,BLACK,BLUE,GREEN,WHITE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> color:Color=Color.BLUE</span><br><span class="line"></span><br><span class="line">    println(Color.values())</span><br><span class="line">    println(Color.valueOf(<span class="string">"RED"</span>))</span><br><span class="line">    println(color.name)</span><br><span class="line">    println(color.ordinal)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自 Kotlin 1.1 起，可以使用 <code>enumValues&lt;T&gt;()</code> 和 <code>enumValueOf&lt;T&gt;()</code> 函数以泛型的方式访问枚举类中的常量 ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">RGB</span> </span>&#123; RED, GREEN, BLUE &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Enum&lt;T&gt;</span>&gt; <span class="title">printAllValues</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    printAllValues&lt;RGB&gt;() <span class="comment">// 输出 RED, GREEN, BLUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举类最基本的用法是实现一个类型安全的枚举。&lt;/p&gt;
&lt;p&gt;枚举常量用逗号分隔,每个枚举常量都是一个对象。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Color&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RED,BLACK,BLUE,GREEN,WHITE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;枚举初始化&quot;&gt;&lt;a href=&quot;#枚举初始化&quot; class=&quot;headerlink&quot; title=&quot;枚举初始化&quot;&gt;&lt;/a&gt;枚举初始化&lt;/h3&gt;&lt;p&gt;每一个枚举都是枚举类的实例，它们可以被初始化：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Color&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; rgb: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RED(&lt;span class=&quot;number&quot;&gt;0xFF0000&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GREEN(&lt;span class=&quot;number&quot;&gt;0x00FF00&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BLUE(&lt;span class=&quot;number&quot;&gt;0x0000FF&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;默认名称为枚举字符名，值从0开始。若需要指定值，则可以使用其构造函数：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt;&lt;/span&gt;(value:&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ovel(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rectangle(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;枚举还支持以声明自己的匿名类及相应的方法、以及覆盖基类的方法。如：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ProtocolState&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WAITING &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = TALKING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TALKING &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = WAITING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: ProtocolState&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin泛型</title>
    <link href="https://zhangmiao.cc/posts/6f6a6f9c.html"/>
    <id>https://zhangmiao.cc/posts/6f6a6f9c.html</id>
    <published>2020-09-19T02:21:33.000Z</published>
    <updated>2020-09-19T02:24:02.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-泛型"><a href="#Kotlin-泛型" class="headerlink" title="Kotlin 泛型"></a>Kotlin 泛型</h1><p>泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</p><p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p><p>声明一个泛型类:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t: T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类的实例时我们需要指定类型参数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box: Box&lt;<span class="built_in">Int</span>&gt; = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">val</span> box = Box(<span class="number">1</span>) <span class="comment">// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure><p>以下实例向泛型类 Box 传入整型数据和字符串：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t : T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> boxInt = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> boxString = Box&lt;String&gt;(<span class="string">"Runoob"</span>)</span><br><span class="line"></span><br><span class="line">    println(boxInt.value)</span><br><span class="line">    println(boxString.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><p>定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。</p><p>Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">boxIn</span><span class="params">(value: <span class="type">T</span>)</span></span> = Box(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都是合法语句</span></span><br><span class="line"><span class="keyword">val</span> box4 = boxIn&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> box5 = boxIn(<span class="number">1</span>)     <span class="comment">// 编译器会进行类型推断</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。</p><p>以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">23</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"runoob"</span></span><br><span class="line">    <span class="keyword">val</span> bool = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    doPrintln(age)    <span class="comment">// 整型</span></span><br><span class="line">    doPrintln(name)   <span class="comment">// 字符串</span></span><br><span class="line">    doPrintln(bool)   <span class="comment">// 布尔型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">doPrintln</span><span class="params">(content: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (content) &#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">"整型数字为 <span class="variable">$content</span>"</span>)</span><br><span class="line">        <span class="keyword">is</span> String -&gt; println(<span class="string">"字符串转换为大写：<span class="subst">$&#123;content.toUpperCase()&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"T 不是整型，也不是字符串"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">整型数字为 <span class="number">23</span></span><br><span class="line">字符串转换为大写：RUNOOB</span><br><span class="line">T 不是整型，也不是字符串</span><br></pre></td></tr></table></figure><hr><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p><p>Kotlin 中使用 : 对泛型的类型上限进行约束。</p><p>最常见的约束是上界(upper bound)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Comparable 的子类型可以替代 T。 例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span></span><br></pre></td></tr></table></figure><p>默认的上界是 Any?。</p><p>对于多个上界约束条件，可以用 where 子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;String&gt;</span><br><span class="line">    where T : CharSequence,</span><br><span class="line">          T : Comparable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h2><p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。</p><h3 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h3><p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p><p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个支持协变的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>&lt;<span class="type">out A</span>&gt;</span>(<span class="keyword">val</span> a: A) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: A &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strCo: Runoob&lt;String&gt; = Runoob(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">var</span> anyCo: Runoob&lt;Any&gt; = Runoob&lt;Any&gt;(<span class="string">"b"</span>)</span><br><span class="line">    anyCo = strCo</span><br><span class="line">    println(anyCo.foo())   <span class="comment">// 输出 a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个支持逆变的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>&lt;<span class="type">in A</span>&gt;</span>(a: A) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">A</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strDCo = Runoob(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">var</span> anyDCo = Runoob&lt;Any&gt;(<span class="string">"b"</span>)</span><br><span class="line">    strDCo = anyDCo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h2><p>有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓”安全地使用”是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。</p><p>对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection):</p><ul><li>假如类型定义为 Foo<out t> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo&lt;<em>&gt; 等价于 Foo<out tupper> . 它表示, 当 T 未知时, 你可以安全地从 Foo&lt;</out></em>&gt; 中 读取TUpper 类型的值.</out></li><li>假如类型定义为 Foo<in t> , 其中 T 是一个反向协变的类型参数, Foo&lt;<em>&gt; 等价于 Foo<innothing> . 它表示, 当 T 未知时, 你不能安全地向 Foo&lt;</innothing></em>&gt; 写入 任何东西.</in></li><li>假如类型定义为 Foo<t> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo&lt;*&gt; 等价于 Foo<out tupper> , 对于写入值的场合, 等价于 Foo<in nothing> .</in></out></t></li></ul><p>如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function&lt;in T, out U&gt; , 那么可以出现以下几种星号投射:</p><ol><li>Function&lt;*, String&gt; , 代表 Function&lt;in Nothing, String&gt; ;</li><li>Function&lt;Int, *&gt; , 代表 Function&lt;Int, out Any?&gt; ;</li><li>Function&lt;<em>,</em> &gt; , 代表 Function&lt;in Nothing, out Any?&gt; .</li></ol><p>注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>关于星号投射，其实就是*代指了所有类型，相当于Any?</p><p>给文中补个例子方便理解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> t: T, <span class="keyword">val</span> t2 : T, <span class="keyword">val</span> t3 : T)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>(<span class="keyword">var</span> name : String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用类    </span></span><br><span class="line">    <span class="keyword">val</span> a1: A&lt;*&gt; = A(<span class="number">12</span>, <span class="string">"String"</span>, Apple(<span class="string">"苹果"</span>))</span><br><span class="line">    <span class="keyword">val</span> a2: A&lt;Any?&gt; = A(<span class="number">12</span>, <span class="string">"String"</span>, Apple(<span class="string">"苹果"</span>))   <span class="comment">//和a1是一样的</span></span><br><span class="line">    <span class="keyword">val</span> apple = a1.t3    <span class="comment">//参数类型为Any</span></span><br><span class="line">    println(apple)</span><br><span class="line">    <span class="keyword">val</span> apple2 = apple <span class="keyword">as</span> Apple   <span class="comment">//强转成Apple类</span></span><br><span class="line">    println(apple2.name)</span><br><span class="line">    <span class="comment">//使用数组</span></span><br><span class="line">    <span class="keyword">val</span> l:ArrayList&lt;*&gt; = arrayListOf(<span class="string">"String"</span>,<span class="number">1</span>,<span class="number">1.2</span>f,Apple(<span class="string">"苹果"</span>))</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> l)&#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-泛型&quot;&gt;&lt;a href=&quot;#Kotlin-泛型&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 泛型&quot;&gt;&lt;/a&gt;Kotlin 泛型&lt;/h1&gt;&lt;p&gt;泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。&lt;/p&gt;
&lt;p&gt;与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。&lt;/p&gt;
&lt;p&gt;声明一个泛型类:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Box&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;(t: T) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;创建类的实例时我们需要指定类型参数:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box: Box&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt; = Box&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box = Box(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&amp;lt;Int&amp;gt;。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以下实例向泛型类 Box 传入整型数据和字符串：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Box&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;(t : T) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; boxInt = Box&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; boxString = Box&amp;lt;String&amp;gt;(&lt;span class=&quot;string&quot;&gt;&quot;Runoob&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(boxInt.value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(boxString.value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runoob&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。&lt;/p&gt;
&lt;p&gt;Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;&amp;lt;T&amp;gt;&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;boxIn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value: &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; = Box(value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下都是合法语句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box4 = boxIn&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; box5 = boxIn(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)     &lt;span class=&quot;comment&quot;&gt;// 编译器会进行类型推断&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin数据类与密封类</title>
    <link href="https://zhangmiao.cc/posts/2fd9bfca.html"/>
    <id>https://zhangmiao.cc/posts/2fd9bfca.html</id>
    <published>2020-09-19T02:16:45.000Z</published>
    <updated>2020-09-19T02:19:49.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>Kotlin 可以创建一个只包含数据的类，关键字为 <strong>data</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：</p><ul><li><code>equals()</code> / <code>hashCode()</code></li><li><code>toString()</code> 格式如 <code>&quot;User(name=John, age=42)&quot;</code></li><li><code>componentN() functions</code> 对应于属性，按声明顺序排列</li><li><code>copy()</code> 函数</li></ul><p>如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。</p><p>为了保证生成代码的一致性以及有意义，数据类需要满足以下条件：</p><ul><li>主构造函数至少包含一个参数。</li><li>所有的主构造函数的参数必须标识为<code>val</code> 或者 <code>var</code> ;</li><li>数据类不可以声明为 <code>abstract</code>, <code>open</code>, <code>sealed</code> 或者 <code>inner</code>;</li><li>数据类不能继承其他类 (但是可以实现接口)。</li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, age: <span class="type">Int</span> = this.age)</span></span> = User(name, age)</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用 copy 类复制 User 数据类，并修改 age 属性:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jack = User(name = <span class="string">"Jack"</span>, age = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br><span class="line">    println(jack)</span><br><span class="line">    println(olderJack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User(name=Jack, age=<span class="number">1</span>)</span><br><span class="line">User(name=Jack, age=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="数据类以及解构声明"><a href="#数据类以及解构声明" class="headerlink" title="数据类以及解构声明"></a>数据类以及解构声明</h3><p>组件函数允许数据类在解构声明中使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jane = User(<span class="string">"Jane"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="keyword">val</span> (name, age) = jane</span><br><span class="line">println(<span class="string">"<span class="variable">$name</span>, <span class="variable">$age</span> years of age"</span>) <span class="comment">// prints "Jane, 35 years of age"</span></span><br></pre></td></tr></table></figure><h3 id="标准数据类"><a href="#标准数据类" class="headerlink" title="标准数据类"></a>标准数据类</h3><p>标准库提供了 <strong>Pair</strong> 和 <strong>Triple</strong> 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。</p><hr><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。</p><p>声明一个密封类，使用 <strong>sealed</strong> 修饰类，密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。</p><p>sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用密封类的关键好处在于使用 when 表达式 的时候，如果能够 验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    Expr.NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// 不再需要 `else` 子句，因为我们已经覆盖了所有的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>我的理解密封类就是一种专门用来配合 when 语句使用的类，举个例子，假如在 Android 中我们有一个 view，我们现在想通过 when 语句设置针对 view 进行两种操作：显示和隐藏，那么就可以这样做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> Show: UiOp()</span><br><span class="line">    <span class="keyword">object</span> Hide: UiOp()</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(view: <span class="type">View</span>, op: <span class="type">UiOp</span>)</span></span> = <span class="keyword">when</span> (op) &#123;</span><br><span class="line">    UiOp.Show -&gt; view.visibility = View.VISIBLE</span><br><span class="line">    UiOp.Hide -&gt; view.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上功能其实完全可以用枚举实现，但是如果我们现在想加两个操作：水平平移和纵向平移，并且还要携带一些数据，比如平移了多少距离，平移过程的动画类型等数据，用枚举显然就不太好办了，这时密封类的优势就可以发挥了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> Show: UiOp()</span><br><span class="line">    <span class="keyword">object</span> Hide: UiOp()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TranslateX</span></span>(<span class="keyword">val</span> px: <span class="built_in">Float</span>): UiOp()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TranslateY</span></span>(<span class="keyword">val</span> px: <span class="built_in">Float</span>): UiOp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(view: <span class="type">View</span>, op: <span class="type">UiOp</span>)</span></span> = <span class="keyword">when</span> (op) &#123;</span><br><span class="line">    UiOp.Show -&gt; view.visibility = View.VISIBLE</span><br><span class="line">    UiOp.Hide -&gt; view.visibility = View.GONE</span><br><span class="line">    <span class="keyword">is</span> UiOp.TranslateX -&gt; view.translationX = op.px <span class="comment">// 这个 when 语句分支不仅告诉 view 要水平移动，还告诉 view 需要移动多少距离，这是枚举等 Java 传统思想不容易实现的</span></span><br><span class="line">    <span class="keyword">is</span> UiOp.TranslateY -&gt; view.translationY = op.px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，TranslateX 是一个类，它可以携带多于一个的信息，比如除了告诉 view 需要水平平移之外，还可以告诉 view 平移多少像素，甚至还可以告诉 view 平移的动画类型等信息，我想这大概就是密封类出现的意义吧。</p><p>除此之外，如果 when 语句的分支不需要携带除“显示或隐藏view之外的其它信息”时（即只需要表明 when 语句分支，不需要携带额外数据时），用 object 关键字创建单例就可以了，并且此时 when 子句不需要使用 is 关键字。只有需要携带额外信息时才定义密封类的子类，而且使用了密封类就不需要使用 else 子句，每当我们多增加一个密封类的子类或单例，编译器就会在 when 语句中给出提示，可以在编译阶段就及时发现错误，这也是以往 switch-case 语句和枚举不具备的功能。</p><p>最后，我们甚至可以把这一组操作封装成一个函数，以便日后调用，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先封装一个UI操作列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui</span></span>(<span class="keyword">val</span> uiOps: List = emptyList()) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(uiOp: <span class="type">UiOp</span>)</span></span> = Ui(uiOps + uiOp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一组操作</span></span><br><span class="line"><span class="keyword">val</span> ui = Ui() +</span><br><span class="line">        UiOp.Show +</span><br><span class="line">        UiOp.TranslateX(<span class="number">20</span>f) +</span><br><span class="line">        UiOp.TranslateY(<span class="number">40</span>f) +</span><br><span class="line">        UiOp.Hide</span><br><span class="line"><span class="comment">// 定义调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">(view: <span class="type">View</span>, ui: <span class="type">Ui</span>)</span></span> &#123;</span><br><span class="line">    ui.uiOps.forEach &#123; execute(view, it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(view, ui) <span class="comment">// 最终调用</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据类&quot;&gt;&lt;a href=&quot;#数据类&quot; class=&quot;headerlink&quot; title=&quot;数据类&quot;&gt;&lt;/a&gt;数据类&lt;/h2&gt;&lt;p&gt;Kotlin 可以创建一个只包含数据的类，关键字为 &lt;strong&gt;data&lt;/strong&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name: String, &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; age: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals()&lt;/code&gt; / &lt;code&gt;hashCode()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toString()&lt;/code&gt; 格式如 &lt;code&gt;&amp;quot;User(name=John, age=42)&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;componentN() functions&lt;/code&gt; 对应于属性，按声明顺序排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy()&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。&lt;/p&gt;
&lt;p&gt;为了保证生成代码的一致性以及有意义，数据类需要满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主构造函数至少包含一个参数。&lt;/li&gt;
&lt;li&gt;所有的主构造函数的参数必须标识为&lt;code&gt;val&lt;/code&gt; 或者 &lt;code&gt;var&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;数据类不可以声明为 &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;sealed&lt;/code&gt; 或者 &lt;code&gt;inner&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;数据类不能继承其他类 (但是可以实现接口)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;复制&quot;&gt;&lt;a href=&quot;#复制&quot; class=&quot;headerlink&quot; title=&quot;复制&quot;&gt;&lt;/a&gt;复制&lt;/h3&gt;&lt;p&gt;复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; = this.name, age: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; = this.age)&lt;/span&gt;&lt;/span&gt; = User(name, age)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h3&gt;&lt;p&gt;使用 copy 类复制 User 数据类，并修改 age 属性:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name: String, &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; age: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; jack = User(name = &lt;span class=&quot;string&quot;&gt;&quot;Jack&quot;&lt;/span&gt;, age = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; olderJack = jack.copy(age = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(jack)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(olderJack)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;User(name=Jack, age=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;User(name=Jack, age=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin扩展</title>
    <link href="https://zhangmiao.cc/posts/36cafa9f.html"/>
    <id>https://zhangmiao.cc/posts/36cafa9f.html</id>
    <published>2020-09-18T06:45:30.000Z</published>
    <updated>2020-09-18T06:48:58.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-扩展"><a href="#Kotlin-扩展" class="headerlink" title="Kotlin 扩展"></a>Kotlin 扩展</h1><p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。</p><p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p><hr><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> receiverType.<span class="title">functionName</span><span class="params">(params)</span></span>&#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>receiverType：表示函数的接收者，也就是函数扩展的对象</li><li>functionName：扩展函数的名称</li><li>params：扩展函数的参数，可以为NULL</li></ul><p>以下实例扩展 User 类 ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**扩展函数**/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(<span class="string">"用户名 <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = User(<span class="string">"Runoob"</span>)</span><br><span class="line">    user.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名 Runoob</span><br></pre></td></tr></table></figure><p>下面代码为 MutableList 添加一个swap 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展函数 swap,调换不同位置的值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1]     <span class="comment">//  this 对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> l = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 位置 0 和 2 的值做了互换</span></span><br><span class="line">    l.swap(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">// 'swap()' 函数内的 'this' 将指向 'l' 的值</span></span><br><span class="line"></span><br><span class="line">    println(l.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>this关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。</p><hr><a id="more"></a><h2 id="扩展函数是静态解析的"><a href="#扩展函数是静态解析的" class="headerlink" title="扩展函数是静态解析的"></a>扩展函数是静态解析的</h2><p>扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span>   <span class="comment">// 扩展函数 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span>   <span class="comment">// 扩展函数 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">    println(c.foo())  <span class="comment">// 类型是 C 类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    printFoo(D())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure><p>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"成员函数"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"扩展函数"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = C()</span><br><span class="line">    c.foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成员函数</span><br></pre></td></tr></table></figure><h3 id="扩展一个空对象"><a href="#扩展一个空对象" class="headerlink" title="扩展一个空对象"></a>扩展一个空对象</h3><p>在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="comment">// 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()</span></span><br><span class="line">    <span class="comment">// 解析为 Any 类的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="literal">null</span></span><br><span class="line">    println(t.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><hr><p>扩展属性</p><p>除了函数，Kotlin 也支持属性对属性进行扩展:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span> <span class="comment">// 错误：扩展属性不能有初始化器</span></span><br></pre></td></tr></table></figure><p>扩展属性只能被声明为 val。</p><hr><h2 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h2><p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。</p><p>伴生对象通过”类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;  <span class="comment">// 将被称为 "Companion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"伴随对象的扩展函数"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> MyClass.Companion.no: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"no:<span class="subst">$&#123;MyClass.no&#125;</span>"</span>)</span><br><span class="line">    MyClass.foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">no:<span class="number">10</span></span><br><span class="line">伴随对象的扩展函数</span><br></pre></td></tr></table></figure><hr><h2 id="扩展的作用域"><a href="#扩展的作用域" class="headerlink" title="扩展的作用域"></a>扩展的作用域</h2><p>通常扩展函数或属性定义在顶级包下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Baz.<span class="title">goo</span><span class="params">()</span></span> &#123; …… &#125;</span><br></pre></td></tr></table></figure><p>要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.usage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.bar.goo <span class="comment">// 导入所有名为 goo 的扩展</span></span><br><span class="line">                   <span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> foo.bar.*   <span class="comment">// 从 foo.bar 导入一切</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">usage</span><span class="params">(baz: <span class="type">Baz</span>)</span></span> &#123;</span><br><span class="line">    baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="扩展声明为成员"><a href="#扩展声明为成员" class="headerlink" title="扩展声明为成员"></a>扩展声明为成员</h2><p>在一个类内部你可以为另一个类声明扩展。</p><p>在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"D bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123; println(<span class="string">"C baz"</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar()   <span class="comment">// 调用 D.bar</span></span><br><span class="line">        baz()   <span class="comment">// 调用 C.baz</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: C = C()</span><br><span class="line">    <span class="keyword">val</span> d: D = D()</span><br><span class="line">    c.caller(d)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D bar</span><br><span class="line">C baz</span><br></pre></td></tr></table></figure><p>在 C 类内，创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。</p><p>假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"D bar"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; println(<span class="string">"C bar"</span>) &#125;  <span class="comment">// 与 D 类 的 bar 同名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar()         <span class="comment">// 调用 D.bar()，扩展接收者优先</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@C</span>.bar()  <span class="comment">// 调用 C.bar()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: C = C()</span><br><span class="line">    <span class="keyword">val</span> d: D = D()</span><br><span class="line">    c.caller(d)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D bar</span><br><span class="line">C bar</span><br></pre></td></tr></table></figure><p>以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> : <span class="type">D</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">caller</span><span class="params">(d: <span class="type">D</span>)</span></span> &#123;</span><br><span class="line">        d.foo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> : <span class="type">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> D1.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"D1.foo in C1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    C().caller(D())   <span class="comment">// 输出 "D.foo in C"</span></span><br><span class="line">    C1().caller(D())  <span class="comment">// 输出 "D.foo in C1" —— 分发接收者虚拟解析</span></span><br><span class="line">    C().caller(D1())  <span class="comment">// 输出 "D.foo in C" —— 扩展接收者静态解析</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D.foo <span class="keyword">in</span> C</span><br><span class="line">D.foo <span class="keyword">in</span> C1</span><br><span class="line">D.foo <span class="keyword">in</span> C</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-扩展&quot;&gt;&lt;a href=&quot;#Kotlin-扩展&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 扩展&quot;&gt;&lt;/a&gt;Kotlin 扩展&lt;/h1&gt;&lt;p&gt;Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。&lt;/p&gt;
&lt;p&gt;扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;扩展函数&quot;&gt;&lt;a href=&quot;#扩展函数&quot; class=&quot;headerlink&quot; title=&quot;扩展函数&quot;&gt;&lt;/a&gt;扩展函数&lt;/h2&gt;&lt;p&gt;扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; receiverType.&lt;span class=&quot;title&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(params)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;receiverType：表示函数的接收者，也就是函数扩展的对象&lt;/li&gt;
&lt;li&gt;functionName：扩展函数的名称&lt;/li&gt;
&lt;li&gt;params：扩展函数的参数，可以为NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下实例扩展 User 类 ：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name:String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**扩展函数**/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; User.&lt;span class=&quot;title&quot;&gt;Print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;用户名 &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg:&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; user = User(&lt;span class=&quot;string&quot;&gt;&quot;Runoob&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    user.Print()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;实例执行输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;用户名 Runoob&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;下面代码为 MutableList 添加一个swap 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 扩展函数 swap,调换不同位置的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; MutableList&lt;span class=&quot;type&quot;&gt;&amp;lt;Int&amp;gt;&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(index1: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, index2: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; tmp = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index1]     &lt;span class=&quot;comment&quot;&gt;//  this 对应该列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index1] = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[index2] = tmp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; l = mutableListOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 位置 0 和 2 的值做了互换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    l.swap(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// &#39;swap()&#39; 函数内的 &#39;this&#39; 将指向 &#39;l&#39; 的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(l.toString())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;实例执行输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;this关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin接口</title>
    <link href="https://zhangmiao.cc/posts/404317d3.html"/>
    <id>https://zhangmiao.cc/posts/404317d3.html</id>
    <published>2020-09-18T06:38:03.000Z</published>
    <updated>2020-09-18T06:43:08.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-接口"><a href="#Kotlin-接口" class="headerlink" title="Kotlin 接口"></a>Kotlin 接口</h1><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>    <span class="comment">// 未实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;  <span class="comment">//已实现</span></span><br><span class="line">      <span class="comment">// 可选的方法体</span></span><br><span class="line">      println(<span class="string">"foo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类或者对象可以实现一个或多个接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可选的方法体</span></span><br><span class="line">        println(<span class="string">"foo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">        println(<span class="string">"bar"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c =  Child()</span><br><span class="line">    c.foo();</span><br><span class="line">    c.bar();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h3><p>接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="comment">//name 属性, 抽象的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImpl</span>:<span class="type">MyInterface&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: String = <span class="string">"runoob"</span> <span class="comment">//重写属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:String <span class="comment">//name 属性, 抽象的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可选的方法体</span></span><br><span class="line">        println(<span class="string">"foo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> : <span class="type">MyInterface &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: String = <span class="string">"runoob"</span> <span class="comment">//重写属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">        println(<span class="string">"bar"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c =  Child()</span><br><span class="line">    c.foo();</span><br><span class="line">    c.bar();</span><br><span class="line">    println(c.name)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><hr><h2 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h2><p>实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如:</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;   <span class="comment">// 已实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>                  <span class="comment">// 未实现，没有方法体，是抽象的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125;   <span class="comment">// 已实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125; <span class="comment">// 已实现</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">"bar"</span>) &#125;   <span class="comment">// 重写</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">A</span>, <span class="type">B &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.foo()</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> d =  D()</span><br><span class="line">    d.foo();</span><br><span class="line">    d.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABbar</span><br></pre></td></tr></table></figure><p>实例中接口 A 和 B 都定义了方法 foo() 和 bar()， 两者都实现了 foo(), B 实现了 bar()。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。</p><p>然而，如果我们从 A 和 B 派生 D，我们需要实现多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则 既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-接口&quot;&gt;&lt;a href=&quot;#Kotlin-接口&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 接口&quot;&gt;&lt;/a&gt;Kotlin 接口&lt;/h1&gt;&lt;p&gt;Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;// 未实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;  &lt;span class=&quot;comment&quot;&gt;//已实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 可选的方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      println(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;实现接口&quot;&gt;&lt;a href=&quot;#实现接口&quot; class=&quot;headerlink&quot; title=&quot;实现接口&quot;&gt;&lt;/a&gt;实现接口&lt;/h3&gt;&lt;p&gt;一个类或者对象可以实现一个或多个接口。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;MyInterface &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 可选的方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;MyInterface &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 方法体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; c =  Child()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c.foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c.bar();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin继承</title>
    <link href="https://zhangmiao.cc/posts/8ca7e9b.html"/>
    <id>https://zhangmiao.cc/posts/8ca7e9b.html</id>
    <published>2020-09-17T07:07:37.000Z</published>
    <updated>2020-09-17T07:22:56.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-继承"><a href="#Kotlin-继承" class="headerlink" title="Kotlin 继承"></a>Kotlin 继承</h1><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> // 从 <span class="title">Any</span> 隐式继承</span></span><br></pre></td></tr></table></figure><p>Any 默认提供了三个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">equals()</span><br><span class="line"></span><br><span class="line">hashCode()</span><br><span class="line"></span><br><span class="line">toString()</span><br></pre></td></tr></table></figure><p>注意：Any 不是 java.lang.Object。</p><p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)           <span class="comment">// 定义基类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="子类有主构造函数"><a href="#子类有主构造函数" class="headerlink" title="子类有主构造函数"></a>子类有主构造函数</h3><p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name : String, <span class="keyword">var</span> age : <span class="built_in">Int</span>)&#123;<span class="comment">// 基类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name : String, age : <span class="built_in">Int</span>, <span class="keyword">var</span> no : String, <span class="keyword">var</span> score : <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s =  Student(<span class="string">"Runoob"</span>, <span class="number">18</span>, <span class="string">"S12346"</span>, <span class="number">89</span>)</span><br><span class="line">    println(<span class="string">"学生名： <span class="subst">$&#123;s.name&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"年龄： <span class="subst">$&#123;s.age&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"学生号： <span class="subst">$&#123;s.no&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"成绩： <span class="subst">$&#123;s.score&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学生名： Runoob</span><br><span class="line">年龄： <span class="number">18</span></span><br><span class="line">学生号： S12346</span><br><span class="line">成绩： <span class="number">89</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="子类没有主构造函数"><a href="#子类没有主构造函数" class="headerlink" title="子类没有主构造函数"></a>子类没有主构造函数</h3><p>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx,attrs) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**用户基类**/</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name:String)&#123;</span><br><span class="line">    <span class="comment">/**次级构造函数**/</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        println(<span class="string">"-------基类次级构造函数---------"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**子类继承 Person 类**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:<span class="type">Person&#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**次级构造函数**/</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,no:String,score:<span class="built_in">Int</span>):<span class="keyword">super</span>(name,age)&#123;</span><br><span class="line">        println(<span class="string">"-------继承类次级构造函数---------"</span>)</span><br><span class="line">        println(<span class="string">"学生名： <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">        println(<span class="string">"年龄： <span class="subst">$&#123;age&#125;</span>"</span>)</span><br><span class="line">        println(<span class="string">"学生号： <span class="subst">$&#123;no&#125;</span>"</span>)</span><br><span class="line">        println(<span class="string">"成绩： <span class="subst">$&#123;score&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s =  Student(<span class="string">"Runoob"</span>, <span class="number">18</span>, <span class="string">"S12345"</span>, <span class="number">89</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-------基类次级构造函数---------</span><br><span class="line">-------继承类次级构造函数---------</span><br><span class="line">学生名： Runoob</span><br><span class="line">年龄： <span class="number">18</span></span><br><span class="line">学生号： S12345</span><br><span class="line">成绩： <span class="number">89</span></span><br></pre></td></tr></table></figure><hr><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**用户基类**/</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span>&#123;       <span class="comment">// 允许子类重写</span></span><br><span class="line">        println(<span class="string">"我毕业了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**子类继承 Person 类**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span>&#123;    <span class="comment">// 重写方法</span></span><br><span class="line">        println(<span class="string">"我在读大学"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s =  Student()</span><br><span class="line">    s.study();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我在读大学</span><br></pre></td></tr></table></figure><p>如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span> <span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123; print(<span class="string">"a"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125; <span class="comment">//接口的成员变量默认是 open 的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123; print(<span class="string">"b"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>() : A() , B&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.f()<span class="comment">//调用 A.f()</span></span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.f()<span class="comment">//调用 B.f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c =  C()</span><br><span class="line">    c.f();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。</p><p>输出结果为:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure><hr><h2 id="属性重写"><a href="#属性重写" class="headerlink" title="属性重写"></a>属性重写</h2><p>属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span> : <span class="type">Foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以用一个var属性重写一个val属性，但是反过来不行。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法</p><p>你可以在主构造函数中使用 override 关键字作为属性声明的一部分:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span>) : Foo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar2</span> : <span class="type">Foo &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-继承&quot;&gt;&lt;a href=&quot;#Kotlin-继承&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 继承&quot;&gt;&lt;/a&gt;Kotlin 继承&lt;/h1&gt;&lt;p&gt;Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt; // 从 &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt; 隐式继承&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Any 默认提供了三个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;equals()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hashCode()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意：Any 不是 java.lang.Object。&lt;/p&gt;
&lt;p&gt;如果一个类要被继承，可以使用 open 关键字进行修饰。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&lt;/span&gt;(p: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)           &lt;span class=&quot;comment&quot;&gt;// 定义基类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Derived&lt;/span&gt;&lt;/span&gt;(p: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) : Base(p)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;h3 id=&quot;子类有主构造函数&quot;&gt;&lt;a href=&quot;#子类有主构造函数&quot; class=&quot;headerlink&quot; title=&quot;子类有主构造函数&quot;&gt;&lt;/a&gt;子类有主构造函数&lt;/h3&gt;&lt;p&gt;如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name : String, &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; age : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;)&amp;#123;&lt;span class=&quot;comment&quot;&gt;// 基类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student&lt;/span&gt;&lt;/span&gt;(name : String, age : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; no : String, &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; score : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) : Person(name, age) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 测试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; s =  Student(&lt;span class=&quot;string&quot;&gt;&quot;Runoob&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;S12346&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;学生名： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.name&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;年龄： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.age&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;学生号： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.no&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;成绩： &lt;span class=&quot;subst&quot;&gt;$&amp;#123;s.score&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;学生名： Runoob&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;年龄： &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;学生号： S12346&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;成绩： &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin类和对象</title>
    <link href="https://zhangmiao.cc/posts/e6f2df3b.html"/>
    <id>https://zhangmiao.cc/posts/e6f2df3b.html</id>
    <published>2020-09-17T06:41:27.000Z</published>
    <updated>2020-09-17T07:05:47.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。</p><p>Kotlin 中使用关键字 <strong>class</strong> 声明类，后面紧跟类名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;  <span class="comment">// 类名为 Runoob</span></span><br><span class="line">    <span class="comment">// 大括号内是类体构成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以定义一个空类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br></pre></td></tr></table></figure><p>可以在类中定义成员函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">"Foo"</span>) &#125; <span class="comment">// 成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h3><p>类的属性可以用关键字 <strong>var</strong> 声明为可变的，否则使用只读关键字 <strong>val</strong> 声明为不可变。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = ……</span><br><span class="line">    <span class="keyword">var</span> url: String = ……</span><br><span class="line">    <span class="keyword">var</span> city: String = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以像使用普通函数那样使用构造函数创建类实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字</span></span><br></pre></td></tr></table></figure><p>要使用一个属性，只要用名称引用它即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site.name           <span class="comment">// 使用 . 号来引用</span></span><br><span class="line">site.url</span><br></pre></td></tr></table></figure><p>Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><p>属性声明的完整语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><p>getter 和 setter 都是可选</p><p>如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allByDefault: <span class="built_in">Int</span>? <span class="comment">// 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法</span></span><br><span class="line"><span class="keyword">var</span> initialized = <span class="number">1</span>    <span class="comment">// 类型为 Int, 默认实现了 getter 和 setter</span></span><br><span class="line"><span class="keyword">val</span> simple: <span class="built_in">Int</span>?       <span class="comment">// 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化</span></span><br><span class="line"><span class="keyword">val</span> inferredType = <span class="number">1</span>   <span class="comment">// 类型为 Int 类型,默认实现 getter</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例定义了一个 Person 类，包含两个可变变量 lastName 和 no，lastName 修改了 getter 方法，no 修改了 setter 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">"zhang"</span></span><br><span class="line">        <span class="keyword">get</span>() = field.toUpperCase()   <span class="comment">// 将变量赋值后转换为大写</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">        <span class="keyword">get</span>() = field                <span class="comment">// 后端变量</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">                field = value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                field = <span class="number">-1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> heiht: <span class="built_in">Float</span> = <span class="number">145.4</span>f</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person: Person = Person()</span><br><span class="line"></span><br><span class="line">    person.lastName = <span class="string">"wang"</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">"lastName:<span class="subst">$&#123;person.lastName&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    person.no = <span class="number">9</span></span><br><span class="line">    println(<span class="string">"no:<span class="subst">$&#123;person.no&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    person.no = <span class="number">20</span></span><br><span class="line">    println(<span class="string">"no:<span class="subst">$&#123;person.no&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lastName:WANG</span><br><span class="line">no:<span class="number">9</span></span><br><span class="line">no:<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>Kotlin 中类不能有字段。提供了 Backing Fields(后端变量) 机制,备用字段使用field关键字声明,field 关键词只能用于属性的访问器，如以上实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">        <span class="keyword">get</span>() = field                <span class="comment">// 后端变量</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">                field = value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                field = <span class="number">-1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>非空属性必须在定义的时候初始化,kotlin提供了一种可以延迟初始化的方案,使用 <strong>lateinit</strong> 关键字描述属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject = TestSubject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.method()  <span class="comment">// dereference directly</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h2><p>主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"FirstName is <span class="variable">$firstName</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：主构造器的参数可以在初始化代码段中使用，也可以在类主体n定义的属性初始化代码中使用。 一种简洁语法，可以通过主构造器来定义属性并初始化属性值（可以是var或val）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>创建一个 Runoob类，并通过构造函数传入网站名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>  <span class="keyword">constructor</span></span>(name: String) &#123;  <span class="comment">// 类名为 Runoob</span></span><br><span class="line">    <span class="comment">// 大括号内是类体构成</span></span><br><span class="line">    <span class="keyword">var</span> url: String = <span class="string">"http://www.runoob.com"</span></span><br><span class="line">    <span class="keyword">var</span> country: String = <span class="string">"CN"</span></span><br><span class="line">    <span class="keyword">var</span> siteName = name</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"初始化网站名: <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"我是类的函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runoob =  Runoob(<span class="string">"菜鸟教程"</span>)</span><br><span class="line">    println(runoob.siteName)</span><br><span class="line">    println(runoob.url)</span><br><span class="line">    println(runoob.country)</span><br><span class="line">    runoob.printTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化网站名: 菜鸟教程</span><br><span class="line">菜鸟教程</span><br><span class="line">http:<span class="comment">//www.runoob.com</span></span><br><span class="line">CN</span><br><span class="line">我是类的函数</span><br></pre></td></tr></table></figure><hr><h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>类也可以有二级构造函数，需要加前缀 constructor:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name: String, age:<span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="comment">// 初始化...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontCreateMe</span> <span class="keyword">private</span> <span class="keyword">constructor</span> </span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> customerName: String = <span class="string">""</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>  <span class="keyword">constructor</span></span>(name: String) &#123;  <span class="comment">// 类名为 Runoob</span></span><br><span class="line">    <span class="comment">// 大括号内是类体构成</span></span><br><span class="line">    <span class="keyword">var</span> url: String = <span class="string">"http://www.runoob.com"</span></span><br><span class="line">    <span class="keyword">var</span> country: String = <span class="string">"CN"</span></span><br><span class="line">    <span class="keyword">var</span> siteName = name</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"初始化网站名: <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 次构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span> (name: String, alexa: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        println(<span class="string">"Alexa 排名 <span class="variable">$alexa</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"我是类的函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runoob =  Runoob(<span class="string">"菜鸟教程"</span>, <span class="number">10000</span>)</span><br><span class="line">    println(runoob.siteName)</span><br><span class="line">    println(runoob.url)</span><br><span class="line">    println(runoob.country)</span><br><span class="line">    runoob.printTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化网站名: 菜鸟教程</span><br><span class="line">Alexa 排名 <span class="number">10000</span></span><br><span class="line">菜鸟教程</span><br><span class="line">http:<span class="comment">//www.runoob.com</span></span><br><span class="line">CN</span><br><span class="line">我是类的函数</span><br></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。</p><p>注意：无需对抽象类或抽象成员标注open注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>我们可以把类嵌套在其他类中，看以下实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;                  <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;             <span class="comment">// 嵌套类</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer.Nested().foo() <span class="comment">// 调用格式：外部类.嵌套类.嵌套类方法/属性</span></span><br><span class="line">    println(demo)    <span class="comment">// == 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类使用 <code>inner</code> 关键字来表示。</p><p>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"成员属性"</span></span><br><span class="line">    <span class="comment">/**嵌套内部类**/</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">innerTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> o = <span class="keyword">this</span><span class="symbol">@Outer</span> <span class="comment">//获取外部类的成员变量</span></span><br><span class="line">            println(<span class="string">"内部类可以引用外部类的成员，例如："</span> + o.v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> demo = Outer().Inner().foo()</span><br><span class="line">    println(demo) <span class="comment">//   1</span></span><br><span class="line">    <span class="keyword">val</span> demo2 = Outer().Inner().innerTest()   </span><br><span class="line">    println(demo2)   <span class="comment">// 内部类可以引用外部类的成员，例如：成员属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label 是一个 代指 this 来源的标签。</p><hr><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用对象表达式来创建匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"成员属性"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setInterFace</span><span class="params">(test: <span class="type">TestInterFace</span>)</span></span> &#123;</span><br><span class="line">        test.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestInterFace</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> test = Test()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用对象表达式来创建接口对象，即匿名内部类的实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    test.setInterFace(<span class="keyword">object</span> : TestInterFace &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"对象表达式创建匿名内部类的实例"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>类的修饰符包括 classModifier 和<em>accessModifier</em>:</p><ul><li><p>classModifier: 类属性修饰符，标示类本身特性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>    <span class="comment">// 抽象类  </span></span><br><span class="line"><span class="keyword">final</span>       <span class="comment">// 类不可继承，默认属性</span></span><br><span class="line"><span class="keyword">enum</span>        <span class="comment">// 枚举类</span></span><br><span class="line"><span class="keyword">open</span>        <span class="comment">// 类可继承，类默认是final的</span></span><br><span class="line"><span class="keyword">annotation</span>  <span class="comment">// 注解类</span></span><br></pre></td></tr></table></figure></li><li><p>accessModifier: 访问权限修饰符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>    <span class="comment">// 仅在同一个文件中可见</span></span><br><span class="line"><span class="keyword">protected</span>  <span class="comment">// 同一个文件中或子类可见</span></span><br><span class="line"><span class="keyword">public</span>     <span class="comment">// 所有调用的地方都可见</span></span><br><span class="line"><span class="keyword">internal</span>   <span class="comment">// 同一个模块中可见</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：example.kt</span></span><br><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 在 example.kt 内可见</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// 该属性随处可见</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span>    <span class="comment">// 相同模块内可见</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; title=&quot;类定义&quot;&gt;&lt;/a&gt;类定义&lt;/h2&gt;&lt;p&gt;Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。&lt;/p&gt;
&lt;p&gt;Kotlin 中使用关键字 &lt;strong&gt;class&lt;/strong&gt; 声明类，后面紧跟类名：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runoob&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;span class=&quot;comment&quot;&gt;// 类名为 Runoob&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 大括号内是类体构成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们也可以定义一个空类：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Empty&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以在类中定义成员函数：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runoob&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123; print(&lt;span class=&quot;string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;) &amp;#125; &lt;span class=&quot;comment&quot;&gt;// 成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&quot;类的属性&quot;&gt;&lt;a href=&quot;#类的属性&quot; class=&quot;headerlink&quot; title=&quot;类的属性&quot;&gt;&lt;/a&gt;类的属性&lt;/h2&gt;&lt;h3 id=&quot;属性定义&quot;&gt;&lt;a href=&quot;#属性定义&quot; class=&quot;headerlink&quot; title=&quot;属性定义&quot;&gt;&lt;/a&gt;属性定义&lt;/h3&gt;&lt;p&gt;类的属性可以用关键字 &lt;strong&gt;var&lt;/strong&gt; 声明为可变的，否则使用只读关键字 &lt;strong&gt;val&lt;/strong&gt; 声明为不可变。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runoob&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: String = ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; url: String = ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; city: String = ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们可以像使用普通函数那样使用构造函数创建类实例：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; site = Runoob() &lt;span class=&quot;comment&quot;&gt;// Kotlin 中没有 new 关键字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要使用一个属性，只要用名称引用它即可&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;site.name           &lt;span class=&quot;comment&quot;&gt;// 使用 . 号来引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;site.url&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;&lt;/span&gt;(firstName: String) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;(firstName: String) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin循环控制</title>
    <link href="https://zhangmiao.cc/posts/e596bfcf.html"/>
    <id>https://zhangmiao.cc/posts/e596bfcf.html</id>
    <published>2020-09-16T06:17:46.000Z</published>
    <updated>2020-09-16T06:21:05.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><p>for 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</span><br></pre></td></tr></table></figure><p>循环体可以是一个代码块:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item: <span class="built_in">Int</span> <span class="keyword">in</span> ints) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，for 可以循环遍历任何提供了迭代器的对象。</p><p>如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    print(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。</p><p>或者你可以用库函数 withIndex：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>对集合进行迭代：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> items = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>)</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> items.indices) &#123;</span><br><span class="line">        println(<span class="string">"item at <span class="variable">$index</span> is <span class="subst">$&#123;items[index]&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">kiwi</span><br><span class="line">item at <span class="number">0</span> <span class="keyword">is</span> apple</span><br><span class="line">item at <span class="number">1</span> <span class="keyword">is</span> banana</span><br><span class="line">item at <span class="number">2</span> <span class="keyword">is</span> kiwi</span><br></pre></td></tr></table></figure><hr><h2 id="while-与-do…while-循环"><a href="#while-与-do…while-循环" class="headerlink" title="while 与 do…while 循环"></a>while 与 do…while 循环</h2><p>while是最基本的循环，它的结构为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">  <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"----while 使用-----"</span>)</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        println( x--)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"----do...while 使用-----"</span>)</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">5</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        println(y--)</span><br><span class="line">    &#125; <span class="keyword">while</span>(y&gt;<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">----<span class="keyword">do</span>...<span class="keyword">while</span> 使用-----</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h2><p>Kotlin 有三种结构化跳转表达式：</p><ul><li><em>return</em>。默认从最直接包围它的函数或者匿名函数返回。</li><li><em>break</em>。终止最直接包围它的循环。</li><li><em>continue</em>。继续下一次最直接包围它的循环。</li></ul><p>在循环中 Kotlin 支持传统的 break 和 continue 操作符。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">3</span>) <span class="keyword">continue</span>  <span class="comment">// i 为 3 时跳过当前循环，继续下一次循环</span></span><br><span class="line">        println(i)</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">5</span>) <span class="keyword">break</span>   <span class="comment">// i 为 6 时 跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Break-和-Continue-标签"><a href="#Break-和-Continue-标签" class="headerlink" title="Break 和 Continue 标签"></a>Break 和 Continue 标签</h3><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以用标签限制 break 或者continue：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。</p><h3 id="标签处返回"><a href="#标签处返回" class="headerlink" title="标签处返回"></a>标签处返回</h3><p>Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach <span class="symbol">lit@</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@lit</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun foo() &#123;</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        if (it == 0) return@forEach</span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        print(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当要返一个回值的时候，解析器优先选用标签限制的 return，即</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="symbol">@a</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>意为”从标签 @a 返回 1”，而不是”返回一个标签标注的表达式 (@a 1)”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;For-循环&quot;&gt;&lt;a href=&quot;#For-循环&quot; class=&quot;headerlink&quot; title=&quot;For 循环&quot;&gt;&lt;/a&gt;For 循环&lt;/h2&gt;&lt;p&gt;for 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; collection) print(item)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;循环体可以是一个代码块:&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (item: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; ints) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ……&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如上所述，for 可以循环遍历任何提供了迭代器的对象。&lt;/p&gt;
&lt;p&gt;如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array.indices) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(array[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。&lt;/p&gt;
&lt;p&gt;或者你可以用库函数 withIndex：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ((index, value) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array.withIndex()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;the element at &lt;span class=&quot;variable&quot;&gt;$index&lt;/span&gt; is &lt;span class=&quot;variable&quot;&gt;$value&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin条件控制</title>
    <link href="https://zhangmiao.cc/posts/7370c7df.html"/>
    <id>https://zhangmiao.cc/posts/7370c7df.html</id>
    <published>2020-09-16T06:13:01.000Z</published>
    <updated>2020-09-16T06:16:21.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IF-表达式"><a href="#IF-表达式" class="headerlink" title="IF 表达式"></a>IF 表达式</h2><p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统用法</span></span><br><span class="line"><span class="keyword">var</span> max = a </span><br><span class="line"><span class="keyword">if</span> (a &lt; b) max = b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 else </span></span><br><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    max = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 作为表达式</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>我们也可以把 IF 表达式的结果赋值给一个变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">"Choose a"</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"Choose b"</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (condition) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        println(<span class="string">"x 大于 0"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">        println(<span class="string">"x 等于 0"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        println(<span class="string">"x 小于 0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> c = <span class="keyword">if</span> (a&gt;=b) a <span class="keyword">else</span> b</span><br><span class="line">    println(<span class="string">"c 的值为 <span class="variable">$c</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x 等于 <span class="number">0</span></span><br><span class="line">c 的值为 <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="使用区间"><a href="#使用区间" class="headerlink" title="使用区间"></a>使用区间</h3><p>使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 <strong>x..y</strong> ：</p><p>实例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">val</span> y = <span class="number">9</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.8</span>) &#123;</span><br><span class="line">        println(<span class="string">"x 在区间内"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 在区间内</span><br></pre></td></tr></table></figure><hr><h2 id="When-表达式"><a href="#When-表达式" class="headerlink" title="When 表达式"></a>When 表达式</h2><p>when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。</p><p>when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。</p><p>when 类似其他语言的 switch 操作符。其最简单的形式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">"x 不是 1 ，也不是 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支。</p><p>如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10.</span><span class="number">.20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPrefix</span><span class="params">(x: <span class="type">Any</span>)</span></span> = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span> -&gt; println(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"otherwise"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; println(<span class="string">"x == 1"</span>)</span><br><span class="line">        <span class="number">2</span> -&gt; println(<span class="string">"x == 2"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">            println(<span class="string">"x 不是 1 ，也不是 2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span> -&gt; println(<span class="string">"x 在该区间范围内"</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"x 不在该区间范围内"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x == <span class="number">0</span> or x == <span class="number">1</span></span><br><span class="line">x 不是 <span class="number">1</span> ，也不是 <span class="number">2</span></span><br><span class="line">x 在该区间范围内</span><br></pre></td></tr></table></figure><p>when 中使用 <strong>in</strong> 运算符来判断集合内是否包含某实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> items = setOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>)</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        <span class="string">"orange"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"juicy"</span>)</span><br><span class="line">        <span class="string">"apple"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"apple is fine too"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apple <span class="keyword">is</span> fine too</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IF-表达式&quot;&gt;&lt;a href=&quot;#IF-表达式&quot; class=&quot;headerlink&quot; title=&quot;IF 表达式&quot;&gt;&lt;/a&gt;IF 表达式&lt;/h2&gt;&lt;p&gt;一个 if 语句包含一个布尔表达式和一条或多条语句。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 传统用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; max = a &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;lt; b) max = b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 else &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; max: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;gt; b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    max = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    max = b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 作为表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; max = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;gt; b) a &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们也可以把 IF 表达式的结果赋值给一个变量。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; max = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;gt; b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;Choose a&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;Choose b&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; c = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (condition) a &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android_Material组件使用详解</title>
    <link href="https://zhangmiao.cc/posts/389c1508.html"/>
    <id>https://zhangmiao.cc/posts/389c1508.html</id>
    <published>2020-09-11T02:34:32.000Z</published>
    <updated>2020-09-12T02:34:21.619Z</updated>
    
    <content type="html"><![CDATA[<p>Android官方为开发者提供了许多丰富的UI控件，Material 组件就是包含了这些控件的一套工具，多数时候使用它可以满足我们日常开发UI的需求，提高效率。目前Android Material 组件已经更新了1.2.0稳定版，赶紧来了解一波。</p><p>导入依赖，就可以开始了。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.android.material:material:1.2.0'</span></span><br></pre></td></tr></table></figure><h2 id="MaterialButton"><a href="#MaterialButton" class="headerlink" title="MaterialButton"></a>MaterialButton</h2><p>我们平时写布局，当遇到按钮需要圆角、或者描边等，通常的方法是新建一个xml文件，在shape标签下写，然后通过android:background或setBackground(drawable)设置。</p><p>这本来没什么问题，但是UI设计师会喜欢看起来和别人不一样的效果，也许是为了审（zhuang）美（bi），例如这个页面用4dp的圆角，那个页面用10dp的圆角，要有描边，颜色还不太一样……如果我们每个界面都新建个xml写shape，那么后期项目大了，维护起来就像无底洞……</p><p>那么有没有这样一个控件，能在xml直接配置圆角、描边属性，满足平时开发的基本UI需求？当然有，GitHub上第三方的库大把。不过Google官方在SDK28的时候也推出了一个新控件 —— MaterialButton，但是我发现很多人还不知道，今天就来安利下。</p><p>先来看一波效果图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105633.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105706.png" alt></p><a id="more"></a><p>按压水波纹，支持设置波纹颜色。</p><p>MaterialButton继承AppCompatButton，在原来Button的基础上做了一些扩展，如圆角、描边、前置和后置icon（icon支持设置Size、Tint、Padding、Gravity等），还支持按压水波纹并且设置color，基本能满足日常的需求。</p><p>公开属性如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200912103257.png" alt></p><h2 id="关于background"><a href="#关于background" class="headerlink" title="关于background"></a><strong>关于background</strong></h2><p>在1.2版本以前，MaterialButton只能通过app:backgroundTint属性设置背景色，该属性接收color state list。不能通过android:background设置自定义drawable。</p><p>1.2版本后，官方已修复此问题。如果未设置自定义背景，则 MaterialShapeDrawable 仍将用作默认背景。</p><p>也就是说，如果按钮背景是纯色，可以通过app:backgroundTint指定；如果按钮背景是渐变色，则需要自己定义drawable，然后通过android:background设置。</p><p>注意：如果要使用android:background设置背景，则需要将backgroundTint设置为@empty，否则background不会生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">”@drawable/custom_background”</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:backgroundTint</span>=<span class="string">”@empty”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>指定@empty后，Android Studio会出现红色警告，可以正常运行，忽略就好。不过既然已经自定义drawable，就没必要使用MaterialButton，直接用普通的Button甚至用TextView就好了。</p><h2 id="关于insetTop、insetBottom"><a href="#关于insetTop、insetBottom" class="headerlink" title="关于insetTop、insetBottom"></a><strong>关于insetTop、insetBottom</strong></h2><p>看下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/btn1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"150dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>xml预览图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105730.png" alt></p><p>有没有感觉怪怪的？貌似button上下多了一个padding！咦！代码里面明明没有设置padding啊！</p><p>看了源码发现，MaterialButton默认在style指定了insetTop和insetBottom为6dp，使得height看起来并没有Button实际设置值一样高，可以在xml将MaterialButton的insetTop和insetBottom都设置为0dp，这样MaterialButton的高度就和实际设置的高度一致了。</p><h2 id="关于阴影"><a href="#关于阴影" class="headerlink" title="关于阴影"></a><strong>关于阴影</strong></h2><p>MD组件默认都是自带阴影的，MaterialButton也不例外。但是有时候我们并不想要按钮有阴影，那么这时候可以指定style为<br>style=”@style/Widget.MaterialComponents.Button.UnelevatedButton”，这样就能去掉阴影，让视图看起来扁平化。</p><h2 id="关于theme"><a href="#关于theme" class="headerlink" title="关于theme"></a><strong>关于theme</strong></h2><p>在MDC1.1.0以后，使用MaterialButton可能会出现闪退的问题，原因就是使用了MD控件，但是未将them设置为MaterialComponents。解决方法可以有几种：</p><p>先在style.xml自定义MaterialComponents_Theme</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"MaterialComponents_Theme"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">       <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法一：</strong><br>AndroidManifest里application节点下配置，作用域为整个应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        ...</span><br><span class="line">        android:theme=&quot;@style/MaterialComponents_Theme&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong><br>只在当前activity配置，作用域为当前activity</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/MaterialComponents_Theme"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法三：</strong><br>为每个在使用到MD控件的地方配置，作用域只针对当前控件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/Theme.MaterialComponents.Light.NoActionBar"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关于在Android-Studio中预览"><a href="#关于在Android-Studio中预览" class="headerlink" title="关于在Android Studio中预览"></a><strong>关于在Android Studio中预览</strong></h2><p>如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.button.MaterialButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_send"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"@style/Widget.MaterialComponents.Button.UnelevatedButton"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"@dimen/dp_80"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"@dimen/dp_30"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">"@dimen/dp_12"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:insetTop</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:insetBottom</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/dispatch_room_text_upper_mic"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"@dimen/font_12"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:backgroundTint</span>=<span class="string">"@color/c_6D56FF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cornerRadius</span>=<span class="string">"@dimen/dp_15"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"@id/iv_head"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"@id/iv_head"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>xml预览</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105742.png" alt></p><p>可以看到xml预览效果和代码是不匹配的，这时候可以将预览的主题指定为MaterialComponents</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105759.png" alt></p><p>这样效果就和xml代码一致了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110109.png" alt></p><h2 id="ShapeableImageView"><a href="#ShapeableImageView" class="headerlink" title="ShapeableImageView"></a>ShapeableImageView</h2><p>来波效果图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110129.png" alt></p><p>以往我们实现图片圆角、描边等需求，多数时候是使用第三方或者自定义，Glide也有个扩展库，能很轻松帮我们实现。不过在MDC1.2.0中，已经有了一套官方的实现方案。那就是ShapeableImageView。</p><p>ShapeableImageView继承自ImageView，可以为image添加描边大小、颜色，以及圆角、裁切等，这得益于它新增了一个属性shapeAppearance，具体实现在ShapeAppearanceModel，可以通过style来配置，也可以通过代码实现。</p><h2 id="style配置："><a href="#style配置：" class="headerlink" title="style配置："></a><strong>style配置：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;StyleShapeAppearanceImage&quot; parent=&quot;&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;cornerFamily&quot;&gt;rounded&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;cornerSize&quot;&gt;16dp&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;cornerSizeTopRight&quot;&gt;10dp&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;cornerSizeBottomRight&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;com.google.android.material.imageview.ShapeableImageView</span><br><span class="line">    app:shapeAppearance=&quot;@style/StyleShapeAppearanceImage&quot;</span><br><span class="line">    ...</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><h2 id="代码设置："><a href="#代码设置：" class="headerlink" title="代码设置："></a><strong>代码设置：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">imageView?.shapeAppearanceModel = ShapeAppearanceModel.builder()</span><br><span class="line">            .setAllCorners(CornerFamily.ROUNDED,20f)</span><br><span class="line">            .setTopLeftCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setTopRightCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setBottomRightCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setBottomLeftCorner(CornerFamily.CUT,RelativeCornerSize(0.3f))</span><br><span class="line">            .setAllCornerSizes(ShapeAppearanceModel.PILL)</span><br><span class="line">            .setTopLeftCornerSize(20f)</span><br><span class="line">            .setTopRightCornerSize(RelativeCornerSize(0.5f))</span><br><span class="line">            .setBottomLeftCornerSize(10f)</span><br><span class="line">            .setBottomRightCornerSize(AbsoluteCornerSize(30f))</span><br><span class="line">            .build()</span><br></pre></td></tr></table></figure><p>代码接收一个ShapeAppearanceModel，通过构建者模式实现，setTopLeft表示处理左上角，其他同理。</p><p>cornerSize表示设置的大小，有RelativeCornerSize和AbsoluteCornerSize，RelativeCornerSize构造方法接收一个百分比，范围0-1；AbsoluteCornerSize构造方法接收一个具体数值，这个数值就是圆角的数值。</p><p>这里还有个CornerFamily，它表示处理的方式，有ROUNDED和CUT两种，ROUNDED是圆角，CUT是直接将圆角部分裁切掉。setAllCornerSizes(ShapeAppearanceModel.PILL)可以直接实现圆形效果。</p><h2 id="关于Stroke"><a href="#关于Stroke" class="headerlink" title="关于Stroke"></a><strong>关于Stroke</strong></h2><p>ShapeableImageView指定strokeWidth描边的时候，其描边会被覆盖掉一半，如strokeWidth=4dp，上下左右会被覆盖，实际的效果是只有2dp被显示。如图，</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110147.png" alt></p><p>github有人反馈了类似问题(<em><a href="https://github.com/material-components/material-components-android/issues/1489" target="_blank" rel="noopener">https://github.com/material-components/material-components-android/issues/1489</a></em>)，我的处理方法是在设置了strokeWidth的同时，设置相应的pading，这样描边就不会被覆盖了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.material.imageview.ShapeableImageView</span><br><span class="line">        ...</span><br><span class="line">        app:strokeWidth=&quot;4dp&quot;</span><br><span class="line">        android:padding=&quot;4dp&quot;</span><br></pre></td></tr></table></figure><h2 id="Slider-加强版的SeekBar"><a href="#Slider-加强版的SeekBar" class="headerlink" title="Slider(加强版的SeekBar)"></a>Slider(加强版的SeekBar)</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110158.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110241.png" alt></p><p>Slider的父类BaseSlider，直接继承View，重新实现逻辑。此外BaseSlider还有个子类RangeSlider，用它来实现图1效果2</p><p>Slider可以实现滑块头部数字变化效果，还可以实现类似刻度尺效果，比原生的SeekBar加强了不少。</p><p>常用属性如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200912103410.png" alt></p><p>其他属性还有haloColor、haloRadius、thumbColor等，用来配置一些外观</p><h2 id="BottomNavigationView"><a href="#BottomNavigationView" class="headerlink" title="BottomNavigationView"></a>BottomNavigationView</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911110253.png" alt></p><p>BottomNavigationView相比之前要完善了很多，可以设置icon大小，添加红点和未读消息数，以及超过3个item，切换效果也不会出现问题，通过LabelVisibilityMode.LABEL_VISIBILITY_LABELED指定。</p><p>以上主要列举了几个常用的控件，基本可以满足一些UI开发了，更多关于MDC的内容，大家可以到github去了解</p><p>material-components-android：</p><blockquote><p><a href="https://github.com/material-components/material-components-android" target="_blank" rel="noopener">https://github.com/material-components/material-components-android</a></p></blockquote><p>参考文章：</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652063934&idx=1&sn=caeaec14e70b7569c06503b1bb04138b&scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PZD8RxrqP7_RAjXIo345aQ</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android官方为开发者提供了许多丰富的UI控件，Material 组件就是包含了这些控件的一套工具，多数时候使用它可以满足我们日常开发UI的需求，提高效率。目前Android Material 组件已经更新了1.2.0稳定版，赶紧来了解一波。&lt;/p&gt;
&lt;p&gt;导入依赖，就可以开始了。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;implementation &lt;span class=&quot;string&quot;&gt;&#39;com.google.android.material:material:1.2.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;MaterialButton&quot;&gt;&lt;a href=&quot;#MaterialButton&quot; class=&quot;headerlink&quot; title=&quot;MaterialButton&quot;&gt;&lt;/a&gt;MaterialButton&lt;/h2&gt;&lt;p&gt;我们平时写布局，当遇到按钮需要圆角、或者描边等，通常的方法是新建一个xml文件，在shape标签下写，然后通过android:background或setBackground(drawable)设置。&lt;/p&gt;
&lt;p&gt;这本来没什么问题，但是UI设计师会喜欢看起来和别人不一样的效果，也许是为了审（zhuang）美（bi），例如这个页面用4dp的圆角，那个页面用10dp的圆角，要有描边，颜色还不太一样……如果我们每个界面都新建个xml写shape，那么后期项目大了，维护起来就像无底洞……&lt;/p&gt;
&lt;p&gt;那么有没有这样一个控件，能在xml直接配置圆角、描边属性，满足平时开发的基本UI需求？当然有，GitHub上第三方的库大把。不过Google官方在SDK28的时候也推出了一个新控件 —— MaterialButton，但是我发现很多人还不知道，今天就来安利下。&lt;/p&gt;
&lt;p&gt;先来看一波效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105633.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200911105706.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基本数据类型</title>
    <link href="https://zhangmiao.cc/posts/83cba390.html"/>
    <id>https://zhangmiao.cc/posts/83cba390.html</id>
    <published>2020-09-08T03:50:03.000Z</published>
    <updated>2020-09-08T03:52:53.953Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。</p><table><thead><tr><th align="left">类型</th><th align="left">位宽度</th></tr></thead><tbody><tr><td align="left">Double</td><td align="left">64</td></tr><tr><td align="left">Float</td><td align="left">32</td></tr><tr><td align="left">Long</td><td align="left">64</td></tr><tr><td align="left">Int</td><td align="left">32</td></tr><tr><td align="left">Short</td><td align="left">16</td></tr><tr><td align="left">Byte</td><td align="left">8</td></tr></tbody></table><hr><h2 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h2><p>下面是所有类型的字面常量：</p><ul><li>十进制：123</li><li>长整型以大写的 L 结尾：123L</li><li>16 进制以 0x 开头：0x0F</li><li>2 进制以 0b 开头：0b00001011</li><li>注意：8进制不支持</li></ul><p>Kotlin 同时也支持传统符号表示的浮点数值：</p><ul><li>Doubles 默认写法: <code>123.5</code>, <code>123.5e10</code></li><li>Floats 使用 f 或者 F 后缀：<code>123.5f</code></li></ul><p>你可以使用下划线使数字常量更易读：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000</span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999</span>_99_9999L</span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF</span>_EC_DE_5E</span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0</span>b11010010_01101001_10010100_10010010</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h2><p>Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p><p>在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">    println(a === a) <span class="comment">// true，值相等，对象地址相等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过了装箱，创建了两个不同的对象</span></span><br><span class="line">    <span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虽然经过了装箱，但是值是相等的，都是10000</span></span><br><span class="line">    println(boxedA === anotherBoxedA) <span class="comment">//  false，值相等，对象地址不一样</span></span><br><span class="line">    println(boxedA == anotherBoxedA) <span class="comment">// true，值相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>我们可以代用其toInt()方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>每种数据类型都有下面的这些方法，可以转化为其它的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toByte(): <span class="built_in">Byte</span></span><br><span class="line">toShort(): <span class="built_in">Short</span></span><br><span class="line">toInt(): <span class="built_in">Int</span></span><br><span class="line">toLong(): <span class="built_in">Long</span></span><br><span class="line">toFloat(): <span class="built_in">Float</span></span><br><span class="line">toDouble(): <span class="built_in">Double</span></span><br><span class="line">toChar(): <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p>有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="number">1</span>L + <span class="number">3</span> <span class="comment">// Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure><hr><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>对于Int和Long类型，还有一系列的位操作符可以使用，分别是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shl(bits) – 左移位 (Java’s &lt;&lt;)</span><br><span class="line">shr(bits) – 右移位 (Java’s &gt;&gt;)</span><br><span class="line">ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</span><br><span class="line">and(bits) – 与</span><br><span class="line">or(bits) – 或</span><br><span class="line">xor(bits) – 异或</span><br><span class="line">inv() – 反向</span><br></pre></td></tr></table></figure><hr><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 <strong>‘</strong> 包含起来的。比如普通字符 ‘0’，’a’。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// 错误：类型不兼容</span></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\t、 \b、\n、\r、&#39;、&quot;、\ 和 $。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’。</p><p>我们可以显式把字符转换为 Int 数字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decimalDigitValue</span><span class="params">(c: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c !<span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Out of range"</span>)</span><br><span class="line">    <span class="keyword">return</span> c.toInt() - <span class="string">'0'</span>.toInt() <span class="comment">// 显式转换为数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。</p><hr><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>布尔用 Boolean 类型表示，它有两个值：true 和 false。</p><p>若需要可空引用布尔会被装箱。</p><p>内置的布尔运算有：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|| – 短路逻辑或</span><br><span class="line">&amp;&amp; – 短路逻辑与</span><br><span class="line">! - 逻辑非</span><br></pre></td></tr></table></figure><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。</p><p>数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//[1,2,3]</span></span><br><span class="line">    <span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//[0,2,4]</span></span><br><span class="line">    <span class="keyword">val</span> b = Array(<span class="number">3</span>, &#123; i -&gt; (i * <span class="number">2</span>) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数组内容</span></span><br><span class="line">    println(a[<span class="number">0</span>])    <span class="comment">// 输出结果：1</span></span><br><span class="line">    println(b[<span class="number">1</span>])    <span class="comment">// 输出结果：2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，[] 运算符代表调用成员函数 get() 和 set()。</p><p>注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。</p><p>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    println(text)   <span class="comment">// 输出有一些前置空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 可以通过 trimMargin() 方法来删除多余的空白。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |菜鸟教程</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |Runoob</span></span><br><span class="line"><span class="string">    """</span>.trimMargin()</span><br><span class="line">    println(text)    <span class="comment">// 前置空格删除了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。</p><hr><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"i = <span class="variable">$i</span>"</span> <span class="comment">// 求值结果为 "i = 10"</span></span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用花括号扩起来的任意表达式:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"runoob"</span></span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span> <span class="comment">// 求值结果为 "runoob.length is 6"</span></span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> price = <span class="string">"""</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    println(price)  <span class="comment">// 求值结果为 $9.99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;类型&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;位宽度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Double&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Float&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Long&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Int&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Short&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Byte&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&quot;字面常量&quot;&gt;&lt;a href=&quot;#字面常量&quot; class=&quot;headerlink&quot; title=&quot;字面常量&quot;&gt;&lt;/a&gt;字面常量&lt;/h2&gt;&lt;p&gt;下面是所有类型的字面常量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十进制：123&lt;/li&gt;
&lt;li&gt;长整型以大写的 L 结尾：123L&lt;/li&gt;
&lt;li&gt;16 进制以 0x 开头：0x0F&lt;/li&gt;
&lt;li&gt;2 进制以 0b 开头：0b00001011&lt;/li&gt;
&lt;li&gt;注意：8进制不支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kotlin 同时也支持传统符号表示的浮点数值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Doubles 默认写法: &lt;code&gt;123.5&lt;/code&gt;, &lt;code&gt;123.5e10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Floats 使用 f 或者 F 后缀：&lt;code&gt;123.5f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以使用下划线使数字常量更易读：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; oneMillion = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;_000_000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; creditCardNumber = &lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;_5678_9012_3456L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; socialSecurityNumber = &lt;span class=&quot;number&quot;&gt;999&lt;/span&gt;_99_9999L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; hexBytes = &lt;span class=&quot;number&quot;&gt;0xFF&lt;/span&gt;_EC_DE_5E&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; bytes = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;b11010010_01101001_10010100_10010010&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/categories/Android/Kotlin/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
  </entry>
  
</feed>
