<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2019-09-13T07:24:31.350Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="https://zhangmiao.cc/posts/1cfae984.html"/>
    <id>https://zhangmiao.cc/posts/1cfae984.html</id>
    <published>2019-09-13T07:24:31.000Z</published>
    <updated>2019-09-13T07:24:31.350Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式十之备忘录模式</title>
    <link href="https://zhangmiao.cc/posts/6afac2a.html"/>
    <id>https://zhangmiao.cc/posts/6afac2a.html</id>
    <published>2019-09-13T07:18:51.000Z</published>
    <updated>2019-09-13T07:22:58.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习备忘录模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>备忘录模式</code>属于行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时口头禅 ”有没有后悔药“ 。备忘录模式实现的方式需要保证被保存的对象状态不能被对象外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象恢复到原先保存的状态。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要保存一个对象在某一个时刻的状态或部分状态。</li><li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913151959.png" alt></p><ul><li>Originator: 负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。</li><li>Memento: 备忘录角色，用于存储 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memento。</li><li>Caretaker: 负责存储备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其它对象。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>需求:</strong>  开发一款简单记事本, 包括撤销、重做功能。</p><p><strong>代码:</strong></p><p>负责管理记事本的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteCaretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大存储容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 50 个容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Memorandum&gt; mMemorandumLists = <span class="keyword">new</span> ArrayList&lt;&gt;(MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存档位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存备忘录到记录列表中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemorandum</span><span class="params">(Memorandum memorandum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMemorandumLists.size() &gt; MAX)&#123;</span><br><span class="line">            mMemorandumLists.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mMemorandumLists.add(memorandum);</span><br><span class="line">        mIndex = mMemorandumLists.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个存档信息，相当于撤销功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memorandum <span class="title">getPrevMemorandum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIndex = mIndex &gt; <span class="number">0</span> ? --mIndex : mIndex;</span><br><span class="line">        <span class="keyword">return</span> mMemorandumLists.get(mIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个存档信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memorandum <span class="title">getNextMemorandum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIndex = mIndex &lt; mMemorandumLists.size() - <span class="number">1</span>? ++mIndex : mIndex;</span><br><span class="line">        <span class="keyword">return</span> mMemorandumLists.get(mIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NodeCaretaker 中会维护一个备忘录列表，然后使用 mIndex 标识编辑器当前所在的记录点，通过 getPrev getNext 分别获取上一个、下一个记录点的备忘录，以此来达到撤销、重做的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeEditText</span> <span class="keyword">extends</span> <span class="title">EditText</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeEditText</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeEditText</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeEditText</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建备忘录对象，即存储编辑器的指定数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memorandum <span class="title">createMemorandum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Memorandum memorandum = <span class="keyword">new</span> Memorandum();</span><br><span class="line">        memorandum.text = getText().toString().trim();</span><br><span class="line">        memorandum.cursor = getSelectionStart();</span><br><span class="line">        <span class="keyword">return</span> memorandum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从备忘录中恢复数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Memorandum memorandum)</span></span>&#123;</span><br><span class="line">        setText(memorandum.text);</span><br><span class="line">        setSelection(memorandum.cursor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义一个记事本编辑器，添加2个函数，分别是 createMemorandum 、restore 函数。createMemorandum 函数是创建一个存储了编辑器文本，光标位置数据的 Memorandum 对象，并且返回给客户端；restore 函数是从 Memorandum 对象中恢复编辑器的文本和光标位置。</p><p>备忘录模式就介绍到这里了，主要还是要明确每个类的职责，遵从面向对象六大原则开发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点：</p><ul><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态。</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li></ul><p>缺点：</p><ul><li>消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习备忘录模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;备忘录模式&lt;/code&gt;属于行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时口头禅 ”有没有后悔药“ 。备忘录模式实现的方式需要保证被保存的对象状态不能被对象外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;需要保存一个对象在某一个时刻的状态或部分状态。&lt;/li&gt;
&lt;li&gt;如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="备忘录模式" scheme="https://zhangmiao.cc/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式九之观察者模式</title>
    <link href="https://zhangmiao.cc/posts/871a12ed.html"/>
    <id>https://zhangmiao.cc/posts/871a12ed.html</id>
    <published>2019-09-13T07:13:25.000Z</published>
    <updated>2019-09-13T07:18:28.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习观察者模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅-发布，因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得她们之间的依赖性更小，甚至做到毫无依赖。以 GUI 系统来说，应用的 UI 具有易变性，尤其是前期随着业务的改变或者产品的需求更改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时， GUI 系统需要一套机制来应对这种情况，使得 UI 层与具体的业务逻辑解耦，观察者模式此时就派上用场了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象间一种 1 对 N 的关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是 “组合” 关系。</li><li>事件多级触发场景。</li><li>跨系统的消息交换场景，如消息队列、事件总线的消息机制。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913151436.png" alt></p><ul><li><p>Subject : 抽象主题，也就是被观察者的角色，抽象主题角色把所有观察者</p><p>对象的引用保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p></li><li><p>ConcreteSubject: 具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发出通知，具体主题角色又叫做具体被观察者角色。</p></li><li><p>Observer: 抽象观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的状态发生变化时更新自身的状态。</p></li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>需求：订阅某网站技术文章，有更新就推送。</p><p>定义一个观察者对象 - 用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有更新将执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"o = ["</span> + o + <span class="string">"], arg = ["</span> + name + <span class="string">" "</span> + (String) arg + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Coder&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义被观察者对象 - 技术网站</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JueJ</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推送</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        <span class="comment">//标识状态或者内容需要发生改变</span></span><br><span class="line">        setChanged();</span><br><span class="line">        <span class="comment">//通知所有订阅者</span></span><br><span class="line">        notifyObservers(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建被观察者--》技术网站</span></span><br><span class="line">    JueJ jueJ = <span class="keyword">new</span> JueJ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建观察者</span></span><br><span class="line">    Coder coderA = <span class="keyword">new</span> Coder(<span class="string">"A"</span>);</span><br><span class="line">    Coder coderB = <span class="keyword">new</span> Coder(<span class="string">"B"</span>);</span><br><span class="line">    Coder coderC = <span class="keyword">new</span> Coder(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生订阅关系，加入被观察者列表中，有更新就推送给它们</span></span><br><span class="line">    jueJ.addObserver(coderA);</span><br><span class="line">    jueJ.addObserver(coderB);</span><br><span class="line">    jueJ.addObserver(coderC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有更新了，通知观察者们</span></span><br><span class="line">    jueJ.post(<span class="string">"Dev_YK: 更新了一篇设计模式文章，点击进行查看。"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o = [com.devyk.android_dp_code.observer.JueJ@<span class="number">48533e64</span>], arg = [C Dev_YK: 更新了一篇设计模式文章，点击进行查看。]</span><br><span class="line">o = [com.devyk.android_dp_code.observer.JueJ@<span class="number">48533e64</span>], arg = [B Dev_YK: 更新了一篇设计模式文章，点击进行查看。]</span><br><span class="line">o = [com.devyk.android_dp_code.observer.JueJ@<span class="number">48533e64</span>], arg = [A Dev_YK: 更新了一篇设计模式文章，点击进行查看。]</span><br></pre></td></tr></table></figure><p>可以看到所有订阅了某技术网站的用户都收到了通知更新，一对多的订阅-发布系统就完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>观察者模式主要的作用就是解耦，将观察者与被观察者完全隔离，只依赖于 Observe 和 Observable 抽象。</p><p><strong>优点：</strong></p><ul><li>观察者和被观察者之间是抽象耦合，应对业务变化。</li><li>增强系统灵活性，可扩展性。</li></ul><p><strong>缺点：</strong></p><ul><li>在应用观察者模式时需要考虑一下开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调试等内容会比较复杂，而且在 Java 中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这个情况下，一般考虑使用异步方式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习观察者模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅-发布，因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得她们之间的依赖性更小，甚至做到毫无依赖。以 GUI 系统来说，应用的 UI 具有易变性，尤其是前期随着业务的改变或者产品的需求更改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时， GUI 系统需要一套机制来应对这种情况，使得 UI 层与具体的业务逻辑解耦，观察者模式此时就派上用场了。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;定义对象间一种 1 对 N 的关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;关联行为场景，需要注意的是，关联行为是可拆分的，而不是 “组合” 关系。&lt;/li&gt;
&lt;li&gt;事件多级触发场景。&lt;/li&gt;
&lt;li&gt;跨系统的消息交换场景，如消息队列、事件总线的消息机制。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="https://zhangmiao.cc/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式八之责任链模式</title>
    <link href="https://zhangmiao.cc/posts/61fa11d3.html"/>
    <id>https://zhangmiao.cc/posts/61fa11d3.html</id>
    <published>2019-09-13T07:10:24.000Z</published>
    <updated>2019-09-13T07:17:49.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习责任链模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>责任链模式 (Iterator Pattern) ,属于行为型设计模式之一。什么是 “链” ？<code>我们将多个节点首尾相连所构成的模型称为链</code> 。就好比生活中一个个铁圆环一个连这一个环环相扣一样。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到处理为止。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个对象可以处理同一个请求，但是具体由哪个对象处理则在运行时动态决定。</li><li>在请求处理者不明确的情况下向多个对象中的一个提交一个请求。</li><li>需要动态指定一组对象处理请求。</li></ol><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913151119.png" alt></p><ul><li>Handler : 抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点 Handler 的引用。</li><li>ConcreteHandler: 具体处理角色，对请求进行处理，如果不能处理则将该请求转发给下一个请求。</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><strong>简单示例1：</strong></p><p>定义抽象处理者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String  TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点来负责处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始处理请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(HandlerRequest handlerRequest)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getHandlerRequestLevel() == handlerRequest.getRequestLevel())&#123;</span><br><span class="line">            handler(handlerRequest);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextHandler.handlerRequest(handlerRequest);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(TAG,<span class="string">"当前事件"</span>+handlerRequest.getRequestLevel() + <span class="string">"都不处理"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体处理方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handlerRequest</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(HandlerRequest handlerRequest)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取处理对象的处理级别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getHandlerRequestLevel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象请求者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerRequest</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取处理对象内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>  <span class="title">getRequestLevel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体处理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(HandlerRequest handlerRequest)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handlerRequest = ["</span> +TAG + <span class="string">" "</span> + (String) handlerRequest.getContent() + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getHandlerRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(HandlerRequest handlerRequest)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handlerRequest = ["</span> + TAG + <span class="string">" "</span> +(String) handlerRequest.getContent() + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getHandlerRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体请求者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestA</span> <span class="keyword">extends</span> <span class="title">HandlerRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestA</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestB</span> <span class="keyword">extends</span> <span class="title">HandlerRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestB</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function">        <span class="title">super</span><span class="params">(obj)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Client 测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造处理对象</span></span><br><span class="line">    Handler handlerA = <span class="keyword">new</span> HandlerA();</span><br><span class="line">    Handler handlerB = <span class="keyword">new</span> HandlerB();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交给下一个节点处理</span></span><br><span class="line">    handlerA.nextHandler = handlerB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造请求对象</span></span><br><span class="line">    HandlerRequest handlerRequestA = <span class="keyword">new</span> RequestA(<span class="string">"A"</span>);</span><br><span class="line">    HandlerRequest handlerRequestB = <span class="keyword">new</span> RequestB(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发起请求</span></span><br><span class="line">    handlerA.handlerRequest(handlerRequestA);</span><br><span class="line">    handlerA.handlerRequest(handlerRequestB);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handlerRequest = [HandlerA A]</span><br><span class="line">handlerRequest = [HandlerB B]</span><br></pre></td></tr></table></figure><p>从测试代码可以看到 ，我们的 handlerA 的下一个请求交给了 handlerB，那么在发起请求的时候内部就会判断，如果当前发起请求的级别跟处理事件的级别不符合的话 ，就交给下一个节点来判断，如果都没有找到就报空。</p><p><strong>实战示例2：</strong></p><p>在 Android 中我们知道 Broadcast 可以分为 2 种，一种是普通广播，一种是有序广播，普通广播是异步的，发出时可以被所有的接收者收到；而有序广播则是根据优先级依次传播的，直到接收者将其处理，是不是觉得有序广播跟我们的责任链模式很相似，通过广播也能达到实现责任链事件的处理，下面先看代码：</p><p>先动态注册 3 个广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerOrderBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filter.addAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    filter.setPriority(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    IntentFilter filterB = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filterB.addAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    filterB.setPriority(<span class="number">500</span>);</span><br><span class="line">    registerReceiver(<span class="keyword">new</span> ReceiverB(),filterB);</span><br><span class="line"></span><br><span class="line">    IntentFilter filterC = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filterC.addAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    filterC.setPriority(<span class="number">100</span>);</span><br><span class="line">    registerReceiver(<span class="keyword">new</span> ReceiverC(),filterC);</span><br><span class="line">    registerReceiver(<span class="keyword">new</span> ReceiverA(),filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverA</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (limit == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intent.getStringExtra(<span class="string">"MEG"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.i(<span class="string">"ReceiverA"</span>,<span class="string">"我处理了"</span>);</span><br><span class="line">                Toast.makeText(context,intent.getStringExtra(<span class="string">"MEG"</span>),Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理事件，终止广播</span></span><br><span class="line">            abortBroadcast();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(<span class="string">"ReceiverA"</span>,<span class="string">"我不处理，分发下去"</span>);</span><br><span class="line">            <span class="comment">//添加信息，继续分发，直到任务处理</span></span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle.putInt(<span class="string">"limit"</span>,<span class="number">1000</span>);</span><br><span class="line">            bundle.putString(<span class="string">"MEG"</span>,<span class="string">"中午啦，该吃饭了！"</span>);</span><br><span class="line">            setResultExtras(bundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…其它 2 个广播省略 内部代码只有 limit == ? 不一样</p><p>发送一个有序广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setAction(<span class="string">"com.it.dp_order"</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"limit"</span>,<span class="number">1000</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"MEG"</span>,<span class="string">"中午了，该吃饭了"</span>);</span><br><span class="line">    sendOrderedBroadcast(intent,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">08</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41.551</span> <span class="number">28992</span>-<span class="number">28992</span>/com.devyk.android_dp_code I/ReceiverA: 我不处理，分发下去</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">08</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41.557</span> <span class="number">28992</span>-<span class="number">28992</span>/com.devyk.android_dp_code I/ReceiverB: 我不处理，分发下去</span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">08</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41.574</span> <span class="number">28992</span>-<span class="number">28992</span>/com.devyk.android_dp_code I/ReceiverC: 我处理了</span><br></pre></td></tr></table></figure><p>这里我们动态注册了 3 个广播，优先级越高越先收到 A，B 都不符合要求，所以下发下去，最后在 C 接收者里面处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点：</strong></p><p>可以对请求者和处理者关系解耦，提高代码灵活性。</p><p><strong>缺点：</strong></p><p>对链中请求处理者的遍历，如果处理者太多，那么遍历会影响一定的性能，特别是在一些递归调用中，要慎用。</p><p>但总体来说，优点是大于缺点的，缺点相对于优点来说还是可控的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习责任链模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;责任链模式 (Iterator Pattern) ,属于行为型设计模式之一。什么是 “链” ？&lt;code&gt;我们将多个节点首尾相连所构成的模型称为链&lt;/code&gt; 。就好比生活中一个个铁圆环一个连这一个环环相扣一样。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到处理为止。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;多个对象可以处理同一个请求，但是具体由哪个对象处理则在运行时动态决定。&lt;/li&gt;
&lt;li&gt;在请求处理者不明确的情况下向多个对象中的一个提交一个请求。&lt;/li&gt;
&lt;li&gt;需要动态指定一组对象处理请求。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="责任链模式" scheme="https://zhangmiao.cc/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式七之状态模式</title>
    <link href="https://zhangmiao.cc/posts/1942adf8.html"/>
    <id>https://zhangmiao.cc/posts/1942adf8.html</id>
    <published>2019-09-13T07:04:34.000Z</published>
    <updated>2019-09-13T07:18:04.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习状态模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式和策略模式的结构几乎完全一样，但它们的目的、本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、可相互替换的。用一句话来表述，状态模式把对象的行为包装在不同的状态对象里，每一个状态对象都有一个共同抽象状态的基类。状态模式的意图是让一个对象在其内部改变的时候，其行为也随之改变。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。</li><li>代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的分支语句 (if-else / switch-case) , 且这些分支依赖于该对象的状态。</li></ol><p>状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的 if - else 等分支语句。</p><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913150739.png" alt></p><ul><li>Context: 环境类，定义客户感兴趣的接口，维护一个 State 子类的实例，这个实例定义了对象的当前状态。</li><li>State: 抽象状态类或者状态接口，定义一个或者一组接口，表示该状态下的行为。</li><li>ConcreteStateA、ConcreteStateB: 具体状态类，每一个具体的状态类实现抽象 State 中定义的接口，从而达到不同状态下的不同行为。</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>在开发中，我们用到状态模式最常见的地方应该是用户登录系统。在用户登录和未登录的情况下，对于同一事件的处理行为是不一样的，例如，在淘宝中，用户在未登录的情况下点击购买，此时会先让用户登录，然后在做购买支付的操作。</p><p>下面我们就用状态模式来简单实现这个过程，首先创建 2 个 Activity , 一个是 LoginActivity, 一个是 HomeActivity , HomeActivity 是应用入口，有购买和注销用户功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽取公共的状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 购物</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Shopping</span><span class="params">(Context context,<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginOut</span><span class="params">(Context context,String token)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体登录状态实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginState</span> <span class="keyword">implements</span> <span class="title">IUserState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shopping</span><span class="params">(Context context,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"购买商品-》"</span> + id + <span class="string">" 即将支付"</span>);</span><br><span class="line">        Toast.makeText(context,<span class="string">"购买商品-》"</span> + id + <span class="string">" 即将支付"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginOut</span><span class="params">(Context context,String token)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"退出系统成功"</span>);</span><br><span class="line">         LoginContext.getInstance().setState(<span class="keyword">new</span> LoginOutState());</span><br><span class="line">        Toast.makeText(context,<span class="string">"退出系统成功"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体未登录状态实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginOutState</span> <span class="keyword">implements</span> <span class="title">IUserState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shopping</span><span class="params">(Context context, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        gotoLogin(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gotoLogin</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, LoginActivity.class);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginOut</span><span class="params">(Context context, String token)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"已经是退出状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context 登录状态管理类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户状态 默认未登录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IUserState mIuserState = <span class="keyword">new</span> LoginOutState();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LoginContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(Context context,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        mIuserState.Shopping(context,id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginOut</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        mIuserState.loginOut(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> LoginContext loginContext = <span class="keyword">new</span> LoginContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoginContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoginHolder.loginContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入用户的状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userState</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(IUserState userState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mIuserState = userState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText mUser;</span><br><span class="line">    <span class="keyword">private</span> EditText mPwd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line"></span><br><span class="line">        mUser = findViewById(R.id.etUser);</span><br><span class="line">        mPwd = findViewById(R.id.etPwd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mUser.getText().toString().trim().equals(<span class="string">"123456"</span>) &amp;&amp; mPwd.getText().toString().trim().equals(<span class="string">"123456"</span>)) &#123;</span><br><span class="line">            LoginContext.getInstance().setState(<span class="keyword">new</span> LoginState());</span><br><span class="line">            Toast.makeText(getApplicationContext(), <span class="string">"登录成功"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, HomeActivity.class));</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_home);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        LoginContext.getInstance().setState(<span class="keyword">new</span> LogoutState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        LoginContext.getInstance().shopping(getApplicationContext(),<span class="number">199</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户默认是未登录状态，此时用户在 HomeActivity 界面点击购物时，会先跳转到 LoginActivity 页面，然后登录成功之后在返回到 HomeActivity 页面，此时，用户再次点击购物就可以实现该功能了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>状态模式的关键点在于不同的状态下对于同一行为有不同的响应，这其实就是一个将 if~else 用多态来实现的一个具体示例，模式的运用一定要考虑所处的情景以及你要解决的问题，只有符合特定的场景才建议使用对应的模式。</p><p><strong>优点：</strong></p><p>State 模式将所有与一个特性的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转换成结构清晰的状态类族，在避免代码膨胀的同时也保证了可扩展性与可维护性。</p><p><strong>缺点：</strong></p><p>状态模式的使用必然会增加系统类和对象的个数。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习状态模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式和策略模式的结构几乎完全一样，但它们的目的、本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、可相互替换的。用一句话来表述，状态模式把对象的行为包装在不同的状态对象里，每一个状态对象都有一个共同抽象状态的基类。状态模式的意图是让一个对象在其内部改变的时候，其行为也随之改变。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。&lt;/li&gt;
&lt;li&gt;代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的分支语句 (if-else / switch-case) , 且这些分支依赖于该对象的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的 if - else 等分支语句。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="https://zhangmiao.cc/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六之策略模式</title>
    <link href="https://zhangmiao.cc/posts/12c9315d.html"/>
    <id>https://zhangmiao.cc/posts/12c9315d.html</id>
    <published>2019-09-13T07:00:43.000Z</published>
    <updated>2019-09-13T07:16:13.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习策略模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在软件开发中常常遇见这样的问题：实现某个功能可以有多种算法或者策略，我们根据实际情况选择不同的算法或者策略来完成该功能。例如，排序算法，可以有多种的实现方式。</p><p>那么，针对这种情况，应该怎么处理？是将这些算法写在一个类中，每一个方法对应一个具体的排序算法；还是将这些排序算法封装在同一个方法中，通过 if…else 或者 case 等条件判断语句来选择具体的算法。这 2 种实现方法我们都可以称之为硬编码。当然，这样是可以实现需求，但是，当很多算法在一个类时，这个类就会变得很臃肿，维护成本就会变高，并且在维护时容易发生错误，如果我们需要新增或者修改算法类的源码，这个就需要动封装好的类，那么这就违背了单一职责和开闭原则了。</p><p>如果将这些算法或者策略抽象出来，提供统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性，可维护性也就更高，这就是我们今天要学习的策略模式。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使他们还可以相互替换，策略模式让算法独立于使用它的客户而独立变化。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li><li>需要安全的封装多种同一类型操作时。</li><li>出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</li></ul><a id="more"></a><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913150549.png" alt></p><ul><li>Context ：用来操作策略的上下文环境</li><li>Stragety : 策略的抽象</li><li>ConcreteStragetyA, ConcreteStragetyB 具体策略实现。</li></ul><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>需求：对交通工具计算车费，一般轿车，中等轿车，豪华轿车。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算费用接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按距离计算车费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> km  公里数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种车的计算方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralCar</span> <span class="keyword">implements</span> <span class="title">ICalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">0</span> &amp;&amp; km &lt;= <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">5</span> &amp;&amp; km &lt;= <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">7</span> &amp;&amp; km &lt;= <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中级车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediumCar</span> <span class="keyword">implements</span> <span class="title">ICalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">0</span> &amp;&amp; km &lt;= <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">5</span> &amp;&amp; km &lt;= <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">7</span> &amp;&amp; km &lt;= <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高级车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuxuryCar</span> <span class="keyword">implements</span> <span class="title">ICalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">0</span> &amp;&amp; km &lt;= <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">5</span> &amp;&amp; km &lt;= <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">if</span> (km &gt; <span class="number">7</span> &amp;&amp; km &lt;= <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在创建一个操作 Context 策略的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportationCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交通工具计算费用策略类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ICalculateStrategy iCalculateStrategy = <span class="keyword">new</span> GeneralCar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> calculateStrategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(ICalculateStrategy calculateStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>. iCalculateStrategy = calculateStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calcu</span><span class="params">(<span class="keyword">int</span> km)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iCalculateStrategy.calculatePrice(km);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TransportationCalculator transportationCalculator = <span class="keyword">new</span> TransportationCalculator();</span><br><span class="line">  System.out.println(<span class="string">"普通车 1 km RMB:"</span> + transportationCalculator.calcu(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  transportationCalculator.setStrategy(<span class="keyword">new</span> MediumCar());</span><br><span class="line">  System.out.println(<span class="string">"中级车 1 km RMB:"</span> + transportationCalculator.calcu(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  transportationCalculator.setStrategy(<span class="keyword">new</span> LuxuryCar());</span><br><span class="line">  System.out.println(<span class="string">"豪华车 1 km RMB:"</span> + transportationCalculator.calcu(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">普通车 <span class="number">1</span> km RMB:<span class="number">5</span></span><br><span class="line">中级车 <span class="number">1</span> km RMB:<span class="number">6</span></span><br><span class="line">豪华车 <span class="number">1</span> km RMB:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>有没有发现这种写法不仅结构变得清晰，而且还易维护，扩展性也很强。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。在这个模式很好地演示了开闭原则，也就是定义接口抽象，注入不同的实现，从而达到很好的可扩展性。</p><p>优点：</p><ul><li>结构清晰明了、使用简单直观；</li><li>耦合度相对而言较低，扩展方便；</li><li>操作封装也更为彻底，数据更为安全；</li></ul><p>缺点：</p><ul><li>随着策略的增加，子类也会变得繁多</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习策略模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在软件开发中常常遇见这样的问题：实现某个功能可以有多种算法或者策略，我们根据实际情况选择不同的算法或者策略来完成该功能。例如，排序算法，可以有多种的实现方式。&lt;/p&gt;
&lt;p&gt;那么，针对这种情况，应该怎么处理？是将这些算法写在一个类中，每一个方法对应一个具体的排序算法；还是将这些排序算法封装在同一个方法中，通过 if…else 或者 case 等条件判断语句来选择具体的算法。这 2 种实现方法我们都可以称之为硬编码。当然，这样是可以实现需求，但是，当很多算法在一个类时，这个类就会变得很臃肿，维护成本就会变高，并且在维护时容易发生错误，如果我们需要新增或者修改算法类的源码，这个就需要动封装好的类，那么这就违背了单一职责和开闭原则了。&lt;/p&gt;
&lt;p&gt;如果将这些算法或者策略抽象出来，提供统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性，可维护性也就更高，这就是我们今天要学习的策略模式。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;策略模式定义了一系列算法，并将每一个算法封装起来，而且使他们还可以相互替换，策略模式让算法独立于使用它的客户而独立变化。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。&lt;/li&gt;
&lt;li&gt;需要安全的封装多种同一类型操作时。&lt;/li&gt;
&lt;li&gt;出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://zhangmiao.cc/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式五之抽象工厂模式</title>
    <link href="https://zhangmiao.cc/posts/1ef33906.html"/>
    <id>https://zhangmiao.cc/posts/1ef33906.html</id>
    <published>2019-09-13T06:54:11.000Z</published>
    <updated>2019-09-13T07:16:29.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习抽象工厂模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>抽象工厂模式 (Abstract Factory Pattern) 也是创建型设计模式之一。上一篇讲解了 <a href="https://zhangmiao.cc/posts/3319c3e.html">工厂方法模式</a> ,那么这个抽象工厂又是怎么一回事呢？大家联想一下像是生活中的工厂肯定都是具体的，也就是说每个工厂都会生产某一种具体的产品，那么抽象工厂意味着生产出来的产品是不确定的，那这岂不是很奇怪？抽象工厂模式起源于以前对不同操作系统的图形化解决方案，如不同操作系统中的按钮和文本框控件其实现不同，展示效果也不一样，对于每一个操作系统，其本身就构成一个产品类，而按钮与文本框控件也构成一个产品类，两种产品类两种变化，各自有自己的特性，如 Android 中的 Button 和 TextView 、IOS 中的 Button 、和 TextView 、 Window Phone 中的 Button 和 TextView  等。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为创建一组相关或者相互依赖的对象提供一个借口，而不需要制定它们的具体类。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一个对象如有相同的约束时可以使用抽象工厂模式。是不是听起来很抽象 ？ 举个例子，Android 、IOS 、Window Phone 下都有短信软件和拨号软件，两者都属于软件的范畴，但是，它们所在的操作系统平台不一样，即便是同一家公司出品的软件，其代码实现逻辑也是不同的，这时候就可以考虑使用抽象工厂方法模式来产生 Android 、IOS 、Window Phone 下短信软件和拨号软件。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913145715.png" alt></p><a id="more"></a><ul><li>AbstractFactory ：抽象工厂角色，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品，如上图中的 AbstractFactory 中就定义了两个方法，分别创建产品 A 和产品 B 。</li><li>ConcreteFactory : 具体工厂角色，它实现了在抽象工厂中定义的创建产品的方法，生成一组具体产品，这些产品构成了一个产品种类，每一个产品都位于某个产品等级结构中，如上述类图中的 ConcreteFactory1 、ConcreteFactory2。</li><li>AbstractProduct: 抽象产品角色，它为每种产品声明接口，比如上述类图中的 AbstractProduct A, AbstractProduct B。</li><li>ConcreteProduct: 具体产品角色，它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法，如上图的 ConcreteProductA1 , ConcreteProductA2 , ConcreteProductB1 ,ConcreteProductB2.</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>其实我们平时在开发中应该很少用到抽象工厂模式，一个很重要的原因是，其相对于其他两种工厂模式来说略显复杂，对于整体架构而言修改较大且不易施展。一个很典型的例子适用于数据库模型的构建，不过对于这块来讲，大多说设计模式都能应用到其中，对于 Android 开发者来说，抽象工厂的一个更好地应用是在主题修改上，假如在项目中需要引入一套主题切换的功能，那么使用抽象工厂来构建主题框架再适合不过了，下面就以一个代码示例在说明吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**抽象主题工厂类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractThemeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractThemeFactory</span><span class="params">(Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = mContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建主题按钮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> ThemeButton <span class="title">createButton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建主题标题栏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  ThemeToolbar <span class="title">createToolbar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象主题工厂中只定义了创建 UI 元素的抽象方法，而具体实现则由不同的子类去完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**暗色系主题工厂*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkThemeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractThemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkThemeFactory</span><span class="params">(Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThemeButton <span class="title">createButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ButtonDrak(mContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThemeToolbar <span class="title">createToolbar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ToolbarDrak(mContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**亮色系主题工厂*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightThemeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractThemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightThemeFactory</span><span class="params">(Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThemeButton <span class="title">createButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ButtonLight(mContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThemeToolbar <span class="title">createToolbar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ToolbarLight(mContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Dark ， Light 都实现了各自的主题元素，下面我们看下 UI 元素抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题标题栏颜色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeToolbar</span> <span class="keyword">extends</span> <span class="title">Toolbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThemeToolbar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        initIcon();</span><br><span class="line">        </span><br><span class="line">        initTextColor();</span><br><span class="line"></span><br><span class="line">        initBackgroundColor()</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initIcon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始话按钮颜色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initTextColor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化按钮颜色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initBackgroundColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题按钮类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeButton</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThemeButton</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">        initTextColor();</span><br><span class="line"></span><br><span class="line">        initBackgroundColor()</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始话按钮颜色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initTextColor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化按钮颜色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initBackgroundColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题颜色实现类，我这里就那一个举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonDark</span> <span class="keyword">extends</span> <span class="title">ThemeButton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ButtonDark</span><span class="params">(Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTextColor</span><span class="params">()</span> </span>&#123;        setTextColor(mContext.getResources().getColor(R.color.dark_color));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBackgroundColor</span><span class="params">()</span> </span>&#123;      setBackgroundColor(mContext.getResources().getColor(R.color.dark_color));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DarkThemeFactory darkThemeFactory = <span class="keyword">new</span> DarkThemeFactory(getContext();</span><br><span class="line"><span class="comment">//创建暗色主题按钮</span></span><br><span class="line">ThemeButton button = darkThemeFactory.createButton();</span><br><span class="line"><span class="comment">//创建亮色主题标题栏</span></span><br><span class="line">ThemeToolbar toolbar = darkThemeFactory.createToolbar();</span><br></pre></td></tr></table></figure><p>大家可以看到，抽象工厂模式的结构相对于简单工厂和工厂方法模式来说要复杂的多，但是其本身也是应用于较为复杂场景的解耦，比如上述事例中，我们就应对了多个层面的变化，因此在实际项目开发中是否使用抽象工厂模式还需要看具体情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点：</p><p>一个显著的优点是分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体实现是谁，客户端只是面向产品接口编程而已，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象工厂方法模式在切换产品类时更加灵活，容易。</p><p>缺点：</p><p>随着产品类的增加，抽象工厂也得修改，相当于所有的具体工厂都得修改，不易扩展新的产品。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习抽象工厂模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;抽象工厂模式 (Abstract Factory Pattern) 也是创建型设计模式之一。上一篇讲解了 &lt;a href=&quot;https://zhangmiao.cc/posts/3319c3e.html&quot;&gt;工厂方法模式&lt;/a&gt; ,那么这个抽象工厂又是怎么一回事呢？大家联想一下像是生活中的工厂肯定都是具体的，也就是说每个工厂都会生产某一种具体的产品，那么抽象工厂意味着生产出来的产品是不确定的，那这岂不是很奇怪？抽象工厂模式起源于以前对不同操作系统的图形化解决方案，如不同操作系统中的按钮和文本框控件其实现不同，展示效果也不一样，对于每一个操作系统，其本身就构成一个产品类，而按钮与文本框控件也构成一个产品类，两种产品类两种变化，各自有自己的特性，如 Android 中的 Button 和 TextView 、IOS 中的 Button 、和 TextView 、 Window Phone 中的 Button 和 TextView  等。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;为创建一组相关或者相互依赖的对象提供一个借口，而不需要制定它们的具体类。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;一个对象如有相同的约束时可以使用抽象工厂模式。是不是听起来很抽象 ？ 举个例子，Android 、IOS 、Window Phone 下都有短信软件和拨号软件，两者都属于软件的范畴，但是，它们所在的操作系统平台不一样，即便是同一家公司出品的软件，其代码实现逻辑也是不同的，这时候就可以考虑使用抽象工厂方法模式来产生 Android 、IOS 、Window Phone 下短信软件和拨号软件。&lt;/p&gt;
&lt;h2 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190913145715.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="抽象工厂模式" scheme="https://zhangmiao.cc/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式四之工厂方法模式</title>
    <link href="https://zhangmiao.cc/posts/3319c3e.html"/>
    <id>https://zhangmiao.cc/posts/3319c3e.html</id>
    <published>2019-09-13T06:48:44.000Z</published>
    <updated>2019-09-13T07:16:43.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习工厂方法模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>工厂模式 ( Factory Pattern ) ，是创建型设计模式之一。工厂方法模式是一种结构简单的模式，其在我们平时开发中应用很广泛，也许你并不知道，但是你已经使用了无数次改模式了，如 Android 中的 Activity 里各个生命周期方法，以 onCreate 方法为例，它就可以看做是一个工厂方法，我们在其中可以构造我们的 View,并通过 setContentView 返回给 Framework 处理。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪个类。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用 new 就可以完成创建的对象无需使用 Factory 。</p><h2 id="工厂模式代码示例"><a href="#工厂模式代码示例" class="headerlink" title="工厂模式代码示例"></a>工厂模式代码示例</h2><p>需求：根据用户不同的权限，匹配不同的业务模块。</p><p>定义一个抽象的业务模块类</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据不同的权限 拿到功能模块</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permission</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;IFunctionModule&gt; <span class="title">getMoudleFun</span><span class="params">(String permission)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体功能的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayMusicImpl</span> <span class="keyword">implements</span> <span class="title">IFunctionModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG,<span class="string">"播放音乐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayVideoImpl</span> <span class="keyword">implements</span> <span class="title">IFunctionModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG,<span class="string">"播放视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsImpl</span> <span class="keyword">implements</span> <span class="title">IFunctionModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"看新闻"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体功能模块工厂开始生产需要的模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunModuleFactor</span> <span class="keyword">extends</span> <span class="title">IModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;IFunctionModule&gt; <span class="title">getMoudleFun</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (permission) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"VIP"</span>:</span><br><span class="line">            List&lt;IFunctionModule&gt; vipLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            vipLists.add(<span class="keyword">new</span> PlayMusicImpl());</span><br><span class="line">            vipLists.add(<span class="keyword">new</span> PlayVideoImpl());</span><br><span class="line">            vipLists.add(<span class="keyword">new</span> NewsImpl());</span><br><span class="line">          <span class="keyword">return</span> vipLists;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">           List&lt;IFunctionModule&gt; kipLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           kipLists.add(<span class="keyword">new</span> PlayMusicImpl());</span><br><span class="line">           kipLists.add(<span class="keyword">new</span> NewsImpl());</span><br><span class="line">           <span class="keyword">return</span> kipLists;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FunModuleFactor funModuleFactor = <span class="keyword">new</span> FunModuleFactor();</span><br><span class="line">    List&lt;IFunctionModule&gt; vip = funModuleFactor.getMoudleFun(<span class="string">"VIP"</span>);</span><br><span class="line">    System.out.println(<span class="string">"VIP:"</span> + vip.size());</span><br><span class="line"></span><br><span class="line">    List&lt;IFunctionModule&gt; kip = funModuleFactor.getMoudleFun(<span class="string">"KIP"</span>);</span><br><span class="line">    System.out.println(<span class="string">"KIP:"</span> + kip.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIP:3</span><br><span class="line">KIP:2</span><br></pre></td></tr></table></figure><p>根据上面代码可知，我们定义了一个抽象模块类 IMoudle，FunModuleFactory 实现了 IModule ,外部可以通过不同的权限来组装对应的业务功能。也就实现了这个需求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，工厂方法模式是一个很好的设计模式，但是也有缺点，每次我们为工厂方法模式添加一个新的模块都要编写新的模块类，同时引入抽象层，这必然会导致类结构的复杂化，所以，在某些情况比较简单时，是否使用工厂模式，需要自己权衡利弊了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习工厂方法模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;工厂模式 ( Factory Pattern ) ，是创建型设计模式之一。工厂方法模式是一种结构简单的模式，其在我们平时开发中应用很广泛，也许你并不知道，但是你已经使用了无数次改模式了，如 Android 中的 Activity 里各个生命周期方法，以 onCreate 方法为例，它就可以看做是一个工厂方法，我们在其中可以构造我们的 View,并通过 setContentView 返回给 Framework 处理。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;定义一个用于创建对象的接口，让子类决定实例化哪个类。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用 new 就可以完成创建的对象无需使用 Factory 。&lt;/p&gt;
&lt;h2 id=&quot;工厂模式代码示例&quot;&gt;&lt;a href=&quot;#工厂模式代码示例&quot; class=&quot;headerlink&quot; title=&quot;工厂模式代码示例&quot;&gt;&lt;/a&gt;工厂模式代码示例&lt;/h2&gt;&lt;p&gt;需求：根据用户不同的权限，匹配不同的业务模块。&lt;/p&gt;
&lt;p&gt;定义一个抽象的业务模块类&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂方法模式" scheme="https://zhangmiao.cc/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式三之原型模式</title>
    <link href="https://zhangmiao.cc/posts/7a86e223.html"/>
    <id>https://zhangmiao.cc/posts/7a86e223.html</id>
    <published>2019-09-12T08:13:39.000Z</published>
    <updated>2019-09-13T06:52:20.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习原型模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>原型模式是一个创建型的模式。原型二字表明了该模式应该有一个模板实例，用户从这个模板对象中复制出一个内部属性一致并且内存地址不同的对象，这个过程也就是我们俗称的 “克隆” 。被复制的实例就是我们所称的 “原型” ，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型复制避免这些消耗。</li><li>通过 new 产生一个对象需要非常繁琐的数据准备和访问权限，这时可以使用原型模式。</li><li>一个对象需要提供给其它对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式复制多个对象供调用者使用，既保护性拷贝。</li></ol><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912161545.png" alt></p><ul><li>Client: 客户端用户。</li><li>Prototype: 抽象类或者接口，声明具备 clone 能力。</li><li>ConcreatePrototype: 具体的原型类</li></ul><a id="more"></a><h2 id="原型模式的简单实现"><a href="#原型模式的简单实现" class="headerlink" title="原型模式的简单实现"></a>原型模式的简单实现</h2><p>下面以简单的文档 copy 为例来演示一下原型模式。</p><p>需求：有一个文档，文档中包含了文字和图片，用户经过了长时间的内容编辑后，打算对该文档做进一步的编辑，但是，这个编辑后的文档是否会被采用还不确定，因此，为了安全起见，用户需要将当前文档 copy 一份，然后再在文档副本上进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***这里代表是具体原型类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mTxt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片名列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mImagePath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getmTxt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmTxt</span><span class="params">(String mTxt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mTxt = mTxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getImagePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImagePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImagepath</span><span class="params">(String imagepath)</span> </span>&#123;</span><br><span class="line">        mImagePath.add(imagepath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印文档内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------------  start  ----------------"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"txt: "</span> + mTxt);</span><br><span class="line">        System.out.println(<span class="string">"mImagePath: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : mImagePath) &#123;</span><br><span class="line">            System.out.println(<span class="string">"path: "</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------  end   ----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明具备 clone 能力</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> clone 的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WordDocument document = (WordDocument)<span class="keyword">super</span>.clone();</span><br><span class="line">            document.mTxt = <span class="keyword">this</span>.mTxt;</span><br><span class="line">            document.mImagePath = <span class="keyword">this</span>.mImagePath;</span><br><span class="line">            <span class="keyword">return</span> document;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 构建文档对象</span></span><br><span class="line">    WordDocument wordDocument = <span class="keyword">new</span> WordDocument();</span><br><span class="line">    <span class="comment">//2. 编辑文档</span></span><br><span class="line">    wordDocument.setmTxt(<span class="string">"今天是一个好天气"</span>);</span><br><span class="line">    wordDocument.addImagepath(<span class="string">"/sdcard/image.png"</span>);</span><br><span class="line">    wordDocument.addImagepath(<span class="string">"/sdcard/image2.png"</span>);</span><br><span class="line">    wordDocument.addImagepath(<span class="string">"/sdcard/image3.png"</span>);</span><br><span class="line">    <span class="comment">//打印文档内容</span></span><br><span class="line">    wordDocument.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"--------------------开始clone-----\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以原始文档为准，copy 副本</span></span><br><span class="line">    WordDocument cloneDoc = wordDocument.clone();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" 打印副本，看看数据  \n\n"</span>);</span><br><span class="line">    <span class="comment">//打印副本，看看数据</span></span><br><span class="line">    cloneDoc.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在副本文档上修改</span></span><br><span class="line">    cloneDoc.setmTxt(<span class="string">"副奔上修改文档：老龙王哭了"</span>);</span><br><span class="line">    System.out.println(<span class="string">"  打印修改后的副本  \n\n"</span>);</span><br><span class="line">    <span class="comment">//打印修改后的副本</span></span><br><span class="line">    cloneDoc.println();</span><br><span class="line">    System.out.println(<span class="string">"----看会不会影响原始文档-----\n\n"</span>);</span><br><span class="line">    <span class="comment">//看会不会影响原始文档？？？？？？？</span></span><br><span class="line">    wordDocument.println();</span><br><span class="line">  System.out.println(<span class="string">"内存地址：\nwordDocument: "</span>+wordDocument.toString() +<span class="string">"\n"</span> + <span class="string">"cloneDoc: "</span>+cloneDoc.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image2<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image3<span class="variable">.png</span></span><br><span class="line">-----------------  <span class="keyword">end</span>   ----------------</span><br><span class="line"></span><br><span class="line">--------------------开始clone-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 打印副本，看看数据  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image2<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image3<span class="variable">.png</span></span><br><span class="line">-----------------  <span class="keyword">end</span>   ----------------</span><br><span class="line"></span><br><span class="line">  打印修改后的副本  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 副奔上修改文档：老龙王哭了</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image2<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image3<span class="variable">.png</span></span><br><span class="line">-----------------  <span class="keyword">end</span>   ----------------</span><br><span class="line"></span><br><span class="line">----看会不会影响原始文档-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image2<span class="variable">.png</span></span><br><span class="line">path: /sdcard/image3<span class="variable">.png</span></span><br><span class="line">-----------------  <span class="keyword">end</span>   ----------------</span><br><span class="line">  </span><br><span class="line">内存地址：</span><br><span class="line">wordDocument: com<span class="variable">.devyk</span><span class="variable">.android_dp_code</span><span class="variable">.prototype</span><span class="variable">.WordDocument</span>@<span class="number">48533</span>e64</span><br><span class="line">cloneDoc: com<span class="variable">.devyk</span><span class="variable">.android_dp_code</span><span class="variable">.prototype</span><span class="variable">.WordDocument</span>@<span class="number">64</span>a294a6</span><br></pre></td></tr></table></figure><p>从上面代码跟打印可以看出 cloneDoc 是通过 wordDocument.clone() 创建的并且 cloneDoc 第一次输出和 wordDocument 原始文档数据一样，既 cloneDoc 是 wordDocument 的一份副本文件。难道这样就完了吗？不知道大家有没有注意这里的  mImagePath 字段，原始对象的 clone 方法这里相当把引用地址复制给了 clone 出来的对象，如果这 2 个对象中的任意一个对其修改，那么就会对原始数据造成破坏，失去了对数据的保护。那么怎么解决这个问题，请继续往下浏览（注意：通过 clone 的对象并不会执行 构造函数！）</p><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>上述原型模式的实现实际上只是一个浅拷贝，也称为影子拷贝。这份拷贝实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912161811.png" alt></p><p>我们知道 A 引用 B 那么我们可以认为 A,B 都指向同一个地址，当修改 A 时 B 也会随之改变， B 修改时 A 也会随之改变。我们直接看下面代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 构建文档对象</span></span><br><span class="line">    WordDocument wordDocument = <span class="keyword">new</span> WordDocument();</span><br><span class="line">    <span class="comment">//2. 编辑文档</span></span><br><span class="line">    wordDocument.setmTxt(<span class="string">"今天是一个好天气"</span>);</span><br><span class="line">    wordDocument.addImagepath(<span class="string">"/sdcard/image.png"</span>);</span><br><span class="line">    wordDocument.addImagepath(<span class="string">"/sdcard/image2.png"</span>);</span><br><span class="line">    wordDocument.addImagepath(<span class="string">"/sdcard/image3.png"</span>);</span><br><span class="line">    <span class="comment">//打印文档内容</span></span><br><span class="line">    wordDocument.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"--------------------开始clone-----\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以原始文档为准，copy 副本</span></span><br><span class="line">    WordDocument cloneDoc = wordDocument.clone();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" 打印副本，看看数据  \n\n"</span>);</span><br><span class="line">    <span class="comment">//打印副本，看看数据</span></span><br><span class="line">    cloneDoc.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在副本文档上修改</span></span><br><span class="line">    cloneDoc.setmTxt(<span class="string">"副奔上修改文档：老龙王哭了"</span>);</span><br><span class="line">    cloneDoc.addImagepath(<span class="string">"/sdcard/副本发生改变"</span>);</span><br><span class="line">    System.out.println(<span class="string">"  打印修改后的副本  \n\n"</span>);</span><br><span class="line">    <span class="comment">//打印修改后的副本</span></span><br><span class="line">    cloneDoc.println();</span><br><span class="line">    System.out.println(<span class="string">"----看会不会影响原始文档-----\n\n"</span>);</span><br><span class="line">    <span class="comment">//看会不会影响原始文档？？？？？？？</span></span><br><span class="line">    wordDocument.println();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"内存地址：\nwordDocument: "</span> + wordDocument.toString() + <span class="string">"\n"</span> + <span class="string">"cloneDoc: "</span> + cloneDoc.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看副本文档，我手动调用 addImagepath 添加了一个新的图片地址。那么大家猜原始文档会发生改变吗？请看下面的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">--------------------开始clone-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 打印副本，看看数据  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">  打印修改后的副本  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 副奔上修改文档：老龙王哭了</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">path: /sdcard/副本发生改变</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">----看会不会影响原始文档-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">path: /sdcard/副本发生改变</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">内存地址：</span><br><span class="line">wordDocument: com.devyk.android_dp_code.prototype.WordDocument@48533e64</span><br><span class="line">cloneDoc: com.devyk.android_dp_code.prototype.WordDocument@64a294a6</span><br></pre></td></tr></table></figure><p>注意看我们副本添加的图片地址是不是影响了原始文档的图片地址数据，那么这是怎么回事勒？对 C++ 了解的同学应该深有体会，这是因为上文中 cloneDoc 只是进行了浅拷贝，图片列表 mImagePath 只是单纯的指向了 this.mImagePath , 并没有重新构造一个 mImagePath 对象，就像开始介绍浅/深拷贝一样， A，B 对象其实指向的是同一个地址，所以不管 A，B 中任意一个对象改了指向地址的数据那么都会随之发生改变，那如何解决这个问题？答案就是采取深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用形式，下面我们修改 clone 代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明具备 clone 能力</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> clone 的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WordDocument <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WordDocument document = (WordDocument)<span class="keyword">super</span>.clone();</span><br><span class="line">        document.mTxt = <span class="keyword">this</span>.mTxt;</span><br><span class="line">        <span class="comment">//进行深拷贝</span></span><br><span class="line">        document.mImagePath = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImagePath.clone();</span><br><span class="line">        <span class="keyword">return</span> document;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来测试一下，看输出类容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">--------------------开始clone-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 打印副本，看看数据  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">  打印修改后的副本  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 副奔上修改文档：老龙王哭了</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">path: /sdcard/副本发生改变</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">----看会不会影响原始文档-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------  start  ----------------</span><br><span class="line"></span><br><span class="line">txt: 今天是一个好天气</span><br><span class="line">mImagePath: </span><br><span class="line">path: /sdcard/image.png</span><br><span class="line">path: /sdcard/image2.png</span><br><span class="line">path: /sdcard/image3.png</span><br><span class="line">-----------------  end   ----------------</span><br><span class="line"></span><br><span class="line">内存地址：</span><br><span class="line">wordDocument: com.devyk.android_dp_code.prototype.WordDocument@48533e64</span><br><span class="line">cloneDoc: com.devyk.android_dp_code.prototype.WordDocument@64a294a6</span><br></pre></td></tr></table></figure><p>通过输出内容，深拷贝解决了上述问题。</p><p>原型模式是一个非常简单的一个模式，它的核心问题就是对原始对象进行拷贝，在这个模式的使用过程中需要注意一点就是 深/浅拷贝的问题。在实际开发中，为了减少不必要的麻烦，建议大家都使用深拷贝。</p><p><a href="https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1" target="_blank" rel="noopener">这里如果对深浅拷贝感兴趣的话可以看掘金上这篇文章，不过是 JS 代码(了解原理就可以了)，很火的一篇文章值得学习一下</a></p><h2 id="源码中的原型模式"><a href="#源码中的原型模式" class="headerlink" title="源码中的原型模式"></a>源码中的原型模式</h2><ul><li><p>ArrayList</p><p>刚刚我们 clone 文档可知，进行的 ArrayList clone ，那么 ArrayList clone 具体是怎么实现的？我们一起来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1. </span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">      <span class="comment">//2. </span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中第一步首先进行自身的 clone ,然后在对自身的数据进行 copy .</p></li><li><p>Intent</p><p>下面以 Intent 来分析源码中的原型模式，首先看如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">toSMS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"smsto:11202"</span>);</span><br><span class="line">  </span><br><span class="line">    Intent preIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO,uri);</span><br><span class="line">    preIntent.putExtra(<span class="string">"sms_body"</span>,<span class="string">"test"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//clone</span></span><br><span class="line">    <span class="keyword">return</span> (Intent) preIntent.clone();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912161940.png" alt></p></li></ul><p>  从代码中可以看到 preIntent.clone(); 方法拷贝了一个对象 Intent ,然后执行跳转 Activity,跳转的内容与原型数据一致。</p><p>  我们继续看 Intent clone 具体实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***进行 clone **/</span>  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Copy constructor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Intent</span><span class="params">(Intent o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mAction = o.mAction;</span><br><span class="line">      <span class="keyword">this</span>.mData = o.mData;</span><br><span class="line">      <span class="keyword">this</span>.mType = o.mType;</span><br><span class="line">      <span class="keyword">this</span>.mPackage = o.mPackage;</span><br><span class="line">      <span class="keyword">this</span>.mComponent = o.mComponent;</span><br><span class="line">      <span class="keyword">this</span>.mFlags = o.mFlags;</span><br><span class="line">      <span class="keyword">this</span>.mContentUserHint = o.mContentUserHint;</span><br><span class="line">      <span class="keyword">this</span>.mLaunchToken = o.mLaunchToken;</span><br><span class="line">      <span class="keyword">if</span> (o.mCategories != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mCategories = <span class="keyword">new</span> ArraySet&lt;String&gt;(o.mCategories);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o.mExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mExtras = <span class="keyword">new</span> Bundle(o.mExtras);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o.mSourceBounds != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mSourceBounds = <span class="keyword">new</span> Rect(o.mSourceBounds);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o.mSelector != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mSelector = <span class="keyword">new</span> Intent(o.mSelector);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o.mClipData != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mClipData = <span class="keyword">new</span> ClipData(o.mClipData);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  可以看到 clone 方法实际上在内部并没有调用 super.clone() 来实现拷贝对象，而是通过 new Intent(this)。 在开始我们提到过，使用 clone 和 new 需要根据构造对象的成本来决定，如果对象的构造成本比较高或者构造麻烦，那么使用 clone 函数效率较高，反之可以使用 new 关键字的形式。这就是和 C++ 中的 copy 构造函数完全一致，将原始对象作为构造函数的参数，然后在构造函数内将原始对象数据挨个 copy , 到此，整个 clone 过程就完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原型模式本质就是对象 copy ,与 C++ 中的拷贝构造函数相似，他们之前容易出现的问题也都是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建爱你对象的效率。还有一个重要的用途，就是保护性拷贝，也就是某个对象对外可能只是只读模式。</p><p>优点：</p><p>原型模式是在内存中二进制流的 copy, 要比 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</p><p>缺点：</p><p>这既是它的有点也是缺点，直接在内存中拷贝，构造函数时不会执行的，在实际开发中应该注意这个潜在的问题。</p><h1 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h1><p><a href="https://item.jd.com/12113187.html" target="_blank" rel="noopener">《 Android 源码设计模式解析与实战 》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习原型模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;原型模式是一个创建型的模式。原型二字表明了该模式应该有一个模板实例，用户从这个模板对象中复制出一个内部属性一致并且内存地址不同的对象，这个过程也就是我们俗称的 “克隆” 。被复制的实例就是我们所称的 “原型” ，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型复制避免这些消耗。&lt;/li&gt;
&lt;li&gt;通过 new 产生一个对象需要非常繁琐的数据准备和访问权限，这时可以使用原型模式。&lt;/li&gt;
&lt;li&gt;一个对象需要提供给其它对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式复制多个对象供调用者使用，既保护性拷贝。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;UML-类图&quot;&gt;&lt;a href=&quot;#UML-类图&quot; class=&quot;headerlink&quot; title=&quot;UML 类图&quot;&gt;&lt;/a&gt;UML 类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912161545.png&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client: 客户端用户。&lt;/li&gt;
&lt;li&gt;Prototype: 抽象类或者接口，声明具备 clone 能力。&lt;/li&gt;
&lt;li&gt;ConcreatePrototype: 具体的原型类&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="原型模式" scheme="https://zhangmiao.cc/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式二之建造者模式</title>
    <link href="https://zhangmiao.cc/posts/8bd761ec.html"/>
    <id>https://zhangmiao.cc/posts/8bd761ec.html</id>
    <published>2019-09-12T08:08:56.000Z</published>
    <updated>2019-09-13T06:52:14.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习建造者模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Builder 模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细的控制对象的构造流程，该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和创建过程隔离开来。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时。</li><li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。</li></ol><h2 id="简单代码示例"><a href="#简单代码示例" class="headerlink" title="简单代码示例"></a>简单代码示例</h2><p>这里比如我们第一次初始化应用的时候，需要初始化一些事物，比如默认记住密码，自动登录，开机登录，崩溃重启等等。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devyk.android_dp_code.builder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     author  : devyk on 2019-09-01 16:48</span></span><br><span class="line"><span class="comment"> *     blog    : https://juejin.im/user/578259398ac2470061f3a3fb/posts</span></span><br><span class="line"><span class="comment"> *     github  : https://github.com/yangkun19921001</span></span><br><span class="line"><span class="comment"> *     mailbox : yang1001yk@gmail.com</span></span><br><span class="line"><span class="comment"> *     desc    : This is LoginManager</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记住密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isSavePwd;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动登录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAutoLogin;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开机自启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBootLauncher;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 崩溃重启</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isCrashOnRestart;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginManager</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isAutoLogin = builder.isAutoLogin;</span><br><span class="line">        <span class="keyword">this</span>.isBootLauncher = builder.isBootLauncher;</span><br><span class="line">        <span class="keyword">this</span>.isCrashOnRestart = builder.isCrashOnRestart;</span><br><span class="line">        <span class="keyword">this</span>.isSavePwd = builder.isSavePwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 记住密码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">boolean</span> isSavePwd;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自动登录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">boolean</span> isAutoLogin;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开机自启动</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">boolean</span> isBootLauncher;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 崩溃重启</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">boolean</span> isCrashOnRestart;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//默认属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isSavePwd = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.isAutoLogin = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.isBootLauncher = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.isCrashOnRestart = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">isSavePwd</span><span class="params">(<span class="keyword">boolean</span> savePwd)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isSavePwd = savePwd;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">isAutoLogin</span><span class="params">(<span class="keyword">boolean</span> autoLogin)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isAutoLogin = autoLogin;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">isBootLauncher</span><span class="params">(<span class="keyword">boolean</span> bootLauncher)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isBootLauncher = bootLauncher;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">isCrashOnRestart</span><span class="params">(<span class="keyword">boolean</span> onReStartApp)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isCrashOnRestart = onReStartApp;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后构建出来</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LoginManager <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoginManager(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接链式调用</span></span><br><span class="line">        LoginManager loginManager = <span class="keyword">new</span> LoginManager.Builder()</span><br><span class="line">                .isAutoLogin(<span class="keyword">true</span>)</span><br><span class="line">                .isBootLauncher(<span class="keyword">true</span>)</span><br><span class="line">                .isCrashOnRestart(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"loginManager:"</span>+loginManager.toString());</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginManager:LoginManager&#123;isSavePwd=<span class="keyword">false</span>, isAutoLogin=<span class="keyword">true</span>, isBootLauncher=<span class="keyword">true</span>, isCrashOnRestart=<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，通过具体的 Builder 类来具体构建 LoginManager 需要的属性，最后通过链式调用，结构变得更加清晰，更加容易控制。</p><h2 id="Android-源码中-AlertDialog-的-Builder-模式全面解析"><a href="#Android-源码中-AlertDialog-的-Builder-模式全面解析" class="headerlink" title="Android 源码中 AlertDialog 的 Builder 模式全面解析"></a>Android 源码中 AlertDialog 的 Builder 模式全面解析</h2><p>在 Android 源码中，最常用之一的 Builder 模式 AlertDialog.Builder, 通过 Builder 来构建复杂的 AlertDialog 对象。请先看它的使用方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showAlertDialog</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> AlertDialog.Builder(context)<span class="comment">// 以下通过 Builder 链式调用构造数据</span></span><br><span class="line">            .setIcon(R.drawable.ic_launcher_background)</span><br><span class="line">            .setMessage(<span class="string">"测试数据"</span>)</span><br><span class="line">            .setTitle(<span class="string">"提示"</span>)</span><br><span class="line">            .setPositiveButton(<span class="string">"取消"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).setNegativeButton(<span class="string">"确认"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).create()<span class="comment">//最后一步就是在 Builder 中构建出 AlerDialog 对象，并初始化数据</span></span><br><span class="line">            .show(); <span class="comment">// 显示</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 AlertDialog.Builder(context) 可以看出 AlertDialog 是一个 Builder 建造者模式，通过 Builder 对象，组装 Dialog 的各个部分，将 Dialog 的构造和表示进行分离。下面请看 AlertDialog Builder 的相关源码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.android.internal.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertDialog</span> <span class="keyword">extends</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Builder成员变量 P 中的各个参数</span></span><br><span class="line">    <span class="keyword">private</span> AlertController mAlert;</span><br><span class="line"></span><br><span class="line"> ....代码省略</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AlertDialog</span><span class="params">(Context context, <span class="keyword">boolean</span> cancelable, OnCancelListener cancelListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        setCancelable(cancelable);</span><br><span class="line">        setOnCancelListener(cancelListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AlertDialog</span><span class="params">(Context context, @StyleRes <span class="keyword">int</span> themeResId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, themeResId, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 AlertDialog</span></span><br><span class="line">    AlertDialog(Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : <span class="number">0</span>,</span><br><span class="line">                createContextThemeWrapper);</span><br><span class="line"></span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert = AlertController.create(getContext(), <span class="keyword">this</span>, getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="meta">@StyleRes</span> <span class="function"><span class="keyword">int</span> <span class="title">resolveDialogTheme</span><span class="params">(Context context, @StyleRes <span class="keyword">int</span> themeResId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (themeResId == THEME_TRADITIONAL) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.style.Theme_Dialog_Alert;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (themeResId == THEME_HOLO_DARK) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.style.Theme_Holo_Dialog_Alert;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (themeResId == THEME_HOLO_LIGHT) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.style.Theme_Holo_Light_Dialog_Alert;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (themeResId == THEME_DEVICE_DEFAULT_DARK) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.style.Theme_DeviceDefault_Dialog_Alert;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (themeResId == THEME_DEVICE_DEFAULT_LIGHT) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.style.Theme_DeviceDefault_Light_Dialog_Alert;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ResourceId.isValid(themeResId)) &#123;</span><br><span class="line">            <span class="comment">// start of real resource IDs.</span></span><br><span class="line">            <span class="keyword">return</span> themeResId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            context.getTheme().resolveAttribute(R.attr.alertDialogTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> outValue.resourceId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//实际上调用的是 mAlert 的 setTitle 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setTitle(title);</span><br><span class="line">        mAlert.setTitle(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Builder#setCustomTitle(View)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   //实际上调用的是 mAlert 的 setCustomTitle 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomTitle</span><span class="params">(View customTitleView)</span> </span>&#123;</span><br><span class="line">        mAlert.setCustomTitle(customTitleView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际上调用的 mAlert 的 setMessage 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">        mAlert.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    ################################ BUilder 为 AlertDialog 构建的内部类 ##############################################</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储 AlertDialog 的各个参数，如果 title,message,icon</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(context, resolveDialogTheme(context, ResourceId.ID_NULL));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context, <span class="keyword">int</span> themeResId)</span> </span>&#123;</span><br><span class="line">            P = <span class="keyword">new</span> AlertController.AlertParams(<span class="keyword">new</span> ContextThemeWrapper(</span><br><span class="line">                    context, resolveDialogTheme(context, themeResId)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  设置标签头部提示</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(@StringRes <span class="keyword">int</span> titleId)</span> </span>&#123;</span><br><span class="line">            P.mTitle = P.mContext.getText(titleId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ..... 其它属性先省略 代码都大同小异 看懂一个就基本懂了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates an &#123;<span class="doctag">@link</span> AlertDialog&#125; with the arguments supplied to this</span></span><br><span class="line"><span class="comment">         * builder.</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 这里才是真正构建 AlertDialog 的地方，通过 Builder 来构建出来的数据 p 传递参数</span></span><br><span class="line"><span class="comment">         * &lt;p&gt; </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AlertDialog <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//实例化 AlertDialog 传参</span></span><br><span class="line">            <span class="keyword">final</span> AlertDialog dialog = <span class="keyword">new</span> AlertDialog(P.mContext, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将 p 中的参数应用到 dialog 中的 mAlert 对象中</span></span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            <span class="keyword">if</span> (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</span><br><span class="line">            <span class="keyword">if</span> (P.mOnKeyListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dialog;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，Builder 类可以设置 AlertDialog 中的 title , message , buttom 等参数，这些参数都存储在 Builder 成员变量 p 中，p 中包含了与 AlertDialog 视图中对应的成员变量。在调用 Builder 类的 create 函数时，此时才真正的创建 AlertDialog,并且将 Builder p 保存的参数交于 AlertDialog mAlert 对象中，既 p.apply(mAlert);我们可以看下 apply 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(AlertController dialog)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (mCustomTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">               dialog.setCustomTitle(mCustomTitleView);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   dialog.setTitle(mTitle);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (mIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   dialog.setIcon(mIcon);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (mIconId != <span class="number">0</span>) &#123;</span><br><span class="line">                   dialog.setIcon(mIconId);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (mIconAttrId != <span class="number">0</span>) &#123;</span><br><span class="line">                   dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//赋值</span></span><br><span class="line">           <span class="keyword">if</span> (mMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">               dialog.setMessage(mMessage);</span><br><span class="line">           &#125;</span><br><span class="line">         </span><br><span class="line">....</span><br><span class="line">  </span><br><span class="line">           <span class="comment">// 如果设置了 ListView 则表示多选列表，此时创建一个 ListView</span></span><br><span class="line">           <span class="keyword">if</span> ((mItems != <span class="keyword">null</span>) || (mCursor != <span class="keyword">null</span>) || (mAdapter != <span class="keyword">null</span>)) &#123;</span><br><span class="line">               createListView(dialog);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//最后将 mView Dialog 中</span></span><br><span class="line">           <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mViewSpacingSpecified) &#123;</span><br><span class="line">                   dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,</span><br><span class="line">                           mViewSpacingBottom);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   dialog.setView(mView);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mViewLayoutResId != <span class="number">0</span>) &#123;</span><br><span class="line">               dialog.setView(mViewLayoutResId);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>在 apply 函数中，只是将 AlertParams 参数设置到 AlertControler 中，当我们调用 show 就能显示对话框了，我们具体来看下 show 的源码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始显示 Dialog </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果已经显示出来了 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (mShowing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCanceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. onCreate 生命周期方法</span></span><br><span class="line">    <span class="keyword">if</span> (!mCreated) &#123;</span><br><span class="line">        dispatchOnCreate(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">        mWindow.getDecorView().dispatchConfigurationChanged(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. onStart 生命周期方法</span></span><br><span class="line">    onStart();</span><br><span class="line">    <span class="comment">//3. 获取 Window DecorView</span></span><br><span class="line">    mDecor = mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span> &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">        <span class="keyword">final</span> ApplicationInfo info = mContext.getApplicationInfo();</span><br><span class="line">        mWindow.setDefaultIcon(info.icon);</span><br><span class="line">        mWindow.setDefaultLogo(info.logo);</span><br><span class="line">        mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 获取布局参数</span></span><br><span class="line">    WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class="line">    <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">            &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == <span class="number">0</span>) &#123;</span><br><span class="line">        WindowManager.LayoutParams nl = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        nl.copyFrom(l);</span><br><span class="line">        nl.softInputMode |=</span><br><span class="line">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">        l = nl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 将 mDecor 添加到 WindowManager 中</span></span><br><span class="line">    mWindowManager.addView(mDecor, l);</span><br><span class="line">    mShowing = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知可以显示了</span></span><br><span class="line">    sendShowMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 show() 中主要做了如下几个事儿：</p><ol><li>通过dispatchOnCreate 函数调用 AlertDialog 生命周期 onCreate 函数；</li><li>然后在调用 onStart</li><li>最后通过 windowManager 把 Dialog 的 DecorView 添加进去</li></ol><p>那么按照构建，内容视图应该是在生命周期的 onCreate 里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mAlert.installContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> contentView = selectContentView();</span><br><span class="line">        <span class="comment">//设置框口内容视图</span></span><br><span class="line">        mWindow.setContentView(contentView);</span><br><span class="line">        <span class="comment">//初始化 AlertDialog 其它子视图的内容</span></span><br><span class="line">        setupView();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>虽然 installContent 代码少，但是及其重要，它调用了 Window 对象的 setContentView, 此处的 setContentView 与 Activity setContentView 中的实现一模一样，都是调用 window 的方法。</p><p>最后 setupView 就是初始化 AlertDialog 布局中各个参数，在调用完该函数之后 Dialog 的视图内容就全部显示完毕了，而这些各区域的视图都属于 mAlertDialogLayout 布局中的子 View ,Window 对象关联了mAlertDialogLayout 的整个布局树，当调用完 setupView 之后整个视图树的数据也就填充完毕，当用户调用 show 函数时， WindowManager 会将 window 对象的 DecorView (也就是 mAlertDialogLayout 对应的视图)添加到用户的窗口上，并且显示出来。到这里 Dialog 就出现在了手机屏幕中。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>经过简单示例与分析源码中的 Builder 模式，相信大家对建造者模式已经有了一定了解了，现在我们就 Builder 模式来对<a href="https://zhangmiao.cc/posts/6a4629d8.html">ImageLoader 示例</a> 改造。请看改造后的 ImageLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加了 Builder 配置类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     author  : devyk on 2019-09-01 19:03</span></span><br><span class="line"><span class="comment"> *     blog    : https://juejin.im/user/578259398ac2470061f3a3fb/posts</span></span><br><span class="line"><span class="comment"> *     github  : https://github.com/yangkun19921001</span></span><br><span class="line"><span class="comment"> *     mailbox : yang1001yk@gmail.com</span></span><br><span class="line"><span class="comment"> *     desc    : This is ImageLoaderConfig</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoaderConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片缓存对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IImageCache imageCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许最大线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> threadCount = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败显示的图片配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> errorIcon = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IDownloader downloader = <span class="keyword">new</span> HttpURLConnectionDownloaderImp();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ImageLoaderConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 Builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 图片缓存对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IImageCache imageCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 允许最大线程数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> threadCount = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 失败显示的图片配置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> errorIcon = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 图片下载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IDownloader downloader = <span class="keyword">new</span> HttpURLConnectionDownloaderImp();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置线程数量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setThreadCount</span><span class="params">(<span class="keyword">int</span> threadCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.threadCount = threadCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置缓存</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setCache</span><span class="params">(IImageCache iImageCache)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.imageCache = iImageCache;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图片下载</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setDownLoader</span><span class="params">(IDownloader iDownloader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.downloader = iDownloader;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置显示失败的图片</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setLoaderErrorIcon</span><span class="params">(<span class="keyword">int</span> icon)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.errorIcon = icon;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyConfig</span><span class="params">(ImageLoaderConfig config)</span> </span>&#123;</span><br><span class="line">            config.errorIcon = <span class="keyword">this</span>.errorIcon;</span><br><span class="line">            config.imageCache = <span class="keyword">this</span>.imageCache;</span><br><span class="line">            config.threadCount = <span class="keyword">this</span>.threadCount;</span><br><span class="line">            config.downloader = <span class="keyword">this</span>.downloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据已经设置好的属性创建配置好对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ImageLoaderConfig <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ImageLoaderConfig config = <span class="keyword">new</span> ImageLoaderConfig();</span><br><span class="line">            applyConfig(config);</span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看到 ImageLoader 需要的业务，都可以在 ImageLoaderConfig Builder 配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     author  : devyk on 2019-08-27 00:11</span></span><br><span class="line"><span class="comment"> *     blog    : https://juejin.im/user/578259398ac2470061f3a3fb/posts</span></span><br><span class="line"><span class="comment"> *     github  : https://github.com/yangkun19921001</span></span><br><span class="line"><span class="comment"> *     mailbox : yang1001yk@gmail.com</span></span><br><span class="line"><span class="comment"> *     desc    : This is ImageLoader</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认内存缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IImageCache mCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IDownloader mImageDownloader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService mExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示失败的图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mErrorIcon ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImageLoader instance;</span><br><span class="line">    <span class="keyword">private</span> ImageLoaderConfig imageLoaderConfig;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> ImageLoader();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ImageLoaderConfig imageLoaderConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imageLoaderConfig = imageLoaderConfig;</span><br><span class="line">        checkConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageLoaderConfig == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (imageLoaderConfig.imageCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//图片缓存</span></span><br><span class="line">            <span class="keyword">this</span>.mCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCache = imageLoaderConfig.imageCache;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (imageLoaderConfig.threadCount != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//线程池，线程数据量为 CPU 的数量</span></span><br><span class="line">            <span class="keyword">this</span>.mExecutorService = Executors.newFixedThreadPool(imageLoaderConfig.threadCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (imageLoaderConfig.errorIcon != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">this</span>.mErrorIcon = imageLoaderConfig.errorIcon;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图片下载</span></span><br><span class="line">        <span class="keyword">this</span>.mImageDownloader = imageLoaderConfig.downloader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = mCache.get(url);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            imageView.setImageBitmap(bitmap);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageView.setTag(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果内存缓存中没有图片，就开启网络请求去下载</span></span><br><span class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Bitmap imager = mImageDownloader.downLoader(url);</span><br><span class="line">                <span class="keyword">if</span> (imager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (imageView.getTag().equals(url)) &#123;</span><br><span class="line">                    displayImage(imager, imageView);</span><br><span class="line">                &#125;</span><br><span class="line">                mCache.put(url, imager);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downBitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> Bitmap downBitmap, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"下载图片"</span>);</span><br><span class="line">                imageView.setImageBitmap(downBitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ImageLoaderConfig config = <span class="keyword">new</span> ImageLoaderConfig.Builder()</span><br><span class="line">            .setCache(<span class="keyword">new</span> DoubleCache(getApplicationContext()))</span><br><span class="line">            .setLoaderErrorIcon(R.drawable.ic_launcher_background)</span><br><span class="line">            .setThreadCount(<span class="number">10</span>)</span><br><span class="line">            .setDownLoader(<span class="keyword">new</span> HttpURLConnectionDownloaderImp())</span><br><span class="line">            .create();</span><br><span class="line">    ImageLoader.getInstance().init(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过配置之后就可以正常使用了，各种 setter 函数不会再用户调用 ImageLoader 方法时出现在视野中，它已经被隔离到了 Builder 模式中。清晰、简单的 API 也是一个开源库必须要保证的地方。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Builder 模式在 Android 源码，开源库（Okhttp…）等常用，将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的 setter,Builder 模式比较常见的实现形式就是链式调用，这样使得代码更加简洁，易懂。</p><p>优点：</p><ol><li>良好的封装性，使用建造者模式可以是客服端不必知道产品内部组成细节。</li><li>独立，易扩展。</li></ol><p>缺点：</p><ol><li>会产生多余的 Builder 对象，消耗内存。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习建造者模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Builder 模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细的控制对象的构造流程，该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和创建过程隔离开来。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;相同的方法，不同的执行顺序，产生不同的事件结果时。&lt;/li&gt;
&lt;li&gt;当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;简单代码示例&quot;&gt;&lt;a href=&quot;#简单代码示例&quot; class=&quot;headerlink&quot; title=&quot;简单代码示例&quot;&gt;&lt;/a&gt;简单代码示例&lt;/h2&gt;&lt;p&gt;这里比如我们第一次初始化应用的时候，需要初始化一些事物，比如默认记住密码，自动登录，开机登录，崩溃重启等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="https://zhangmiao.cc/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式一之单列模式</title>
    <link href="https://zhangmiao.cc/posts/ed2ac199.html"/>
    <id>https://zhangmiao.cc/posts/ed2ac199.html</id>
    <published>2019-09-12T07:48:29.000Z</published>
    <updated>2019-09-13T06:52:09.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过理论,代码示例,Android源码来学习单列模式</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例模式是应用最为广泛的模式之一，也可能是很多入门或初级工程师唯一会使用的设计模式之吧，在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个实例类。有利于我们的调用，避免一个相同的类重复创建实例，比如一个网络请求，图片请求/下载，数据库操作等，如果频繁创建同一个相同对象的话，很消耗资源，因此，没有理由让它们构造多个实例。全局都需要使用这个功能的时候，避免重复创建，就可以用单例，这就是单例使用场景。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>应用中重复使用某个类时，为了避免多次创建产生的资源消耗，那么这个时候就可以考虑使用单例设计模式。</p><h2 id="单例-UML-类图"><a href="#单例-UML-类图" class="headerlink" title="单例 UML 类图"></a>单例 UML 类图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912155055.png" alt></p><p>实现单例模式主要有如下几个关键点:</p><ol><li>构造函数不对外开放，一般为 private;</li><li>通过一个静态方法或者枚举返回单例对象；</li><li>确保单例类的对象有且只有一个，尤其是在多线程环境下；</li><li>确保单例类对象在反序列化时不会被重新构建对象。</li></ol><a id="more"></a><h2 id="单例示例"><a href="#单例示例" class="headerlink" title="单例示例"></a>单例示例</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>单例模式是设计模式中比较简单的，只有一个单例类，没有其他层次结构与抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗较多的资源或者没有多个实例的情况。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 饿汉式单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DaoManager instance = <span class="keyword">new</span> DaoManager();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DaoManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DaoManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String dao = DaoManager.getInstance().toString();</span><br><span class="line">    String dao1 = DaoManager.getInstance().toString();</span><br><span class="line">    String dao2 = DaoManager.getInstance().toString();</span><br><span class="line">    String dao3 = DaoManager.getInstance().toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(dao);</span><br><span class="line">    System.out.println(dao1);</span><br><span class="line">    System.out.println(dao2);</span><br><span class="line">    System.out.println(dao3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.devyk.android_dp_code.singleton.DaoManager@<span class="number">28</span>ba21f3</span><br><span class="line">com.devyk.android_dp_code.singleton.DaoManager@<span class="number">28</span>ba21f3</span><br><span class="line">com.devyk.android_dp_code.singleton.DaoManager@<span class="number">28</span>ba21f3</span><br><span class="line">com.devyk.android_dp_code.singleton.DaoManager@<span class="number">28</span>ba21f3</span><br></pre></td></tr></table></figure><p>从上面代码可以看到 DaoManager 不能通过 new 的形式构造对象，只能通过 getInstance() 拿到实例，而 DaoManager 对象是静态的，那么在声明的时候已经初始化了，这就保证了对象的唯一性，从输入结果中发现， DaoManager 四次输出的地址都是一样的。这个实现的核心在与将 DaoManager 类的构造方法私有化，使得外部程序不能通过构造来 new 对象，只能通过 getInstance() 来返回一个对象。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>懒汉模式是声明了一个静态对象，并且在第一调用的时候进行初始化，而上面的饿汉纸则是在声明的时候已经初始化了。懒汉式的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoManager2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DaoManager2 instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DaoManager2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证线程安全的懒汉式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> DaoManager2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> DaoManager2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者可能已经发现了，getInstance() 方法中添加了 <code>synchronized</code> 关键字， getInstance 是一个同步方法，保证了在多线程情况下单例对象唯一性。细想下，大家可能会发现一个问题，即使 instance 已经被初始化，每次调用都会进行同步检查，这样会消耗不必要的资源，这也是懒汉单例模式存在的最大问题。</p><p>最后总结一下，懒汉单例模式的优点是单例只有再使用的时候进行初始化，在一定程度上节约了资源；缺点是第一次加载时需要进行初始化，反应稍慢，最大的问题就是每次调用的时候 getInstance 都进行同步，造成不必要的开销。这种模式一般不建议使用。</p><h3 id="Double-Check-Lock-实现单例"><a href="#Double-Check-Lock-实现单例" class="headerlink" title="Double Check Lock 实现单例"></a>Double Check Lock 实现单例</h3><p>DCL 方式实现单例模式的有点是既能够在需要时初始化单例，又能保证线程安全，且单例对象初始化后调用 instance 不进行同步锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoManager3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DaoManager3 sinstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DaoManager3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证线程安全的懒汉式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DaoManager3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == sinstance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DaoManager3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">                    sinstance = <span class="keyword">new</span> DaoManager3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sinstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本段代码的亮点就在于 getInstance 方法上，可以看到 getInstance 方法对 instance 进行了两次判空；第一层判断主要是为了避免不必要的同步，第二层的判断则是为了在 null 的情况下创建实例。是不是看起来有点迷糊，下面在来解释下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinstance = <span class="keyword">new</span> DaoManager3();</span><br></pre></td></tr></table></figure><p>这个步骤，其实在jvm里面的执行分为三步：</p><ol><li>在堆内存开辟内存空间;</li><li>在堆内存中实例化 DaoManager3 里面的各个参数;</li><li>把对象指向堆内存空间;</li></ol><p>由于在 JDK 1.5 以前 Java 编译器允许处理器乱序执行，以及 JMM 无法保证 Cache, 寄存器（Java 内存模型）保证按照 1，2，3 的顺序执行。所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，sinstance 已经非空了，会被直接拿出来用，这样的话，就会出现异常。而且不易复现不易跟踪是一个隐藏的 BUG。</p><p>不过在 JDK 1.5 之后，官方也发现了这个问题，故而具体化了 volatile ，即在 JDK 1.6 以后，只要定义为 private volatile static DaoManager3 sinstance ; 就可解决 DCL 失效问题。volatile 确保 sinstance 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p><p>DCL 优点：资源利用率高，第一次执行 getInstance 时单例对象才会被实例化，效率高。</p><p>DCL 缺点：第一次加载时，反应稍慢，也由于 Java 内存模型的原因偶尔会失败。在高并发环境下也有一定的缺陷，虽然发生概率很小。</p><p>DCL 模式是使用最多的模式，它能够在需要时才被实例化，并且能够在绝大多数场景下保证单例对象的唯一性，除非你的代码在并发场景比较复杂或者低于 JDK 6 版本下使用，否则，这种方式一般能够满足需求。</p><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>DCL 虽然在一定程度上解决了资源消耗、多余的同步、线程安全等问题，但是，它还是在某些情况下出现失效的问题，这个问题被称为双重检查锁定失效，在《Java 并发编程实践》一书的最后谈到了这个问题，并指出这种 “优化” 是丑陋的，不赞成使用。而建议使用如下的代码替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoManager4</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DaoManager4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DaoManager4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DaoManager4Holder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoManager4Holder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DaoManager4 sInstance = <span class="keyword">new</span> DaoManager4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。</p><p>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p><ol><li>遇到 new、getstatic、setstatic 或者 invokestatic 这4个字节码指令时，对应的 java 代码场景为：new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时 ( final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li><li>当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。</li><li>当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</li></ol><p>我们再回头看下 getInstance() 方法，调用的是 DaoManager4Holder.sInstance ，取的是DaoManager4Holder 里的 sInstance 对象，跟上面那个 DCL 方法不同的是 ，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance() 方法，取的都是同一个sInstance 对象，而不用去重新创建。当 getInstance() 方法被调用时，DaoManager4Holder 才在 DaoManager4 的运行时常量池里，把符号引用替换为直接引用，这时静态对象sInstance 也真正被创建，然后再被 getInstance() 方法返回出去，这点同饿汉模式。那么sInstance 在创建过程中又是如何保证线程安全的呢？在《深入理解JAVA虚拟机》中，有这么一句话:</p><p>虚拟机会保证一个类的 () 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 () 方法，其他线程都需要阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时很长的操作，就可能造成多个进程阻塞 (需要注意的是，其他线程虽然会被阻塞，但如果执行 () 方法后，其他线程唤醒之后不会再次进入 () 方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p><p>故而，可以看出 sInstance 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p><p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>前面讲解了几个单例模式的实现方式，这几个实现方式不是稍显麻烦就是会在某种情况下出现问题，那么还有没有更简单的实现方式勒？  我们先来看看下面的实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  DaoManager5 &#123;</span><br><span class="line">    </span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.i(<span class="string">"DAO-&gt;"</span>,<span class="string">"枚举单例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就是枚举单例！</p><p>写法简单简单是枚举单例最大的优点，枚举在 Java 中与普通的类时一样的，不仅能够拥有字段，还能够拥有自己的方法。最重要的是默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。</p><p>优点：枚举本身是线程安全的，且能防止通过反射和反序列化创建实例。</p><p>缺点：对 JDK 版本有限制要求，非懒加载。</p><h3 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h3><p>学习了上面 5 大单例模式，最后在来介绍一种容器单例模式，请看下面代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoManager6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; singletonMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DaoManager6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDao</span><span class="params">(String key,Object instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!singletonMap.containsKey(key))&#123;</span><br><span class="line">            singletonMap.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getDao</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的初始，可以将单例类型注入到统一管理类中，在使用的时候根据 key 获取对应单例对象，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p><h2 id="Android-源码中单例模式"><a href="#Android-源码中单例模式" class="headerlink" title="Android 源码中单例模式"></a>Android 源码中单例模式</h2><p>Android 源码中涉及了大量的单例模式，这里就拿较为熟悉的 context.getSystemService(String name); 容器单例模式，以 Context.LAYOUT_INFLATER_SERVICE 举例。</p><p><a href="https://zhangmiao.cc/posts/61266016.html">从 setContentView 入口，全方位分析 LayoutInflater</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式在应用中时属于使用频率最高的一种设计模式了，但是由于客户端通常没有高并发的情况，因此，选择哪种实现方式并不会有太大的影响。当然，考虑效率和并发的场景还是推荐大家使用 DCL 或 静态内部类单例模式。</p><p>注意：如果单例对象必须持有参数的话，那么最好建议使用弱引用来接收参数，如果是 Context 级别的类型，建议使用 context.getApplication() 否则容易造成内存泄漏;</p><p>感谢你的阅读，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过理论,代码示例,Android源码来学习单列模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;单例模式是应用最为广泛的模式之一，也可能是很多入门或初级工程师唯一会使用的设计模式之吧，在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个实例类。有利于我们的调用，避免一个相同的类重复创建实例，比如一个网络请求，图片请求/下载，数据库操作等，如果频繁创建同一个相同对象的话，很消耗资源，因此，没有理由让它们构造多个实例。全局都需要使用这个功能的时候，避免重复创建，就可以用单例，这就是单例使用场景。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;应用中重复使用某个类时，为了避免多次创建产生的资源消耗，那么这个时候就可以考虑使用单例设计模式。&lt;/p&gt;
&lt;h2 id=&quot;单例-UML-类图&quot;&gt;&lt;a href=&quot;#单例-UML-类图&quot; class=&quot;headerlink&quot; title=&quot;单例 UML 类图&quot;&gt;&lt;/a&gt;单例 UML 类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912155055.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;实现单例模式主要有如下几个关键点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造函数不对外开放，一般为 private;&lt;/li&gt;
&lt;li&gt;通过一个静态方法或者枚举返回单例对象；&lt;/li&gt;
&lt;li&gt;确保单例类的对象有且只有一个，尤其是在多线程环境下；&lt;/li&gt;
&lt;li&gt;确保单例类对象在反序列化时不会被重新构建对象。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单列模式" scheme="https://zhangmiao.cc/tags/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>通过代码示例来学习面向对象六大原则</title>
    <link href="https://zhangmiao.cc/posts/6a4629d8.html"/>
    <id>https://zhangmiao.cc/posts/6a4629d8.html</id>
    <published>2019-09-12T07:18:36.000Z</published>
    <updated>2019-09-12T08:15:16.497Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读 Android 系统底层源码或者开源框架源码时，发现内部大量的设计模式，如果你对设计模式不懂的话，那么阅读源码真的是寸步难行。那么这篇文章我们先来学习面向对象的六大原则，设计模式大概 23 种，后面我们一步一步来学习它。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则的英文名称是 Single Responsibility Principle ，缩写是 SRP 。 SRP 的定义是：<strong>就一个类而言，应该仅有一个引起变化的原因</strong>。简单的来说，就是一个类中应该是一组相关性很高的函数、数据的封装。单一职责的划分界限也并不是那么的清晰，很多时候都是靠个人经验来给定界限，当然，最大的的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。</p><p>下面我们就以 <strong>图片加载库</strong> 的例子代码来对类的职责简单说明下，在设计一个图片加载库之前，我们需要先大概画下 UML 类图，有了 UML 图之后写代码就能更加的清晰。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912152536.png" alt></p><a id="more"></a><p>从上面 UML 类图可以看出 ImageLoader 只负责加载图片，MemoryCache 实现 IImageCache 负责往内存中存/取缓存，到这里也许有的同学对单一职责有了一定概念了，相信看完下面的代码，你已经对单一职责掌握的差不多了，直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IImageCache mMemoryCache;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IDownloader mImageDownloader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService mExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImageLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> ImageLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//图片缓存</span></span><br><span class="line">       <span class="keyword">this</span>. mMemoryCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line">       <span class="comment">//图片下载</span></span><br><span class="line">       <span class="keyword">this</span>.mImageDownloader = <span class="keyword">new</span> HttpURLConnectionDownloaderImp();</span><br><span class="line">        <span class="comment">//线程池，线程数据量为 CPU 的数量</span></span><br><span class="line">       <span class="keyword">this</span>.mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = mMemoryCache.get(url);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            imageView.setImageBitmap(bitmap);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageView.setTag(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果内存缓存中没有图片，就开启网络请求去下载</span></span><br><span class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Bitmap imager = mImageDownloader.downLoader(url);</span><br><span class="line">                <span class="keyword">if</span> (imager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (imageView.getTag().equals(url)) &#123;</span><br><span class="line">                    displayImage(imager, imageView);</span><br><span class="line">                &#125;</span><br><span class="line">                mMemoryCache.put(url,imager);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downBitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> Bitmap downBitmap, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                imageView.setImageBitmap(downBitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> <span class="keyword">implements</span> <span class="title">IImageCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化内存缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryLru;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentMaxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//内存缓存的大小</span></span><br><span class="line">        <span class="keyword">int</span> cacheSize = currentMaxMemory / <span class="number">4</span>;</span><br><span class="line">        mMemoryLru = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        mMemoryLru.put(url,bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMemoryLru.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出 ImageLoader 负责图片加载的逻辑，而 MemoryCache 负责缓存，这 2 个类职责分明，就像公司里面不同部门干不同的活一样。但是，如果这 2 类写在一起的话，缺点一下就出来了，不仅功能职责不分明，而且代码也比较臃肿，耦合太重。 现在虽然代码结构变得清晰，职责也分明了，但是可扩展性还需要进一步优化，下面我们就来慢慢优化吧。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则英文全称是 Open Close Principle,缩写 OCP ，它是 Java 世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。</p><p>开闭原则的定义是：<strong>软件中的对象 (类、模块、函数等) 应该对于扩展是开放的，但是，对于修改是封闭的</strong> 这就是开放-关闭原则。</p><p>上一小节的 ImageLoader 职责单一，结构清晰，应该算是一个不错的开始了，但是 Android 中应用内存是有限制的，当应用重新启动，那么原有的缓存就不在了。现在我们加上本地磁盘缓存，为了遵从开闭原则的思想，我又对 ImageLoader 重新设计了。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912152821.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认内存缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IImageCache mMemoryCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService mExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImageLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> ImageLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMemoryCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line">        <span class="comment">//线程池，线程数据量为 CPU 的数量</span></span><br><span class="line">        mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户配置缓存策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageCache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(IImageCache imageCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemoryCache = imageCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">       .....</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downBitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> Bitmap downBitmap, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">     .....</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//磁盘缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> <span class="keyword">implements</span> <span class="title">IImageCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DiskLruCache mDiskLruCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//10MB</span></span><br><span class="line">    <span class="comment">//IO缓存流大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IO_BUFFER_SIZE = <span class="number">8</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISK_CACHE_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiskCache</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File cacheDir = CacheUtils.getDiskCacheDir(context, <span class="string">"bitmapCache"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!cacheDir.exists()) &#123;</span><br><span class="line">                cacheDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            mDiskLruCache = DiskLruCache.open(cacheDir, ImageLoaderUtils.getAppVersion(context), <span class="number">1</span>, MAX_SIZE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        DiskLruCache.Snapshot snapshot = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        String key = ImageLoaderUtils.hashKeyForDisk(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            snapshot = mDiskLruCache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                DiskLruCache.Editor editor = mDiskLruCache.edit(key);</span><br><span class="line">                <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    outputStream = editor.newOutputStream(DISK_CACHE_INDEX);</span><br><span class="line"></span><br><span class="line">                    InputStream inputStream = ImageLoaderUtils.bitmap2InputStream(bitmap, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                    in = <span class="keyword">new</span> BufferedInputStream(inputStream, IO_BUFFER_SIZE);</span><br><span class="line">                    out = <span class="keyword">new</span> BufferedOutputStream(outputStream, IO_BUFFER_SIZE);</span><br><span class="line">                    <span class="keyword">int</span> b;</span><br><span class="line">                    <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        out.write(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                    editor.commit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    snapshot.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过key值在缓存中找到对应的Bitmap</span></span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        String key = ImageLoaderUtils.hashKeyForDisk(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//得到文件输入流</span></span><br><span class="line">            InputStream fileInputStream = snapshot.getInputStream(DISK_CACHE_INDEX);</span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="keyword">null</span>)</span><br><span class="line">                bitmap = BitmapFactory.decodeStream(fileInputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCache</span> <span class="keyword">implements</span> <span class="title">IImageCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IImageCache mMemoryCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 磁盘缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IImageCache mDiskCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleCache</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemoryCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line">        <span class="keyword">this</span>.mDiskCache = <span class="keyword">new</span> DiskCache(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        mMemoryCache.put(key, bitmap);</span><br><span class="line">        mDiskCache.put(key, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = mMemoryCache.get(url);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.i(TAG,<span class="string">"使用内存缓存"</span>);</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG,<span class="string">"使用磁盘缓存"</span>);</span><br><span class="line">        <span class="keyword">return</span> mDiskCache.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IImageCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IImageCache 接口简单定义了 存储/获取 两个函数，缓存的 url 就是图片网络地址，值就是缓存的图片，经过这次重构我们扩展了内存/磁盘缓存，细心的同学可能注意到了， ImageLoader  类中增加了一个 setImageCache (IImageCache cache) 函数，用户可以通过该函数来设置缓存，也就是通常说的依赖注入。下面看看怎么配置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用双缓存</span></span><br><span class="line">  ImageLoader.getInstance().setImageCache(<span class="keyword">new</span> DoubleCache(getApplicationContext()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户自定义</span></span><br><span class="line">  ImageLoader.getInstance().setImageCache(<span class="keyword">new</span> IImageCache() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，通过 setImageCache() 方法注入不同的缓存实现，这样不仅能够使 ImageLoader 更简单，健壮，也使得 ImageLoader 的可扩展性，灵活性能高，MemoryCache 、DiskCache 、DoubleCache 缓存图片的具体实现完全一样，但是，他们的一个特点是都实现了 ImageCache 接口，并且通过 setImageCache() 注入到 IImageCache 中，这样就实现了千变万化的缓存策略，且扩展不会导致内部的修改，哈哈，这就是我们之前所说的开闭原则。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则英文全称是 Liskov Substitution Principle , 缩写是 LSP。LSP 的第一种定义是：<strong>如果对每一个类型为 S 的对象 O1, 都有类型为 T 的对象 O2, 使得以 T 定义的所有程序 P 在所有的对象 O1都替换成 O2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型</strong>。上面这种描述确实有点不好理解，我们再来看第二种里氏替换原则定义：<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</p><p>我们知道，面向对象语言的三大特点是 继承，封装，多态，里氏替换原则就是依赖于 继承，多态这两大特性。里氏替换原则通俗来说的话就是，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本不用知道是父类还是子类，但是反过来就不行了，有子类出现的地方，父类就不一定能适应，说了这么多，其实最终总结就两个字：<strong>抽象</strong>。</p><p>为了我们能够深入理解直接看下面代码示例吧:</p><p>​    <img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912153056.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//框口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">    view.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立视图对象，测量视图的宽高为公用代码，绘制实现交给具体的子类</span></span><br><span class="line">pubic <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> vid <span class="title">measure</span><span class="params">(<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    <span class="comment">//测量视图大小</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageView</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  draw&#123;</span><br><span class="line">    <span class="comment">//绘制图片</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... extends View&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例代码中， Window 依赖于 View , 而 View 定义了一个视图抽象， measure 是各个子类共享的方法，子类通过重写 View 的draw 方法实现具有各自特色的功能，在这里，这个功能就是绘制自身的内容，在任何继承 View 类的子类都可以传递给 show 函数，这就是所说的里氏替换。</p><p>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在 OOP 当中，继承的优缺点都相当明显，优点：</p><ol><li>代码复用，减少创建类的成本，每个子类都拥有父类的方法和属性；</li><li>子类于父类基本相似，但又与父类有所区别；</li><li>提高代码的可扩展性；</li></ol><p>继承的缺点：</p><ol><li>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；</li><li>可能造成子类代码冗余，灵活性降低，因为子类必须拥有父类的属性和方法。</li></ol><p>事务都是都利和弊，须合理利用。</p><p>继续拿上面的 ImageLoader 缓存策略来说明里氏替换原则，用户只需要指定具体的缓存对象就可以通过 ImageCache 的 setImageCache() 函数就可以替换 ImageLoader 的缓存策略，这就使得 ImageLoader 的缓存系统有了无限的可能性，也保证了可扩展性。</p><p>开闭和里氏往往是生世相依，不离不弃，通过里氏替换来达到程序的扩展，对修改的关闭效果。然而，这两个原则都同时强调了一个 OOP 的重要性 - 抽象，因此，在开发过程中，运用抽象是走向代码优化的重要一步。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则英文全称是 Dependence Inversion Principle, 简写 DIP 。依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖于底层次模块的实现细节的目的，依赖模块被颠倒了。这个概念有点不好理解，这到底是什么意思勒？</p><p>依赖倒置有几个关键点：</p><ol><li>高层模块不应该依赖底层模块，两者都应该依赖起抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象；</li></ol><p>在 Java 语言中，抽象就是接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，其特点就是可以直接实例化，也就是可以加上一个 new 关键字产生一个对象。高层模块就是调用端，底层模块就是具体实现类。依赖倒置原则在 Java  语言中的表现就是: <strong>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的</strong> ，这又是一个将理论抽象化的实例，其实一句话可以概括：面向接口编程，或者说是面向抽象编程，面向接口编程是面向对象精髓之一，也就是上面两节强调的抽象。</p><p>这里我们还是以 ImageLoader 来说明，先看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认内存缓存(直接依赖于细节，而不是抽象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MemoryCache mMemoryCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService mExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImageLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> ImageLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMemoryCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line">        <span class="comment">//线程池，线程数据量为 CPU 的数量</span></span><br><span class="line">        mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户配置缓存策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageCache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(MemoryCache imageCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemoryCache = imageCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码 ImageLoader 直接依赖于细节 MemoryCache ，如果框架升级需有多级缓存也就是内存 + SD 卡缓存策略，那么就又需要改 ImageLoader 中的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认内存缓存(直接依赖于细节，而不是抽象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleCache mMemoryCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService mExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImageLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> ImageLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMemoryCache = <span class="keyword">new</span> DoubleCache();</span><br><span class="line">        <span class="comment">//线程池，线程数据量为 CPU 的数量</span></span><br><span class="line">        mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户配置缓存策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageCache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(DoubleCache imageCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemoryCache = imageCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ImageLoader 中我们把默认内存缓存改成了双缓存，这样不仅违背了没有开闭原则，也没有依赖于抽象，所以下面的代码才是正确的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = getClass().getSimpleName();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认内存缓存 默认依赖于抽象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IImageCache mMemoryCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImageLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> ImageLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户配置缓存策略 注入抽象类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageCache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(IImageCache imageCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemoryCache = imageCache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里实现类没有发生直接的依赖，而是通过抽象发生的依赖。满足了依赖倒置基本原则，想要让程序更为灵活，那么抽象就是迈出灵活的第一步。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><code>接口隔离原则英文全称是</code> InterfaceSegregation Principles, 缩写 ISP 。接口隔离原则的目的是系统解耦，从而容易重构、更改和重新部署。说白了就是让客服端依赖的接口尽可能地小，这样说可能还有点抽象，还是以一个示例说明一下</p><p>未优化的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> <span class="keyword">implements</span> <span class="title">IImageCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DiskLruCache mDiskLruCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//10MB</span></span><br><span class="line">    <span class="comment">//IO缓存流大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IO_BUFFER_SIZE = <span class="number">8</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISK_CACHE_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">       .....</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    snapshot.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见上面一段代码虽然功能达到了要求，但是各种 try…catch 嵌套，不经影响代码美观，而且可读性差。我们可以看 Cloaseable 这个类的实现差不多 160 多个实现类，如果每个类都 close 那不的疯了，我们直接抽取一个 CloseUtils 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloaseUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (closeable.length == <span class="number">1</span>)&#123;</span><br><span class="line">                    closeable[<span class="number">0</span>].close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; closeable.length; i++) &#123;</span><br><span class="line">                    closeable[i].close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持同时关闭一个，或多个实现类的 close。</p><p>改造之后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> <span class="keyword">implements</span> <span class="title">IImageCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DiskLruCache mDiskLruCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//10MB</span></span><br><span class="line">    <span class="comment">//IO缓存流大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IO_BUFFER_SIZE = <span class="number">8</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISK_CACHE_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">       .....</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       CloaseUtils.close(snapshot,out,in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是清爽多了，一行代码解决了刚刚差不多 10 行代码的逻辑。而且这里基本原理就是依赖于 Closeable 抽象，而不是具体实现类（这不就是我们刚刚才说了的依赖倒置原则嘛），并且建立在最小化依赖原则的基础上，它只需要知道这个对象是否关闭，其它一概不关心，也就是这里的接口隔离原则。</p><h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>迪米特原则英文的全称为 Law of Demeter , 缩写是 LOD , 也称为最少知识原则。虽然名字不同，但描述的是同一个原则：<strong>一个对象应该对其他对象有最少的的了解</strong>。通俗的将，一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现与调用者或者依赖者没有关系，调用者或者依赖着只需要知道它需要的方法即可，其他的可一概不用管。类与类之间关系密切，耦合度就越大，当一个类发生改变时，对另一个类的影响也越大。</p><p>下面以一个租房例子说明:<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912153331.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**房子*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">  <span class="comment">//面积</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span> area;</span><br><span class="line">  <span class="comment">//价钱</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span> price;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">float</span> area,<span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.area = area;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**中介*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">  List &lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">      mRoom.add(<span class="keyword">new</span> Room(<span class="number">14</span> + i,(<span class="number">14</span> + i) * <span class="number">150</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Room&gt; <span class="title">getAllRooms</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRooms;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**租客**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentRoom</span><span class="params">(<span class="keyword">float</span> roomArea,<span class="keyword">float</span> roomPrice,Mediator mediator)</span></span>&#123;</span><br><span class="line">    List&lt;Room&gt; rooms = mediator.getAllRooms();</span><br><span class="line">  <span class="keyword">for</span>(Room room : rooms)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isSuitable(roomArea,roomPrice,room))&#123;</span><br><span class="line">        Log.i(TAG,<span class="string">"租到房子了"</span>);</span><br><span class="line">      bread;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//租金要小于等于指定的值，面积要大于等于指定的值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(<span class="keyword">float</span> roomArea,<span class="keyword">float</span> roomPrice,Room room)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> room.price &lt;= roomPrice &amp;&amp; room.area &gt;= roomArea;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看到，Tenant 不仅依赖了 Mediator 类，还需要频繁得于 Room 类打交道。租客只是找一个房子而已，如果把这些功能都放在 Tenant 类里面，那中介都没有存在感了吧？耦合太重了，我们只需要跟中介通信就行了，继续重构代码；</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912153515.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">  List&lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**构造房子**/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">      mRoom.add(<span class="keyword">new</span> Room(<span class="number">14</span> + i,(<span class="number">14</span> + i) * <span class="number">150</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Room <span class="title">rentOut</span><span class="params">(<span class="keyword">float</span> area,<span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Room room : mRooms)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isSuitable(area,price,room))&#123;</span><br><span class="line">        <span class="keyword">return</span> room;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(<span class="keyword">float</span> area,<span class="keyword">float</span> price ,Room room)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> room.price &lt;= price &amp;&amp; room.area &gt;= area</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span></span>&#123;</span><br><span class="line">  <span class="comment">/**是否租到房子了*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Room <span class="title">rentRoom</span><span class="params">(<span class="keyword">float</span> roomArea,<span class="keyword">float</span> roomPrice,Mediator mediator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mediator.rentOut(roomArea,roomPrice);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的重构优化，我们得出结构，租客只需要跟中介通信，主要关心中介那里有没有我需要的房子，而中介勒就去他的资源库里面去找，有没有租客需要的房子，每个对象做的事儿明确。“只与直接有关系的联系” 这简单的几个字就能够将我们从复杂的关系网中抽离出来，使程序耦合度更低，稳定性更好。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从六大原则中我们得出了重要的结论，就是一定要有抽象的思维，面向抽象或面向接口编程。在应用开发过程中，最难的不是完成开发工作，而是后续的维护和迭代工作是否拥有可变性，扩展性，在不破坏系统的稳定性前提下依然保持 <strong>二高一低原则（高扩展，高内聚，低耦合）</strong> 在经历多个版本的迭代项目依然保持清晰，灵活，稳定的系统架构。当然这是我们一个比较理想的情况，但是我们需要往这个方向去实现努力，就相当于接口（想法）出来了，我们要去实现（接口实现类）它，遵循面向对象六大原则就是我们走向灵活软件之路所迈出的第一步，加油！</p><h1 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h1><p><a href="https://item.jd.com/12113187.html" target="_blank" rel="noopener">《 Android 源码设计模式解析与实战 》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读 Android 系统底层源码或者开源框架源码时，发现内部大量的设计模式，如果你对设计模式不懂的话，那么阅读源码真的是寸步难行。那么这篇文章我们先来学习面向对象的六大原则，设计模式大概 23 种，后面我们一步一步来学习它。&lt;/p&gt;
&lt;h2 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h2&gt;&lt;p&gt;单一职责原则的英文名称是 Single Responsibility Principle ，缩写是 SRP 。 SRP 的定义是：&lt;strong&gt;就一个类而言，应该仅有一个引起变化的原因&lt;/strong&gt;。简单的来说，就是一个类中应该是一组相关性很高的函数、数据的封装。单一职责的划分界限也并不是那么的清晰，很多时候都是靠个人经验来给定界限，当然，最大的的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。&lt;/p&gt;
&lt;p&gt;下面我们就以 &lt;strong&gt;图片加载库&lt;/strong&gt; 的例子代码来对类的职责简单说明下，在设计一个图片加载库之前，我们需要先大概画下 UML 类图，有了 UML 图之后写代码就能更加的清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912152536.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhangmiao.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="六大原则" scheme="https://zhangmiao.cc/tags/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>推荐一波最近学习Gradle的项目</title>
    <link href="https://zhangmiao.cc/posts/8f5f13d7.html"/>
    <id>https://zhangmiao.cc/posts/8f5f13d7.html</id>
    <published>2019-09-12T03:05:56.000Z</published>
    <updated>2019-09-12T03:21:05.696Z</updated>
    
    <content type="html"><![CDATA[<p>最新搞了好久的 Gradle，说起 Gradle 这个东西也很奇怪，明明在 gradle 文件内是支持各种我们熟悉的代码的，比如 Java，Groovy，但是就是在里面写几个功能极其费劲，总体而言，还是对其原理缺乏认识导致的。</p><p>再者，我们在研究很多技术时，基本都离不开 Gradle 相关的知识，比如编译相关，热修复，插件化，很多性能优化相关，反正你想干涉整个打包流程，或者在编译期间搞点小动作，或多或少是要了解相关知识的。</p><p>好了，下面就推荐一些学习资源，基本上足够大家系统性学习了，当然前提是你愿意看哈…</p><h2 id="官方用户手册"><a href="#官方用户手册" class="headerlink" title="官方用户手册"></a>官方用户手册</h2><p>如果英文足够好的话，当然首选官网了：</p><p><em><a href="https://docs.gradle.org/current/userguide/getting_started.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/getting_started.html</a></em></p><p>而且官网也提供了 user guide pdf 的下载：</p><p><em><a href="https://docs.gradle.org/current/userguide/userguide.pdf" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/userguide.pdf</a></em></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912110958.png" alt></p><p>想离线看很方便。</p><a id="more"></a><h2 id="Gradle-User-Guide-中文版"><a href="#Gradle-User-Guide-中文版" class="headerlink" title="Gradle User Guide 中文版"></a>Gradle User Guide 中文版</h2><p><a href="https://github.com/DONGChuan/GradleUserGuide" target="_blank" rel="noopener">https://github.com/DONGChuan/GradleUserGuide</a></p><p>没错，总有可爱的人，会愿意翻译 user guide然后分享出来，当然了，因为是翻译，所以内容并不是最新的，不过倒是不影响前期的学习，可以边敲边学，遇到有问题的，搜一下解决就行了。</p><p>阅读地址：</p><p><a href="https://dongchuan.gitbooks.io/gradle-user-guide-/" target="_blank" rel="noopener">https://dongchuan.gitbooks.io/gradle-user-guide-/</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912111249.png" alt></p><h2 id="一个不错的入门系列"><a href="#一个不错的入门系列" class="headerlink" title="一个不错的入门系列"></a>一个不错的入门系列</h2><p>如果你就是想单纯的先入个门，那么可以花点时间看这个系列：</p><p><em><a href="https://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">https://www.cnblogs.com/davenkin/p/gradle-learning-1.html</a></em></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912111341.png" alt></p><p>对应源码:</p><p><em><a href="https://github.com/davenkin/gradle-learning" target="_blank" rel="noopener">https://github.com/davenkin/gradle-learning</a></em></p><p>很早的文章了，不过依然适合入门。</p><h2 id="一个非常棒的深入系列"><a href="#一个非常棒的深入系列" class="headerlink" title="一个非常棒的深入系列"></a>一个非常棒的深入系列</h2><p>github 地址：</p><p><em><a href="https://github.com/5A59/android-training" target="_blank" rel="noopener">https://github.com/5A59/android-training</a></em></p><p>当然也可以在掘金上看整个系列：</p><p>【Android 修炼手册】Gradle 篇 – Gradle 的基本使用</p><p><em><a href="https://juejin.im/post/5cd441f851882554b86d088b" target="_blank" rel="noopener">https://juejin.im/post/5cd441f851882554b86d088b</a></em></p><ol><li>掌握 gradle 的基本使用</li><li>了解 gradle 及 android gradle plugin</li><li>了解 gradle 构建阶段及生命周期回调</li><li>掌握 Task，Transform 等概念</li><li>学会自定义 task，自定义 gradle 插件</li></ol><p>【Android 修炼手册】Gradle 篇 – Android Gradle Plugin 主要流程分析</p><p><em><a href="https://juejin.im/post/5cd640526fb9a03232199a05" target="_blank" rel="noopener">https://juejin.im/post/5cd640526fb9a03232199a05</a></em></p><ol><li>了解 android gradle plugin 的构建流程</li><li>了解 android gradle plugin 的主要 task 的实现</li><li>学会 hook android 构建流程，添加自己想要的功能</li></ol><p>【Android 修炼手册】Gradle 篇 – Android Gradle Plugin 主要 Task 分析</p><p><em><a href="https://juejin.im/post/5ce913735188254e8309290b" target="_blank" rel="noopener">https://juejin.im/post/5ce913735188254e8309290b</a></em></p><ol><li>了解 android gradle plugin 中各个 task 作用</li><li>了解 android gradle plugin 中主要 task 的实现</li></ol><p>【Android 修炼手册】Gradle 篇 – Gradle 源码分析</p><p><em><a href="https://juejin.im/post/5cf3e4dfe51d454d56535790" target="_blank" rel="noopener">https://juejin.im/post/5cf3e4dfe51d454d56535790</a></em></p><ol><li>了解 gradle 的实现原理</li></ol><p>这算的上是写的非常深入而且实用的一个系列了，从</p><p><strong>基本使用-&gt;</strong></p><p><strong>常见 API（Task,Transform，插件-&gt;</strong> </p><p><strong>打包过程task 分析-&gt;</strong> </p><p><strong>核心 task 源码分析-&gt;</strong></p><p> <strong>gradle 源码分析</strong></p><p>超赞…</p><p>最后，关于一些针对性的知识，比如你已经很明确了要自定义一个 Transform 子类的，搜索就ok 了，<a href="https://www.wanandroid.com" target="_blank" rel="noopener">wanandroid</a> 上也收录了一大批好文。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912111507.png" alt></p><p>以上已经足够大家系统性学习整个 Gradle 的知识了，回见！</p><p>转自鸿洋大神：<a href="https://mp.weixin.qq.com/s/TVuF8_304DZQ1wbe1vm1ag" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TVuF8_304DZQ1wbe1vm1ag</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最新搞了好久的 Gradle，说起 Gradle 这个东西也很奇怪，明明在 gradle 文件内是支持各种我们熟悉的代码的，比如 Java，Groovy，但是就是在里面写几个功能极其费劲，总体而言，还是对其原理缺乏认识导致的。&lt;/p&gt;
&lt;p&gt;再者，我们在研究很多技术时，基本都离不开 Gradle 相关的知识，比如编译相关，热修复，插件化，很多性能优化相关，反正你想干涉整个打包流程，或者在编译期间搞点小动作，或多或少是要了解相关知识的。&lt;/p&gt;
&lt;p&gt;好了，下面就推荐一些学习资源，基本上足够大家系统性学习了，当然前提是你愿意看哈…&lt;/p&gt;
&lt;h2 id=&quot;官方用户手册&quot;&gt;&lt;a href=&quot;#官方用户手册&quot; class=&quot;headerlink&quot; title=&quot;官方用户手册&quot;&gt;&lt;/a&gt;官方用户手册&lt;/h2&gt;&lt;p&gt;如果英文足够好的话，当然首选官网了：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://docs.gradle.org/current/userguide/getting_started.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.gradle.org/current/userguide/getting_started.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;而且官网也提供了 user guide pdf 的下载：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://docs.gradle.org/current/userguide/userguide.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.gradle.org/current/userguide/userguide.pdf&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190912110958.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;想离线看很方便。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>马云卸任挥泪洒现场，核心观点总结他所想</title>
    <link href="https://zhangmiao.cc/posts/a1768e04.html"/>
    <id>https://zhangmiao.cc/posts/a1768e04.html</id>
    <published>2019-09-11T10:50:52.000Z</published>
    <updated>2019-09-11T11:08:55.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911185713.png" alt></p><blockquote><p>去年，在教师节那天，阿里巴巴集团创始人马云今天公开信宣布：一年后的阿里巴巴20周年之际，即2019年9月10日，也就是昨天，他将不再担任集团董事局主席，却留下句句触动心灵的话！</p></blockquote><a id="more"></a><h3 id="1、我最遗憾的错误"><a href="#1、我最遗憾的错误" class="headerlink" title="1、我最遗憾的错误"></a>1、我最遗憾的错误</h3><p>01年，我犯了一个错误，我告诉我的18位共同创业同仁，他们只能做小组经理，而所有的副总裁都得从外面聘请。</p><p>现在十年过去了，我从外面聘请的人才都走了，而我之前曾怀疑过其能力的人都成了副总或董事。</p><p>我相信两个信条：态度比能力重要，选择同样也比能力重要！</p><h3 id="2、-不能统一人的思想，但可以统一人的目标"><a href="#2、-不能统一人的思想，但可以统一人的目标" class="headerlink" title="2、 不能统一人的思想，但可以统一人的目标"></a>2、 <strong>不能统一人的思想，但可以统一人的目标</strong></h3><p>千万不要相信你能统一人的思想，那是不可能的。</p><p>30%的人永远不可能相信你，不要让你的同事为你干活，而让他们为我们的共同目标干活。</p><p>团结在一个共同的目标下，要比团结在一个人周围容易的多。</p><h3 id="3、-细节好的人格局一般都差"><a href="#3、-细节好的人格局一般都差" class="headerlink" title="3、 细节好的人格局一般都差"></a>3、 <strong>细节好的人格局一般都差</strong></h3><p>①有人觉得我牛，6分钟说服了孙正义，其实是他说服了我。见孙正义之前，我在硅谷至少被拒绝了40次。</p><p>②做企业赢在细节，输在格局。</p><p>③格局，“格”是人格，“局”是胸怀，细节好的人格局一般都差，格局好的人从来不重细节，两个都干好，那叫太有才！</p><h3 id="4、-领导比员工多什么？"><a href="#4、-领导比员工多什么？" class="headerlink" title="4、 领导比员工多什么？"></a>4、 <strong>领导比员工多什么？</strong></h3><p>领导永远不要跟下属比技能，下属肯定比你强；如果不比你强，说明你请错人了。</p><p>①要比眼光：比他看得远；</p><p>②要比胸怀：领导的胸怀是委屈撑大的，要能容人所不容；</p><p>③要比实力：抗失败的能力比他强；一个优秀的领导人的素质就是眼光、胸怀和实力。</p><h3 id="5、-中国商人千万别在“红道”上混"><a href="#5、-中国商人千万别在“红道”上混" class="headerlink" title="5、 中国商人千万别在“红道”上混"></a>5、 <strong>中国商人千万别在“红道”上混</strong></h3><p>①人一辈子要明白钱和权两个东西是绝对不要碰在一起，当了官永远不要想有钱，当了商人千万别想权；</p><p>②钱和权这两个东西碰在一起就是炸药和雷管碰在一起，必然要爆炸；</p><p>③胡雪岩的悲哀就在于他是红顶商人；</p><p>④中国商人千万别在“红道”上混。</p><h3 id="6、-年轻人必须思考的4大问题"><a href="#6、-年轻人必须思考的4大问题" class="headerlink" title="6、 年轻人必须思考的4大问题"></a>6、 <strong>年轻人必须思考的4大问题</strong></h3><p>①什么是失败？放弃就是最大的失败。</p><p>②什么叫坚强？经历许多磨难、委屈、不爽，你才知道什么叫坚强。</p><p>③你的职责是什么？比别人多勤奋一点、多努力一点、多一点理想，这就是你的职责。</p><p>④傻瓜用嘴讲话，聪明人用脑袋讲话，智者用心讲话。</p><h3 id="7、-人生在世在做人，不是做事"><a href="#7、-人生在世在做人，不是做事" class="headerlink" title="7、 人生在世在做人，不是做事"></a>7、 <strong>人生在世在做人，不是做事</strong></h3><p>我跟自己讲我们到这个世界上不是来工作的，我们是来享受人生的，我们是来做人不是做事。</p><p>如果一辈子都做事的话，忘了做人，将来一定会后悔。</p><p>不管事业多成功、多伟大、多了不起，记住我们到这个世界就是享受经历这个人生的体验。</p><p>忙着做事一定会后悔。</p><h3 id="8、-高手的竞争论"><a href="#8、-高手的竞争论" class="headerlink" title="8、 高手的竞争论"></a>8、 <strong>高手的竞争论</strong></h3><p>①一定要争得你死我活的商战，是最愚蠢的。</p><p>②眼睛中全是敌人，外面就全是敌人。</p><p>③竞争的时候不要带仇恨，带仇恨一定失败。</p><p>④竞争乐趣就像下棋一样，你输了，我们再来过，两个棋手不能打架。</p><p>⑤真正做企业是没有仇人的，心中无敌，天下无敌。</p><h3 id="9、-别把抱怨当习惯"><a href="#9、-别把抱怨当习惯" class="headerlink" title="9、 别把抱怨当习惯"></a>9、 <strong>别把抱怨当习惯</strong></h3><p>人是退化最严重的动物。跟兽比人很“弱肢”，和狗比人很“闻盲”，但人类“进化”了抱怨。</p><p>偶尔为之无大碍，但当抱怨成习惯，就如喝海水，喝的越多渴得越厉害。</p><p>最后发现，走在成功路上的，都是些不抱怨的“傻子们”。</p><p>世界不会记得你说了什么，但一定不会忘记你做了什么！</p><h3 id="10、-给初创企业者的忠告"><a href="#10、-给初创企业者的忠告" class="headerlink" title="10、 给初创企业者的忠告"></a>10、 <strong>给初创企业者的忠告</strong></h3><p>①大家看不清的机会，才是真正的机会。</p><p>②让员工笑着干活。</p><p>③客户第一、员工第二、股东第三。</p><p>④抢在变化之前先变。</p><p>⑤忘掉money，忘掉赚钱。</p><p>⑥小聪明不如傻坚持。</p><p>⑦心态决定姿态，姿态决定状态。</p><h3 id="11、-谈创业"><a href="#11、-谈创业" class="headerlink" title="11、 谈创业"></a>11、 <strong>谈创业</strong></h3><p>①一个好的东西往往是说不清楚的，说得清楚的往往不是好东西！</p><p>②创业要找最合适的人，不一定要找最成功的人。</p><p>③这世界最不可靠的东西就是关系。</p><p>④免费是世界上最昂贵的东西。</p><p>⑤今天很残酷，明天更残酷，后天很美好。</p><h3 id="12、-“四不”创业智慧"><a href="#12、-“四不”创业智慧" class="headerlink" title="12、 “四不”创业智慧"></a>12、 <strong>“四不”创业智慧</strong></h3><p>①创业最怕就是看不见，看不起，看不懂，跟不上；</p><p>②看不见对手在哪里，看不起对手，看不懂对手为什么可以变得那么强，然后就跟不上了；</p><p>③即使对手很弱小，也一定要把对方看的很强大，即使对手很强大，也不一定要把自己看的很弱小。</p><h3 id="13、-当你决定要创业时"><a href="#13、-当你决定要创业时" class="headerlink" title="13、 当你决定要创业时"></a>13、 <strong>当你决定要创业时</strong></h3><p>便意味着：</p><p>①没有了稳定的收入；②没有了请假的权利；③没有了得红包的机会。</p><p>然而却更意味着：</p><p>①收入不再受限制；②时间运用更有效；③手心向下不求人。</p><p>想法若不同，结果便不同；选择不一样，生活才变样。</p><h3 id="14、谈机会"><a href="#14、谈机会" class="headerlink" title="14、谈机会"></a>14、<strong>谈机会</strong></h3><p>如果一个方案有90%的人说“好”的话，我一定要把它扔到垃圾桶里去。</p><p>因为这么多人说好的方案，必然有很多人在做了，机会肯定不会是我们的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911185713.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;去年，在教师节那天，阿里巴巴集团创始人马云今天公开信宣布：一年后的阿里巴巴20周年之际，即2019年9月10日，也就是昨天，他将不再担任集团董事局主席，却留下句句触动心灵的话！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android_build.gradle配置详解</title>
    <link href="https://zhangmiao.cc/posts/aaeab884.html"/>
    <id>https://zhangmiao.cc/posts/aaeab884.html</id>
    <published>2019-09-11T08:42:16.000Z</published>
    <updated>2019-09-11T08:48:39.423Z</updated>
    
    <content type="html"><![CDATA[<p>Android Studio是采用gradle来构建项目的，gradle是基于groovy语言的，如果只是用它构建普通Android项目的话，是可以不去学groovy的。当我们创建一个Android项目时会包含两个Android build.gradle配置详解文件，如下图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164601.png" alt></p><a id="more"></a><h2 id="一、Project的build-gradle文件："><a href="#一、Project的build-gradle文件：" class="headerlink" title="一、Project的build.gradle文件："></a>一、Project的build.gradle文件：</h2><p>对应的build.gradle代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;<span class="comment">//这里是gradle脚本执行所需依赖，分别是对应的maven库和插件</span></span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()<span class="comment">//从Android Studio3.0后新增了google()配置，可以引用google上的开源项目</span></span><br><span class="line">        jcenter()<span class="comment">//是一个类似于github的代码托管仓库，声明了jcenter()配置，可以轻松引用 jcenter上的开源项目</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.0.0'</span><span class="comment">////此处是android的插件gradle，gradle是一个强大的项目构建工具</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;<span class="comment">//这里是项目本身需要的依赖，比如项目所需的maven库</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行gradle clean时，执行此处定义的task任务。</span></span><br><span class="line"><span class="comment">// 该任务继承自Delete，删除根目录中的build目录。</span></span><br><span class="line"><span class="comment">// 相当于执行Delete.delete(rootProject.buildDir)。</span></span><br><span class="line"><span class="comment">// gradle使用groovy语言，调用method时可以不用加（）。</span></span><br><span class="line">task clean(<span class="keyword">type</span>: Delete) &#123;</span><br><span class="line">    <span class="built_in">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>buildscript{}闭包里是gradle脚本执行所需依赖，分别是对应的maven库和插件。</li><li>allprojects{}闭包里是项目本身需要的依赖，比如项目所需的maven库。</li><li>task clean(type: Delete){}是运行gradle clean时，执行此处定义的task任务，该任务继承自Delete，删除根目录中的build目录。其中buildscript包含repositories闭包和dependencies闭包。</li></ul><h4 id="repositories-闭包：配置远程仓库"><a href="#repositories-闭包：配置远程仓库" class="headerlink" title="repositories{}闭包：配置远程仓库"></a>repositories{}闭包：配置远程仓库</h4><p>该闭包中声明了jcenter()和google()的配置，其中jcenter是一个代码托管仓库，上面托管了很多Android开源项目，在这里配置了jcenter后我们可以在项目中方便引用jcenter上的开源项目，从Android Studio3.0后新增了google()配置，可以引用google上的开源项目。</p><h4 id="dependencies-闭包：配置构建工具"><a href="#dependencies-闭包：配置构建工具" class="headerlink" title="dependencies{}闭包：配置构建工具"></a>dependencies{}闭包：配置构建工具</h4><p>该闭包使用classpath声明了一个Gradle插件，由于Gradle并不只是用来构建Android项目，因此此处引入相关插件来构建Android项目，其中’3.0.0’为该插件的版本号，可以根据最新的版本号来调整。</p><h2 id="二、Module的build-gradle文件："><a href="#二、Module的build-gradle文件：" class="headerlink" title="二、Module的build.gradle文件："></a>二、Module的build.gradle文件：</h2><p>从文件内容可以看出，主要分为三大部分，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164623.png" alt></p><h4 id="1、apply-plugin："><a href="#1、apply-plugin：" class="headerlink" title="1、apply plugin："></a>1、apply plugin：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明是Android程序，</span></span><br><span class="line"><span class="comment">//com.android.application 表示这是一个应用程序模块</span></span><br><span class="line"><span class="comment">//com.android.library 标识这是一个库模块</span></span><br><span class="line"><span class="comment">//而这区别：前者可以直接运行，后着是依附别的应用程序运行</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br></pre></td></tr></table></figure><p>文件中第一行使用apply plugin表示应用了一个插件，该插件一般有两种值可选：</p><ul><li>‘com.android.application’，表示该模块为应用程序模块，可以直接运行，打包得到的是.apk文件</li><li>‘com.android.library’，表示该模块为库模块，只能作为代码库依附于别的应用程序模块来运行，打包得到的是.aar文件</li></ul><h4 id="2、android-闭包："><a href="#2、android-闭包：" class="headerlink" title="2、android{}闭包："></a>2、android{}闭包：</h4><p>这个闭包主要为了配置项目构建的各种属性：</p><h5 id="2-1、添加signingConfigs-闭包："><a href="#2-1、添加signingConfigs-闭包：" class="headerlink" title="2.1、添加signingConfigs{}闭包："></a>2.1、添加signingConfigs{}闭包：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;<span class="comment">// 自动化打包配置</span></span><br><span class="line">    release &#123;<span class="comment">// 线上环境</span></span><br><span class="line">        keyAlias <span class="string">'test'</span></span><br><span class="line">        keyPassword <span class="string">'123456'</span></span><br><span class="line">        storeFile file(<span class="string">'test.keystore'</span>)</span><br><span class="line">        storePassword <span class="string">'123456'</span></span><br><span class="line">    &#125;</span><br><span class="line">    debug &#123;<span class="comment">// 开发环境</span></span><br><span class="line">        keyAlias <span class="string">'test'</span></span><br><span class="line">        keyPassword <span class="string">'123456'</span></span><br><span class="line">        storeFile file(<span class="string">'test.keystore'</span>)</span><br><span class="line">        storePassword <span class="string">'123456'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以手动添加签名配置，也可以通过Project Structure 选中app，点击Singing添加，具体步骤如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164646.png" alt></p><p>签名配置完成后可以方便带签名打包，在module的Build Variants中有两个Type，分别是debug和release，可以选择任意一个类型进行打包，并且他们会利用各自配置的Key进行打包，执行 Run app或者Build-&gt;Build apk就会自动在module name/app/build/outputs/apk路径下生成Apk文件。另一种打包方式是Build-&gt;Generate Signed APK填写签名信息生成Apk。</p><h5 id="2-2、compileSdkVersion：设置编译时用的Android版本"><a href="#2-2、compileSdkVersion：设置编译时用的Android版本" class="headerlink" title="2.2、compileSdkVersion：设置编译时用的Android版本"></a>2.2、compileSdkVersion：设置编译时用的Android版本</h5><p>2.3、buildToolsVersion：设置编译时使用的构建工具的版本，Android Studio3.0后去除此项配置</p><h5 id="2-4、defaultConfig-闭包："><a href="#2-4、defaultConfig-闭包：" class="headerlink" title="2.4、defaultConfig{}闭包："></a>2.4、defaultConfig{}闭包：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compileSdkVersion <span class="number">27</span><span class="comment">//设置编译时用的Android版本</span></span><br><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId <span class="string">"com.billy.myapplication"</span><span class="comment">//项目的包名</span></span><br><span class="line">    minSdkVersion <span class="number">16</span><span class="comment">//项目最低兼容的版本</span></span><br><span class="line">    targetSdkVersion <span class="number">27</span><span class="comment">//项目的目标版本</span></span><br><span class="line">    versionCode <span class="number">1</span><span class="comment">//版本号</span></span><br><span class="line">    versionName <span class="string">"1.0"</span><span class="comment">//版本名称</span></span><br><span class="line">    testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span><span class="comment">//表明要使用AndroidJUnitRunner进行单元测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>applicationId</strong>：指定了项目的包名。</li><li><strong>minSdkVersion</strong>：指定项目最低兼容的版本，如果设备小于这个版本或者大于maxSdkVersion(一般不用)将无法安装这个应用，这里指定为16，表示最低兼容到Android 4.1系统。</li><li><strong>targetSdkVersion</strong>：指定项目的目标版本，表示在该目标版本上已经做过充分测试，系统会为该应用启动一些对应该目标系统的最新功能特性，Android系统平台的行为变更，只有targetSdkVersion的属性值被设置为大于或等于该系统平台的API版本时，才会生效。例如，若指定targetSdkVersion值为22，则表示该程序最高只在Android5.1版本上做过充分测试，在Android6.0系统上（对应targetSdkVersion为23）拥有的新特性如系统运行时权限等功能就不会被启用。</li><li><strong>versionCode</strong>：表示版本号，一般每次打包上线时该值只能增加，打包后看不见。</li><li><strong>versionName</strong>：表示版本名称，展示在应用市场上。</li><li><strong>testInstrumentationRunner</strong> “android.support.test.runner.AndroidJUnitRunner”表明要使用AndroidJUnitRunner进行单元测试。</li></ul><h5 id="2-5、-buildTypes-闭包："><a href="#2-5、-buildTypes-闭包：" class="headerlink" title="2.5、 buildTypes{}闭包："></a>2.5、 buildTypes{}闭包：</h5><p>这个闭包主要指定生成安装文件的主要配置，一般包含两个子闭包，一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写；另一个是release闭包，用于指定生成正式版安装文件的配置。两者能配置的参数相同，最大的区别默认属性配置不一样，两种模式支持的属性配置如下图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164659.png" alt></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;<span class="comment">// 生产/测试环境配置</span></span><br><span class="line">    release &#123;<span class="comment">// 生产环境</span></span><br><span class="line">        buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">        buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://release.cn/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">        minifyEnabled <span class="literal">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">        signingConfig signingConfigs.release<span class="comment">//设置签名信息</span></span><br><span class="line">        pseudoLocalesEnabled <span class="literal">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">        zipAlignEnabled <span class="literal">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">        applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">    &#125;</span><br><span class="line">    debug &#123;<span class="comment">// 测试环境</span></span><br><span class="line">        buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">        buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://test.com/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">        minifyEnabled <span class="literal">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">        signingConfig signingConfigs.debug<span class="comment">//设置签名信息</span></span><br><span class="line">        debuggable <span class="literal">false</span><span class="comment">//是否支持断点调试</span></span><br><span class="line">        jniDebuggable <span class="literal">false</span><span class="comment">//是否可以调试NDK代码</span></span><br><span class="line">        renderscriptDebuggable <span class="literal">false</span><span class="comment">//是否开启渲染脚本就是一些c写的渲染方法</span></span><br><span class="line">        zipAlignEnabled <span class="literal">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">        pseudoLocalesEnabled <span class="literal">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">        applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="release-闭包和debug-闭包两者能配置的参数相同，最大的区别默认属性配置不一样："><a href="#release-闭包和debug-闭包两者能配置的参数相同，最大的区别默认属性配置不一样：" class="headerlink" title="release{}闭包和debug{}闭包两者能配置的参数相同，最大的区别默认属性配置不一样："></a>release{}闭包和debug{}闭包两者能配置的参数相同，最大的区别默认属性配置不一样：</h5><ul><li><strong>minifyEnabled</strong>：表明是否对代码进行混淆，true表示对代码进行混淆，false表示对代码不进行混淆，默认的是false。</li><li><strong>proguardFiles</strong>：指定混淆的规则文件，这里指定了proguard-android.txt文件和proguard-rules.pro文件两个文件，proguard-android.txt文件为默认的混淆文件，里面定义了一些通用的混淆规则。proguard-rules.pro文件位于当前项目的根目录下，可以在该文件中定义一些项目特有的混淆规则。</li><li><strong>buildConfigField</strong>：用于解决Beta版本服务和Release版本服务地址不同或者一些Log打印需求控制的。例如：配置buildConfigField(“boolean”, “LOG_DEBUG”, “true”)，这个方法接收三个非空的参数，第一个：确定值的类型，第二个：指定key的名字，第三个：传值，调用的时候BuildConfig.LOG_DEBUG即可调用。</li><li><strong>debuggable</strong>：表示是否支持断点调试，release默认为false，debug默认为true。</li><li><strong>jniDebuggable</strong>：表示是否可以调试NDK代码，使用lldb进行c和c++代码调试，release默认为false</li><li><strong>signingConfig</strong>：设置签名信息，通过signingConfigs.release或者signingConfigs.debug，配置相应的签名，但是添加此配置前必须先添加signingConfigs闭包，添加相应的签名信息。</li><li><strong>renderscriptDebuggable</strong>：表示是否开启渲染脚本就是一些c写的渲染方法，默认为false。</li><li><strong>renderscriptOptimLevel</strong>：表示渲染等级，默认是3。</li><li><strong>pseudoLocalesEnabled</strong>：是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多。</li><li><strong>applicationIdSuffix</strong>：和defaultConfig中配置是一的，这里是在applicationId 中添加了一个后缀，一般使用的不多。</li><li><strong>versionNameSuffix</strong>：表示添加版本名称的后缀，一般使用的不多。</li><li><strong>zipAlignEnabled</strong>：表示是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率，release和debug默认都为true。</li></ul><h5 id="2-6、sourceSets-闭包：配置目录指向"><a href="#2-6、sourceSets-闭包：配置目录指向" class="headerlink" title="2.6、sourceSets{}闭包：配置目录指向"></a>2.6、sourceSets{}闭包：配置目录指向</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;<span class="comment">//目录指向配置</span></span><br><span class="line">    main &#123;</span><br><span class="line">        jniLibs.srcDirs = [<span class="string">'libs'</span>]<span class="comment">//指定lib库目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 jniLibs.srcDirs = [‘libs’]，可以在Android studio的Android视图下生成jniLibs文件夹，可以方便我们存放jar包和库文件，其中Android视图下的jniLibs和project视图下的libs指向同一文件夹（app→libs），如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164716.png" alt></p><h5 id="2-7、packagingOptions-闭包：打包时的相关配置"><a href="#2-7、packagingOptions-闭包：打包时的相关配置" class="headerlink" title="2.7、packagingOptions{}闭包：打包时的相关配置"></a>2.7、packagingOptions{}闭包：打包时的相关配置</h5><p>当项目中依赖的第三方库越来越多时，有可能会出现两个依赖库中存在同一个（名称）文件。如果这样，Gradle在打包时就会提示错误（警告）。那么就可以根据提示，然后使用以下方法将重复的文件剔除，比较常用的是通过exclude去除重复的文件，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">packagingOptions&#123;</span><br><span class="line">    <span class="comment">//pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk</span></span><br><span class="line">    <span class="comment">// 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时  只用第一个 这样打包就不会报错</span></span><br><span class="line">    pickFirsts = [<span class="string">'META-INF/LICENSE'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//merges何必 当出现重复文件时 合并重复的文件 然后打包入apk</span></span><br><span class="line">    <span class="comment">//这个是有默认值得 merges = [] 这样会把默默认值去掉  所以我们用下面这种方式 在默认值后添加</span></span><br><span class="line">    merge <span class="string">'META-INF/LICENSE'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。</span></span><br><span class="line">    exclude <span class="string">'META-INF/services/javax.annotation.processing.Processor'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-8、productFlavors-闭包：多个渠道配置"><a href="#2-8、productFlavors-闭包：多个渠道配置" class="headerlink" title="2.8、productFlavors{}闭包：多个渠道配置"></a>2.8、productFlavors{}闭包：多个渠道配置</h5><p>这个配置是经常会使用到的，通常在适配多个渠道的时候，需要为特定的渠道做部分特殊的处理，比如设置不同的包名、应用名等。场景：当我们使用友盟统计时，通常需要设置一个渠道ID，那么我们就可以利用productFlavors来生成对应渠道信息的包，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        wandoujia &#123;</span><br><span class="line">            <span class="comment">//豌豆荚渠道包配置</span></span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"wandoujia"</span>]</span><br><span class="line">            <span class="comment">//manifestPlaceholders的使用在后续章节（AndroidManifest里的占位符）中介绍</span></span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"xiaomi"</span>]</span><br><span class="line">            applicationId <span class="string">"com.wiky.gradle.xiaomi"</span> <span class="comment">//配置包名</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        _360 &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"_360"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也有更简洁的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        _360 &#123;&#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123; </span><br><span class="line">        <span class="comment">//批量修改，类似一个循序遍历</span></span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完之后，在命令行窗口中（Terminal）中输入gradlew assembleRelease（windows）即可开始打包，在Mac系统中对应指令应该是./gradlew assembleRelease。当然，如果想要debug版本的包，将指令中assembleRelease改为assembleDebug即可。最后生成的包还是在app/build/outputs/apk中，默认命名格式如app-wandoujia-release-unsigned.apk，在module的Build Variants中可以选择相应的渠道。<br><strong>注：</strong>Android Studio3.0需在主app的build.gradle里面的<br>defaultConfig {<br>targetSdkVersion：*<br>minSdkVersion ：*<br>versionCode：*<br>versionName ：*<br>//版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了<br>flavorDimensions “versionCode”<br>}</p><h5 id="2-9、lintOptions-闭包：代码扫描分析"><a href="#2-9、lintOptions-闭包：代码扫描分析" class="headerlink" title="2.9、lintOptions{}闭包：代码扫描分析"></a>2.9、lintOptions{}闭包：代码扫描分析</h5><p>Lint 是Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构/质量问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。</p><p>Lint 发现的每个问题都有描述信息和等级（和测试发现 bug 很相似），我们可以很方便地定位问题，同时按照严重程度进行解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关</span></span><br><span class="line">lintOptions &#123;</span><br><span class="line">    abortOnError <span class="literal">false</span> <span class="comment">//即使报错也不会停止打包</span></span><br><span class="line">    checkReleaseBuilds <span class="literal">false</span>  <span class="comment">//打包release版本的时候进行检测</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、dependencies-闭包："><a href="#3、dependencies-闭包：" class="headerlink" title="3、dependencies{}闭包："></a>3、dependencies{}闭包：</h4><p>该闭包定义了项目的依赖关系，一般项目都有三种依赖方式：本地依赖、库依赖和远程依赖。本地依赖可以对本地的jar包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖可以对jcener库上的开源项目添加依赖关系。<code>从Android Studio3.0后compile引入库不在使用，而是通过api和implementation，api完全等同于以前的compile，用api引入的库整个项目都可以使用，用implementation引入的库只有对应的Module能使用，其他Module不能使用，由于之前的项目统一用compile依赖，导致的情况就是模块耦合性太高，不利于项目拆解，使用implementation之后虽然使用起来复杂了但是做到降低偶合兴提高安全性。</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;<span class="comment">//项目的依赖关系</span></span><br><span class="line">    implementation fileTree(<span class="keyword">include</span>: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)<span class="comment">//本地jar包依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:27.1.1'</span><span class="comment">//远程依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span><span class="comment">//声明测试用例库</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>implementation</strong> fileTree(include: [‘*.jar’], dir: ‘libs’)：implementation fileTree是一个本地依赖声明，表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。</li><li><strong>implementation ‘com.android.support:appcompat-v7:27.1.1’</strong>：implementation语句为 远程依赖声明，’com.android.support:appcompat-v7:27.1.1’为一个标准的远程依赖库格式，其中com.android.support为域名部分，用于区分不同公司的库；appcompat-v7为组件名称，用于区分同一个公司的不同库；27.1.1为版本号，用于区分同一个库的不同版本。加上这句声明后，Gradle在构建项目时会先检查一下本地是否已经缓存过该库，若没有缓存则自动联网下载，下载后自动添加到项目的构建路径中去。</li><li><strong>testImplementation和androidTestImplementation</strong>：表示声明测试用例库。</li></ul><h2 id="Module完整的build-gradle配置如下："><a href="#Module完整的build-gradle配置如下：" class="headerlink" title="Module完整的build.gradle配置如下："></a>Module完整的build.gradle配置如下：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明是Android程序，</span></span><br><span class="line"><span class="comment">//com.android.application 表示这是一个应用程序模块</span></span><br><span class="line"><span class="comment">//com.android.library 标识这是一个库模块</span></span><br><span class="line"><span class="comment">//而这区别：前者可以直接运行，后着是依附别的应用程序运行</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;<span class="comment">// 自动化打包配置</span></span><br><span class="line">        release &#123;<span class="comment">// 线上环境</span></span><br><span class="line">            keyAlias <span class="string">'test'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            storeFile file(<span class="string">'test.jks'</span>)</span><br><span class="line">            storePassword <span class="string">'123456'</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;<span class="comment">// 开发环境</span></span><br><span class="line">            keyAlias <span class="string">'test'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            storeFile file(<span class="string">'test.jks'</span>)</span><br><span class="line">            storePassword <span class="string">'123456'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileSdkVersion <span class="number">27</span><span class="comment">//设置编译时用的Android版本</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.billy.myapplication"</span><span class="comment">//项目的包名</span></span><br><span class="line">        minSdkVersion <span class="number">16</span><span class="comment">//项目最低兼容的版本</span></span><br><span class="line">        targetSdkVersion <span class="number">27</span><span class="comment">//项目的目标版本</span></span><br><span class="line">        versionCode <span class="number">1</span><span class="comment">//版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span><span class="comment">//版本名称</span></span><br><span class="line">        flavorDimensions <span class="string">"versionCode"</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span><span class="comment">//表明要使用AndroidJUnitRunner进行单元测试</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;<span class="comment">// 生产/测试环境配置</span></span><br><span class="line">        release &#123;<span class="comment">// 生产环境</span></span><br><span class="line">            buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://release.cn/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">            signingConfig signingConfigs.release<span class="comment">//设置签名信息</span></span><br><span class="line">            pseudoLocalesEnabled <span class="keyword">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">            applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">            versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;<span class="comment">// 测试环境</span></span><br><span class="line">            buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://test.com/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">            signingConfig signingConfigs.debug<span class="comment">//设置签名信息</span></span><br><span class="line">            debuggable <span class="keyword">false</span><span class="comment">//是否支持断点调试</span></span><br><span class="line">            jniDebuggable <span class="keyword">false</span><span class="comment">//是否可以调试NDK代码</span></span><br><span class="line">            renderscriptDebuggable <span class="keyword">false</span><span class="comment">//是否开启渲染脚本就是一些c写的渲染方法</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">            pseudoLocalesEnabled <span class="keyword">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">            applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">            versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;<span class="comment">//目录指向配置</span></span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]<span class="comment">//指定lib库目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packagingOptions&#123;<span class="comment">//打包时的相关配置</span></span><br><span class="line">        <span class="comment">//pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk</span></span><br><span class="line">        <span class="comment">// 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时  只用第一个 这样打包就不会报错</span></span><br><span class="line">        pickFirsts = [<span class="string">'META-INF/LICENSE'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">//merges何必 当出现重复文件时 合并重复的文件 然后打包入apk</span></span><br><span class="line">        <span class="comment">//这个是有默认值得 merges = [] 这样会把默默认值去掉  所以我们用下面这种方式 在默认值后添加</span></span><br><span class="line">        merge <span class="string">'META-INF/LICENSE'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。</span></span><br><span class="line">        exclude <span class="string">'META-INF/services/javax.annotation.processing.Processor'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        _360 &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line">            <span class="comment">//批量修改，类似一个循序遍历</span></span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [IFLYTEK_CHANNEL: name]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关</span></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">        <span class="comment">//即使报错也不会停止打包</span></span><br><span class="line">        checkReleaseBuilds <span class="keyword">false</span></span><br><span class="line">        <span class="comment">//打包release版本的时候进行检测</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//项目的依赖关系</span></span><br><span class="line">    implementation fileTree(<span class="keyword">include</span>: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span><br><span class="line">    <span class="comment">//本地jar包依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:27.1.1'</span></span><br><span class="line">    <span class="comment">//远程依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="comment">//声明测试用例库</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Studio是采用gradle来构建项目的，gradle是基于groovy语言的，如果只是用它构建普通Android项目的话，是可以不去学groovy的。当我们创建一个Android项目时会包含两个Android build.gradle配置详解文件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164601.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Gradle" scheme="https://zhangmiao.cc/categories/Android/Gradle/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Gradle" scheme="https://zhangmiao.cc/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android_Studio_3.5：稳步推进ProjectMarble计划</title>
    <link href="https://zhangmiao.cc/posts/4fc3338f.html"/>
    <id>https://zhangmiao.cc/posts/4fc3338f.html</id>
    <published>2019-09-10T03:39:37.000Z</published>
    <updated>2019-09-10T03:54:24.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910115202.png" alt></p><p>我们在 Android Studio 3.5 中引入了许多质量变更，请参阅《<a href="https://developer.android.google.cn/studio/releases#3-5-0" target="_blank" rel="noopener">Android Studio 3.5 Beta 现已发布</a>》或者 <a href="https://android-developers.googleblog.com/2019/05/android-studio-35-beta.html" target="_blank" rel="noopener">Android Studio 版本说明</a>，查看完整版变更列表。当然，您也可以先阅读一下这篇文章或收看下方视频，快速了解一下其中的若干重要变更:</p><ul><li><strong>腾讯视频链接:</strong> <a href="https://link.juejin.im?target=https%3A%2F%2Fv.qq.com%2Fx%2Fpage%2Fw0919w56970.html" target="_blank" rel="noopener">v.qq.com/x/page/w091…</a></li><li><strong>Bilibili 视频链接:</strong> <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav65716536%2F" target="_blank" rel="noopener">www.bilibili.com/video/av657…</a></li></ul><h2 id="系统健康"><a href="#系统健康" class="headerlink" title="系统健康"></a>系统健康</h2><p>Project Marble 计划中系统健康方面的改进包括: 内存性能、输入与用户界面冻结、构建速度、CPU 使用以及 I/O 性能。我们针对这五点分别设计了新的监测机制，以便在开发过程中更准确地识别问题，此外，流程上的优化也让团队得以更好地分析用户反馈，从开发者自愿分享的统计数据和错误报告中获取更多洞见。</p><p>尽管系统健康的许多优化项可能并不为大家所熟知，不过其中还是有几个比较明显的变更，其中包括:</p><p><strong>自动推荐内存设置</strong></p><p>在 Android Studio 3.5 中，IDE 会识别出一个应用项目在 RAM 容量更高的机器上何时需要更多的 RAM，并在通知开发者增加内存堆大小；或者您也可以在 Appearance &amp; Behavior → Memory Settings 下自行调整设置。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114337.png" alt></p><p><strong>用户界面冻结</strong></p><p>在 Project Marble 计划开发期间，我们在产品分析数据中发现 IDE 中的 XML 代码编辑速度明显较慢。我们基于这个数据点优化了 XML 输入，使得 Android Studio 3.5 的性能表现有了极大的提升。从以下两张图中您可以发现，得益于输入延迟的改进，使用 XML 编辑数据绑定表达式的速度明显加快了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/29/16cdb222b4adbb4e?imageslim" alt="img">改进前: 在 Android Studio 3.4 中编辑代码</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/29/16cdb228e68e5701?imageslim" alt="img">改进后: 在 Android Studio 3.5 中编辑代码</p><p><strong>构建速度</strong></p><p>为了提高 Android Studio 3.5 的构建速度，我们采取了许多措施，其中最为重要的一项变更是为<a href="https://developer.android.google.cn/studio/build/optimize-your-build.html#annotation_processors" target="_blank" rel="noopener">顶级注释处理器</a>添加增量构建支持，这些处理器包括 Glide、AndroidX data binding、Dagger、Realm 和 Kotlin (KAPT)。增量支持能够显著提高构建速度。更多内容，请阅读<a href="https://mp.weixin.qq.com/s/AyBkfNL_vodQVLgaZOD6kQ" target="_blank" rel="noopener">《在 Android Studio 中加快构建速度</a>》。</p><p><strong>磁盘 I/O 文件访问速度</strong></p><p>Android Studio 的许多用户都在使用微软旗下的 Windows 系统。我们发现与其他平台相比，Windows 的磁盘 I/O 文件访问耗时明显更久。深度分析数据后，我们发现在一些杀毒程序在默认设置下，并未将 Android Studio 的构建输出文件夹 (build output folder) 排除在扫描范围之外。在 Android Studio 3.5 中，一旦系统监测到这个情况，Studio 将通过弹窗引导您进行最优设置。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114351.png" alt></p><h2 id="特性优化"><a href="#特性优化" class="headerlink" title="特性优化"></a>特性优化</h2><p>除改善系统健康之外，我们还重新检查了一些关键用户流程， 修复了一些错误以及若干导致不良用户体验的问题，涉及领域包括: 数据绑定、布局、Chrome OS 支持和项目升级，而应用部署流则是其中较为关键的一项改进。</p><p><strong>Apply Changes</strong></p><p>在 Project Marble 计划期间，我们移除了 Instant Run，然后在 Android Studio 3.5 中重新构建并实现了一个更加实用的替代方案，即 <a href="https://developer.android.google.cn/studio/run#apply-changes" target="_blank" rel="noopener">Apply Changes</a>。Apply Changes 使用 Android Oreo 及以上版本中的平台特定 API 来确保可靠且一致的系统行为。与 Instant Run 的机制不同，更改系统配置并不会重写您的 APK 文件。为了支持此项变更，我们重构了整个部署管道，以此提升部署速度；与此同时，我们还微调了工具栏中的运行与部署按钮，希望借此为您提供更为精简的开发体验。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114405.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114418.png" alt></p><p>总结一下，Android Studio 3.5 共修复几百个错误，并针对以下核心领域引入了若干关键变更:</p><p><strong>系统健康</strong></p><ul><li>内存设置</li><li>内存使用报告</li><li>减少异常</li><li>用户界面冻结</li><li>构建速度</li><li>IDE 速度</li><li>Lint 代码分析</li><li>I/O 文件访问</li><li>模拟器 CPU 使用</li></ul><p><strong>特性优化</strong></p><ul><li>Apply Changes</li><li>Gradle 同步</li><li>项目更新</li><li>布局编辑器</li><li>数据绑定</li><li>应用部署</li><li>C++ 改进</li><li>Intellij 2019 平台升级</li><li>动态特性支持之条件交付</li><li>模拟器对可折叠设备及 Google Pixel 设备的支持</li><li>Chrome OS 支持</li></ul><p>更多内容，请参阅<a href="https://developer.android.google.cn/studio/releases#3-5-0" target="_blank" rel="noopener"> Android Studio 版本说明</a>，或阅读下列与 Project Marble 计划相关的深度学习专栏或收看 Google I/O 专题分享会:</p><ul><li>Project Marble 计划: Apply Changes： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-studio-project-marble-apply-changes-e3048662e8cd" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>在 Android Studio 中加快构建速度： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fimproving-build-speed-in-android-studio-3e1425274837" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Android 模拟器: Project Marble 计划改进项： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-emulator-project-marble-improvements-1175a934941e" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Android Studio Project Marble 计划: Lint 性能： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-studio-project-marble-lint-performance-8baedbff2521" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Android Studio Project Marble 计划: 布局编辑器： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-studio-project-marble-layout-editor-608b6704957a" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Google I/O: Marble 计划 — Android 开发工具有哪些更新? <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D8rfvfojtRss" target="_blank" rel="noopener">www.youtube.com/watch?v=8rf…</a></li></ul><h2 id="自愿数据分享与反馈"><a href="#自愿数据分享与反馈" class="headerlink" title="自愿数据分享与反馈"></a>自愿数据分享与反馈</h2><p>我们基于开发者提交的反馈与指标数据，判断 Android Studio 中有哪些内容适用于 Project Marble 计划，并决定具体的优化项目和实现手段。开发者可自愿在 Android Studio 内勾选数据分享，收集上来的数据将帮助团队判定产品是否含有波及全体用户的问题，接着在此基础上，调整功能开发工作的顺序，优先解决最令用户头疼的问题。为了获取最优洞见，我们在产品整合了多种不同的反馈渠道，指标数据分享是其中最基本的一款反馈工具，您可通过以下路径在 Android Studio 中启用该功能 Preferences /Settings → Appearance &amp; Behavior → Data Sharing。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114430.png" alt></p><p> 不知道您今年是否留意到 IDE 右下角的用户心情标志。Android Studio 通过这个小小的心情标志，了解用户的使用感受，并获取与实际用例相关的反馈。这是用户向团队提交错误报告最快的途径。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114442.png" alt></p><h2 id="即刻体验"><a href="#即刻体验" class="headerlink" title="即刻体验"></a>即刻体验</h2><p><strong>下载</strong></p><p>请前往<a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">下载页面</a>，获取 Android Studio 3.5。如果您当前正在使用旧版本的 Android Studio，请直接进行升级操作即可。</p><p>如需使用上述 Android 模拟器特性，请确保您正在运行通过 Android Studio SDK 管理器下载的 Android 模拟器 v29.1.9 或更高版本。</p><p>非常感谢大家继续踊跃反馈，与我们分享您的所感所想，建议与意见，或者任何您期望看到的新特性。如果您遇到任何错误或问题，请<a href="https://source.android.google.cn/source/report-bugs#developer-tools" target="_blank" rel="noopener">提交错误报告</a>，或在评论区留言。</p><p><a href="[http://services.google.cn/fb/forms/yourquestions/](http://services.google.cn/fb/forms/yourquestions/)">点击这里</a>提交产品反馈建议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910115202.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我们在 Android Studio 3.5 中引入了许多质量变更，请参阅《&lt;a href=&quot;https://developer.android.google.cn/studio/releases#3-5-0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio 3.5 Beta 现已发布&lt;/a&gt;》或者 &lt;a href=&quot;https://android-developers.googleblog.com/2019/05/android-studio-35-beta.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio 版本说明&lt;/a&gt;，查看完整版变更列表。当然，您也可以先阅读一下这篇文章或收看下方视频，快速了解一下其中的若干重要变更:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;腾讯视频链接:&lt;/strong&gt; &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fv.qq.com%2Fx%2Fpage%2Fw0919w56970.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v.qq.com/x/page/w091…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bilibili 视频链接:&lt;/strong&gt; &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav65716536%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.bilibili.com/video/av657…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;系统健康&quot;&gt;&lt;a href=&quot;#系统健康&quot; class=&quot;headerlink&quot; title=&quot;系统健康&quot;&gt;&lt;/a&gt;系统健康&lt;/h2&gt;&lt;p&gt;Project Marble 计划中系统健康方面的改进包括: 内存性能、输入与用户界面冻结、构建速度、CPU 使用以及 I/O 性能。我们针对这五点分别设计了新的监测机制，以便在开发过程中更准确地识别问题，此外，流程上的优化也让团队得以更好地分析用户反馈，从开发者自愿分享的统计数据和错误报告中获取更多洞见。&lt;/p&gt;
&lt;p&gt;尽管系统健康的许多优化项可能并不为大家所熟知，不过其中还是有几个比较明显的变更，其中包括:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动推荐内存设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Android Studio 3.5 中，IDE 会识别出一个应用项目在 RAM 容量更高的机器上何时需要更多的 RAM，并在通知开发者增加内存堆大小；或者您也可以在 Appearance &amp;amp; Behavior → Memory Settings 下自行调整设置。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="Android Studio" scheme="https://zhangmiao.cc/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器输入URL回车之后发生了什么</title>
    <link href="https://zhangmiao.cc/posts/d674143a.html"/>
    <id>https://zhangmiao.cc/posts/d674143a.html</id>
    <published>2019-09-09T03:43:23.000Z</published>
    <updated>2019-09-09T04:15:51.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅.</p><p><strong>注意：</strong>本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><p><strong>大致流程</strong></p><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><a id="more"></a><h3 id="URL-解析"><a href="#URL-解析" class="headerlink" title="URL 解析"></a>URL 解析</h3><h4 id="地址解析："><a href="#地址解析：" class="headerlink" title="地址解析："></a>地址解析：</h4><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><h4 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h4><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<strong>你所不知道的 HSTS</strong>[1]。</p><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><h4 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120457.png" alt></p><h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120545.png" alt></p><h4 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h4><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><h4 id="2-操作系统缓存"><a href="#2-操作系统缓存" class="headerlink" title="2. 操作系统缓存"></a>2. 操作系统缓存</h4><p>操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><h4 id="3-路由器缓存"><a href="#3-路由器缓存" class="headerlink" title="3. 路由器缓存"></a>3. 路由器缓存</h4><p>路由器也有自己的缓存。</p><h4 id="4-ISP-DNS-缓存"><a href="#4-ISP-DNS-缓存" class="headerlink" title="4. ISP DNS 缓存"></a>4. ISP DNS 缓存</h4><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><h4 id="根域名服务器查询"><a href="#根域名服务器查询" class="headerlink" title="根域名服务器查询"></a>根域名服务器查询</h4><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120558.png" alt></p><p>根域名服务器（维基百科）</p><h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</li><li>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><h3 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120712.png" alt></p><h4 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a>1. 应用层：发送 HTTP 请求</h4><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h4 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a>2. 传输层：TCP 传输报文</h4><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>“</p><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p><p>相关知识点：</p><ol><li>SYN 泛洪攻击</li></ol><p>”</p></blockquote><h4 id="3-网络层：IP协议查询Mac地址"><a href="#3-网络层：IP协议查询Mac地址" class="headerlink" title="3. 网络层：IP协议查询Mac地址"></a>3. 网络层：IP协议查询Mac地址</h4><p>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>“</p><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p><p>”</p></blockquote><h4 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a>4. 链路层：以太网协议</h4><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><p><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p><strong>注意</strong>：接收方回应是单播。</p><blockquote><p>“</p><p>相关知识点：</p><ol><li>ARP 攻击</li></ol><p>”</p></blockquote><h4 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a>服务器接受请求</h4><p>接受过程就是把以上步骤逆转过来，参见上图。</p><h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><h4 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121029.png" alt></p><h4 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h4><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>假如服务器配置了 HTTP 重定向，就会返回一个 <code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>“</p><p>关于更多：<strong>详见这篇文章</strong>[2]</p><p>”</p></blockquote><h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h3 id="浏览器接受响应"><a href="#浏览器接受响应" class="headerlink" title="浏览器接受响应"></a>浏览器接受响应</h3><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 <strong>MIME</strong>[3] 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121308.png" alt></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121319.png" alt></p><h4 id="6-1-HTML-解析"><a href="#6-1-HTML-解析" class="headerlink" title="6.1. HTML 解析"></a>6.1. HTML 解析</h4><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><p><strong>① 解码（encoding）</strong></p><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p><p><strong>② 预解析（pre-parsing）</strong></p><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p><p><strong>③ 符号化（Tokenization）</strong></p><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p><p><strong>④ 构建树（tree construction）</strong></p><blockquote><p>“</p><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p><p>”</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;    &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;h1&gt;Web page parsing&lt;/h1&gt;        &lt;p&gt;This is an example Web page.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121435.png" alt></p><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p><h4 id="6-2-CSS-解析"><a href="#6-2-CSS-解析" class="headerlink" title="6.2. CSS 解析"></a>6.2. CSS 解析</h4><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<strong>语法规范</strong>[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><h4 id="6-3-渲染树"><a href="#6-3-渲染树" class="headerlink" title="6.3. 渲染树"></a>6.3. 渲染树</h4><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>“</p><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p><p>”</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p><ol><li>标签名、class、id</li><li>是否内联样式</li><li><code>!important</code></li></ol><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong></p><p>当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<strong>这篇文章</strong>[5]</p><h4 id="6-4-布局与绘制"><a href="#6-4-布局与绘制" class="headerlink" title="6.4. 布局与绘制"></a>6.4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="6-5-合并渲染层"><a href="#6-5-合并渲染层" class="headerlink" title="6.5. 合并渲染层"></a>6.5. 合并渲染层</h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-6-回流与重绘"><a href="#6-6-回流与重绘" class="headerlink" title="6.6. 回流与重绘"></a>6.6. 回流与重绘</h4><p><strong>回流(reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p><p>reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li></ul><h4 id="6-7-JavaScript-编译执行"><a href="#6-7-JavaScript-编译执行" class="headerlink" title="6.7. JavaScript 编译执行"></a>6.7. JavaScript 编译执行</h4><p><strong>大致流程</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121453.png" alt></p><p>可以分为三个阶段：</p><h5 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h5><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将<code>var a = 2</code>，，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h5 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h5><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong></p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li><p>创建变量对象</p></li><li><ul><li>参数、函数、变量</li></ul></li><li><p>建立作用域链</p></li><li><ul><li>确认当前执行环境是否能访问变量</li></ul></li><li><p>确定 This 指向</p></li></ul><h5 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h5><p><strong>JS 线程</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121506.png" alt></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>“</p><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p><p>”</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong></p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li></ul><p><strong>微任务</strong></p><p>微任务是ES6和Node环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121522.png" alt></p><p><strong>代码例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;); // 宏任务 同步</span><br><span class="line">setTimeout(function() &#123;    console.log(&apos;2&apos;); // 宏任务 异步&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;    console.log(&apos;3&apos;); // 宏任务 同步    resolve();&#125;).then(function() &#123;    console.log(&apos;4&apos;) // 微任务&#125;)</span><br><span class="line">console.log(&apos;5&apos;) // 宏任务 同步</span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><p><strong>参考文档</strong></p><p>[1] 你所不知道的 HSTS: <a href="http://t.cn/AiR8pTqx" target="_blank" rel="noopener">http://t.cn/AiR8pTqx</a></p><p>[2] 详见这篇文章: <a href="http://t.cn/AiR8pnEC" target="_blank" rel="noopener">http://t.cn/AiR8pnEC</a></p><p>[3] MIME: <a href="http://t.cn/AiR8prtm" target="_blank" rel="noopener">http://t.cn/AiR8prtm</a></p><p>[4] 语法规范: <a href="http://t.cn/AiR80GdO" target="_blank" rel="noopener">http://t.cn/AiR80GdO</a></p><p>[5] 这篇文章: <a href="http://t.cn/AiR80c1k" target="_blank" rel="noopener">http://t.cn/AiR80c1k</a></p><p>[6] what-happens-when-zh_CN: <a href="http://t.cn/AiR80xb5" target="_blank" rel="noopener">http://t.cn/AiR80xb5</a></p><p>[7] Tags to DOM:<a href="http://t.cn/AiR80djX" target="_blank" rel="noopener">http://t.cn/AiR80djX</a></p><p>[8] 彻底理解浏览器的缓存机制: <a href="http://t.cn/AiR8Ovob" target="_blank" rel="noopener">http://t.cn/AiR8Ovob</a></p><p>[9] 浏览器的工作原理：新式网络浏览器幕后揭秘: <a href="http://t.cn/AiR8Oz06" target="_blank" rel="noopener">http://t.cn/AiR8Oz06</a></p><p>[10] 深入浅出浏览器渲染原理: <a href="http://t.cn/AiR8O4fO" target="_blank" rel="noopener">http://t.cn/AiR8O4fO</a></p><p>[11] js引擎的执行过程（一）:<a href="http://t.cn/AiR8Ot3s" target="_blank" rel="noopener">http://t.cn/AiR8Ot3s</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。&lt;/p&gt;
&lt;p&gt;这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大致流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;URL 解析&lt;/li&gt;
&lt;li&gt;DNS 查询&lt;/li&gt;
&lt;li&gt;TCP 连接&lt;/li&gt;
&lt;li&gt;处理请求&lt;/li&gt;
&lt;li&gt;接受响应&lt;/li&gt;
&lt;li&gt;渲染页面&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="前端" scheme="https://zhangmiao.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="tips" scheme="https://zhangmiao.cc/categories/%E5%89%8D%E7%AB%AF/tips/"/>
    
    
      <category term="前端" scheme="https://zhangmiao.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="tips" scheme="https://zhangmiao.cc/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Google终于发布了Android 10正式版</title>
    <link href="https://zhangmiao.cc/posts/3609d6c4.html"/>
    <id>https://zhangmiao.cc/posts/3609d6c4.html</id>
    <published>2019-09-05T01:53:46.000Z</published>
    <updated>2019-09-05T07:08:16.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>9月4号凌晨，Google终于发布了Android 10正式版！</p><p>全新的Logo，依然沿用经典机器人，但在图标，颜色及细节上都有明显变动。新的设计是为了更加现代，更加易用。特别是文字从绿色改为了黑色，这样的变更对视觉障碍者更加友好。</p><p>除了Logo的变化，新版Android系统的命名也有重大变动。现有的命名规则是安装英文字母顺序依次选区甜品或零食来命名。如果从09年的Cupcake算起，不算08年开始的alpha和beat测试版，到现在已经用了10年。</p><p>在新的版本中将打破甜品，零食的命名规则，可能改为Android 10。David表示：“改变命名是为了避免全球不同地区的误解，某些语言里L和R是没有区分的。另外有些地方馅饼也不是甜点，棉花糖虽然味道不错，但是在世界上有很多地区是不受欢迎的食物。”</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826095720.png" alt></p><a id="more"></a><h3 id="1-创新体验"><a href="#1-创新体验" class="headerlink" title="1. 创新体验"></a>1. 创新体验</h3><p>本次Android 10带来了全新的用户体验，包括：</p><ul><li>暗黑主题</li><li>智能回复</li><li>5G网络支持</li><li>可折叠</li></ul><h4 id="1-1-暗黑主题"><a href="#1-1-暗黑主题" class="headerlink" title="1.1 暗黑主题"></a>1.1 暗黑主题</h4><p>对于用户来说（特别是低视力 &amp; 强光敏感），可提高屏幕内容可见度 &amp; 保护性。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150439.png" alt></p><h4 id="1-2-智能回复"><a href="#1-2-智能回复" class="headerlink" title="1.2 智能回复"></a>1.2 智能回复</h4><ul><li>使用机器学习来预测你在回复信息时可能会说些什么，从而提供对信息的回复建议 &amp; 建议操作</li><li>如朋友约吃饭，Google会建议你发送回应短信 &amp; 在 Google 地图中直接显示位置信息</li></ul><blockquote><p>注：本在 Android P 中已提供，但仅限于谷歌专用的应用程序；本次Android 10 中，已内置到整个通知系统中。</p></blockquote><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150534.png" alt></p><h4 id="1-3-5G网络"><a href="#1-3-5G网络" class="headerlink" title="1.3 5G网络"></a>1.3 5G网络</h4><p>针对之前已公布的5G网络，Android 10增加了对5G网络通信支持（提供了检测连接性的API），从而使得用户可以获得更加快速的网络冲凉体验。</p><h4 id="1-4-可折叠支持"><a href="#1-4-可折叠支持" class="headerlink" title="1.4 可折叠支持"></a>1.4 可折叠支持</h4><p>针对应用程序窗口的多任务处理，Android 10增加了对可折叠屏的支持：设备折叠 / 展开时提供屏幕连续性来维护应用程序状态，通过优化可折叠设备，为当今的创新设备提供无缝体验。</p><hr><h3 id="2-隐私保护"><a href="#2-隐私保护" class="headerlink" title="2. 隐私保护"></a>2. 隐私保护</h3><p>近年来，Google对于用户的隐私保护十分看重。Android 10更新中，对于隐私保护也是核心关注点，主要包括以下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150612.png" alt></p><hr><h3 id="3-安全加强"><a href="#3-安全加强" class="headerlink" title="3. 安全加强"></a>3. 安全加强</h3><p>由于Android碎片化，系统的安全性一直被诟病。在Android 10中，引入了更多的确定用户安全的特性，具体如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150700.png" alt></p><hr><h3 id="4-系统优化"><a href="#4-系统优化" class="headerlink" title="4. 系统优化"></a>4. 系统优化</h3><p>主要包括ART优化 &amp; 神经网络升级</p><h4 id="4-1-ART优化"><a href="#4-1-ART优化" class="headerlink" title="4.1 ART优化"></a>4.1 ART优化</h4><p>ART运行时的改进可以帮助您的应用程序启动得更快、消耗更少的内存、运行得更流畅。Google对ART进行了优化：</p><ul><li>在运行前，就预先编译应用程序的部分</li><li>在运行时，分代垃圾收集使垃圾收集在时间 &amp; CPU方面更高效，减少jank，并帮助应用程序在低端设备上更好地运行。</li></ul><p>以下是优化对比：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150725.png" alt></p><h4 id="4-2-神经网络升级"><a href="#4-2-神经网络升级" class="headerlink" title="4.2 神经网络升级"></a>4.2 神经网络升级</h4><ul><li>增加了大量在神经网络方面的新操作，包括ARGMAX、ARGMIN、量化LSTM &amp; 一系列性能优化</li><li>这使得加速更大范围的模型奠定了基础，比如用于目标检测和图像分割的模型</li><li>正在与硬件供应商和流行的机器学习框架（如TensorFlow）合作，优化和推出对NNAPI 1.2的支持</li></ul><hr><h3 id="关于更新推送"><a href="#关于更新推送" class="headerlink" title="关于更新推送"></a>关于更新推送</h3><ul><li>Google首先面向自身的Pixel系列设备推送</li><li>对于国内，小米成为国内第一家提供Android 10更新的公司 - 其旗下的Redmi K20 Pro 首批接收到了基于 Android 10 的 MIUI 更新</li></ul><hr><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li>每次Anroid新版本的到来，就意味着我们要进行适配。</li></ul><h3 id="回顾历史版本"><a href="#回顾历史版本" class="headerlink" title="回顾历史版本"></a>回顾历史版本</h3><p>让我们一起回忆这10年来陪伴我们的Android点心。这是每个Android 开发者的青春。</p><h3 id="Cupcake-1-5-（纸杯蛋糕）–-2009年4月"><a href="#Cupcake-1-5-（纸杯蛋糕）–-2009年4月" class="headerlink" title="Cupcake 1.5 （纸杯蛋糕）– 2009年4月"></a>Cupcake 1.5 （纸杯蛋糕）– 2009年4月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100017.png" alt></p><h3 id="Donut-1-6（甜甜圈）–-2009年9月"><a href="#Donut-1-6（甜甜圈）–-2009年9月" class="headerlink" title="Donut 1.6（甜甜圈）– 2009年9月"></a>Donut 1.6（甜甜圈）– 2009年9月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100053.png" alt></p><h3 id="Eclair-2-0-1（泡芙）–-2009年10月26日"><a href="#Eclair-2-0-1（泡芙）–-2009年10月26日" class="headerlink" title="Eclair 2.0-1（泡芙）– 2009年10月26日"></a>Eclair 2.0-1（泡芙）– 2009年10月26日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100113.png" alt></p><h3 id="Froyo-2-2（冻酸奶）–-2010年5月"><a href="#Froyo-2-2（冻酸奶）–-2010年5月" class="headerlink" title="Froyo 2.2（冻酸奶）– 2010年5月"></a>Froyo 2.2（冻酸奶）– 2010年5月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100132.png" alt></p><h3 id="Gingerbread-2-3（姜饼）–-2010年12月"><a href="#Gingerbread-2-3（姜饼）–-2010年12月" class="headerlink" title="Gingerbread 2.3（姜饼）– 2010年12月"></a>Gingerbread 2.3（姜饼）– 2010年12月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100132.png" alt></p><h3 id="Honeycomb-3-0-2（蜂巢）–-2011年2月2日"><a href="#Honeycomb-3-0-2（蜂巢）–-2011年2月2日" class="headerlink" title="Honeycomb 3.0-2（蜂巢）– 2011年2月2日"></a>Honeycomb 3.0-2（蜂巢）– 2011年2月2日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100503.png" alt></p><h3 id="Ice-Cream-Sandwich-4-0（冰淇淋三明治）–-2011年10月19日"><a href="#Ice-Cream-Sandwich-4-0（冰淇淋三明治）–-2011年10月19日" class="headerlink" title="Ice Cream Sandwich 4.0（冰淇淋三明治）– 2011年10月19日"></a>Ice Cream Sandwich 4.0（冰淇淋三明治）– 2011年10月19日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100523.png" alt></p><h3 id="Jelly-Bean-4-1-3（果冻豆）–-2012年6月28日"><a href="#Jelly-Bean-4-1-3（果冻豆）–-2012年6月28日" class="headerlink" title="Jelly Bean 4.1-3（果冻豆）– 2012年6月28日"></a>Jelly Bean 4.1-3（果冻豆）– 2012年6月28日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100541.png" alt></p><h3 id="KitKat-4-4（日本巧克力品牌）–-2013年11月01日"><a href="#KitKat-4-4（日本巧克力品牌）–-2013年11月01日" class="headerlink" title="KitKat 4.4（日本巧克力品牌）– 2013年11月01日"></a>KitKat 4.4（日本巧克力品牌）– 2013年11月01日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100603.png" alt></p><h3 id="Lollipop-5-0-1（棒棒糖）–-2014年10月15日"><a href="#Lollipop-5-0-1（棒棒糖）–-2014年10月15日" class="headerlink" title="Lollipop 5.0-1（棒棒糖）– 2014年10月15日"></a>Lollipop 5.0-1（棒棒糖）– 2014年10月15日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100631.png" alt></p><h3 id="Marshmallow-6-0（棉花糖）–-2015年9月30日"><a href="#Marshmallow-6-0（棉花糖）–-2015年9月30日" class="headerlink" title="Marshmallow 6.0（棉花糖）– 2015年9月30日"></a>Marshmallow 6.0（棉花糖）– 2015年9月30日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100652.png" alt></p><h3 id="Nougat-7-0-1（牛轧糖）–-2016年8月22日"><a href="#Nougat-7-0-1（牛轧糖）–-2016年8月22日" class="headerlink" title="Nougat 7.0-1（牛轧糖）– 2016年8月22日"></a>Nougat 7.0-1（牛轧糖）– 2016年8月22日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100800.png" alt></p><h3 id="Oreo-8-0-1（奥利奥）–-2017-年-8-月-22-日"><a href="#Oreo-8-0-1（奥利奥）–-2017-年-8-月-22-日" class="headerlink" title="Oreo 8.0-1（奥利奥）– 2017 年 8 月 22 日"></a>Oreo 8.0-1（奥利奥）– 2017 年 8 月 22 日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100819.png" alt></p><h3 id="Pie-9-0（果馅派）–-2018-年-5月-9日"><a href="#Pie-9-0（果馅派）–-2018-年-5月-9日" class="headerlink" title="Pie 9.0（果馅派）– 2018 年 5月 9日"></a>Pie 9.0（果馅派）– 2018 年 5月 9日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100845.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;9月4号凌晨，Google终于发布了Android 10正式版！&lt;/p&gt;
&lt;p&gt;全新的Logo，依然沿用经典机器人，但在图标，颜色及细节上都有明显变动。新的设计是为了更加现代，更加易用。特别是文字从绿色改为了黑色，这样的变更对视觉障碍者更加友好。&lt;/p&gt;
&lt;p&gt;除了Logo的变化，新版Android系统的命名也有重大变动。现有的命名规则是安装英文字母顺序依次选区甜品或零食来命名。如果从09年的Cupcake算起，不算08年开始的alpha和beat测试版，到现在已经用了10年。&lt;/p&gt;
&lt;p&gt;在新的版本中将打破甜品，零食的命名规则，可能改为Android 10。David表示：“改变命名是为了避免全球不同地区的误解，某些语言里L和R是没有区分的。另外有些地方馅饼也不是甜点，棉花糖虽然味道不错，但是在世界上有很多地区是不受欢迎的食物。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826095720.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="Android版本" scheme="https://zhangmiao.cc/tags/Android%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>优雅解决Android软键盘弹出时把布局顶上去</title>
    <link href="https://zhangmiao.cc/posts/f2eb3913.html"/>
    <id>https://zhangmiao.cc/posts/f2eb3913.html</id>
    <published>2019-08-27T08:12:51.000Z</published>
    <updated>2019-08-27T08:14:44.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>在你的activity中的oncreate中setContentView之前写上这个代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">getWindow</span>()<span class="selector-class">.setSoftInputMode</span>(<span class="selector-tag">WindowManager</span><span class="selector-class">.LayoutParams</span><span class="selector-class">.SOFT_INPUT_ADJUST_PAN</span>);</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>在项目的AndroidManifest.xml文件中界面对应的<activity>里加入android:windowSoftInputMode=”stateVisible|adjustResize”，这样会让屏幕整体上移。如果加上的是<br>android:windowSoftInputMode=”adjustPan”这样键盘就会覆盖屏幕。</activity></p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>把顶级的layout替换成ScrollView，或者说在顶级的Layout上面再加一层ScrollView的封装。这样就会把软键盘和输入框一起滚动了，软键盘会一直处于底部。</p><a id="more"></a><h3 id="主窗口与软键盘窗口交互设置值如下："><a href="#主窗口与软键盘窗口交互设置值如下：" class="headerlink" title="主窗口与软键盘窗口交互设置值如下："></a>主窗口与软键盘窗口交互设置值如下：</h3><table><thead><tr><th>将覆盖在主题中设置的值</th><th>值描述</th></tr></thead><tbody><tr><td>“stateUnspecified”</td><td>软键盘的状态(是否它是隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。这个是为了软件盘行为默认的设置。</td></tr><tr><td>“stateUnchanged”</td><td>软键盘被保持无论它上次是什么状态，是否可见或隐藏，当主窗口出现在前面时。</td></tr><tr><td>“stateHidden”</td><td>当用户选择该Activity时，软键盘被隐藏——也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。</td></tr><tr><td>“stateAlwaysHidden”</td><td>软键盘总是被隐藏的，当该Activity主窗口获取焦点时。</td></tr><tr><td>“stateVisible”</td><td>软键盘是可见的，当那个是正常合适的时(当用户导航到Activity主窗口时)。</td></tr><tr><td>“stateAlwaysVisible”</td><td>当用户选择这个Activity时，软键盘是可见的——也就是，也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。</td></tr><tr><td>“adjustUnspecified”</td><td>它不被指定是否该 Activity主窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局视图能够滚动他们的内容。如果有这样的一个视图，这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为设置。</td></tr><tr><td>“adjustResize”</td><td>该Activity主窗口总是被调整屏幕的大小以便留出软键盘的空间</td></tr><tr><td>“adjustPan”</td><td>该Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;h3 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerlink&quot; title=&quot;方法一：&quot;&gt;&lt;/a&gt;方法一：&lt;/h3&gt;&lt;p&gt;在你的activity中的oncreate中setContentView之前写上这个代码&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;getWindow&lt;/span&gt;()&lt;span class=&quot;selector-class&quot;&gt;.setSoftInputMode&lt;/span&gt;(&lt;span class=&quot;selector-tag&quot;&gt;WindowManager&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LayoutParams&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.SOFT_INPUT_ADJUST_PAN&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;方法二：&quot;&gt;&lt;a href=&quot;#方法二：&quot; class=&quot;headerlink&quot; title=&quot;方法二：&quot;&gt;&lt;/a&gt;方法二：&lt;/h3&gt;&lt;p&gt;在项目的AndroidManifest.xml文件中界面对应的&lt;activity&gt;里加入android:windowSoftInputMode=”stateVisible|adjustResize”，这样会让屏幕整体上移。如果加上的是&lt;br&gt;android:windowSoftInputMode=”adjustPan”这样键盘就会覆盖屏幕。&lt;/activity&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法三：&quot;&gt;&lt;a href=&quot;#方法三：&quot; class=&quot;headerlink&quot; title=&quot;方法三：&quot;&gt;&lt;/a&gt;方法三：&lt;/h3&gt;&lt;p&gt;把顶级的layout替换成ScrollView，或者说在顶级的Layout上面再加一层ScrollView的封装。这样就会把软键盘和输入框一起滚动了，软键盘会一直处于底部。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="软键盘" scheme="https://zhangmiao.cc/tags/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Android APK 安装的原理</title>
    <link href="https://zhangmiao.cc/posts/2da5bed1.html"/>
    <id>https://zhangmiao.cc/posts/2da5bed1.html</id>
    <published>2019-08-26T02:15:08.000Z</published>
    <updated>2019-08-26T02:17:48.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家有没有想过一个应用的APK是怎么被安装到安卓手机上的，安装的本质是什么？我们知道，Windows应用程序的安装包是一个可执行的压缩包，安装的过程是把压缩包中的数据和依赖库拷贝到安装目录，再在桌面或启动栏创建快捷方式，那么安卓的APK安装过程是不是也是这样的呢？本文将为大家解答这些问题。</p><h3 id="APK包的构成"><a href="#APK包的构成" class="headerlink" title="APK包的构成"></a>APK包的构成</h3><p>首先，我看一下APK包的构成，Android的APK包和Windows应用程序安装包是不同的，它只是个简单的压缩包，没有可执行的能力，我们还可以用zip工具直接解压它。</p><p>一个APK包含以下这些文件：</p><ul><li>META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF）</li><li>assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取</li><li>res目录：包含那些没有被编译到resources.arsc的资源</li><li>lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips</li><li>resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片</li><li>classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。</li><li>AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。</li></ul><p>这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。</p><a id="more"></a><h3 id="安装APK"><a href="#安装APK" class="headerlink" title="安装APK"></a>安装APK</h3><p>我们安装应用程序，最常用的方法就是在PC上运行命令adb install 加APK的文件路径，回车等待Android设备安装完成，安装成功命令行会显示Success。那么其内部是怎样的一个过程呢？</p><h4 id="1-将APK包push到手机"><a href="#1-将APK包push到手机" class="headerlink" title="1. 将APK包push到手机"></a>1. 将APK包push到手机</h4><p>首先，adb会将PC端的APK文件push到Android设备的/data/local/tmp目录下，一些手机会将拷贝的进度反馈给adb客户端，于是PC上的命令行会展示拷贝的进度。</p><h4 id="2-执行pm命令"><a href="#2-执行pm命令" class="headerlink" title="2. 执行pm命令"></a>2. 执行pm命令</h4><p>PC端的adb程序会向Android端的adbd发送shell:pm命令，于是adbd会向系统的PackageManagerService（PMS）进程发送消息，通知其安装apk包。这里我有两个理解：<br>理解一：我们平常也可以在adb shell上执行pm命令与PMS交互，那么pm应该是个独立的进程，adbd执行pm命令，是启动了pm这个进程，这个进程再向PMS进程发送消息，通知其安装APK。<br>理解二：adbd直接向PMS进程发送消息，通知其安装APK。<br>不知哪个正确，这个有待继续研究，如果有童鞋了解这个，希望能不吝赐教。</p><h4 id="3-触发安装过程"><a href="#3-触发安装过程" class="headerlink" title="3. 触发安装过程"></a>3. 触发安装过程</h4><p>PMS首先将APK包拷贝到另外一个目录/data/app，这个目录是非系统应用的apk存放的目录，与之相对应的，系统应用的apk存放的目录是/system/frameworks、/system/app和/vendor/app。<br>PMS内部有个AppDirObserver类，其监听着/data/app目录的变化，当apk被复制到/data/app目录之后，该类随即触发PMS对APK进行解析。</p><h4 id="4-APK的解析"><a href="#4-APK的解析" class="headerlink" title="4. APK的解析"></a>4. APK的解析</h4><p>我们可以先想想，Android系统是如何启动一个APP的？比如点击屏幕上的应用图标，然后一个Activity就被启动了。这个过程中，桌面程序Launcher先是向ActivityManagerService（AMS）进程发送了一个Intent，AMS随即会将这个Intent扔给PMS，PMS则解析这个Intent得到Activity的信息给到AMS，然后AMS会启动一个空进程，并通知该进程创建该Activity。那么PMS为什么会有这个Activity的信息呢？</p><p>这就是PMS解析APK要做的事情了，而解析APK的时机又要分成两种场景：</p><p><strong>1. 系统启动时解析APK</strong><br>Android系统在启动的时候，会启动一个system_server进程，这个进程驻留着系统多个重要的服务，其中便包含了与APK最相关的PackageManagerService服务，这个服务在启动的时候，会扫描Android系统中几个目标文件夹中的APK，对每个APK进行解析。</p><p><strong>2. 安装过程中解析APK</strong><br>安装一个apk的过程，PMS也会对这个APK进行解析，其调用的是PackageManagerService.java的scanPackageLI()方法，其实在系统启动时扫描全部apk的过程也是调用该方法。</p><p>可以这样理解，系统启动的时候，是解析已经安装的所有APK，而安装单个APK时，则是用同样的方法解析这个APK，过程是一样的。</p><p><strong>那么解析APK具体做的是什么事情呢？</strong></p><p>其中主要的过程就是解析APK中的AndroidManifest.xml文件，将APK的关键信息四大组件信息、权限信息等存储在内存中的PackageParser对象中，PackageParser对象的结构如图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826101647.png" alt></p><p>这个PackageParser包含了IntentFilter的信息，使得PMS可以根据Intent来获取一个Activity的信息。那么，PMS在得到PackageParser对象之后，接着会将这个APK的信息加入到PMS自身管理中去，比如将Activity的数据保存在mActivities对象中，将Provider的数据保存在mProviders对象中等，PKMS提供了好几个重要数据结构来保存这些数据，这些数据结构的相关信息如图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826101712.png" alt></p><p>除了解析和保存APK的核心数据，PMS还会创建应用程序目录：/data/data/包名，同时提取apk中的dex文件并保存到/data/dalvik-cache中，如果该APK包含了native动态库，则需要将它们从APK文件中解压并复制到对应目录中，以及对APK进行dex优化，还有其它一些细节比如APK签名的校验，杀死APK所在进程（覆盖安装的情况）等，安装过程的最后，会发送ACTION_PACKAGE_ADDED广播，通知所有其它应用有新应用安装了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，APK安装过程就结束了。纵观整个过程，apk安装的关键就是解析AndroidManifest.xml，将重要的信息保存在PMS进程的内存中，以保证后续启动这个应用程序的组件时，可以在PMS中找到这个组件的信息。我们本来认为的更重要的代码只是进行dex优化后简单地提取到一个目录中而已，另外，APK中的资源并没有被处理，而是在启动应用进程的时候，动态去从APK包中加载而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大家有没有想过一个应用的APK是怎么被安装到安卓手机上的，安装的本质是什么？我们知道，Windows应用程序的安装包是一个可执行的压缩包，安装的过程是把压缩包中的数据和依赖库拷贝到安装目录，再在桌面或启动栏创建快捷方式，那么安卓的APK安装过程是不是也是这样的呢？本文将为大家解答这些问题。&lt;/p&gt;
&lt;h3 id=&quot;APK包的构成&quot;&gt;&lt;a href=&quot;#APK包的构成&quot; class=&quot;headerlink&quot; title=&quot;APK包的构成&quot;&gt;&lt;/a&gt;APK包的构成&lt;/h3&gt;&lt;p&gt;首先，我看一下APK包的构成，Android的APK包和Windows应用程序安装包是不同的，它只是个简单的压缩包，没有可执行的能力，我们还可以用zip工具直接解压它。&lt;/p&gt;
&lt;p&gt;一个APK包含以下这些文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF）&lt;/li&gt;
&lt;li&gt;assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取&lt;/li&gt;
&lt;li&gt;res目录：包含那些没有被编译到resources.arsc的资源&lt;/li&gt;
&lt;li&gt;lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips&lt;/li&gt;
&lt;li&gt;resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片&lt;/li&gt;
&lt;li&gt;classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。&lt;/li&gt;
&lt;li&gt;AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="Android版本" scheme="https://zhangmiao.cc/tags/Android%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
</feed>
