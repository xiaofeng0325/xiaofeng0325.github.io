<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2019-08-23T01:56:16.413Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>静态代码lint常见报错处理</title>
    <link href="https://zhangmiao.cc/posts/db4fcd4.html"/>
    <id>https://zhangmiao.cc/posts/db4fcd4.html</id>
    <published>2019-08-23T01:48:58.000Z</published>
    <updated>2019-08-23T01:56:16.413Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周做了一些关于Android静态代码检测的东西，对于一些常见的lint警告做了记录,其实对于常见的lint警告我们得处理步骤可以分为如下：</p><blockquote><ul><li>查看lint报错的错误类型</li><li>追踪到代码处，确定是否代码自身问题</li><li>分析该类错误影响范围</li><li>确定解决方式(规范代码、添加注解、添加规则)</li></ul></blockquote><h5 id="规范代码"><a href="#规范代码" class="headerlink" title="规范代码"></a>规范代码</h5><p>一般是由于开发者在开发时，不细心造成误写等，或者是某些API过时，需要进行手动修改。</p><h4 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h4><p>对于某些特殊需求，可以通过加注解来避免lint报错,以下给出常见的添加注解的地方</p><h5 id="java源代码"><a href="#java源代码" class="headerlink" title="java源代码"></a>java源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"xxxx"</span>) <span class="comment">// xxxx代表某种lint检测类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h5><p>首先添加命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace xmlns:tools="http://schemas.android.com/tools"</span><br></pre></td></tr></table></figure><p>然后在报错地方添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xxxx代表某种lint检测类型,或者可以是直接all,禁止掉所有检测类型--&gt;</span></span><br><span class="line">tools:ignore="xxxx"</span><br></pre></td></tr></table></figure><h4 id="添加规则-lint-xml文件"><a href="#添加规则-lint-xml文件" class="headerlink" title="添加规则(lint.xml文件)"></a>添加规则(lint.xml文件)</h4><p>对于某些大规模类型的，或者是知道自己必须这么干时，就可以添加规则来规避某种类型的所有lint报错或者是指定路径，亦或者是通过正则指定。<br> 添加规则格式为：<br> <strong>规避一种类型</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xxxx代表某种lint检测类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"xxxx"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>指定路径</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--xxxx代表某种lint检测类型--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--****代表指定路径或者是文件--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--####通过正则来指定相关文件或者属性等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"xxxx"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ignore</span> <span class="attr">path</span>=<span class="string">"****"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ignore</span> <span class="attr">regexp</span>=<span class="string">"####"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">issue</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>改变lint检测类型</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--xxxx代表某种lint检测类型--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--severity有不同种程度的类型  Fatal、Error 、Warning 、Information 、Ignore--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"xxxx"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>接下来记录下我见到和处理的一些报错类型</p><h4 id="1-Missing-commit-on-SharedPreference-editor"><a href="#1-Missing-commit-on-SharedPreference-editor" class="headerlink" title="1. Missing commit() on SharedPreference editor"></a>1. Missing commit() on SharedPreference editor</h4><p>缺少commit()方法调用，添加即可;但是你或许会遇到下面这个问题,它依然会lint检测报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SharedPreferencesUtils.apply(dataStore.edit() .putString(xxx, xxx));</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(SharedPreferences.Editor editor)</span> </span>&#123;</span><br><span class="line">        editor.apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是这样的话，建议到指定方法调用处添加注解</p><blockquote><p>@SuppressLint(“CommitPrefEdits”)</p></blockquote><h4 id="2-Use-apply-on-SharedPreferences"><a href="#2-Use-apply-on-SharedPreferences" class="headerlink" title="2. Use apply() on SharedPreferences"></a>2. Use apply() on SharedPreferences</h4><p>建议使用apply()替换commit(),对于两个方法的区别，建议看看<a href="https://www.cnblogs.com/dd-dd/p/5688991.html" target="_blank" rel="noopener">这里</a></p><h4 id="3-Mismatched-Styleable-Custom-View-Name"><a href="#3-Mismatched-Styleable-Custom-View-Name" class="headerlink" title="3. Mismatched Styleable/Custom View Name"></a>3. Mismatched Styleable/Custom View Name</h4><p>建议在自定义View的时候，尽量保证View名称与&lt;declare-styleable 的name一致,<br> 若有特殊需求需要对指定进行添加注解.</p><blockquote><p>@SuppressLint(“CustomViewStyleable”)<br> 若存在特殊需求，则更建议在lint.xml中添加规则:<br> <issue id="CustomViewStyleable" severity="ignore"></issue></p></blockquote><h4 id="4-Duplicate-ids-across-layouts-combined-with-include-tags"><a href="#4-Duplicate-ids-across-layouts-combined-with-include-tags" class="headerlink" title="4. Duplicate ids across layouts combined with include tags"></a>4. Duplicate ids across layouts combined with include tags</h4><p>在布局中，通过<include>进来的layout，存在和父布局中相同id的view，修改建议，修改布局中id命名.</include></p><h4 id="5-Using-android-media-ExifInterface"><a href="#5-Using-android-media-ExifInterface" class="headerlink" title="5. Using android.media.ExifInterface"></a>5. Using android.media.ExifInterface</h4><p>Avoid using android.media.ExifInterface;use android.support.media.ExifInterface from the support library instead.<br> 使用support包相关替换</p><h4 id="6-Hardcoded-reference-to-sdcard"><a href="#6-Hardcoded-reference-to-sdcard" class="headerlink" title="6. Hardcoded reference to /sdcard"></a>6. Hardcoded reference to /sdcard</h4><p>Do not hardcode “/data/“; use Context.getFilesDir().getPath() instead<br> lint 给出的修改建议是使用Context.getFilesDir().getPath() 替换直接通过路径拼接，但是根据场景可以自变吧；若不想通过这种方式可以直接忽略，添加注解<br> 类似错误场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbCopyHelper</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_PATH = <span class="string">"/data/data/"</span> + BuildConfig.APPLICATION_ID + <span class="string">"/databases/"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Context context, String dbName, <span class="keyword">boolean</span> force)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(DB_PATH);</span><br></pre></td></tr></table></figure><blockquote><p>@SuppressLint(“ SdCardPath”)<br> 若存在特殊需求，则更建议在lint.xml中添加规则:<br> <issue id="SdCardPath" severity="ignore"></issue></p></blockquote><h4 id="7-Attribute-unused-on-older-versions"><a href="#7-Attribute-unused-on-older-versions" class="headerlink" title="7. Attribute unused on older versions"></a>7. Attribute unused on older versions</h4><p>建议添加规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xxxx代表某个属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"UnusedAttribute"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ignore</span> <span class="attr">regexp</span>=<span class="string">".*xxxxx.*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">issue</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-Appcompat-Custom-Widgets"><a href="#8-Appcompat-Custom-Widgets" class="headerlink" title="8. Appcompat Custom Widgets"></a>8. Appcompat Custom Widgets</h4><p>This custom view should extend android.support.v7.widget.AppCompatTextView instead<br> 建议:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加规则</span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"AppCompatCustomView"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br><span class="line">或者是添加注解</span><br><span class="line">@SuppressLint(“AppCompatCustomView”)</span><br></pre></td></tr></table></figure><h4 id="9-Restricted-API"><a href="#9-Restricted-API" class="headerlink" title="9. Restricted API"></a>9. Restricted API</h4><p>xxx can only be called from within the same library group<br> 方法只能在同一个library group中调用<br> 添加注解:</p><blockquote><p>@SuppressLint(“RestrictedApi”)<br> 或者是规则</p></blockquote><h4 id="10-Invalid-format-string"><a href="#10-Invalid-format-string" class="headerlink" title="10. Invalid format string"></a>10. Invalid format string</h4><p>在进行字符串格式化处理的时候，需要注意formatted=“false” 的影响<br> 直接添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略string的format--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"StringFormatInvalid"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于formatted=“false”的理解,在进行string.xml编写的时候，注意内容的占位符号，如果大于等于2个占位符的时候，建议使用formatted=“false”，或者使用正则方式%n$m。</p><h4 id="11-Insecure-HostnameVerifier"><a href="#11-Insecure-HostnameVerifier" class="headerlink" title="11. Insecure HostnameVerifier"></a>11. Insecure HostnameVerifier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;                    </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>场景是直接均返回true，被认为是不安全的操作，若知道自己在干什么，可以直接添加注解</p><blockquote><p>@SuppressLint(“AllowAllHostnameVerifier”)</p></blockquote><p>或者添加规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略业务中总是返回true--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"BadHostnameVerifier"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="12-Insecure-TLS-SSL-trust-manager"><a href="#12-Insecure-TLS-SSL-trust-manager" class="headerlink" title="12. Insecure TLS/SSL trust manager"></a>12. Insecure TLS/SSL trust manager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">       CertificateException </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议添加规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略信任X509TrustManager带来的危险--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"TrustAllX509TrustManager"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="13-Obsolete-layout-params"><a href="#13-Obsolete-layout-params" class="headerlink" title="13. Obsolete layout params"></a>13. Obsolete layout params</h4><p>Invalid layout param in a LinearLayout: layout_centerInParent<br> 建议开发中，对布局的使用注意可用性，在参考代码的时候，注意删除修改后不可用的属性</p><h4 id="14-Static-Field-Leaks"><a href="#14-Static-Field-Leaks" class="headerlink" title="14. Static Field Leaks"></a>14. Static Field Leaks</h4><p>注意在书写单例的时候，避免使用局部context.均转换为全局上下文</p><h4 id="15-Node-can-be-replaced-by-a-TextView-with-compound-drawables"><a href="#15-Node-can-be-replaced-by-a-TextView-with-compound-drawables" class="headerlink" title="15. Node can be replaced by a TextView with compound drawables"></a>15. Node can be replaced by a TextView with compound drawables</h4><p>这个警告的产生，主要是在一个线性布局中存在一个textView和一个ImageView，认为一个textView可以实现类似的功能，而不用添加多余的嵌套和View；<br> 但是对于特定的需求，不能保证能实现想要的效果，因此建议添加规则忽略：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略对linearlayout(包含TextView和ImageView)使用的误报--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"UseCompoundDrawables"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="16-View-Holder-Candidates"><a href="#16-View-Holder-Candidates" class="headerlink" title="16. View Holder Candidates"></a>16. View Holder Candidates</h4><p>Unconditional layout inflation from view adapter: Should use View Holder pattern (use recycled view passed into this method as the second parameter) for smoother scrolling<br> 建议使用ViewHolder</p><h4 id="17-Missing-baselineAligned-attribute"><a href="#17-Missing-baselineAligned-attribute" class="headerlink" title="17. Missing baselineAligned attribute"></a>17. Missing baselineAligned attribute</h4><p>缺少baselineAligned这个属性，建议看看<a href="https://www.jianshu.com/p/07ba80fdd86a" target="_blank" rel="noopener">这里</a>，这个警告可以根据需求自行添加属性与否，或者是添加规则和注解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略建议 Set android:baselineAligned="false"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"DisableBaselineAlignment"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="18-Inefficient-layout-weight"><a href="#18-Inefficient-layout-weight" class="headerlink" title="18. Inefficient layout weight"></a>18. Inefficient layout weight</h4><p>在使用layout weight属性的时候，应保持相应属性为0dp;或者是在copy代码的时候忘记删除layout_weight代码导致lint检测报错</p><h4 id="19-Nested-layout-weights"><a href="#19-Nested-layout-weights" class="headerlink" title="19. Nested layout weights"></a>19. Nested layout weights</h4><p>在布局进行嵌套使用时，父布局与子布局都使用了android:layout_weight，根据需求进行修改;</p><h4 id="20-Useless-parent-layout"><a href="#20-Useless-parent-layout" class="headerlink" title="20. Useless parent layout"></a>20. Useless parent layout</h4><p>警告有未使用的父布局，或者是无用的父布局。<br> 根据实际需求进行忽略或者是删除相应布局</p><h4 id="21-Unused-namespace"><a href="#21-Unused-namespace" class="headerlink" title="21. Unused namespace"></a>21. Unused namespace</h4><p>命名空间重复添加，或者是删除对应属性后，命名空间未删除，删除.</p><h4 id="22-Hyphen-can-be-replaced-with-dash"><a href="#22-Hyphen-can-be-replaced-with-dash" class="headerlink" title="22. Hyphen can be replaced with dash"></a>22. Hyphen can be replaced with dash</h4><p>Replace “-“ with an “en dash” character (–, –)<br> 为了符合人性化的开发，建议直接添加规则忽略</p><h4 id="23-H-Ellipsis-string-can-be-replaced-with-ellipsis-character"><a href="#23-H-Ellipsis-string-can-be-replaced-with-ellipsis-character" class="headerlink" title="23. H Ellipsis string can be replaced with ellipsis character"></a>23. H Ellipsis string can be replaced with ellipsis character</h4><p>处理同上</p><h4 id="24-Duplicated-icons-under-different-names"><a href="#24-Duplicated-icons-under-different-names" class="headerlink" title="24. Duplicated icons under different names"></a>24. Duplicated icons under different names</h4><p>存在不同命名的同文件的icons<br> 目前的处理是添加规则忽略</p><h4 id="25-Missing-accessibility-label"><a href="#25-Missing-accessibility-label" class="headerlink" title="25. Missing accessibility label"></a>25. Missing accessibility label</h4><p>对EditTextView的使用，建议添加一个它的标签View<br> 根据需要进行忽略  或者添加android:labelfor</p><h4 id="26-Keyboard-inaccessible-widget"><a href="#26-Keyboard-inaccessible-widget" class="headerlink" title="26. Keyboard inaccessible widget"></a>26. Keyboard inaccessible widget</h4><p>一个控件（比如图片），如果没有定义focusable(可聚焦的)，却定义了是clickable（可点击的），那么是不能通过键盘访问的。所以，需要添加一个focusable=“true”;相当于指定可获取焦点.</p><h4 id="27-Usage-of-showAsAction-always"><a href="#27-Usage-of-showAsAction-always" class="headerlink" title="27. Usage of showAsAction=always"></a>27. Usage of showAsAction=always</h4><p>建议使用”ifRoom”替换”always”<br> 根据需求进行修改或者忽略</p><h4 id="28-Missing-inputType"><a href="#28-Missing-inputType" class="headerlink" title="28. Missing inputType"></a>28. Missing inputType</h4><p>This text field does not specify an inputType<br> 建议为EditText指定inputType属性</p><h4 id="29-Overdraw-Painting-regions-more-than-once"><a href="#29-Overdraw-Painting-regions-more-than-once" class="headerlink" title="29. Overdraw: Painting regions more than once"></a>29. Overdraw: Painting regions more than once</h4><p>Possible overdraw: Root element paints background @color/actionbar_color with a theme that also paints a background (inferred theme is @style/ActionTheme_NoTitle)<br> 存在过度绘制的可能性<br> 但是这个报警有点牵强，所以还是先添加规则给过滤吧</p><h4 id="30-Hardware-Id-Usage"><a href="#30-Hardware-Id-Usage" class="headerlink" title="30. Hardware Id Usage"></a>30. Hardware Id Usage</h4><p>获取设备相关信息，可以查看官方API,使用其替换方法</p><h4 id="31-Incompatible-Gradle-Versions"><a href="#31-Incompatible-Gradle-Versions" class="headerlink" title="31. Incompatible Gradle Versions"></a>31. Incompatible Gradle Versions</h4><p>不兼容依赖版本库，可通过打依赖树，进行查找</p><h4 id="贴出常见的lint-issueid和秒速，以供对照"><a href="#贴出常见的lint-issueid和秒速，以供对照" class="headerlink" title="贴出常见的lint issueid和秒速，以供对照"></a>贴出常见的lint issueid和秒速，以供对照</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"ContentDescription"</span>: Image without contentDescription</span><br><span class="line"><span class="string">"AddJavascriptInterface"</span>: addJavascriptInterface Called</span><br><span class="line"><span class="string">"ShortAlarm"</span>: Short <span class="keyword">or</span> Frequent Alarm</span><br><span class="line"><span class="string">"AllCaps"</span>: Combining textAllCaps <span class="keyword">and</span> markup</span><br><span class="line"><span class="string">"AllowAllHostnameVerifier"</span>: Insecure HostnameVerifier</span><br><span class="line"><span class="string">"AlwaysShowAction"</span>: Usage of showAsAction=always</span><br><span class="line"><span class="string">"InvalidUsesTagAttribute"</span>: Invalid <span class="keyword">name</span> attribute <span class="keyword">for</span> uses element.</span><br><span class="line"><span class="string">"MissingIntentFilterForMediaSearch"</span>: Missing intent-filter with action</span><br><span class="line">      android.media.action.MEDIA_PLAY_FROM_SEARCH</span><br><span class="line"><span class="string">"MissingMediaBrowserServiceIntentFilter"</span>: Missing intent-filter with action</span><br><span class="line">      android.media.browse.MediaBrowserService.</span><br><span class="line"><span class="string">"MissingOnPlayFromSearch"</span>: Missing onPlayFromSearch.</span><br><span class="line"><span class="string">"ImpliedTouchscreenHardware"</span>: Hardware feature touchscreen <span class="keyword">not</span> explicitly</span><br><span class="line">      marked as optional</span><br><span class="line"><span class="string">"MissingTvBanner"</span>: TV Missing Banner</span><br><span class="line"><span class="string">"MissingLeanbackLauncher"</span>: Missing Leanback Launcher Intent Filter.</span><br><span class="line"><span class="string">"MissingLeanbackSupport"</span>: Missing Leanback Support.</span><br><span class="line"><span class="string">"PermissionImpliesUnsupportedHardware"</span>: Permission Implies Unsupported</span><br><span class="line">      Hardware</span><br><span class="line"><span class="string">"UnsupportedTvHardware"</span>: Unsupported TV Hardware Feature</span><br><span class="line"><span class="string">"SupportAnnotationUsage"</span>: Incorrect support annotation usage</span><br><span class="line"><span class="string">"ShiftFlags"</span>: Dangerous Flag Constant Declaration</span><br><span class="line"><span class="string">"LocalSuppress"</span>: @SuppressLint <span class="keyword">on</span> invalid element</span><br><span class="line"><span class="string">"SwitchIntDef"</span>: Missing @IntDef in Switch</span><br><span class="line"><span class="string">"UniqueConstants"</span>: Overlapping Enumeration Constants</span><br><span class="line"><span class="string">"InlinedApi"</span>: <span class="keyword">Using</span> inlined constants <span class="keyword">on</span> older versions</span><br><span class="line"><span class="string">"Override"</span>: Method conflicts with <span class="keyword">new</span> inherited method</span><br><span class="line"><span class="string">"ObsoleteSdkInt"</span>: Obsolete SDK_INT Version Check</span><br><span class="line"><span class="string">"NewApi"</span>: Calling <span class="keyword">new</span> methods <span class="keyword">on</span> older versions</span><br><span class="line"><span class="string">"UnusedAttribute"</span>: Attribute unused <span class="keyword">on</span> older versions</span><br><span class="line"><span class="string">"AppCompatMethod"</span>: <span class="keyword">Using</span> Wrong AppCompat Method</span><br><span class="line"><span class="string">"AppCompatCustomView"</span>: Appcompat Custom Widgets</span><br><span class="line"><span class="string">"AppCompatResource"</span>: Menu namespace</span><br><span class="line"><span class="string">"GoogleAppIndexingApiWarning"</span>: Missing support <span class="keyword">for</span> Firebase App Indexing Api</span><br><span class="line"><span class="string">"GoogleAppIndexingWarning"</span>: Missing support <span class="keyword">for</span> Firebase App Indexing</span><br><span class="line"><span class="string">"AppLinksAutoVerifyError"</span>: App Links <span class="keyword">Auto</span> Verification Failure</span><br><span class="line"><span class="string">"AppLinksAutoVerifyWarning"</span>: Potential App Links <span class="keyword">Auto</span> Verification Failure</span><br><span class="line"><span class="string">"AppLinkUrlError"</span>: URL <span class="keyword">not</span> supported by app <span class="keyword">for</span> Firebase App Indexing</span><br><span class="line"><span class="string">"TestAppLink"</span>: Unmatched URLs</span><br><span class="line"><span class="string">"InconsistentArrays"</span>: Inconsistencies in array element counts</span><br><span class="line"><span class="string">"Assert"</span>: Assertions</span><br><span class="line"><span class="string">"BadHostnameVerifier"</span>: Insecure HostnameVerifier</span><br><span class="line"><span class="string">"BatteryLife"</span>: Battery Life Issues</span><br><span class="line"><span class="string">"BackButton"</span>: Back button</span><br><span class="line"><span class="string">"ButtonCase"</span>: Cancel/OK dialog button capitalization</span><br><span class="line"><span class="string">"ButtonOrder"</span>: Button order</span><br><span class="line"><span class="string">"ButtonStyle"</span>: Button should be borderless</span><br><span class="line"><span class="string">"ByteOrderMark"</span>: Byte order mark inside <span class="keyword">files</span></span><br><span class="line"><span class="string">"MissingSuperCall"</span>: Missing Super <span class="keyword">Call</span></span><br><span class="line"><span class="string">"AdapterViewChildren"</span>: AdapterViews cannot have children in XML</span><br><span class="line"><span class="string">"ScrollViewCount"</span>: ScrollViews can have only one child</span><br><span class="line"><span class="string">"PermissionImpliesUnsupportedChromeOsHardware"</span>: Permission Implies Unsupported</span><br><span class="line">      Chrome OS Hardware</span><br><span class="line"><span class="string">"UnsupportedChromeOsHardware"</span>: Unsupported Chrome OS Hardware Feature</span><br><span class="line"><span class="string">"GetInstance"</span>: Cipher.getInstance with ECB</span><br><span class="line"><span class="string">"CommitTransaction"</span>: Missing commit() <span class="keyword">calls</span></span><br><span class="line"><span class="string">"Recycle"</span>: Missing recycle() <span class="keyword">calls</span></span><br><span class="line"><span class="string">"CommitPrefEdits"</span>: Missing commit() <span class="keyword">on</span> SharedPreference editor</span><br><span class="line"><span class="string">"ApplySharedPref"</span>: Use apply() <span class="keyword">on</span> SharedPreferences</span><br><span class="line"><span class="string">"ClickableViewAccessibility"</span>: Accessibility in Custom Views</span><br><span class="line"><span class="string">"EasterEgg"</span>: Code contains easter egg</span><br><span class="line"><span class="string">"StopShip"</span>: Code contains STOPSHIP marker</span><br><span class="line"><span class="string">"MissingConstraints"</span>: Missing Constraints in ConstraintLayout</span><br><span class="line"><span class="string">"VulnerableCordovaVersion"</span>: Vulnerable Cordova Version</span><br><span class="line"><span class="string">"CustomViewStyleable"</span>: Mismatched Styleable/Custom <span class="keyword">View</span> <span class="keyword">Name</span></span><br><span class="line"><span class="string">"CutPasteId"</span>: Likely cut &amp; paste mistakes</span><br><span class="line"><span class="string">"SimpleDateFormat"</span>: Implied locale in date format</span><br><span class="line"><span class="string">"SetTextI18n"</span>: TextView Internationalization</span><br><span class="line"><span class="string">"Deprecated"</span>: <span class="keyword">Using</span> deprecated resources</span><br><span class="line"><span class="string">"MissingPrefix"</span>: Missing Android XML namespace</span><br><span class="line"><span class="string">"MangledCRLF"</span>: Mangled file <span class="keyword">line</span> endings</span><br><span class="line"><span class="string">"DuplicateIncludedIds"</span>: Duplicate ids across layouts combined with include</span><br><span class="line">      tags</span><br><span class="line"><span class="string">"DuplicateIds"</span>: Duplicate ids within a single layout</span><br><span class="line"><span class="string">"DuplicateDefinition"</span>: Duplicate definitions of resources</span><br><span class="line"><span class="string">"ReferenceType"</span>: Incorrect reference types</span><br><span class="line"><span class="string">"StringEscaping"</span>: Invalid string escapes</span><br><span class="line"><span class="string">"UnpackedNativeCode"</span>: Missing android:extractNativeLibs=false</span><br><span class="line"><span class="string">"UnsafeDynamicallyLoadedCode"</span>: <span class="keyword">load</span> used <span class="keyword">to</span> dynamically <span class="keyword">load</span> code</span><br><span class="line"><span class="string">"UnsafeNativeCodeLocation"</span>: Native code outside library directory</span><br><span class="line"><span class="string">"EllipsizeMaxLines"</span>: Combining Ellipsize <span class="keyword">and</span> Maxlines</span><br><span class="line"><span class="string">"ExifInterface"</span>: <span class="keyword">Using</span> android.media.ExifInterface</span><br><span class="line"><span class="string">"ExtraText"</span>: Extraneous text in resource <span class="keyword">files</span></span><br><span class="line"><span class="string">"FieldGetter"</span>: <span class="keyword">Using</span> getter instead of <span class="keyword">field</span></span><br><span class="line"><span class="string">"InvalidAnalyticsName"</span>: Invalid Analytics <span class="keyword">Name</span></span><br><span class="line"><span class="string">"MissingFirebaseInstanceTokenRefresh"</span>: Missing Firebase Instance ID Token</span><br><span class="line">      Refresh</span><br><span class="line"><span class="string">"FontValidationError"</span>: Validation of font <span class="keyword">files</span></span><br><span class="line"><span class="string">"FontValidationWarning"</span>: Validation of font <span class="keyword">files</span></span><br><span class="line"><span class="string">"FullBackupContent"</span>: Valid Full Backup Content File</span><br><span class="line"><span class="string">"ValidFragment"</span>: Fragment <span class="keyword">not</span> instantiatable</span><br><span class="line"><span class="string">"GetContentDescriptionOverride"</span>: Overriding getContentDescription() <span class="keyword">on</span> a <span class="keyword">View</span></span><br><span class="line"><span class="string">"PackageManagerGetSignatures"</span>: Potential Multiple Certificate Exploit</span><br><span class="line"><span class="string">"AccidentalOctal"</span>: Accidental Octal</span><br><span class="line"><span class="string">"UseOfBundledGooglePlayServices"</span>: Use of bundled version of Google <span class="keyword">Play</span></span><br><span class="line">      services</span><br><span class="line"><span class="string">"GradleCompatible"</span>: Incompatible Gradle Versions</span><br><span class="line"><span class="string">"GradleDependency"</span>: Obsolete Gradle Dependency</span><br><span class="line"><span class="string">"GradleDeprecated"</span>: Deprecated Gradle Construct</span><br><span class="line"><span class="string">"DevModeObsolete"</span>: Dev Mode Obsolete</span><br><span class="line"><span class="string">"DuplicatePlatformClasses"</span>: Duplicate Platform Classes</span><br><span class="line"><span class="string">"GradleGetter"</span>: Gradle Implicit Getter <span class="keyword">Call</span></span><br><span class="line"><span class="string">"GradlePluginVersion"</span>: Incompatible Android Gradle Plugin</span><br><span class="line"><span class="string">"HighAppVersionCode"</span>: VersionCode too high</span><br><span class="line"><span class="string">"GradleIdeError"</span>: Gradle IDE Support Issues</span><br><span class="line"><span class="string">"GradlePath"</span>: Gradle Path Issues</span><br><span class="line"><span class="string">"GradleDynamicVersion"</span>: Gradle Dynamic Version</span><br><span class="line"><span class="string">"NotInterpolated"</span>: Incorrect Interpolation</span><br><span class="line"><span class="string">"StringShouldBeInt"</span>: String should be <span class="keyword">int</span></span><br><span class="line"><span class="string">"NewerVersionAvailable"</span>: Newer Library Versions Available</span><br><span class="line"><span class="string">"MinSdkTooLow"</span>: API Version Too Low</span><br><span class="line"><span class="string">"GridLayout"</span>: GridLayout validation</span><br><span class="line"><span class="string">"HandlerLeak"</span>: Handler reference leaks</span><br><span class="line"><span class="string">"HardcodedDebugMode"</span>: Hardcoded value of android:debuggable in the manifest</span><br><span class="line"><span class="string">"HardcodedText"</span>: Hardcoded text</span><br><span class="line"><span class="string">"HardwareIds"</span>: Hardware Id Usage</span><br><span class="line"><span class="string">"IconDuplicatesConfig"</span>: Identical bitmaps across various configurations</span><br><span class="line"><span class="string">"IconDuplicates"</span>: Duplicated icons under different names</span><br><span class="line"><span class="string">"GifUsage"</span>: <span class="keyword">Using</span> .gif format <span class="keyword">for</span> bitmaps is discouraged</span><br><span class="line"><span class="string">"IconColors"</span>: Icon colors do <span class="keyword">not</span> follow the recommended visual style</span><br><span class="line"><span class="string">"IconDensities"</span>: Icon densities validation</span><br><span class="line"><span class="string">"IconDipSize"</span>: Icon density-independent size validation</span><br><span class="line"><span class="string">"IconExpectedSize"</span>: Icon has incorrect size</span><br><span class="line"><span class="string">"IconExtension"</span>: Icon format does <span class="keyword">not</span> match the file extension</span><br><span class="line"><span class="string">"IconLauncherShape"</span>: The launcher icon shape should use a distinct silhouette</span><br><span class="line"><span class="string">"IconLocation"</span>: Image defined in density-independent drawable folder</span><br><span class="line"><span class="string">"IconMissingDensityFolder"</span>: Missing density folder</span><br><span class="line"><span class="string">"IconMixedNinePatch"</span>: Clashing PNG <span class="keyword">and</span> <span class="number">9</span>-PNG <span class="keyword">files</span></span><br><span class="line"><span class="string">"IconNoDpi"</span>: Icon appears in both -nodpi <span class="keyword">and</span> dpi folders</span><br><span class="line"><span class="string">"IconXmlAndPng"</span>: Icon is specified both as .xml file <span class="keyword">and</span> as a bitmap</span><br><span class="line"><span class="string">"ConvertToWebp"</span>: Convert <span class="keyword">to</span> WebP</span><br><span class="line"><span class="string">"WebpUnsupported"</span>: WebP Unsupported</span><br><span class="line"><span class="string">"IncludeLayoutParam"</span>: Ignored layout params <span class="keyword">on</span> include</span><br><span class="line"><span class="string">"DisableBaselineAlignment"</span>: Missing baselineAligned attribute</span><br><span class="line"><span class="string">"InefficientWeight"</span>: Inefficient layout weight</span><br><span class="line"><span class="string">"NestedWeights"</span>: Nested layout weights</span><br><span class="line"><span class="string">"Orientation"</span>: Missing explicit orientation</span><br><span class="line"><span class="string">"Suspicious0dp"</span>: Suspicious <span class="number">0d</span>p dimension</span><br><span class="line"><span class="string">"InstantApps"</span>: Instant App Issues</span><br><span class="line"><span class="string">"DuplicateDivider"</span>: Unnecessary Divider Copy</span><br><span class="line"><span class="string">"TrustAllX509TrustManager"</span>: Insecure TLS/SSL trust manager</span><br><span class="line"><span class="string">"InvalidImeActionId"</span>: Invalid imeActionId declaration</span><br><span class="line"><span class="string">"InvalidPackage"</span>: Package <span class="keyword">not</span> included in Android</span><br><span class="line"><span class="string">"DrawAllocation"</span>: Memory allocations within drawing code</span><br><span class="line"><span class="string">"UseSparseArrays"</span>: HashMap can be replaced with SparseArray</span><br><span class="line"><span class="string">"UseValueOf"</span>: Should use valueOf instead of <span class="keyword">new</span></span><br><span class="line"><span class="string">"JavascriptInterface"</span>: Missing @JavascriptInterface <span class="keyword">on</span> methods</span><br><span class="line"><span class="string">"JobSchedulerService"</span>: JobScheduler problems</span><br><span class="line"><span class="string">"KeyboardInaccessibleWidget"</span>: Keyboard inaccessible widget</span><br><span class="line"><span class="string">"LabelFor"</span>: Missing labelFor attribute</span><br><span class="line"><span class="string">"InconsistentLayout"</span>: Inconsistent Layouts</span><br><span class="line"><span class="string">"InflateParams"</span>: Layout Inflation without a Parent</span><br><span class="line"><span class="string">"StaticFieldLeak"</span>: Static <span class="keyword">Field</span> Leaks</span><br><span class="line"><span class="string">"DefaultLocale"</span>: Implied default locale in case conversion</span><br><span class="line"><span class="string">"LocaleFolder"</span>: Wrong locale <span class="keyword">name</span></span><br><span class="line"><span class="string">"GetLocales"</span>: Locale crash</span><br><span class="line"><span class="string">"InvalidResourceFolder"</span>: Invalid Resource Folder</span><br><span class="line"><span class="string">"WrongRegion"</span>: Suspicious Language/Region Combination</span><br><span class="line"><span class="string">"UseAlpha2"</span>: <span class="keyword">Using</span> <span class="number">3</span>-letter Codes</span><br><span class="line"><span class="string">"LogConditional"</span>: Unconditional Logging <span class="keyword">Calls</span></span><br><span class="line"><span class="string">"LongLogTag"</span>: Too Long <span class="keyword">Log</span> Tags</span><br><span class="line"><span class="string">"LogTagMismatch"</span>: Mismatched <span class="keyword">Log</span> Tags</span><br><span class="line"><span class="string">"AllowBackup"</span>: AllowBackup/FullBackupContent Problems</span><br><span class="line"><span class="string">"MissingApplicationIcon"</span>: Missing application icon</span><br><span class="line"><span class="string">"DeviceAdmin"</span>: Malformed Device Admin</span><br><span class="line"><span class="string">"DuplicateActivity"</span>: Activity registered more than once</span><br><span class="line"><span class="string">"DuplicateUsesFeature"</span>: Feature declared more than once</span><br><span class="line"><span class="string">"GradleOverrides"</span>: Value overridden by Gradle build script</span><br><span class="line"><span class="string">"IllegalResourceRef"</span>: <span class="keyword">Name</span> <span class="keyword">and</span> version must be integer <span class="keyword">or</span> string, <span class="keyword">not</span></span><br><span class="line">      resource</span><br><span class="line"><span class="string">"MipmapIcons"</span>: Use Mipmap Launcher Icons</span><br><span class="line"><span class="string">"MockLocation"</span>: <span class="keyword">Using</span> mock location provider in production</span><br><span class="line"><span class="string">"MultipleUsesSdk"</span>: Multiple &lt;uses-sdk&gt; elements in the manifest</span><br><span class="line"><span class="string">"ManifestOrder"</span>: Incorrect order of elements in manifest</span><br><span class="line"><span class="string">"MissingVersion"</span>: Missing application <span class="keyword">name</span>/version</span><br><span class="line"><span class="string">"OldTargetApi"</span>: Target SDK attribute is <span class="keyword">not</span> targeting latest version</span><br><span class="line"><span class="string">"UniquePermission"</span>: Permission names are <span class="keyword">not</span> unique</span><br><span class="line"><span class="string">"UsesMinSdkAttributes"</span>: Minimum SDK <span class="keyword">and</span> target SDK attributes <span class="keyword">not</span> defined</span><br><span class="line"><span class="string">"WearableBindListener"</span>: Usage of Android Wear BIND_LISTENER is deprecated</span><br><span class="line"><span class="string">"WrongManifestParent"</span>: Wrong manifest parent</span><br><span class="line"><span class="string">"InvalidPermission"</span>: Invalid Permission Attribute</span><br><span class="line"><span class="string">"ManifestResource"</span>: Manifest Resource References</span><br><span class="line"><span class="string">"ManifestTypo"</span>: Typos in manifest tags</span><br><span class="line"><span class="string">"FloatMath"</span>: <span class="keyword">Using</span> FloatMath instead of Math</span><br><span class="line"><span class="string">"MergeMarker"</span>: Code contains <span class="keyword">merge</span> marker</span><br><span class="line"><span class="string">"MergeRootFrame"</span>: FrameLayout can be replaced with &lt;<span class="keyword">merge</span>&gt; tag</span><br><span class="line"><span class="string">"IncompatibleMediaBrowserServiceCompatVersion"</span>: Obsolete version of</span><br><span class="line">      MediaBrowserServiceCompat</span><br><span class="line"><span class="string">"InnerclassSeparator"</span>: Inner classes should use $ rather than .</span><br><span class="line"><span class="string">"Instantiatable"</span>: Registered class is <span class="keyword">not</span> instantiatable</span><br><span class="line"><span class="string">"MissingRegistered"</span>: Missing registered class</span><br><span class="line"><span class="string">"MissingId"</span>: Fragments should specify an id <span class="keyword">or</span> tag</span><br><span class="line"><span class="string">"LibraryCustomView"</span>: Custom views in libraries should use res-<span class="keyword">auto</span>-namespace</span><br><span class="line"><span class="string">"ResAuto"</span>: Hardcoded Package in Namespace</span><br><span class="line"><span class="string">"NamespaceTypo"</span>: Misspelled namespace declaration</span><br><span class="line"><span class="string">"UnusedNamespace"</span>: Unused namespace</span><br><span class="line"><span class="string">"NegativeMargin"</span>: Negative Margins</span><br><span class="line"><span class="string">"NestedScrolling"</span>: Nested scrolling widgets</span><br><span class="line"><span class="string">"NetworkSecurityConfig"</span>: Valid Network Security Config File</span><br><span class="line"><span class="string">"MissingBackupPin"</span>: Missing Backup Pin</span><br><span class="line"><span class="string">"PinSetExpiry"</span>: Validate &lt;pin-set&gt; expiration attribute</span><br><span class="line"><span class="string">"NfcTechWhitespace"</span>: Whitespace in NFC tech lists</span><br><span class="line"><span class="string">"UnlocalizedSms"</span>: SMS phone number missing country code</span><br><span class="line"><span class="string">"ObjectAnimatorBinding"</span>: Incorrect ObjectAnimator Property</span><br><span class="line"><span class="string">"AnimatorKeep"</span>: Missing @Keep <span class="keyword">for</span> Animated Properties</span><br><span class="line"><span class="string">"ObsoleteLayoutParam"</span>: Obsolete layout params</span><br><span class="line"><span class="string">"OnClick"</span>: onClick method does <span class="keyword">not</span> exist</span><br><span class="line"><span class="string">"Overdraw"</span>: Overdraw: Painting regions more than once</span><br><span class="line"><span class="string">"DalvikOverride"</span>: Method considered overridden by Dalvik</span><br><span class="line"><span class="string">"OverrideAbstract"</span>: <span class="keyword">Not</span> overriding abstract methods <span class="keyword">on</span> older platforms</span><br><span class="line"><span class="string">"ParcelCreator"</span>: Missing Parcelable CREATOR <span class="keyword">field</span></span><br><span class="line"><span class="string">"UnusedQuantity"</span>: Unused quantity translations</span><br><span class="line"><span class="string">"MissingQuantity"</span>: Missing quantity translation</span><br><span class="line"><span class="string">"ImpliedQuantity"</span>: Implied Quantities</span><br><span class="line"><span class="string">"ExportedPreferenceActivity"</span>: PreferenceActivity should <span class="keyword">not</span> be exported</span><br><span class="line"><span class="string">"PrivateApi"</span>: <span class="keyword">Using</span> Private APIs</span><br><span class="line"><span class="string">"PackagedPrivateKey"</span>: Packaged private <span class="keyword">key</span></span><br><span class="line"><span class="string">"PrivateResource"</span>: <span class="keyword">Using</span> private resources</span><br><span class="line"><span class="string">"ProguardSplit"</span>: Proguard.cfg file contains generic Android rules</span><br><span class="line"><span class="string">"Proguard"</span>: <span class="keyword">Using</span> obsolete ProGuard configuration</span><br><span class="line"><span class="string">"PropertyEscape"</span>: Incorrect property escapes</span><br><span class="line"><span class="string">"UsingHttp"</span>: <span class="keyword">Using</span> HTTP instead of HTTPS</span><br><span class="line"><span class="string">"SpUsage"</span>: <span class="keyword">Using</span> dp instead of sp <span class="keyword">for</span> text sizes</span><br><span class="line"><span class="string">"InOrMmUsage"</span>: <span class="keyword">Using</span> mm <span class="keyword">or</span> in dimensions</span><br><span class="line"><span class="string">"PxUsage"</span>: <span class="keyword">Using</span> <span class="comment">'px' dimension</span></span><br><span class="line"><span class="string">"SmallSp"</span>: Text size is too small</span><br><span class="line"><span class="string">"ParcelClassLoader"</span>: Default Parcel Class Loader</span><br><span class="line"><span class="string">"PendingBindings"</span>: Missing Pending Bindings</span><br><span class="line"><span class="string">"RecyclerView"</span>: RecyclerView Problems</span><br><span class="line"><span class="string">"Registered"</span>: Class is <span class="keyword">not</span> registered in the manifest</span><br><span class="line"><span class="string">"RelativeOverlap"</span>: Overlapping items in RelativeLayout</span><br><span class="line"><span class="string">"RequiredSize"</span>: Missing layout_width <span class="keyword">or</span> layout_height attributes</span><br><span class="line"><span class="string">"AaptCrash"</span>: Potential AAPT crash</span><br><span class="line"><span class="string">"ResourceCycle"</span>: Cycle in resource definitions</span><br><span class="line"><span class="string">"ResourceName"</span>: Resource with Wrong Prefix</span><br><span class="line"><span class="string">"ValidRestrictions"</span>: Invalid Restrictions Descriptor</span><br><span class="line"><span class="string">"RtlCompat"</span>: Right-<span class="keyword">to</span>-left text compatibility issues</span><br><span class="line"><span class="string">"RtlEnabled"</span>: <span class="keyword">Using</span> RTL attributes without enabling RTL support</span><br><span class="line"><span class="string">"RtlSymmetry"</span>: Padding <span class="keyword">and</span> margin symmetry</span><br><span class="line"><span class="string">"RtlHardcoded"</span>: <span class="keyword">Using</span> left/right instead of start/<span class="keyword">end</span> attributes</span><br><span class="line"><span class="string">"ScrollViewSize"</span>: ScrollView size validation</span><br><span class="line"><span class="string">"SdCardPath"</span>: Hardcoded reference <span class="keyword">to</span> /sdcard</span><br><span class="line"><span class="string">"SecureRandom"</span>: <span class="keyword">Using</span> a fixed seed with SecureRandom</span><br><span class="line"><span class="string">"TrulyRandom"</span>: Weak RNG</span><br><span class="line"><span class="string">"ExportedContentProvider"</span>: Content provider does <span class="keyword">not</span> require permission</span><br><span class="line"><span class="string">"ExportedReceiver"</span>: Receiver does <span class="keyword">not</span> require permission</span><br><span class="line"><span class="string">"ExportedService"</span>: Exported service does <span class="keyword">not</span> require permission</span><br><span class="line"><span class="string">"SetWorldReadable"</span>: File.setReadable() used <span class="keyword">to</span> make file world-readable</span><br><span class="line"><span class="string">"SetWorldWritable"</span>: File.setWritable() used <span class="keyword">to</span> make file world-writable</span><br><span class="line"><span class="string">"GrantAllUris"</span>: Content provider shares everything</span><br><span class="line"><span class="string">"WorldReadableFiles"</span>: openFileOutput() <span class="keyword">or</span> similar <span class="keyword">call</span> passing</span><br><span class="line">      MODE_WORLD_READABLE</span><br><span class="line"><span class="string">"WorldWriteableFiles"</span>: openFileOutput() <span class="keyword">or</span> similar <span class="keyword">call</span> passing</span><br><span class="line">      MODE_WORLD_WRITEABLE</span><br><span class="line"><span class="string">"ServiceCast"</span>: Wrong <span class="keyword">system</span> service casts</span><br><span class="line"><span class="string">"WifiManagerLeak"</span>: WifiManager Leak</span><br><span class="line"><span class="string">"WifiManagerPotentialLeak"</span>: WifiManager Potential Leak</span><br><span class="line"><span class="string">"SetJavaScriptEnabled"</span>: <span class="keyword">Using</span> setJavaScriptEnabled</span><br><span class="line"><span class="string">"SignatureOrSystemPermissions"</span>: signatureOrSystem permissions declared</span><br><span class="line"><span class="string">"SQLiteString"</span>: <span class="keyword">Using</span> STRING instead of TEXT</span><br><span class="line"><span class="string">"SSLCertificateSocketFactoryCreateSocket"</span>: Insecure <span class="keyword">call</span> <span class="keyword">to</span></span><br><span class="line">      SSLCertificateSocketFactory.createSocket()</span><br><span class="line"><span class="string">"SSLCertificateSocketFactoryGetInsecure"</span>: <span class="keyword">Call</span> <span class="keyword">to</span></span><br><span class="line">      SSLCertificateSocketFactory.getInsecure()</span><br><span class="line"><span class="string">"StateListReachable"</span>: Unreachable state in a &lt;selector&gt;</span><br><span class="line"><span class="string">"AuthLeak"</span>: Code might contain an auth leak</span><br><span class="line"><span class="string">"StringFormatCount"</span>: Formatting argument types incomplete <span class="keyword">or</span> inconsistent</span><br><span class="line"><span class="string">"StringFormatMatches"</span>: <span class="string">"String.format string doesn't match the XML format</span></span><br><span class="line"><span class="string">      string"</span></span><br><span class="line"><span class="string">"StringFormatInvalid"</span>: Invalid format string</span><br><span class="line"><span class="string">"PluralsCandidate"</span>: Potential Plurals</span><br><span class="line"><span class="string">"UseCheckPermission"</span>: <span class="keyword">Using</span> the result of check permission <span class="keyword">calls</span></span><br><span class="line"><span class="string">"CheckResult"</span>: Ignoring results</span><br><span class="line"><span class="string">"ResourceAsColor"</span>: Should pass resolved <span class="keyword">color</span> instead of resource id</span><br><span class="line"><span class="string">"MissingPermission"</span>: Missing Permissions</span><br><span class="line"><span class="string">"Range"</span>: Outside Range</span><br><span class="line"><span class="string">"ResourceType"</span>: Wrong Resource Type</span><br><span class="line"><span class="string">"RestrictedApi"</span>: Restricted API</span><br><span class="line"><span class="string">"WrongThread"</span>: Wrong Thread</span><br><span class="line"><span class="string">"WrongConstant"</span>: Incorrect constant</span><br><span class="line"><span class="string">"VisibleForTests"</span>: Visible Only <span class="keyword">For</span> Tests</span><br><span class="line"><span class="string">"ProtectedPermissions"</span>: <span class="keyword">Using</span> <span class="keyword">system</span> app permission</span><br><span class="line"><span class="string">"TextFields"</span>: Missing inputType <span class="keyword">or</span> hint</span><br><span class="line"><span class="string">"TextViewEdits"</span>: TextView should probably be an EditText instead</span><br><span class="line"><span class="string">"SelectableText"</span>: Dynamic text should probably be selectable</span><br><span class="line"><span class="string">"MenuTitle"</span>: Missing menu title</span><br><span class="line"><span class="string">"ShowToast"</span>: Toast created but <span class="keyword">not</span> shown</span><br><span class="line"><span class="string">"TooDeepLayout"</span>: Layout hierarchy is too deep</span><br><span class="line"><span class="string">"TooManyViews"</span>: Layout has too many views</span><br><span class="line"><span class="string">"ExtraTranslation"</span>: Extra translation</span><br><span class="line"><span class="string">"MissingTranslation"</span>: Incomplete translation</span><br><span class="line"><span class="string">"Typos"</span>: Spelling <span class="keyword">error</span></span><br><span class="line"><span class="string">"TypographyDashes"</span>: Hyphen can be replaced with dash</span><br><span class="line"><span class="string">"TypographyEllipsis"</span>: Ellipsis string can be replaced with ellipsis character</span><br><span class="line"><span class="string">"TypographyFractions"</span>: Fraction string can be replaced with fraction</span><br><span class="line">      character</span><br><span class="line"><span class="string">"TypographyOther"</span>: Other typographical problems</span><br><span class="line"><span class="string">"TypographyQuotes"</span>: Straight quotes can be replaced with curvy quotes</span><br><span class="line"><span class="string">"UnsafeProtectedBroadcastReceiver"</span>: Unsafe Protected BroadcastReceiver</span><br><span class="line"><span class="string">"UnprotectedSMSBroadcastReceiver"</span>: Unprotected SMS BroadcastReceiver</span><br><span class="line"><span class="string">"UnusedResources"</span>: Unused resources</span><br><span class="line"><span class="string">"UnusedIds"</span>: Unused id</span><br><span class="line"><span class="string">"UseCompoundDrawables"</span>: Node can be replaced by a TextView with compound</span><br><span class="line">      drawables</span><br><span class="line"><span class="string">"UselessLeaf"</span>: Useless leaf layout</span><br><span class="line"><span class="string">"UselessParent"</span>: Useless parent layout</span><br><span class="line"><span class="string">"EnforceUTF8"</span>: Encoding used in resource <span class="keyword">files</span> is <span class="keyword">not</span> UTF-<span class="number">8</span></span><br><span class="line"><span class="string">"VectorRaster"</span>: Vector Image Generation</span><br><span class="line"><span class="string">"VectorDrawableCompat"</span>: <span class="keyword">Using</span> VectorDrawableCompat</span><br><span class="line"><span class="string">"VectorPath"</span>: Long vector paths</span><br><span class="line"><span class="string">"InvalidVectorPath"</span>: Invalid vector paths</span><br><span class="line"><span class="string">"ViewConstructor"</span>: Missing <span class="keyword">View</span> constructors <span class="keyword">for</span> XML inflation</span><br><span class="line"><span class="string">"ViewHolder"</span>: <span class="keyword">View</span> Holder Candidates</span><br><span class="line"><span class="string">"ViewTag"</span>: Tagged object leaks</span><br><span class="line"><span class="string">"WrongViewCast"</span>: Mismatched <span class="keyword">view</span> type</span><br><span class="line"><span class="string">"FindViewByIdCast"</span>: Add Explicit Cast</span><br><span class="line"><span class="string">"Wakelock"</span>: Incorrect WakeLock usage</span><br><span class="line"><span class="string">"WakelockTimeout"</span>: <span class="keyword">Using</span> wakeLock without timeout</span><br><span class="line"><span class="string">"InvalidWearFeatureAttribute"</span>: Invalid attribute <span class="keyword">for</span> Wear uses-feature</span><br><span class="line"><span class="string">"WearStandaloneAppFlag"</span>: Invalid <span class="keyword">or</span> missing Wear standalone app flag</span><br><span class="line"><span class="string">"WebViewLayout"</span>: WebViews in wrap_content parents</span><br><span class="line"><span class="string">"WrongCall"</span>: <span class="keyword">Using</span> wrong <span class="keyword">draw</span>/layout method</span><br><span class="line"><span class="string">"WrongCase"</span>: Wrong case <span class="keyword">for</span> <span class="keyword">view</span> tag</span><br><span class="line"><span class="string">"InvalidId"</span>: Invalid ID declaration</span><br><span class="line"><span class="string">"NotSibling"</span>: RelativeLayout Invalid Constraints</span><br><span class="line"><span class="string">"UnknownId"</span>: Reference <span class="keyword">to</span> an unknown id</span><br><span class="line"><span class="string">"UnknownIdInLayout"</span>: Reference <span class="keyword">to</span> an id that is <span class="keyword">not</span> in the current layout</span><br><span class="line"><span class="string">"SuspiciousImport"</span>: import android.R statement</span><br><span class="line"><span class="string">"WrongFolder"</span>: Resource file in the wrong res folder</span><br><span class="line"><span class="string">"WrongThreadInterprocedural"</span>: Wrong Thread (Interprocedural)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>还有遇到一些简单代码规范的问题，平时注意，就能规避，比如常见的宽高，写成了sp、xp；总之就是sp、xp、dp使用混乱等一些规范问题，或者是内存泄漏风险.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一周做了一些关于Android静态代码检测的东西，对于一些常见的lint警告做了记录,其实对于常见的lint警告我们得处理步骤可以分为如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查看lint报错的错误类型&lt;/li&gt;
&lt;li&gt;追踪到代码处，确定是否代码自身问题&lt;/li&gt;
&lt;li&gt;分析该类错误影响范围&lt;/li&gt;
&lt;li&gt;确定解决方式(规范代码、添加注解、添加规则)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;规范代码&quot;&gt;&lt;a href=&quot;#规范代码&quot; class=&quot;headerlink&quot; title=&quot;规范代码&quot;&gt;&lt;/a&gt;规范代码&lt;/h5&gt;&lt;p&gt;一般是由于开发者在开发时，不细心造成误写等，或者是某些API过时，需要进行手动修改。&lt;/p&gt;
&lt;h4 id=&quot;添加注解&quot;&gt;&lt;a href=&quot;#添加注解&quot; class=&quot;headerlink&quot; title=&quot;添加注解&quot;&gt;&lt;/a&gt;添加注解&lt;/h4&gt;&lt;p&gt;对于某些特殊需求，可以通过加注解来避免lint报错,以下给出常见的添加注解的地方&lt;/p&gt;
&lt;h5 id=&quot;java源代码&quot;&gt;&lt;a href=&quot;#java源代码&quot; class=&quot;headerlink&quot; title=&quot;java源代码&quot;&gt;&lt;/a&gt;java源代码&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SuppressLint&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;xxxx&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// xxxx代表某种lint检测类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="lint" scheme="https://zhangmiao.cc/tags/lint/"/>
    
  </entry>
  
  <entry>
    <title>正确的提问方式</title>
    <link href="https://zhangmiao.cc/posts/6cc70a12.html"/>
    <id>https://zhangmiao.cc/posts/6cc70a12.html</id>
    <published>2019-08-22T07:10:34.000Z</published>
    <updated>2019-08-22T07:17:08.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提问之前"><a href="#提问之前" class="headerlink" title="提问之前"></a>提问之前</h2><ol><li>你是否在谷歌/百度/论坛上搜索过？</li><li>你是否查过手册/文档？</li><li>你是否阅读过源码？</li></ol><h2 id="正确提问"><a href="#正确提问" class="headerlink" title="正确提问"></a>正确提问</h2><ol><li>你想做什么？遇到了什么问题？你做过什么？尝试过什么解决方案？结果是什么？</li><li>附上log，代码等</li></ol><p><strong>Ps：提供越多有效信息，越能得到帮助</strong></p><h2 id="错误提问"><a href="#错误提问" class="headerlink" title="错误提问"></a>错误提问</h2><ol><li>有大佬在吗？有人在吗？有人会吗？有人懂吗？</li><li>这个怎么解决？为什么会出现这个？这是怎麽回事？有没有人帮我解决这个问题？</li></ol><p><strong>Ps：大家都忙，请尊重彼此的时间</strong></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;提问之前&quot;&gt;&lt;a href=&quot;#提问之前&quot; class=&quot;headerlink&quot; title=&quot;提问之前&quot;&gt;&lt;/a&gt;提问之前&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;你是否在谷歌/百度/论坛上搜索过？&lt;/li&gt;
&lt;li&gt;你是否查过手册/文档？&lt;/li&gt;
&lt;li&gt;你是否阅读过源码？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;正确提问&quot;&gt;&lt;a href=&quot;#正确提问&quot; class=&quot;headerlink&quot; title=&quot;正确提问&quot;&gt;&lt;/a&gt;正确提问&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;你想做什么？遇到了什么问题？你做过什么？尝试过什么解决方案？结果是什么？&lt;/li&gt;
&lt;li&gt;附上log，代码等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Ps：提供越多有效信息，越能得到帮助&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;错误提问&quot;&gt;&lt;a href=&quot;#错误提问&quot; class=&quot;headerlink&quot; title=&quot;错误提问&quot;&gt;&lt;/a&gt;错误提问&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;有大佬在吗？有人在吗？有人会吗？有人懂吗？&lt;/li&gt;
&lt;li&gt;这个怎么解决？为什么会出现这个？这是怎麽回事？有没有人帮我解决这个问题？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Ps：大家都忙，请尊重彼此的时间&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>为Hexo添加CNZZ统计</title>
    <link href="https://zhangmiao.cc/posts/fb66bb1.html"/>
    <id>https://zhangmiao.cc/posts/fb66bb1.html</id>
    <published>2019-08-22T02:17:39.000Z</published>
    <updated>2019-08-22T02:28:03.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚开始弄NexT主题的时候，一直都是用不蒜子的统计，但是不蒜子统计的内容太过简单了，不能够看到其他的一些数据，最近把友盟的统计给加上了。</p><p><strong>友盟+ 传送门</strong>：<a href="https://passport.umeng.com/login?appId=cnzz" target="_blank" rel="noopener">https://passport.umeng.com/login?appId=cnzz</a></p><h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p>登录之后，选择右上角的添加站点，配置好你的站点信息</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190822102053.png" alt></p><a id="more"></a><h3 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h3><p>获取友盟提供给你的代码，友盟提供了很多的样式，随便复制一份就行。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190822102153.png" alt></p><p>在<code>\themes\next\layout\_third-party\analytics\cnzz-analytics.swig</code>中将原来的代码全部删除，复制下面的代码：<br>ps：如果没有该文件，请自行创建然后复制修改下面的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.cnzz_siteid %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 填写你的友盟代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> cnzz_protocol = ((<span class="string">"https:"</span> == <span class="built_in">document</span>.location.protocol) ? <span class="string">" https://"</span> : <span class="string">" http://"</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="built_in">unescape</span>(<span class="string">"%3Cspan id='cnzz_stat_icon_12'%3E%3C/span%3E%3Cscript </span></span></span><br><span class="line"><span class="javascript">src=<span class="string">'" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D12%2show%3Dpic'</span> </span></span><br><span class="line"><span class="javascript">type=<span class="string">'text/javascript'</span>%<span class="number">3</span>E%<span class="number">3</span>C/script%<span class="number">3</span>E<span class="string">"));</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 你的友盟代码 end --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>添加了代码之后，还需要修改next的配置文件才能够生效。注意是主题配置文件<br>打开<code>\themes\next</code>目录下的<code>_config.yml</code>，按<code>ctrl + F</code>搜索<code>CNZZ</code>,找到之后将注释的内容打开，并设置成true，注意空格</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CNZZ count</span><br><span class="line">cnzz_siteid: true</span><br></pre></td></tr></table></figure><p>这样就可以成功的使用CNZZ进行统计了。建议使用<code>hexo s</code>在本地测试，看是否有问题再部署上去。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;刚开始弄NexT主题的时候，一直都是用不蒜子的统计，但是不蒜子统计的内容太过简单了，不能够看到其他的一些数据，最近把友盟的统计给加上了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友盟+ 传送门&lt;/strong&gt;：&lt;a href=&quot;https://passport.umeng.com/login?appId=cnzz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://passport.umeng.com/login?appId=cnzz&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置站点信息&quot;&gt;&lt;a href=&quot;#配置站点信息&quot; class=&quot;headerlink&quot; title=&quot;配置站点信息&quot;&gt;&lt;/a&gt;配置站点信息&lt;/h3&gt;&lt;p&gt;登录之后，选择右上角的添加站点，配置好你的站点信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190822102053.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://zhangmiao.cc/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="Hexo" scheme="https://zhangmiao.cc/tags/Hexo/"/>
    
      <category term="建站" scheme="https://zhangmiao.cc/tags/%E5%BB%BA%E7%AB%99/"/>
    
      <category term="博客" scheme="https://zhangmiao.cc/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Mac Os，iphone，ipad绑定阿里云邮箱</title>
    <link href="https://zhangmiao.cc/posts/94899ee0.html"/>
    <id>https://zhangmiao.cc/posts/94899ee0.html</id>
    <published>2019-08-21T07:15:28.000Z</published>
    <updated>2019-08-21T07:26:22.446Z</updated>
    
    <content type="html"><![CDATA[<p>在 MacOS iPhone  iPad 上面设置可能有差别，但是关键参数如下。</p><p>以Mac OS为例，打开设置，前往互联网账户，添加其他账户，邮件账户，按自己的阿里邮箱，或者你们公司给你的以你们公司名后缀结束的邮箱（其实还是阿里邮箱），填写邮箱密码。</p><hr><p><strong>接着选择账户类型：pop</strong></p><p><strong>收件服务器：pop3.aliyun.com</strong></p><p><strong>发件服务器：smtp.aliyun.com</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821151548.png" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 MacOS iPhone  iPad 上面设置可能有差别，但是关键参数如下。&lt;/p&gt;
&lt;p&gt;以Mac OS为例，打开设置，前往互联网账户，添加其他账户，邮件账户，按自己的阿里邮箱，或者你们公司给你的以你们公司名后缀结束的邮箱（其实还是阿里邮箱），填写邮箱密码。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;接着选择账户类型：pop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收件服务器：pop3.aliyun.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发件服务器：smtp.aliyun.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821151548.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://zhangmiao.cc/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://zhangmiao.cc/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-9.0进阶指南</title>
    <link href="https://zhangmiao.cc/posts/e2baf374.html"/>
    <id>https://zhangmiao.cc/posts/e2baf374.html</id>
    <published>2019-08-21T06:25:10.000Z</published>
    <updated>2019-08-21T06:44:42.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国内从去年开始就有消息说，应用上架或者更新要求TargetSdkVersion最低要为26以上，也就是最低也要适配到8.0。今年来也都逐步地开始落实。</p><table><thead><tr><th align="center"><a href="https://link.juejin.im/?target=https%3A%2F%2Fdev.mi.com%2Fconsole%2Fdoc%2Fdetail%3FpId%3D1695" target="_blank" rel="noopener">小米应用商店公告</a></th><th align="center"><a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fdistribute%2Fbest-practices%2Fdevelop%2Ftarget-sdk%3Fhl%3Dzh-cn" target="_blank" rel="noopener">Google Play的要求</a></th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142559.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142744.png" alt></td></tr></tbody></table><p>还包括从8月份开始在Google Play上发布的应用必须支持64位架构。可以看到适配工作真的不能像以前一样随心所欲了。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>进入正题，首先将我们项目中的<code>targetSdkVersion</code>改为 28。接下来运行你的项目，看有没中枪。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="Http请求失败"><a href="#Http请求失败" class="headerlink" title="Http请求失败"></a>Http请求失败</h3><p>在9.0中默认情况下启用网络传输层安全协议 (TLS)，默认情况下已停用明文支持。也就是不允许使用http请求，要求使用https。</p><p>比如我使用的是okhttp，会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.UnknownServiceException: CLEARTEXT communication to xxxx not permitted by network security policy</span><br></pre></td></tr></table></figure><p>解决方法是需要我们添加网络安全配置。首先在 <code>res</code> 目录下新建<code>xml</code>文件夹，添加<code>network_security_config.xml</code>文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>AndroidManifest.xml</code>中的<code>application</code>添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config"</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上这是一种简单粗暴的配置方法，要么支持http，要么不支持http。为了安全灵活，我们可以指定支持的http域名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Android 9.0 上部分域名时使用 http --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>secure.example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>cdn.example1.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然不止这些配置，还有抓包配置、设置自定义CA以及各种场景下灵活的配置，详细的方法可以查看<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Ftraining%2Farticles%2Fsecurity-config.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="Apache-HTTP-客户端弃用"><a href="#Apache-HTTP-客户端弃用" class="headerlink" title="Apache HTTP 客户端弃用"></a>Apache HTTP 客户端弃用</h3><p>在 Android 6.0 时，就已经取消了对 <code>Apache HTTP</code> 客户端的支持。 从 Android 9.0 开始，默认情况下该库已从 <code>bootclasspath</code> 中移除。但是耐不住有些SDK中还在使用，比如我见到的<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.umeng.com%2Fdocs%2F66750%2Fdetail%2F94386" target="_blank" rel="noopener">友盟QQ分享报错问题</a>。</p><p>所以要想继续使用<code>Apache HTTP</code>，需要在应用的 AndroidManifest.xml 文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-library</span> <span class="attr">android:name</span>=<span class="string">"org.apache.http.legacy"</span> <span class="attr">android:required</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><p>可以试着搜索一下你的代码，看是否有调用<code>startForegroundService</code> 方法来启动一个前台服务。</p><p><code>startForegroundService</code> 主要来源估计都是8.0适配时候加上的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    startForegroundService(intentService);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startService(intentService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.0 要求创建一个前台服务需要请求 <code>FOREGROUND_SERVICE</code> 权限，否则系统会引发 <code>SecurityException</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to start service com.weilu.test.MyService@81795be with Intent &#123; cmp=com.weilu.test/.MyService &#125;: </span><br><span class="line">java.lang.SecurityException: Permission Denial: startForeground from pid=28631, uid=10626 requires android.permission.FOREGROUND_SERVICE</span><br><span class="line">        at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:3723)</span><br><span class="line">        at android.app.ActivityThread.access$1700(ActivityThread.java:201)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1705)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:207)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6820)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)</span><br></pre></td></tr></table></figure><p>解决方法就是<code>AndroidManifest.xml</code>中添加<code>FOREGROUND_SERVICE</code>权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.FOREGROUND_SERVICE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h2><p>在9.0 中，不能直接非 <code>Activity</code> 环境中（比如<code>Service</code>，<code>Application</code>）启动 <code>Activity</code>，否则会崩溃报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to create service com.weilu.test.MyService: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br><span class="line">        at android.app.ActivityThread.handleCreateService(ActivityThread.java:3578)</span><br><span class="line">        at android.app.ActivityThread.access$1400(ActivityThread.java:201)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:207)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6820)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)</span><br></pre></td></tr></table></figure><p>这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标<code>FLAG_ACTIVITY_NEW_TASK</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h2 id="异形屏适配"><a href="#异形屏适配" class="headerlink" title="异形屏适配"></a>异形屏适配</h2><p>这类异形屏叫法很多，刘海屏、水滴屏、挖孔屏、美人尖。。</p><ol><li>其实如果你的页面不需要全屏显示，那么不需要额外的适配工作。</li><li>如果页面是全屏显示（比如启动页）。为了防止你的内容被遮挡，大部分场景下都是可以使用获取状态栏高度来处理遮挡的适配问题。因为状态栏的高度都是大于等于刘海的高度。</li></ol><p>当然，如果你想利用起来刘海区域，就需要获取刘海位置等信息进行适配。在Android 9.0中官方提供了<code>DisplayCutout</code> 类，可以确定刘海区域的位置，国内的部分厂商在8.0就有了自己的适配方案。</p><p>具体的我就不过多介绍了，推荐大家看以下文章：</p><ul><li><a href="https://juejin.im/post/5b1930835188257d7541ba33#heading-26" target="_blank" rel="noopener">Android P 刘海屏适配全攻略</a></li><li><a href="https://juejin.im/post/5cf635846fb9a07f0c466ea7" target="_blank" rel="noopener">Android刘海屏、水滴屏全面屏适配方案</a></li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>首先是权限组的变更：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821144142.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821144220.png" alt></p><p>上图可以看到，在9.0 中新增权限组<code>CALL_LOG</code> 并将 <code>READ_CALL_LOG</code>、<code>WRITE_CALL_LOG</code> 和 <code>PROCESS_OUTGOING_CALLS</code> 权限从<code>PHONE</code>中移入该组。</p><h3 id="限制访问通话记录"><a href="#限制访问通话记录" class="headerlink" title="限制访问通话记录"></a>限制访问通话记录</h3><p>如果应用需要访问通话记录或者需要处理去电，则您必须向 <code>CALL_LOG</code>权限组明确请求这些权限。 否则会发生 <code>SecurityException</code>。</p><h3 id="限制访问电话号码"><a href="#限制访问电话号码" class="headerlink" title="限制访问电话号码"></a>限制访问电话号码</h3><ul><li><p>要通过 <code>PHONE_STATE</code> Intent 操作读取电话号码，同时需要 <code>READ_CALL_LOG</code> 权限和 <code>READ_PHONE_STATE</code> 权限。</p></li><li><p>要从 <code>PhoneStateListener的onCallStateChanged()</code> 中读取电话号码，只需要 <code>READ_CALL_LOG</code> 权限。 不需要 <code>READ_PHONE_STATE</code> 权限。</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>在 Android 9 中，调用<code>Build.SERIAL</code> 会始终返回 <code>UNKNOWN</code> 以保护用户的隐私。如果你的应用需要访问设备的硬件序列号，那么需要先请求 <code>READ_PHONE_STATE</code> 权限，然后调用 <code>Build.getSerial()</code>。</p></li><li><p>注意非 SDK 接口的限制。主要是一些热修复、插件化框架涉及比较多，注意及时升级新版本。</p></li><li><p>多进程使用<code>WebView</code>注意无法共用同一数据目录。 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fabout%2Fversions%2Fpie%2Fandroid-9.0-changes-28%23web-data-dirs" target="_blank" rel="noopener">详细点击查看</a></p></li></ul><p>总的来说，9.0的适配工作需要改动和注意的点相比较以前版本的适配来说并不多，从本篇的篇幅就可以看出来，详细的变化可以参看文末的链接。后面如果遇到什么坑，我也会及时补充进来。感谢你的阅读！！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fabout%2Fversions%2Fpie%2Fandroid-9.0" target="_blank" rel="noopener">Android 9.0 行为变更</a></li><li><a href="https://juejin.im/post/5d36c2d26fb9a07ea33c562e#heading-6" target="_blank" rel="noopener">targetSdkVersion升级28</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;国内从去年开始就有消息说，应用上架或者更新要求TargetSdkVersion最低要为26以上，也就是最低也要适配到8.0。今年来也都逐步地开始落实。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fdev.mi.com%2Fconsole%2Fdoc%2Fdetail%3FpId%3D1695&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小米应用商店公告&lt;/a&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fdistribute%2Fbest-practices%2Fdevelop%2Ftarget-sdk%3Fhl%3Dzh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Play的要求&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142559.png&quot; alt&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142744.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;还包括从8月份开始在Google Play上发布的应用必须支持64位架构。可以看到适配工作真的不能像以前一样随心所欲了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-8.0详解</title>
    <link href="https://zhangmiao.cc/posts/cd8b8392.html"/>
    <id>https://zhangmiao.cc/posts/cd8b8392.html</id>
    <published>2019-08-21T05:52:29.000Z</published>
    <updated>2019-08-21T06:17:00.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>将我们项目中的<code>targetSdkVersion</code>改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android P怎么适配（滑稽）。</p><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p>首先<a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes#rmp" target="_blank" rel="noopener">引用</a>官方的原文。</p><blockquote><p>在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。<br>对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。<br>例如，假设某个应用在其清单中列出<code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code>。应用请求 <code>READ_EXTERNAL_STORAGE</code>，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予<code>WRITE_EXTERNAL_STORAGE</code>，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 <code>READ_EXTERNAL_STORAGE</code>；不过，如果该应用后来又请求 <code>WRITE_EXTERNAL_STORAGE</code>，则系统会立即授予该权限，而不会提示用户。</p></blockquote><a id="more"></a><p>所谓权限组如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821135542.png" alt></p><p>所以总结下来，如果你之前是用什么权限就去申请什么权限，那么恭喜你，这个变化不会影响到你。如果你只申请了权限组中的某些权限，却用了同组的其他权限，那么你就需要去适配一下了。</p><p>那么怎么适配呢，如果你去检查之前每个申请权限的地方，未免太过麻烦。那么你可以根据你项目中的<code>Manifest</code>文件中需要的权限与权限组去对比，整理出你需要申请的各个权限组。比如你需要<code>android.permission.CALL_PHONE</code>(打电话)与<code>android.permission.READ_PHONE_STATE</code>(读取手机状态) 这两个权限。那么你就整理出了类似下面的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Phone权限</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String[] PHONE = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">          Manifest.permission.READ_PHONE_STATE, </span><br><span class="line">          Manifest.permission.CALL_PHONE</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到时在申请权限时就可以直接获取它，一次将它们都申请了。这样就防止了遗漏某个权限，导致的异常。</p><p>注意：<code>8.0中PHONE</code>权限组新增两个权限：</p><p>``ANSWER_PHONE_CALLS<code>：允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用</code>acceptRingingCall() `函数。</p><p><code>READ_PHONE_NUMBERS</code> ：权限允许您的应用读取设备中存储的电话号码。</p><h2 id="通知适配"><a href="#通知适配" class="headerlink" title="通知适配"></a>通知适配</h2><p>其实8.0在通知这里变化还挺多的，比如<strong>通知渠道</strong>、<strong>通知标志</strong>、<strong>通知超时</strong>、<strong>背景颜色</strong>的等，详细的说明可以去看官方的<a href="https://developer.android.google.cn/about/versions/oreo/android-8.0#notifications" target="_blank" rel="noopener">Android 8.0 功能和 API</a>。虽然变化很多，但是国内的机子貌似支持的不多。。。我在小米的文档中了解到，Android 已将通知渠道的逻辑纳入 Android Compatibility Definition Document (CDD) 中，意味着所有 Android 厂商都必须支持。所以我们可以放心的去适配。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821135800.png" alt></p><blockquote><p>通知渠道：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。</p></blockquote><p>我个人很喜欢这个新特性。也就是说，我们可以将我们给用户的通知进行分类，我用高德地图app来举例</p><table><thead><tr><th align="center">小米(MIUI10)</th><th align="center">华为(EMUI 8.1.0)</th><th align="center">一加(氢OS 5.1)</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140019.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140114.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140151.png" alt></td></tr></tbody></table><p>可以看到高德地图分的很细致，分为四个组共13个类别(华为貌似对组不生效)。这样有个好处，我们可以控制我们想收到的通知，比如我不喜欢运营活动通知，那我就可以把它关闭。这样避免大量的不必要通知，否则使得用户觉得烦，一棒子打死。直接关闭你的允许通知。当然了，大量app都还没有适配，适配的也都分的不是很细致，比如下图的QQ。(没有对比就没有伤害)</p><table><thead><tr><th align="center">小米(MIUI10)</th><th align="center">一加(氢OS 5.1)</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140256.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140332.png" alt></td></tr></tbody></table><p>当然更重要的问题是，如果不去适配，可能通知都不会弹出来。那么适配的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNotificationChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line"></span><br><span class="line">            NotificationManager notificationManager = (NotificationManager)</span><br><span class="line">                    getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分组（可选）</span></span><br><span class="line">            <span class="comment">//groupId要唯一</span></span><br><span class="line">            String groupId = <span class="string">"group_001"</span>;</span><br><span class="line">            NotificationChannelGroup group = <span class="keyword">new</span> NotificationChannelGroup(groupId, <span class="string">"广告"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建group</span></span><br><span class="line">            notificationManager.createNotificationChannelGroup(group);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//channelId要唯一</span></span><br><span class="line">            String channelId = <span class="string">"channel_001"</span>;</span><br><span class="line"></span><br><span class="line">            NotificationChannel adChannel = <span class="keyword">new</span> NotificationChannel(channelId,</span><br><span class="line">                    <span class="string">"推广信息"</span>, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">            <span class="comment">//补充channel的含义（可选）</span></span><br><span class="line">            adChannel.setDescription(<span class="string">"推广信息"</span>);</span><br><span class="line">            <span class="comment">//将渠道添加进组（先创建组才能添加）</span></span><br><span class="line">            adChannel.setGroup(groupId);</span><br><span class="line">            <span class="comment">//创建channel</span></span><br><span class="line">            notificationManager.createNotificationChannel(adChannel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建通知时，标记你的渠道id</span></span><br><span class="line">            Notification notification = <span class="keyword">new</span> Notification.Builder(MainActivity.<span class="keyword">this</span>, channelId)</span><br><span class="line">                    .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">                    .setContentTitle(<span class="string">"一条新通知"</span>)</span><br><span class="line">                    .setContentText(<span class="string">"这是一条测试消息"</span>)</span><br><span class="line">                    .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            notificationManager.notify(<span class="number">1</span>, notification);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th align="center">小米(MIUI10)</th><th align="center">华为(EMUI 8.1.0)</th><th align="center">一加(氢OS 5.1)</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140658.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140501.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140530.png" alt></td></tr></tbody></table><p>华为手机当只有一个渠道时，不会显示，会当做默认通知处理，除非一个以上。</p><blockquote><p><strong>注意</strong>：当Channel已经存在时，后面的<code>createNotificationChannel</code>方法仅能更新其name/description，以及对importance进行降级，其余配置均无法更新。所以如果有必要的修改只能创建新的渠道，删除旧渠道</p></blockquote><p>删除渠道代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNotificationChannel</span><span class="params">(String channelId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            NotificationManager mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">            mNotificationManager.deleteNotificationChannel(channelId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="悬浮窗适配"><a href="#悬浮窗适配" class="headerlink" title="悬浮窗适配"></a>悬浮窗适配</h2><p>使用 <code>SYSTEM_ALERT_WINDOW</code> 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口:</p><ul><li>TYPE_PHONE</li><li>TYPE_PRIORITY_PHONE</li><li>TYPE_SYSTEM_ALERT</li><li>TYPE_SYSTEM_OVERLAY</li><li>TYPE_SYSTEM_ERROR</li></ul><p>相反，应用必须使用名为 <code>TYPE_APPLICATION_OVERLAY</code> 的新窗口类型。</p><p>也就是说需要在之前的基础上判断一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然记得需要有权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_OVERLAY_WINDOW"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再进行判断</p><h2 id="安装APK"><a href="#安装APK" class="headerlink" title="安装APK"></a>安装APK</h2><p>Android 8.0去除了“允许未知来源”选项，所以如果我们的App有安装App的功能（检查更新之类的），那么会无法正常安装。</p><p>首先在<code>AndroidManifest</code>文件中添加安装未知来源应用的权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.REQUEST_INSTALL_PACKAGES"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样系统会自动询问用户完成授权。当然你也可以先使用 <code>canRequestPackageInstalls()</code>查询是否有此权限，如果没有的话使用<code>Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES</code>这个action将用户引导至安装未知应用权限界面去授权。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE_UNKNOWN_APP = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installAPK</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasInstallPermission = getPackageManager().canRequestPackageInstalls();</span><br><span class="line">            <span class="keyword">if</span> (hasInstallPermission) &#123;</span><br><span class="line">                <span class="comment">//安装应用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//跳转至“安装未知应用”权限界面，引导用户开启权限</span></span><br><span class="line">                Uri selfPackageUri = Uri.parse(<span class="string">"package:"</span> + <span class="keyword">this</span>.getPackageName());</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri);</span><br><span class="line">                startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//安装应用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收“安装未知应用”权限的开启结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123;</span><br><span class="line">            installAPK();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于权限组、悬浮窗还有安装未知来源应用的权限适配，我们也可以使用<a href="https://github.com/yanzhenjie/AndPermission" target="_blank" rel="noopener">AndPermission</a>。这样更加便捷。</p><h2 id="透明主题的Activity"><a href="#透明主题的Activity" class="headerlink" title="透明主题的Activity"></a>透明主题的Activity</h2><p>这个是在targetSdk=27，Android为8.0的手机时，出现的bug（因为官方已经在8.1修复）。问题的探究可以<a href="https://www.jianshu.com/p/e6b5e7261c25" target="_blank" rel="noopener">查看这里</a>。</p><p>只有全屏不透明的activity才可以设置方向。否则报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation</span><br><span class="line">at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2957)</span><br><span class="line">at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3032)</span><br><span class="line">at android.app.ActivityThread.-wrap11(Unknown Source:0)</span><br><span class="line">at adroid.app.ActivityThread$H.handleMessage(ActivityThread.java:1696)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:105)</span><br><span class="line">at android.os.Looper.loop(Looper.java:164)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:6944)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:327)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1374)</span><br></pre></td></tr></table></figure><p>容易中枪的比如微信分享、支付的回调页面，我们习惯设为透明。</p><p>解决办法：</p><ol><li>要么去掉对应activity中的 <code>screenOrientation</code> 属性，或者对应设置方向的代码。</li><li>要么舍弃透明效果，在它的<code>Theme</code>中添加：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="集合的处理"><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>现在，<code>AbstractCollection.removeAll(null)</code>和<code>AbstractCollection.retainAll(null)</code>始终引发 <code>NullPointerException</code>；之前，当集合为空时不会引发 <code>NullPointerException</code>。所以我们需要做判空处理。</p><h2 id="后台执行限制"><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h2><p>应用在两个方面受到限制：</p><ul><li><p>后台服务限制：处于空闲状态时，应用可以使用的后台服务存在限制。 这些限制不适用于前台服务，因为前台服务更容易引起用户注意。</p></li><li><p>广播限制：除了有限的例外情况，应用无法使用清单注册隐式广播。 它们仍然可以在运行时注册这些广播，并且可以使用清单注册专门针对它们的显式广播。</p></li></ul><p>在大多数情况下，应用都可以使用 <code>JobScheduler</code> 克服这些限制。 这种方式让应用安排为在未活跃运行时执行工作，不过仍能够使系统可以在不影响用户体验的情况下安排这些作业。关于的用法可以参考官方例子：<a href="https://github.com/googlesamples/android-JobScheduler" target="_blank" rel="noopener">android-JobScheduler</a>。</p><p>后台任务google推荐方案使用 <code>WorkManager</code>，<code>WorkManager</code>可以自动维护后台任务，同时可适应不同的条件，同时满足后台<code>Service</code>和静态广播，内部维护着<code>JobScheduler</code>，而在6.0以下系统版本则可自动切换为<code>AlarmManager</code>！有兴趣的可以<a href="https://my.oschina.net/JiangTun/blog/1923680" target="_blank" rel="noopener">了解一下</a>。</p><p>当然还有<a href="https://developer.android.google.cn/about/versions/oreo/background-location-limits" target="_blank" rel="noopener">后台位置的限制</a>需要去注意。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>1.<a href="https://dev.mi.com/console/doc/detail?pId=1303" target="_blank" rel="noopener">MIUI 10 通知类别 / Channel 适配</a></li><li>2.<a href="https://developer.android.google.cn/training/notify-user/channels" target="_blank" rel="noopener">Create and Manage Notification Channels</a></li><li>3.<a href="https://source.android.google.cn/compatibility/8.0/android-8.0-cdd#3_8_user_interface_compatibility" target="_blank" rel="noopener">Presentation of Notifications</a></li><li>4.<a href="https://blog.csdn.net/mq2856992713/article/details/79688587" target="_blank" rel="noopener">Android 实现应用更新适配 Android O</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;将我们项目中的&lt;code&gt;targetSdkVersion&lt;/code&gt;改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android P怎么适配（滑稽）。&lt;/p&gt;
&lt;h2 id=&quot;运行时权限&quot;&gt;&lt;a href=&quot;#运行时权限&quot; class=&quot;headerlink&quot; title=&quot;运行时权限&quot;&gt;&lt;/a&gt;运行时权限&lt;/h2&gt;&lt;p&gt;首先&lt;a href=&quot;https://developer.android.google.cn/about/versions/oreo/android-8.0-changes#rmp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引用&lt;/a&gt;官方的原文。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。&lt;br&gt;对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。&lt;br&gt;例如，假设某个应用在其清单中列出&lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; 和&lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;。应用请求 &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt;，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予&lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt;；不过，如果该应用后来又请求 &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;，则系统会立即授予该权限，而不会提示用户。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-7.0的踩坑之路</title>
    <link href="https://zhangmiao.cc/posts/a6a9da5d.html"/>
    <id>https://zhangmiao.cc/posts/a6a9da5d.html</id>
    <published>2019-08-21T04:10:33.000Z</published>
    <updated>2019-08-21T05:53:17.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装时解析错误"><a href="#安装时解析错误" class="headerlink" title="安装时解析错误"></a>安装时解析错误</h2><p>我们的App通常会有检查更新的功能。用户在收到提示更新并且下载完后，会自动打开安装页面让用户来去安装。这时就会出现安装错误的问题，这类的问题的可能性比较多。比如较低版本的App想要覆盖已有的较高版本App会提示安装未完成，或是签名不一致导致的。不过7.0上常见的有以下两种情况。</p><h3 id="应用间共享文件"><a href="#应用间共享文件" class="headerlink" title="应用间共享文件"></a>应用间共享文件</h3><p>在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 <a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件</a> 这篇文章。</p><h3 id="APK-signature-scheme-v2"><a href="#APK-signature-scheme-v2" class="headerlink" title="APK signature scheme v2"></a>APK signature scheme v2</h3><blockquote><p>Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。详细看<a href="https://developer.android.google.cn/about/versions/nougat/android-7.0.html#apk_signature_v2" target="_blank" rel="noopener">安卓官方说明</a>。</p></blockquote><p>简单地说就是任何方式的篡改APK 文件，在利用了V2签名的apk上会失效。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/WechatIMG163.png" alt></p><p>可以看到默认是V1 和V2选中的。</p><p>1）只勾选v1签名就是传统方案签署，但是在7.0上不会使用V2安全的验证方式。<br>2）只勾选V2签名7.0以下会显示未安装，7.0上则会使用了V2安全的验证方式。<br>3）同时勾选V1和V2则所有版本都没问题。</p><h2 id="PopupWindow位置不正确"><a href="#PopupWindow位置不正确" class="headerlink" title="PopupWindow位置不正确"></a>PopupWindow位置不正确</h2><p>7.0系统的手机上，PopupWindow弹出位置不正确。有两种可能：</p><p><strong>第一种：</strong></p><p>我们使用了<code>update</code>方法，同时设置了<code>Gravity</code>（<code>Gravity.NO_GRAVITY</code>没事）。因为在<code>update</code>方法中有调用<code>computeGravity</code>方法去获取<code>Gravity</code>。（7.0以下没有获取<code>Gravity</code>进行更新判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> newGravity = computeGravity();</span><br><span class="line">       <span class="keyword">if</span> (newGravity != p.gravity) &#123;</span><br><span class="line">           p.gravity = newGravity;</span><br><span class="line">           update = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (update) &#123;</span><br><span class="line">           setLayoutDirectionFromAnchor();</span><br><span class="line">           mWindowManager.updateViewLayout(mDecorView, p);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Android 7.1<code>computeGravity</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeGravity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gravity = mGravity == Gravity.NO_GRAVITY ?  Gravity.START | Gravity.TOP : mGravity;</span><br><span class="line">    <span class="keyword">if</span> (mIsDropdown &amp;&amp; (mClipToScreen || mClippingEnabled)) &#123;</span><br><span class="line">        gravity |= Gravity.DISPLAY_CLIP_VERTICAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gravity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然在7.0上我们设置的<code>Gravity</code>被覆盖了。解决就很简单了，不使用<code>update</code>方法。如果你真的要使用可以参考<a href="http://www.jianshu.com/p/0df10893bf5b" target="_blank" rel="noopener">这篇文章</a>的方法。</p><p><strong>第二种：</strong></p><p><code>PopupWindow</code>高度为<code>MATCH_PARENT</code>，在显示的时候调用<code>showAsLocation</code>方法时，<code>PopupWindow</code>并没有在指定控件的下方显示。如果使用<code>showAsDropDown</code>，会全屏显示。</p><p>解决方法：</p><p>1.最简单的解决方法就是指定 <code>PopupWindow</code> 的高度为 <code>WRAP_CONTENT</code>, 调用 <code>showAsDropDown</code>方法。</p><p>2.或者弹出时做一下判断处理（代码来自<a href="https://github.com/tianma8023/PopupWindowCompat" target="_blank" rel="noopener">PopupWindowCompat</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123; <span class="comment">// Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性</span></span><br><span class="line">    <span class="keyword">int</span>[] location = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">// 记录anchor在屏幕中的位置</span></span><br><span class="line">    anchor.getLocationOnScreen(location);</span><br><span class="line">    <span class="keyword">int</span> offsetY = location[<span class="number">1</span>] + anchor.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">25</span>) &#123; <span class="comment">// Android 7.1 ,8.0中，PopupWindow高度为 match_parent 时，会占据整个屏幕</span></span><br><span class="line">        <span class="comment">// 故而需要在 Android 7.1上再做特殊处理</span></span><br><span class="line">        <span class="keyword">int</span> screenHeight = ScreenUtils.getScreenHeight(context); <span class="comment">// 获取屏幕高度</span></span><br><span class="line">        popupWindow.setHeight(screenHeight - offsetY); <span class="comment">// 重新设置 PopupWindow 的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, <span class="number">0</span>, offsetY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    popupWindow.showAsDropDown(anchor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后台优化"><a href="#后台优化" class="headerlink" title="后台优化"></a>后台优化</h2><p>小伙伴们都知道在Android中有一些隐式广播，使用这些隐式广播可以做一些特定的功能，如，当手机网络变成WiFi时自动下载更新包等。 但，这些隐式广播会在后台频繁启动已注册侦听这些广播的应用，从而带来很大的电量消耗，为缓解这一问题来提升设备性能和用户体验，在Android 7.0中删除了三项隐式广播，以帮助优化内存使用和电量消耗。</p><p>Android 7.0 应用了以下优化措施：</p><ul><li>在 Android 7.0上 应用不会收到 CONNECTIVITY_ACTION 广播，即使你在manifest清单文件中设置了请求接受这些事件的通知。 但，在前台运行的应用如果使用BroadcastReceiver 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。</li><li>在 Android 7.0上应用无法发送或接收 ACTION_NEW_PICTURE 或ACTION_NEW_VIDEO 类型的广播。</li></ul><blockquote><p>应对策略：Android 框架提供多个解决方案来缓解对这些隐式广播的需求。 例如，<a href="https://developer.android.google.cn/reference/android/app/job/JobScheduler.html" target="_blank" rel="noopener">JobScheduler API</a><br>提供了一个稳健可靠的机制来安排满足指定条件（例如连入无线流量网络）时所执行的网络操作。 您甚至可以使用 <a href="https://developer.android.google.cn/reference/android/app/job/JobScheduler.html" target="_blank" rel="noopener">JobScheduler API</a> 来适应内容提供程序变化。</p></blockquote><p>另外，大家如果想了解更多关于后台的优化可查阅<a href="https://developer.android.google.cn/preview/features/background-optimization.html" target="_blank" rel="noopener">后台优化</a></p><p>移动设备会经历频繁的连接变更，例如在 Wi-Fi 和移动数据之间切换时。 目前，可以通过在应用清单中注册一个接收器来侦听隐式 CONNECTIVITY_ACTION 广播，<br>让应用能够监控这些变更。 由于很多应用会注册接收此广播，因此单次网络切换即会导致所有应用被唤醒并同时处理此广播。<br>以上内容来自<a href="https://github.com/crazycodeboy/crazycodeboy.github.io/blob/master/_posts/2016-9-28-Android7.0适配心得.md#后台优化" target="_blank" rel="noopener">这里</a></p><h2 id="多语言特性"><a href="#多语言特性" class="headerlink" title="多语言特性"></a>多语言特性</h2><p>首先是官方的API指南：<a href="https://weilu.blog.csdn.net/article/details/n/guide/topics/resources/multilingual-support.html" target="_blank" rel="noopener">语言和语言区域</a></p><ul><li><p>变化对比：<a href="http://blog.csdn.net/cekiasoo/article/details/53012646" target="_blank" rel="noopener"> Android 7.0多语言支持开发浅析</a></p></li><li><p>实现功能： <a href="http://blog.csdn.net/cekiasoo/article/details/54933135" target="_blank" rel="noopener">Android 实现应用内置语言切换</a></p></li></ul><h2 id="通知栏适配"><a href="#通知栏适配" class="headerlink" title="通知栏适配"></a>通知栏适配</h2><p>这里有一篇非常详细的通知栏介绍与适配，分享给大家：<a href="http://iluhcm.com/2017/03/12/experience-of-adapting-to-android-notifications/" target="_blank" rel="noopener">Android通知栏介绍与适配总结</a></p><h2 id="WebView问题"><a href="#WebView问题" class="headerlink" title="WebView问题"></a>WebView问题</h2><ul><li><a href="http://blog.csdn.net/u012347067/article/details/70829013" target="_blank" rel="noopener">Android 7.0 WebView 部分机型打不开</a></li><li><a href="http://www.jianshu.com/p/07b781795b78" target="_blank" rel="noopener">Android 7.0 WebView 二级跳转后界面空白</a></li></ul><h2 id="Toast导致的BadTokenException"><a href="#Toast导致的BadTokenException" class="headerlink" title="Toast导致的BadTokenException"></a>Toast导致的BadTokenException</h2><ul><li><a href="https://blog.csdn.net/Dovar_66/article/details/84799894" target="_blank" rel="noopener">同学，你的系统Toast可能需要修复一下</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装时解析错误&quot;&gt;&lt;a href=&quot;#安装时解析错误&quot; class=&quot;headerlink&quot; title=&quot;安装时解析错误&quot;&gt;&lt;/a&gt;安装时解析错误&lt;/h2&gt;&lt;p&gt;我们的App通常会有检查更新的功能。用户在收到提示更新并且下载完后，会自动打开安装页面让用户来去安装。这时就会出现安装错误的问题，这类的问题的可能性比较多。比如较低版本的App想要覆盖已有的较高版本App会提示安装未完成，或是签名不一致导致的。不过7.0上常见的有以下两种情况。&lt;/p&gt;
&lt;h3 id=&quot;应用间共享文件&quot;&gt;&lt;a href=&quot;#应用间共享文件&quot; class=&quot;headerlink&quot; title=&quot;应用间共享文件&quot;&gt;&lt;/a&gt;应用间共享文件&lt;/h3&gt;&lt;p&gt;在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 &lt;a href=&quot;https://blog.csdn.net/lmj623565791/article/details/72859156&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 7.0 行为变更 通过FileProvider在应用间共享文件&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;h3 id=&quot;APK-signature-scheme-v2&quot;&gt;&lt;a href=&quot;#APK-signature-scheme-v2&quot; class=&quot;headerlink&quot; title=&quot;APK signature scheme v2&quot;&gt;&lt;/a&gt;APK signature scheme v2&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。详细看&lt;a href=&quot;https://developer.android.google.cn/about/versions/nougat/android-7.0.html#apk_signature_v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安卓官方说明&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地说就是任何方式的篡改APK 文件，在利用了V2签名的apk上会失效。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-6.0的动态权限管理</title>
    <link href="https://zhangmiao.cc/posts/eea8a783.html"/>
    <id>https://zhangmiao.cc/posts/eea8a783.html</id>
    <published>2019-08-21T03:10:33.000Z</published>
    <updated>2019-08-21T05:54:12.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都知道Android 6.0的新特性之一就是应用权限的管理。也就是说凡是涉及用户隐私的权限，用户可以自己去设置管理了。然而在6.0以前，我们安装一款APP是默认同意此APP所需的所有权限（比如定位、访问通讯录），不同意就不能安装。当然，国内的一些手机厂商基于Android定制的系统中，可以实现在6.0以前关闭指定的权限。如下图：</p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/F1139AC38851B1B3F95BC8D301BA75A4.jpg" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/00E7B3451E21BB3E9A5428062F7D9473.jpg" alt></td></tr></tbody></table><a id="more"></a><h2 id="危险权限列表-Dangerous-Permission"><a href="#危险权限列表-Dangerous-Permission" class="headerlink" title="危险权限列表(Dangerous Permission)"></a>危险权限列表(Dangerous Permission)</h2><p>Dangerous Permission一般都是涉及用户隐私的权限。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821111740.png" alt></p><p>从上面的图片中可以看到，摄像头、电话、定位等等都是我们平常开发中常用的权限。</p><h2 id="可以在6-0不适配权限管理吗？"><a href="#可以在6-0不适配权限管理吗？" class="headerlink" title="可以在6.0不适配权限管理吗？"></a>可以在6.0不适配权限管理吗？</h2><p>答案是可以，但是不推荐。</p><p>首先说怎么不适配，那就是设置targetSdkVersion小于23（Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果您APP设置的targetSdkVersion低于23，在运行时也不会崩溃。）</p><p>有人一看这不是挺好的嘛，解决问题。那么我想告诉你，首先这不是长久之计，早晚都要面对的。你不可能永远targetSdkVersion低于23。其次，它是有一个前提，那就是用户自己不去操作权限。要知道如果用户是6.0以上的手机或是国内部分6.0以前的手机，他可以自己在设置中关闭权限，那么到时APP因为没有权限获取数据异常，导致空指针的异常时，APP就会崩溃。</p><h2 id="怎么适配"><a href="#怎么适配" class="headerlink" title="怎么适配"></a>怎么适配</h2><p>首先Android Studio：<br>在build.gradle中声明targetSdkVersion为23及以上。</p><p>Eclipse：<br>在AndroidManifest.xml中声明targetSdkVersion为23及以上。</p><p>这里引用高德定位Demo的CheckPermissionsActivity类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承了Activity，实现Android6.0的运行时权限检测</span></span><br><span class="line"><span class="comment"> * 需要进行运行时权限检测的Activity可以继承这个类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @创建时间：2016年5月27日 下午3:01:31 </span></span><br><span class="line"><span class="comment"> * @项目名称： AMapLocationDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hongming.wang</span></span><br><span class="line"><span class="comment"> * @文件名称：PermissionsChecker.java</span></span><br><span class="line"><span class="comment"> * @类型名称：PermissionsChecker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckPermissionsActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要进行检测的权限数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String[] needPermissions = &#123;</span><br><span class="line">Manifest.permission.ACCESS_COARSE_LOCATION,</span><br><span class="line">Manifest.permission.ACCESS_FINE_LOCATION,</span><br><span class="line">Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">Manifest.permission.READ_PHONE_STATE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERMISSON_REQUESTCODE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要检测，防止不停的弹框</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isNeedCheck = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onResume();</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span></span><br><span class="line">&amp;&amp; getApplicationInfo().targetSdkVersion &gt;= <span class="number">23</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">checkPermissions(needPermissions);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permissions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> * requestPermissions方法是请求某一权限，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(String... permissions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span></span><br><span class="line">&amp;&amp; getApplicationInfo().targetSdkVersion &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">List&lt;String&gt; needRequestPermissonList = findDeniedPermissions(permissions);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != needRequestPermissonList</span><br><span class="line">&amp;&amp; needRequestPermissonList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">String[] array = needRequestPermissonList.toArray(<span class="keyword">new</span> String[needRequestPermissonList.size()]);</span><br><span class="line">Method method = getClass().getMethod(<span class="string">"requestPermissions"</span>, <span class="keyword">new</span> Class[]&#123;String[].class,</span><br><span class="line"><span class="keyword">int</span>.class&#125;);</span><br><span class="line"></span><br><span class="line">method.invoke(<span class="keyword">this</span>, array, PERMISSON_REQUESTCODE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取权限集中需要申请权限的列表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permissions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> * checkSelfPermission方法是在用来判断是否app已经获取到某一个权限</span></span><br><span class="line"><span class="comment">     * shouldShowRequestPermissionRationale方法用来判断是否</span></span><br><span class="line"><span class="comment">     * 显示申请权限对话框，如果同意了或者不在询问则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">findDeniedPermissions</span><span class="params">(String[] permissions)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; needRequestPermissonList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span></span><br><span class="line">&amp;&amp; getApplicationInfo().targetSdkVersion &gt;= <span class="number">23</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (String perm : permissions) &#123;</span><br><span class="line">Method checkSelfMethod = getClass().getMethod(<span class="string">"checkSelfPermission"</span>, String.class);</span><br><span class="line">Method shouldShowRequestPermissionRationaleMethod = getClass().getMethod(<span class="string">"shouldShowRequestPermissionRationale"</span>,</span><br><span class="line">String.class);</span><br><span class="line"><span class="keyword">if</span> ((Integer)checkSelfMethod.invoke(<span class="keyword">this</span>, perm) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">|| (Boolean)shouldShowRequestPermissionRationaleMethod.invoke(<span class="keyword">this</span>, perm)) &#123;</span><br><span class="line">needRequestPermissonList.add(perm);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> needRequestPermissonList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测是否所有的权限都已经授权</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grantResults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifyPermissions</span><span class="params">(<span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> result : grantResults) &#123;</span><br><span class="line"><span class="keyword">if</span> (result != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 申请权限结果的回调方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@TargetApi</span>(<span class="number">23</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">String[] permissions, <span class="keyword">int</span>[] paramArrayOfInt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (requestCode == PERMISSON_REQUESTCODE) &#123;</span><br><span class="line"><span class="keyword">if</span> (!verifyPermissions(paramArrayOfInt)) &#123;</span><br><span class="line">showMissingPermissionDialog();</span><br><span class="line">isNeedCheck = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示提示信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMissingPermissionDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>);</span><br><span class="line">builder.setTitle(R.string.notifyTitle);</span><br><span class="line">builder.setMessage(R.string.notifyMsg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝, 退出应用</span></span><br><span class="line">builder.setNegativeButton(R.string.cancel,</span><br><span class="line"><span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">builder.setPositiveButton(R.string.setting,</span><br><span class="line"><span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">startAppSettings();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">builder.setCancelable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">builder.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  启动应用的设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAppSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(</span><br><span class="line">Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(keyCode == KeyEvent.KEYCODE_BACK)&#123;</span><br><span class="line"><span class="keyword">this</span>.finish();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在上面的类中，自己加入了一些注释，大家仔细看就可以明白了。</p><p>补充：小米手机在动态权限这里还需要一些兼容，我们需要注意一下。当然对于国内部分6.0以前手机，只能在需要权限去去捕获异常来处理了。</p><blockquote><p>当然不止上面一种实现方法，github上有许多大神开源的封装库，可以很方便的实现权限适配。我推荐两个库，大家根据需求选择：</p></blockquote><ol><li><p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher" target="_blank" rel="noopener">PermissionsDispatcher</a></p></li><li><p><a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">鸿洋大神的MPermissions</a></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.jianshu.com/p/e1ab1a179fbb" target="_blank" rel="noopener">Android M 新的运行时权限开发者需要知道的一切</a></p></li><li><p><a href="https://lbs.amap.com/api/android-location-sdk/guide/utilities/permission/" target="_blank" rel="noopener">高德地图定位API</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大家都知道Android 6.0的新特性之一就是应用权限的管理。也就是说凡是涉及用户隐私的权限，用户可以自己去设置管理了。然而在6.0以前，我们安装一款APP是默认同意此APP所需的所有权限（比如定位、访问通讯录），不同意就不能安装。当然，国内的一些手机厂商基于Android定制的系统中，可以实现在6.0以前关闭指定的权限。如下图：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/F1139AC38851B1B3F95BC8D301BA75A4.jpg&quot; alt&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/00E7B3451E21BB3E9A5428062F7D9473.jpg&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
      <category term="动态权限" scheme="https://zhangmiao.cc/tags/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>开箱即用的自定义Banner</title>
    <link href="https://zhangmiao.cc/posts/108df6b8.html"/>
    <id>https://zhangmiao.cc/posts/108df6b8.html</id>
    <published>2019-08-19T09:59:59.000Z</published>
    <updated>2019-08-19T10:14:16.291Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/640112319204sda.gif" alt></p><a id="more"></a><h2 id="自定义Banner用法明细"><a href="#自定义Banner用法明细" class="headerlink" title="自定义Banner用法明细"></a>自定义Banner用法明细</h2><p>支持XML自定义属性：</p><ul><li><p>bv_viewHeight：Banner视图区域的高度，小于等于0时为该布局的高度</p></li><li><p>bv_viewCornerRadius：视图区域圆角的半径</p></li><li><p>bv_itemViewWidthRatio：根据该布局宽度的百分比设置ItemView的宽度</p></li><li><p>bv_itemViewMargin：设置ItemView之间的间距</p></li><li><p>bv_intervalInMillis：Banner轮换时间（在SMOOTH模式下为Banner从右匀速到左的时间）</p></li><li><p>bv_pageHoldInMillis：手指滑动后，页面停留的时长（只在SMOOTH模式下生效）</p></li><li><p>bv_scrollMode：设置Banner滚动模式</p></li><li><ul><li>INTERVAL：间隔切换模式</li><li>SMOOTH：匀速滚动模式</li></ul></li><li><p>bv_itemViewAlign：ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置）</p></li><li><ul><li>CENTER_HORIZONTAL：水平居中</li><li>ALIGN_PARENT_LEFT：居左对齐</li><li>ALIGN_PARENT_RIGHT：居右对齐</li></ul></li></ul><p>暴露的API有：</p><ul><li>setBannerViewImpl(impl: IBannerView)：设置Banner必须的实现类</li><li>startAutoScroll()：开始自动滚动（页面数量小于1时不会滚动）</li><li>stopAutoScroll()：停止自动滚动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义页面切换回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnPageChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">onPageSelected</span><span class="params">(position: Int)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">interface IBannerViewBase </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getCount</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemView</span><span class="params">(context: Context)</span>: View</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">onBindView</span><span class="params">(itemView: View, position: Int)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * BannerView依赖的外部实现</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">interface IBannerView : OnPageChangeListener, IBannerViewBase </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当count为0时的默认view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">getDefaultView</span><span class="params">(context: Context)</span>: View? </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认关闭自动滚动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">isDefaultAutoScroll</span><span class="params">()</span>: Boolean </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onPageSelected</span><span class="params">(position: Int)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址：</p><blockquote><p><a href="https://github.com/drawf/SourceSet/tree/master/app/src/main/java/me/erwa/sourceset/view/banner" target="_blank" rel="noopener">https://github.com/drawf/SourceSet/tree/master/app/src/main/java/me/erwa/sourceset/view/banner</a></p></blockquote><h2 id="思考分析"><a href="#思考分析" class="headerlink" title="思考分析"></a>思考分析</h2><p><strong>NOTE：</strong>这篇文章我们专注于BannerView的封装与实现，关于更底层的PagerSnapHelper的原理部分不在范围内，但在文末我<strong>拜读的文章</strong>中贴出了一份链接，大家可自行食用。</p><p>前路漫漫，我们先梳理下需求：</p><ol><li>要支持两种滚动模式，间隔切换、平滑滚动</li><li>要支持设置视图区域圆角</li><li>要支持设置条目视图圆角（ItemView）（该需求本次未做实现，下文会自动忽略该需求）</li><li>要支持无限循环滚动</li><li>要支持根据BannerView的宽的比值设置ItemView的宽</li><li>要支持设置ItemView之间的间距</li><li>要支持设置滚动间隔，匀速模式要支持设置滚动一页的时间</li><li>要支持设置匀速模式下，手指滑动后，页面停留的时长</li><li>要支持设置ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置）</li><li>要支持设置默认是否开启滚动</li><li>要支持设置数据源为空时的默认View</li><li>要支持数据源只有1张banner时，禁止滚动</li><li>要暴露API控制Banner的自动滚动与暂停</li><li>要支持设置指示器（Indicator），且能灵活控制指示器位置，且与BannerView解耦</li></ol><p>🤩这么多需求，不要怕，我们根据需求来理一遍核心技术点：</p><ol><li><code>平滑滚动模式</code>可以使用RecyclerView+PagerSnapHelper实现，<code>间隔滚动模式</code>可以继续使用ViewPager实现，也可以使用前者方式实现。（本文统一使用RecyclerView+PagerSnapHelper方式，不过代码中也留出了接口，可用ViewPager做实现）</li><li>设置圆角还是采用<code>Xfermode</code>做裁剪合成即可。（该方式在之前的文章<strong>ShadowLayout</strong>中使用过，故本文不再赘述）</li><li>需求[4]将adpter中getItemCount()返回Int.MAX_VALUE，再在绑定View时候，用当前的position与真实count求余数，作为真实的position去绑定数据，即可实现。</li><li>需求[4]到[13]，都没有技术复杂度，但有业务复杂度，做常规实现即可。</li><li>需求[14]可定义Indicator涉及的接口做代码解耦，并将BannerView继承RelativeLayout，这样Indicator作为子View在xml中可灵活控制位置。</li></ol><p>这样一来，实现我们想要的BannerView只是耐心+时间的问题了。以下，我会挑本次实现中重要的几点来做说明，如下：</p><ol><li>RecyclerView+PagerSnapHelper实现的<strong>PagerRecyclerView</strong></li><li>生成PagerView实例的工厂<strong>PagerViewFactory</strong></li><li>Indicator的解耦实现</li></ol><h2 id="PagerRecyclerView"><a href="#PagerRecyclerView" class="headerlink" title="PagerRecyclerView"></a>PagerRecyclerView</h2><p>看名字便知这是一个用RecyclerView实现ViewPager功能的类，所以继承自RecyclerView。</p><p>它作为BannerView的核心功能实现类，为了与上层解耦（也就是方便切换为其它实现，比如用ViewPager做实现）所以定义接口<code>IPagerViewInstance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PagerView功能实例需实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPagerViewInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自动滚动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervalInMillis: Int 在INTERVAL模式下为页面切换间隔 在SMOOTH模式下为滚动一页所需时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">startAutoScroll</span><span class="params">(intervalInMillis: Int)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 停止自动滚动</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">stopAutoScroll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 获取当前Item的位置（List的索引）</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">getCurrentPosition</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 获取当前真实的Item的位置（List的索引）</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">getRealCurrentPosition</span><span class="params">(realCount: Int)</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 设置平滑模式是否开启，否则为间隔切换模式</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">setSmoothMode</span><span class="params">(enabled: Boolean)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 设置页面停留时长</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">setPageHoldInMillis</span><span class="params">(pageHoldInMillis: Int)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 设置页面切换回调</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">setOnPageChangeListener</span><span class="params">(listener: OnPageChangeListener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 通知数据刷新</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">notifyDataSetChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>关于<code>PagerSnapHelper</code>的使用极其简单，只需创建出实例，attachToRecyclerView一下，即可让RecyclerView摇身一变成为ViewPager一样。（这里实在让人惊叹！！我们都应该追求这种API的极致设计）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动到具体位置帮助器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> var mSnapHelper: PagerSnapHelper = PagerSnapHelper()</span><br><span class="line">... 省略代码</span><br><span class="line">init &#123;</span><br><span class="line">    mSnapHelper.attachToRecyclerView(<span class="keyword">this</span>)</span><br><span class="line">    ... 省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>间隔切换模式 匀速滚动模式</code>的实现主要是在<code>startTimer()</code>方法中，两者的区别在于Timer的间隔时间不同、回调中执行的方法不同。其中匀速模式的Timer间隔时间需要使用<code>外部设置的滚动一屏的时间、一屏的宽度、每次scrollBy的距离</code>计算而来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">startTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTimer?.cancel()</span><br><span class="line">    <span class="keyword">if</span> (mWidth &gt; <span class="number">0</span> &amp;&amp; mFlagStartTimer &amp;&amp; context != <span class="keyword">null</span> &amp;&amp; context is Activity) &#123;</span><br><span class="line">        mTimer = timer(initialDelay = mDelayedTime, period = mPeriodTime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mScrollState == SCROLL_STATE_IDLE) &#123;</span><br><span class="line">                (context as Activity).runOnUiThread &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mSmoothMode) &#123;</span><br><span class="line">                        scrollBy(DEFAULT_PERIOD_SCROLL_PIXEL, <span class="number">0</span>)</span><br><span class="line">                        triggerOnPageSelected()</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        smoothScrollToPosition(++mOldPosition)</span><br><span class="line">                        mPageChangeListener?.onPageSelected(mOldPosition)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">onSizeChanged</span><span class="params">(w: Int, h: Int, oldw: Int, oldh: Int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">    mWidth = (w - paddingLeft - paddingRight).toFloat()</span><br><span class="line">    mHeight = (h - paddingTop - paddingBottom).toFloat()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算匀速滚动的时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (mSmoothMode) &#123;</span><br><span class="line">        mPeriodTime = (mSmoothSpeed / (mWidth / DEFAULT_PERIOD_SCROLL_PIXEL)).toLong()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        startTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>页面选中</strong>是根据PagerSnapHelper中提供的findSnapView方法，先找到Snap（就是当前的目标View），再找它的位置，当然还需用一个变量记录一下，防止多次触发回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发OnPageSelected回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">triggerOnPageSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val layoutManager = getLinearLayoutManager()</span><br><span class="line">    val view = mSnapHelper.findSnapView(layoutManager)</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        val position = layoutManager.getPosition(view)</span><br><span class="line">        <span class="comment">//防止同一位置多次触发</span></span><br><span class="line">        <span class="keyword">if</span> (position != mOldPosition) &#123;</span><br><span class="line">            mOldPosition = position</span><br><span class="line">            mPageChangeListener?.onPageSelected(position)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个值得说道的点是初始化时需要矫正<strong>Snap</strong>的位置，因为<strong>PagerSnapHelper</strong>手指滑动的时候才工作让RecyclerView滑动出ViewPager的感觉，所以初始化时不矫正会发现选中的页面不居中显示，还是一个RecyclerView的样子。那如何矫正呢？这里去看了<strong>PagerSnapHelper</strong>实现，搬过来，稍加修改即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矫正首次初始化时SnapView的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">correctSnapViewPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val layoutManager = getLinearLayoutManager()</span><br><span class="line">    val snapView = mSnapHelper.findSnapView(layoutManager)</span><br><span class="line">    <span class="keyword">if</span> (snapView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        val snapDistance = mSnapHelper.calculateDistanceToFinalSnap(layoutManager, snapView)</span><br><span class="line">        <span class="keyword">if</span> (snapDistance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapDistance[<span class="number">0</span>] != <span class="number">0</span> || snapDistance[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//我们把源码的smoothScrollBy改为scrollBy，这样视觉上觉察不出矫正过程</span></span><br><span class="line">                scrollBy(snapDistance[<span class="number">0</span>], snapDistance[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//首次触发回调</span></span><br><span class="line">            triggerOnPageSelected()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是源码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snapToTargetExistingView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mRecyclerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LayoutManager layoutManager = <span class="keyword">this</span>.mRecyclerView.getLayoutManager();</span><br><span class="line">        <span class="keyword">if</span> (layoutManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            View snapView = <span class="keyword">this</span>.findSnapView(layoutManager);</span><br><span class="line">            <span class="keyword">if</span> (snapView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] snapDistance = <span class="keyword">this</span>.calculateDistanceToFinalSnap(layoutManager, snapView);</span><br><span class="line">                <span class="keyword">if</span> (snapDistance[<span class="number">0</span>] != <span class="number">0</span> || snapDistance[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mRecyclerView.smoothScrollBy(snapDistance[<span class="number">0</span>], snapDistance[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我认为PagerRecyclerView较为关键的点，其它部分均为业务逻辑的处理与实现，大家可打开源码自行食用。</p><h2 id="PagerViewFactory"><a href="#PagerViewFactory" class="headerlink" title="PagerViewFactory"></a>PagerViewFactory</h2><p>这里采用了<strong>工厂方法模式</strong>来创建Banner底层的核心实现。</p><p>首先定义了BannerView实例接口，它将作为工厂实例的构造方法参数，用于区分创建底层实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBannerViewBase</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getCount</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemView</span><span class="params">(context: Context)</span>: View</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">onBindView</span><span class="params">(itemView: View, position: Int)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 定义BannerView实例接口</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">interface IBannerViewInstance : IBannerViewBase </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">getContext</span><span class="params">()</span>: Context</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">isSmoothMode</span><span class="params">()</span>: Boolean</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemViewWidth</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemViewMargin</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemViewAlign</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>工厂有个getPagerView()的方法，来创建Banner核心实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂根据参数创建对应PagerView实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">override fun <span class="title">getPagerView</span><span class="params">()</span>: IPagerViewInstance </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (bannerView.isSmoothMode()) &#123;</span><br><span class="line">        casePagerRecycler(<span class="keyword">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervalUseViewPager) &#123;</span><br><span class="line">            <span class="comment">//这里可以根据需要用ViewPager做底层实现</span></span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">"这里未使用ViewPager做底层实现"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            casePagerRecycler(<span class="keyword">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是创建了之前写好的PagerRecyclerView，其实就是创建配置使用一个RecyclerView的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理PagerRecyclerView</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">casePagerRecycler</span><span class="params">(isSmoothMode: Boolean)</span>: IPagerViewInstance </span>&#123;</span><br><span class="line">    val recyclerView = PagerRecyclerView(bannerView.getContext())</span><br><span class="line">    recyclerView.layoutManager = LinearLayoutManager(bannerView.getContext(), LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>)</span><br><span class="line">    recyclerView.adapter = object : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">        <span class="function">override fun <span class="title">getItemCount</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Int.MAX_VALUE</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">onBindViewHolder</span><span class="params">(holder: RecyclerView.ViewHolder, position: Int)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isActivityDestroyed(holder.itemView.context)) &#123;</span><br><span class="line">                val realPos = position % bannerView.getCount()</span><br><span class="line">                bannerView.onBindView(holder.itemView.findViewById(R.id.id_real_item_view), realPos)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">onCreateViewHolder</span><span class="params">(parent: ViewGroup, viewType: Int)</span>: RecyclerView.ViewHolder </span>&#123;</span><br><span class="line">            val itemWrapper = LayoutInflater.from(parent.context).inflate(</span><br><span class="line">                R.layout.layout_banner_item_wrapper,</span><br><span class="line">                parent,</span><br><span class="line">                <span class="keyword">false</span></span><br><span class="line">            ) as RelativeLayout</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理ItemViewWrapper的宽</span></span><br><span class="line">            itemWrapper.layoutParams.width = bannerView.getItemViewWidth() + bannerView.getItemViewMargin()</span><br><span class="line"></span><br><span class="line">            <span class="comment">//外部实际的ItemView</span></span><br><span class="line">            val itemView = bannerView.getItemView(parent.context)</span><br><span class="line">            itemView.id = R.id.id_real_item_view</span><br><span class="line">            val ivParams = RelativeLayout.LayoutParams(</span><br><span class="line">                bannerView.getItemViewWidth(),</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">            )</span><br><span class="line">            ivParams.addRule(bannerView.getItemViewAlign())</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加ItemView到Wrapper</span></span><br><span class="line">            itemWrapper.addView(itemView, ivParams)</span><br><span class="line">            <span class="keyword">return</span> object : RecyclerView.ViewHolder(itemWrapper) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化位置</span></span><br><span class="line">    recyclerView.scrollToPosition(bannerView.getCount() * <span class="number">100</span>)</span><br><span class="line">    recyclerView.setSmoothMode(isSmoothMode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recyclerView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Indicator的解耦实现"><a href="#Indicator的解耦实现" class="headerlink" title="Indicator的解耦实现"></a>Indicator的解耦实现</h2><p>解耦的惯用套路就是抽象方法定义接口。所以我们定义了两个接口，一个是<strong>指示器实例需实现的接口</strong>，一个是<strong>指示器依赖的外部实现</strong>。所以使用这两个接口，可以自定义实现想要的样式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指示器实例需实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IIndicatorInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置外部实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">setIndicator</span><span class="params">(impl: IIndicator)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 重新布局</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">doRequestLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 重新绘制</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">doInvalidate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 指示器依赖的外部实现</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">interface IIndicator </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取adapter总数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">getCount</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 获取当前选中页面的索引</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">getCurrentIndex</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>对于我们这次实现的CrossBarIndicator，它就是一个常规的自定义View，这里已没有什么好说的啦。重点要说的是需求中有<strong>一条且能灵活控制指示器位置</strong>，如何实现呢？需求分析时说了，我们的BannerView是一个RelativeLayout，Indicator作为其子View可以很方便的控制其位置。</p><p>然后，看下BannerView中的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate()</span><br><span class="line">    findIndicator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在子View中找到指示器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">findIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until childCount) &#123;</span><br><span class="line">        val child = getChildAt(i)</span><br><span class="line">        <span class="keyword">if</span> (child is IIndicatorInstance) &#123;</span><br><span class="line">            <span class="comment">//布局填充完毕时，找到子View中的Indicator，并保存下来</span></span><br><span class="line">            mIndicator = child</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBannerViewImpl != <span class="keyword">null</span> &amp;&amp; mWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        val bvImpl = mBannerViewImpl!!</span><br><span class="line">        removeAllViews()</span><br><span class="line"></span><br><span class="line">        ... 省略代码</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化指示器</span></span><br><span class="line">        <span class="keyword">if</span> (mIndicator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mIndicator?.setIndicator(object : IIndicator &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function">override fun <span class="title">getCount</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> bvImpl.getCount()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">override fun <span class="title">getCurrentIndex</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> mPagerViewInstance.getRealCurrentPosition(bvImpl.getCount())</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//把指示器再添加回去</span></span><br><span class="line">            addView(mIndicator as View)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>到这里整体要说的就完结了，整个BannerView的实现细节、逻辑还是很多的，不过复杂度倒没那么高，建议食用源码~ O(∩_∩)O哈哈~</p><p><strong>个人能力有限，如有不正之处欢迎大家批评指出，我会虚心接受并第一时间修改，以不误导大家。</strong></p><h2 id="拜读的文章"><a href="#拜读的文章" class="headerlink" title="拜读的文章"></a><strong>拜读的文章</strong></h2><p>SnapHelper硬核讲解：</p><blockquote><p><a href="https://juejin.im/post/5cbe78ae5188250a6b183872" target="_blank" rel="noopener">https://juejin.im/post/5cbe78ae5188250a6b183872</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/640112319204sda.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
      <category term="Banner" scheme="https://zhangmiao.cc/tags/Banner/"/>
    
  </entry>
  
  <entry>
    <title>Android Context细节解析</title>
    <link href="https://zhangmiao.cc/posts/b902250c.html"/>
    <id>https://zhangmiao.cc/posts/b902250c.html</id>
    <published>2019-08-19T09:37:48.000Z</published>
    <updated>2019-08-19T09:52:41.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Context到底是啥？"><a href="#Context到底是啥？" class="headerlink" title="Context到底是啥？"></a>Context到底是啥？</h2><p>Context 本身是一个抽象类，它的实现类为 ContextImpl。</p><p>另外有子类 ContextWrapper 和 ContextThemeWrapper，这两个子类都是 Context 的代理类，主要区别是 ContextThemeWrapper 有自己的主题资源。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819173910.png" alt></p><p>一个 Context 意味着一个<strong>场景</strong>，一个场景就是我们和软件进行<strong>交互的一个过程</strong>。</p><p>从安卓程序的角度来看，其实一个 Activity 就是一个 Context ，一个 Service 也是一个 Context。</p><a id="more"></a><h2 id="Context有啥作用？"><a href="#Context有啥作用？" class="headerlink" title="Context有啥作用？"></a>Context有啥作用？</h2><p>有啥用？要看它能做啥，看看主要提供了哪些接口了。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174053.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174212.png" alt></p><p>还挺多的，看起来管得挺多，四大组件都管着，像个 Application 大管家。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174304.png" alt></p><h2 id="一个app里有多少个Context？"><a href="#一个app里有多少个Context？" class="headerlink" title="一个app里有多少个Context？"></a>一个app里有多少个Context？</h2><p>前面说啦，一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。</p><h2 id="ContextImpl和ContextWrapper有啥区别？"><a href="#ContextImpl和ContextWrapper有啥区别？" class="headerlink" title="ContextImpl和ContextWrapper有啥区别？"></a>ContextImpl和ContextWrapper有啥区别？</h2><p>看下ContextWrapper：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174343.png" alt></p><p>再看下ContextImpl：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174949.png" alt></p><p>比较下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174503.png" alt></p><p>不同组件创建ContextImpl的方式：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174546.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174608.png" alt></p><p>Context相当于Application的大管家；</p><p>ContextWrapper、ContextThemWrapper都是Context的代理类，ContextImpl是Context的主要实现类，是个实力派！</p><p>参考:</p><p><a href="https://juejin.im/post/5c1fab7d5188254eb05fbe48" target="_blank" rel="noopener">https://juejin.im/post/5c1fab7d5188254eb05fbe48</a></p><p><a href="https://juejin.im/post/5865bfa1128fe10057e57c63" target="_blank" rel="noopener">https://juejin.im/post/5865bfa1128fe10057e57c63</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Context到底是啥？&quot;&gt;&lt;a href=&quot;#Context到底是啥？&quot; class=&quot;headerlink&quot; title=&quot;Context到底是啥？&quot;&gt;&lt;/a&gt;Context到底是啥？&lt;/h2&gt;&lt;p&gt;Context 本身是一个抽象类，它的实现类为 ContextImpl。&lt;/p&gt;
&lt;p&gt;另外有子类 ContextWrapper 和 ContextThemeWrapper，这两个子类都是 Context 的代理类，主要区别是 ContextThemeWrapper 有自己的主题资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819173910.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;一个 Context 意味着一个&lt;strong&gt;场景&lt;/strong&gt;，一个场景就是我们和软件进行&lt;strong&gt;交互的一个过程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从安卓程序的角度来看，其实一个 Activity 就是一个 Context ，一个 Service 也是一个 Context。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android 中东阿拉伯语适配</title>
    <link href="https://zhangmiao.cc/posts/c080be13.html"/>
    <id>https://zhangmiao.cc/posts/c080be13.html</id>
    <published>2019-08-17T13:44:25.000Z</published>
    <updated>2019-08-17T14:08:53.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RTL-语言由来"><a href="#RTL-语言由来" class="headerlink" title="RTL 语言由来"></a>RTL 语言由来</h3><p>RTL 是 Right-to-left(从右向左) 的缩写。其意为人们书写阅读习惯是从右向左，朝左继续的，常见的 RTL 语言有阿拉伯语，希伯来语等。</p><p>看一下对比：</p><table><thead><tr><th align="center">LTR</th><th align="center">RTL</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817215957.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817220045.png" alt></td></tr></tbody></table><p>那么对于这种从右到左的习惯，在 Android 布局中有没有支持呢？</p><p>答案是有的：从 Android 4.2 即 SDK 17 开始，提供了全面的本地布局支持，允许镜像布局，可以同时支持 RTL 和 LTR。</p><a id="more"></a><p>接下来我将介绍如何一步一步适配阿拉伯语。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>name</th><th>desc</th><th>chinese</th></tr></thead><tbody><tr><td>android:layoutDirection</td><td>attribute for setting the direction of a component’s layout</td><td>设置组件的布局排列方向</td></tr><tr><td>android:textDirection</td><td>attribute for setting the direction of a component’s text</td><td>设置组件的文字排列方向</td></tr><tr><td>android:textAlignment</td><td>attribute for setting the alignment of a component’s text</td><td>设置文字的对齐方式</td></tr><tr><td>getLayoutDirectionFromLocale()</td><td>method for getting the Locale-specified direction</td><td>获取指定地区的惯用布局方式</td></tr></tbody></table><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在 AndroidManifest.xml 文件中 application 节点添加支持从右到左布局方式代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="切换语言"><a href="#切换语言" class="headerlink" title="切换语言"></a>切换语言</h3><p>相关链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2900023%2Fchange-language-programmatically-in-android" target="_blank" rel="noopener">change-language-programmatically-in-android</a><br> 对应国家语言代码: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F7973023%2Fwhat-is-the-list-of-supported-languages-locales-on-android" target="_blank" rel="noopener">what-is-the-list-of-supported-languages-locales-on-android</a><br> 下面切换语言方式 updateConfiguration 方法在 Api 25 已经过时, 新的切换方式实例 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FDroidKaigi%2Fconference-app-2017%2Fpull%2F315%2Ffiles" target="_blank" rel="noopener">地址</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String languageToLoad  = <span class="string">"ar"</span>; <span class="comment">// your language</span></span><br><span class="line">Resources res = getResources(); </span><br><span class="line">DisplayMetrics dm = res.getDisplayMetrics();</span><br><span class="line">Locale locale = <span class="keyword">new</span> Locale(languageToLoad); </span><br><span class="line">Locale.setDefault(locale);</span><br><span class="line">Configuration config = <span class="keyword">new</span> Configuration();</span><br><span class="line">config.locale = locale;</span><br><span class="line">res.updateConfiguration(conf, dm);</span><br></pre></td></tr></table></figure><h3 id="AS-一键适配"><a href="#AS-一键适配" class="headerlink" title="AS 一键适配"></a>AS 一键适配</h3><p>AS 支持一键适配 RTL，主要是在原来 Layout 中设置 Left 和 Right 属性的补充添加 Start 和 End 属性（你们在写布局的时候是不是很少用到 paddingStart、marginStart？接下来你们写布局的时候可不能再偷懒了，该加的还是得加上)</p><p>Start 属性在 LTR 中对应 Left，在 RTL 中对应 Right，在API 17开始支持，为了兼容低版本，需要同时有 Left 和 Start。从市场来看，Android 4.2 系统以下的手机用户已经不多了，我的建议是可以不兼容，具体还得你们看自家产品在 4.2 系统以下用户数。</p><blockquote><p>Refactor &gt; Add RTL Support Where Possible…</p></blockquote><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817215036.png" alt></p><h3 id="利用第三方插件"><a href="#利用第三方插件" class="headerlink" title="利用第三方插件"></a>利用第三方插件</h3><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fznyang%2Fgradle-android-rtl" target="_blank" rel="noopener">gradle-android-rtl</a></td><td align="center">自动修复布局文件中未添加RTL支持的标签</td></tr></tbody></table><p>与 AS 插件的比较：</p><ul><li>性能更好。在处理大批量文件修改时，用AS工具会出现卡顿</li><li>支持padding标签的补齐</li></ul><h3 id="使用全局样式"><a href="#使用全局样式" class="headerlink" title="使用全局样式"></a>使用全局样式</h3><h4 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h4><p>发现 EditText 控件基本都需要设置下面两个属性<br> 相关链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F10903647%2Fset-a-consistent-style-to-all-edittext-for-e-g" target="_blank" rel="noopener">set-a-consistent-style-to-all-edittext-for-e-g</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:textAlignment="viewStart"</span><br><span class="line">android:gravity="start"</span><br></pre></td></tr></table></figure><p>那我们就可以在 style.xml 样式中全部 EditText 都设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"editTextStyle"</span>&gt;</span>@style/EditTextStyle.Alignment<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"EditTextStyle.Alignment"</span> <span class="attr">parent</span>=<span class="string">"@android:style/Widget.EditText"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textAlignment"</span>&gt;</span>viewStart<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:gravity"</span>&gt;</span>start<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textDirection"</span>&gt;</span>locale<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h4><p>全局给所有 TextView 添加一个 RTL 属性<br> 相关链接:<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F3078081%2Fsetting-global-styles-for-views-in-android" target="_blank" rel="noopener">setting-global-styles-for-views-in-android</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textViewStyle"</span>&gt;</span>@style/TextViewStyle.TextDirection<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"TextViewStyle.TextDirection"</span> <span class="attr">parent</span>=<span class="string">"android:Widget.TextView"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textDirection"</span>&gt;</span>locale<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="判断是否是-RTL-布局"><a href="#判断是否是-RTL-布局" class="headerlink" title="判断是否是 RTL 布局"></a>判断是否是 RTL 布局</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextUtilsCompat.getLayoutDirectionFromLocale(Locale.getDefault()) == LayoutDirection.RTL</span><br></pre></td></tr></table></figure><h3 id="对集合进行倒序处理"><a href="#对集合进行倒序处理" class="headerlink" title="对集合进行倒序处理"></a>对集合进行倒序处理</h3><p>在某些场合下, 这个方法很有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(List&lt;?&gt; list);</span><br></pre></td></tr></table></figure><h3 id="代码动态设置控件-setMargins"><a href="#代码动态设置控件-setMargins" class="headerlink" title="代码动态设置控件 setMargins"></a>代码动态设置控件 setMargins</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FrameLayout.LayoutParams params = <span class="keyword">new</span> FrameLayout.LayoutParams(</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">params.setMargins(<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">params.setMarginEnd(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h3><p>相关链接: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F37196714%2Ftabs-swipe-direction-in-right-to-left-android-app" target="_blank" rel="noopener">tabs-swipe-direction-in-right-to-left-android-app</a></p><blockquote><p>Android 官方控件大多支持 RTL，ViewPager 除外，GitHub 上面有人对 ViewPager 进行修改支持 RTL, <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fdiego-gomez-olvera%2FRtlViewPager" target="_blank" rel="noopener">地址</a></p></blockquote><h3 id="适配总结"><a href="#适配总结" class="headerlink" title="适配总结"></a>适配总结</h3><ol><li>横向布局 LinearLayout ，可以使用 FrameLayout，控件需要靠左或靠右可以使用 layout_gravity 设置对应属性</li><li>切换阿拉伯语时，网格布局 item 之间的距离会出现增大问题，处理方法是：网格分割线 ItemDecoration 需要加入语言来判断，调换原来设置左右的边距即可</li><li>禁止掉之前的侧滑返回，以免出现冲突</li><li>一些方向图标，重新做一个相对方向的放到 mipmap-ldrtl-xxxhdpi 包下</li><li>动画翻转, 放在 anim-ldrtl 将对应的动画进行反向处理</li><li>布局里如果设置了 paddingLeft、drawableLeft 等等这些属性更改为一个支持 RTL 的属性 paddingStart、drawableStart；但是有些地方可以不加的，例如：购物车上的数量徽章，加了之后感觉怪怪的，所以还是不加了</li><li>利用在 AS 右边的预览布局工具中的语言切换工具，切换成阿拉伯语，能实时看到布局的效果图</li><li>EditText 添加 android:layoutDirection=”locale” ，如果外面有 TextInputLayout 的需给它设置 android:textDirection=”locale” ，如果输入类型时密码时还需添加一个属性 android:textAlignment=”viewStart”</li><li>TextView 需要加上 android:textAlignment=”viewStart 或 viewEnd” 以及 android:textDirection=”locale”</li><li>RecyclerView 网络布局的可以考虑使用 StaggeredGridLayoutManager ，如果数量太多的网格布局，不太建议使用，可能会出现滑动混乱</li><li>阿拉伯语目录下的 String.xml 文件, 出现占位符 d% 需要注意改为 %d, 但又并不是所有都改成这样, 目前我发现当代码中使用了 Toast 和 SpannableString 属性的就需要更改为 %d</li></ol><h3 id="建议计划"><a href="#建议计划" class="headerlink" title="建议计划"></a>建议计划</h3><ol><li>从基础类开始入手，判断是否是阿拉伯语，如果是需要将界面设置为从右到左的显示方式</li><li>分模块进行适配</li><li>复杂的模块，可以放到 layout-ldrtl 包下，单独做一个布局来适配阿拉伯语，例如详情页</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fandroid-developers.googleblog.com%2F2013%2F03%2Fnative-rtl-support-in-android-42.html" target="_blank" rel="noopener">https://android-developers.googleblog.com/2013/03/native-rtl-support-in-android-42.html</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmedium.com%2F%40zhangqichuan%2Frtl-support-in-android-898e11f31561" target="_blank" rel="noopener">https://medium.com/@zhangqichuan/rtl-support-in-android-898e11f31561</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmobikul.com%2Fjust-few-steps-to-make-your-app-rtl-supportable%2F" target="_blank" rel="noopener">https://mobikul.com/just-few-steps-to-make-your-app-rtl-supportable/</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.robustastudio.com%2Ffeatured%2Fandroid-rtl-support%2F" target="_blank" rel="noopener">https://blog.robustastudio.com/featured/android-rtl-support/</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Ffigo0423%2Farticle%2Fdetails%2F50241363" target="_blank" rel="noopener">http://blog.csdn.net/figo0423/article/details/50241363</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fwxx614817%2Farticle%2Fdetails%2F50586388" target="_blank" rel="noopener">http://blog.csdn.net/wxx614817/article/details/50586388</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fjiajixin.cn%2F2016%2F10%2F08%2Fandroid_adapt_rtl%2F" target="_blank" rel="noopener">http://jiajixin.cn/2016/10/08/android_adapt_rtl/</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.apkbus.com%2Fblog-327085-57866.html" target="_blank" rel="noopener">http://www.apkbus.com/blog-327085-57866.html</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdroidyue.com%2Fblog%2F2014%2F07%2F07%2Fsupport-rtl-in-android%2Findex.html" target="_blank" rel="noopener">http://droidyue.com/blog/2014/07/07/support-rtl-in-android/index.html</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fchuansong.me%2Fn%2F920084451521" target="_blank" rel="noopener">http://chuansong.me/n/920084451521</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RTL-语言由来&quot;&gt;&lt;a href=&quot;#RTL-语言由来&quot; class=&quot;headerlink&quot; title=&quot;RTL 语言由来&quot;&gt;&lt;/a&gt;RTL 语言由来&lt;/h3&gt;&lt;p&gt;RTL 是 Right-to-left(从右向左) 的缩写。其意为人们书写阅读习惯是从右向左，朝左继续的，常见的 RTL 语言有阿拉伯语，希伯来语等。&lt;/p&gt;
&lt;p&gt;看一下对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;LTR&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;RTL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817215957.png&quot; alt&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817220045.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;那么对于这种从右到左的习惯，在 Android 布局中有没有支持呢？&lt;/p&gt;
&lt;p&gt;答案是有的：从 Android 4.2 即 SDK 17 开始，提供了全面的本地布局支持，允许镜像布局，可以同时支持 RTL 和 LTR。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="阿拉伯语" scheme="https://zhangmiao.cc/tags/%E9%98%BF%E6%8B%89%E4%BC%AF%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>轻量级存储框架MMKV</title>
    <link href="https://zhangmiao.cc/posts/4770b281.html"/>
    <id>https://zhangmiao.cc/posts/4770b281.html</id>
    <published>2019-08-17T13:14:35.000Z</published>
    <updated>2019-08-17T14:21:21.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>APP 的性能优化之路是永无止境的, 这里学习一个<strong>腾讯开源用于提升本地存储效率的轻量级存储框架</strong> <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV" target="_blank" rel="noopener">MMKV</a></p><p>目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR</p><p>网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了</p><p>因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架</p><h2 id="二、集成与测试"><a href="#二、集成与测试" class="headerlink" title="二、集成与测试"></a>二、集成与测试</h2><p>以下介绍简单的使用方式, 更多详情请查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn" target="_blank" rel="noopener">Wiki</a></p><h3 id="2-1-依赖注入"><a href="#2-1-依赖注入" class="headerlink" title="2.1 依赖注入"></a>2.1 依赖注入</h3><p>在 App 模块的 build.gradle 文件里添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.tencent:mmkv:1.0.22&apos;</span><br><span class="line">    // replace &quot;1.0.22&quot; with any available version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置初始化的根目录</span></span><br><span class="line">String dir = getFilesDir().getAbsolutePath() + <span class="string">"/mmkv_2"</span>;</span><br><span class="line">String rootDir = MMKV.initialize(dir);</span><br><span class="line">Log.i(<span class="string">"MMKV"</span>, <span class="string">"mmkv root: "</span> + rootDir);</span><br></pre></td></tr></table></figure><h3 id="2-3-获取实例"><a href="#2-3-获取实例" class="headerlink" title="2.3 获取实例"></a>2.3 获取实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认的全局实例</span></span><br><span class="line">MMKV kv = MMKV.defaultMMKV();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据业务区别存储, 附带一个自己的 ID</span></span><br><span class="line">MMKV kv = MMKV.mmkvWithID(<span class="string">"MyID"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多进程同步支持</span></span><br><span class="line">MMKV kv = MMKV.mmkvWithID(<span class="string">"MyID"</span>, MMKV.MULTI_PROCESS_MODE);</span><br></pre></td></tr></table></figure><h3 id="2-4-CURD"><a href="#2-4-CURD" class="headerlink" title="2.4 CURD"></a>2.4 CURD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加/更新数据</span></span><br><span class="line">kv.encode(key, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">int</span> tmp = kv.decodeInt(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">kv.removeValueForKey(key);</span><br></pre></td></tr></table></figure><h3 id="2-5-SP-的迁移"><a href="#2-5-SP-的迁移" class="headerlink" title="2.5 SP 的迁移"></a>2.5 SP 的迁移</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testImportSharedPreferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MMKV mmkv = MMKV.mmkvWithID(<span class="string">"myData"</span>);</span><br><span class="line">    SharedPreferences old_man = getSharedPreferences(<span class="string">"myData"</span>, MODE_PRIVATE);</span><br><span class="line">    <span class="comment">// 迁移旧数据</span></span><br><span class="line">    mmkv.importFromSharedPreferences(old_man);</span><br><span class="line">    <span class="comment">// 清空旧数据</span></span><br><span class="line">    old_man.edit().clear().commit();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-数据测试"><a href="#2-6-数据测试" class="headerlink" title="2.6 数据测试"></a>2.6 数据测试</h3><p>以下是 MMKV、SharedPreferences 和 SQLite 同步写入 1000 条数据的测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV</span></span><br><span class="line">MMKV: MMKV write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">12</span> ms</span><br><span class="line">MMKV: MMKV read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">3</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: MMKV write String: loop[<span class="number">1000</span>]: <span class="number">7</span> ms</span><br><span class="line">MMKV: MMKV read String: loop[<span class="number">1000</span>]: <span class="number">4</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// SharedPreferences</span></span><br><span class="line">MMKV: SharedPreferences write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">119</span> ms</span><br><span class="line">MMKV: SharedPreferences read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">3</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: SharedPreferences write String: loop[<span class="number">1000</span>]: <span class="number">187</span></span><br><span class="line">MMKV: SharedPreferences read String: loop[<span class="number">1000</span>]: <span class="number">2</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQLite</span></span><br><span class="line">MMKV: sqlite write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">101</span> ms</span><br><span class="line">MMKV: sqlite read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">136</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: sqlite write String: loop[<span class="number">1000</span>]: <span class="number">29</span> ms</span><br><span class="line">MMKV: sqlite read String: loop[<span class="number">1000</span>]: <span class="number">93</span> ms</span><br></pre></td></tr></table></figure><p>可以看到 MMKV 无论是对比 SP 还是 SQLite, 在性能上都有非常大的优势, 官方提供的数据测试结果如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817211812.png" alt></p><p>更详细的性能测试见 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_benchmark_cn" target="_blank" rel="noopener">wiki</a></p><p>了解 MMKV 的使用方式和测试结果, 让我对其实现原理产生了很大的好奇心, 接下来便看看它是如何将性能做到这个地步的, 这里对主要对 MMKV 的基本操作进行剖析</p><ul><li>初始化</li><li>实例化</li><li>encode</li><li>decode</li><li>进程读写的同步</li></ul><p>我们从初始化的流程开始分析</p><h2 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call on program start</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initialize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String root = context.getFilesDir().getAbsolutePath() + <span class="string">"/mmkv"</span>;</span><br><span class="line">        <span class="keyword">return</span> initialize(root, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> String rootDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initialize</span><span class="params">(String rootDir, LibLoader loader)</span> </span>&#123;</span><br><span class="line">        ...... <span class="comment">// 省略库文件加载器相关代码</span></span><br><span class="line">        <span class="comment">// 保存根目录</span></span><br><span class="line">        MMKV.rootDir = rootDir;</span><br><span class="line">        <span class="comment">// Native 层初始化</span></span><br><span class="line">        jniInitialize(MMKV.rootDir);</span><br><span class="line">        <span class="keyword">return</span> rootDir;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">jniInitialize</span><span class="params">(String rootDir)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MMKV 的初始化, 主要是将根目录通过 jniInitialize 传入了 Native 层, 接下来看看 Native 的初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line">    </span><br><span class="line"><span class="function">MMKV_JNI <span class="keyword">void</span> <span class="title">jniInitialize</span><span class="params">(JNIEnv *env, jobject obj, jstring rootDir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootDir) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *kstr = env-&gt;GetStringUTFChars(rootDir, nullptr);</span><br><span class="line">    <span class="keyword">if</span> (kstr) &#123;</span><br><span class="line">        MMKV::initializeMMKV(kstr);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(rootDir, kstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> unordered_map&lt;std::string, MMKV *&gt; *g_instanceDic;</span><br><span class="line"><span class="keyword">static</span> ThreadLock g_instanceLock;</span><br><span class="line"><span class="keyword">static</span> std::string g_rootDir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.1 获取一个 unordered_map, 类似于 Java 中的 HashMap</span></span><br><span class="line">    g_instanceDic = <span class="keyword">new</span> unordered_map&lt;std::string, MMKV *&gt;;</span><br><span class="line">    <span class="comment">// 1.2 初始化线程锁</span></span><br><span class="line">    g_instanceLock = ThreadLock();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MMKV::initializeMMKV(<span class="keyword">const</span> std::string &amp;rootDir) &#123;</span><br><span class="line">    <span class="comment">// 由 Linux Thread 互斥锁和条件变量保证 initialize 函数在一个进程内只会执行一次</span></span><br><span class="line">    <span class="comment">// https://blog.csdn.net/zhangxiao93/article/details/51910043</span></span><br><span class="line">    <span class="keyword">static</span> pthread_once_t once_control = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="comment">// 1. 进行初始化操作</span></span><br><span class="line">    pthread_once(&amp;once_control, initialize);</span><br><span class="line">    <span class="comment">// 2. 将根目录保存到全局变量</span></span><br><span class="line">    g_rootDir = rootDir;</span><br><span class="line">    <span class="comment">// 拷贝字符串</span></span><br><span class="line">    <span class="keyword">char</span> *path = strdup(g_rootDir.c_str());</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">        <span class="comment">// 3. 根据路径, 生成目标地址的目录</span></span><br><span class="line">        mkPath(path);</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        free(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 initializeMMKV 中主要任务是初始化数据, 以及创建根目录</p><ul><li>pthread_once_t: 类似于 Java 的单例, 其 initialize 方法在进程内只会执行一次 <ul><li>创建 MMKV 对象的缓存散列表 g_instanceDic</li><li>创建一个线程锁 g_instanceLock</li></ul></li><li>mkPath: 根据字符串创建文件目录</li></ul><p>接下来我们看看这个目录创建的过程</p><h3 id="3-1-目录的创建"><a href="#3-1-目录的创建" class="headerlink" title="3.1 目录的创建"></a>3.1 目录的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MmapedFile.cpp</span></span><br><span class="line"><span class="function">bool <span class="title">mkPath</span><span class="params">(<span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 stat 结构体用于描述文件的属性</span></span><br><span class="line">    struct stat sb = &#123;&#125;;</span><br><span class="line">    bool done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 指向字符串起始地址</span></span><br><span class="line">    <span class="keyword">char</span> *slash = path;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="comment">// 移动到第一个非 "/" 的下标处</span></span><br><span class="line">        slash += strspn(slash, <span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// 移动到第一个 "/" 下标出处</span></span><br><span class="line">        slash += strcspn(slash, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        done = (*slash == <span class="string">'\0'</span>);</span><br><span class="line">        *slash = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stat(path, &amp;sb) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行创建文件夹的操作, C 中无 mkdirs 的操作, 需要一个一个文件夹的创建</span></span><br><span class="line">            <span class="keyword">if</span> (errno != ENOENT || mkdir(path, <span class="number">0777</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                MMKVWarning(<span class="string">"%s : %s"</span>, path, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若非文件夹, 则说明为非法路径</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">            MMKVWarning(<span class="string">"%s: %s"</span>, path, strerror(ENOTDIR));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *slash = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 Native 层创建文件路径的通用代码, 逻辑很清晰</p><p>好的, 文件目录创建好了之后, Native 层的初始化操作便结束了, 接下来看看 MMKV 实例构建的过程</p><h2 id="四、实例化"><a href="#四、实例化" class="headerlink" title="四、实例化"></a>四、实例化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MMKV <span class="title">mmkvWithID</span><span class="params">(String mmapID, <span class="keyword">int</span> mode, String cryptKey, String relativePath)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 执行 Native 初始化, 获取句柄值</span></span><br><span class="line">        <span class="keyword">long</span> handle = getMMKVWithID(mmapID, mode, cryptKey, relativePath);</span><br><span class="line">        <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建一个 Java 的壳对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MMKV(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">    getMMKVWithID(String mmapID, <span class="keyword">int</span> mode, String cryptKey, String relativePath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// jni</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nativeHandle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MMKV</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">        nativeHandle = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 MMKV 实例构建的主要逻辑通过 getMMKVWithID 方法实现, 看它内部做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">MMKV_JNI jlong <span class="title">getMMKVWithID</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JNIEnv *env, jobject, jstring mmapID, jint mode, jstring cryptKey, jstring relativePath)</span> </span>&#123;</span><br><span class="line">    MMKV *kv = nullptr;</span><br><span class="line">    <span class="keyword">if</span> (!mmapID) &#123;</span><br><span class="line">        <span class="keyword">return</span> (jlong) kv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取独立存储 id</span></span><br><span class="line">    string str = jstring2string(env, mmapID);</span><br><span class="line"></span><br><span class="line">    bool done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (cryptKey) &#123;</span><br><span class="line">        <span class="comment">// 获取秘钥</span></span><br><span class="line">        string crypt = jstring2string(env, cryptKey);</span><br><span class="line">        <span class="keyword">if</span> (crypt.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (relativePath) &#123;</span><br><span class="line">                <span class="comment">// 获取相对路径</span></span><br><span class="line">                string path = jstring2string(env, relativePath);</span><br><span class="line">                <span class="comment">// 通过 mmkvWithID 函数获取一个 MMKV 的对象</span></span><br><span class="line">                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, &amp;path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, nullptr);</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 强转成句柄, 返回到 Java</span></span><br><span class="line">    <span class="keyword">return</span> (jlong) kv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终通过  MMKV::mmkvWithID 函数获取到 MMKV 的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">MMKV *MMKV::mmkvWithID(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mmapID.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPEDLOCK(g_instanceLock);</span><br><span class="line">    <span class="comment">// 1. 通过 mmapID 和 relativePath, 组成最终的 mmap 文件路径的 key</span></span><br><span class="line">    auto mmapKey = mmapedKVKey(mmapID, relativePath);</span><br><span class="line">    <span class="comment">// 2. 从全局缓存中查找</span></span><br><span class="line">    auto itr = g_instanceDic-&gt;find(mmapKey);</span><br><span class="line">    <span class="keyword">if</span> (itr != g_instanceDic-&gt;end()) &#123;</span><br><span class="line">        MMKV *kv = itr-&gt;second;</span><br><span class="line">        <span class="keyword">return</span> kv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 创建缓存文件</span></span><br><span class="line">    <span class="keyword">if</span> (relativePath) &#123;</span><br><span class="line">        <span class="comment">// 根据 mappedKVPathWithID 获取 mmap 的最终文件路径</span></span><br><span class="line">        <span class="comment">// mmapID 使用 md5 加密</span></span><br><span class="line">        auto filePath = mappedKVPathWithID(mmapID, mode, relativePath);</span><br><span class="line">        <span class="comment">// 不存在则创建一个文件</span></span><br><span class="line">        <span class="keyword">if</span> (!isFileExist(filePath)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!createFile(filePath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 创建实例对象</span></span><br><span class="line">    auto kv = <span class="keyword">new</span> MMKV(mmapID, size, mode, cryptKey, relativePath);</span><br><span class="line">    <span class="comment">// 5. 缓存这个 mmapKey</span></span><br><span class="line">    (*g_instanceDic)[mmapKey] = kv;</span><br><span class="line">    <span class="keyword">return</span> kv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mmkvWithID 函数的实现流程非常的清晰, 这里我们主要关注一下实例对象的创建流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">MMKV::MMKV(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath)</span><br><span class="line">    : m_mmapID(mmapedKVKey(mmapID, relativePath)) </span><br><span class="line">    <span class="comment">// 拼装文件的路径</span></span><br><span class="line">    , m_path(mappedKVPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    <span class="comment">// 拼装 .crc 文件路径</span></span><br><span class="line">    , m_crcPath(crcPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    <span class="comment">// 1. 将文件映射到内存</span></span><br><span class="line">    , m_metaFile(m_crcPath, DEFAULT_MMAP_SIZE, (mode &amp; MMKV_ASHMEM) ? MMAP_ASHMEM : MMAP_FILE)</span><br><span class="line">    ......</span><br><span class="line">    , m_sharedProcessLock(&amp;m_fileLock, SharedLockType)</span><br><span class="line">    ......</span><br><span class="line">    , m_isAshmem((mode &amp; MMKV_ASHMEM) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 判断是否为 Ashmem 跨进程匿名共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (m_isAshmem) &#123;</span><br><span class="line">        <span class="comment">// 创共享内存的文件</span></span><br><span class="line">        m_ashmemFile = <span class="keyword">new</span> MmapedFile(m_mmapID, static_cast&lt;size_t&gt;(size), MMAP_ASHMEM);</span><br><span class="line">        m_fd = m_ashmemFile-&gt;getFd();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_ashmemFile = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 cryptKey 创建 AES 加解密的引擎</span></span><br><span class="line">    <span class="keyword">if</span> (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        m_crypter = <span class="keyword">new</span> AESCrypt((<span class="keyword">const</span> unsigned <span class="keyword">char</span> *) cryptKey-&gt;data(), cryptKey-&gt;length());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// sensitive zone</span></span><br><span class="line">    &#123;</span><br><span class="line">        SCOPEDLOCK(m_sharedProcessLock);</span><br><span class="line">        <span class="comment">// 2. 根据 m_mmapID 来加载文件中的数据</span></span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从 MMKV 的构造函数中看到很多有趣的信息, <strong>MMKV 是支持 Ashmem 共享内存的, 这意味着即使是跨进程大数据的传输, 它也能够提供很好的性能支持</strong></p><p>不过这里我们主要关注两个关键点</p><ul><li>m_metaFile 文件的映射</li><li>loadFromFile 数据的载入</li></ul><p>接下来我们先看看, 文件的映射</p><h3 id="4-1-文件映射到内存"><a href="#4-1-文件映射到内存" class="headerlink" title="4.1 文件映射到内存"></a>4.1 文件映射到内存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MmapedFile.cpp</span></span><br><span class="line">MmapedFile::MmapedFile(<span class="keyword">const</span> std::string &amp;path, size_t size, bool fileType)</span><br><span class="line">    : m_name(path), m_fd(-<span class="number">1</span>), m_segmentPtr(nullptr), m_segmentSize(<span class="number">0</span>), m_fileType(fileType) &#123;</span><br><span class="line">    <span class="comment">// 用于内存映射的文件</span></span><br><span class="line">    <span class="keyword">if</span> (m_fileType == MMAP_FILE) &#123;</span><br><span class="line">        <span class="comment">// 1. 打开文件</span></span><br><span class="line">        m_fd = open(m_name.c_str(), O_RDWR | O_CREAT, S_IRWXU);</span><br><span class="line">        <span class="keyword">if</span> (m_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            MMKVError(<span class="string">"fail to open:%s, %s"</span>, m_name.c_str(), strerror(errno));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 创建文件锁</span></span><br><span class="line">            <span class="function">FileLock <span class="title">fileLock</span><span class="params">(m_fd)</span></span>;</span><br><span class="line">            <span class="function">InterProcessLock <span class="title">lock</span><span class="params">(&amp;fileLock, ExclusiveLockType)</span></span>;</span><br><span class="line">            SCOPEDLOCK(lock);</span><br><span class="line">            <span class="comment">// 获取文件的信息</span></span><br><span class="line">            struct stat st = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (fstat(m_fd, &amp;st) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取文件大小</span></span><br><span class="line">                m_segmentSize = static_cast&lt;size_t&gt;(st.st_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 验证文件的大小是否小于一个内存页, 一般为 4kb</span></span><br><span class="line">            <span class="keyword">if</span> (m_segmentSize &lt; DEFAULT_MMAP_SIZE) &#123;</span><br><span class="line">                m_segmentSize = static_cast&lt;size_t&gt;(DEFAULT_MMAP_SIZE);</span><br><span class="line">                <span class="comment">// 3.1 通过 ftruncate 将文件大小对其到内存页</span></span><br><span class="line">                <span class="comment">// 3.2 通过 zeroFillFile 将文件对其后的空白部分用 0 填充</span></span><br><span class="line">                <span class="keyword">if</span> (ftruncate(m_fd, m_segmentSize) != <span class="number">0</span> || !zeroFillFile(m_fd, <span class="number">0</span>, m_segmentSize)) &#123;</span><br><span class="line">                    <span class="comment">// 说明文件拓展失败了, 移除这个文件</span></span><br><span class="line">                    close(m_fd);</span><br><span class="line">                    m_fd = -<span class="number">1</span>;</span><br><span class="line">                    removeFile(m_name);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 通过 mmap 将文件映射到内存, 获取内存首地址</span></span><br><span class="line">            m_segmentPtr =</span><br><span class="line">                (<span class="keyword">char</span> *) mmap(nullptr, m_segmentSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (m_segmentPtr == MAP_FAILED) &#123;</span><br><span class="line">                MMKVError(<span class="string">"fail to mmap [%s], %s"</span>, m_name.c_str(), strerror(errno));</span><br><span class="line">                close(m_fd);</span><br><span class="line">                m_fd = -<span class="number">1</span>;</span><br><span class="line">                m_segmentPtr = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于共享内存的文件</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MmapedFile 的构造函数处理的事务如下</p><ul><li>打开指定的文件</li><li>创建这个文件锁</li><li>修正文件大小, 最小为 4kb <ul><li>前 4kb 用于统计数据总大小</li></ul></li><li>通过 mmap 将文件映射到内存</li></ul><p>好的, 通过 MmapedFile 的构造函数, 我们便能够获取到映射后的内存首地址了, 操作这块内存时 Linux 内核会负责将内存中的数据同步到文件中</p><p>比起 SP 的数据同步, mmap 显然是要优雅的多, <strong>即使进程意外死亡, 也能够通过 Linux 内核的保护机制, 将进行了文件映射的内存数据刷入到文件中, 提升了数据写入的可靠性</strong></p><p>结下来看看数据的载入</p><h3 id="4-2-数据的载入"><a href="#4-2-数据的载入" class="headerlink" title="4.2 数据的载入"></a>4.2 数据的载入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// MMKV.cpp</span><br><span class="line">void MMKV::loadFromFile() &#123;</span><br><span class="line">    </span><br><span class="line">    ......// 忽略匿名共享内存相关代码</span><br><span class="line">    </span><br><span class="line">    // 若已经进行了文件映射</span><br><span class="line">    if (m_metaFile.isFileValid()) &#123;</span><br><span class="line">        // 则获取相关数据</span><br><span class="line">        m_metaInfo.read(m_metaFile.getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取文件描述符</span><br><span class="line">    m_fd = open(m_path.c_str(), O_RDWR | O_CREAT, S_IRWXU);</span><br><span class="line">    if (m_fd &lt; 0) &#123;</span><br><span class="line">        MMKVError(&quot;fail to open:%s, %s&quot;, m_path.c_str(), strerror(errno));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 1. 获取文件大小</span><br><span class="line">        m_size = 0;</span><br><span class="line">        struct stat st = &#123;0&#125;;</span><br><span class="line">        if (fstat(m_fd, &amp;st) != -1) &#123;</span><br><span class="line">            m_size = static_cast&lt;size_t&gt;(st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        // 1.1 将文件大小对其到内存页的整数倍</span><br><span class="line">        if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 获取文件映射后的内存地址</span><br><span class="line">        m_ptr = (char *) mmap(nullptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0);</span><br><span class="line">        if (m_ptr == MAP_FAILED) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 3. 读取内存文件的前 32 位, 获取存储数据的真实大小</span><br><span class="line">            memcpy(&amp;m_actualSize, m_ptr, Fixed32Size);</span><br><span class="line">            ......</span><br><span class="line">            bool loadFromFile = false, needFullWriteback = false;</span><br><span class="line">            if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                // 4. 验证文件的长度</span><br><span class="line">                if (m_actualSize &lt; m_size &amp;&amp; m_actualSize + Fixed32Size &lt;= m_size) &#123;</span><br><span class="line">                    // 5. 验证文件 CRC 的正确性</span><br><span class="line">                    if (checkFileCRCValid()) &#123;</span><br><span class="line">                        loadFromFile = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 若不正确, 则回调异常 CRC 异常</span><br><span class="line">                        auto strategic = mmkv::onMMKVCRCCheckFail(m_mmapID);</span><br><span class="line">                        if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                            loadFromFile = true;</span><br><span class="line">                            needFullWriteback = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 回调文件长度异常</span><br><span class="line">                    auto strategic = mmkv::onMMKVFileLengthError(m_mmapID);</span><br><span class="line">                    if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                        writeAcutalSize(m_size - Fixed32Size);</span><br><span class="line">                        loadFromFile = true;</span><br><span class="line">                        needFullWriteback = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 6. 需要从文件获取数据</span><br><span class="line">            if (loadFromFile) &#123;</span><br><span class="line">                ......</span><br><span class="line">                // 构建输入缓存</span><br><span class="line">                MMBuffer inputBuffer(m_ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);</span><br><span class="line">                if (m_crypter) &#123;</span><br><span class="line">                    // 解密输入缓冲中的数据</span><br><span class="line">                    decryptBuffer(*m_crypter, inputBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">                // 从输入缓冲中将数据读入 m_dic</span><br><span class="line">                m_dic.clear();</span><br><span class="line">                MiniPBCoder::decodeMap(m_dic, inputBuffer);</span><br><span class="line">                // 构建输出数据</span><br><span class="line">                m_output = new CodedOutputData(m_ptr + Fixed32Size + m_actualSize,</span><br><span class="line">                                               m_size - Fixed32Size - m_actualSize);</span><br><span class="line">                // 进行重整回写, 剔除重复的数据</span><br><span class="line">                if (needFullWriteback) &#123;</span><br><span class="line">                    fullWriteback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            // 7. 说明文件中没有数据, 或者校验失败了</span><br><span class="line">            else &#123;</span><br><span class="line">                SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">                // 清空文件中的数据</span><br><span class="line">                if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                    writeAcutalSize(0);</span><br><span class="line">                &#125;</span><br><span class="line">                m_output = new CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size);</span><br><span class="line">                // 重新计算 CRC</span><br><span class="line">                recaculateCRCDigest();</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    m_needLoadFromFile = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 可以看到 loadFromFile 中对于 CRC 验证通过的文件, 会将文件中的数据读入到 m_dic 中缓存, 否则则会清空文件</p><ul><li><p>因此用户恶意修改文件之后, 会破坏 CRC 的值, 这个存储数据便会被作废, 这一点要尤为注意</p></li><li><p>从文件中读取数据到 m_dic 之后, 会将 mdic 回写到文件中</p><p>, 其重写的目的是为了剔除重复的数据 </p><ul><li>关于为什么会出现重复的数据, 在后面 encode 操作中再分析</li></ul></li></ul><h3 id="4-3-回顾"><a href="#4-3-回顾" class="headerlink" title="4.3 回顾"></a>4.3 回顾</h3><p>到这里 MMKV 实例的构建就完成了, 有了 m_dic 这个内存缓存, 我们进行数据查询的效率就大大提升了</p><p>从最终的结果来看它与 SP 是一致的, 都是初次加载时会将文件中所有的数据加载到散列表中, 不过 MMKV 多了一步数据回写的操作, 因此当数据量比较大时, 对实例构建的速度有一定的影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 写入 1000 条数据之后, MMVK 和 SharedPreferences 实例化的时间对比</span><br><span class="line">E/TAG: create MMKV instance time is 4 ms</span><br><span class="line">E/TAG: create SharedPreferences instance time is 1 ms</span><br></pre></td></tr></table></figure><p>从结果上来看, MMVK 的确在实例构造速度上有一定的劣势, 不过得益于是将 m_dic 中的数据写入到 mmap 的内存, 其真正进行文件写入的时机由 Linux 内核决定, 再加上文件的页缓存机制, 所以速度上虽有劣势, 但不至于无法接受</p><h2 id="五、encode"><a href="#五、encode" class="headerlink" title="五、encode"></a>五、encode</h2><p>关于 <strong>encode 即数据的添加与更新</strong>的流程, 这里以 encodeString 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">encode</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encodeString(nativeHandle, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">encodeString</span><span class="params">(<span class="keyword">long</span> handle, String key, String value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看 native 层的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">MMKV_JNI jboolean <span class="title">encodeString</span><span class="params">(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue)</span> </span>&#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        <span class="comment">// 若是 value 非 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (oValue) &#123;</span><br><span class="line">            <span class="comment">// 通过 setStringForKey 函数, 将数据存入</span></span><br><span class="line">            string value = jstring2string(env, oValue);</span><br><span class="line">            <span class="keyword">return</span> (jboolean) kv-&gt;setStringForKey(value, key);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 若是 value 为 NULL, 则移除 key 对应的 value 值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            kv-&gt;removeValueForKey(key);</span><br><span class="line">            <span class="keyword">return</span> (jboolean) <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (jboolean) <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要分析一下 setStringForKey 这个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::setStringForKey(<span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 将数据编码成 ProtocolBuffer</span></span><br><span class="line">    auto data = MiniPBCoder::encodeDataWithObject(value);</span><br><span class="line">    <span class="comment">// 2. 更新键值对</span></span><br><span class="line">    <span class="keyword">return</span> setDataForKey(std::move(data), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要分为两步操作</p><ul><li>数据编码</li><li>更新键值对</li></ul><h3 id="5-1-数据的编码"><a href="#5-1-数据的编码" class="headerlink" title="5.1 数据的编码"></a>5.1 数据的编码</h3><p>MMKV 采用的是 ProtocolBuffer 编码方式, 这里就不做过多介绍了, 具体请查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fencoding" target="_blank" rel="noopener">Google 官方文档</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MiniPBCoder.cpp</span></span><br><span class="line">MMBuffer MiniPBCoder::getEncodeData(<span class="keyword">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建编码条目的集合</span></span><br><span class="line">    m_encodeItems = <span class="keyword">new</span> vector&lt;PBEncodeItem&gt;();</span><br><span class="line">    <span class="comment">// 2. 为集合填充数据</span></span><br><span class="line">    size_t index = prepareObjectForEncode(str);</span><br><span class="line">    PBEncodeItem *oItem = (index &lt; m_encodeItems-&gt;size()) ? &amp;(*m_encodeItems)[index] : nullptr;</span><br><span class="line">    <span class="keyword">if</span> (oItem &amp;&amp; oItem-&gt;compiledSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 开辟一个内存缓冲区, 用于存放编码后的数据</span></span><br><span class="line">        m_outputBuffer = <span class="keyword">new</span> MMBuffer(oItem-&gt;compiledSize);</span><br><span class="line">        <span class="comment">// 4. 创建一个编码操作对象</span></span><br><span class="line">        m_outputData = <span class="keyword">new</span> CodedOutputData(m_outputBuffer-&gt;getPtr(), m_outputBuffer-&gt;length());</span><br><span class="line">        <span class="comment">// 执行 protocolbuffer 编码, 并输出到缓冲区</span></span><br><span class="line">        writeRootObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用移动构造函数, 重新创建实例返回</span></span><br><span class="line">    <span class="keyword">return</span> move(*m_outputBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t MiniPBCoder::prepareObjectForEncode(<span class="keyword">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="comment">// 2.1 创建 PBEncodeItem 对象用来描述待编码的条目, 并添加到 vector 集合</span></span><br><span class="line">    m_encodeItems-&gt;push_back(PBEncodeItem());</span><br><span class="line">    <span class="comment">// 2.2 获取 PBEncodeItem 对象</span></span><br><span class="line">    PBEncodeItem *encodeItem = &amp;(m_encodeItems-&gt;back());</span><br><span class="line">    <span class="comment">// 2.3 记录索引位置</span></span><br><span class="line">    size_t index = m_encodeItems-&gt;size() - <span class="number">1</span>;</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 2.4 填充编码类型</span></span><br><span class="line">        encodeItem-&gt;type = PBEncodeItemType_String;</span><br><span class="line">        <span class="comment">// 2.5 填充要编码的数据</span></span><br><span class="line">        encodeItem-&gt;value.strValue = &amp;str;</span><br><span class="line">        <span class="comment">// 2.6 填充数据大小</span></span><br><span class="line">        encodeItem-&gt;valueSize = static_cast&lt;int32_t&gt;(str.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.7 计算编码后的大小</span></span><br><span class="line">    encodeItem-&gt;compiledSize = pbRawVarint32Size(encodeItem-&gt;valueSize) + encodeItem-&gt;valueSize;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 再未进行编码操作之前, 编码后的数据大小就已经确定好了, 并且将它保存在了 encodeItem-&gt;compiledSize 中, 接下来我们看看执行数据编码并输出到缓冲区的操作流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MiniPBCoder.cpp</span></span><br><span class="line"><span class="keyword">void</span> MiniPBCoder::writeRootObject() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t index = <span class="number">0</span>, total = m_encodeItems-&gt;size(); index &lt; total; index++) &#123;</span><br><span class="line">        PBEncodeItem *encodeItem = &amp;(*m_encodeItems)[index];</span><br><span class="line">        <span class="keyword">switch</span> (encodeItem-&gt;type) &#123;</span><br><span class="line">            <span class="comment">// 主要关心编码 String</span></span><br><span class="line">            <span class="keyword">case</span> PBEncodeItemType_String: &#123;</span><br><span class="line">                m_outputData-&gt;writeString(*(encodeItem-&gt;value.strValue));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CodedOutputData.cpp</span></span><br><span class="line"><span class="keyword">void</span> CodedOutputData::writeString(<span class="keyword">const</span> string &amp;value) &#123;</span><br><span class="line">    size_t numberOfBytes = value.size();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1. 按照 varint 方式编码字符串长度, 会改变 m_position 的值</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;writeRawVarint32((int32_t) numberOfBytes);</span><br><span class="line">    <span class="comment">// 2. 将字符串的数据拷贝到编码好的长度后面</span></span><br><span class="line">    memcpy(m_ptr + m_position, ((uint8_t *) value.data()), numberOfBytes);</span><br><span class="line">    <span class="comment">// 更新 position 的值</span></span><br><span class="line">    m_position += numberOfBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 CodedOutputData 的 writeString 中按照 protocol buffer 进行了字符串的编码操作</p><p>其中 m_ptr 是上面开辟的内存缓冲区的地址, 也就是说 writeString 执行结束之后, 数据就已经被写入缓冲区了</p><p>有了编码好的数据缓冲区, 接下来看看更新键值对的操作</p><h3 id="5-2键值对的更新"><a href="#5-2键值对的更新" class="headerlink" title="5.2键值对的更新"></a>5.2键值对的更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::setStringForKey(<span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 编码数据获取存放数据的缓冲区</span></span><br><span class="line">    auto data = MiniPBCoder::encodeDataWithObject(value);</span><br><span class="line">    <span class="comment">// 更新键值对</span></span><br><span class="line">    <span class="keyword">return</span> setDataForKey(std::move(data), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将键值对写入 mmap 文件映射的内存中</span></span><br><span class="line">    auto ret = appendDataWithKey(data, key);</span><br><span class="line">    <span class="comment">// 写入成功, 更新散列数据</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        m_dic[key] = std::move(data);</span><br><span class="line">        m_hasFullWriteback = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MMKV::appendDataWithKey(<span class="keyword">const</span> MMBuffer &amp;data, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 1. 计算 key + value 的 ProtocolBuffer 编码后的长度</span></span><br><span class="line">    size_t keyLength = key.length();</span><br><span class="line">    size_t size = keyLength + pbRawVarint32Size((int32_t) keyLength);</span><br><span class="line">    size += data.length() + pbRawVarint32Size((int32_t) data.length());</span><br><span class="line">    SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 验证是否有足够的空间, 不足则进行数据重整与扩容操作</span></span><br><span class="line">    bool hasEnoughSize = ensureMemorySize(size);</span><br><span class="line">    <span class="keyword">if</span> (!hasEnoughSize || !isFileValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 更新文件头的数据总大小</span></span><br><span class="line">    writeAcutalSize(m_actualSize + size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 将 key 和编码后的 value 写入到文件映射的内存</span></span><br><span class="line">    m_output-&gt;writeString(key);</span><br><span class="line">    m_output-&gt;writeData(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 获取文件映射内存当前 &lt;key, value&gt; 的起始位置</span></span><br><span class="line">    auto ptr = (uint8_t *) m_ptr + Fixed32Size + m_actualSize - size;</span><br><span class="line">    <span class="keyword">if</span> (m_crypter) &#123;</span><br><span class="line">        <span class="comment">// 加密这块区域</span></span><br><span class="line">        m_crypter-&gt;encrypt(ptr, ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 更新 CRC</span></span><br><span class="line">    updateCRCDigest(ptr, size, KeepSequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 可以看到更新键值对的操作还是比较复杂的, 首先将键值对数据写入到文件映射的内存中, 写入成功之后更新散列数据</p><p>关于写入到文件映射的过程, 上面代码中的注释也非常的清晰, 接下来我们 ensureMemorySize 是如何进行数据的重整与扩容的</p><h5 id="5-2-1-数据的重整与扩容"><a href="#5-2-1-数据的重整与扩容" class="headerlink" title="5.2.1 数据的重整与扩容"></a>5.2.1 数据的重整与扩容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::ensureMemorySize(size_t newSize) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 计算新键值对的大小</span></span><br><span class="line">    constexpr size_t ItemSizeHolderSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_dic.empty()) &#123;</span><br><span class="line">        newSize += ItemSizeHolderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据重写: </span></span><br><span class="line">    <span class="comment">// 1. 文件剩余空闲空间少于新的键值对</span></span><br><span class="line">    <span class="comment">// 2. 散列为空</span></span><br><span class="line">    <span class="keyword">if</span> (newSize &gt;= m_output-&gt;spaceLeft() || m_dic.empty()) &#123;</span><br><span class="line">        <span class="comment">// 计算所需的数据空间</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> offset = pbFixed32Size(<span class="number">0</span>);</span><br><span class="line">        MMBuffer data = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">        size_t lenNeeded = data.length() + offset + newSize;</span><br><span class="line">        <span class="keyword">if</span> (m_isAshmem) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="comment">// 计算每个键值对的平均大小</span></span><br><span class="line">            size_t avgItemSize = lenNeeded / std::max&lt;size_t&gt;(<span class="number">1</span>, m_dic.size());</span><br><span class="line">            <span class="comment">// 计算未来可能会使用的大小(类似于 1.5 倍)</span></span><br><span class="line">            size_t futureUsage = avgItemSize * std::max&lt;size_t&gt;(<span class="number">8</span>, (m_dic.size() + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 1. 所需空间 &gt;= 当前文件总大小</span></span><br><span class="line">            <span class="comment">// 2. 所需空间的 1.5 倍 &gt;= 当前文件总大小</span></span><br><span class="line">            <span class="keyword">if</span> (lenNeeded &gt;= m_size || (lenNeeded + futureUsage) &gt;= m_size) &#123;</span><br><span class="line">                <span class="comment">// 扩容为 2 倍</span></span><br><span class="line">                size_t oldSize = m_size;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    m_size *= <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (lenNeeded + futureUsage &gt;= m_size);</span><br><span class="line">                .......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 进行数据的重写</span></span><br><span class="line">        writeAcutalSize(data.length());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以了解到</p><ul><li>数据的重写时机<ul><li>文件剩余空间少于新的键值对大小</li><li>散列为空</li></ul></li><li>文件扩容时机<ul><li>所需空间的 1.5 倍超过了当前文件的总大小时, 扩容为之前的两倍</li></ul></li></ul><h3 id="5-3回顾"><a href="#5-3回顾" class="headerlink" title="5.3回顾"></a>5.3回顾</h3><p>至此 encode 的流程我们就走完了, 回顾一下整个 encode 的流程</p><ul><li><p>使用 ProtocolBuffer 编码 value</p></li><li><p>将 </p><p>key</p><p> 和 </p><p>编码后的 value</p><p> 使用 ProtocolBuffer 的格式 append 到文件映射区内存的尾部 </p><ul><li>文件空间不足 <ul><li>判断是否需要扩容</li><li>进行数据的回写</li></ul></li><li>即在文件后进行追加</li></ul></li><li><p>对这个键值对区域进行统一的加密</p></li><li><p>更新 CRC 的值</p></li><li><p>将 key 和 value 对应的 ProtocolBuffer 编码内存区域, 更新到散列表 m_dic 中</p></li></ul><p>通过 encode 的分析, 我们得知 MMKV 文件的存储方式如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212352.png" alt></p><p>接下来看看 decode 的流程</p><h2 id="六、decode"><a href="#六、decode" class="headerlink" title="六、decode"></a>六、decode</h2><p>decode 的过程同样以 decodeString 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">MMKV_JNI jstring</span><br><span class="line">decodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) &#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        <span class="comment">// 通过 getStringForKey, 将数据输出到传出参数中 value 中</span></span><br><span class="line">        string value;</span><br><span class="line">        bool hasValue = kv-&gt;getStringForKey(key, value);</span><br><span class="line">        <span class="keyword">if</span> (hasValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> string2jstring(env, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oDefaultValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::getStringForKey(<span class="keyword">const</span> std::string &amp;key, std::string &amp;result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPEDLOCK(m_lock);</span><br><span class="line">    <span class="comment">// 1. 从内存缓存中获取数据</span></span><br><span class="line">    auto &amp;data = getDataForKey(key);</span><br><span class="line">    <span class="keyword">if</span> (data.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 解析 data 对应的 ProtocolBuffer 数据</span></span><br><span class="line">        result = MiniPBCoder::decodeString(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MMBuffer &amp;MMKV::getDataForKey(<span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 从散列表中获取 key 对应的 value</span></span><br><span class="line">    auto itr = m_dic.find(key);</span><br><span class="line">    <span class="keyword">if</span> (itr != m_dic.end()) &#123;</span><br><span class="line">        <span class="keyword">return</span> itr-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MMBuffer <span class="title">nan</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> nan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的可以看到 decode 的流程比较简单, 先从内存缓存中获取 key 对应的 value 的 ProtocolBuffer 内存区域, 再解析这块内存区域, 从中获取真正的 value 值</p><h3 id="6-1-思考"><a href="#6-1-思考" class="headerlink" title="6.1 思考"></a>6.1 思考</h3><p>看到这里可能会有一个疑问, <strong>为什么 m_dic 不直接存储 key 和 value 原始数据呢, 这样查询效率不是更快吗?</strong></p><ul><li>如此一来查询效率的确会更快, 因为少了 ProtocolBuffer 解码的过程</li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212418.png" alt></p><p>从图上的结果可以看出, MMKV 的读取性能时略低于 SharedPreferences 的, 这里笔者给出自己的思考</p><ul><li><strong>m_dic 在数据重整中也起到了非常重要的作用, 需要依靠 m_dic 将数据写入到 mmap 的文件映射区</strong>, 这个过程是非常耗时的, 若是原始的 value, 则需要对所有的 value 再进行一次 ProtocolBuffer 编码操作, 尤其是当数据量比较庞大时, 其带来的性能损耗更是无法忽略的</li></ul><p>既然 m_dic 还承担着方便数据复写的功能, 那<strong>能否再添加一个内存缓存专门用于存储原始的 value 呢?</strong></p><ul><li>当然可以, 这样 MMKV 的读取定是能够达到 SharedPreferences 的水平, 不过 value 的内存消耗则会加倍, <strong>MMKV 作为一个轻量级缓存的框架, 查询时时间的提升幅度还不足以用内存加倍的代价去换取</strong>, 我想这是 Tencent 在进行多方面权衡之后, 得到的一个比较合理的解决方案</li></ul><h2 id="七、进程读写的同步"><a href="#七、进程读写的同步" class="headerlink" title="七、进程读写的同步"></a>七、进程读写的同步</h2><p>说起进程间读写同步, 我们很自然的想到 Linux 的共享内存配合信号量使用的案例, 但是这种方式有一个弊端, 那就是<strong>当持有锁的进程意外死亡的时候, 并不会释放其拥有的信号量, 若多进程之间存在竞争, 那么阻塞的进程将不会被唤醒</strong>, 这是非常危险的</p><p>MMKV 是采用 <strong>文件锁</strong> 的方式来进行进程间的同步操作</p><ul><li><strong>LOCK_SH(共享锁)</strong>: 多个进程可以使用同一把锁, 常被用作读共享锁</li><li><strong>LOCK_EX(排他锁)</strong>: 同时只允许一个进程使用, 常被用作写锁</li><li><strong>LOCK_UN</strong>: 释放锁</li></ul><p>接下来我看看 MMKV 加解锁的操作</p><h3 id="7-1-文件共享锁"><a href="#7-1-文件共享锁" class="headerlink" title="7.1 文件共享锁"></a>7.1 文件共享锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MMKV::MMKV(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath)</span><br><span class="line">    : m_mmapID(mmapedKVKey(mmapID, relativePath))</span><br><span class="line">    <span class="comment">// 创建文件锁的描述</span></span><br><span class="line">    , m_fileLock(m_metaFile.getFd())</span><br><span class="line">    <span class="comment">// 描述共享锁</span></span><br><span class="line">    , m_sharedProcessLock(&amp;m_fileLock, SharedLockType)</span><br><span class="line">    <span class="comment">// 描述排它锁</span></span><br><span class="line">    , m_exclusiveProcessLock(&amp;m_fileLock, ExclusiveLockType)</span><br><span class="line">    <span class="comment">// 判读是否为进程间通信</span></span><br><span class="line">    , m_isInterProcess((mode &amp; MMKV_MULTI_PROCESS) != <span class="number">0</span> || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != <span class="number">0</span>)</span><br><span class="line">    , m_isAshmem((mode &amp; MMKV_ASHMEM) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据是否跨进程操作判断共享锁和排它锁的开关</span></span><br><span class="line">    m_sharedProcessLock.m_enable = m_isInterProcess;</span><br><span class="line">    m_exclusiveProcessLock.m_enable = m_isInterProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sensitive zone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文件读操作, 启用了文件共享锁</span></span><br><span class="line">        SCOPEDLOCK(m_sharedProcessLock);</span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在我们前面分析过的构造函数中, MMKV 对文件锁进行了初始化, 并且创建了共享锁和排它锁, 并在跨进程操作时开启, 当进行读操作时, 启动了共享锁</p><h3 id="7-2-文件排它锁"><a href="#7-2-文件排它锁" class="headerlink" title="7.2 文件排它锁"></a>7.2 文件排它锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::fullWriteback() &#123;</span><br><span class="line">    ......</span><br><span class="line">    auto allData = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">    <span class="comment">// 启动了排它锁</span></span><br><span class="line">    SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">    <span class="keyword">if</span> (allData.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allData.length() + Fixed32Size &lt;= m_size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_crypter) &#123;</span><br><span class="line">                m_crypter-&gt;reset();</span><br><span class="line">                auto ptr = (unsigned <span class="keyword">char</span> *) allData.getPtr();</span><br><span class="line">                m_crypter-&gt;encrypt(ptr, ptr, allData.length());</span><br><span class="line">            &#125;</span><br><span class="line">            writeAcutalSize(allData.length());</span><br><span class="line">            delete m_output;</span><br><span class="line">            m_output = <span class="keyword">new</span> CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size);</span><br><span class="line">            m_output-&gt;writeRawData(allData); <span class="comment">// note: don't write size of data</span></span><br><span class="line">            recaculateCRCDigest();</span><br><span class="line">            m_hasFullWriteback = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ensureMemorySize will extend file &amp; full rewrite, no need to write back again</span></span><br><span class="line">            <span class="keyword">return</span> ensureMemorySize(allData.length() + Fixed32Size - m_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行数据回写的函数中, 启动了排它锁</p><h3 id="7-3-读写效率表现"><a href="#7-3-读写效率表现" class="headerlink" title="7.3 读写效率表现"></a>7.3 读写效率表现</h3><p>其进程同步读写的性能表现如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212512.png" alt></p><p>可以看到进程同步读写的效率也是非常 nice 的</p><p>关于跨进程同步就介绍到这里, 当然 MMKV 的文件锁并没有表面上那么简单, 因为文件锁为状态锁, 无论加了多少次锁, 一个解锁操作就全解除, 显然无法应对子函数嵌套调用的问题, <strong>MMKV 内部通过了自行实现计数器来实现锁的可重入性</strong>, 更多的细节可以查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_ipc" target="_blank" rel="noopener">wiki</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析, 我们对 MMKV 有了一个整体上的把控, 其具体的表现如下所示</p><table><thead><tr><th>项目</th><th>评价</th><th>描述</th></tr></thead><tbody><tr><td>正确性</td><td>优</td><td>支持多进程安全, 使用 mmap, 由操作系统保证数据回写的正确性</td></tr><tr><td>时间开销</td><td>优</td><td>使用 mmap 实现, 减少了用户空间数据到内核空间的拷贝</td></tr><tr><td>空间开销</td><td>中</td><td>使用 protocl buffer 存储数据, 同样的数据会比 xml 和 json 消耗空间小   使用的是数据追加到末尾的方式, 只有到达一定阈值之后才会触发键值合并, 不合并之前会导致同一个 key 存在多份</td></tr><tr><td>安全</td><td>中</td><td>使用 crc 校验, 甄别文件系统和操作系统不稳定导致的异常数据</td></tr><tr><td>开发成本</td><td>优</td><td>使用方式较为简单</td></tr><tr><td>兼容性</td><td>优</td><td>各个安卓版本都前后兼容</td></tr></tbody></table><p>虽然 MMKV 一些场景下比 SP 稍慢(如: 首次实例化会进行数据的复写剔除重复数据, 比 SP 稍慢, 查询数据时存在 ProtocolBuffer 解码, 比 SP 稍慢), 但其<strong>逆天的数据写入速度、mmap Linux 内核保证数据的同步, 以及 ProtocolBuffer 编码带来的更小的本地存储空间占用等都是非常棒的闪光点</strong></p><p>在分析 MMKV 的代码的过程中, 从中学习到了很多知识, 非常感谢 Tencent 为开源社区做出的贡献</p><h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn" target="_blank" rel="noopener">github.com/Tencent/MMK…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fencoding" target="_blank" rel="noopener">developers.google.com/protocol-bu…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Farticle%2F76677" target="_blank" rel="noopener">time.geekbang.org/column/arti…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fkex1n%2Fp%2F7100107.html" target="_blank" rel="noopener">www.cnblogs.com/kex1n/p/710…</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;APP 的性能优化之路是永无止境的, 这里学习一个&lt;strong&gt;腾讯开源用于提升本地存储效率的轻量级存储框架&lt;/strong&gt; &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MMKV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR&lt;/p&gt;
&lt;p&gt;网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了&lt;/p&gt;
&lt;p&gt;因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架&lt;/p&gt;
&lt;h2 id=&quot;二、集成与测试&quot;&gt;&lt;a href=&quot;#二、集成与测试&quot; class=&quot;headerlink&quot; title=&quot;二、集成与测试&quot;&gt;&lt;/a&gt;二、集成与测试&lt;/h2&gt;&lt;p&gt;以下介绍简单的使用方式, 更多详情请查看 &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-依赖注入&quot;&gt;&lt;a href=&quot;#2-1-依赖注入&quot; class=&quot;headerlink&quot; title=&quot;2.1 依赖注入&quot;&gt;&lt;/a&gt;2.1 依赖注入&lt;/h3&gt;&lt;p&gt;在 App 模块的 build.gradle 文件里添加:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.tencent:mmkv:1.0.22&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // replace &amp;quot;1.0.22&amp;quot; with any available version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/categories/Android/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>BannerViewPage</title>
    <link href="https://zhangmiao.cc/posts/6831bdd1.html"/>
    <id>https://zhangmiao.cc/posts/6831bdd1.html</id>
    <published>2019-08-13T10:13:23.000Z</published>
    <updated>2019-08-13T10:17:35.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BannerViewPage"><a href="#BannerViewPage" class="headerlink" title="BannerViewPage"></a><a href="https://github.com/zhangmiaocc/BannerViewPage" target="_blank" rel="noopener">BannerViewPage</a></h1><p>Banner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/aaa.gif" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BannerViewPage&quot;&gt;&lt;a href=&quot;#BannerViewPage&quot; class=&quot;headerlink&quot; title=&quot;BannerViewPage&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/zhangmiaocc/BannerViewPage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BannerViewPage&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;Banner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/aaa.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>关于OKR的解读</title>
    <link href="https://zhangmiao.cc/posts/5b77eb6.html"/>
    <id>https://zhangmiao.cc/posts/5b77eb6.html</id>
    <published>2019-07-31T06:56:33.000Z</published>
    <updated>2019-07-31T07:00:21.114Z</updated>
    
    <content type="html"><![CDATA[<p>OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。</p><p>具体拆解如下：</p><p>1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。</p><p>2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。</p><ul><li>以季度（或者其他预先规定的周期）为单位刷新OKR；</li><li>仔细确认结果达成情况；</li><li>如有必要，持续修正现行战略和商业模式；</li><li>结果导向。</li></ul><p>3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。</p><p>4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。</p><p>5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。</p><p>6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。&lt;/p&gt;
&lt;p&gt;具体拆解如下：&lt;/p&gt;
&lt;p&gt;1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。&lt;/p&gt;
&lt;p&gt;2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以季度（或者其他预先规定的周期）为单位刷新OKR；&lt;/li&gt;
&lt;li&gt;仔细确认结果达成情况；&lt;/li&gt;
&lt;li&gt;如有必要，持续修正现行战略和商业模式；&lt;/li&gt;
&lt;li&gt;结果导向。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。&lt;/p&gt;
&lt;p&gt;4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。&lt;/p&gt;
&lt;p&gt;5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。&lt;/p&gt;
&lt;p&gt;6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。&lt;/p&gt;
    
    </summary>
    
      <category term="awsome" scheme="https://zhangmiao.cc/categories/awsome/"/>
    
    
      <category term="awsome" scheme="https://zhangmiao.cc/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>什么是灰度发布，灰度测试</title>
    <link href="https://zhangmiao.cc/posts/5b196854.html"/>
    <id>https://zhangmiao.cc/posts/5b196854.html</id>
    <published>2019-07-30T07:36:54.000Z</published>
    <updated>2019-07-30T07:40:29.370Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是灰度发布？"><a href="#什么是灰度发布？" class="headerlink" title="什么是灰度发布？"></a>什么是灰度发布？</h4><p>灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><p>灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。</p><h4 id="灰度发布的意义"><a href="#灰度发布的意义" class="headerlink" title="灰度发布的意义"></a>灰度发布的意义</h4><p>灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。</p><h4 id="灰度发布步骤"><a href="#灰度发布步骤" class="headerlink" title="灰度发布步骤"></a>灰度发布步骤</h4><ol><li>定义目标</li><li>选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等</li><li>筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等</li><li>部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调</li><li>发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表</li><li>产品完善</li><li>新一轮灰度发布或完整发布</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是灰度发布？&quot;&gt;&lt;a href=&quot;#什么是灰度发布？&quot; class=&quot;headerlink&quot; title=&quot;什么是灰度发布？&quot;&gt;&lt;/a&gt;什么是灰度发布？&lt;/h4&gt;&lt;p&gt;灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。&lt;/p&gt;
&lt;p&gt;灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。&lt;/p&gt;
&lt;p&gt;灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。&lt;/p&gt;
&lt;h4 id=&quot;灰度发布的意义&quot;&gt;&lt;a href=&quot;#灰度发布的意义&quot; class=&quot;headerlink&quot; title=&quot;灰度发布的意义&quot;&gt;&lt;/a&gt;灰度发布的意义&lt;/h4&gt;&lt;p&gt;灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。&lt;/p&gt;
&lt;h4 id=&quot;灰度发布步骤&quot;&gt;&lt;a href=&quot;#灰度发布步骤&quot; class=&quot;headerlink&quot; title=&quot;灰度发布步骤&quot;&gt;&lt;/a&gt;灰度发布步骤&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;定义目标&lt;/li&gt;
&lt;li&gt;选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等&lt;/li&gt;
&lt;li&gt;筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等&lt;/li&gt;
&lt;li&gt;部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调&lt;/li&gt;
&lt;li&gt;发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表&lt;/li&gt;
&lt;li&gt;产品完善&lt;/li&gt;
&lt;li&gt;新一轮灰度发布或完整发布&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="awsome" scheme="https://zhangmiao.cc/categories/awsome/"/>
    
    
      <category term="awsome" scheme="https://zhangmiao.cc/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>java.lang.ClassNotFoundException:&quot;org.apache.http.ProtocolVersion&quot;</title>
    <link href="https://zhangmiao.cc/posts/c7a54c5f.html"/>
    <id>https://zhangmiao.cc/posts/c7a54c5f.html</id>
    <published>2019-07-26T03:38:39.000Z</published>
    <updated>2019-07-26T03:46:34.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行项目遇到以下问题："><a href="#运行项目遇到以下问题：" class="headerlink" title="运行项目遇到以下问题："></a>运行项目遇到以下问题：</h3><blockquote><p>Caused by: java.lang.ClassNotFoundException: Didn’t find class “org.apache.http.ProtocolVersion” on path: DexPathList[[zip file “/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk”],nativeLibraryDirectories=[/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk!/lib/arm64-v8a, /system/lib64, /product/lib64]]</p></blockquote><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p><strong>1.在清单文件增加代码:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:usesCleartextTraffic</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.在清单文件清单再加一句代码：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:usesCleartextTraffic</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">uses-library</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"org.apache.http.legacy"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:required</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，重新运行解决了.<br>最根本的做法是使用https进行接口访问，毕竟涉及数据的安全性。当然了，这需要服务器的支持。还有第三方sdk，也需要使用https。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;运行项目遇到以下问题：&quot;&gt;&lt;a href=&quot;#运行项目遇到以下问题：&quot; class=&quot;headerlink&quot; title=&quot;运行项目遇到以下问题：&quot;&gt;&lt;/a&gt;运行项目遇到以下问题：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Caused by: java.lang.ClassNotFoundException: Didn’t find class “org.apache.http.ProtocolVersion” on path: DexPathList[[zip file “/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk”],nativeLibraryDirectories=[/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk!/lib/arm64-v8a, /system/lib64, /product/lib64]]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决方案：&quot;&gt;&lt;a href=&quot;#解决方案：&quot; class=&quot;headerlink&quot; title=&quot;解决方案：&quot;&gt;&lt;/a&gt;解决方案：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.在清单文件增加代码:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;android:usesCleartextTraffic&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;2.在清单文件清单再加一句代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;android:usesCleartextTraffic&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;uses-library&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;org.apache.http.legacy&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;android:required&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;好了，重新运行解决了.&lt;br&gt;最根本的做法是使用https进行接口访问，毕竟涉及数据的安全性。当然了，这需要服务器的支持。还有第三方sdk，也需要使用https。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Exception" scheme="https://zhangmiao.cc/categories/Android/Exception/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Exception" scheme="https://zhangmiao.cc/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>GoogleMap使用介绍</title>
    <link href="https://zhangmiao.cc/posts/50fe3b5b.html"/>
    <id>https://zhangmiao.cc/posts/50fe3b5b.html</id>
    <published>2019-07-25T08:17:10.000Z</published>
    <updated>2019-07-25T08:48:12.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过本文，你可以知道如何使用 GoogleMap 相关 API、定位当前位置、获取当前所在城市、获取当前位置附近的地点、导航、地点搜索等内容。大致内容，可以查看如下思维导图。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/GoogleMapXmind.png" alt></p><a id="more"></a><h3 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a><strong>特别注意</strong>：</h3><p>demo 使用的 GoogleMap key 对应我自己电脑的 keystore，如果重新编译项目，生成的apk使用的是你的电脑的 keystore，和我的 keystore 是不一样的，所以要正常运行，</p><ol><li>直接下载我编译好的 apk；</li><li>用我的项目包名，和你自己的 keystore 的 SHA-1 去申请新的 GoogleMap key。（方法在下面，往下看哈）</li></ol><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>因为国内众所周知的网络问题，谷歌地图的页面加载和 API 的使用会出现无效的情况，如果你要使用或调试，首先要确保是可以科学上网的。</p><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>Android 设备，必须<strong>安装了 Google 服务</strong>。</p><h3 id="谷歌账号"><a href="#谷歌账号" class="headerlink" title="谷歌账号"></a>谷歌账号</h3><p>作为用户，不需要拥有或者登录你的 Google 账号。网络和 Google 服务正常即可。</p><p>作为开发者，必须拥有一个 Google 账号。要知道，谷歌地图是不开源的，要使用他的 API ，必须用你的包名，和编译 Android app 的 keystore 的 SHA-1，去申请App 对应的 Google Map Key。获取 Key 的教程官网讲得很详细，<a href="https://developers.google.com/maps/documentation/android-api/signup" target="_blank" rel="noopener">请看这里</a></p><p><a href="https://console.developers.google.com/project/_/apiui/credential" target="_blank" rel="noopener">Google API Console</a> 设置完成后，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190725162411.png" alt></p><p>设置好后，还要确保已经 <strong>Enable</strong>了对应的API，<strong>不然会出现数据访问不到的情况</strong>。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190725162433.png" alt></p><p>把这个 API key 填入 <em>AndroidManifest.xml</em> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.google.android.geo.API_KEY"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"your key"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Map-相关"><a href="#Map-相关" class="headerlink" title="Map 相关"></a>Map 相关</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><h5 id="初始化-Google-Map"><a href="#初始化-Google-Map" class="headerlink" title="初始化 Google Map"></a>初始化 Google Map</h5><h6 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h6><p>在你的布局文件里面，只需要如下方式声明一个 Fragment，这个 Fragment 是可以放在 LinearLayout 或 RelativeLayout 下面的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/map"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">map:uiZoomControls</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">map:uiCompass</span> = <span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.google.android.gms.maps.SupportMapFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@id/layout_btn"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h6 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h6><p>在 <em>onCreate</em> 的时候，进行初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> GoogleMap mMap;</span><br><span class="line">SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()</span><br><span class="line">        .findFragmentById(map);</span><br><span class="line">mapFragment.getMapAsync(<span class="keyword">new</span> OnMapReadyCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapReady</span><span class="params">(GoogleMap googleMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化完 GoogleMap</span></span><br><span class="line">        mMap = googleMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="确保-GoogleMap-实例化"><a href="#确保-GoogleMap-实例化" class="headerlink" title="确保 GoogleMap 实例化"></a>确保 GoogleMap 实例化</h5><p>在使用 GoogleMap 相关接口前，必须确保 GoogleMap 已经实例化，即已经在 <em>onMapReady</em>回调中获取了 GoogleMap实例。</p><h4 id="开关类"><a href="#开关类" class="headerlink" title="开关类"></a>开关类</h4><h5 id="定位按钮"><a href="#定位按钮" class="headerlink" title="定位按钮"></a>定位按钮</h5><p>定位功能必须获取用户的位置权限，判断是非获取了用户权限，没有获取则手动请求权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 检查定位权限，如果未授权则请求该权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  true：已经授权； false：未授权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkLocationPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_FINE_LOCATION)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="comment">// Permission to access the location is missing.</span></span><br><span class="line">        PermissionUtils.requestPermission(<span class="keyword">this</span>, LOCATION_PERMISSION_REQUEST_CODE,</span><br><span class="line">                Manifest.permission.ACCESS_FINE_LOCATION, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">requestPermission</span><span class="params">(FragmentActivity activity, <span class="keyword">int</span> requestId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String permission, <span class="keyword">boolean</span> finishActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) &#123;</span><br><span class="line">        <span class="comment">// Display a dialog with rationale.</span></span><br><span class="line">        PermissionUtils.RationaleDialog.newInstance(requestId, finishActivity)</span><br><span class="line">                .show(activity.getSupportFragmentManager(), <span class="string">"dialog"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Location permission has not been granted yet, request it.</span></span><br><span class="line">        ActivityCompat.requestPermissions(activity, <span class="keyword">new</span> String[]&#123;permission&#125;, requestId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让地图上显示开关按钮，只需要设置<code>mMap.setMyLocationEnabled(true);</code></p><p>点击此按钮，地图的摄像头就会开始移动，定位到当前设备所在位置，如果要获取点击此按钮的回调，可以设置监听器 <code>mMap.setOnMyLocationButtonClickListener</code></p><h5 id="放大／缩小按钮"><a href="#放大／缩小按钮" class="headerlink" title="放大／缩小按钮"></a>放大／缩小按钮</h5><p>地图的放大缩小，就以摄像头焦点（地图中心）进行缩放。要出现这个开关，只需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setZoomControlsEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h5 id="指南针按钮"><a href="#指南针按钮" class="headerlink" title="指南针按钮"></a>指南针按钮</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setCompassEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h5 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h5><ol><li><p>旋转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setRotateGesturesEnabled(mRotateGesturesEnabled);</span><br></pre></td></tr></table></figure></li><li><p>平移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setScrollGesturesEnabled(mScrollGesturesEnabled);</span><br></pre></td></tr></table></figure></li></ol><h4 id="自定义标注"><a href="#自定义标注" class="headerlink" title="自定义标注"></a>自定义标注</h4><h5 id="清除标注"><a href="#清除标注" class="headerlink" title="清除标注"></a>清除标注</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mMap.clear();</span><br></pre></td></tr></table></figure><h5 id="新增标注"><a href="#新增标注" class="headerlink" title="新增标注"></a>新增标注</h5><p>增加一个标注，只需要把当前的经纬度，图标，标题等信息传入 <em>MarkerOptions</em> ，之后在 <em>addMarker</em> 到 map对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LatLng latLng = <span class="keyword">new</span> LatLng(latitude, longitude);</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记当前坐标</span></span><br><span class="line">mMap.addMarker(<span class="keyword">new</span> MarkerOptions()</span><br><span class="line">        .position(latLng)</span><br><span class="line">        .icon(BitmapDescriptorFactory.fromResource(R.drawable.icon_position_small))</span><br><span class="line">        .title(getString(R.string.map_camera_center_location)));</span><br></pre></td></tr></table></figure><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><h5 id="当前位置"><a href="#当前位置" class="headerlink" title="当前位置"></a>当前位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前摄像头中心点的坐标</span></span><br><span class="line"><span class="keyword">double</span> latitude = mMap.getCameraPosition().target.latitude;</span><br><span class="line"><span class="keyword">double</span> longitude = mMap.getCameraPosition().target.longitude;</span><br></pre></td></tr></table></figure><h5 id="移动相关监听"><a href="#移动相关监听" class="headerlink" title="移动相关监听"></a>移动相关监听</h5><ol><li><p>开始监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摄像头开始滑动监听</span></span><br><span class="line">mMap.setOnCameraMoveStartedListener(<span class="keyword">new</span> GoogleMap.OnCameraMoveStartedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraMoveStarted</span><span class="params">(<span class="keyword">int</span> reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reason == GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE) &#123;</span><br><span class="line">            <span class="comment">//表示摄像头移动是为了响应用户在地图上做出的手势，如平移、倾斜、通过捏合手指进行缩放或旋转地图</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reason == GoogleMap.OnCameraMoveStartedListener</span><br><span class="line">                .REASON_API_ANIMATION) &#123;</span><br><span class="line">            <span class="comment">//表示 API 移动摄像头是为了响应非手势用户操作，如点按 zoom 按钮、点按 My Location 按钮或点击标记</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reason == GoogleMap.OnCameraMoveStartedListener</span><br><span class="line">                .REASON_DEVELOPER_ANIMATION) &#123;</span><br><span class="line">            <span class="comment">//表示您的应用已发起摄像头移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></li><li><p>取消</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摄像头移动停止状态的监听</span></span><br><span class="line">mMap.setOnCameraIdleListener(<span class="keyword">new</span> GoogleMap.OnCameraIdleListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摄像头移动中被取消时的监听</span></span><br><span class="line">mMap.setOnCameraMoveCanceledListener(<span class="keyword">new</span> GoogleMap.OnCameraMoveCanceledListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraMoveCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="点击监听"><a href="#点击监听" class="headerlink" title="点击监听"></a>点击监听</h4><h5 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击地图上某个坐标</span></span><br><span class="line">mMap.setOnMapClickListener(<span class="keyword">new</span> GoogleMap.OnMapClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapClick</span><span class="params">(LatLng latLng)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MapActivity.<span class="keyword">this</span>,</span><br><span class="line">                getString(R.string.map_click_tip, latLng.latitude, latLng.longitude),</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="长按"><a href="#长按" class="headerlink" title="长按"></a>长按</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长按地图上某个坐标</span></span><br><span class="line">mMap.setOnMapLongClickListener(<span class="keyword">new</span> GoogleMap.OnMapLongClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapLongClick</span><span class="params">(LatLng latLng)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MapActivity.<span class="keyword">this</span>,</span><br><span class="line">                getString(R.string.map_long_click_tip, latLng.latitude, latLng.longitude),</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="点击景点"><a href="#点击景点" class="headerlink" title="点击景点"></a>点击景点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击地图上某个景点</span></span><br><span class="line">mMap.setOnPoiClickListener(<span class="keyword">new</span> GoogleMap.OnPoiClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPoiClick</span><span class="params">(PointOfInterest pointOfInterest)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MapActivity.<span class="keyword">this</span>,</span><br><span class="line">                getString(R.string.map_place_click_tip, pointOfInterest.name, pointOfInterest.placeId, pointOfInterest.latLng.latitude, pointOfInterest.latLng.longitude),</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>快照分两种，一种是直接不管地图有没有加载完，就把当前的地图截屏，如果此时地图未加载完，截取的图片会出现模糊的情况；另外一种是判断地图是否在加载中，如果是，则等加载完毕再截图，如果不是，就直接截图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否等待地图加载完毕</span></span><br><span class="line"><span class="keyword">if</span> (mWaitForMapLoaded) &#123;</span><br><span class="line">    <span class="comment">//获取加载完的高清图片</span></span><br><span class="line">    mMap.setOnMapLoadedCallback(<span class="keyword">new</span> GoogleMap.OnMapLoadedCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapLoaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != mMap) &#123;</span><br><span class="line">                mMap.snapshot(<span class="keyword">new</span> GoogleMap.SnapshotReadyCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSnapshotReady</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//获取bitmap</span></span><br><span class="line">                    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//未加载完，就执行快照功能，会导致截取模糊图片</span></span><br><span class="line">    mMap.snapshot(<span class="keyword">new</span> GoogleMap.SnapshotReadyCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSnapshotReady</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取bitmap</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GoogleApiClient"><a href="#GoogleApiClient" class="headerlink" title="GoogleApiClient"></a>GoogleApiClient</h3><h4 id="前提-1"><a href="#前提-1" class="headerlink" title="前提"></a>前提</h4><ol><li><p>初始化 GoogleApiClient</p><p>在 onCreate 的时候进行初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 google client 用于获取地点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createGoogleApiClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGoogleApiClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mGoogleApiClient = <span class="keyword">new</span> GoogleApiClient</span><br><span class="line">                .Builder(<span class="keyword">this</span>)</span><br><span class="line">                .addApi(Places.GEO_DATA_API)</span><br><span class="line">                .addApi(Places.PLACE_DETECTION_API)</span><br><span class="line">                .addApi(LocationServices.API)</span><br><span class="line">                .addConnectionCallbacks(<span class="keyword">new</span> GoogleApiClient.ConnectionCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnected</span><span class="params">(@Nullable Bundle bundle)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接成功</span></span><br><span class="line">                        mConnected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionSuspended</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接暂停</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .addOnConnectionFailedListener(<span class="keyword">new</span> GoogleApiClient.OnConnectionFailedListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionFailed</span><span class="params">(@NonNull ConnectionResult connectionResult)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接失败</span></span><br><span class="line">                        mConnected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .enableAutoManage(<span class="keyword">this</span>, <span class="keyword">new</span> GoogleApiClient.OnConnectionFailedListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionFailed</span><span class="params">(@NonNull ConnectionResult connectionResult)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接失败</span></span><br><span class="line">                        mConnected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 onStart() 的时候连接，在 onStop() 的时候，断开连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mGoogleApiClient) &#123;</span><br><span class="line">        mGoogleApiClient.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mGoogleApiClient) &#123;</span><br><span class="line">        mGoogleApiClient.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用位置相关 API 的前提，必须确保用户授予位置权限。方法同上的 <em>checkLocationPermission()</em></p></li></ol><h4 id="获取当前定位的经纬度坐标"><a href="#获取当前定位的经纬度坐标" class="headerlink" title="获取当前定位的经纬度坐标"></a>获取当前定位的经纬度坐标</h4><h5 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h5><ul><li><p>WGS-84</p><p>国际标准的坐标系，国际标准的 GPS 设备定位获取的就是这种坐标。简称 <strong>地球坐标系</strong>。</p></li><li><p>GCJ-02</p><p>在我们国家，据说是为了保密，我们不使用 WGS-84 坐标，而是使用经过加密的 GCJ-02，高德地图，谷歌地图（国内板块）都是使用这个坐标系。这个就是俗称的 <strong>火星坐标系</strong>。</p></li><li><p>其他坐标系</p><p>比如百度地图，他用的是他们家的 BD-09 坐标，这个只适用于百度相关产品。搜狗地图也有自己的坐标。</p></li><li><p>格式<br>注意到谷歌地图的坐标是 latitude, longitude 格式，即 纬度，经度 格式。和国内的百度，高德坐标写法是反过来的。国内的一般是 经度，纬度 的方式。</p></li></ul><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Location lastLocation = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != lastLocation) &#123;</span><br><span class="line">    <span class="keyword">double</span> latitude = lastLocation.getLatitude();</span><br><span class="line">    <span class="keyword">double</span> longitude = lastLocation.getLongitude();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始我也以为这么简单就可以了，在测试设备上确实可以获取到坐标，但是实际上，大多数情况，在第一次运行定位的时候，获取的 Location 对象是为null。所以还需要注册位置变化的监听。等监听到位置信息后，移除此监听，防止不断监听引起高耗电现象。这部分百度地图用得很方便，他封装好了，但是谷歌地图就要自己实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> UPDATE_INTERVAL = <span class="number">10</span> * <span class="number">1000</span>;  <span class="comment">/* 10 secs */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> FASTEST_INTERVAL = <span class="number">1500</span>; <span class="comment">/* 1.5 sec */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TIME = <span class="number">2</span>; <span class="comment">//最多定位次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != lastLocation) &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果获取不到位置信息，注册位置变化监听</span></span><br><span class="line">regLocationUpdates();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">regLocationUpdates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkLocationPermission()) &#123;</span><br><span class="line">        showContentText(getString(R.string.cilent_permission_failed));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LocationRequest locationRequest = LocationRequest.create()</span><br><span class="line">            .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)</span><br><span class="line">            .setInterval(UPDATE_INTERVAL)</span><br><span class="line">            .setFastestInterval(FASTEST_INTERVAL);</span><br><span class="line"></span><br><span class="line">    LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient,</span><br><span class="line">            locationRequest, <span class="keyword">new</span> LocationListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLocationChanged</span><span class="params">(Location location)</span> </span>&#123;</span><br><span class="line">                    time++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果获取到位置信息，则移除位置变化监听</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != location) &#123;</span><br><span class="line">                        LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, <span class="keyword">this</span>);</span><br><span class="line">                        <span class="comment">//获取定位的经纬度</span></span><br><span class="line">                        <span class="keyword">double</span> latitude = location.getLatitude();</span><br><span class="line">                        <span class="keyword">double</span> longitude = location.getLongitude();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果超过最大的定位次数则停止位置变化监听</span></span><br><span class="line">                    <span class="keyword">if</span> (time == MAX_TIME) &#123;</span><br><span class="line">                        <span class="comment">//移除位置变化监听</span></span><br><span class="line">                        LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//获取当前位置失败</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在终于获取到定位坐标了，等等，好像不太对，这个坐标和我实际位置好像有不少的偏差…..我打开了 GoogleMap 这个官方的 APP，点击了他的定位。这下就懵逼了，怎么官方的这个是没问题了，误差很小….</p><p>我明明用的是 GoogleMap 的 API，为什么定位会不一样？</p><p>原因在刚才的坐标系里面，谷歌地图的国内板块是用 GCJ-02，但是定位 API 获取的坐标是国际标准坐标 WGS-84，所以需要把 WGS-84 转化 GCJ-02。</p><p>那谷歌地图 APP 上为什么可以呢？</p><p>我猜测，谷歌地图在访问网络的时候，会进行位置判断，如果是国内坐标，就进行转换，国外坐标就不转换。</p><p><strong>WGS-84 转化 GCJ-02 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> a = <span class="number">6378245.0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> ee = <span class="number">0.00669342162296594323</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把 WGS-84 转换成 GCJ-02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wgLoc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LatLng <span class="title">transformFromWGSToGCJ</span><span class="params">(LatLng wgLoc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果在国外，则默认不进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (outOfChina(wgLoc.latitude, wgLoc.longitude)) &#123;</span><br><span class="line">        <span class="comment">//return new LatLng(wgLoc.latitude, wgLoc.longitude);</span></span><br><span class="line">        <span class="keyword">return</span> wgLoc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> dLat = transformLat(wgLoc.longitude - <span class="number">105.0</span>,</span><br><span class="line">            wgLoc.latitude - <span class="number">35.0</span>);</span><br><span class="line">    <span class="keyword">double</span> dLon = transformLon(wgLoc.longitude - <span class="number">105.0</span>,</span><br><span class="line">            wgLoc.latitude - <span class="number">35.0</span>);</span><br><span class="line">    <span class="keyword">double</span> radLat = wgLoc.latitude / <span class="number">180.0</span> * Math.PI;</span><br><span class="line">    <span class="keyword">double</span> magic = Math.sin(radLat);</span><br><span class="line">    magic = <span class="number">1</span> - ee * magic * magic;</span><br><span class="line">    <span class="keyword">double</span> sqrtMagic = Math.sqrt(magic);</span><br><span class="line">    dLat = (dLat * <span class="number">180.0</span>)/ ((a * (<span class="number">1</span> - ee)) / (magic * sqrtMagic) * Math.PI);</span><br><span class="line">    dLon = (dLon * <span class="number">180.0</span>) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LatLng(wgLoc.latitude + dLat, wgLoc.longitude + dLon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">transformLat</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = -<span class="number">100.0</span> + <span class="number">2.0</span> * x + <span class="number">3.0</span> * y + <span class="number">0.2</span> * y * y + <span class="number">0.1</span> * x * y</span><br><span class="line">            + <span class="number">0.2</span> * Math.sqrt(x &gt; <span class="number">0</span> ? x : -x);</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(<span class="number">6.0</span> * x * Math.PI) + <span class="number">20.0</span> * Math.sin(<span class="number">2.0</span> * x</span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(y * Math.PI) + <span class="number">40.0</span> * Math.sin(y / <span class="number">3.0</span></span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">160.0</span> * Math.sin(y / <span class="number">12.0</span> * Math.PI) + <span class="number">320</span> * Math.sin(y</span><br><span class="line">            * Math.PI / <span class="number">30.0</span>)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">transformLon</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">300.0</span> + x + <span class="number">2.0</span> * y + <span class="number">0.1</span> * x * x + <span class="number">0.1</span> * x * y + <span class="number">0.1</span></span><br><span class="line">            * Math.sqrt(x &gt; <span class="number">0</span> ? x : -x);</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(<span class="number">6.0</span> * x * Math.PI) + <span class="number">20.0</span> * Math.sin(<span class="number">2.0</span> * x</span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(x * Math.PI) + <span class="number">40.0</span> * Math.sin(x / <span class="number">3.0</span></span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">150.0</span> * Math.sin(x / <span class="number">12.0</span> * Math.PI) + <span class="number">300.0</span> * Math.sin(x</span><br><span class="line">            / <span class="number">30.0</span> * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否在中国以外</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">outOfChina</span><span class="params">(<span class="keyword">double</span> lat, <span class="keyword">double</span> lon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lon &lt; <span class="number">72.004</span> || lon &gt; <span class="number">137.8347</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (lat &lt; <span class="number">0.8293</span> || lat &gt; <span class="number">55.8271</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据经纬度获取附近地点"><a href="#根据经纬度获取附近地点" class="headerlink" title="根据经纬度获取附近地点"></a>根据经纬度获取附近地点</h4><p>通过经纬度获取对应的地理位置信息，这个叫做<strong>反地理编码请求</strong>，以前百度地图有个 API <code>mGeoCoder.reverseGeoCode(mReverseGeoCodeOption);</code>可以直接使用，Google地图也有类似的，只不过在我使用过程中存在 bug。</p><p>心急想马上能用的，可以自己调到 <strong>Web API</strong> 中的 【根据经纬度获取附近地点】章节。</p><p>此处存在的问题：如果坐标切换为国外，就会造成获取数据为null。即使修改地区 mGeocoder = new Geocoder(this, Locale.JAPAN) 也无效。</p><ol><li><p>初始化 <strong>Geocoder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mGeocoder = <span class="keyword">new</span> Geocoder(<span class="keyword">this</span>, Locale.getDefault());</span><br><span class="line"><span class="comment">//设置区域</span></span><br><span class="line"><span class="comment">//mGeocoder = new Geocoder(this, Locale.JAPAN);</span></span><br></pre></td></tr></table></figure></li><li><p>在子线程获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Address&gt; addressList =  mGeocoder.getFromLocation(latitude, longitude, maxResult);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != addressList &amp;&amp; addressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历获取附近地点信息</span></span><br><span class="line">    <span class="keyword">for</span> (Address address : addressList) &#123;</span><br><span class="line">    <span class="comment">//省</span></span><br><span class="line">    String adminArea = address.getAdminArea();</span><br><span class="line">    <span class="comment">//市</span></span><br><span class="line">    String city = address.getLocality();</span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    String feature = address.getFeatureName();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//获取附近地点失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="startActivity方式"><a href="#startActivity方式" class="headerlink" title="startActivity方式"></a>startActivity方式</h3><h4 id="地点搜索"><a href="#地点搜索" class="headerlink" title="地点搜索"></a>地点搜索</h4><ol><li><p>打开 Activity</p><p><code>private static final int REQUEST_CODE_AUTOCOMPLETE = 2;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开搜索的 Activity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openAutocompleteActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// MODE_FULLSCREEN 全屏方式启动一个 Activity</span></span><br><span class="line">        <span class="comment">// MODE_OVERLAY 启动浮在界面上的控件</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> PlaceAutocomplete.IntentBuilder(PlaceAutocomplete.MODE_OVERLAY)</span><br><span class="line">                .build(<span class="keyword">this</span>);</span><br><span class="line">        startActivityForResult(intent, REQUEST_CODE_AUTOCOMPLETE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GooglePlayServicesRepairableException e) &#123;</span><br><span class="line">        GoogleApiAvailability.getInstance().getErrorDialog(<span class="keyword">this</span>, e.getConnectionStatusCode(), <span class="number">0</span>).show();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GooglePlayServicesNotAvailableException e) &#123;</span><br><span class="line">        String message = <span class="string">"Google Play Services is not available: "</span> +</span><br><span class="line">                GoogleApiAvailability.getInstance().getErrorString(e.errorCode);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, message, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <em>onActivityResult</em> 回调中获取搜索的地点信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (requestCode == REQUEST_CODE_AUTOCOMPLETE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                Place place = PlaceAutocomplete.getPlace(<span class="keyword">this</span>, data);</span><br><span class="line">                String placeText = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != place) &#123;</span><br><span class="line">                    placeText = <span class="string">"place.getId() = "</span> + place.getId()</span><br><span class="line">                              + <span class="string">"\nplace.getName() = "</span> + place.getName()</span><br><span class="line">                              + <span class="string">"\nplace.getLatLng().latitude = "</span> + place.getLatLng().latitude</span><br><span class="line">                              + <span class="string">"\nplace.getLatLng().longitude = "</span> + place.getLatLng().longitude</span><br><span class="line">                              + <span class="string">"\nplace.getAddress() = "</span> +place.getAddress()</span><br><span class="line">                              + <span class="string">"\nplace.getPhoneNumber() = "</span> + place.getPhoneNumber()</span><br><span class="line">                              + <span class="string">"\nplace.getLocale() = "</span> + place.getLocale()</span><br><span class="line">                              + <span class="string">"\n......."</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, getString(R.string.start_by_activity_btn_search_place_result, placeText), Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultCode == PlaceAutocomplete.RESULT_ERROR) &#123;</span><br><span class="line">            <span class="comment">//错误码</span></span><br><span class="line">                Status status = PlaceAutocomplete.getStatus(<span class="keyword">this</span>, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultCode == RESULT_CANCELED) &#123;</span><br><span class="line">            <span class="comment">//取消</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启导航</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNavigation</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Uri gmmIntentUri = Uri.parse(<span class="string">"google.navigation:q="</span>+latitude+<span class="string">","</span>+longitude+<span class="string">"&amp;mode=d"</span>);</span><br><span class="line">        Intent mapIntent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, gmmIntentUri);</span><br><span class="line">        mapIntent.setPackage(<span class="string">"com.google.android.apps.maps"</span>);</span><br><span class="line">        startActivity(mapIntent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//提示未安装google map</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//开启google map下载界面</span></span><br><span class="line">        showGoogleMapDownloadView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启google map下载界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showGoogleMapDownloadView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"market://details?id=com.google.android.apps.maps"</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri);</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附近地点"><a href="#附近地点" class="headerlink" title="附近地点"></a>附近地点</h4><ol><li><p>获取定位权限</p><p>获取方法和前面一样，使用 <em>checkLocationPermission()</em></p></li><li><p>打开 Activity，开启附近地点选择</p><p><code>private static final int PLACE_PICKER_REQUEST = 3;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PlacePicker.IntentBuilder builder = <span class="keyword">new</span> PlacePicker.IntentBuilder();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    startActivityForResult(builder.build(<span class="keyword">this</span>), PLACE_PICKER_REQUEST);</span><br><span class="line">&#125; <span class="keyword">catch</span> (GooglePlayServicesRepairableException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (GooglePlayServicesNotAvailableException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 onActivityResult 获取选择的地点信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (requestCode == PLACE_PICKER_REQUEST) &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">          Place place = PlacePicker.getPlace(<span class="keyword">this</span>, data);</span><br><span class="line">          <span class="comment">//place.getName() .... </span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Places"><a href="#Places" class="headerlink" title="Places"></a>Places</h2><h3 id="当前位置及附近地点"><a href="#当前位置及附近地点" class="headerlink" title="当前位置及附近地点"></a>当前位置及附近地点</h3><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mMaxEntries = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前位置及附近地点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCurrentPlaces</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mConnected) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkLocationPermission()) &#123;</span><br><span class="line">    <span class="comment">//未授权定位</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PendingResult&lt;PlaceLikelihoodBuffer&gt; result = Places.PlaceDetectionApi</span><br><span class="line">            .getCurrentPlace(mGoogleApiClient, <span class="keyword">null</span>);</span><br><span class="line">    result.setResultCallback(<span class="keyword">new</span> ResultCallback&lt;PlaceLikelihoodBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(@NonNull PlaceLikelihoodBuffer likelyPlaces)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            String[] likelyPlaceNames = <span class="keyword">new</span> String[mMaxEntries];</span><br><span class="line">            String[] likelyPlaceAddresses = <span class="keyword">new</span> String[mMaxEntries];</span><br><span class="line">            String[] likelyPlaceAttributions = <span class="keyword">new</span> String[mMaxEntries];</span><br><span class="line">            LatLng[] likelyPlaceLatLngs = <span class="keyword">new</span> LatLng[mMaxEntries];</span><br><span class="line">            <span class="keyword">for</span> (PlaceLikelihood placeLikelihood : likelyPlaces) &#123;</span><br><span class="line">                <span class="comment">// Build a list of likely places to show the user. Max 5.</span></span><br><span class="line">                likelyPlaceNames[i] = (String) placeLikelihood.getPlace().getName();</span><br><span class="line">                likelyPlaceAddresses[i] = (String) placeLikelihood.getPlace().getAddress();</span><br><span class="line">                likelyPlaceAttributions[i] = (String) placeLikelihood.getPlace()</span><br><span class="line">                        .getAttributions();</span><br><span class="line">                likelyPlaceLatLngs[i] = placeLikelihood.getPlace().getLatLng();</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//String placeId = (String) placeLikelihood.getPlace().getId();</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &gt; (mMaxEntries - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            likelyPlaces.release();</span><br><span class="line"></span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String placeName : likelyPlaceNames) &#123;</span><br><span class="line">                builder.append(placeName + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//显示地点列表</span></span><br><span class="line">            <span class="comment">//builder.toString()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据-PlaceID-获取对应地点"><a href="#根据-PlaceID-获取对应地点" class="headerlink" title="根据 PlaceID 获取对应地点"></a>根据 PlaceID 获取对应地点</h3><p>在 <em>onResult</em> 返回的 places 一般只有一个，所以取第一个元素，就是 id 对应的地点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过placeId获取对应的位置信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> placeId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">getPlaceById</span><span class="params">(String placeId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(placeId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Places.GeoDataApi.getPlaceById(mGoogleApiClient, placeId)</span><br><span class="line">            .setResultCallback(<span class="keyword">new</span> ResultCallback&lt;PlaceBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(PlaceBuffer places)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (places.getStatus().isSuccess() &amp;&amp; places.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Place myPlace = places.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="comment">//获取id对应的Place</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//没有获取到数据</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    places.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h2><p>这里说的 Web API 是指：通过拼接 url 的方式，向 Google 服务器请求数据，服务器会返回一段 JSON，我们本地再用 fastjson 解析，获取对应的数据。</p><h3 id="根据坐标获取所在城市"><a href="#根据坐标获取所在城市" class="headerlink" title="根据坐标获取所在城市"></a>根据坐标获取所在城市</h3><p>这里的 URL 可以这样拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GOOGLE_MAP_URL = <span class="string">"https://maps.google.com/maps/api/geocode/json?language=%1$s&amp;sensor=true&amp;latlng=%2$s,%3$s"</span>;</span><br></pre></td></tr></table></figure><p>其中 <em>%1$s</em> 对应的是语言，比如我要返回的是中文，那么对于的就是 <em>zh-CN*，</em>%2$s %3$s* 对应的就是纬度和经度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LANGUAGE = <span class="string">"zh-CN"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拼接url(默认设置语言为中文)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getGoogleMapUrl</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(GOOGLE_MAP_URL, DEFAULT_LANGUAGE, Double.valueOf(latitude), Double.valueOf(longitude));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，外面只需要直接调这个方法，参数传入纬度、经度，就会返回拼接好的 URL。</p><p>获取了 URL，我们就可以异步访问网络，去获取数据了。这里主要讲下思路，详细代码，可以自己查看 <a href="https://github.com/ansuote/GoogleMapDemo" target="_blank" rel="noopener">Demo</a>。</p><p>以Demo为例，拼接的URL为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//maps.google.com/maps/api/geocode/json?language=zh-CN&amp;sensor=true&amp;latlng=22.536817569098282,113.97451490163802</span></span><br></pre></td></tr></table></figure><p>获取的 JSON 如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"results"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"address_components"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"9028"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"9028"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"street_number"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"深南大道"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"深南大道"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"route"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"华侨城"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"华侨城"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"neighborhood"</span>,</span><br><span class="line">                        <span class="string">"political"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"南山区"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"南山区"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"political"</span>,</span><br><span class="line">                        <span class="string">"sublocality"</span>,</span><br><span class="line">                        <span class="string">"sublocality_level_1"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"深圳市"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"深圳市"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"locality"</span>,</span><br><span class="line">                        <span class="string">"political"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"广东省"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"广东省"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"administrative_area_level_1"</span>,</span><br><span class="line">                        <span class="string">"political"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                /**</span><br><span class="line">                 * 篇幅原因，省略其余数据</span><br><span class="line">                 */</span><br><span class="line">    <span class="string">"status"</span>: <span class="string">"OK"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 type 对应的值是 <strong>locality</strong> 的就是<strong>城市名字</strong>，<strong>political</strong> 代表<strong>政治实体</strong>。</p><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据经纬度获取对应的城市</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCityByLatlngWeb</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    String urlString = GoogleMapUrlUtil.getGoogleMapUrl(latitude, longitude);</span><br><span class="line">    <span class="keyword">if</span> (URLUtil.isNetworkUrl(urlString)) &#123;</span><br><span class="line">        <span class="keyword">new</span> GeocodeTask().execute(urlString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeocodeTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">JSONObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> com.alibaba.fastjson.<span class="function">JSONObject <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//请求网络，并且转化为 JSONObject 对象</span></span><br><span class="line">        <span class="keyword">return</span> GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(com.alibaba.fastjson.JSONObject result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != result) &#123;</span><br><span class="line">            JSONArray jsonArray = result.getJSONArray(<span class="string">"results"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jsonArray) &#123;</span><br><span class="line">                Object firstObj = jsonArray.get(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != firstObj) &#123;</span><br><span class="line">                    GeocodeBean bean = JSON.parseObject(firstObj.toString(), GeocodeBean.class);</span><br><span class="line">                    <span class="comment">//获取所在城市</span></span><br><span class="line">                    String city = getLocality(bean);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeocodeBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;AddressComponent&gt; address_components;</span><br><span class="line">    <span class="keyword">private</span> String formatted_address;</span><br><span class="line">    <span class="comment">//geometry</span></span><br><span class="line">    <span class="keyword">private</span> String place_id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; types;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//set, get 方法自己补充哈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据集里面获取所在城市</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getLocality</span><span class="params">(GeocodeBean bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != bean) &#123;</span><br><span class="line">        List&lt;AddressComponent&gt; list = bean.getAddress_components();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != list) &#123;</span><br><span class="line">            <span class="keyword">for</span> (AddressComponent address : list) &#123;</span><br><span class="line">                List&lt;String&gt; types = address.getTypes();</span><br><span class="line">                <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"locality"</span>.equals(type)) &#123;</span><br><span class="line">                        isFound = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isFound) &#123;</span><br><span class="line">                    <span class="keyword">return</span> address.getShort_name();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据经纬度获取附近地点-1"><a href="#根据经纬度获取附近地点-1" class="headerlink" title="根据经纬度获取附近地点"></a>根据经纬度获取附近地点</h3><p>前面获取对应城市中用的 URL 很方便，基本上没有限制。但是获取附近地点的就没这么好了，在拼接 URL 的时候，需要加上谷歌授权给你的 <em>Web API key</em>。这个是官方推荐的做法，详情可以查看<a href="https://developers.google.com/maps/documentation/geocoding/intro" target="_blank" rel="noopener">官网的介绍</a></p><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>这里有一点要特别注意的，这里说的 <em>Web API key</em> 必须要重新申请的。之前我们使用 GoogleMap 的时候已经申请了 KEY，但是选项选择的是<strong>【Android apps】</strong>，只是作用于 Android Map 相关 API，这个时候访问 Web API 必须重新申请多一个 KEY。申请方法和前面一样，只是选项为<strong>【None】</strong>即可。</p><p>设置完之后如果一般间隔几分钟就可以调用，如果不行，就要手动开启服务。<a href="https://console.developers.google.com/apis/api/places_backend?project=_" target="_blank" rel="noopener">点击此处开启</a>,选择对应的项目，<strong>【启用】</strong> <em>Google Places API Web Service</em> 服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GOOGLE_MAP_PLACES_URL = <span class="string">"https://maps.googleapis.com/maps/api/place/nearbysearch/json?language=%1$s&amp;location=%2$s,%3$s&amp;radius=%4$s&amp;type=%5$s&amp;key=%6$s"</span>;</span><br></pre></td></tr></table></figure><p>这下参数有点多了哈，前面3个和之前一样，分别对应语言、纬度、经度。第四个参数是查询地点的半径多大，第五个是类型，这里我使用的是 <strong>point_of_interest</strong> 意思是<strong>已经命名的景点</strong>，<a href="https://developers.google.com/maps/documentation/geocoding/intro#Types" target="_blank" rel="noopener">其他类型可以查看官网</a>，最后一个参数是你的 APP 申请的 Key值。</p><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取经纬度对应的附近地点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPlacesByLatLngWeb</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    String url = GoogleMapUrlUtil.getGoogleMapPlacesUrl(latitude, longitude);</span><br><span class="line">    <span class="keyword">if</span> (URLUtil.isNetworkUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">new</span> NearbyPlacesTask().execute(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyPlacesTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">JSONObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JSONObject <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(JSONObject result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != result) &#123;</span><br><span class="line">            JSONArray jsonArray = result.getJSONArray(<span class="string">"results"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jsonArray) &#123;</span><br><span class="line">                List&lt;NearbyPlaceBean&gt; list = JSON.parseArray(jsonArray.toString(), NearbyPlaceBean.class);</span><br><span class="line">                <span class="comment">//遍历 list 可以获取对应的附近地点信息</span></span><br><span class="line">                <span class="comment">//list的size能比较大，可以根据项目需求，指截取前面10个。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NearbyPlaceBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//geometry</span></span><br><span class="line">    <span class="comment">//icon</span></span><br><span class="line">    <span class="keyword">private</span> String id;      <span class="comment">//1f7541b5f729cdc8bc8bb546f205848c50315af7</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//澎柏白金假日公寓</span></span><br><span class="line">    <span class="comment">//photos</span></span><br><span class="line">    <span class="keyword">private</span> String place_id;    <span class="comment">//ChIJX9_kRAXsAzQRKmc97njB67c</span></span><br><span class="line">    <span class="comment">//reference</span></span><br><span class="line">    <span class="comment">//scope</span></span><br><span class="line">    <span class="comment">//types</span></span><br><span class="line">    <span class="keyword">private</span> String vicinity;    <span class="comment">//深圳市宝安区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GeometryBean geometry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set，get 自己补充哈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战：附近地点推荐"><a href="#实战：附近地点推荐" class="headerlink" title="实战：附近地点推荐"></a>实战：附近地点推荐</h2><p>可以像上面那样使用 Activity 的方式，弹出 Google 自带的地点推荐／选取界面，但是这样的UI定制性低，不能按照项目需求显示界面。所以根据上面学习到的东西，我重新写了个类似的界面，实现地点推荐、搜索、选择和截图功能的功能。考虑到频繁调接口会损耗请求次数，所以我设置了个半径，超过半径的才重新请求数据。</p><h2 id="限制／收费"><a href="#限制／收费" class="headerlink" title="限制／收费"></a>限制／收费</h2><p>前面我把类型分为 Map，Places主要原因就是，他们的收费标准是不同的。<a href="https://developers.google.com/maps/pricing-and-plans/#details" target="_blank" rel="noopener">详情可见</a></p><table><thead><tr><th align="left">Android</th><th align="left">标准方案</th><th align="left">高级</th></tr></thead><tbody><tr><td align="left">Google Maps Android API</td><td align="left">不受限制地免费使用。<a href="https://developers.google.com/maps/pricing-and-plans/#sup_1" target="_blank" rel="noopener">1</a></td><td align="left">定价基于所需数量。如需了解详细信息，请参阅<a href="https://developers.google.com/maps/premium/usage-limits" target="_blank" rel="noopener">Premium Plan使用率和限制</a>。</td></tr><tr><td align="left">Google Places API for Android</td><td align="left">默认每天 1,000 次免费请求，<a href="https://developers.google.com/places/android-api/usage#query-limits" target="_blank" rel="noopener">信用卡验证</a>后可增至每天 150,000 次免费请求。符合要求的应用可免费提升。<a href="https://developers.google.com/places/android-api/usage" target="_blank" rel="noopener">详情</a></td><td align="left">—-</td></tr></tbody></table><table><thead><tr><th align="left">Web 服务</th><th align="left">标准</th><th align="left">高级</th></tr></thead><tbody><tr><td align="left">Google Places API Web Service</td><td align="left">每天 150,000 次免费请求（<a href="https://developers.google.com/places/web-service/usage" target="_blank" rel="noopener">信用卡验证</a>后）。</td><td align="left">定价基于所需数量。如需了解详细信息，请参阅<a href="https://developers.google.com/maps/premium/usage-limits" target="_blank" rel="noopener">Premium Plan使用率和限制</a>。</td></tr></tbody></table><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><h3 id="官方-Demo"><a href="#官方-Demo" class="headerlink" title="官方 Demo"></a>官方 Demo</h3><p>官方 Demo 要跑起来，必须像前面的方式一样，去申请对应的 Key。</p><h4 id="android-samples-apiDemos"><a href="#android-samples-apiDemos" class="headerlink" title="android-samples-apiDemos"></a><a href="https://github.com/googlemaps/android-samples/tree/master/ApiDemos" target="_blank" rel="noopener">android-samples-apiDemos</a></h4><p>介绍 Map 相关 API。</p><h4 id="android-play-places"><a href="#android-play-places" class="headerlink" title="android-play-places"></a><a href="https://github.com/googlesamples/android-play-places/" target="_blank" rel="noopener">android-play-places</a></h4><p>介绍 Places 相关 API 。包括地点搜索，附近地点选择，地点补全等。</p><h4 id="android-maps-utils"><a href="#android-maps-utils" class="headerlink" title="android-maps-utils"></a><a href="https://github.com/googlemaps/android-maps-utils" target="_blank" rel="noopener">android-maps-utils</a></h4><p><strong>点聚合 Clustering</strong> 可以通过这个 demo 学习，GoogleMap的点聚合和百度是一样的用法，外层代码基本上是一样的。</p><h3 id="工具类网页"><a href="#工具类网页" class="headerlink" title="工具类网页"></a>工具类网页</h3><ol><li><a href="https://console.developers.google.com/apis/credentials?project=savvy-generator-167702" target="_blank" rel="noopener">API Console</a> （Key 管理控制台）</li><li><a href="https://developers.google.com/android/reference/com/google/android/gms/maps/package-summary" target="_blank" rel="noopener">Google Map API 查询</a></li><li>坐标反查 (通过经纬度查对应地点)<br><a href="https://www.google.com/maps" target="_blank" rel="noopener">GoogleMap</a><br>(谷歌地图直接把经纬度输入输入框即可查询，例如输入：22.536817569098282,113.97451490163802 )<br><a href="http://lbs.amap.com/console/show/picker" target="_blank" rel="noopener">高德地图</a><br><a href="http://api.map.baidu.com/lbsapi/getpoint/" target="_blank" rel="noopener">百度地图</a></li></ol><h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><p>[1]官方 Map 教程 <a href="https://developers.google.com/maps/documentation/android-api/" target="_blank" rel="noopener">https://developers.google.com/maps/documentation/android-api/</a><br>[2]官方 Places 教程 <a href="https://developers.google.com/places/android-api/" target="_blank" rel="noopener">https://developers.google.com/places/android-api/</a><br>[3]启动 GoogleMap <a href="https://developers.google.com/maps/documentation/android-api/intents" target="_blank" rel="noopener">https://developers.google.com/maps/documentation/android-api/intents</a><br>[4]Android使用intent调取导航或者地图 <a href="https://blog.csdn.net/qwer4755552/article/details/51659833" target="_blank" rel="noopener">https://blog.csdn.net/qwer4755552/article/details/51659833</a><br>[5]关于地图和偏移的那些事 <a href="https://blog.csdn.net/sanjay_f/article/details/48493699" target="_blank" rel="noopener">https://blog.csdn.net/sanjay_f/article/details/48493699</a><br>[6]地图坐标转换大全 <a href="http://www.eoeandroid.com/forum.php?mod=viewthread&tid=332419" target="_blank" rel="noopener">http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=332419</a><br>[7]Show Popup when Location access is disable by user (Andorid Google Maps) <a href="https://stackoverflow.com/questions/24160472/show-popup-when-location-access-is-disable-by-user-andorid-google-maps" target="_blank" rel="noopener">https://stackoverflow.com/questions/24160472/show-popup-when-location-access-is-disable-by-user-andorid-google-maps</a><br>[8]How to show enable location dialog like Google maps? <a href="https://stackoverflow.com/questions/29801368/how-to-show-enable-location-dialog-like-google-maps" target="_blank" rel="noopener">https://stackoverflow.com/questions/29801368/how-to-show-enable-location-dialog-like-google-maps</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;通过本文，你可以知道如何使用 GoogleMap 相关 API、定位当前位置、获取当前所在城市、获取当前位置附近的地点、导航、地点搜索等内容。大致内容，可以查看如下思维导图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/GoogleMapXmind.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Map" scheme="https://zhangmiao.cc/categories/Android/Map/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Map" scheme="https://zhangmiao.cc/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>最新Android框架排行榜，上百项资源汇总不容错过</title>
    <link href="https://zhangmiao.cc/posts/b0de6447.html"/>
    <id>https://zhangmiao.cc/posts/b0de6447.html</id>
    <published>2019-07-22T03:30:00.000Z</published>
    <updated>2019-07-22T03:36:29.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android框架排行榜"><a href="#Android框架排行榜" class="headerlink" title="Android框架排行榜"></a>Android框架排行榜</h4><h5 id="1-Retrofit"><a href="#1-Retrofit" class="headerlink" title="1.Retrofit　　"></a>1.Retrofit　　</h5><blockquote><p>一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言</p></blockquote><p>上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。</p><ul><li>官网地址：<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">http://square.github.io/retrofit/</a></li><li>github：<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">https://github.com/square/retrofit</a></li><li>作者：square团队</li></ul><h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;</span><br></pre></td></tr></table></figure><h5 id="2-okhttp"><a href="#2-okhttp" class="headerlink" title="2.okhttp"></a>2.okhttp</h5><blockquote><p>一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端</p></blockquote><p>上榜理由，okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。</p><ul><li>官网地址：<a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">http://square.github.io/okhttp/</a></li><li>github：<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">https://github.com/square/okhttp</a></li><li>作者：square团队</li></ul><h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup.okhttp3:okhttp:3.9.1&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="3-Butter-Knife"><a href="#3-Butter-Knife" class="headerlink" title="3.Butter Knife"></a>3.Butter Knife</h5><blockquote><p>一句话介绍：Butter Knife所提供了一种能力——使用注解生成模板代码，将view与方法和参数绑定。</p></blockquote><p>上榜理由：github上16.5K个star，配合Androidstudio提供的Butter Knife插件，帮助开发者省却了频繁findviewbyid的烦恼，最新的Butter Knife还提供了onclick绑定以及字符串的初始化，初学者可以查阅Butter Knife以及Butter Knife插件进一步学习！</p><ul><li>官网地址：<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">http://jakewharton.github.io/butterknife/</a></li><li>github：<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">https://github.com/JakeWharton/butterknife</a></li><li>作者：JakeWharton ，也是square团队成员之一</li></ul><h5 id="使用：-2"><a href="#使用：-2" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;com.jakewharton:butterknife:8.8.1&apos;  </span><br><span class="line">  annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-MPAndroidChart"><a href="#4-MPAndroidChart" class="headerlink" title="4.MPAndroidChart"></a>4.MPAndroidChart</h5><blockquote><p>一句话介绍：MPAndroidChart是一款图表框架</p></blockquote><p>上榜理由：github上16.1K个star，以快速、简洁。强大著称的图表框架</p><ul><li>官网地址：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart</a></li><li>github：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart</a></li><li>作者：PhilJay</li></ul><h5 id="使用：-3"><a href="#使用：-3" class="headerlink" title="使用："></a>使用：</h5><p>在AS中加入Gradle依赖</p><p>在根目录的 build.gradle上加入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">            maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app的build.gradle上加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.github.PhilJay:MPAndroidChart:v3.0.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-glide"><a href="#5-glide" class="headerlink" title="5.glide"></a>5.glide</h5><blockquote><p>一句话介绍：glide是一款专注于提供流畅划动能力的“图片加载和缓存框架”</p></blockquote><p>上榜理由：15.9k个star，图片加载类框架排名第一的框架，google 在2014开发者大会上演示的camera app就是基于gilde框架开发的</p><ul><li>github：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></li><li>作者：Bump Technologies团队</li></ul><h5 id="使用：-4"><a href="#使用：-4" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.github.bumptech.glide:glide:4.5.0&apos;   </span><br><span class="line">    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.5.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-leakcanary"><a href="#6-leakcanary" class="headerlink" title="6.leakcanary"></a>6.leakcanary</h5><blockquote><p>一句话介绍：一款内存检测框架，服务于java和android客户端</p></blockquote><p>上榜理由：方便，简洁是leakcanary最大的特点，只需在应用的apllication中集成，就可以直接使用它；15.5k个star说明了它有多么受欢迎</p><ul><li>github：<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a></li><li>作者：square团队</li></ul><h5 id="使用：-5"><a href="#使用：-5" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;   </span><br><span class="line">   releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;   </span><br><span class="line">   testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Application 中写入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void onCreate() &#123; </span><br><span class="line">    super.onCreate();    </span><br><span class="line">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;      </span><br><span class="line">      // This process is dedicated to LeakCanary for heap analysis.      </span><br><span class="line">      // You should not init your app in this process.      </span><br><span class="line">      return;    </span><br><span class="line">    &#125;    </span><br><span class="line">    LeakCanary.install(this);    </span><br><span class="line">    // Normal app init code...  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-Android-Universal-Image-Loader"><a href="#7-Android-Universal-Image-Loader" class="headerlink" title="7.Android-Universal-Image-Loader"></a>7.Android-Universal-Image-Loader</h5><blockquote><p>一句话介绍：曾经的图片加载框架王者，android开发老手都用过它</p></blockquote><p>上榜理由:android端图片加载框架的老大哥了，15.3k个star足以证明它的热门，UIL与gilde最大区别是可定制，UIL提供了大量配置方式，图片加载状态的回调（成功，失败，进行中），加载动画等；以及提供了移动端图片加载框架的缓存思路：三级缓存策略 sd卡-内存-网络；值得注意的是，UIL以及两年未更新了，但笔者仍推荐各位使用！</p><ul><li>github：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">https://github.com/nostra13/Android-Universal-Image-Loader</a></li><li>作者：nostra13</li></ul><h6 id="使用：-6"><a href="#使用：-6" class="headerlink" title="使用："></a>使用：</h6><ul><li>下载地址  universal-image-loader-1.9.5.jar</li></ul><h5 id="8-EventBus"><a href="#8-EventBus" class="headerlink" title="8.EventBus"></a>8.EventBus</h5><blockquote><p>一句话介绍：EventBus是一款本地组件间通信框架</p></blockquote><p>上榜理由：组件间通信框架star量第一：14.8k，在大型项目的Activities，fragments，Threads，Services都可以看到它的使用场景，尽管EventBus在向未创建的组件传递事件时有些局限，仅适合在“活着的”组件间传递消息，但仍不妨碍它活跃在各个大型项目各个场景里。</p><ul><li>官网地址：<a href="http://greenrobot.org/eventbus/documentation/how-to-get-started/" target="_blank" rel="noopener">http://greenrobot.org/eventbus/documentation/how-to-get-started/</a></li><li>github：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a></li><li>作者：greenrobot</li></ul><h5 id="使用：-7"><a href="#使用：-7" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br></pre></td></tr></table></figure><h5 id="9-zxing"><a href="#9-zxing" class="headerlink" title="9.zxing"></a>9.zxing</h5><blockquote><p>一句话介绍：条码图像处理库</p></blockquote><p>上榜理由：如果你用过二维码，你肯定已经间接使用过大名鼎鼎的zxing了。13.9K的star量，让它排在本榜单第九，实至名归，如果你有了解二维码的需求，不妨从了解、修改它源码入手。</p><ul><li>github：<a href="https://github.com/zxing/zxing" target="_blank" rel="noopener">https://github.com/zxing/zxing</a></li><li>作者：Sean Owen</li></ul><h5 id="10-picasso"><a href="#10-picasso" class="headerlink" title="10.picasso"></a>10.picasso</h5><blockquote><p>一句话介绍：强力的图片下载、缓存框架</p></blockquote><p>上榜理由：本榜单出现的第三款图片类框架，不同的是picasso更强调图片下载，你可以将picasso集成进你的项目中，你也可以结合gilde和UIL与picasso，三者一齐封装至你的项目中，按需所用。</p><ul><li>官网地址：<a href="http://square.github.io/picasso/" target="_blank" rel="noopener">http://square.github.io/picasso/</a></li><li>github：<a href="https://github.com/square/picasso" target="_blank" rel="noopener">https://github.com/square/picasso</a></li><li>作者：square团队</li></ul><h5 id="使用：-8"><a href="#使用：-8" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup.picasso:picasso:2.5.2&apos;</span><br></pre></td></tr></table></figure><p>或者下载jar包</p><h5 id="11-lottie-android"><a href="#11-lottie-android" class="headerlink" title="11.lottie-android"></a>11.lottie-android</h5><blockquote><p>一句话介绍：一款可以在Android端快速展示Adobe Afeter Effect（AE）工具所作动画的框架</p></blockquote><p>上榜理由：动画类框架第一名，github上13.3k个star证明了他的优越性，利用json文件快速实现动画效果是它最大的便利，而这个json文件也是由Adobe提供的After Effects（AE）工具制作的，在AE中装一个Bodymovin的插件，使用这个插件最终将动画效果生成json文件，这个json文件即可由LottieAnimationView解析并生成绚丽的动画效果。而且它还支持跨平台哟。</p><ul><li>github：<a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">https://github.com/airbnb/lottie-android</a></li><li>作者：Airbnb 团队</li></ul><h5 id="12-fresco"><a href="#12-fresco" class="headerlink" title="12.fresco"></a>12.fresco</h5><blockquote><p>一句话介绍：一款可以管理图片内存的框架</p></blockquote><p>上榜理由:github上12.8k个star，图片类排行榜第四名，facebook的出身证明了它并非是重复造的轮子，在管理图片内存领域上有着它的一片天地，渐进式加载、加载gif都是它与前三位相比独有的特性</p><ul><li>官网地址：<a href="https://www.fresco-cn.org/" target="_blank" rel="noopener">https://www.fresco-cn.org/</a></li><li>github：<a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">https://github.com/facebook/fresco</a></li><li>作者：facebook</li></ul><h5 id="使用：-9"><a href="#使用：-9" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 其他依赖  </span><br><span class="line">  compile &apos;com.facebook.fresco:fresco:0.12.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的依赖需要根据需求添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 在 API &lt; 14 上的机器支持 WebP 时，需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:animated-base-support:0.12.0&apos;  </span><br><span class="line"></span><br><span class="line">  // 支持 GIF 动图，需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:animated-gif:0.12.0&apos;  </span><br><span class="line"></span><br><span class="line">  // 支持 WebP （静态图+动图），需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:animated-webp:0.12.0&apos;  </span><br><span class="line">  compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos;  </span><br><span class="line"></span><br><span class="line">  // 仅支持 WebP 静态图，需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="13-RxAndroid"><a href="#13-RxAndroid" class="headerlink" title="13.RxAndroid"></a>13.RxAndroid</h5><blockquote><p>一句话介绍：一款Android客户端组件间异步通信的框架</p></blockquote><p>上榜理由：github上12.7k个star，位居组件通信框架的第二名，仅在EventBus之后，如果要问两者的区别，Eventbus是用来取代组件间繁琐的interface，RxAndroid是用来取代AnsyTask的，并不冲突；当然RxAndroid的优点并不仅限于此，更多优雅的实现，可以去官网查阅！</p><ul><li>github：<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">https://github.com/ReactiveX/RxAndroid</a></li><li>作者：JakeWharton</li></ul><h5 id="使用：-10"><a href="#使用：-10" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</span><br><span class="line">compile &apos;io.reactivex.rxjava2:rxjava:2.1.0&apos;</span><br></pre></td></tr></table></figure><h5 id="14-SlidingMenu"><a href="#14-SlidingMenu" class="headerlink" title="14.SlidingMenu"></a>14.SlidingMenu</h5><blockquote><p>一句话介绍：侧滑菜单栏框架</p></blockquote><p>上榜理由：与Userval-Image-loader 齐名的上古神器框架——为你的app提供侧滑菜单栏的功能；github闪更有10.5k个star，证明了它的经久不衰，即使在Google推出了NavigationDrawer，仍然没有减少开发者对SildingMenu的拥簇，经典总是经得起考验的，这个上古神兽已经四年没有更新了；有太多太多的app使用过它，这些都可以在软件的开源许可上看到！</p><ul><li>github：<a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="noopener">https://github.com/jfeinstein10/SlidingMenu</a></li><li>作者：Jeremy Feinstein</li></ul><h5 id="使用：-11"><a href="#使用：-11" class="headerlink" title="使用："></a>使用：</h5><p>在gihub上fork源码，集成进项目中</p><h5 id="15-PhotoView"><a href="#15-PhotoView" class="headerlink" title="15.PhotoView"></a>15.PhotoView</h5><blockquote><p>一句话介绍：一款ImageView展示框架，支持缩放，响应手势</p></blockquote><p>上榜理由：10.3k的star数量，位于图片类框架排行榜第五位，PhotoView与前四位不同的是这次带来的是图片的展示能力，你一定好奇微信的头像点击放大是如何实现的，很多App的图片显示响应手势按压是如何实现的，了解PhotoView，你一定会开心的！（笔者也不会告诉你ImageView的点击放大效果在Android的sample也有）</p><ul><li>github：<a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="noopener">https://github.com/chrisbanes/PhotoView</a></li><li>作者：chrisbanes</li></ul><h5 id="使用：-12"><a href="#使用：-12" class="headerlink" title="使用："></a>使用：</h5><p>在app根目录的build.gradle中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app的module目录的build.gralde中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.github.chrisbanes:PhotoView:latest.release.here&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.github.chrisbanes.photoview.PhotoView</span><br><span class="line">    android:id=&quot;@+id/photo_view&quot;    </span><br><span class="line">    android:layout_width=&quot;match_parent&quot;    </span><br><span class="line">    android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PhotoView photoView = (PhotoView) findViewById(R.id.photo_view);</span><br><span class="line">photoView.setImageResource(R.drawable.image);</span><br></pre></td></tr></table></figure><h5 id="16-material-dialogs"><a href="#16-material-dialogs" class="headerlink" title="16.material-dialogs"></a>16.material-dialogs</h5><blockquote><p>一句话介绍：一款自定义dialog框架</p></blockquote><p>上榜理由：9.9k个star，也是继PhotoView，SlidingMenu之后第三款自定义View框架，也许你还是自定义View的新人，对Dialog使用的还有点生疏，你可以通过它提升你的Dilaog使用能力</p><ul><li>github：<a href="https://github.com/afollestad/material-dialogs" target="_blank" rel="noopener">https://github.com/afollestad/material-dialogs</a></li><li>作者：Aidan Follestad</li></ul><h5 id="使用：-13"><a href="#使用：-13" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // ... other dependencies here    </span><br><span class="line">    compile &apos;com.afollestad.material-dialogs:core:0.9.4.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="17-droid-async-http"><a href="#17-droid-async-http" class="headerlink" title="17.droid-async-http"></a>17.droid-async-http</h5><blockquote><p>一句话介绍：一款基于Http协议的异步请求的网络框架，</p></blockquote><p>上榜理由：虽然你有无数个使用retrofit+okhttp的理由，但9.8k个star，证明它仍然值得你深入学习。值得注意的是，它也已经有两年没更新了，你尽管拿去当你懒惰的理由！</p><ul><li>github：<a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">https://github.com/loopj/android-async-http</a></li><li>作者：James Smith</li></ul><h5 id="使用：-14"><a href="#使用：-14" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  maven &#123; </span><br><span class="line">    url &apos;https://oss.sonatype.org/content/repositories/snapshots/&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;com.loopj.android:android-async-http:1.5.0-SNAPSHOT&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="18-androidannotations"><a href="#18-androidannotations" class="headerlink" title="18.androidannotations"></a>18.androidannotations</h5><blockquote><p>一句话介绍：一款基于注解的快速开发框架</p></blockquote><p>上榜理由：与Butterknife一样基于注解，利用注解快速完成view的初始化，不同的是androidannotations提供了更多的能力：简单的线程模型等；笔者只接触过Butterknife，无法更进一步叙述androidannotations的优势，如果你志在深入了解注解的妙用，可以尝试探索一下！</p><ul><li>官网地址：<a href="http://androidannotations.org/" target="_blank" rel="noopener">http://androidannotations.org/</a></li><li>github：<a href="https://github.com/androidannotations/androidannotations" target="_blank" rel="noopener">https://github.com/androidannotations/androidannotations</a></li><li>作者：WonderCsabo</li></ul><h5 id="19-fastjson"><a href="#19-fastjson" class="headerlink" title="19.fastjson"></a>19.fastjson</h5><blockquote><p>一句话介绍:一款基于json解析、生成的框架</p></blockquote><p>上榜理由：从它的名字不难看出，快速是它最大的特性，阿里巴巴的出身保证了代码的质量和优越，9.4k的star数量，也是榜单里第一个出现的中国开源框架，涉及网络的app都会用到json，fastjson值得作为你的首选！</p><ul><li>github：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a></li><li>作者：alibaba</li></ul><h5 id="使用：-15"><a href="#使用：-15" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.alibaba:fastjson:1.1.58.android&apos;</span><br></pre></td></tr></table></figure><h5 id="20-Material-Animations"><a href="#20-Material-Animations" class="headerlink" title="20.Material-Animations"></a>20.Material-Animations</h5><blockquote><p>一句话介绍：一款提供场景转换过渡能力的动画框架</p></blockquote><p>上榜理由：Android动画框架排行榜第二名，9.3k个star数量，与动画框架榜单第一名lottie-android不同的是，Material-Animations提供的是场景切换的动画效果。Android 官网sample中已经提供了部分Transition （转场动画）的展示，作为初学者很难快速拓展到自己项目中，Material-Animations的示例出现为开发者省去了此类麻烦，直接照搬应用到自己的App中吧。</p><ul><li>github：<a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">https://github.com/lgvalle/Material-Animations</a></li><li>作者：Luis G. Valle</li></ul><h5 id="使用：-16"><a href="#使用：-16" class="headerlink" title="使用："></a>使用：</h5><p>down源码，修改学习</p><h5 id="21-tinker"><a href="#21-tinker" class="headerlink" title="21.tinker"></a>21.tinker</h5><blockquote><p>一句话介绍：它是微信官网的Android热补丁解决方案</p></blockquote><p>上榜理由：9.1k个star，微信在用的热补丁方案，心动不如行动</p><ul><li>官网地址：<a href="http://www.tinkerpatch.com/Docs/intro" target="_blank" rel="noopener">http://www.tinkerpatch.com/Docs/intro</a></li><li>github：<a href="https://github.com/Tencent/tinker" target="_blank" rel="noopener">https://github.com/Tencent/tinker</a></li><li>作者：Tencent</li></ul><h5 id="22-ViewPagerIndicator"><a href="#22-ViewPagerIndicator" class="headerlink" title="22.ViewPagerIndicator"></a>22.ViewPagerIndicator</h5><blockquote><p>一句话介绍：一款基于ViewPager的页面指示器开源框架</p></blockquote><p>上榜理由：上古神器，尽管已经五年未更新了，但你仍然可以在淘宝等app中看到它的使用场景，8.9K的star量让它不愠不火的在矗立在榜单里</p><ul><li>官网地址：<a href="http://viewpagerindicator.com/" target="_blank" rel="noopener">http://viewpagerindicator.com/</a></li><li>github：<a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blank" rel="noopener">https://github.com/JakeWharton/ViewPagerIndicator</a></li><li>作者：JakeWharton</li></ul><h5 id="使用：-17"><a href="#使用：-17" class="headerlink" title="使用："></a>使用：</h5><p>下载地址：<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master" target="_blank" rel="noopener">https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master</a></p><h5 id="23-Android-CleanArchitecture"><a href="#23-Android-CleanArchitecture" class="headerlink" title="23.Android-CleanArchitecture"></a>23.Android-CleanArchitecture</h5><blockquote><p>一句话介绍：一个讲解设计框架的demo</p></blockquote><p>上榜理由：它不是框架，你可以把它当作一本书，它将教会你如何设计简洁的架构，工程里有一个sample app，配合图文讲解，你将对Android客户端的架构有更深一层的认识。8.8k的star数量，证明了它是一本“好书”哟。</p><ul><li>github：<a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">https://github.com/android10/Android-CleanArchitecture</a></li><li>作者：Fernando Cejas</li></ul><h5 id="24-Android-PullToRefresh"><a href="#24-Android-PullToRefresh" class="headerlink" title="24.Android-PullToRefresh"></a>24.Android-PullToRefresh</h5><blockquote><p>一句话介绍：一款为普通视图提供刷新UI的视图框架</p></blockquote><p>上榜理由：8.2K的star数量使它位居刷新类UI框架榜首，强大的兼容能力，该框架支持ListView，GrdiView，WebViewScrollView，ViewPager等众多View增加刷新的能力，如果你有增加上拉加载，下拉加载的需求，你应该考虑它了！</p><ul><li>github：<a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="noopener">https://github.com/chrisbanes/Android-PullToRefresh</a></li><li>作者：Chris Banes</li></ul><h5 id="使用：-18"><a href="#使用：-18" class="headerlink" title="使用："></a>使用：</h5><p>github fork源码，集成到项目中</p><h5 id="25-flexbox-layout"><a href="#25-flexbox-layout" class="headerlink" title="25.flexbox-layout"></a>25.flexbox-layout</h5><blockquote><p>一句话介绍：一款弹性伸缩布局</p></blockquote><p>上榜理由：8.1k个star，前端H5开发者转Android开发的福音，FlexboxLayout作为LinearLayout和RelativeLayout的替代者，值得各位一试，与其一同推出的还有ConstraintLayout。</p><ul><li>github：<a href="https://github.com/google/flexbox-layout" target="_blank" rel="noopener">https://github.com/google/flexbox-layout</a></li><li>作者：Google</li></ul><h5 id="使用：-19"><a href="#使用：-19" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.google.android:flexbox:0.3.0-alpha3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="26-AndroidSwipeLayout"><a href="#26-AndroidSwipeLayout" class="headerlink" title="26.AndroidSwipeLayout"></a>26.AndroidSwipeLayout</h5><blockquote><p>一句话介绍：非常强大滑动式布局</p></blockquote><p>上榜理由:滑动删除是国产app常见需求，商品详情的上下滑动需求作为开发者的我们也经常遇到，AndroidSwipeLayout在github上拥有8K个star，证明它经受住了检验，各位值得一试</p><ul><li>github：<a href="https://github.com/daimajia/AndroidSwipeLayout" target="_blank" rel="noopener">https://github.com/daimajia/AndroidSwipeLayout</a></li><li>作者：daimajia</li></ul><h5 id="使用：-20"><a href="#使用：-20" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.android.support:recyclerview-v7:21.0.0&apos;    </span><br><span class="line">    compile &apos;com.android.support:support-v4:20.+&apos;    </span><br><span class="line">    compile &quot;com.daimajia.swipelayout:library:1.2.0@aar&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="或下载"><a href="#或下载" class="headerlink" title="或下载"></a>或下载</h5><p>AndroidSwipeLayout-v1.1.8.jar</p><h5 id="27-realm-java"><a href="#27-realm-java" class="headerlink" title="27.realm-java"></a>27.realm-java</h5><blockquote><p>一句话介绍：Realm是一款移动端数据库框架</p></blockquote><p>上榜理由：核心数据引擎C++打造，比普通的Sqlite型数据库快的多。笔者猜测正是如此，realm以7892个star数让它位于大名鼎鼎的数据库框架GreenDao（7877）之前</p><ul><li>官网地址：<a href="https://realm.io/cn/" target="_blank" rel="noopener">https://realm.io/cn/</a></li><li>github：<a href="https://github.com/realm/realm-java" target="_blank" rel="noopener">https://github.com/realm/realm-java</a></li><li>作者：Realm团队</li></ul><h5 id="使用：-21"><a href="#使用：-21" class="headerlink" title="使用："></a>使用：</h5><p><a href="https://realm.io/docs/java/latest/" target="_blank" rel="noopener">https://realm.io/docs/java/latest/</a></p><h5 id="28-greenDAO"><a href="#28-greenDAO" class="headerlink" title="28.greenDAO"></a>28.greenDAO</h5><blockquote><p>一句话介绍：greenDAO是一款高效、快速的SQLite型数据库</p></blockquote><p>上榜理由：greenDAO的star数量与Realm不相上下，且与EventBus师出同门，也是由greenrobot团队开发维护的，质量有所保证，但若拷问笔者Realm与greenDao两者的优劣性，只能具体到实际使用当中，模拟线上的使用情形，进行高强度测试后才能下判断，故在此不能一言两语说完，深表遗憾</p><ul><li>官网地址：<a href="http://greenrobot.org/greendao/" target="_blank" rel="noopener">http://greenrobot.org/greendao/</a></li><li>github：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">https://github.com/greenrobot/greenDAO</a></li></ul><h5 id="使用：-22"><a href="#使用：-22" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()        </span><br><span class="line">        mavenCentral() // add repository    </span><br><span class="line">    &#125;    </span><br><span class="line">    dependencies &#123; </span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.1&apos;        </span><br><span class="line">        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin </span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="29-stetho"><a href="#29-stetho" class="headerlink" title="29.stetho"></a>29.stetho</h5><blockquote><p>一句话介绍：一款提供在Chrome开发者工具上调试Android app能力的开源框架</p></blockquote><p>上榜理由：上古时期Android程序员要调试本地数据库，需要进入Android Device Monitor找到/data/data/com.xxx.xxx/databases里面的db文件，导出到PC端，用PC的数据工具查看，现在使用stetho省却了如此的麻烦；如今的Android程序员如果想调试网络请求响应过程中的报文段，需要在请求中加入Log语句，一个信息一个信息打印出来，相当繁琐，现在请使用stetho，省却诸如此类的麻烦把！7.8K个star数，广大Android开发者调试的福音，你值得拥有！</p><ul><li>官网地址：<a href="http://facebook.github.io/stetho/" target="_blank" rel="noopener">http://facebook.github.io/stetho/</a></li><li>github：<a href="https://github.com/facebook/stetho" target="_blank" rel="noopener">https://github.com/facebook/stetho</a></li><li>作者：FaceBook</li></ul><h5 id="使用：-23"><a href="#使用：-23" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile ‘com.facebook.stetho:stetho:1.5.0’</span><br></pre></td></tr></table></figure><h5 id="30-BaseRecyclerViewAdapterHelper"><a href="#30-BaseRecyclerViewAdapterHelper" class="headerlink" title="30.BaseRecyclerViewAdapterHelper"></a>30.BaseRecyclerViewAdapterHelper</h5><blockquote><p>一句话介绍：强大、流畅的Recyvlerview通用适配器</p></blockquote><p>上榜理由：如果你是RecyclerView的拥簇者，你一定要体验这款专门服务该view的适配器，7.7K个star，让这个家伙位于github上Android 适配器排行榜第一，还有很多惊喜等你去探寻！</p><ul><li>官网地址：<a href="http://www.recyclerview.org/" target="_blank" rel="noopener">http://www.recyclerview.org/</a></li></ul><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123; </span><br><span class="line">        ...       </span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot;&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.CymChad:BaseRecyclerViewAdapterHelper:VERSION_CODE&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="31-AndroidViewAnimations"><a href="#31-AndroidViewAnimations" class="headerlink" title="31.AndroidViewAnimations"></a>31.AndroidViewAnimations</h5><blockquote><p>一句话介绍：一款提供可爱动画集合的框架</p></blockquote><p>上榜理由：正如作者所说，它囊括了开发需求过程中所有的动画效果，集成进了这个简洁可爱的动画框架。7.6K的star数，证明了它在动画框架领域的战斗力，让它仅仅位列lottie-android和Material-Animations两个动画框架霸主之后，屈居第三名</p><ul><li>github：<a href="https://github.com/daimajia/AndroidViewAnimations" target="_blank" rel="noopener">https://github.com/daimajia/AndroidViewAnimations</a></li><li>作者：daimajia</li></ul><h5 id="使用：-24"><a href="#使用：-24" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.android.support:support-compat:25.1.1&apos;        </span><br><span class="line">        compile &apos;com.daimajia.easing:library:2.0@aar&apos;        </span><br><span class="line">        compile &apos;com.daimajia.androidanimations:library:2.2@aar&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sample：</span><br><span class="line">YoYo.with(Techniques.Tada)</span><br><span class="line">    .duration(700)    </span><br><span class="line">    .repeat(5)    </span><br><span class="line">    .playOn(findViewById(R.id.edit_area));</span><br></pre></td></tr></table></figure><h5 id="32-MaterialDrawer"><a href="#32-MaterialDrawer" class="headerlink" title="32.MaterialDrawer"></a>32.MaterialDrawer</h5><blockquote><p>一句话介绍：强大的塑料风格的抽屉框架</p></blockquote><p>上榜理由：7.6K的star数量，作者的持续更新状态，如果你还在犹豫上手SlidingMenu遇到bug没人管的困境，那么你可以入手它作为你的抽屉布局</p><ul><li>github：<a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="noopener">https://github.com/mikepenz/MaterialDrawer</a></li><li>作者：Mike Penz</li></ul><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用:"></a>使用:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compile(&apos;com.mikepenz:materialdrawer:5.9.2@aar&apos;) &#123;</span><br><span class="line">    transitive = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new DrawerBuilder().withActivity(this).build();</span><br></pre></td></tr></table></figure><h5 id="33-Android-ObservableScrollView"><a href="#33-Android-ObservableScrollView" class="headerlink" title="33.Android-ObservableScrollView"></a>33.Android-ObservableScrollView</h5><blockquote><p>一句话介绍：一款让视图滑动更具有视觉效果的滑动式框架</p></blockquote><p>上榜理由：7.5K的star数量，证明了它曾经的价值，github上提供了12种滑动效果，你可以用它弥补其他框架的不足，提升你的App体验！</p><ul><li>github：<a href="https://github.com/ksoichiro/Android-ObservableScrollView" target="_blank" rel="noopener">https://github.com/ksoichiro/Android-ObservableScrollView</a></li><li>作者：Soichiro Kashima</li></ul><h5 id="使用：-25"><a href="#使用：-25" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile com.github.ksoichiro:android-observablescrollview</span><br></pre></td></tr></table></figure><h5 id="34-CircleImageView"><a href="#34-CircleImageView" class="headerlink" title="34.CircleImageView"></a>34.CircleImageView</h5><blockquote><p>一句话介绍：圆角ImageView</p></blockquote><p>上榜理由：也许你已经听说过无数种展示圆角图片的方法，但如果你不尝试尝试CircleImageView，那么你的知识库会因为少了它黯然失色，有的时候完成需求是开发者优先考虑的，不同实现方法牵扯到的性能差异更值得让人深思，如果你有心在图片性能上有所涉猎，那么CircleImageView绝对不会让你败兴而归。最后别忘了记得去看Romain Guy的建议哟。</p><ul><li>github：<a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">https://github.com/hdodenhof/CircleImageView</a></li><li>作者：Henning Dodenhof</li></ul><h5 id="使用：-26"><a href="#使用：-26" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...    </span><br><span class="line">    compile &apos;de.hdodenhof:circleimageview:2.1.0&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;de.hdodenhof.circleimageview.CircleImageView</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:id=&quot;@+id/profile_image&quot;</span><br><span class="line">    android:layout_width=&quot;96dp&quot;</span><br><span class="line">    android:layout_height=&quot;96dp&quot;</span><br><span class="line">    android:src=&quot;@drawable/profile&quot;</span><br><span class="line">    app:civ_border_width=&quot;2dp&quot;    </span><br><span class="line">    app:civ_border_color=&quot;#FF000000&quot;/&gt;</span><br></pre></td></tr></table></figure><h5 id="35-logger"><a href="#35-logger" class="headerlink" title="35.logger"></a>35.logger</h5><blockquote><p>一句话介绍：一款让log日志优雅显示的框架</p></blockquote><p>上榜理由：logger作为调试框架，并未给出很强大的能力，它最大的亮点是优雅的输出log信息，并且支持多种格式：线程、Json、Xml、List、Map等，如果你整日沉迷于汪洋大海般的log信息不能自拔，logger就是你的指路明灯！6.6k个star让他位列调试框架第二名，屈居facebook的stetho之后</p><ul><li>github：<a href="https://github.com/orhanobut/logger" target="_blank" rel="noopener">https://github.com/orhanobut/logger</a></li><li>作者：Orhan Obut</li></ul><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.orhanobut:logger:2.1.1&apos;</span><br><span class="line"></span><br><span class="line">Logger.d(MAP);</span><br><span class="line">Logger.d(SET);</span><br><span class="line">Logger.d(LIST);</span><br><span class="line">Logger.d(ARRAY);</span><br><span class="line">Logger.json(JSON_CONTENT);</span><br><span class="line">Logger.xml(XML_CONTENT);</span><br></pre></td></tr></table></figure><h5 id="36-agera"><a href="#36-agera" class="headerlink" title="36.agera"></a>36.agera</h5><blockquote><p>一句话介绍:一款服务于Android平台的响应式编程框架</p></blockquote><p>上榜理由：google专门推出一套响应式编程框架服务于Android开发者，相比于之响应式编程框架榜首的 RxJava RxAndroid，它更轻量，两者最大的不同点在于agera基于push event、pull data （VS Rx系列 push data）。</p><ul><li>github：<a href="https://github.com/google/agera" target="_blank" rel="noopener">https://github.com/google/agera</a></li><li>作者：Google</li></ul><h5 id="使用：-27"><a href="#使用：-27" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.google.android.agera:agera:1.3.0&apos;</span><br></pre></td></tr></table></figure><h5 id="扩展能力"><a href="#扩展能力" class="headerlink" title="扩展能力"></a>扩展能力</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.google.android.agera:content:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:database:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:net:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:rvadapter:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:rvdatabinding:1.3.0&apos;</span><br></pre></td></tr></table></figure><h5 id="37-BottmBar"><a href="#37-BottmBar" class="headerlink" title="37.BottmBar"></a>37.BottmBar</h5><blockquote><p>一句话介绍：一款底部导航栏视图框架</p></blockquote><p>上榜理由：底部栏里的王者框架，6.3K的star数量，证明了它的优秀，完全遵循材料设计规范，上手非常方便。如果说缺点，无法设置icon与titile的间距，无法自定义视图的大小等，但这些都可以通过修改源代码解决，笔者献丑也修改了一套符合国内开发者的底部导航框架，即将开源。</p><ul><li>github：<a href="https://github.com/roughike/BottomBar" target="_blank" rel="noopener">https://github.com/roughike/BottomBar</a></li><li>作者：Iiro Krankka</li></ul><h5 id="使用：-28"><a href="#使用：-28" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.roughike:bottom-bar:2.3.1&apos;</span><br></pre></td></tr></table></figure><h5 id="38-Calligraphy"><a href="#38-Calligraphy" class="headerlink" title="38.Calligraphy"></a>38.Calligraphy</h5><blockquote><p>一句话介绍：一款自定义字体框架</p></blockquote><p>上榜理由：如果你还在为一键修改App内所有字体样式而烦恼，6.3K个star的Calligraphy就值得你拥有，它可以同时修改整个整个项目的Textview字体，也可以单独 设置某个Textview的字体，还在等什么，快来试试吧！</p><ul><li>github：<a href="https://github.com/chrisjenx/Calligraphy" target="_blank" rel="noopener">https://github.com/chrisjenx/Calligraphy</a></li><li>作者：Christopher Jenkins</li></ul><h5 id="使用：-29"><a href="#使用：-29" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;uk.co.chrisjenx:calligraphy:2.3.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="39-AndroidSlidingUpPanel"><a href="#39-AndroidSlidingUpPanel" class="headerlink" title="39.AndroidSlidingUpPanel"></a>39.AndroidSlidingUpPanel</h5><blockquote><p>一句话介绍：可拖动的滑动面板视图框架</p></blockquote><p>上榜理由：如果你的项目需要一个可拖拽的滑动式面板（展示某些详情信息，播放音乐，地图信息等），那么推荐你使用它，6.3k个star，来自创业公司umano的作品，证明它是用心推出的杰作</p><ul><li>github：<a href="https://github.com/umano/AndroidSlidingUpPanel" target="_blank" rel="noopener">https://github.com/umano/AndroidSlidingUpPanel</a></li><li>作者：umano</li></ul><h5 id="使用：-30"><a href="#使用：-30" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    repositories &#123;    </span><br><span class="line">       mavenCentral()    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    compile &apos;com.sothree.slidinguppanel:library:3.3.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="40-AppIntro"><a href="#40-AppIntro" class="headerlink" title="40.AppIntro"></a>40.AppIntro</h5><blockquote><p>一句话介绍：一款提供快速制作欢迎页的框架</p></blockquote><p>上榜理由：笔者从未把打算把欢迎页框架纳入排行榜当中，作为国内开发者，ViewPager开发App的欢迎页已经是手到擒来的需求，为何一个开源的欢迎页框架会在github上拥有6.3k个star？也许你会不屑一顾，是的，往往就在不屑一顾的瞬间，机遇就悄悄溜走了。</p><ul><li>github：<a href="https://github.com/apl-devs/AppIntro" target="_blank" rel="noopener">https://github.com/apl-devs/AppIntro</a></li><li>作者：Paolo Rotolo</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;  </span><br><span class="line">   repositories &#123;      </span><br><span class="line">       ...            </span><br><span class="line">       maven &#123; url &apos;https://jitpack.io&apos;&#125; </span><br><span class="line">   &#125;      </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">dependencies &#123;     </span><br><span class="line">        compile &apos;com.github.apl-devs:appintro:v4.2.0&apos;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="41-recyclerview-animators"><a href="#41-recyclerview-animators" class="headerlink" title="41.recyclerview-animators"></a>41.recyclerview-animators</h5><blockquote><p>一句话介绍：一款为Recyclerview提供扩展动画能力的框架</p></blockquote><p>上榜理由：有一句老话：如果有天你失去对新事物的兴趣，那就说明你老了。recyclerview已经推出快三年了，还在用listview的人们，是否已经发掘自己渐渐变老；不要灰心，快为你的项目加入recyclerview-animators框架吧，为“自己”加入新鲜的血液和能量！（笔者备注：6.2K个star）</p><ul><li>github：<a href="https://github.com/wasabeef/recyclerview-animators" target="_blank" rel="noopener">https://github.com/wasabeef/recyclerview-animators</a></li><li>作者：<a href="https://github.com/wasabeef" target="_blank" rel="noopener">https://github.com/wasabeef</a></li></ul><h5 id="使用：-31"><a href="#使用：-31" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // jCenter  </span><br><span class="line">  compile &apos;jp.wasabeef:recyclerview-animators:2.2.6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="42-dagger"><a href="#42-dagger" class="headerlink" title="42.dagger"></a>42.dagger</h5><blockquote><p>一句话介绍：一款通过依赖注入降低程序间耦合的开发框架</p></blockquote><p>上榜理由：github 上dagger1版本 有6.2k个star ， dagger2版本有7.3k个；由square完成的dagger1版本，到如今google团队接手的dagger2版本，强力开发团队保证了代码在设计上的优越性；如果你想探究Android 领域的设计模式，这也是不错的选择。</p><ul><li>官网地址：<a href="https://google.github.io/dagger/" target="_blank" rel="noopener">https://google.github.io/dagger/</a></li><li>github：<a href="https://github.com/google/dagger" target="_blank" rel="noopener">https://github.com/google/dagger</a></li><li>作者：google</li></ul><h5 id="使用：-32"><a href="#使用：-32" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;com.google.dagger:dagger:2.x&apos;  </span><br><span class="line">  annotationProcessor &apos;com.google.dagger:dagger-compiler:2.x&apos;</span><br><span class="line">&#125;</span><br><span class="line">If you&apos;re using classes in dagger.android you&apos;ll also want to include:</span><br><span class="line"></span><br><span class="line">compile &apos;com.google.dagger:dagger-android:2.x&apos;</span><br><span class="line">compile &apos;com.google.dagger:dagger-android-support:2.x&apos; </span><br><span class="line">annotationProcessor &apos;com.google.dagger:dagger-android-processor:2.x&apos;</span><br></pre></td></tr></table></figure><h5 id="43-Android-Bootstarp"><a href="#43-Android-Bootstarp" class="headerlink" title="43.Android-Bootstarp"></a>43.Android-Bootstarp</h5><blockquote><p>一句话介绍：一款提供在Android应用上实现Bootstrap（web框架）所作出效果的框架</p></blockquote><p>上榜理由：榜单上第二款响应web技术的Android 端框架，还记得第一名是谁吗——flexbox-layout，作为Android开发者，你有必要去了解Web技术了。5.9k个star，证明它不容小觑</p><ul><li>github：<a href="https://github.com/Bearded-Hen/Android-Bootstrap" target="_blank" rel="noopener">https://github.com/Bearded-Hen/Android-Bootstrap</a></li><li>作者：Bearded-Hen团队</li></ul><h5 id="使用：-33"><a href="#使用：-33" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile &apos;com.beardedhen:androidbootstrap:&#123;X.X.X&#125;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="44-RxBinding"><a href="#44-RxBinding" class="headerlink" title="44.RxBinding"></a>44.RxBinding</h5><p>一句话介绍：一款提供UI组件事件响应能力的框架</p><p>上榜理由：如果你还未开始RxAndroid 之旅，RxBinding可以作为你的第一站，通过RXBinding，你将理解响应式编程的快乐，让项目里的事件流程更清晰。5.6K个star，RxAndroid作者亲自操刀，快来试用吧！</p><ul><li>github：<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">https://github.com/JakeWharton/RxBinding</a></li><li>作者：JakeWharton</li></ul><h5 id="Platform-bindings"><a href="#Platform-bindings" class="headerlink" title="Platform bindings:"></a>Platform bindings:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding:2.0.0&apos;</span><br><span class="line">&apos;support-v4&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-support-v4:2.0.0&apos;</span><br><span class="line">&apos;appcompat-v7&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-appcompat-v7:2.0.0&apos;</span><br><span class="line">&apos;design&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-design:2.0.0&apos;</span><br><span class="line">&apos;recyclerview-v7&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:2.0.0&apos;</span><br><span class="line">&apos;leanback-v17&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-leanback-v17:2.0.0&apos;</span><br></pre></td></tr></table></figure><h5 id="45-ListViewAnimations"><a href="#45-ListViewAnimations" class="headerlink" title="45.ListViewAnimations"></a>45.ListViewAnimations</h5><blockquote><p>一句话介绍：一款为ListView提供动展示画效果能力的框架</p></blockquote><p>上榜理由：如果有一天我承认自己老了，我还会排排我的兄弟——ListView，证明我和它一起战斗过。ListViewAnimations的存在就是证明我们这些“老年人”仍有用武之地，也许你有说不出口的难处，无法体会到RecyclerView里动画的快乐，拥有ListViewAnimations，你一样可以骄傲的说，我的孩子（每个item）也有自己的动效啦。（笔者备注 5.6K个star）</p><ul><li>github：<a href="https://github.com/nhaarman/ListViewAnimations" target="_blank" rel="noopener">https://github.com/nhaarman/ListViewAnimations</a></li><li>作者：nhaarman</li></ul><h5 id="使用：-34"><a href="#使用：-34" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.nhaarman.listviewanimations:lib-core:3.1.0@aar&apos;    </span><br><span class="line">    compile &apos;com.nhaarman.listviewanimations:lib-manipulation:3.1.0@aar&apos;    </span><br><span class="line">    compile &apos;com.nhaarman.listviewanimations:lib-core-slh:3.1.0@aar&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="46-UItimateRecyclerView"><a href="#46-UItimateRecyclerView" class="headerlink" title="46.UItimateRecyclerView"></a>46.UItimateRecyclerView</h5><blockquote><p>一句话介绍：一款提供刷新、加载更多、动画特效等额外能力的RecyclerView框架</p></blockquote><p>上榜理由：榜单上第三次出现RecyclerView的身影，足以证明RecyclerView的优异性，5.5K个star，框架里所提供众多的能力，如果你是个功利开发者，那么此框架会为你节省很多学习时间，它可以完成多item式布局的大多数需求，值得注意的是，这个项目也是在其他项目的思路上二次开发的。</p><ul><li>github：<a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="noopener">https://github.com/cymcsg/UltimateRecyclerView</a></li><li>作者：MarshalChen</li></ul><h5 id="使用：-35"><a href="#使用：-35" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()    </span><br><span class="line">    &#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...    </span><br><span class="line">    compile &apos;com.marshalchen.ultimaterecyclerview:library:0.7.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="47-uCrop"><a href="#47-uCrop" class="headerlink" title="47.uCrop"></a>47.uCrop</h5><blockquote><p>一句话介绍：一款优雅的图片裁剪框架</p></blockquote><p>上榜理由：5.3K个star，图片编辑模块单独拎出来也是一款优雅的App。</p><ul><li>github：<a href="https://github.com/Yalantis/uCrop" target="_blank" rel="noopener">https://github.com/Yalantis/uCrop</a></li><li>作者：Yalantis</li></ul><h5 id="使用：-36"><a href="#使用：-36" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">   repositories &#123;  </span><br><span class="line">      jcenter()      </span><br><span class="line">      maven &#123; url &quot;https://jitpack.io&quot; &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile &apos;com.github.yalantis:ucrop:2.2.1&apos;</span><br></pre></td></tr></table></figure><h5 id="48-RxJava-Android-Samples"><a href="#48-RxJava-Android-Samples" class="headerlink" title="48.RxJava-Android-Samples"></a>48.RxJava-Android-Samples</h5><blockquote><p>一句话介绍：一款介绍RxJava使用场景的app</p></blockquote><p>上榜理由：榜单出现的第一个“仅仅为告诉你如何使用另一个项目”的开源项目，它可以说是RxJava的用例，你想得到的想不到的RxJava用法这里都有，这就是为什么它以5.2k个star矗立在这份榜单里的原因。遗憾自己没有创作这么一个受人追捧的demo？赶快动手写个其他的“XX项目用例吧”</p><ul><li>github：<a href="https://github.com/kaushikgopal/RxJava-Android-Samples" target="_blank" rel="noopener">https://github.com/kaushikgopal/RxJava-Android-Samples</a></li><li>作者：kaushikgopal</li></ul><h5 id="使用：-37"><a href="#使用：-37" class="headerlink" title="使用："></a>使用：</h5><p>clone到本地慢慢探索吧</p><h5 id="49-AndroidAutoLayout"><a href="#49-AndroidAutoLayout" class="headerlink" title="49.AndroidAutoLayout"></a>49.AndroidAutoLayout</h5><blockquote><p>一句话介绍：一个提供适配能力的框架</p></blockquote><p>上榜理由：5.2K个star，鸿洋老弟的作品，适合小项目的开发团队，拿到设计MM的px像素设计稿是不是很头疼捏？这个框架一键式搞定你的问题，它有很多的不足，但在追求完美适配的路上，你值得探索和了解它！笔者并不推荐把它应用到已经成熟运行的项目中，毕竟市面上已经有太多的适配解决方案了，适配问题就像是个大杂烩，想炒一盘好菜，就得备好各种佐料（适配小方案），当你把各种小佐料用的炉火纯青的时候，你离美食大厨就不远了。</p><ul><li>github：<a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="noopener">https://github.com/hongyangAndroid/AndroidAutoLayout</a></li><li>作者：张鸿洋</li></ul><h5 id="使用：-38"><a href="#使用：-38" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.zhy:autolayout:1.4.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="50-EffectiveAndroidUI"><a href="#50-EffectiveAndroidUI" class="headerlink" title="50.EffectiveAndroidUI"></a>50.EffectiveAndroidUI</h5><blockquote><p>一句话介绍：一款讲解高效展示UI的教学型App</p></blockquote><p>上榜理由：编程新手很难对MVC MVP,MVVM等模式有深刻的理解，如果有一个示例型app，那对初学者会有很大裨益，笔者在遇到它时也是相见恨晚。4.8K个star，证明了它经受了广大开发者的考验与审视，其中Effective UI的编程思想更是与Android官方课程里的Effective UI课程不谋而合，并且，此项目还包含了fragment、dagger、主题样式、Butterknife等众多小知识点，作为编程初学者的学习用例再适合不过了</p><ul><li>github：<a href="https://github.com/pedrovgs/EffectiveAndroidUI" target="_blank" rel="noopener">https://github.com/pedrovgs/EffectiveAndroidUI</a></li><li>作者：Pedro Vicente</li></ul><h5 id="使用：-39"><a href="#使用：-39" class="headerlink" title="使用："></a>使用：</h5><p>clone项目到本地</p><h5 id="51-Luban"><a href="#51-Luban" class="headerlink" title="51.Luban"></a>51.Luban</h5><blockquote><p>一句话介绍：最接近微信的图片压缩框架</p></blockquote><p>上榜理由：好的思路总是可以让你大放异彩，Luban仅以图片压缩单一功能，俘获了4.8K个star，证明了它在图片压缩上的造诣，它可能不是最优秀的，但它是让你我最接近伟大的项目</p><ul><li>github：<a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">https://github.com/Curzibn/Luban</a></li><li>作者：Curzibn</li></ul><h5 id="使用：-40"><a href="#使用：-40" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;top.zibin:Luban:1.1.1&apos;</span><br></pre></td></tr></table></figure><h5 id="52-DroidPlugin"><a href="#52-DroidPlugin" class="headerlink" title="52.DroidPlugin"></a>52.DroidPlugin</h5><blockquote><p>一句话介绍：一款热门的插件化开发框架</p></blockquote><p>上榜理由：4.8K个star，插件化框架榜单第一名，，360团队出品，框架质量有保证，有成功案例——360手机助手，并且持续维护着</p><ul><li>github：<a href="https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md" target="_blank" rel="noopener">https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md</a></li><li>作者：Andy Zhang</li></ul><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用:"></a>使用:</h5><p>clone项目到本地</p><h5 id="53-otto"><a href="#53-otto" class="headerlink" title="53.otto"></a>53.otto</h5><blockquote><p>一句话介绍:一款老旧且强大的事件总线框架</p></blockquote><p>上榜理由：4.8K个star，是square团队早先推出的事件响应型框架，淘宝app的事件驱动也是基于此框架封装的，如今square已经建议开发者采用RxJava RxAndroid来代替otto了。但otto仍有与EventBus横向对比的价值，纵向来说，otto与square自家开发的Rx系列框架的差异同样值得开发者们去探究。</p><ul><li>github <a href="https://github.com/square/otto" target="_blank" rel="noopener">https://github.com/square/otto</a></li><li>作者：square</li></ul><h5 id="使用：-41"><a href="#使用：-41" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()    </span><br><span class="line">    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile &apos;com.michaelpardo:activeandroid:3.1.0-SNAPSHOT&apos;</span><br></pre></td></tr></table></figure><h5 id="54-u2020"><a href="#54-u2020" class="headerlink" title="54.u2020"></a>54.u2020</h5><blockquote><p>一句话介绍：一款提供Dagger的高级教学示例的app（额，名字是有点绕）</p></blockquote><p>上榜理由：4.7K个star，JakeWharton牵头开发的教学类app，教你使用Dagger在其他高级框架的用法，它展示了Dagger与ButterKnife、Retrofit、Moshi、Picasso、Okhttp、RxJava、Timber、Madge、LeakCanar等众多优秀框架结合起来的高级用法，你也可以借鉴到自己的项目当中</p><ul><li>github：<a href="https://github.com/JakeWharton/u2020" target="_blank" rel="noopener">https://github.com/JakeWharton/u2020</a></li><li>作者：JakeWharton</li></ul><h5 id="55-buck"><a href="#55-buck" class="headerlink" title="55.buck"></a>55.buck</h5><blockquote><p>一句话介绍：buck是一个快速构建系统</p></blockquote><p>上榜理由：facebook+google出身的作者，对构建代码的出色理解，加上大型团队的维护，以及增量更新时的快速高效，让buck成为了微信Android团队构建项目的首选，构建大型项目时，它比gradle更快，然而中小公司并不适合此框架，但作为立志在框架设计领域有一番作为的人们，欢迎来一探究竟</p><ul><li>官网地址：<a href="https://buckbuild.com/" target="_blank" rel="noopener">https://buckbuild.com/</a></li><li>github：<a href="https://github.com/facebook/buck" target="_blank" rel="noopener">https://github.com/facebook/buck</a></li><li>作者：facebook</li></ul><h5 id="使用：-42"><a href="#使用：-42" class="headerlink" title="使用："></a>使用：</h5><p>linux or mac system  +docs</p><h5 id="56-PermissionsDispatcher"><a href="#56-PermissionsDispatcher" class="headerlink" title="56.PermissionsDispatcher"></a>56.PermissionsDispatcher</h5><blockquote><p>一句话介绍：一款基于注解的提供解决运行时危险权限方案的框架</p></blockquote><p>上榜理由：自Android6.0 Google提出危险权限一词起，用户安全性被提到一定的高度，一些运行时对用户较为危险的权限将不再自动被开发者获取，需要经过用户批准，开发者才可以继续使用该权限，如果你曾经被权限问题搞的抓耳挠腮，建议你试试这个框架，它足够解决你的问题</p><ul><li>官网地址：<a href="https://hotchemi.github.io/PermissionsDispatcher/" target="_blank" rel="noopener">https://hotchemi.github.io/PermissionsDispatcher/</a></li><li>github：<a href="https://github.com/hotchemi/PermissionsDispatcher" target="_blank" rel="noopener">https://github.com/hotchemi/PermissionsDispatcher</a></li><li>作者：Shintaro Katafuchi</li></ul><h5 id="使用：-43"><a href="#使用：-43" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile(&apos;com.github.hotchemi:permissionsdispatcher:$&#123;latest.version&#125;&apos;) &#123;</span><br><span class="line">        exclude module: &quot;support-v13&quot;  </span><br><span class="line">  &#125;  </span><br><span class="line">  annotationProcessor &apos;com.github.hotchemi:permissionsdispatcher-processor:$&#123;latest.version&#125;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  jcenter()  </span><br><span class="line">  maven &#123; url &apos;http://oss.jfrog.org/artifactory/oss-snapshot-local/&apos; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="57-android-gif-drawable"><a href="#57-android-gif-drawable" class="headerlink" title="57.android-gif-drawable"></a>57.android-gif-drawable</h5><blockquote><p>一句话介绍:一款提供展示GIF动画能力的视图框架</p></blockquote><p>上榜理由：据我所查国内著名App——知乎使用了android-gif-drawable，因此证明了它的存在价值，尽管在榜单第十一位介绍了lottie-android直接应用AE动画的示例，但AE设计师不是每个公司都配备的，GIF的存在，就必然存在了展示GIF的需要，它值得你拥有！</p><ul><li>github：<a href="https://github.com/koral--/android-gif-drawable" target="_blank" rel="noopener">https://github.com/koral--/android-gif-drawable</a></li><li>作者：Karol Wrótniak</li></ul><h5 id="使用：-44"><a href="#使用：-44" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()    </span><br><span class="line">    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;pl.droidsonroids.gif:android-gif-drawable:1.2.+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="58-Apktool"><a href="#58-Apktool" class="headerlink" title="58.Apktool"></a>58.Apktool</h5><blockquote><p>一句话介绍：一款反编译apk的工具</p></blockquote><p>上榜理由：开源的反编译工具，对于志在了解apk逆向破解的诸位，值得拥有，4.5k个star，逆向破解apk神器！</p><ul><li>github：<a href="https://github.com/iBotPeaches/Apktool" target="_blank" rel="noopener">https://github.com/iBotPeaches/Apktool</a></li><li>官网地址：<a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">https://ibotpeaches.github.io/Apktool/</a></li><li>作者：Connor Tumbleson</li></ul><h5 id="59-dynamic-load-apk"><a href="#59-dynamic-load-apk" class="headerlink" title="59.dynamic-load-apk"></a>59.dynamic-load-apk</h5><blockquote><p>一句话介绍：插件化开发框架</p></blockquote><p>上榜理由：4.5k个star，位于插件化开发框架第二名（第一名来自360团队），全面的文档介绍让你很快就能上手插件化开发，如果你喜欢大段文字讲解，那么这个项目一定适合你</p><ul><li>github：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">https://github.com/singwhatiwanna/dynamic-load-apk</a></li><li>作者：singwhatiwanna</li></ul><h5 id="使用：-45"><a href="#使用：-45" class="headerlink" title="使用："></a>使用：</h5><p>github上的文档配合作者博客更配哟</p><h5 id="60-atlas"><a href="#60-atlas" class="headerlink" title="60.atlas"></a>60.atlas</h5><blockquote><p>一句话介绍：淘宝推出的组件化开发框架</p></blockquote><p>上榜理由：淘宝团队所出的精品，atlas框架提供了解耦、组件、动态的开发能力，4.5k个star让他位列组件化开发框架第一名</p><ul><li>github：<a href="https://github.com/alibaba/atlas" target="_blank" rel="noopener">https://github.com/alibaba/atlas</a></li><li>作者：alibaba</li></ul><h5 id="61-volley"><a href="#61-volley" class="headerlink" title="61.volley"></a>61.volley</h5><blockquote><p>一句话介绍：google推荐使用的Android端网络请求框架</p></blockquote><p>上榜理由：4.4k个star，并不是他不够优秀，而是使用volley已经渐渐成为广大开发者的习惯</p><ul><li>github：<a href="https://github.com/google/volley（新版volley地址）" target="_blank" rel="noopener">https://github.com/google/volley（新版volley地址）</a></li><li>作者：google</li></ul><h5 id="使用：-46"><a href="#使用：-46" class="headerlink" title="使用："></a>使用：</h5><p>clone源码到本地</p><h5 id="62-androidmvp"><a href="#62-androidmvp" class="headerlink" title="62.androidmvp"></a>62.androidmvp</h5><blockquote><p>一句话介绍：一款展示Android端Mvp设计的demo</p></blockquote><p>上榜理由：榜单里为数不多、仅凭展示某种设计模式就获得4.2K个star的项目，如果你有尝试mvp的打算，androidmvp可以作为你的前哨站</p><ul><li>github：<a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="noopener">https://github.com/antoniolg/androidmvp</a></li><li>作者：Antonio Leiva</li></ul><h5 id="使用：-47"><a href="#使用：-47" class="headerlink" title="使用："></a>使用：</h5><p>clone到本地</p><h5 id="63-SwipeBackLayout"><a href="#63-SwipeBackLayout" class="headerlink" title="63.SwipeBackLayout"></a>63.SwipeBackLayout</h5><blockquote><p>一句话介绍:一款可以让你通过滑动手势关闭页面的的框架</p></blockquote><p>上榜理由：仿微信滑动退出当前聊天界面的效果，提供了activity的滑动关闭能力，通过这种思路，实现fragment的滑动关闭轻而易举;笔者坚持建议诸位clone源码到本地探索一番；4.2k个star证明很多人都喜爱它</p><ul><li>github：<a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="noopener">https://github.com/ikew0ng/SwipeBackLayout</a></li><li>作者：ike_w0ng</li></ul><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用:"></a>使用:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;me.imid.swipebacklayout.lib:library:1.0.0&apos;</span><br></pre></td></tr></table></figure><h5 id="64-FlycoTabLayout"><a href="#64-FlycoTabLayout" class="headerlink" title="64.FlycoTabLayout"></a>64.FlycoTabLayout</h5><blockquote><p>一句话介绍：一款可以让作出多种多样指示器效果的框架</p></blockquote><p>上榜理由：尽管我们没有理由为了给app加入页面指示器功能就集成2.5M的依赖库，但是作为了解viewpager或swip views的指示器设计原理的优秀框架，你值得打开它试试，笔者建议单独拆分所需源码，加入到自己的项目中去。4.1K个star，二次开发的作品，仍然推荐！</p><ul><li>github：<a href="https://github.com/H07000223/FlycoTabLayout" target="_blank" rel="noopener">https://github.com/H07000223/FlycoTabLayout</a></li><li>作者：Flyco</li></ul><h5 id="65-android-testing"><a href="#65-android-testing" class="headerlink" title="65.android-testing"></a>65.android-testing</h5><blockquote><p>一句话介绍：一款展示四大自动化测试框架用例的demo（Espresso，UiAutomator，AndroidJunitRunner，JUnit4）</p></blockquote><p>上榜理由：学习者经常会陷入似懂非懂的境地，如果你有幸学习过Android Testing Support Library site的课程，那么你一定对android的四大测试框架迫不及待，这款demo非常适合你，快来学习这个4.1k个star的明星项目吧</p><ul><li>github：<a href="https://github.com/googlesamples/android-testing" target="_blank" rel="noopener">https://github.com/googlesamples/android-testing</a></li><li>作者：googlesampes团队</li></ul><h5 id="66-FileDownloader"><a href="#66-FileDownloader" class="headerlink" title="66.FileDownloader"></a>66.FileDownloader</h5><blockquote><p>一句话介绍：一款高效、稳定、灵活、易用的文件下载引擎</p></blockquote><p>上榜理由：4.1k证明了它有多受人喜爱，文件下载看似简单的背后暗藏了多少的坑坑点点，我知道你有能力自己实现文件下载功能，但优秀的框架可以提升你的设计编码能力，这款框架可以提升你的实力！</p><ul><li>github：<a href="https://github.com/lingochamp/FileDownloader" target="_blank" rel="noopener">https://github.com/lingochamp/FileDownloader</a></li><li>作者：LingoChamp团队</li></ul><h5 id="使用：-48"><a href="#使用：-48" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.liulishuo.filedownloader:library:1.5.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="67-JieCaoVideoPlayer"><a href="#67-JieCaoVideoPlayer" class="headerlink" title="67.JieCaoVideoPlayer"></a>67.JieCaoVideoPlayer</h5><blockquote><p>一句话介绍：基于MediaPlayer api——VideoView 的多媒体播放框架</p></blockquote><p>上榜理由：榜单里第三款多媒体播放框架，它以灵巧的身姿挤入本榜单，精巧是它最大的优点，不到100k，拥有它，你就可以快速开发类似今日头条那样的视频播放效果，4k个star，证明它值得一试</p><ul><li>github：<a href="https://github.com/lipangit/JieCaoVideoPlayer" target="_blank" rel="noopener">https://github.com/lipangit/JieCaoVideoPlayer</a></li><li>作者：Nathen</li></ul><h5 id="使用：-49"><a href="#使用：-49" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;fm.jiecao:jiecaovideoplayer:5.5.4&apos;</span><br></pre></td></tr></table></figure><h5 id="68-glide-transformations"><a href="#68-glide-transformations" class="headerlink" title="68.glide-transformations"></a>68.glide-transformations</h5><blockquote><p>一句话介绍：为众多著名图片加载框架提供图片形状变幻能力的框架</p></blockquote><p>上榜理由：在榜单靠前的部分已经介绍过glide，Picasso，Fresco等图片加载框架，glide-transformations就是一款为他们提供图片变形能力的框架，使用起来非常简单，因此受到了大家的喜爱，github上有3.8K个star</p><ul><li>github：<a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="noopener">https://github.com/wasabeef/glide-transformations</a></li><li>作者：Daichi Furiya</li></ul><h5 id="使用：-50"><a href="#使用：-50" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;jp.wasabeef:glide-transformations:2.0.2&apos;    </span><br><span class="line">    // If you want to use the GPU Filters    </span><br><span class="line">    compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Glide里设置变幻效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set Glide Transform.</span><br><span class="line"></span><br><span class="line">Glide.with(this).load(R.drawable.demo) </span><br><span class="line">       .bitmapTransform(new BlurTransformation(context))        </span><br><span class="line">       .into((ImageView) findViewById(R.id.image));</span><br></pre></td></tr></table></figure><h5 id="69-android-gpuimage"><a href="#69-android-gpuimage" class="headerlink" title="69.android-gpuimage"></a>69.android-gpuimage</h5><blockquote><p>一句话介绍：一款基于OpenGL的图片渲染引擎</p></blockquote><p>上榜理由：放下GpuImage在IOS平台的荣誉不谈，Android版的android-gpuimage就提供多达70多种图片渲染效果，你还在好奇美图秀秀是如何实现图片变幻的？有了它，一切都不是问题。如果你是美图工具类的工程师，此框架的建设思路也会对你大有裨益。笔者也是通过android-gpuimage仿造了美图App并俘获女友芳心的，再次为它的实力点赞。ios版+android版一共19k个star，已经证明了它的实力，还在等什么呢？</p><ul><li>github：<a href="https://github.com/CyberAgent/android-gpuimage" target="_blank" rel="noopener">https://github.com/CyberAgent/android-gpuimage</a></li><li>作者：CyberAgent 团队</li></ul><h5 id="使用：-51"><a href="#使用：-51" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的改造方法，还需要阅读Ios的编程文档，对于有毅力的小伙伴强力推荐！</p><h5 id="70-RxPermissions"><a href="#70-RxPermissions" class="headerlink" title="70.RxPermissions"></a>70.RxPermissions</h5><blockquote><p>一句话介绍：一款基于RxJava完成权限申请的框架</p></blockquote><p>上榜理由：榜单里第二款提供权服务的框架，基于RxJava的设计，让你可以专心写业务，3.7K个star已经证明了它的实用价值</p><ul><li>github：<a href="https://github.com/tbruyelle/RxPermissions" target="_blank" rel="noopener">https://github.com/tbruyelle/RxPermissions</a></li><li>作者：Thomas Bruyelle</li></ul><h5 id="使用：-52"><a href="#使用：-52" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter() // If not already there</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RxPermissions rxPermissions = new RxPermissions(this); </span><br><span class="line"></span><br><span class="line">rxPermissions</span><br><span class="line">    .request(Manifest.permission.CAMERA)    </span><br><span class="line">    .subscribe(granted -&gt; &#123;   </span><br><span class="line">        if (granted) &#123; // I can control the camera now        </span><br><span class="line">        &#125; else &#123;       </span><br><span class="line">           // Oups permission denied       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h5 id="71-freeline"><a href="#71-freeline" class="headerlink" title="71.freeline"></a>71.freeline</h5><blockquote><p>一句话介绍：一款动态替换的编译构建框架</p></blockquote><p>上榜理由：继Facebook的Buck，Androdi官方的InstRun之后，蚂蚁金服推出了Freeline编译框架，官网宣称Freeline与业内主流构建方式相比仍然有数倍的速度领先;排行有先后，编译速度并不在本榜单排序的考据因素中，因此freeline以3.7个star，暂列编译框架第二名</p><ul><li>官网地址：<a href="https://www.freelinebuild.com/" target="_blank" rel="noopener">https://www.freelinebuild.com/</a></li><li>github：<a href="https://github.com/alibaba/freeline" target="_blank" rel="noopener">https://github.com/alibaba/freeline</a></li><li>作者：alibaba</li></ul><h5 id="使用：-53"><a href="#使用：-53" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;   </span><br><span class="line">        jcenter()   </span><br><span class="line">    &#125;    </span><br><span class="line">    dependencies &#123; </span><br><span class="line">       classpath &apos;com.antfortune.freeline:gradle:0.8.7&apos;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;com.antfortune.freeline&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>File → Settings… → Plugins → Browse repositories →freeline.</p></blockquote><h5 id="72-RxLifecycle"><a href="#72-RxLifecycle" class="headerlink" title="72.RxLifecycle"></a>72.RxLifecycle</h5><blockquote><p>一句话介绍：一款提供在使用RxJava过程中管理Activity和Fragment生命周期能力的框架</p></blockquote><p>上榜理由：在榜单靠前的部分，你已经了解RxJava和RxAndroid的强大之处，但部分粗心的开发者因为没有及时取消订阅而产生严重的内存泄漏，不要担心，RxLifecycle可以为你解决难题，在gtihub上拥有3.7K个star，国内知名软件——知乎和淘宝也都在使用它</p><ul><li>github：<a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">https://github.com/trello/RxLifecycle</a></li><li>作者：trello团队</li></ul><h5 id="使用：-54"><a href="#使用：-54" class="headerlink" title="使用："></a>使用：</h5><p>clone源码到本地</p><h5 id="73-classyshark"><a href="#73-classyshark" class="headerlink" title="73.classyshark"></a>73.classyshark</h5><blockquote><p>一句话介绍：一款可执行文件浏览器</p></blockquote><p>上榜理由：榜单里继Apktool之后第二款apk逆向工具，如果你喜欢优雅的图形数据展示，那么你一定不能错过他，classyshark可以将破解的结果以图形化展示用户，方便分析，3.7K个star，让它暂列apk逆向工具第二位！</p><ul><li>github：<a href="https://github.com/google/android-classyshark" target="_blank" rel="noopener">https://github.com/google/android-classyshark</a></li><li>作者：google</li></ul><h5 id="使用：-55"><a href="#使用：-55" class="headerlink" title="使用："></a>使用：</h5><p>下载 JAR</p><h5 id="74-acra"><a href="#74-acra" class="headerlink" title="74.acra"></a>74.acra</h5><blockquote><p>一句话介绍：一款提供记录APP崩溃日志能力的框架</p></blockquote><p>上榜理由：如果你面临着收集APP崩溃日志的需求，那么acra是个不错的选择。3.7K个star，让acra位列崩溃日志框架排行榜第一名，acra有足够的能力记录线上APP，并且发回服务端，acra也提供了相当棒的崩溃日志统计服务端框架Acralyzer，cralyzer工作在Apache CouchDB之上，所以除了CouchDB之外，没有必要安装任何额外的软件，移动端开发者也可以借此学习服务端的建设，一举两得！</p><ul><li>github：<a href="https://github.com/ACRA/acra" target="_blank" rel="noopener">https://github.com/ACRA/acra</a></li><li>服务端github：<a href="https://github.com/ACRA/acralyzer" target="_blank" rel="noopener">https://github.com/ACRA/acralyzer</a></li><li>作者：acra团队</li></ul><h5 id="使用：-56"><a href="#使用：-56" class="headerlink" title="使用："></a>使用：</h5><p>没有什么方法比clone源码到本地更方便了</p><h5 id="75-DiskLruCache"><a href="#75-DiskLruCache" class="headerlink" title="75.DiskLruCache"></a>75.DiskLruCache</h5><blockquote><p>一句话介绍：一款提供磁盘文件缓存管理能力的框架</p></blockquote><p>上榜理由：3.7k个star并不足以说明DiskLruCache的优秀，仅仅以管理磁盘文件能力单独拎出来成为一个框架，作者需要很大的勇气，很幸运，作者做到了，并且也成为Google官网提倡的缓存  ；如还记得上次做“一键清除缓存”、“查看缓存文件大小”功能是什么时候吗？DiskLruCache一句话就可以搞定！</p><ul><li>github：<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">https://github.com/JakeWharton/DiskLruCache</a></li><li>作者：JakeWharton</li></ul><h5 id="使用：-57"><a href="#使用：-57" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.jakewharton:disklrucache:2.0.2&apos;</span><br></pre></td></tr></table></figure><p>或者下载 latest .jar</p><h5 id="76-dexposed"><a href="#76-dexposed" class="headerlink" title="76.dexposed"></a>76.dexposed</h5><blockquote><p>一句话介绍：一款支撑阿里大部分App客户端热修复、线上调试能力的框架</p></blockquote><p>上榜理由：榜单上再次出现热修复框架的身影，证明App热修复技术的火热，dexposed提供图形化的性能监控、在线热修复bug漏洞、支持AOP编程思想等，不论你是企业热修复技术的设计者还是打算在热修复领域一探究竟的新人，这款框架很适合你。3.5k个star，证明它作为一门技术框架的存在，是多么令人喜爱！</p><ul><li>github：<a href="https://github.com/alibaba/dexposed" target="_blank" rel="noopener">https://github.com/alibaba/dexposed</a></li><li>作者：alibaba</li></ul><h5 id="使用：-58"><a href="#使用：-58" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.taobao.android:dexposed:0.1.1@aar&apos;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="77-Litho"><a href="#77-Litho" class="headerlink" title="77.Litho"></a>77.Litho</h5><blockquote><p>一句话介绍：一款提供高效构建UI能力的框架</p></blockquote><p>上榜理由：作为一款专门构建UI的框架，Litho高效的地方在于：单独开辟了用于渲染和布局的线程，然后将创建好的组件传递给UI线程去完成最终的渲染，使用更少的视图层级，来提升界面的滚动速度，值得注意的是，它仅支持开发者作出不可改变的UI组件 ,3.5K个star，证明了它在构建UI领域的价值，更多的妙处，期待你亲自去发掘！</p><ul><li>github：<a href="https://github.com/facebook/litho" target="_blank" rel="noopener">https://github.com/facebook/litho</a></li><li>作者：facebook</li></ul><h5 id="使用：-59"><a href="#使用：-59" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // ...  </span><br><span class="line">  // Litho  </span><br><span class="line">  compile &apos;com.facebook.litho:litho-core:0.3.1&apos;  </span><br><span class="line">  compile &apos;com.facebook.litho:litho-widget:0.3.1&apos;  </span><br><span class="line">  provided &apos;com.facebook.litho:litho-annotations:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  annotationProcessor &apos;com.facebook.litho:litho-processor:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  // SoLoader  </span><br><span class="line">  compile &apos;com.facebook.soloader:soloader:0.2.0&apos;  </span><br><span class="line"></span><br><span class="line">  // Optional  </span><br><span class="line">  // For debugging  </span><br><span class="line">  debugCompile &apos;com.facebook.litho:litho-stetho:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  // For integration with Fresco  </span><br><span class="line">  compile &apos;com.facebook.litho:litho-fresco:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  // For testing  </span><br><span class="line">  testCompile &apos;com.facebook.litho:litho-testing:0.3.1&apos;&#125;</span><br></pre></td></tr></table></figure><h5 id="78-mosby"><a href="#78-mosby" class="headerlink" title="78.mosby"></a>78.mosby</h5><blockquote><p>一句话介绍：一款提供构建MVP项目能力的框架</p></blockquote><p>上榜理由：榜单靠前的部分已经介绍了MVC,MVVM,MVP的框架项目，想必此时你在构建企业项目架构上，选择或者开发一款合适的MVP框架迫在眉睫，mosby可以作为你的第一步参考，你可以封装它，也可以照抄它，无论如何，3.4K个star，证明了它在框架设计上有多受开发者的喜爱</p><ul><li>github：<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="noopener">https://github.com/sockeqwe/mosby</a></li><li>作者：Hannes Dorfmann</li></ul><h5 id="使用：-60"><a href="#使用：-60" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">  compile &apos;com.hannesdorfmann.mosby3:mvi:3.0.4&apos; // Model-View-Intent  </span><br><span class="line">  // or  </span><br><span class="line">  compile &apos;com.hannesdorfmann.mosby3:mvp:3.0.4&apos; // Plain MVP  </span><br><span class="line">  // or  </span><br><span class="line">  compile &apos;com.hannesdorfmann.mosby3:viewstate:3.0.4&apos; // MVP + ViewState support</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">      ...    </span><br><span class="line"></span><br><span class="line">      maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="79-AndResGuard"><a href="#79-AndResGuard" class="headerlink" title="79.AndResGuard"></a>79.AndResGuard</h5><blockquote><p>一句话介绍：一款提供资源文件路径混淆 的工具</p></blockquote><p>上榜理由：如果你是个对APK大小很敏感的人，那么AndResGuard一定适合你，它的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a，3.4K个star，证明了在优化APK道路上，你不是一个人在战斗！</p><ul><li>github：<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">https://github.com/shwenzhang/AndResGuard</a></li><li>作者：wechat team</li></ul><h5 id="使用：-61"><a href="#使用：-61" class="headerlink" title="使用："></a>使用：</h5><p>clone项目到本地，其实也就是个三两句话的文档</p><h5 id="80-StatusBarUtil"><a href="#80-StatusBarUtil" class="headerlink" title="80.StatusBarUtil"></a>80.StatusBarUtil</h5><blockquote><p>一句话介绍：一款提供设置沉浸式状态栏样式能力的框架</p></blockquote><p>上榜理由：设计师MM总是抱怨系统状态栏不优雅？那就给她一个完美的沉浸式状态栏。StatusBarUtil可以随心所欲的设置状态栏样式，3.3K个star，足以说明它有多受设计MM的喜爱</p><ul><li>github：<a href="https://github.com/laobie/StatusBarUtil" target="_blank" rel="noopener">https://github.com/laobie/StatusBarUtil</a></li><li>作者：Jaeger</li></ul><h5 id="使用：-62"><a href="#使用：-62" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.jaeger.statusbarutil:library:1.4.0&apos;</span><br></pre></td></tr></table></figure><h5 id="81-robolectric"><a href="#81-robolectric" class="headerlink" title="81.robolectric"></a>81.robolectric</h5><blockquote><p>一句话介绍：一款不依赖于Android设备的单元测试框架，</p></blockquote><p>上榜理由：sample中列举了如何对Android四大组件和常见功能测试的用例，3.2K个star，值得充满好奇心的人尝试</p><ul><li>官网地址：<a href="http://robolectric.org/" target="_blank" rel="noopener">http://robolectric.org/</a></li><li>github：<a href="https://github.com/robolectric/robolectric" target="_blank" rel="noopener">https://github.com/robolectric/robolectric</a></li><li>作者：robolectric</li></ul><h5 id="使用：-63"><a href="#使用：-63" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile &quot;org.robolectric:robolectric:3.3.2&quot;</span><br></pre></td></tr></table></figure><h5 id="82-Fragmentation"><a href="#82-Fragmentation" class="headerlink" title="82.Fragmentation"></a>82.Fragmentation</h5><blockquote><p>一句话介绍:一款提供管理Fragmen嵌套t能力的框架</p></blockquote><p>上榜理由：对于Activity和Fragment使用，你一定得心应手，但如果要做一套通用的Activity&amp;Fragment嵌套设计，想必你有点手足无措了，Fragmentation可以作为你设计Fragment管理上的第一步，3.2K个star，笔者认为有点名副其实了，项目介绍里说的是Fragment的管理能力，但并未提供Fragment&amp;Activity生命周期、任务栈的管理能力，因此很难直接应用到企业项目当中，但源码当中的设计思路，值得笔者与诸位借鉴，拾人牙慧留有余香！</p><ul><li>github：<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="noopener">https://github.com/YoKeyword/Fragmentation</a></li><li>作者：YoKey</li></ul><h5 id="使用：-64"><a href="#使用：-64" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// appcompat v7包是必须的compile ‘me.yokeyword:fragmentation:0.10.7’// 如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，请再添加下面的库// compile ‘me.yokeyword:fragmentation-swipeback:0.10.4’</span><br></pre></td></tr></table></figure><h5 id="83-Small"><a href="#83-Small" class="headerlink" title="83.Small"></a>83.Small</h5><blockquote><p>一句话介绍：轻巧的插件化框架</p></blockquote><p>上榜理由：作为插件框架榜单的新成员，Small的优点是轻巧，适合作为小团队的插件开发方案，3.1K个star，让它获得了酷狗音乐等著名开发团队的青睐，如果你们的团队想逐步实施插件化开发，Small是个不错的选择！</p><ul><li>官网地址：<a href="http://code.wequick.net/Small/cn/cases" target="_blank" rel="noopener">http://code.wequick.net/Small/cn/cases</a></li><li>github：<a href="https://github.com/wequick/Small" target="_blank" rel="noopener">https://github.com/wequick/Small</a></li><li>作者：wequick 团队</li></ul><h5 id="使用：-65"><a href="#使用：-65" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript  &#123;</span><br><span class="line">    dependencies &#123;  </span><br><span class="line">          classpath &apos;net.wequick.tools.build:gradle-small:1.2.0-alpha6&apos;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;net.wequick.small&apos;small &#123; </span><br><span class="line">   aarVersion = &apos;1.2.0-alpha6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="84-JsBridge"><a href="#84-JsBridge" class="headerlink" title="84.JsBridge"></a>84.JsBridge</h5><blockquote><p>一句话介绍：一款提供WebView和Javascript通信能力的框架</p></blockquote><p>上榜理由：该框架提供给了允许H5页面调用通过JS调用App方法的能力；3.1K个star，简洁的通讯方式，值得每一个WebHybrid App开发者尝试</p><ul><li>gtihub：<a href="https://github.com/lzyzsd/JsBridge" target="_blank" rel="noopener">https://github.com/lzyzsd/JsBridge</a></li><li>作者：hi大头鬼hi</li></ul><h5 id="使用：-66"><a href="#使用：-66" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    // ...    </span><br><span class="line">    maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; </span><br><span class="line">   compile &apos;com.github.lzyzsd:jsbridge:1.0.4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="85-richeditor-android"><a href="#85-richeditor-android" class="headerlink" title="85.richeditor-android"></a>85.richeditor-android</h5><blockquote><p>一句话介绍：一款强大的富文本编辑框架</p></blockquote><p>上榜理由：2.8k个star，榜单里第一个为TextView提供扩展能力的框架，你暂时不需要它，但不能不知道它</p><ul><li>github：<a href="https://github.com/wasabeef/richeditor-android" target="_blank" rel="noopener">https://github.com/wasabeef/richeditor-android</a></li><li>作者：Daichi Furiya</li></ul><h5 id="使用：-67"><a href="#使用：-67" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;jp.wasabeef:richeditor-android:1.2.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="86-Transitions-Everywhere"><a href="#86-Transitions-Everywhere" class="headerlink" title="86.Transitions-Everywhere"></a>86.Transitions-Everywhere</h5><blockquote><p>一句话介绍：一款教你正确使用Transitions API（Android 转场动画API）的教学型项目</p></blockquote><p>上榜理由：你可能还未尝试过Android API的Transitions 框架，可能听过，但却无法做出优雅奇妙的动效——别担心，Transitions-Everywhere正如它的名字一样，它将带你全面体验Transitions 的强大之处</p><ul><li>github：<a href="https://github.com/andkulikov/Transitions-Everywhere" target="_blank" rel="noopener">https://github.com/andkulikov/Transitions-Everywhere</a></li><li>作者：Andrey Kulikov</li></ul><h5 id="使用：-68"><a href="#使用：-68" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;com.andkulikov:transitionseverywhere:1.7.4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="87-android-viewbadger"><a href="#87-android-viewbadger" class="headerlink" title="87.android-viewbadger"></a>87.android-viewbadger</h5><blockquote><p>一句话介绍：能够快速的为Android 视图加入“勋章”能力的框架</p></blockquote><p>上榜理由：如果说勋章一词听起来陌生，那么显示已读未读个数、小红点标记信息这一类词语你一定不太陌生，笔者相信在诸位实际开发中经常遇到为某些item加入小红点标记的需求，聪明的各位一定有着各种实现方案，为什么不能快速优雅的完成呢？android-viewbadger可以帮你实现，当然，在某些情况下，你需要具备修改源码的能力，以符合设计MM的需求！值得注意的是，这宽项目已经五年没有更新了！</p><ul><li>github：<a href="https://github.com/jgilfelt/android-viewbadger" target="_blank" rel="noopener">https://github.com/jgilfelt/android-viewbadger</a></li><li>作者：Jeff Gilfelt</li></ul><h5 id="使用：-69"><a href="#使用：-69" class="headerlink" title="使用："></a>使用：</h5><p>clone源码到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">View target = findViewById(R.id.target_view);</span><br><span class="line">BadgeView badge = new BadgeView(this, target);</span><br><span class="line">badge.setText(&quot;1&quot;);</span><br><span class="line">badge.show();</span><br></pre></td></tr></table></figure><h5 id="88-AndroidWiFiADB"><a href="#88-AndroidWiFiADB" class="headerlink" title="88.AndroidWiFiADB"></a>88.AndroidWiFiADB</h5><blockquote><p>一句话介绍：一款不用数据线也可以让你调试手机设备APP的插件项目</p></blockquote><p>上榜理由：你是否还在担心测试过程中高强度的拔插数据线对手机电池和USB端口造成终生难以弥补的损害？别担心，有wifi有AndroidWiFiADB，无须数据线也可以调试应用了，更有趣的是，在测试工程师一边拿着手机一边找你聊bug的时候，你已经偷偷在它的手机上修复了bug，深藏功与名！</p><ul><li>github：<a href="https://github.com/pedrovgs/AndroidWiFiADB" target="_blank" rel="noopener">https://github.com/pedrovgs/AndroidWiFiADB</a></li><li>作者：Pedro Vicente Gómez Sánchez</li></ul><h5 id="使用：-70"><a href="#使用：-70" class="headerlink" title="使用："></a>使用：</h5><blockquote><p>Preferences/Settings-&gt;Plugins-&gt;Browse Repositories-&gt;serch AndroidWiFiADB</p></blockquote><h5 id="89-emojicon"><a href="#89-emojicon" class="headerlink" title="89.emojicon"></a>89.emojicon</h5><blockquote><p>一句话介绍：一款提供在TextView、EdiText展示表情包能力的框架</p></blockquote><p>上榜理由：2.7k个star，,榜单第二款增强TextView显示能力的框架，这款专为表情包设计，如果你曾经好奇微信、QQ的表情显示是如何做到的？这款框架一定能满足你的求知欲。</p><h5 id="90-packer-ng-plugin"><a href="#90-packer-ng-plugin" class="headerlink" title="90.packer-ng-plugin"></a>90.packer-ng-plugin</h5><blockquote><p>一句话介绍：一款打爆工具插件</p></blockquote><p>上榜利用：笔者尽力维护榜单涉及范围的全面性，因此引入此插件项目——项目号称完成100个渠道包只需要10秒钟，在市面上各种各样多渠道打包方案的今天，选择一款适合自己团队的，才是上上选择</p><ul><li>github：<a href="https://github.com/mcxiaoke/packer-ng-plugin" target="_blank" rel="noopener">https://github.com/mcxiaoke/packer-ng-plugin</a></li><li>作者：Xiaoke Zhang</li></ul><h5 id="使用：-71"><a href="#使用：-71" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ......    </span><br><span class="line">    dependencies&#123;    </span><br><span class="line">    // add packer-ng </span><br><span class="line">       classpath &apos;com.mcxiaoke.gradle:packer-ng:1.0.9&apos;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">apply plugin: &apos;packer&apos; </span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.mcxiaoke.gradle:packer-helper:1.0.9&apos;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">android &#123;    //...    signingConfigs &#123;</span><br><span class="line">      release &#123;          </span><br><span class="line">      // 满足下面两个条件时需要此配置          </span><br><span class="line">      // 1. Gradle版本 &gt;= 2.14.1          </span><br><span class="line">      // 2. Android Gradle Plugin 版本 &gt;= 2.2.0          </span><br><span class="line">      // 作用是只使用旧版签名，禁用V2版签名模式        </span><br><span class="line">      v2SigningEnabled false       &#125;    &#125;  &#125;</span><br></pre></td></tr></table></figure><h5 id="91-android-priority-jobqueue"><a href="#91-android-priority-jobqueue" class="headerlink" title="91.android-priority-jobqueue"></a>91.android-priority-jobqueue</h5><blockquote><p>一句话介绍：一款提供后台任务管理能力的框架</p></blockquote><p>上榜理由：如果你是个志在深入研究多线程操作的开发者，这个项目一定不要错过，不论是Activity重新加载、Service使用线程池时的任务优先级和并发问题，都不要担心，Job Manage会照顾优先级，持久性，负载平衡，延迟，网络控制，分组，2.4K个star，优秀的多线程管理能力，况且它依赖的第三方框架很少，值得你一试</p><ul><li>github：<a href="https://github.com/yigit/android-priority-jobqueue" target="_blank" rel="noopener">https://github.com/yigit/android-priority-jobqueue</a></li><li>作者：Yigit Boyar</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android框架排行榜&quot;&gt;&lt;a href=&quot;#Android框架排行榜&quot; class=&quot;headerlink&quot; title=&quot;Android框架排行榜&quot;&gt;&lt;/a&gt;Android框架排行榜&lt;/h4&gt;&lt;h5 id=&quot;1-Retrofit&quot;&gt;&lt;a href=&quot;#1-Retrofit&quot; class=&quot;headerlink&quot; title=&quot;1.Retrofit　　&quot;&gt;&lt;/a&gt;1.Retrofit　　&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官网地址：&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github：&lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/square/retrofit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：square团队&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;使用：&quot;&gt;&lt;a href=&quot;#使用：&quot; class=&quot;headerlink&quot; title=&quot;使用：&quot;&gt;&lt;/a&gt;使用：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.squareup.retrofit2:retrofit:2.3.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h5 id=&quot;2-okhttp&quot;&gt;&lt;a href=&quot;#2-okhttp&quot; class=&quot;headerlink&quot; title=&quot;2.okhttp&quot;&gt;&lt;/a&gt;2.okhttp&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上榜理由，okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官网地址：&lt;a href=&quot;http://square.github.io/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://square.github.io/okhttp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github：&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/square/okhttp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：square团队&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;使用：-1&quot;&gt;&lt;a href=&quot;#使用：-1&quot; class=&quot;headerlink&quot; title=&quot;使用：&quot;&gt;&lt;/a&gt;使用：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.squareup.okhttp3:okhttp:3.9.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/categories/Android/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android面试总结</title>
    <link href="https://zhangmiao.cc/posts/27a6e4df.html"/>
    <id>https://zhangmiao.cc/posts/27a6e4df.html</id>
    <published>2019-07-10T06:29:31.000Z</published>
    <updated>2019-07-22T09:19:05.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试大纲"><a href="#面试大纲" class="headerlink" title="面试大纲"></a>面试大纲</h3><ul><li>java基础、面向对象、集合、线程使用；</li><li>Android 机型适配、SDK适配、内存优化、内存溢出、内存泄漏；</li><li>MVC/MVP/MVVM的使用场景；</li><li>了解并能使用最新流行开源库RXjava+Retrofit+OKHttp、Glide、EventBus等；</li><li>JNI及NDK的使用、熟悉Framework。</li></ul><a id="more"></a><h3 id="频繁面试题"><a href="#频繁面试题" class="headerlink" title="频繁面试题"></a>频繁面试题</h3><ul><li>1.面向对象（OOP） </li><li>2.数据类型 </li><li>3.equal和==的区别 </li><li>4.字符串运行速度：StringBuilder、StringBuffer、 String </li><li>5.Queue 队列、Stack 栈 </li><li>6.ListView机制 </li><li>7.Fragment生命周期</li><li>8.四大引用类型 </li><li>9.线程、进程及其通信方式 </li><li>10.PackageManagerService </li><li>11.binder机制 </li><li>12.launcher的实现 </li><li>13.Android 版本特性 </li><li>14.BroadcastReceiver广播 </li><li>15.RecycleView </li><li>16.各种集合比较SparseArray、HashMap、ArrayMap、LinkedList、ArrayList </li><li>17.SQLite升级 </li><li>18.Bitmap </li><li>19.Handler机制 </li><li>20.性能优化技巧 </li><li>21.ANR </li><li>22.自定义View </li><li>23.MVC、MVP、MVVM三种架构设计 </li><li>24.APP 启动流程 </li><li>25.插件化 </li><li>26.Kotlin 多平台应用的静态编程语言 </li><li>27.Framework 工作原理 </li><li>28.Android 屏幕适配 </li><li>29.事件分发机制 </li><li>30.Android 动画分类：视图，属性，帧，gif </li><li>31.Android 进程 </li><li>32.Android 五大存储方式 </li><li>33.屏幕旋转Activity生命周期</li><li>34.Activity 四大启动模式 </li><li>35.CPU、GPU工作原理 </li><li>36.UI卡顿原因 </li><li>37.Application的生命周期 </li><li>38.如何避免因引入的开源库导致的安全性和稳定性？ </li><li>39.简单的音频/视频格式 </li><li>40.线程同步的方法</li><li>41.线程安全的单例 </li><li>42.Serializable、Parcelelable </li><li>43.Service启动方式和生命周期 </li><li>44.Android 常见布局 </li><li>45.Http、Https、Volley、OkHttp、RxJava + Retrofit + OkHttp、TCP、UDP </li><li>46.如何节省内存使用，主动回收内存？ </li><li>47.Activity如何生成View？ </li><li>48.为什么要使用多线程？ </li><li>49.现场保护 </li><li>50.内存溢出、内存泄漏</li><li>51.JNI和NDK</li><li>52.常用的设计模式及其实现思想和作用</li><li>53.HashMap、 HashTable、HashSet的异同</li><li>54.Android 中内存泄漏原因及优化方案</li><li>55.LeakCanary 内存泄漏检查的开源工具</li><li>56.多线程、线程池</li><li>57.腾讯 Bugly</li><li>58.Glide</li><li>59.Fresco</li><li>60.React</li></ul><h3 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h3><h4 id="1-面向对象（OOP）"><a href="#1-面向对象（OOP）" class="headerlink" title="1.面向对象（OOP）"></a>1.面向对象（OOP）</h4><p>针对业务处理过程的实体及其属性和行为进行抽象封装以获得高效清晰的逻辑单元划分。  </p><p><strong>三大特性：①封装</strong>（隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变量隔离便于使用，提高代码的服用小和安全性）；②<strong>继承</strong>（提高代码的复用性，继承是多态的前提）；③<strong>多态</strong>（父类或接口定义的引用变量可以指向子类或具体实现类的形象，提高了程序的拓展性）。</p><p><strong>五大原则：</strong>单一职责、开放封闭、里氏替换、依赖倒置、接口分离。</p><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p>byte 1个字符，short 、char2 个字符，int 、float 4个字符，long 、double 8个字符。**</p><p><strong>volatile是一个类型修饰符（type specifier）volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。（from百度）</strong></p><p>volatile的变量是说这变量可能会被意想不到地改变，这样，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E7%BC%96%E8%AF%91%E5%99%A8%2F8853067" target="_blank" rel="noopener">编译器</a>就不会去假设这个变量的值了。</p><p>在JDK1.7之前，switch语句仅支持byte、short、char、int，<strong>在JDK1.7之后，枚举、字符串类型都可以，通过String.hashcode转成int进行判断。</strong></p><p><strong>String不可变原因：字符串常量池的需要；运行String对象缓存HashCode，提高效率；多线程安全。</strong></p><p><strong>String 转integer的方法和原理</strong></p><p> <strong>①</strong>Integer.parseInt（String str）调用Integer内部的；</p><p>②Integer.parseInt（String s, int radix）parseInt内部首先判断字符串是否包含符号（-或者+），则对相应的negative和limit进行赋值，然后再循环字符串，对单个char进行数值计算</p><p>③Character.digit(char ch, int radix) 返回指定基数中字符表示的数值。函数肯定进入到0-9字符的判断（相对于string转换到int），否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。</p><p><strong>限定参数类型的上界：参数类型必须是T或T的子类型</strong></p><p><strong>&lt;? super T&gt; 限定参数类型的下界：参数类型必须是T或T的超类型</strong></p><h4 id="3-equal和-的区别：equal-比较对象，-比较原生类型"><a href="#3-equal和-的区别：equal-比较对象，-比较原生类型" class="headerlink" title="3.equal和==的区别：equal 比较对象，==比较原生类型"></a>3.equal和==的区别：equal 比较对象，==比较原生类型</h4><p>equal：存储空间的值是否相同，字符串内容比较，<strong>值是否相同</strong></p><p>==：是否为同一内存空间，内存空间是否相同，引用是否相同</p><p><strong>如果一个类重写了equals()方法，则一定也要重写hashCode()方法</strong>，原因是：虽然equals()方法重写可以保证正确判断两个对象在逻辑是否相同，但是hashCode()方法映射的物理地址是不相同的，依然会将逻辑上相同的两个元素存入集合，但是第二个对象的内容会是Null.</p><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fnesnes%2Fp%2F9863664.html" target="_blank" rel="noopener">关于java中Object类中的equals()和hashCode()方法的使用个人总结 - 张森（ZhangSen） - 博客园</a></p><h4 id="4-字符串运行速度：StringBuilder-gt-StringBuffer-（线程安全）-gt-String-，String为常量，其它为变量，所以运行慢。"><a href="#4-字符串运行速度：StringBuilder-gt-StringBuffer-（线程安全）-gt-String-，String为常量，其它为变量，所以运行慢。" class="headerlink" title="4.字符串运行速度：StringBuilder &gt; StringBuffer （线程安全）&gt; String ，String为常量，其它为变量，所以运行慢。"></a>4.字符串运行速度：StringBuilder &gt; StringBuffer （线程安全）&gt; String ，String为常量，其它为变量，所以运行慢。</h4><h4 id="5-Queue-队列：先进先出，Stack-栈：后进先出。Collect-–-gt-List-Set-Map"><a href="#5-Queue-队列：先进先出，Stack-栈：后进先出。Collect-–-gt-List-Set-Map" class="headerlink" title="5.Queue 队列：先进先出，Stack 栈：后进先出。Collect –&gt;List/Set/Map"></a>5.Queue 队列：先进先出，Stack 栈：后进先出。Collect –&gt;List/Set/Map</h4><h4 id="6-ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter"><a href="#6-ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter" class="headerlink" title="6.ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter"></a>6.ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter</h4><p>BaseAdapter 重写的方法getCount()、getItem()、getItemId()、getView()，<strong>每绘制一次就调用一次getView()</strong>，在getView()中将事先定好的layout布局确定显示的效果并返回一个view对象作为一个item 显示出来，getItem()、getItemId()在调用LIstView响应方法时调用。</p><h4 id="7-Fragment生命周期"><a href="#7-Fragment生命周期" class="headerlink" title="7.Fragment生命周期"></a>7.Fragment生命周期</h4><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_36882793%2Farticle%2Fdetails%2F82151686" target="_blank" rel="noopener">Fragment各种情况的生命周期 - 猫吻鱼的博客 - CSDN博客</a></p><p>onAttach()： 完成Fragment和Activity的绑定，参数中的Activity即为要绑定的Activity，可以进行赋值等操作。</p><p>onCreate() : 完成Fragment的初始化</p><p>onCreateView() : 加载Fragment布局，绑定布局文件</p><p>onActivityCreated() : 表名与Fragment绑定的Activity已经执行完成了onCreate，可以与Activity进行交互操作。</p><p>onStart() : Fragment变为可见状态</p><p>onResume() : Fragment变为可交互状态</p><p>onPause()： Fragment变为不可交互状态(不代表不可见)</p><p>onSaveInstanceState()：保存当前Fragment的状态。记录一些数据，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本。</p><p>onStop(): Fragment变为不可见状态</p><p>onDestroyView() : 销毁Fragment的有关视图，但并未和Activity解绑，可以通过onCreateView()重新创建视图。Fragment销毁时或者ViewPager+Fragment情况下会调用</p><p>onDestroy() : 销毁Fragment时调用</p><p>onDetach() : 解除和Activity的绑定。Fragmen销毁最后一步。</p><h4 id="8-四大引用类型"><a href="#8-四大引用类型" class="headerlink" title="8.四大引用类型"></a>8.四大引用类型</h4><p><strong>强引用</strong>： 是指创建一个对象并把这个对象赋给一个引用变量。 强引用有<strong>引用变量指向时永远不会被垃圾回收</strong>，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</p><p><strong>软引用</strong>（SoftReference）：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。</p><p><strong>弱引用</strong>（WeakReference）：<strong>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象</strong>。在java中，用java.lang.ref.WeakReference类来表示。</p><p><strong>虚引用</strong>（PhantomReference）：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。<strong>如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收</strong>。要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p><h4 id="9-线程是进程的子集，一个进程可有多个线程。"><a href="#9-线程是进程的子集，一个进程可有多个线程。" class="headerlink" title="9.线程是进程的子集，一个进程可有多个线程。"></a>9.线程是进程的子集，一个进程可有多个线程。</h4><p><strong>线程间通讯方式</strong>：①共享变量；②管道；③handler；④runOnUiThread(Runnable)；⑤view.post(Runnable)。</p><p> <strong>进程间通讯方式</strong>：①管道；②FIFO；③消息队列；④信号量；⑤共享内存区；⑥套接字socket信号。</p><p> <strong>Activity间的通信方式</strong>：①Intent；②借助类的静态变量；③借助全局变量/Application；④借助外部工具（SharedPreference、SQLite、File、剪贴板）；⑤借助Service。</p><h4 id="10-PackageManagerService-APP安装有关的service，WindowManagerService-APP调用窗口相关的service，ActivityManagerService-系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。"><a href="#10-PackageManagerService-APP安装有关的service，WindowManagerService-APP调用窗口相关的service，ActivityManagerService-系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。" class="headerlink" title="10.PackageManagerService APP安装有关的service，WindowManagerService APP调用窗口相关的service，ActivityManagerService 系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。"></a>10.PackageManagerService APP安装有关的service，WindowManagerService APP调用窗口相关的service，ActivityManagerService 系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。</h4><p>自定义系统服务：在ServiceManager注册，在Framework/base增加JNI，C++ 文件，在build 配置mk文件，全部编译，才可调用。</p><h4 id="11-binder机制"><a href="#11-binder机制" class="headerlink" title="11.binder机制"></a>11.binder机制</h4><p>Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，<strong>它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁</strong>。</p><h4 id="12-launcher的实现"><a href="#12-launcher的实现" class="headerlink" title="12.launcher的实现"></a>12.launcher的实现</h4><p>Manifest 配置launcher，PackageManager、ActivityManager<strong>对应包的管理和应用进程的管理</strong>。</p><h4 id="13-Android-版本特性"><a href="#13-Android-版本特性" class="headerlink" title="13.Android 版本特性"></a>13.Android 版本特性</h4><p><strong>6.0需要代码请求权限checkPermissions，7.0应用间文件共享限制，系统广播删除，8.0通知渠道、悬浮窗、透明窗口不允许屏幕旋转，9.0明文流量的网络请求（Https加密）</strong></p><p><strong>Android SDK兼容</strong>：<strong>minSdkVersion必须</strong>，targetSdkVersion针对某版本，maxSdkVersion非必需。</p><p>详细特性可见转载文档：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fccw0054%2Farticle%2Fdetails%2F83061841" target="_blank" rel="noopener">Android 各版本新特性介绍 - 落叶Ex的博客 - CSDN博客</a></p><h4 id="14-BroadcastReceiver广播"><a href="#14-BroadcastReceiver广播" class="headerlink" title="14.BroadcastReceiver广播"></a>14.BroadcastReceiver广播</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722160840.png" alt></p><p>BroadcastReceiver比较</p><p>特别注意：<strong>动态广播最好在Activity 的 onResume()注册、onPause()注销。</strong></p><p>原因：对于动态广播，有注册就必然得有注销，否则会导致<strong>内存泄露，</strong>重复注册、重复注销也不允许</p><p>广播的类型主要分为5类：</p><p><strong>普通广播</strong>（Normal Broadcast）：开发者自身定义 intent的广播（最常用），<strong>sendBroadcast(intent);</strong></p><p><strong>系统广播</strong>（System Broadcast）：涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播，每个广播都有特定的Intent - Filter（包括具体的action）</p><p><strong>有序广播</strong>（Ordered Broadcast）：<strong>发送出去的广播被广播接收者按照先后顺序接收，按照Priority属性值从大-小排序；Priority属性相同者，动态注册的广播优先</strong>；</p><p><strong>sendOrderedBroadcast(intent);</strong></p><p>特点</p><p>接收广播按顺序接收</p><p>先接收的广播接收者可以<strong>对广播进行截断</strong>，即后接收的广播接收者不再接收到此广播；</p><p>先接收的广播接收者可以<strong>对广播进行修改</strong>，那么后接收的广播接收者将接收到被修改后的广播</p><p>App应用内广播（Local Broadcast）：<a href="https://www.jianshu.com/p/6f1ea19a17ed" target="_blank" rel="noopener">Android高效安全的本地广播LocalBroadcast完全解析 - 简书</a></p><p>粘性广播（Sticky Broadcast）：由于在Android5.0 &amp; API 21中已经失效，所以不建议使用</p><h4 id="15-RecycleView"><a href="#15-RecycleView" class="headerlink" title="15.RecycleView"></a>15.RecycleView</h4><p>方法：<strong>onCreateViewHolder() 、onBinderViewHolder()、getItemCount()</strong></p><p>三种布局：<strong>垂直or水平、网格、瀑布流</strong></p><p>需要自定义分割线、易于回收、View复用、便于实现添加和删除item动画。</p><h4 id="16-各种集合比较"><a href="#16-各种集合比较" class="headerlink" title="16.各种集合比较"></a>16.各种集合比较</h4><p><strong>SparseArray稀疏数组与HashMap相比</strong>，正序插入快，逆序插入慢，查找慢占用内存少于HashMap；</p><p><strong>HashMap和ArrayMap的区别</strong></p><p>①查找效率   HashMap依据HashCode查找，效率增加；ArrayMap使用二分法查找，效率下降。数量大时用HashMap</p><p>②扩展数量   HashMap初始值16个长度，每次扩容申请双倍的数组空间；A扩容申请空间更少</p><p>③扩容效率  ArrayMap更好</p><p>④内存消耗  数据量小时，ArrayMap更节省内存</p><p>总结：数据量小时，并需要频繁使用map存储时，用ArrayMap，数据量大时，用HashMap。</p><p><strong>HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p><p>HashMap 的实例有两个参数影响其性能：初始容量和加载因子。容量是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">哈希表</a>中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。在Java编程语言中，加载因子默认值为0.75，默认哈希表元为101</p><p>hashMap的默认加载因子为0.75，<strong>加载因子</strong>表示Hsah表中元素的填满的程度。加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。冲突的机会越大,则查找的成本越高。反之,查找的成本越小。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p><p>参考文章：<a href="https://www.jianshu.com/p/dff8f4641814" target="_blank" rel="noopener">为什么java Hashmap 中的加载因子是默认为0.75 - 简书</a></p><p><strong>LinkedList 链表结构</strong>，查找慢，插入快；</p><p><strong>ArrayList 数组结构</strong>，查找快，插入慢。</p><h4 id="17-SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade-方法中判断oldVersion对数据库进行增删改查以实现数据库升级。"><a href="#17-SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade-方法中判断oldVersion对数据库进行增删改查以实现数据库升级。" class="headerlink" title="17.SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade()方法中判断oldVersion对数据库进行增删改查以实现数据库升级。"></a>17.SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade()方法中判断oldVersion对数据库进行增删改查以实现数据库升级。</h4><h4 id="18-Bitmap"><a href="#18-Bitmap" class="headerlink" title="18.Bitmap"></a>18.Bitmap</h4><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fwinter-is-coming%2Fp%2F9112192.html" target="_blank" rel="noopener">Android Bitmap详解 - 小爷宋 - 博客园</a></p><p>位图包括图片的像素、长宽、颜色等描述，可通过这些信息计算出图像占用内存的大小。作为花架，可对图片做一些处理，位图文件显示效果好，但是非压缩格式，需要占用较大存储空间。</p><p>①<strong>Config：表示图片像素类型</strong></p><p>②三种压缩格式：<strong>Bitmap.CompressFormat.JPEG、Bitmap.CompressFormat.PNG、Bitmap.CompressFormat.WEBP</strong></p><p><strong>③</strong>BitmapFactory提供了四类加载方法：<strong>decodeFile、decodeResource、decodeStream、decodeByteArray。巨图加载：BitmapRegionDecoder，可以按照区域进行加载。高效加载：核心其实也很简单，主要是采样压缩、缓存策略、异步加载等</strong></p><p>④<strong>内存优化</strong>：缓存LRU、缩放、Config、Compress选择、内存管理、缓存方式等等方面入手。、内存管理、内存优化、缩放、config、compress</p><p>开源框架：ImageLoader、Glide（google）、Fresco（FaceBook）、Picasso（Square）</p><p><strong>图片优化：异步加载，压缩处理bitmapFactory.options，设置内存大小，缓存于内存、SD卡，没有内存再从网络取</strong>。</p><p><strong>Picasso包体积小、清晰，但功能有局限不能加载gif、只能缓存全尺寸；</strong></p><p><strong>Glide功能全面，擅长大型图片流，体积较大；</strong></p><p><strong>Fresco内存优化，减少oom，体积更大。</strong></p><p><strong>如何处理大图：BitmapFactory.Options，把inJustDecodeBounds这个属性设为true，计算inSampleSize。参考文章：官方推荐方法，如何有效率的加载大图Bitmap - 月毛毛的专栏 - CSDN博客</strong></p><h4 id="19-Handler机制"><a href="#19-Handler机制" class="headerlink" title="19.Handler机制"></a>19.Handler机制</h4><p><strong>主线程不能进行耗时操作，子线程不能更新UI，Handler实现线程间通信，将要发送的消息保存到Message中，Handler调用sendMessage()方法将message发送到MessageQueue，Looper对象不断调用loop()方法，不断从MessageQueue中取出message交给handler处理，从而实现线程间的通信。</strong></p><p>主线程handler不需要调用Looper.prepare()，Looper.loop()，通过sendMessage将message添加到messagequeue。</p><p>子线程可以new Handler。</p><p><strong>总结：当创建Handler时将通过ThreadLocal在当前线程绑定一个Looper对象，而Looper持有MessageQueue对象。执行Handler.sendMessage(Message)方法将一个待处理的Message插入到MessageQueue中，这时候通过Looper.loop()方法获取到队列中Message，然后再交由Handler.handleMessage(Message)来处理。</strong></p><h4 id="20-性能优化技巧"><a href="#20-性能优化技巧" class="headerlink" title="20.性能优化技巧"></a>20.性能优化技巧</h4><p>启动速度优化，布局优化，内存、电量、APP大小优化、列表滑动优化等等。</p><p>性能优化工具：TraceView、Hierarchy Viewer。</p><h4 id="21-ANR（Application-Not-Responding）"><a href="#21-ANR（Application-Not-Responding）" class="headerlink" title="21.ANR（Application Not Responding）"></a>21.ANR（Application Not Responding）</h4><p>扩展文链接：<a href="https://www.jianshu.com/p/54f945a15acb" target="_blank" rel="noopener">深入理解ANR - 简书</a></p><p>Android应用程序有一段时间响应不够灵敏，系统会向用户显示应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现ANR，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。<strong>默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</strong></p><p>原因：<strong>主线程做耗时操作；主线程被其他线程锁；CPU被其他进程占用，该进程没有分配CPU资源；OnReceiver过多操作，IO操作，如数据库、文件、网络</strong>。</p><h4 id="22-自定义View"><a href="#22-自定义View" class="headerlink" title="22.自定义View"></a>22.自定义View</h4><p>扩展文链接：<a href="https://www.jianshu.com/p/705a6cb6bfee" target="_blank" rel="noopener">Android自定义View全解 - 简书</a></p><p>自定义组合控件  多个控件组合成为一个新的控件，方便多处复用</p><p>继承系统View控件  继承自TextView等系统控件，在系统控件的基础功能上进行扩展</p><p>继承View  不复用系统控件逻辑，继承View进行功能定义</p><p>继承系统ViewGroup  继承自LinearLayout等系统控件，在系统控件的基础功能上进行扩展</p><p>继承ViewViewGroup  不复用系统控件逻辑，继承ViewGroup进行功能定义</p><p> <strong>View绘制流程基本由measure()、layout()、draw()这个三个函数完成</strong></p><p>函数作用相关方法</p><p><strong>measure()测量View的宽高measure(),setMeasuredDimension(),onMeasure()</strong></p><p><strong>layout()计算当前View以及子View的位置layout(),onLayout(),setFrame()</strong></p><p><strong>draw()视图的绘制工作draw(),onDraw()</strong></p><p><strong>自定义View的注意事项   参考文章：Android自定义View注意事项 - 简书</strong></p><p><strong>①需要在onMeasure方法中处理wrap_content的方法，让View支持wrap_content；</strong></p><p><strong>②避免padding和子元素的margin失效，让View支持padding；</strong></p><p><strong>③尽量不要在View中使用Handler，View中已提供了post系列方法，可替代Handler作用；</strong></p><p><strong>④避免造成内存泄漏，View中如果有线程或者动画，需要及时停止。</strong></p><h4 id="23-MVC、MVP、MVVM三种架构设计"><a href="#23-MVC、MVP、MVVM三种架构设计" class="headerlink" title="23.MVC、MVP、MVVM三种架构设计"></a>23.MVC、MVP、MVVM三种架构设计</h4><p>扩展文链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Flihaoxiang123%2Farticle%2Fdetails%2F78977181" target="_blank" rel="noopener">Android高精战争（MVC、MVP、MVVM） - lihaoxiang123的博客 - CSDN博客</a></p><p>MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p>其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。</p><p>MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。</p><p>MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）：</p><p>View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity)</p><p>Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合)</p><p>Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</p><p>View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试</p><p>MVC 与MVP的区别</p><p>（最主要区别）<strong>View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互</strong></p><p><strong>通常View与Presenter是一对一的</strong>，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View</p><p><strong>Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。</strong></p><p>在MVP中，Activity的代码不臃肿；</p><p>在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会；</p><p>在MVP中，IUserView这个接口可以实现方便地对Presenter的测试；</p><p>在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。</p><p>MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。</p><h4 id="24-APP-启动流程"><a href="#24-APP-启动流程" class="headerlink" title="24.APP 启动流程"></a>24.APP 启动流程</h4><p>点击桌面图标，launcher进程启动主Activity以Binder方式发送给AMS服务，交付给ActivityManagerService处理Intent和flag信息，通过prepareMainLooper()方法loop处理消息</p><h4 id="25-插件化"><a href="#25-插件化" class="headerlink" title="25.插件化"></a>25.插件化</h4><p><strong>解除代码耦合，插件支持热插拔，静默升级，从根本上解决65k属性和方法的bug，进行自定义classLoader。</strong></p><p>插件化和热修复都是动态加载技术，使用场景不同，<strong>热修复为解决线上问题或者小功能更新，插件化解决应用上的大问题。</strong></p><p><strong>组件化：为了解耦，把复杂系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</strong></p><p>26.Kotlin 是一个用于现代<strong>多平台应用的静态编程语言</strong>，由 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FJetBrains" target="_blank" rel="noopener">JetBrains</a> 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。</p><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 <strong>flutter。</strong></p><h4 id="27-Framework-工作原理"><a href="#27-Framework-工作原理" class="headerlink" title="27.Framework 工作原理"></a>27.Framework 工作原理</h4><p><strong>Android 系统对Linux、kernel、lib库等封装，提供WMS、AMS、binder机制，handler-message机制等方式，供APP使用。Framework 就是提供APP生存环境。</strong></p><h4 id="28-Android-屏幕适配"><a href="#28-Android-屏幕适配" class="headerlink" title="28.Android 屏幕适配"></a>28.Android 屏幕适配</h4><p>各种dp文件，使用各种尺寸屏幕</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722160920.png" alt></p><p><strong>布局文件中view设置高宽时不限定大小，尽量使用wrap_content，match_parent；代码中设置高宽前可获取屏幕大小，如果是线性布局可设置view在LinearLayout的weight；单位dp适配屏幕，单位sp适用字体，多图片，多布局。</strong></p><h4 id="29-事件分发机制"><a href="#29-事件分发机制" class="headerlink" title="29.事件分发机制"></a>29.事件分发机制</h4><p>dispatchTouchEvent() 负责事件分发。当点击事件产生后，事件首先传递给当前Activity，调用Activity的dispatchTouchEvent()方法，返回值为true则表示View或子View消费了此事件，如果返回true，则表示没有消费事件，并调用父View的onTouchEvent方法。</p><p>onTouchEvent()用于处理事件，返回值决定当前控件是否消费了这个事件，也就是说在当前控件在<strong>调用父View的onTouchEvent方法</strong>完Touch事件后，是否还允许Touch事件继续向上（父控件）传递，一但返回True，则父控件不用操心自己来处理Touch事件。返回true，则向上传递给父控件。</p><p>onInterceptTouchEvent() ViewGroup的一个方法，用于处理事件（类似于预处理，当然也可以不处理）并改变事件的传递方向，也就是决定是否允许Touch事件继续向下（子控件）传递，一但返回True（代表事件在当前的viewGroup中会被处理），则向下传递之路被截断（所有子控件将没有机会参与Touch事件），同时把事件传递给当前的控件的onTouchEvent()处理；返回false，则把事件交给子控件的onInterceptTouchEvent()。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722160945.png" alt></p><p>事件分发机制原理图</p><p>当一个Touch事件(触摸事件为例)到达根节点，即Acitivty的ViewGroup时，它会依次下发，下发的过程是调用子View(ViewGroup)的dispatchTouchEvent方法实现的。简单来说，就是ViewGroup遍历它包含着的子View，调用每个View的dispatchTouchEvent方法，而当子View为ViewGroup时，又会通过调用ViwGroup的dispatchTouchEvent方法继续调用其内部的View的dispatchTouchEvent方法。上述例子中的消息下发顺序是这样的：①-②-⑤-⑥-⑦-③-④。dispatchTouchEvent方法只负责事件的分发，它拥有boolean类型的返回值，当返回为true时，顺序下发会中断。</p><p>小结：onInterceptTouchEvent()默认返回false，不做截获。返回true之后，事件流的后端控件就没有机会处理touch事件。view的onTouchEvent()返回了false，那么该事件将被传递至其上一层次的view的onTouchEvent()处理，如果onTouchEvent()返回了true，那么后续事件将可以继续传递给该view的onTouchEvent()处理。</p><h4 id="30-Android-动画分类：视图，属性，帧，gif。"><a href="#30-Android-动画分类：视图，属性，帧，gif。" class="headerlink" title="30.Android 动画分类：视图，属性，帧，gif。"></a>30.Android 动画分类：视图，属性，帧，gif。</h4><h4 id="31-Android-进程"><a href="#31-Android-进程" class="headerlink" title="31.Android 进程"></a>31.Android 进程</h4><p>一般大体分为<strong>前台进程，后台进程，可见进程，服务进程，空进程</strong>这五大进程。其中<strong>空进程优先级最低</strong>，调用startService()让service所在进程成为前台进程，service的onDestory()里重新启动自己可避免后台进程被杀死。</p><p><strong>一个应用允许多个进程</strong>，在清单文件配置的service为一个进程，Android:process就可以配置；</p><p><strong>多进程会引起的异常</strong>：静态成员和单例模式会失效，线程同步机制完全失效，SharedPreferences可靠性下降，Application会多次创建。</p><h4 id="32-Android-五大存储方式"><a href="#32-Android-五大存储方式" class="headerlink" title="32.Android 五大存储方式"></a>32.Android 五大存储方式</h4><p>使用SharedPreferences存储数据； 文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据。</p><p>当APP没有获取文件存储权限时，当需要存储大文件时，可以保存在APP-data-cache目录里。</p><p><strong>ContentProvider</strong>：抽象类，为不同应用数据提供数据共享，提供统一接口，<strong>通过uri标识要访问的数据。</strong></p><h4 id="33-屏幕旋转Activity生命周期"><a href="#33-屏幕旋转Activity生命周期" class="headerlink" title="33.屏幕旋转Activity生命周期"></a>33.屏幕旋转Activity生命周期</h4><p>参考文章链接：<a href="https://www.jianshu.com/p/8c40829905ec" target="_blank" rel="noopener">Activity横竖屏切换生命周期变化 - 简书</a></p><p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行1次，切竖屏时会执行1次</p><p>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p><p>3、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><p>4、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏切记要加上screenSize,否则4.0版本以上生命周期不生效</p><h4 id="34-Activity-四大启动模式"><a href="#34-Activity-四大启动模式" class="headerlink" title="34.Activity 四大启动模式"></a>34.Activity 四大启动模式</h4><p><strong>standard 启动模式</strong></p><p> Activity 默认的启动模式，每次 startActivity 都会在栈顶创建一个新的实例，在同一个任务中可以存在多个Activity 的实例。</p><p><strong>singleTop 启动模式</strong></p><p><strong>栈顶复用</strong>，也就是说，要启动 singleTop 模式的 Activity，如果它恰好在当前栈顶，那么直接复用，执行其 onNewIntent 方法。否则，就重新创建一个实例入栈。</p><p>singleTask 启动模式</p><p>在系统中<strong>只有一个实例</strong>，当再次启动该 Activity 时，会重用已存在的任务和实例，并且会调用这个实例的 onNewIntent()方法，将 Intent 实例传递到该实例中。</p><p>singleInstance 启动模式</p><p><strong>总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他 Activity 会自动运行于另一个任务中。</strong>当再次启动该 Activity 的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将 Intent 实例传递到该实例中。</p><p>总结：<strong>①standard每一次都会创建新的实例；②singleTop栈顶复用。和standard相似，但是如果栈顶已有实例，复用该实例，回调onNewIntent()方法；③singleTask栈内复用。查找栈内有没有该实例，有则复用回调onNewIntent()方法，如果没有，新建Activity，并入栈；④singleInstance单例模式，全局唯一。具备singleTask所有特性，独占一个任务栈。</strong></p><h4 id="35-CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。"><a href="#35-CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。" class="headerlink" title="35.CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。"></a><strong>35.CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。</strong></h4><h4 id="36-UI卡顿原因"><a href="#36-UI卡顿原因" class="headerlink" title="36.UI卡顿原因"></a>36.UI卡顿原因</h4><p>每16ms绘制一次Activity，如果由于一些原因导致了我们的逻辑、CPU耗时、GPU耗时大于16ms(<strong>应用卡顿的根源就在于16ms内不能完成绘制渲染合成过程,16ms需要完成视图树的所有测量、布局、绘制渲染及合成</strong>)，UI就无法完成一次绘制，那么就会造成卡顿。<strong>①内存抖动问题，②方法耗时，③view本身卡顿。</strong></p><p><strong>解决办法：修改方法，使其不耗时，放到子线程中，如网络访问，大文件操作等，防止ANR，避免GPU过度绘制。</strong></p><h4 id="37-Application的生命周期"><a href="#37-Application的生命周期" class="headerlink" title="37.Application的生命周期"></a><strong>37.Application的生命周期</strong></h4><p><strong>参考文章：Android中Application的用途及生命周期_YY小爬虫_新浪博客</strong></p><p>①onCreate0 在创建应用程序时创建；</p><p>②onTerminate()  在模拟环境下执行。当终止应用程序对象时调用，不保证一定被调用，当程序是被内核终止以便为其他应用程序释放资源，那么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程；</p><p>③onLowMemory() 低内存时执行。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况；</p><p>④onConfigurationChanged(Configuration newConfig) 配置改变时触发这个方法。</p><p>⑤onTrimMemory(int level) 程序在进行内存清理时执行。</p><h4 id="38-如何避免因引入的开源库导致的安全性和稳定性？"><a href="#38-如何避免因引入的开源库导致的安全性和稳定性？" class="headerlink" title="38.如何避免因引入的开源库导致的安全性和稳定性？"></a>38.如何避免因引入的开源库导致的安全性和稳定性？</h4><p>由于项目引入了太多第三方开源库，Android APP有65536方法数的问题，可使用multidex解决。<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fplugins.jetbrains.com%2Fplugin%2F8076%3Fpr%3Dandroidstudio" target="_blank" rel="noopener">Android Methods Count</a>插件可以高效统计Android开源库的方法数。</p><h4 id="39-简单的音频-视频格式"><a href="#39-简单的音频-视频格式" class="headerlink" title="39.简单的音频/视频格式"></a><strong>39.简单的音频/视频格式</strong></h4><p><strong>PCM</strong>：<strong>脉冲编码调制</strong>，由二进制数字信号对光源进行通断调制产生，没有压缩的编码方式。</p><p><strong>WAV</strong>：<strong>无损音频文件格式</strong>，PCM是无损WAV文件中音频数据的一种编码方式，但是WAV还可以用其它编码。</p><p><strong>AVI</strong>：音视频交错，调用方便，图像质量好，压缩标准可选。</p><p><strong>WMV</strong>：可扩充的媒体类型，本地或网络回放，流优先级化。</p><p><strong>3GP</strong>：3G流媒体，配合3G网络高速传输而开发。</p><p><strong>FLV</strong>：文件小，加载速度快，用于网络观看视频。</p><p><strong>MP4</strong>：音视频压缩编码标准。</p><h4 id="40-线程同步的方法"><a href="#40-线程同步的方法" class="headerlink" title="40.线程同步的方法"></a>40.线程同步的方法</h4><p>转载文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fxiaoxi%2Fp%2F7679470.html" target="_blank" rel="noopener">多线程同步的五种方法 - 平凡希 - 博客园</a></p><p><strong>①synchronized</strong>  即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态；</p><p><strong>②同步代码块</strong>  即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步；</p><p><strong>③使用特殊变量Volatile</strong> </p><p>（1）volatile关键字为域变量的访问提供了一种免锁机制；</p><p>（2）使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；</p><p>（3）因此每次使用该域就要重新计算，而不是使用寄存器中的值；</p><p>（4）volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p><p>④<strong>使用重入锁</strong></p><p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力；</p><p><strong>⑤使用局部变量；</strong></p><p><strong>⑥使用阻塞队列。</strong></p><p><strong>线程sleep()和wait()的区别</strong></p><p><strong>sleep()不释放同步锁，自动唤醒，需要try-catch，线程方法。</strong></p><p><strong>wait()释放同步锁，需要notify唤醒，是object方法。</strong></p><p><strong><em>线程的生命周期？如何中断？</em></strong></p><p>生命周期：文章转载：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fwzy330782%2Fp%2F5456923.html" target="_blank" rel="noopener">多线程——线程的生命周期 - 积_跬步 - 博客园</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161023.png" alt></p><p><strong>① 新建状态(New Thread)</strong>：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。</p><p>线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。</p><p><strong>② 就绪状态(Runnable)</strong>：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。</p><p><strong>③ 运行状态(Running)</strong>：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。</p><p>a) 可以通过Thread类的isAlive方法来判断线程是否处于就绪/运行状态：当线程处于就绪/运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。</p><p><strong>④ 阻塞和唤醒线程</strong></p><p>阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括：</p><p>​              a)当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。</p><p>​              b)当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。</p><p>​              c)当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()/notify()方法的执行要求线程首先获得该对象的锁。</p><p><strong>⑤ 死亡状态(Dead)</strong>：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。</p><p><strong>终止线程的三种方法</strong></p><p>① 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。</p><p>② 使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。</p><p>③ 使用interrupt方法中断线程。</p><h4 id="41-线程安全的单例"><a href="#41-线程安全的单例" class="headerlink" title="41.线程安全的单例"></a>41.线程安全的单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">(SingleInstance instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="42-Serializable-序列化接口，开销大，建议使用，java方法；"><a href="#42-Serializable-序列化接口，开销大，建议使用，java方法；" class="headerlink" title="42.Serializable 序列化接口，开销大，建议使用，java方法；"></a>42.Serializable 序列化接口，开销大，建议使用，java方法；</h4><p> Parcelelable 使用麻烦，效率高，多用于内存，Android方法。</p><h4 id="43-Service启动方式和生命周期"><a href="#43-Service启动方式和生命周期" class="headerlink" title="43.Service启动方式和生命周期"></a>43.Service启动方式和生命周期</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161217.png" alt></p><p>①startService()：开启，调用者退出后Service仍在；<br> 生命周期：onCreate()–onStartCommand()–onDestory()<br> 通过startService启动后，service会一直无限期运行下去，只有外部调用了stopService()或stopSelf()方法时，该Service才会停止运行并销毁。<br> ②bindService()：开启，调用者退出后Service随即退出。<br> 生命周期：onCreate()–onBind()–onUnBind()–onDestory()<br> ①+② 的生命周期：onCreate()–onStartCommand()–onBind()–onUnBind()–onDestory()</p><h4 id="44-Android-常见布局"><a href="#44-Android-常见布局" class="headerlink" title="44.Android 常见布局"></a>44.Android 常见布局</h4><p> FrameLayout （框架布局）、LinearLayout（线性布局）、AbsoluteLayout（绝对布局）、RelativeLayout（相对布局）、TableLayout（表格布局）</p><h4 id="45-Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。"><a href="#45-Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。" class="headerlink" title="45.Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。"></a>45.Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。</h4><p> ①HttpClient：开源框架，无封装，原始，使用方便，开发快，实现比较稳定，Android废弃，Android 6.0删除；<br> ②HttpUrlConnection：对网络请求没有HttpClient封装彻底，Android2.2之前存在bug，所以2.2之前用HttpClient，之后用容易优化的HttpUrlConnection，开源框架，封装了请求头、参数、内容体、响应在I/O流，接口中统一封成了HttpGet/HttpPost，减少了操作的繁琐性，访问速度快。</p><p>Https是以安全为目标的Http通道，简单讲就是Http的安全版，即Http下加入SSL层，安全基础是SSL，加密的详细内容是SSL，作用：建立一个信息安全通道，来保证数据传输的安全、确认网站的安全性。</p><p>Volley：适合处理数据量小，通信频繁的网络操作，内部封装了异步操作，可直接在线程执行并处理结果，同时可以取消，容易扩展，但是不适合大数据请求，比如下载表现糟糕，不支持https，android2.2及以下用HttpClient，android2.3及以上用HttpUrlConnection。</p><p>OkHttp：专注于提升网络连接效率的Http客户端，能够实现IP和端口的请求重用一个socket，大大降低了连接时间，也降低了服务器的压力，对Http和https都有良好的支持，不用担心app版本更换的困扰，但是okHttp请求是在线程里执行，不能直接刷新UI，需要手动处理。</p><p>总结：在项目实际运用中，视情况选择网络请求方式，也可以Volley+OkHttp搭配使用。异步回调用Volley，网络请求底层用OkHttp</p><p>RxJava + Retrofit3 + OkHttp3<br> ①RxJava 主要用来实现线程切换，我们制定订阅在哪一个线程，观察在哪个线程，通过操作符进行数据变换，整个过程是键式的，简化逻辑。<br> ②Retrofit 是网络请求的一个架子，用它设置一些参数和请求Url。<br> ③OkHttp是网络请求的内核，实际的网络请求是它发出来的。</p><p>TCP 是网络层，滑动窗口协议，拥塞控制，可靠连接借助socket长连接，需要3次握手，第四次取消连接，画面优先。<br> UDP：不关心数据是否到达，是否阻塞，不可靠连接，流畅优先。</p><h4 id="46-如何节省内存使用，主动回收内存？"><a href="#46-如何节省内存使用，主动回收内存？" class="headerlink" title="46.如何节省内存使用，主动回收内存？"></a>46.如何节省内存使用，主动回收内存？</h4><p> 答：尽量多使用内部类，提高程序效率，回收已使用的资源，合理使用缓存，合理设置变量的作用范围。</p><h4 id="47-Activity如何生成View？"><a href="#47-Activity如何生成View？" class="headerlink" title="47.Activity如何生成View？"></a>47.Activity如何生成View？</h4><p> 答：Activity执行在attch()方法的时候，会创建一个PhoneWindow（Window的子类），在onCreate()方法的setContentView()方法中，创建DecorView，DecorView的addView()方法，把layout布局加载出来。通过onDraw()画出来，画View之前调用onMeasure()方法计算显示的大小。</p><h4 id="48-为什么要使用多线程？"><a href="#48-为什么要使用多线程？" class="headerlink" title="48.为什么要使用多线程？"></a>48.为什么要使用多线程？</h4><p> ①更好地利用CPU资源；②进程间数据不能数据共享，线程可以；③系统创建进程需要为该进程重新分配系统资源，创建线程代价较小；④Java语言内置了多线程功能支持，简化了java多线程编程。</p><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，在创建线程后自动启动这些任务，线程池线程是后台线程，每个线程都使用默认的堆栈大小，以优先级执行。</p><h4 id="49-现场保护"><a href="#49-现场保护" class="headerlink" title="49.现场保护"></a>49.现场保护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：①进程被异常杀死；②系统配置发生变化（比如横竖屏切花换）。<br> 当Activity处于onPause() ，onStop() ，onDestroy() 三种状态时程序可能会被Android系统回收掉，这时可能会造成用户在程序当中的数据或者修改丢失。于是我们需要”现场保护”，当下次重启程序或activity时恢复上一次的数据。<br> 因此Android提供了onSaveInstanceState(Bundlout State)方法会在程序被回收前进行调用，但需要注意的是onSaveInstanceState()方法只适合保存瞬态数据, 比如UI控件的状态, 成员变量的值等，而不应该用来保存持久化数据。onRestoreInstanceState方法，需要注意的是onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p><h4 id="50-内存溢出，内存泄漏"><a href="#50-内存溢出，内存泄漏" class="headerlink" title="50.内存溢出，内存泄漏"></a>50.内存溢出，内存泄漏</h4><p> 内存溢出（OOM）：程序在申请内存时，没有足够的内存空间使用。<br> 原因：加载对象过大，相对资源较多，来不及加载。<br> 解决办法：内存引用上做处理，比如用软引用；图片加载时处理（压缩等）；动态回收内存；优化内存分配，自定义堆内存大小，避免使用Enum，减少BitMap的内存占用，内存对象重复使用，避免对象的内存泄漏。<br> 内存泄漏（memory leak）： 程序在申请内存后，无法释放已申请的内存空间，一次泄漏危害可忽略，但推积严重最终会导致OOM；</p><p>handler泄露：消息引用了handler对象，该对象又隐性地持有了Activity对象，当发生GC时以为message-handler-activity的引用链导致Activity无法被回收，即发生泄漏，简单来说就是handler对activity强引用导致的GC，无法及时回收Activity。（PS：GC垃圾回收，当堆内存里的对象没有引用指向时，GC回收。）</p><p>解决办法：方法一：通过程序逻辑来进行保护。</p><p>1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。</p><p>2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。</p><p>方法二：将Handler声明为静态类。</p><p>PS:在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。</p><p>静态类不持有外部类的对象，所以你的Activity可以随意被回收。由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）。<br> WebView泄漏：创建的对象没有在合适的时间销毁，则一直存在内存里耗费内存空间，WebView不建议在xml文件中指明，因为一直存在不能对其销毁，应该在代码中创建WebView，通过addView()的方式加入layout，在Activity 的onDestory()方法中需要销毁，先将加载的内容置为null，webView.destroy();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">WebView mWebView = <span class="keyword">new</span> WebView(getApplicationContext());</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( mWebView!=<span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           ViewParent parent = mWebView.getParent();</span><br><span class="line">           <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ((ViewGroup) parent).removeView(mWebView);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mWebView.stopLoading();</span><br><span class="line">           <span class="comment">// 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错</span></span><br><span class="line">           mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">false</span>);</span><br><span class="line">           mWebView.clearHistory();</span><br><span class="line">           mWebView.clearView();</span><br><span class="line">           mWebView.removeAllViews();</span><br><span class="line">           mWebView.destroy();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="51-JNI和NDK"><a href="#51-JNI和NDK" class="headerlink" title="51.JNI和NDK"></a>51.JNI和NDK</h4><p>​     <strong>JNI是Java调用Native 语言的一种特性，属于Java，Java本地接口，使Java与本地其他类型语言交互（C++）</strong></p><p>​       实现步骤：<strong>在Java中声明Native方法，编译该文件得到.class文件，通过javah命令导出JNI头文件（.h文件），使用Java需要交互的本地代码实现子啊Java中声明的Native方法，编译so文件，通过Java执行Java程序，最终实现Java调用本地代码</strong></p><hr><p>​     <strong>NDK（Native Develop Kit）：Android开发工具包，属于Android。</strong></p><p>​     作用：快速开发C、C++动态库，并自动将so文件和应用打包成APK，即可通过NDK在Android中使用JNI与本地代码（C、C++）交互（Android开发需要本地代码C、C++实现）</p><p>​      特点：运行效率高，代码安全性高，功能拓展性好，易于代码复用和移植。</p><p>​      使用步骤：<strong>①配置NDK环境；②创建Android项目，并于NDK进行关联；③在Android项目中声明所需调用的Native方法；④使用该Native方法；⑤通过NDK build命令编译产生so文件；⑥编译AS工程，实现调用本地代码。</strong></p><p>​    <strong>JNI和NDK的关系：JNI实现目的，NDK是Android实现JNI的手段，即在AS开发环境中通过NDK从而实现JNI功能。</strong></p><h4 id="52-常用的设计模式及其实现思想和作用"><a href="#52-常用的设计模式及其实现思想和作用" class="headerlink" title="52.常用的设计模式及其实现思想和作用"></a><strong>52.常用的设计模式及其实现思想和作用</strong></h4><p><strong>转载文章：23种设计模式全解析 - codeTao - 博客园</strong></p><p><strong>①单例模式：</strong>单例对象能保证在一个JVM中，该对象只有一个实例存在。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161310.png" alt></p><p><strong>②工厂模式</strong></p><p>一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。</p><p>抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 </p><p><strong>③适配器模式</strong></p><p>将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p><p><strong>④装饰模式（Decorator）</strong></p><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161327.png" alt></p><p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能。</p><p>装饰器模式的应用场景：</p><p>1、需要扩展一个类的功能。</p><p>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</p><p>缺点：产生过多相似的对象，不易排错！</p><p><strong>⑤代理模式（Proxy）</strong>：多一个代理类出来，替原对象进行一些操作。</p><p><strong>⑥桥接模式（Bridge）</strong>：桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：<strong>将抽象化与实现化解耦，使得二者可以独立变化。</strong></p><p><strong>⑦观察者模式</strong>：一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p><p><strong>⑧访问者模式</strong>：一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。</p><h4 id="53-HashMap、-HashTable、HashSet的异同"><a href="#53-HashMap、-HashTable、HashSet的异同" class="headerlink" title="53.HashMap、 HashTable、HashSet的异同"></a>53.HashMap、 HashTable、HashSet的异同</h4><p>转载文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fywl925%2Fp%2F3865269.html" target="_blank" rel="noopener">HashSet HashTable HashMap的区别 及其Java集合介绍 - ywl925 - 博客园</a></p><p>①HashSet是Set的一个实现类，HashMap是Map的一个实现类，同时HashMap是HashTable的替代品</p><p>②HashSet以对象作为元素，而HashMap以(key-value)的一组对象作为元素，且HashSet拒绝接受重复的对象。HashMap可以看作三个视图：key的Set，value的Collection，Entry的Set。 这里HashSet就是其实就是HashMap的一个视图。</p><p>HashSet内部就是使用HashMap实现的，和HashMap不同的是它不需要Key和Value两个值。</p><p>HashMap是一个数组和链表的结合体，新加入的放在链头，重复的key不同的alue被新value替代</p><p>③继承不同</p><p>public class Hashtable extends Dictionary&lt;&gt; implements Map&lt;&gt;</p><p>public class HashMap  extends AbstractMap&lt;&gt; implements Map&lt;&gt;</p><p>④HashTable 方法同步，而HashMap需要自己增加同步处理。</p><p>⑤HashTable中，key和value都不允许出现null值。</p><p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。用containsKey()方法来判断是否存在某个键。</p><p>⑥两个遍历方式的内部实现上不同。</p><p>HashTable、HashMap都使用了 Iterator。而由于历史原因，HashTable还使用了Enumeration的方式 。</p><p>⑦哈希值的使用不同</p><p>HashTable直接使用对象的hashCode，HashTable中hash数组默认大小是11，增加的方式是 old*2+1。</p><p>而HashMap重新计算hash值，HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><p>如何实现HashMap线程同步？</p><p>①使用 java.util.Hashtable 类，此类是线程安全的。</p><p>②使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。</p><p>③使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。</p><h4 id="54-Android-中内存泄漏原因及优化方案？"><a href="#54-Android-中内存泄漏原因及优化方案？" class="headerlink" title="54.Android 中内存泄漏原因及优化方案？"></a>54.Android 中内存泄漏原因及优化方案？</h4><p>文章转载：<a href="https://www.jianshu.com/p/abee7c186bfa" target="_blank" rel="noopener">Android 中内存泄漏的原因和解决方案 - 简书</a></p><p>①<strong>非静态内部类造成的内存泄漏</strong>  非静态类会持有外部类的引用，如果这个内部类比外部类的生命周期长，在外部类被销毁时，内部类无法回收，即造成内存泄漏；</p><p><strong>②外部类中持有非静态内部类的静态对象</strong>  保持一致的生命周期，将内部类对象改成非静态；</p><p>③<strong>Handler 或 Runnable 作为非静态内部类</strong>  Handler 和 Runnable 作为匿名内部类，都会持有 Activity 的引用，由于 Handler 和 Runnable 的生命周期比 Activity 长，导致Activity 无法被回收，从而造成内存泄漏。  解决办法：将Handler 和 Runnable 定义为静态内部类，在Activity 的onDestory()方法中调用Handler 的 removeCallbacks 方法来移除 Message。</p><p>还有一种特殊情况，如果 Handler 或者 Runnable 中持有 Context 对象，那么即使使用静态内部类，还是会发生内存泄漏。解决办法：使用弱引用</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161341.png" alt></p><p>④其他内存泄漏情况：比如BraodcastReceiver 未注销，InputStream 未关闭，再代码中多注意注销或关闭。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161424.png" alt></p><h4 id="55-LeakCanary内存优化"><a href="#55-LeakCanary内存优化" class="headerlink" title="55.LeakCanary内存优化"></a>55.LeakCanary内存优化</h4><p>参考文章：<a href="https://www.jianshu.com/p/261e70f3083f" target="_blank" rel="noopener">LeakCanary原理解析 - 简书</a></p><p>①项目如何使用LeakCanary</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161409.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161434.png" alt></p><p>LeakCanary.enableDisplayLeakActivity(context);内存溢出图标，图标以通知的形式显示内存溢出</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161447.png" alt></p><p>②工作机制</p><p>LeakCanary.install() 会返回一个预定义的 <strong>RefWatcher</strong>，同时也会启用一个 <strong>ActivityRefWatcher</strong>，用于自动监控调用Activity.onDestroy() 之后泄露的 activity。</p><p>1.RefWatcher.watch() 创建一个 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsquare%2Fleakcanary%2Fblob%2Fmaster%2Flibrary%2Fleakcanary-watcher%2Fsrc%2Fmain%2Fjava%2Fcom%2Fsquareup%2Fleakcanary%2FKeyedWeakReference.java" target="_blank" rel="noopener">KeyedWeakReference</a> 到要被监控的对象。</p><p>2.然后在后台线程检查引用是否被清除，如果没有，调用GC。</p><p>3.如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。</p><p>4.在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsquare%2Fhaha" target="_blank" rel="noopener">HAHA</a> 解析这个文件。</p><p>5.得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。</p><p>6.HeapAnalyzer 计算 <em>到 GC roots 的最短强引用路径</em>，并确定是否是泄露。如果是的话，建立导致泄露的引用链。</p><p>7.引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。</p><h4 id="56-多线程、线程池"><a href="#56-多线程、线程池" class="headerlink" title="56.多线程、线程池"></a>56.多线程、线程池</h4><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fwxd0108%2Fp%2F5479442.html" target="_blank" rel="noopener">Java中的多线程你只要看这一篇就够了 - Givefine - 博客园</a></p><p>线程的并行和并发</p><p>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</p><p>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p><p>线程安全：多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。</p><hr><p>Java通过Executors提供四种线程池（from 百度）</p><p><strong>newCachedThreadPool</strong>——创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p><strong>newFixedThreadPool</strong>——创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p><strong>newScheduledThreadPool</strong>——创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>newSingleThreadExecutor</strong>——创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fdolphin0520%2Fp%2F3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用 - Matrix海子 - 博客园</a></p><p><strong>①线程池中的线程初始化</strong></p><p>创建线程池后，线程池中没有线程，需要提交任务才会创建线程。</p><p>prestartCoreThread()：初始化一个核心线程；</p><p>prestartAllCoreThreads()：初始化所有核心线程</p><p><strong>②workQueue，任务缓存队列，用来存放等待执行的任务</strong></p><p>workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>　　3）SynchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p><p><strong>③任务拒绝策略</strong></p><p>当线程池的任务缓存队列已满或线程数目达到maximumPoolSize，还有任务来时会采用任务拒绝策略</p><p>1）ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</p><p>2）ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p><p>3）ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p><p>4）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p><p><strong>④线程池的关闭</strong></p><p>1）shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p><p>2）shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p><p><strong>⑤线程池容量的动态调整</strong></p><p>1）setCorePoolSize：设置核心池大小</p><p>2）setMaximumPoolSize：设置线程池最大能创建的线程数目大小</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161503.png" alt></p><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fsuperfj%2Fp%2F7544971.html" target="_blank" rel="noopener">由浅入深理解Java线程池及线程池的如何使用 - Janti - 博客园</a></p><p>corePoolSize :线程池的核心池大小，在创建线程池之后，线程池默认没有任何线程。</p><p>当有任务过来的时候才会去创建创建线程执行任务。换个说法，线程池创建之后，线程池中的线程数为0，当任务过来就会创建一个线程去执行，直到线程数达到corePoolSize之后，就会被到达的任务放在队列中。（注意是到达的任务）。换句更精炼的话：corePoolSize表示允许线程池中允许同时运行的最大线程数。</p><p>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p><p>maximumPoolSize :线程池允许的最大线程数，他表示最大能创建多少个线程。maximumPoolSize肯定是大于等于corePoolSize。</p><p>keepAliveTime :表示线程没有任务时最多保持多久然后停止。默认情况下，只有线程池中线程数大于corePoolSize时，keepAliveTime才会起作用。换句话说，当线程池中的线程数大于corePoolSize，并且一个线程空闲时间达到了keepAliveTime，那么就是shutdown。</p><p>Unit:keepAliveTime的单位。</p><p>workQueue：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能</p><p>threadFactory：线程工厂，用来创建线程。</p><p>handler :表示当拒绝处理任务时的策略。</p><p>在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的<strong>几个静态方法来创建线程池</strong>：</p><p>Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</p><p>Executors.newSingleThreadExecutor(); //创建容量为1的缓冲池</p><p>Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池</p><h4 id="57-腾讯-Bugly"><a href="#57-腾讯-Bugly" class="headerlink" title="57.腾讯 Bugly"></a>57.腾讯 Bugly</h4><p>腾讯公司为移动开发者开放的服务之一，面向移动开发者提供专业的 <strong>Crash 监控、崩溃分析</strong>等质量跟踪服务。Bugly 能帮助移动互联网开发者更及时地发现掌控异常，更全面的了解定位异常，更高效的修复解决异常。</p><p>针对移动应用，腾讯 Bugly 提供了专业的 Crash、Android ANR ( application not response)、iOS 卡顿监控和解决方案。移动开发者 ( Android / iOS ) 可以通过监控，快速发现用户在使用过程中出现的 Crash (崩溃)、Android ANR 和 iOS 卡顿，并根据上报的信息快速定位和解决问题。</p><h4 id="58-Glide"><a href="#58-Glide" class="headerlink" title="58.Glide"></a>58.Glide</h4><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbumptech%2Fglide" target="_blank" rel="noopener">github 地址</a></p><p>项目依赖Glide，在app build.gradle 中配置 compile’com.github.bumptech.glide:glide:3.7.0’</p><p>使用glide3.7版本，更高版本或出现异常：Error:Failed to resolve: com.android.support:support-annotations:27.0.2</p><p><strong>Glide缓存机制</strong></p><p>内存存缓存的 读存都在Engine类中完成。内存缓存使用弱引用和LruCache结合完成的,弱引用来缓存的是正在使用中的图片。图片封装类Resources内部有个计数器判断是该图片否正在使用。</p><p><strong>Glide内存缓存的流程</strong></p><p>读：是先从lruCache取，取不到再从弱引用中取；</p><p>存：内存缓存取不到，从网络拉取回来先放在弱引用里，渲染图片，图片对象Resources使用计数加一；</p><p>渲染完图片，图片对象Resources使用计数减一，如果计数为0，图片缓存从弱引用中删除，放入lruCache缓存。</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/7ce7b02988a4" target="_blank" rel="noopener">Google推荐——Glide使用详解 - 简书</a></p><p><a href="https://www.jianshu.com/p/17644406396b" target="_blank" rel="noopener">Glide 系列(四) Glide缓存机制 - 野生的安卓兽 - 简书</a></p><h4 id="59-Fresco"><a href="#59-Fresco" class="headerlink" title="59.Fresco"></a>59.Fresco</h4><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ffacebook%2Ffresco" target="_blank" rel="noopener">github 地址</a></p><p>项目依赖Glide，在app build.gradle 中配置：implementation’com.facebook.fresco:fresco:1.9.0’</p><p><a href="https://github.com/desmond1121/Fresco-Source-Analysis" target="_blank" rel="noopener">https://github.com/desmond1121/Fresco-Source-Analysis</a></p><p>参考文章：<a href="https://www.jianshu.com/p/3b143cf39013" target="_blank" rel="noopener">Fresco的使用小结 - 简书</a></p><p><a href="https://blog.csdn.net/yw59792649/article/details/78921025" target="_blank" rel="noopener">https://blog.csdn.net/yw59792649/article/details/78921025</a></p><h4 id="60-React-Native"><a href="#60-React-Native" class="headerlink" title="60.React Native"></a>60.React Native</h4><p><strong>混合开发技术移动开发-混合App介绍 - Primise7的博客 - CSDN博客</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161536.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面试大纲&quot;&gt;&lt;a href=&quot;#面试大纲&quot; class=&quot;headerlink&quot; title=&quot;面试大纲&quot;&gt;&lt;/a&gt;面试大纲&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;java基础、面向对象、集合、线程使用；&lt;/li&gt;
&lt;li&gt;Android 机型适配、SDK适配、内存优化、内存溢出、内存泄漏；&lt;/li&gt;
&lt;li&gt;MVC/MVP/MVVM的使用场景；&lt;/li&gt;
&lt;li&gt;了解并能使用最新流行开源库RXjava+Retrofit+OKHttp、Glide、EventBus等；&lt;/li&gt;
&lt;li&gt;JNI及NDK的使用、熟悉Framework。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/categories/Android/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题集</title>
    <link href="https://zhangmiao.cc/posts/4a3cde30.html"/>
    <id>https://zhangmiao.cc/posts/4a3cde30.html</id>
    <published>2019-07-02T06:36:57.000Z</published>
    <updated>2019-07-22T09:18:42.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java部分</strong><br><strong>Android部分</strong><br><strong>数据结构与算法部分</strong><br><strong>常用的开源库部分</strong><br><strong>计算机网络认识</strong></p><a id="more"></a><h2 id="1-Java部分"><a href="#1-Java部分" class="headerlink" title="1.Java部分"></a><strong>1.Java部分</strong></h2><h3 id="1-1-操作系统相关"><a href="#1-1-操作系统相关" class="headerlink" title="1.1 操作系统相关"></a>1.1 操作系统相关</h3><ul><li>1.什么是操作系统？</li><li>2.什么是线程，什么是进程？</li></ul><h3 id="1-2-JDK-amp-JVM-amp-JRE"><a href="#1-2-JDK-amp-JVM-amp-JRE" class="headerlink" title="1.2 JDK&amp;JVM&amp;JRE"></a>1.2 JDK&amp;JVM&amp;JRE</h3><ul><li>1.JDK &amp; JVM &amp; JRE分别是什么以及它们的区别？</li><li>2.解释一下为什么Java可以跨平台？</li></ul><h3 id="1-3-面向过程-amp-面向对象"><a href="#1-3-面向过程-amp-面向对象" class="headerlink" title="1.3 面向过程 &amp; 面向对象"></a>1.3 面向过程 &amp; 面向对象</h3><ul><li>1.什么是面向过程 &amp; 什么是面向对象 &amp; 区别？</li><li>2.给我说说Java面向对象的特征以及讲讲你代码中凸显这些特征的经验。</li><li>3.什么是重载 &amp; 什么是重写 &amp; 区别。</li><li>4.谈谈你对this和super的认识。</li><li>5.接口和抽象类的区别。</li><li>6.静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？</li><li>7.给我说说权限修饰符特性。</li><li>8.给我谈谈Java中的内部类。</li><li>9.闭包和内部类的区别？</li><li>10.Java多态的实现机制是什么？</li><li>11.谈谈你对对象生命周期的认识？</li><li>12.static关键字的作用？</li><li>13.final关键字的作用。</li></ul><h3 id="1-4-八大基本数据类型-amp-引用类型"><a href="#1-4-八大基本数据类型-amp-引用类型" class="headerlink" title="1.4 八大基本数据类型&amp;引用类型"></a>1.4 八大基本数据类型&amp;引用类型</h3><ul><li>1.说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 什么是引用类型？</li><li>2.什么是拆箱 &amp; 装箱，能给我举栗子吗？</li></ul><h3 id="1-5-数组"><a href="#1-5-数组" class="headerlink" title="1.5 数组"></a>1.5 数组</h3><ul><li>1.能说说多维数组在内存上是怎么存储的吗？</li><li>2.你对数组二次封装过吗？说说封装了什么</li></ul><h3 id="1-6-Java异常"><a href="#1-6-Java异常" class="headerlink" title="1.6 Java异常"></a>1.6 Java异常</h3><ul><li>1.说说Java异常体系主要用来干什么的 &amp; 异常体系？</li><li>2.Error和Exception的区别？</li><li>3.说说运行时异常和非运行时异常的区别？</li><li>4.如何自定义一个异常？</li><li>5.throw和throws 的区别？</li><li>6.try{}catch{}finally{}可以没有finally吗？</li><li>7.finally语块有什么特点？</li><li>8.return在try{}catch{}finally{}中执行具有哪些规则？</li><li>9.给我例举至少5个常见的运行时异常。</li></ul><h3 id="1-7-NIO-BIO-AIO"><a href="#1-7-NIO-BIO-AIO" class="headerlink" title="1.7 NIO/BIO/AIO"></a>1.7 NIO/BIO/AIO</h3><ul><li>1.NIO是什么 &amp; BIO是什么 &amp; AIO是什么 &amp; 它们之间的区别？</li><li>2.IO按照方向和数据类型划分能划分为哪些数据流？</li><li>3.能给我说说NIO有什么特点？平常开发中使用过吗？</li></ul><h3 id="1-8-集合-容器"><a href="#1-8-集合-容器" class="headerlink" title="1.8 集合(容器)"></a>1.8 集合(容器)</h3><ul><li>1.说说Java中集合的框架？</li><li>2.Collection &amp; Map区别</li><li>3.谈谈你常用的集合 &amp; 它们底层的实现方式 &amp; 优缺点 &amp; 使用场景。</li><li>4.Map的遍历方式有哪些？</li><li>5.给我说说ArrayList的扩容机制.</li><li>6.什么是深拷贝 &amp; 浅拷贝 &amp; 如何深拷贝一个List集合.</li><li>7.Set是如何确保它的唯一性的。</li><li>8.你觉得HashMap的元素顺序和什么有关？</li><li>9.Java中HashMap如何解决哈希碰撞的？</li><li>10.ConcurrentHashMap如何实现并发访问的？</li><li>11.谈谈Java集合中那些线程安全的集合 &amp; 实现原理。</li><li>12.说说有哪些集合能加入null,哪些不能加入null,为什么？</li><li>13.说说LinkedHashMap原理。</li><li>14.Collection 和 Collections的区别？</li><li>15.比较一下ArrayMap和HashMap。</li><li>16.说说HashMap的原理。</li></ul><h3 id="1-9-线程"><a href="#1-9-线程" class="headerlink" title="1.9 线程"></a>1.9 线程</h3><ul><li>1.什么是线程？能解决什么问题。</li><li>2.Java中创建线程的2种方式 &amp; 区别？</li><li>3.给我说说线程的生命周期。</li><li>4.线程死锁的原因 &amp; 举个栗子 &amp; 如何避免死锁。</li><li>5.Synchronized放在静态方法和非静态方法上的锁对象分别是什么？</li><li>6.如何停止掉一个线程？</li><li>7.给我说说线程池的种类 &amp; 特点 &amp; 内部原理 &amp; 平时当中使用案例。</li><li>8.给我谈谈你是如何保证线程数据安全问题的？</li><li>9.wait()和sleep()的区别？</li><li>10.什么是公平锁&amp;非公平锁&amp;区别？</li><li>11.给我讲讲线程间通信</li><li>12.volatile关键字是如何使用的？原理是什么</li><li>13.说说使用5个线程去计算一个数组之和的思路。</li><li>14.谈谈线程阻塞的原因有哪些？</li><li>15.谈谈你对notify的理解？</li><li>16.你觉得Lock和Synchronized的区别是什么？</li><li>17.谈谈你对ReentrantLock的认识。</li><li>18.调用run()和start()的区别？</li><li>19.transient关键字的用法 &amp; 作用 &amp; 原理。</li><li>20.线程池的种类  &amp; 工作原理 &amp; ThreadPoolExecutor的工作策略有哪些？</li><li>21.ThreadLocal了解吗？说说原理。</li><li>22.权衡多线程的性能。</li><li>23.如何理解同步和异步，阻塞和非阻塞。</li></ul><h3 id="1-10-泛型"><a href="#1-10-泛型" class="headerlink" title="1.10 泛型"></a>1.10 泛型</h3><ul><li>1.什么是泛型？能解决什么问题？</li><li>2.说说Java中泛型的工作机制？</li><li>3.在泛型种extends和super关键字的区别是什么？</li></ul><h3 id="1-11-反射"><a href="#1-11-反射" class="headerlink" title="1.11 反射"></a>1.11 反射</h3><ul><li>1.什么是反射？</li><li>2.如何获取一个类的成员变量 &amp; 成员方法 &amp; 注解信息 &amp; …。</li><li>3.通常在项目当中用到反射多吗？都是用来干嘛？</li></ul><h3 id="1-12-注解"><a href="#1-12-注解" class="headerlink" title="1.12 注解"></a>1.12 注解</h3><ul><li>1.什么是注解 &amp; 它和注释的区别？</li><li>2.注解的工作机制是什么？</li></ul><h3 id="1-13-Socket编程"><a href="#1-13-Socket编程" class="headerlink" title="1.13 Socket编程"></a>1.13 Socket编程</h3><ul><li>1.什么是Socket编程？</li><li>2.什么是TCP,什么是UDP,二者之间区别如何？</li></ul><h3 id="1-14-设计模式"><a href="#1-14-设计模式" class="headerlink" title="1.14 设计模式"></a>1.14 设计模式</h3><ul><li>1.说说设计模式的六大原则。</li><li>2.请讲讲你会使用的一些设计模式？</li><li>3.请说说单例模式 &amp; 你项目中常用的单例模式。</li><li>4.懒汉单例模式为什么要加volaitle？</li><li>5.能否给我说说Android中至少3个用到设计模式的栗子？</li></ul><h3 id="1-15-JVM相关"><a href="#1-15-JVM相关" class="headerlink" title="1.15 JVM相关"></a>1.15 JVM相关</h3><ul><li>1.什么是class文件？</li><li>2.Java代码执行流程？</li><li>3.Java内存结构 &amp; 内存模型。</li><li>4.GC回收机制。</li><li>5.Java虚拟机是如何加载一个类的？</li><li>6.给我谈谈类加载器。</li><li>7.谈谈static编译运行时的流程，在虚拟机中如何保存的？</li><li>8.说说Java种的4种引用以及用法？</li><li>9.如何判断一个对象是死亡的？</li><li>10.代码中直接调用System.gc()会发生什么？</li><li>11.一个强引用直接被null赋值，那么这个对象会被立刻回收吗？</li><li>12.String a = “a”+”b”+”c”;在内存中创建了几个对象？</li><li>13.谈谈你对字符集的理解。</li><li>14.常见的编码格式有哪些？</li><li>15.utf-8中的中文占几个字节？int型占几个字节？</li><li>16.谈谈你对逻辑地址和物理地址的理解？</li><li>17.你知道对象什么时候会回调finalize方法吗？</li></ul><h3 id="1-16-其它Java部分有关面试题"><a href="#1-16-其它Java部分有关面试题" class="headerlink" title="1.16 其它Java部分有关面试题"></a>1.16 其它Java部分有关面试题</h3><ul><li>1.为什么局部内部类访问局部变量需要final?</li><li>2.String、StringBuffer、StringBuilder、CharSequence的区别。</li><li>3.equals和==的区别？</li><li>4.关于字符串的拼接你在项目中常常怎么操作的？为什么不能用“+”的方式进行拼接呢？</li><li>5.什么是Callback,讲讲你项目中使用的一些有关Callback的栗子。</li><li>6.retrun &amp; break &amp; continue 区别？</li><li>7.如何判断一个字符串是回文字符串？</li><li>8.final,finally,finalize的区别？</li><li>9.什么是动态代理 &amp; 什么是静态代理？</li><li>10.String为什么会加final？</li><li>11.OOM可以try{}catch{}吗？</li><li>12.给我谈谈正则表达式。</li><li>13.如何将String转成int?</li><li>14.谈谈你对String的理解。</li><li>15.你如何理解序列化？有哪些方式序列化？</li><li>16.谈谈你对依赖注入的理解。</li><li>17.给我谈谈你对分派的理解。</li></ul><h2 id="2-Android-部分"><a href="#2-Android-部分" class="headerlink" title="2.Android 部分"></a><strong>2.Android 部分</strong></h2><ul><li>四大组件是哪四个？ABCS(Activity,Braodcast,ContentProvider,Service)</li></ul><h3 id="2-1-Activity"><a href="#2-1-Activity" class="headerlink" title="2.1 Activity"></a>2.1 Activity</h3><ul><li>1.Activity是什么？</li><li>2.典型情况下的Activity生命周期？</li><li>3.异常情况下的Activity的生命周期 &amp; 数据如何保存和恢复？</li><li>4.从Activity A跳转到Activity B之后，然后再点击back建之后，它们的生命周期调用流程是什么？</li><li>5.如何统计Activity的工作时间？</li><li>6.给我说说Activity的启动模式 &amp; 使用场景。</li><li>7.如何在任意位置关掉应用所有Activity &amp; 如何在任意位置关掉指定的Activity？</li><li>8.Activity的启动流程(从源码角度解析)？</li><li>9.启动一个其它应用的Activity的生命周期分析。</li><li>10.Activity任务栈是什么？在项目中有用到它吗？说给我听听</li><li>11.什么情况下Activity不走onDestory?</li><li>12.什么情况下Activity会单独执行onPause?</li><li>13.a-&gt;b-&gt;c界面，其中b是SingleInstance的，那么c界面点back返回a界面，为什么？</li><li>14.如果一个Activity弹出一个Dialog,那么这个Acitvity会回调哪些生命周期函数呢？</li><li>15.Activity之间如何通信 &amp; Activity和Fragment之间通信 &amp; Activity和Service之间通信？</li><li>16.说说Activity横竖屏切换的生命周期。</li><li>17.前台切换到后台，然后在回到前台时Activity的生命周期。</li><li>18.下拉状态栏时Activity的生命周期？</li><li>19.Activity与Fragment的生命周期比较？</li><li>20.了解哪些Activity常用的标记位Flags？</li><li>21.谈谈隐式启动和显示启动Activity的方式？</li><li>22.Activity用Intent传递数据和Bundle传递数据的区别？为什么不用HashMap呢？</li><li>23.在隐式启动中Intent可以设置多个action,多个category吗 &amp; 顺便讲讲它们的匹配规则？</li><li>24.Activity可以设置为对话框的形式吗？</li><li>25.如何给Activity设置进入和退出的动画？</li><li>26.Activity使用Intent传递数据是否有限制 &amp; 如果传递一个复杂的对象，例如一个复杂的控件对象应该怎么做？</li></ul><h3 id="2-2-BroadcastReceiver"><a href="#2-2-BroadcastReceiver" class="headerlink" title="2.2 BroadcastReceiver"></a>2.2 BroadcastReceiver</h3><ul><li>1.广播是什么？</li><li>2.广播的注册方式有哪些？</li><li>3.广播的分类 &amp; 特性 &amp; 使用场景？</li><li>4.说说系统广播和本地广播的原理 &amp; 区别 &amp; 使用场景。</li><li>5.有两个应用注册了一样的广播，一个是静态，一个是动态，连优先级也一样，那么当广播从系统发出来后，哪个应用先接收到广播？</li></ul><h3 id="2-3-ContentProvider"><a href="#2-3-ContentProvider" class="headerlink" title="2.3 ContentProvider"></a>2.3 ContentProvider</h3><ul><li>1.什么是内容提供者？</li><li>2.说说如何创建自己应用的内容提供者 &amp; 使用场景。</li><li>3.说说ContentProvider的原理。</li><li>4.ContentProvider,ContentResolver,ContentObserver之间的关系？</li><li>5.说说ContentProvider的权限管理。</li></ul><h3 id="2-4-Service"><a href="#2-4-Service" class="headerlink" title="2.4 Service"></a>2.4 Service</h3><ul><li>1.什么是Service?</li><li>2.说说Service的生命周期。</li><li>3.Service和Thread的区别？</li><li>4.Android 5.0以上的隐式启动问题及其解决方案。</li><li>5.给我说说Service保活方案</li><li>6.IntentService是什么 &amp; 原理 &amp; 使用场景 &amp; 和Service的区别。</li><li>7.创建一个独立进程的Service应该怎样做？</li><li>8.Service和Activity之间如何通信？</li><li>9.说说你了解的系统Service。</li><li>10.谈谈你对ActivityManagerService的理解。</li><li>11.在Activtiy中创建一个Thread和在一个Service中创建一个Thread的区别？</li></ul><h3 id="2-5-Handler"><a href="#2-5-Handler" class="headerlink" title="2.5 Handler"></a>2.5 Handler</h3><ul><li>1.子线程一定不能更新UI吗？</li><li>2.给我说说Handler的原理</li><li>3.Handler导致的内存泄露你是如何解决的？</li><li>4.如何使用Handler让子线程和子线程通信？</li><li>5.你能给我说说Handler的设计原理？</li><li>6.HandlerThread是什么 &amp; 原理 &amp; 使用场景？</li><li>7.IdleHandler是什么？</li><li>8.一个线程能否创建多个Handler,Handler和Looper之间的对应关系？</li><li>9.为什么Android系统不建议子线程访问UI？</li><li>10.Looper死循环为什么不会导致应用卡死？</li><li>11.使用Handler的postDealy后消息队列有什么变化？</li><li>12.可以在子线程直接new一个Handler出来吗？</li><li>13.Message对象创建的方式有哪些 &amp; 区别？</li></ul><h3 id="2-6-AsyncTask"><a href="#2-6-AsyncTask" class="headerlink" title="2.6 AsyncTask"></a>2.6 AsyncTask</h3><ul><li>1.AsyncTask是什么？能解决什么问题</li><li>2.给我谈谈AsyncTask的三个泛型参数作用 &amp; 它的一些方法作用。</li><li>3.给我说说AsyncTask的原理。</li><li>4.你觉得AsyncTask有不足之处吗？</li></ul><h3 id="2-7-Fragment"><a href="#2-7-Fragment" class="headerlink" title="2.7 Fragment"></a>2.7 Fragment</h3><ul><li>1.Android中v4包下Fragment和app包下Fragment的区别是什么？</li><li>2.Fragment的生命周期 &amp; 请结合Activity的生命周期再一起说说。</li><li>3.说说Fragment如何进行懒加载。</li><li>4.ViewPager + Fragment结合使用会出现内存泄漏吗 &amp; 如何解决？</li><li>5.Fragment如何和Activity进行通信 &amp; Fragment之间如何进行通信？</li><li>6.给我谈谈Fragment3种切换的方式以及区别 &amp; 使用场景。</li><li>7.getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？</li><li>8.FragmentPagerAdapter和FragmentStatePagerAdapter区别？</li><li>9.Fragment如何实现类似Activity栈的压栈和出栈效果的？</li></ul><h3 id="2-8-序列化"><a href="#2-8-序列化" class="headerlink" title="2.8 序列化"></a>2.8 序列化</h3><ul><li>1.什么是序列化 &amp; 能用来干什么？</li><li>2.Android中序列化方式有几种？说说它们的区别。</li><li>3.如果想要序列化的类中某些字段不序列化，那么应该怎么做？</li></ul><h3 id="2-9-IPC"><a href="#2-9-IPC" class="headerlink" title="2.9 IPC"></a>2.9 IPC</h3><ul><li>1.说说你对Android多进程开发的认识？</li><li>2.Android中进程间通信的方式有哪些？</li><li>3.什么是AIDL?如何创建一个AIDL。</li></ul><h3 id="2-10-文件存储"><a href="#2-10-文件存储" class="headerlink" title="2.10 文件存储"></a>2.10 文件存储</h3><ul><li>1.说说Android中数据持久化的方式 &amp; 使用场景。</li><li>2.接触过MMKV吗？说说SharedPreference和它的区别。</li><li>3.第三方数据库框架用过哪些？有没有自己封装过一个SQLite的库？</li><li>4.SQLite是线程安全的吗 &amp; SharedPreference是线程安全的吗？</li><li>5.请简单的给我说说什么是三级缓存？</li><li>6.SharedPreference的apply和commit的区别。</li><li>7.谈谈你对SQLite事务的认识。</li><li>8.千奇百怪的SQL语句考察。</li><li>9.SharePreference跨进程使用会怎么样？如何保证跨进程使用安全？</li><li>10.谈谈SQLite升级要注意哪些地方？</li></ul><h3 id="2-11-ListView-amp-RecyclerView"><a href="#2-11-ListView-amp-RecyclerView" class="headerlink" title="2.11 ListView &amp; RecyclerView"></a>2.11 ListView &amp; RecyclerView</h3><ul><li>1.ListView是什么？如何使用？</li><li>2.RecyclerView是什么？如何使用？如何返回不一样的Item。</li><li>3.ListView和RecycyclerView的区别是什么？</li><li>4.分别讲讲你对ListView &amp; RecyclerView的优化经验。</li><li>5.给我说说RecyclerView的回收复用机制</li><li>6.说说你是如何给ListView &amp; RecyclerView加上拉刷新 &amp; 下拉加载更多机制。</li><li>7.谈谈你是如何对ListView &amp; RecycleView进行局部刷新的？</li><li>8.谈谈如何进行分页加载？</li><li>9.ScrollView下嵌套一个ListView通常会出现什么问题？</li><li>10.一个ListView或者一个RecyclerView在显示新闻数据的时候，出现图片错位，可能的原因有哪些 &amp; 如何解决？</li></ul><h3 id="2-12-图片编程"><a href="#2-12-图片编程" class="headerlink" title="2.12 图片编程"></a>2.12 图片编程</h3><ul><li>1.你对Bitmap了解吗？它在内存中如何存在？</li><li>2.有关Bitmap导致OOM的原因知道吗？如何优化？</li><li>3.给我谈谈图片压缩。</li><li>4.LruCache &amp; DiskLruCache原理。</li><li>5.说说你平常会使用的一些第三方图片加载库,最好给我谈谈它的原理。</li><li>6.如果让你设计一个图片加载库，你会如何设计？</li><li>7.有一张非常大的图片,你如何去加载这张大图片？</li><li>8.你知道Android中处理图片的一些库吗(OpenCv &amp; GPUImage …)？</li><li>9.如何计算一张图片在内存中占用的大小？</li></ul><h3 id="2-13-WebView"><a href="#2-13-WebView" class="headerlink" title="2.13 WebView"></a>2.13 WebView</h3><ul><li>1.WebView是什么？</li><li>2.WebView会导致内存泄露吗？原因是什么？解决方式有哪些？</li><li>3.你知道Hybrid开发吗？说说你的相关经验。</li><li>4.说说WebSettings &amp; WebViewClient &amp; WebChromeClient这三个类的作用 &amp; 用法。</li><li>5.说说你了解的Hybrid框架。</li></ul><h3 id="2-14-ViewPager"><a href="#2-14-ViewPager" class="headerlink" title="2.14 ViewPager"></a>2.14 ViewPager</h3><ul><li>1.什么是ViewPager?说说它的那些适配器。</li><li>2.你了解ViewPager2吗？和ViewPager 1有哪些区别？</li><li>3.ViewPager + Fragment结合使用存在的内存泄漏的原因是什么？如何解决？</li></ul><h3 id="2-15-View事件分发机制"><a href="#2-15-View事件分发机制" class="headerlink" title="2.15 View事件分发机制"></a>2.15 View事件分发机制</h3><ul><li>1.什么是事件分发机制？主要用来解决什么问题？</li><li>2.给我说说事件分发的流程 &amp; 你项目解决事件冲突的一些案例。</li><li>3.多点触摸事件平时接触过吗？如何监听用户第二个手指，第三个…？</li><li>4.OnTouchListener &amp; OnTouchEvent &amp; onClickListener三者之间的关系？</li><li>5.谈谈你对MotionEvent的认识？Cancel事件是什么情况下触发的？</li><li>6.能给我谈谈Android中坐标体系吗？</li></ul><h3 id="2-16-View绘制机制"><a href="#2-16-View绘制机制" class="headerlink" title="2.16 View绘制机制"></a>2.16 View绘制机制</h3><ul><li>1.说说View绘制流程。</li><li>2.说说Activity View树结构。</li><li>3.自定义View的方式有哪些?给我说说你之前项目中的案例。</li><li>4.invalidate和postvalidate的区别？</li><li>5.说说你在自定义View时常常重写的一些方法？</li><li>6.说说自定义View中如何自定义属性？</li><li>7.requestLayout(),onLayout(),onDraw(),drawChild()区别和联系？</li><li>8.如何计算出一个View的嵌套层级？</li><li>9.自定义View如何考虑机型适配？</li></ul><h3 id="2-17-布局"><a href="#2-17-布局" class="headerlink" title="2.17 布局"></a>2.17 布局</h3><ul><li>1.说说Android中有哪些布局 &amp; 特点。</li><li>2.你知道布局文件到控件对象的过程吗？</li><li>3.有这么一个布局需求，一个文本控件放在屏幕一半的一半的中间位置，你如何进行布局？</li><li>4.LinearLayout,FrameLayout,RelativeLayout性能对比，为什么？</li></ul><h3 id="2-18-Binder"><a href="#2-18-Binder" class="headerlink" title="2.18 Binder"></a>2.18 Binder</h3><ul><li>1.什么是Binder？用来干什么？</li><li>2.给我具体讲讲Binder机制。</li></ul><h3 id="2-19-动画机制"><a href="#2-19-动画机制" class="headerlink" title="2.19 动画机制"></a>2.19 动画机制</h3><ul><li>1.Android中的动画分为哪些种类 &amp; 特点 &amp; 缺点。</li><li>2.知道SVG &amp; 矢量动画吗？</li><li>3.给我说说转场动画。</li><li>4.给我谈谈插值器 &amp; 估值器 的作用。</li><li>5.说说Android动画框架实现的原理。</li></ul><h3 id="2-20-JNI"><a href="#2-20-JNI" class="headerlink" title="2.20 JNI"></a>2.20 JNI</h3><ul><li>1.什么是JNI?它主要用来干什么。</li><li>2.Java Native方法如何和Native函数进行绑定的？</li><li>3.JNI如何实现数据传递？</li><li>4.如何全局捕获Native发生的异常？</li><li>5.只有C/C++能编写Native库吗？</li></ul><h3 id="2-21-Window-amp-Appliction-amp-Context"><a href="#2-21-Window-amp-Appliction-amp-Context" class="headerlink" title="2.21 Window &amp; Appliction &amp; Context"></a>2.21 Window &amp; Appliction &amp; Context</h3><ul><li>1.说说你对Android中Window的理解。</li><li>2.说说你对Application的理解 &amp; 生命周期。</li><li>3.Android中有哪些上下文 &amp; 区别 &amp; 作用。</li><li>4.谈谈你对Android中Context的理解。</li></ul><h3 id="2-22-通知"><a href="#2-22-通知" class="headerlink" title="2.22 通知"></a>2.22 通知</h3><ul><li>1.Android 8.0如何适配通知？</li><li>2.自定义通知流程？</li></ul><h3 id="2-23-对话框-Dialog-amp-DialogFragment-amp-PopWindow"><a href="#2-23-对话框-Dialog-amp-DialogFragment-amp-PopWindow" class="headerlink" title="2.23 对话框(Dialog &amp; DialogFragment &amp; PopWindow)"></a>2.23 对话框(Dialog &amp; DialogFragment &amp; PopWindow)</h3><ul><li>1.说说Android中对话框可以用哪些方式完成？</li></ul><h3 id="2-24-蓝牙"><a href="#2-24-蓝牙" class="headerlink" title="2.24 蓝牙"></a>2.24 蓝牙</h3><ul><li>1.说说最新的蓝牙版本？新版本的特性是什么？</li></ul><h3 id="2-25-冷启动-amp-热启动"><a href="#2-25-冷启动-amp-热启动" class="headerlink" title="2.25 冷启动&amp;热启动"></a>2.25 冷启动&amp;热启动</h3><ul><li>1.什么是冷启动 &amp; 什么是热启动 &amp; 它们的流程？</li><li>2.如何优化冷启动？</li><li>3.启动页白屏，黑屏，太慢如何解决？</li></ul><h3 id="2-26-悬浮窗"><a href="#2-26-悬浮窗" class="headerlink" title="2.26 悬浮窗"></a>2.26 悬浮窗</h3><ul><li>1.在做悬浮窗的时候你遇到了什么困难(主要指悬浮窗权限适配)？</li><li>2.如何制作一个悬浮窗？</li></ul><h3 id="2-27-Android版本"><a href="#2-27-Android版本" class="headerlink" title="2.27 Android版本"></a>2.27 Android版本</h3><ul><li>1.最新的Android版本多少知道吗？有哪些特性</li><li>2.说说更新较大的Android版本。</li></ul><h3 id="2-28-Android-Studio"><a href="#2-28-Android-Studio" class="headerlink" title="2.28 Android Studio"></a>2.28 Android Studio</h3><ul><li>1.你现在比较常用Android Studio那个版本 &amp; 用的Gradle版本是多少？</li><li>2.如何理解gradle?</li><li>3.说说Android Studio中大致项目结构？</li><li>4.混淆是什么 &amp; 为什么需要进行混淆 &amp; 混淆的原理 &amp; 为什么Java反射常常会和混淆冲突？</li></ul><h3 id="2-29-UI卡顿优化"><a href="#2-29-UI卡顿优化" class="headerlink" title="2.29 UI卡顿优化"></a>2.29 UI卡顿优化</h3><ul><li>1.ANR是什么？导致原因有哪些？</li><li>2.谈谈你项目中避免ANR的一些经验。</li><li>3.分别说说Activity &amp; BroadcastReceiver &amp; Serice最长可耗时时间为多少？</li></ul><h3 id="2-30-内存优化"><a href="#2-30-内存优化" class="headerlink" title="2.30 内存优化"></a>2.30 内存优化</h3><ul><li>1.什么是OOM &amp; 什么是内存泄漏 &amp; 什么是内存抖动？</li><li>2.谈谈你项目中内存优化的一些经验。</li></ul><h3 id="2-31-屏幕适配"><a href="#2-31-屏幕适配" class="headerlink" title="2.31 屏幕适配"></a>2.31 屏幕适配</h3><ul><li>1.说说Android中一些屏幕单位。</li><li>2.谈谈你项目中的一些屏幕适配的经验。</li><li>3.今日头条的轻量级适配方案了解吗 &amp; 给我说说原理。</li></ul><h3 id="2-32-多渠道打包-amp-apk签名"><a href="#2-32-多渠道打包-amp-apk签名" class="headerlink" title="2.32 多渠道打包 &amp; apk签名"></a>2.32 多渠道打包 &amp; apk签名</h3><ul><li>1.apk为什么需要签名？</li><li>2.多渠道打包是什么 &amp; 有类似经验吗？</li><li>3.简述多渠道打包及原理和常用操作？</li></ul><h3 id="2-33-项目架构"><a href="#2-33-项目架构" class="headerlink" title="2.33 项目架构"></a>2.33 项目架构</h3><ul><li>1.说说你用过的项目架构？</li><li>2.分别给我说说MVC,MVP,MVVM特点和区别。</li><li>3.以登陆界面为例子,设计MVP架构。</li><li>4.谈谈AndroidManifest.xml文件的理解。</li></ul><h3 id="2-34-Android前沿知识"><a href="#2-34-Android前沿知识" class="headerlink" title="2.34 Android前沿知识"></a>2.34 Android前沿知识</h3><ul><li>1.谷歌新出的Flutter知道吗？</li><li>2.谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。</li><li>3.谈谈Kotlin中协程的认识？</li></ul><h3 id="2-35-音视频开发-高薪"><a href="#2-35-音视频开发-高薪" class="headerlink" title="2.35 音视频开发(高薪)"></a>2.35 音视频开发(高薪)</h3><ul><li>1.之前有过音视频开发经验吗 &amp; 说说用哪些开源架子开发的。</li><li>2.FFmpeng了解过吗？</li><li>3.Android中播放视频音频的方式有哪些？</li><li>4.Android中播放网络地址视频有哪些出色的开源库？</li><li>5.流媒体服务器了解吗？</li><li>6.谈谈你对编码格式的理解。</li><li>7.MediaPlayer和SoundPool的区别？</li><li>8.视频硬解码和软解码的区别？</li></ul><h3 id="2-36-其它Android部分有关面试题"><a href="#2-36-其它Android部分有关面试题" class="headerlink" title="2.36 其它Android部分有关面试题"></a>2.36 其它Android部分有关面试题</h3><ul><li>1.说说一个app的启动流程(从源码角度讲解)。</li><li>2.你知道无论是Kotlin或者是Java,程序运行的主要入口都是main()方法，那么Android的main方法在哪里？</li><li>3.Android Hock技术了解吗？</li><li>4.简述Android中的加固和使用平台？</li><li>5.谈谈你对Apk瘦身的经验？</li><li>6.为什么子线程不能更新UI？</li><li>7.你知道如何定位内存泄漏吗？</li><li>8.说说System.exit(0),onDestory(),Activity.finish()的区别？</li><li>9.在OnResume或者之前获取View的宽高为多少 &amp; 为什么？</li><li>10.Art &amp; Dvm 区别，特别是谈谈GC的区别。</li><li>11.说说你用的二维码框架 &amp; 有过优化经验吗？</li><li>12.谈谈App多进程的好处 &amp; 缺点。</li><li>13.说说AMS是怎么找到启动指定的Activity？</li><li>14.View的getWidth和getMeasureWidth有啥区别？</li><li>15.有插件化或者热修复经验吗？说说它的原理。</li><li>16.断点续传了解吗？谈谈你是如何通过多线程实现断点续传的。</li><li>17.给我谈谈你对SurfaceView的认识。</li><li>18.什么情况下你会使用到ScrollView。</li><li>19.低版本SDK如何使用高版本API？</li><li>20.AlertDialog,PopWindow,Activity之间的区别？</li><li>21.Application和Activity,Context的区别？</li><li>22.谈谈Android中多线程通信方式？</li><li>23.说说Android大体的架构图，试着画出来。</li><li>24.知道SpareArray吗？</li><li>25.Activity除了setContentView可以设置布局，还有其它方式吗？</li><li>26.Android为每个应用程序分配的内存大小为多少？</li><li>27.Android进程保活方案？</li><li>28.谈谈Android系统安装apk的过程？</li><li>29.Activity,Window,View三者的关系？</li><li>30.ActivityThread,ActivityManagerService,WindowManagerService的工作原理？</li><li>31.PackageManagerService的工作原理？</li><li>32.PowerManagerService的工作原理？</li><li>33.在桌面点击一个未启动的App的流程 &amp; 点击一个已启动的App的流程？</li><li>34.Android中进程分为哪些种类？</li><li>35.什么是埋点，懂点它的原理吗？</li><li>36.进程和Application生命周期之间的关系？</li><li>37.App相互唤醒的有哪些方式？</li><li>38.Android中如何开启多进程？应用是否可以开启N个进程？</li><li>39.谈谈消息推送的方式有哪些？</li><li>40.谈谈你对Root权限的理解。</li><li>41.谈谈项目如何进行国际化？</li><li>42.谈谈你对Intent和IntentFilter的理解。</li><li>43.一条最长的短信息约占多少byte？</li></ul><h2 id="3-算法与数据结构部分"><a href="#3-算法与数据结构部分" class="headerlink" title="3.算法与数据结构部分"></a><strong>3.算法与数据结构部分</strong></h2><h3 id="3-1-复杂度分析"><a href="#3-1-复杂度分析" class="headerlink" title="3.1 复杂度分析"></a>3.1 复杂度分析</h3><ul><li>1.什么是时间复杂度 &amp; 什么是空间复杂度？</li><li>2.时间复杂度和空间复杂度之间存在什么联系？</li></ul><h3 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h3><ul><li>1.谈谈你对数组的理解。</li></ul><h3 id="3-3-链表"><a href="#3-3-链表" class="headerlink" title="3.3 链表"></a>3.3 链表</h3><ul><li>1.什么是单链表 &amp; 双向链表 &amp; 循环链表 &amp; 双向循环链表 &amp; 静态链表。</li><li>2.反转一个链表有哪些方式？</li><li>3.如何判断链表有环？</li><li>4.用Java语言设计一个LinkedList。</li></ul><h3 id="3-4-堆"><a href="#3-4-堆" class="headerlink" title="3.4 堆"></a>3.4 堆</h3><ul><li>1.如何理解堆？</li></ul><h3 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h3><ul><li>1.什么是栈 &amp; 栈的特点是什么？</li><li>2.什么是顺序栈 &amp; 链式栈？</li><li>3.你有没有基于栈封装的业务类？</li><li>4.你能用栈实现队列吗？</li><li>5.如何实现浏览器前进和后退功能？</li></ul><h3 id="3-6-队列"><a href="#3-6-队列" class="headerlink" title="3.6 队列"></a>3.6 队列</h3><ul><li>1.什么是队列 &amp; 队列的特点是什么？</li><li>2.什么是优先队列？</li><li>3.什么是双端队列 &amp; 阻塞队列?</li><li>4.你能用队列实现栈吗？</li></ul><h3 id="3-7-散列表"><a href="#3-7-散列表" class="headerlink" title="3.7 散列表"></a>3.7 散列表</h3><ul><li>1.什么是散列函数？</li><li>2.什么是散列冲突？解决的方式有哪些？Java中的HashMap解决方式采用的哪一种？</li><li>3.什么是散列表的动态扩容？</li><li>4.什么是位图？</li></ul><h3 id="3-8-树"><a href="#3-8-树" class="headerlink" title="3.8 树"></a>3.8 树</h3><ul><li>1.什么是二叉树？</li><li>2.什么是先序遍历 &amp; 中序遍历 &amp; 后序遍历。</li><li>3.什么是多路查找树？</li><li>4.什么是红黑树？</li></ul><h3 id="3-9-排序"><a href="#3-9-排序" class="headerlink" title="3.9 排序"></a>3.9 排序</h3><ul><li>1.给我说说你会的排序 &amp; 复杂度如何？</li><li>2.现在有10万条数据需要进行排序，你会选择什么排序？</li></ul><h3 id="3-10-查找"><a href="#3-10-查找" class="headerlink" title="3.10 查找"></a>3.10 查找</h3><ul><li>1.说说你知道的查找算法 &amp; 复杂度如何？</li></ul><h3 id="3-11-递归-amp-回溯算法"><a href="#3-11-递归-amp-回溯算法" class="headerlink" title="3.11 递归&amp;回溯算法"></a>3.11 递归&amp;回溯算法</h3><ul><li>1.什么是递归 &amp; 什么是回溯？</li></ul><h3 id="3-12-贪心算法"><a href="#3-12-贪心算法" class="headerlink" title="3.12 贪心算法"></a>3.12 贪心算法</h3><ul><li>1.什么是贪心算法？</li></ul><h3 id="3-13-其它有关算法与数据结构的面试题"><a href="#3-13-其它有关算法与数据结构的面试题" class="headerlink" title="3.13 其它有关算法与数据结构的面试题"></a>3.13 其它有关算法与数据结构的面试题</h3><ul><li>1.什么是图？可以解决一些什么问题？</li><li>2.时针走一圈，时针分针重合几次？</li><li>3.有一个不均匀的绳子烧完要1个小时，如何算出1小时15分钟？</li><li>4.求1000以内的水仙花数以及40亿以内的水仙花数？</li><li>5.数据怎么压缩，数据的安全。</li><li>6.谈谈你对对称加密 &amp; 非对称加密的理解。</li></ul><h2 id="4-常用的开源库部分"><a href="#4-常用的开源库部分" class="headerlink" title="4.常用的开源库部分"></a><strong>4.常用的开源库部分</strong></h2><h3 id="4-1-异步通信"><a href="#4-1-异步通信" class="headerlink" title="4.1 异步通信"></a>4.1 异步通信</h3><ul><li>1.RxJava用法 &amp; RxJava2用法 &amp; 原理 &amp;用到的设计模式？</li><li>2.EventBus用法 &amp; 原理。</li></ul><h3 id="4-2-网络"><a href="#4-2-网络" class="headerlink" title="4.2 网络"></a>4.2 网络</h3><ul><li>1.OkHttp用法 &amp; 源码分析。</li><li>2.Retrofit用法 &amp; 源码分析。</li><li>3.Volley用法 &amp; 缺点。</li></ul><h3 id="4-3-依赖注入"><a href="#4-3-依赖注入" class="headerlink" title="4.3 依赖注入"></a>4.3 依赖注入</h3><ul><li>1.ButterKnife用法 &amp; 原理。</li><li>2.Dagger2用法 &amp; 原理。</li></ul><h3 id="4-4-图片加载"><a href="#4-4-图片加载" class="headerlink" title="4.4 图片加载"></a>4.4 图片加载</h3><ul><li>1.Glide用法 &amp; 原理。</li><li>2.Picasso用法 &amp; 原理。</li><li>3.Fresco用法 &amp; 原理。</li></ul><h3 id="4-5-数据库"><a href="#4-5-数据库" class="headerlink" title="4.5 数据库"></a>4.5 数据库</h3><ul><li>1.GreenDao。</li><li>2.LitePal。</li><li>3.OrmLite。</li><li>4.DBFlow。</li><li>5.Realm。</li></ul><h3 id="4-6-其它"><a href="#4-6-其它" class="headerlink" title="4.6 其它"></a>4.6 其它</h3><ul><li>1.分享你觉得比较好用的开源库。</li><li>2.自己有封装库吗？给我说说你是如何设计的？</li><li>3.你是如何设计一个网络请求框架的？</li></ul><h2 id="5-计算机网络部分"><a href="#5-计算机网络部分" class="headerlink" title="5.计算机网络部分"></a><strong>5.计算机网络部分</strong></h2><ul><li>1.给我介绍5层网络模型。</li><li>2.Http/Https协议工作在哪一层？</li><li>3.TCP/UDP协议工作在哪一层？</li><li>4.给我说说三次握手和四次挥手。</li><li>5.什么是请求头 &amp; 响应头 ? 说说请求头中一些重要的字段。</li><li>6.什么是Cookie &amp; Session。</li><li>7.知道什么是心跳检测吗？</li><li>8.Http和Https的区别？</li><li>9.加密协议TLS/SSL加密过程是怎样的？</li><li>10.什么是DNS &amp; 作用是什么 &amp;工作机制？</li><li>11.浏览器访问一个url网址所经历的过程是什么？</li><li>12.Socket是协议吗？WebSocket是协议吗？它们的区别是什么？</li><li>13.Json解析方式有哪些？比较它们的优劣势。</li><li>14.XML解析方式有哪些？比较它们的优劣势。</li><li>15.http1.x &amp; http 2.0区别是什么？</li><li>16.说说HTTP缓存的原理。</li><li>17.如果有个100M大的文件，需要上传至服务器中，而服务器form表单最大只能上传2M,可以使用什么方法？</li><li>18.说说你项目中即时通讯的方案有哪些？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Android部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;数据结构与算法部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;常用的开源库部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;计算机网络认识&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/categories/Android/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
