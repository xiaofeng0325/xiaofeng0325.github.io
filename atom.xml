<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2020-03-04T03:21:47.887Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Studio 3.6 正式版终于发布了</title>
    <link href="https://zhangmiao.cc/posts/aaf10946.html"/>
    <id>https://zhangmiao.cc/posts/aaf10946.html</id>
    <published>2020-03-04T02:54:25.000Z</published>
    <updated>2020-03-04T03:21:47.887Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304110901.png" alt></p><p>如题，Android Studio 3.6 正式版终于发布了，值得兴奋呀，毕竟 3.5 大版本更新也已经差不多半年了，撒花撒花！这次更新又更新了什么呢？</p><p>包括有设计、开发、构建、测试、优化等多方面，下面我们来看看 Release Notes 写了些什么吧！</p><h2 id="Release-Notes"><a href="#Release-Notes" class="headerlink" title="Release Notes"></a>Release Notes</h2><p>我们很高兴宣布 Android Studio 3.6 发布稳定版本了，该版本内有一些针对性的新特性，主要解决了在代码编辑和调试用例中的质量问题。这是我们在 Project Marble 结束之后的第一个版本，其重点是构建强大的集成开发环境（IDE）的基本功能和流。我们从 Project Marble 中学到了很多，在 Android Studio 3.6 中，我们引入了一小部分功能，完善的现有功能，并花费了很大的精力来解决错误并改善基础性能，以确保我们达到去年设定的高质量标准。</p><p>Android Studio 3.6 的一些亮点包括一种使用 XML 快速设计、开发和预览应用布局的新方法，在设计编辑器中提供了新的拆分视图。此外，您不再需要手动键入 GPS 坐标来测试应用的位置，因为我们现在将 Google 地图直接嵌入到 Android 模拟器扩展控制面板中。最后，通过针对片段和活动的自动内存泄漏检测，我们简化了应用并查找 Bug。我们希望所有这些功能可以帮助您在 Android 上开发时更快乐、更高效。</p><p>感谢在预览版中提供早期反馈的用户。您的反馈帮助我们迭代和改进 Android Studio 3.6 中的功能。如果您已准备好迎接下一个稳定版本，并且想要使用一组新的生产力功能，Android Studio 3.6 已准备好下载，以便您入门。</p><p>以下是 Android Studio 3.6 中由主要开发人员流组织的全部新功能列表。</p><a id="more"></a><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><h4 id="在设计编辑器中拆分视图"><a href="#在设计编辑器中拆分视图" class="headerlink" title="在设计编辑器中拆分视图"></a>在设计编辑器中拆分视图</h4><p>设计编辑器（如布局编辑器和导航编辑器）现在提供”拆分”视图，使您能够同时查看 UI 的”设计和代码”视图。拆分视图将替换和改进较早的”预览”窗口，并可以逐个文件进行配置，以保留上下文信息（如缩放因子和设计视图选项），因此您可以选择最适合每个用例的视图。要启用拆分视图，请单击编辑器窗口右上角的”拆分”图标。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111247.png" alt></p><h4 id="颜色选取器资源选项卡"><a href="#颜色选取器资源选项卡" class="headerlink" title="颜色选取器资源选项卡"></a>颜色选取器资源选项卡</h4><p>在此版本中，我们希望更轻松地应用已定义为颜色资源的颜色。在 Android Studio 3.6 中，颜色选取器将填充应用中的颜色资源，以便快速选择和替换颜色资源值。颜色选取器可在设计工具和 XML 编辑器中访问。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111308.png" alt></p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="视图绑定"><a href="#视图绑定" class="headerlink" title="视图绑定"></a>视图绑定</h4><p>视图绑定是一项功能，允许您在引用代码中的视图时提供编译时安全性，从而更轻松地编写与视图交互的代码。启用后，视图绑定将为每个模块中存在的 XML 布局文件生成一个绑定类。在大多数情况下，视图绑定将替换 findViewById。您可以引用具有 ID 的所有视图，这些视图没有空指针或类强制转换异常的风险。这些差异意味着布局和代码之间的不兼容将导致生成在编译时失败，而不是在运行时。要在项目中启用视图绑定，请在每个模块的生成中包括以下内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    viewBinding.enabled = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Android-NDK-修改"><a href="#Android-NDK-修改" class="headerlink" title="Android NDK 修改"></a>Android NDK 修改</h4><p>Android Studio 中的以下 Android NDK 功能以前在 Java 中支持，现在 Kotlin 也支持：</p><ul><li>从 JNI 声明导航到 C/C++ 中的相应实现函数。通过将鼠标悬停在托管源代码文件中行号附近的 C 或C++项标记上，查看此映射。</li><li>自动为 JNI 声明创建存根实现函数。首先定义 JNI 声明，然后在要激活的 C/C++ 文件中键入”jni”或方法名称。</li></ul><h3 id="IntelliJ-平台更改"><a href="#IntelliJ-平台更改" class="headerlink" title="IntelliJ 平台更改"></a>IntelliJ 平台更改</h3><p>Android Studio 3.6 包括 IntelliJ 2019.2 平台版本。此 IntelliJ 版本包括许多改进，从新的服务工具窗口到大大缩短的启动时间。</p><h3 id="应用更改"><a href="#应用更改" class="headerlink" title="应用更改"></a>应用更改</h3><p>现在，您可以通过单击”应用代码更改”或”应用更改并重新启动活动”来添加类，然后将该代码更改部署到正在运行的应用。</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="Android-Gradle-Plugin-AGP-updates"><a href="#Android-Gradle-Plugin-AGP-updates" class="headerlink" title="Android Gradle Plugin (AGP) updates"></a>Android Gradle Plugin (AGP) updates</h4><p>Android Gradle 插件 3.6 及更高版本包括对 Maven 发布 Gradle 插件的支持，该插件允许您将构建项目发布到 Apache Maven 存储库。Android Gradle 插件为应用或库模块中的每个生成变体项目创建一个组件，您可以使用该组件将出版物自定义到 Maven 存储库。此更改将更轻松地管理各种目标的发布生命周期。</p><p>此外，Android Gradle 插件在大型项目的注释处理/KAPT 方面取得了显著的性能改进。这是由 AGP 现在直接生成 R 类字节码，而不是 .java 文件引起的。</p><h4 id="新的打包工具"><a href="#新的打包工具" class="headerlink" title="新的打包工具"></a>新的打包工具</h4><p>Android 构建团队不断进行更改以提高生成性能，在此版本中，我们将默认打包工具更改为 zipflinger 以进行调试生成。用户应该看到生成速度的提高，但您也可以通过设置 <code>android.useNewApkCreator_false</code> 在您的分级中恢复使用旧的打包工具。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111433.png" alt></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="Android-模拟器-Google-地图"><a href="#Android-模拟器-Google-地图" class="headerlink" title="Android 模拟器 - Google 地图"></a>Android 模拟器 - Google 地图</h4><p>Android 模拟器 29.2.12 为应用开发人员提供了一种与模拟设备位置进行接口的新方式。我们在扩展控件菜单中嵌入了 Google 地图用户界面，以便更轻松地指定位置，并构建来自位置对的路由。可以保存单个点并将其重新发送到设备作为虚拟位置，而路由可以通过键入地址或单击两个点来生成。当路线上的位置发送到来宾 OS 时，可以实时重播这些路由。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111448.png" alt></p><h4 id="多屏支持"><a href="#多屏支持" class="headerlink" title="多屏支持"></a>多屏支持</h4><p>模拟器 29.1.10 包括对多个虚拟显示器的初步支持。由于有更多的设备具有多个显示器，因此在各种多显示器配置上测试应用非常重要。用户可以通过设置菜单（扩展控件和设置）配置多个显示器。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111510.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111526.png" alt></p><h4 id="SDK-断点续传"><a href="#SDK-断点续传" class="headerlink" title="SDK 断点续传"></a>SDK 断点续传</h4><p>当使用 Android Studio SDK 管理器下载 Android SDK 组件和工具时，Android Studio 现在允许您恢复中断的下载（例如，由于网络问题），而不是从一开始就重新启动下载。当互联网连接不可靠时，此增强功能对于大型下载（如 Android 模拟器或系统映像）特别有用。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111543.png" alt></p><h4 id="导入的-APK-可以自动更新"><a href="#导入的-APK-可以自动更新" class="headerlink" title="导入的 APK 可以自动更新"></a>导入的 APK 可以自动更新</h4><p>Android Studio 允许您导入外部构建的 APK 来调试和分析它们。以前，当对这些 APK 进行更改时，您必须再次手动导入它们并重新附加符号和源。Android Studio 3.6 现在会自动检测对导入的 APK 文件所做的更改，并为您提供就地重新导入该文件的选项。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="内存探查器中的泄漏检测"><a href="#内存探查器中的泄漏检测" class="headerlink" title="内存探查器中的泄漏检测"></a>内存探查器中的泄漏检测</h4><p>根据反馈，我们在内存探查器中添加了检测可能泄漏的活动和片段实例的能力。要开始使用，请在内存探查器中捕获或导入堆转储文件，并选中”活动/碎片泄漏”复选框以生成结果。有关 Android Studio 如何检测泄漏的详细信息，请参阅我们的文档。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111557.png" alt></p><h4 id="在-APK-分析器中去解类和方法字节码"><a href="#在-APK-分析器中去解类和方法字节码" class="headerlink" title="在 APK 分析器中去解类和方法字节码"></a>在 APK 分析器中去解类和方法字节码</h4><p>使用 APK 分析器检查 DEX 文件时，现在可以取消分类和方法字节码。在 DEX 文件查看器中，加载要分析的 APK 的 ProGuard 映射文件。加载后，您将能够通过选择”显示字节码”右键单击要检查的类或方法。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304111611.png" alt></p><h2 id="概括地说，Android-Studio-3-6-包括这些新的增强功能和功能"><a href="#概括地说，Android-Studio-3-6-包括这些新的增强功能和功能" class="headerlink" title="概括地说，Android Studio 3.6 包括这些新的增强功能和功能"></a>概括地说，Android Studio 3.6 包括这些新的增强功能和功能</h2><h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><ul><li>设计编辑器中的拆分视图</li><li>颜色选取器资源选项卡已</li></ul><h3 id="开发-1"><a href="#开发-1" class="headerlink" title="开发"></a>开发</h3><ul><li>视图绑定</li><li>NDK 修改</li><li>Intelli J平台更改</li><li>Add classes with Apply Changes</li></ul><h2 id="构建-1"><a href="#构建-1" class="headerlink" title="构建"></a>构建</h2><ul><li>Android Gradle Plugin (AGP) 升级</li><li>新的打包工具</li></ul><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><ul><li>Android模拟器Google Maps UI</li><li>多显示器支持</li><li>可恢复的SDK下载</li><li>导入的APK的就地更新</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>内存探查器中的泄漏检测<br> 在APK分析器中反混淆类和方法字节码<br> 将Kotlin来源附加到导入的APK</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>从下载页面下载 Android Studio 3.6。如果您使用的是早期版本的 Android Studio，则只需将其更新为最新版本的 Android Studio。要使用上述 Android Emulator 功能，请确保您至少运行通过 Android Studio SDK 管理器下载的 Android Emulator v29.2.12。</p><ul><li><a href="https://developer.android.com/studio" target="_blank" rel="noopener">Google 下载地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200304110901.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;如题，Android Studio 3.6 正式版终于发布了，值得兴奋呀，毕竟 3.5 大版本更新也已经差不多半年了，撒花撒花！这次更新又更新了什么呢？&lt;/p&gt;
&lt;p&gt;包括有设计、开发、构建、测试、优化等多方面，下面我们来看看 Release Notes 写了些什么吧！&lt;/p&gt;
&lt;h2 id=&quot;Release-Notes&quot;&gt;&lt;a href=&quot;#Release-Notes&quot; class=&quot;headerlink&quot; title=&quot;Release Notes&quot;&gt;&lt;/a&gt;Release Notes&lt;/h2&gt;&lt;p&gt;我们很高兴宣布 Android Studio 3.6 发布稳定版本了，该版本内有一些针对性的新特性，主要解决了在代码编辑和调试用例中的质量问题。这是我们在 Project Marble 结束之后的第一个版本，其重点是构建强大的集成开发环境（IDE）的基本功能和流。我们从 Project Marble 中学到了很多，在 Android Studio 3.6 中，我们引入了一小部分功能，完善的现有功能，并花费了很大的精力来解决错误并改善基础性能，以确保我们达到去年设定的高质量标准。&lt;/p&gt;
&lt;p&gt;Android Studio 3.6 的一些亮点包括一种使用 XML 快速设计、开发和预览应用布局的新方法，在设计编辑器中提供了新的拆分视图。此外，您不再需要手动键入 GPS 坐标来测试应用的位置，因为我们现在将 Google 地图直接嵌入到 Android 模拟器扩展控制面板中。最后，通过针对片段和活动的自动内存泄漏检测，我们简化了应用并查找 Bug。我们希望所有这些功能可以帮助您在 Android 上开发时更快乐、更高效。&lt;/p&gt;
&lt;p&gt;感谢在预览版中提供早期反馈的用户。您的反馈帮助我们迭代和改进 Android Studio 3.6 中的功能。如果您已准备好迎接下一个稳定版本，并且想要使用一组新的生产力功能，Android Studio 3.6 已准备好下载，以便您入门。&lt;/p&gt;
&lt;p&gt;以下是 Android Studio 3.6 中由主要开发人员流组织的全部新功能列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="Android Studio" scheme="https://zhangmiao.cc/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Flutter不能热加载，热重载按钮为灰色</title>
    <link href="https://zhangmiao.cc/posts/628bd6da.html"/>
    <id>https://zhangmiao.cc/posts/628bd6da.html</id>
    <published>2020-03-03T06:50:54.000Z</published>
    <updated>2020-03-03T07:08:57.468Z</updated>
    
    <content type="html"><![CDATA[<p>前言，Flutter的热重载(hot reload)功能可以帮助您在无需重新启动应用的情况下快速、轻松地进行测试、构建用户界面、添加功能以及修复错误。</p><p>通过将更新后的源代码文件注入正在运行的Dart虚拟机（VM）中来实现热重载。</p><p>在虚拟机使用新的的字段和函数更新类后，Flutter框架会自动重新构建widget树，以便您快速查看更改的效果。</p><p>要热重载一个Flutter应用程序:</p><ol><li>从受支持的IntelliJ IDE 、Android Studio 或终端窗口运行应用程序。物理机或虚拟器都可以运行。</li><li>修改项目中的一个Dart文件。大多数类型的代码更改可以重新加载; 有关需要完全重新启动的更改列表，请参阅<a href="https://flutterchina.club/hot-reload/#limitations" target="_blank" rel="noopener">限制</a>。</li><li>如果您使用的是IntelliJ IDE 、Android Studio ，请选择<strong>Save All</strong> (<code>cmd-s</code>/<code>ctrl-s</code>)），或者单击工具栏上的Hot Reload按钮。</li></ol><a id="more"></a><h1 id="一、现象："><a href="#一、现象：" class="headerlink" title="一、现象："></a>一、现象：</h1><p>Flutter 不能热加载 热重载按钮灰色，无法点击。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200303145348.png" alt></p><h1 id="二、分析原因："><a href="#二、分析原因：" class="headerlink" title="二、分析原因："></a>二、分析原因：</h1><p><code>终端</code>flutter doctor 显示 NO_PROXY is not set</p><p>没有设置无代理的端口</p><p><strong>➜</strong>  <span style="color:red"><strong>~</strong> flutter doctor       </span>                            </p><p>Doctor summary (to see all details, run flutter doctor -v):</p><p><span style="color:green">[✓] Flutter(Channel stable, v1.7.8, on Mac OS X 10.14.3 18D109, locale zh-Hans-CN)</span></p><p><span style="color:green">[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.1)</span></p><p><span style="color:green">[✓] Xcode - develop for iOS and macOS (Xcode 10.2.1)</span></p><p><span style="color:green">[✓] iOS tools - develop for iOS devices</span></p><p><span style="color:green">[✓] Android Studio (version 3.5)</span></p><p><span style="color:green">[✓] VS Code (version 1.41.1)</span></p><p><span style="color:orange">[!] Proxy Configuration</span></p><p>   <span style="color:orange"> <strong>!</strong> <strong>NO_PROXY is not set</strong></span></p><p><span style="color:green">[✓] Connected device (1 available) </span></p><p><span style="color:orange">! Doctor found issues in 1 category.</span></p><blockquote><p>重点在于：<strong>NO_PROXY is not set</strong></p></blockquote><h1 id="三、解决方案："><a href="#三、解决方案：" class="headerlink" title="三、解决方案："></a>三、解决方案：</h1><p>设置 <strong>NO_PROXY即可</strong></p><p>1.启动终端</p><p>2.进入当前用户的home目录</p><p>cd ~ 或者  cd /users/YourMacUserName</p><p>3.输入touch .bash_profile</p><p>查看和编辑.bash_profile文件</p><p>1.终端输入open -e .bash_profile</p><p>2.编辑文件，新增 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">"localhost,127.0.0.1"</span></span><br></pre></td></tr></table></figure><p>3.关闭保存</p><p>最后更新配置的环境变量</p><p>输入: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure><p>不懂这块的话，看这里<a href="https://www.cnblogs.com/jukaiit/p/10785318.html" target="_blank" rel="noopener">设置Mac 终端走代理</a></p><p>操作如下：</p><p><strong>➜</strong>  <span style="color:red"><strong>~</strong> cd ~ </span></p><p><strong>➜</strong>  <span style="color:red"><strong>~</strong> touch .bash_profile</span></p><p><strong>➜</strong>  <span style="color:red"><strong>~</strong> open -e .bash_profile</span></p><p><strong>➜</strong>  <span style="color:red"><strong>~</strong> source .bash_profile</span></p><p><strong>➜</strong>  <span style="color:red"><strong>~</strong> flutter doctor </span>                      </p><p>Doctor summary (to see all details, run flutter doctor -v):</p><p><span style="color:green">[✓] Flutter (Channel stable, v1.7.8, on Mac OS X 10.14.3 18D109, locale zh-Hans-CN)</span></p><p><span style="color:green">[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.1)</span></p><p><span style="color:green">[✓] Xcode - develop for iOS and macOS (Xcode 10.2.1)</span></p><p><span style="color:green">[✓] iOS tools - develop for iOS devices</span></p><p><span style="color:green">[✓] Android Studio (version 3.5)</span></p><p><span style="color:green">[✓] VS Code (version 1.41.1)</span></p><p><span style="color:green">[✓] Proxy Configuration</span></p><p><span style="color:green">[✓] Connected device (1 available)</span></p><p><span style="color:green">• No issues found!</span></p><p><strong>➜</strong>  <strong>~</strong> </p><h1 id="四、验证"><a href="#四、验证" class="headerlink" title="四、验证"></a>四、验证</h1><p>运行时，热重载按钮变为橙色，可以点击。</p><p>快捷键保存编辑时，自动重载。</p><p> <img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200303145307.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言，Flutter的热重载(hot reload)功能可以帮助您在无需重新启动应用的情况下快速、轻松地进行测试、构建用户界面、添加功能以及修复错误。&lt;/p&gt;
&lt;p&gt;通过将更新后的源代码文件注入正在运行的Dart虚拟机（VM）中来实现热重载。&lt;/p&gt;
&lt;p&gt;在虚拟机使用新的的字段和函数更新类后，Flutter框架会自动重新构建widget树，以便您快速查看更改的效果。&lt;/p&gt;
&lt;p&gt;要热重载一个Flutter应用程序:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从受支持的IntelliJ IDE 、Android Studio 或终端窗口运行应用程序。物理机或虚拟器都可以运行。&lt;/li&gt;
&lt;li&gt;修改项目中的一个Dart文件。大多数类型的代码更改可以重新加载; 有关需要完全重新启动的更改列表，请参阅&lt;a href=&quot;https://flutterchina.club/hot-reload/#limitations&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;限制&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果您使用的是IntelliJ IDE 、Android Studio ，请选择&lt;strong&gt;Save All&lt;/strong&gt; (&lt;code&gt;cmd-s&lt;/code&gt;/&lt;code&gt;ctrl-s&lt;/code&gt;)），或者单击工具栏上的Hot Reload按钮。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>SourceTree_push_remote:Invalid_username_or_password.</title>
    <link href="https://zhangmiao.cc/posts/44ceee89.html"/>
    <id>https://zhangmiao.cc/posts/44ceee89.html</id>
    <published>2020-02-27T06:08:16.000Z</published>
    <updated>2020-02-27T06:27:08.514Z</updated>
    
    <content type="html"><![CDATA[<p>在网络里面移除就行了· 再推就会要你重新输入了。<br>有点不人性化， mark 一下。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/WechatIMG196212.png" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络里面移除就行了· 再推就会要你重新输入了。&lt;br&gt;有点不人性化， mark 一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/WechatIMG196212.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂 Android Debug 调试</title>
    <link href="https://zhangmiao.cc/posts/a9889f48.html"/>
    <id>https://zhangmiao.cc/posts/a9889f48.html</id>
    <published>2020-02-27T05:47:43.000Z</published>
    <updated>2020-02-27T06:08:37.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、打上断点，启动debug模式"><a href="#一、打上断点，启动debug模式" class="headerlink" title="一、打上断点，启动debug模式"></a>一、打上断点，启动debug模式</h2><p>首先在我们需要打断点的代码行数上稍微偏右，点击鼠标左键，如图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227134850.png" alt></p><p> 点击小爬虫按钮，启动debug模式。 </p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227134905.png" alt></p><p> 运行成功后如下。可以看到红色框内，从下往上的顺序运行方法，一直阻塞在我们打断点的方法里；绿色款内，则是展示目前阻塞方法内变量和参数的数值。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227134915.png" alt></p><a id="more"></a><h2 id="二、接下来，我们一起分解debug的每个按钮操作"><a href="#二、接下来，我们一起分解debug的每个按钮操作" class="headerlink" title="二、接下来，我们一起分解debug的每个按钮操作"></a>二、接下来，我们一起分解debug的每个按钮操作</h2><h3 id="2-1、Step-Over（F8）"><a href="#2-1、Step-Over（F8）" class="headerlink" title="2.1、Step Over（F8）"></a>2.1、Step Over（F8）</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227134934.png" alt></p><p>这个按钮的意思：程序向下一步执行，但是要注意，这个按钮不会主动进入方法体内，而是会直接运行完整个方法后直接运行下一步。<br>例如：我当前运行的debug，如果一直点击这个按钮的话，他会在onCreate()方法内，执行完add(),再执行完sub(),然后直接结束，并不会进add和sub方法内去打印。 </p><h3 id="2-2、Step-Into（F7）"><a href="#2-2、Step-Into（F7）" class="headerlink" title="2.2、Step Into（F7）"></a>2.2、Step Into（F7）</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135110.png" alt></p><p> 这个按钮的意思：程序向下一步执行，和Step Over的区别是如果该行有方法调用且为自定义方法，则运行进入自定义方法（不会进入官方类库的方法）。 </p><p>例如：我当前运行的debug，如果你想进入到add()方法里，那么点击Step Into。假如我的add()方法里，还调用了其他的自定义方法，如果此时你都想进入各个方法查看则继续用Step Into，假如你只想停留在add()方法里，其他方法只需要得到个返回值的话，这个时候应该用Step Over; </p><h3 id="2-3、Force-Step-Into"><a href="#2-3、Force-Step-Into" class="headerlink" title="2.3、Force Step Into"></a>2.3、Force Step Into</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135124.png" alt></p><p> 从字面意思上你也能看得出来：可以进入包括官方类库在内的任何方法。一般我认为这个比较适合研究源码。 </p><h3 id="2-4、Step-out"><a href="#2-4、Step-out" class="headerlink" title="2.4、Step out"></a>2.4、Step out</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135138.png" alt></p><p> 假如此时调试在add()方法里，如果我们觉得add()方法没有问题，想跳出这个方法继续debug其他断点时，那么点击Step out，跳出该方法。 </p><h3 id="2-5、Run-to-Cursor"><a href="#2-5、Run-to-Cursor" class="headerlink" title="2.5、Run to Cursor"></a>2.5、Run to Cursor</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135156.png" alt></p><p> 从字面意思上看，他是移动到下个断点的意思。经过测试如下:</p><blockquote><p>1、假如在我们当前运行的debug，如果还在onCreate()方法内，当前断点在add()方法时，点击Run to Cursor，断点确实会移动到下个断点停留在sub()方法。</p></blockquote><blockquote><p>2、如果此时我们已经进入到add()方法体内，点击Run to Cursor,我们会看到，他只是运行完一次for循环后，继续堵塞。如下图：</p></blockquote><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135207.png" alt></p><p> 所以我总结为，Run to Cursor是在当前方法体内，运行到下一个断点。（如果有误，请大佬及时纠正）； </p><p>那么此时，如果我们已经在add()方法内，就是想直接运行到下个断点sub()上，怎么操作呢？点击Resume Program </p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135219.png" alt></p><p> 这个按钮不会管你在不在方法内，直接回到下一步断点上。 </p><h2 id="三、Debug进阶用法。"><a href="#三、Debug进阶用法。" class="headerlink" title="三、Debug进阶用法。"></a>三、Debug进阶用法。</h2><h3 id="3-1、Watches"><a href="#3-1、Watches" class="headerlink" title="3.1、Watches"></a>3.1、Watches</h3><p>如果我们在debug的时候，可能会出现很多变量，而我们就想观察那么几个变量。我们可以把他加到watches里。比如我add()方法里的变量i，</p><blockquote><p>方法1：在我们观察的Variables里，找到那个变量右键，选择Add to Watches</p></blockquote><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135231.png" alt></p><blockquote><p>方法2：在我们的Watches界面，点击+号，在输入框内，输入i，进行搜索，也能添加到Watches，方便我们debug调试</p></blockquote><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135254.png" alt></p><h3 id="3-2、Set-Value"><a href="#3-2、Set-Value" class="headerlink" title="3.2、Set Value"></a>3.2、Set Value</h3><p>比如在我们的add()方法里，有一个for循环，正常调试是每次都会从i=0的时候进行调试，如果我们想直接从i=5的时候进行调试，那么我们可以在Variables界面，找到那个变量值，右键选择Set Value后，输入我们5，就能跳过前几次循环。 </p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135308.png" alt></p><h3 id="3-3、查看所有断点"><a href="#3-3、查看所有断点" class="headerlink" title="3.3、查看所有断点"></a>3.3、查看所有断点</h3><p>开发中你打了很多断点忘记取消的情况下，你可以点击View Breakpoints查看所有断点 </p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135319.png" alt></p><p> 打开如下界面：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135330.png" alt></p><h3 id="3-4、停止debug调试"><a href="#3-4、停止debug调试" class="headerlink" title="3.4、停止debug调试"></a>3.4、停止debug调试</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135344.png" alt></p><h3 id="3-5、已经运行的程序，避免重新运行程序的情况下，怎么添加debug调试。"><a href="#3-5、已经运行的程序，避免重新运行程序的情况下，怎么添加debug调试。" class="headerlink" title="3.5、已经运行的程序，避免重新运行程序的情况下，怎么添加debug调试。"></a>3.5、已经运行的程序，避免重新运行程序的情况下，怎么添加debug调试。</h3><p>这里多说几句，因为是在已经运行的程序上，添加debug调试，那么比如进入一个页面，onCreate()方法里的代码，都已经全部执行完了，比如我们点击一个按钮，需要运行的方法，在这个方法里我们才能添加debug调试。比如首先是一个正常运行的程序，我们给点击事件里加断点。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135357.png" alt></p><p>然后，点击Attach Debugger to Android Process</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135433.png" alt></p><p>弹出如下页面，点击OK就行了，点击按钮就能进行debug调试了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227135420.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、打上断点，启动debug模式&quot;&gt;&lt;a href=&quot;#一、打上断点，启动debug模式&quot; class=&quot;headerlink&quot; title=&quot;一、打上断点，启动debug模式&quot;&gt;&lt;/a&gt;一、打上断点，启动debug模式&lt;/h2&gt;&lt;p&gt;首先在我们需要打断点的代码行数上稍微偏右，点击鼠标左键，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227134850.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt; 点击小爬虫按钮，启动debug模式。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227134905.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt; 运行成功后如下。可以看到红色框内，从下往上的顺序运行方法，一直阻塞在我们打断点的方法里；绿色款内，则是展示目前阻塞方法内变量和参数的数值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20200227134915.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android跳转到应用商店详情页面</title>
    <link href="https://zhangmiao.cc/posts/916b091e.html"/>
    <id>https://zhangmiao.cc/posts/916b091e.html</id>
    <published>2020-01-09T07:08:58.000Z</published>
    <updated>2020-01-09T11:04:03.190Z</updated>
    
    <content type="html"><![CDATA[<p>Android应用开发过程中，可能会有需求，比如：推广时跳转到应用市场下载应用，跳转到应用市场给自己的应用打分，跳转到应用市场更新自己的应用。那如何跳转到应用市场呢？</p><p>可能跳转的方法大家都是知道的，方法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> goToMarket(Context context, <span class="built_in">String</span> packageName) &#123;</span><br><span class="line">    <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"market://details?id="</span> + packageName);</span><br><span class="line">    Intent goToMarket = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        context.startActivity(goToMarket);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法支持应用宝、360手机助手、豌豆荚、小米商店等主流的应用市场，当手机上面装有多个应用市场时，则会弹出菜单让用户选择调转到哪个市场。那么，问题来了，如果这么简单就结束了，怎么还会有这篇文章呢？<br> 在红米Note2上测试时发现，调用此方法默认是直接调转到小米市场，那如果在小米手机上，想要跳转到应用宝或者其他的应用市场怎么办呢，方法自然是有的，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> goToMarket(Context context, <span class="built_in">String</span> packageName) &#123;</span><br><span class="line">    <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"market://details?id="</span> + packageName);</span><br><span class="line">    Intent goToMarket = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        goToMarket.setClassName(<span class="string">"com.tencent.android.qqdownloader"</span>, <span class="string">"com.tencent.pangu.link.LinkProxyActivity"</span>);</span><br><span class="line">        context.startActivity(goToMarket);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>看起来好像和第一个方法没什么区别，是的，只需要给多调用goToMarket.setClassName()方法，设置指定的应用去处理这个Intent事件，这样就可以在小米手机上跳转到应用宝的应用详情页面，而且，上一个方法如果在手机上装有多个应用市场时，会弹出菜单让用户选择，如果已经确定好要跳转到哪个应用市场时，也可使用此方法，直接跳转，省去中间用户选择的环节。<br> 但是上面方法的思路似乎并不能对所有的应用市场有效，哪天产品经理提出要跳转到三星的应用市场，毕竟三星手机在国内的占有率还是排前几位的，再使用上面的方法，发现懵逼了，三星市场竟然不支持这种方式，难怪三星手机在国内市场节节败退。不过再笔者的努力下终于找到了如下方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> goToSamsungappsMarket(Context context, <span class="built_in">String</span> packageName) &#123;</span><br><span class="line">    <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"http://www.samsungapps.com/appquery/appDetail.as?appId="</span> + packageName);</span><br><span class="line">    Intent goToMarket = <span class="keyword">new</span> Intent();</span><br><span class="line">    goToMarket.setClassName(<span class="string">"com.sec.android.app.samsungapps"</span>, <span class="string">"com.sec.android.app.samsungapps.Main"</span>);</span><br><span class="line">    goToMarket.setData(uri);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        context.startActivity(goToMarket);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，后来发现在乐视手机上面，乐视的应用市场也是不支持goToMarket()方法的，所以又专门调研了跳转乐视应用市场的方法，方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goToLeTVStoreDetail</span><span class="params">(Context context, String packageName)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setClassName(<span class="string">"com.letv.app.appstore"</span>, <span class="string">"com.letv.app.appstore.appmodule.details.DetailsActivity"</span>);</span><br><span class="line">        intent.setAction(<span class="string">"com.letv.app.appstore.appdetailactivity"</span>);</span><br><span class="line">        intent.putExtra(<span class="string">"packageName"</span>, packageName);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上方法，希望能帮助到有需要的人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳转到谷歌应用市场</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goToGoogleMarket</span><span class="params">(Context context, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"market://details?id="</span> + packageName));</span><br><span class="line">        intent.setPackage(<span class="string">"com.android.vending"</span>);<span class="comment">//这里对应的是谷歌商店，跳转别的商店改成对应的即可</span></span><br><span class="line">        <span class="keyword">if</span> (intent.resolveActivity(context.getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            context.startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有应用市场，通过浏览器跳转到Google Play</span></span><br><span class="line">            Intent intent2 = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">            intent2.setData(Uri.parse(<span class="string">"https://play.google.com/store/apps/details?id="</span> + packageName));</span><br><span class="line">            <span class="keyword">if</span> (intent2.resolveActivity(context.getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.startActivity(intent2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有Google Play 也没有浏览器</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳转到三星应用市场</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goToSamsungappsMarket</span><span class="params">(Context context, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Uri uri = Uri.parse(<span class="string">"http://www.samsungapps.com/appquery/appDetail.as?appId="</span> + packageName);</span><br><span class="line">        Intent goToMarket = <span class="keyword">new</span> Intent();</span><br><span class="line">        goToMarket.setClassName(<span class="string">"com.sec.android.app.samsungapps"</span>, <span class="string">"com.sec.android.app.samsungapps.Main"</span>);</span><br><span class="line">        goToMarket.setData(uri);</span><br><span class="line">        context.startActivity(goToMarket);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android应用开发过程中，可能会有需求，比如：推广时跳转到应用市场下载应用，跳转到应用市场给自己的应用打分，跳转到应用市场更新自己的应用。那如何跳转到应用市场呢？&lt;/p&gt;
&lt;p&gt;可能跳转的方法大家都是知道的，方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; goToMarket(Context context, &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; packageName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt; uri = &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt;.parse(&lt;span class=&quot;string&quot;&gt;&quot;market://details?id=&quot;&lt;/span&gt; + packageName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Intent goToMarket = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_VIEW, uri);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        context.startActivity(goToMarket);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ActivityNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;此方法支持应用宝、360手机助手、豌豆荚、小米商店等主流的应用市场，当手机上面装有多个应用市场时，则会弹出菜单让用户选择调转到哪个市场。那么，问题来了，如果这么简单就结束了，怎么还会有这篇文章呢？&lt;br&gt; 在红米Note2上测试时发现，调用此方法默认是直接调转到小米市场，那如果在小米手机上，想要跳转到应用宝或者其他的应用市场怎么办呢，方法自然是有的，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; goToMarket(Context context, &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; packageName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt; uri = &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt;.parse(&lt;span class=&quot;string&quot;&gt;&quot;market://details?id=&quot;&lt;/span&gt; + packageName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Intent goToMarket = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_VIEW, uri);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        goToMarket.setClassName(&lt;span class=&quot;string&quot;&gt;&quot;com.tencent.android.qqdownloader&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;com.tencent.pangu.link.LinkProxyActivity&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        context.startActivity(goToMarket);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ActivityNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>TextView字体大小自适应</title>
    <link href="https://zhangmiao.cc/posts/14fca390.html"/>
    <id>https://zhangmiao.cc/posts/14fca390.html</id>
    <published>2019-11-28T08:05:49.000Z</published>
    <updated>2019-11-28T08:07:03.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在进行android 开发过程中，会遇到TextView 中文本显示不全的情况，这个时候想根据文本的长度自动改变字体大小，首先想到的时候自定义View ，但是呢在Android O 中已经提供了实现方式，并且拥有兼容库，最低支持到API 14,这瞬间就爽到我了，不多BB 了，直接看实现。</p><h2 id="重点注意："><a href="#重点注意：" class="headerlink" title="重点注意："></a>重点注意：</h2><p>如果代码中设置了以下的代码，不生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:singleLine=<span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>必须设置的属性是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:maxLines=<span class="string">"1"</span></span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>没有效果图，如果你用过今日头条添加频道的话，这里就不会骂我了。</p><h2 id="通过代码方式"><a href="#通过代码方式" class="headerlink" title="通过代码方式"></a>通过代码方式</h2><p>在代码中调用函数 setAutoSizeTextTypeWithDefaults(@AutoSizeTextType int autoSizeTextType) 并指定参数为 AUTO_SIZE_TEXT_TYPE_UNIFORM来设置默认值。如果你不想启用自动调整字体大小的功能，则可以设置参数为 AUTO_SIZE_TEXT_TYPE_NONE.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM);</span><br></pre></td></tr></table></figure><p>或者设置粒度（设置最大只和最小值，并且指定每次调整的增量值）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//autoSizeMinTextSize 最小值；autoSizeMaxTextSize：最大值；autoSizeStepGranularity：增量；unit：类型，此处指定的是sp</span></span><br><span class="line">textView.setAutoSizeTextTypeUniformWithConfiguration(<span class="number">10</span>,<span class="number">17</span>,<span class="number">1</span>,TypedValue.COMPLEX_UNIT_SP);</span><br></pre></td></tr></table></figure><h2 id="通过xml-方式-推荐的方式"><a href="#通过xml-方式-推荐的方式" class="headerlink" title="通过xml 方式(推荐的方式)"></a>通过xml 方式(推荐的方式)</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">        android:<span class="keyword">id</span>=<span class="string">"@+id/title"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">        app:autoSizeTextType=<span class="string">"uniform"</span></span><br><span class="line">        app:autoSizeMinTextSize=<span class="string">"3sp"</span></span><br><span class="line">        app:autoSizeMaxTextSize=<span class="string">"15sp"</span></span><br><span class="line">        app:autoSizeStepGranularity=<span class="string">"1sp"</span></span><br><span class="line">        android:maxLines=<span class="string">"1"</span>/&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;在进行android 开发过程中，会遇到TextView 中文本显示不全的情况，这个时候想根据文本的长度自动改变字体大小，首先想到的时候自定义View ，但是呢在Android O 中已经提供了实现方式，并且拥有兼容库，最低支持到API 14,这瞬间就爽到我了，不多BB 了，直接看实现。&lt;/p&gt;
&lt;h2 id=&quot;重点注意：&quot;&gt;&lt;a href=&quot;#重点注意：&quot; class=&quot;headerlink&quot; title=&quot;重点注意：&quot;&gt;&lt;/a&gt;重点注意：&lt;/h2&gt;&lt;p&gt;如果代码中设置了以下的代码，不生效。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android:singleLine=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;必须设置的属性是：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android:maxLines=&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;p&gt;没有效果图，如果你用过今日头条添加频道的话，这里就不会骂我了。&lt;/p&gt;
&lt;h2 id=&quot;通过代码方式&quot;&gt;&lt;a href=&quot;#通过代码方式&quot; class=&quot;headerlink&quot; title=&quot;通过代码方式&quot;&gt;&lt;/a&gt;通过代码方式&lt;/h2&gt;&lt;p&gt;在代码中调用函数 setAutoSizeTextTypeWithDefaults(@AutoSizeTextType int autoSizeTextType) 并指定参数为 AUTO_SIZE_TEXT_TYPE_UNIFORM来设置默认值。如果你不想启用自动调整字体大小的功能，则可以设置参数为 AUTO_SIZE_TEXT_TYPE_NONE.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;textView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;或者设置粒度（设置最大只和最小值，并且指定每次调整的增量值）：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//autoSizeMinTextSize 最小值；autoSizeMaxTextSize：最大值；autoSizeStepGranularity：增量；unit：类型，此处指定的是sp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;textView.setAutoSizeTextTypeUniformWithConfiguration(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,TypedValue.COMPLEX_UNIT_SP);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;通过xml-方式-推荐的方式&quot;&gt;&lt;a href=&quot;#通过xml-方式-推荐的方式&quot; class=&quot;headerlink&quot; title=&quot;通过xml 方式(推荐的方式)&quot;&gt;&lt;/a&gt;通过xml 方式(推荐的方式)&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;TextView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@+id/title&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_width=&lt;span class=&quot;string&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_height=&lt;span class=&quot;string&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:gravity=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_gravity=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:autoSizeTextType=&lt;span class=&quot;string&quot;&gt;&quot;uniform&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:autoSizeMinTextSize=&lt;span class=&quot;string&quot;&gt;&quot;3sp&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:autoSizeMaxTextSize=&lt;span class=&quot;string&quot;&gt;&quot;15sp&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:autoSizeStepGranularity=&lt;span class=&quot;string&quot;&gt;&quot;1sp&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:maxLines=&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android中常用的加密方式</title>
    <link href="https://zhangmiao.cc/posts/caa299cc.html"/>
    <id>https://zhangmiao.cc/posts/caa299cc.html</id>
    <published>2019-11-27T03:02:21.000Z</published>
    <updated>2019-11-27T03:03:26.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Rsa加密"><a href="#一、Rsa加密" class="headerlink" title="一、Rsa加密"></a>一、Rsa加密</h2><h3 id="1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；"><a href="#1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；" class="headerlink" title="1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；"></a>1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；</h3><h3 id="2、算法原理："><a href="#2、算法原理：" class="headerlink" title="2、算法原理："></a>2、算法原理：</h3><p>1）、随机产生两个大的质数m、n且m！=n，计算K1=mn；<br> 2)、选择一个大于1小于k1的自然数k2，k2必须与(m-1)(n-1)互为素数；<br> 3)、计算得到d—&gt;d x k2=1(mod(m-1)(n-1));<br> 4)、销毁mn；<br> 最终产生的k1和k2为“公钥”，d为“私钥”，发送方使用k1进行加密，接收方使用d进行解密。</p><h3 id="3、注意："><a href="#3、注意：" class="headerlink" title="3、注意："></a>3、注意：</h3><p>1、RSA的安全性依赖于大数分解，小于1024位的k1被认为是不安全的；<br> 2、RSA的计算速度慢。</p><h3 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h3><p>1、生成密钥对</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机生成RSA密钥对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param keyLength 密钥长度，范围：512～2048</span></span><br><span class="line"><span class="comment"> *                  一般1024</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> KeyPair generateRSAKeyPair(<span class="built_in">int</span> keyLength) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        KeyPairGenerator kpg = KeyPairGenerator.getInstance(RSA);</span><br><span class="line">        kpg.initialize(keyLength);</span><br><span class="line">        <span class="keyword">return</span> kpg.genKeyPair();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、公钥加密</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用公钥对字符串进行加密</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param data 原文</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">encryptByPublicKey</span>(<span class="params"><span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] publicKey</span>) throws Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 得到公钥</span></span><br><span class="line">      X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(publicKey);</span><br><span class="line">      KeyFactory kf = KeyFactory.getInstance(RSA);</span><br><span class="line">      PublicKey keyPublic = kf.generatePublic(keySpec);</span><br><span class="line">      <span class="comment">// 加密数据</span></span><br><span class="line">      Cipher cp = Cipher.getInstance(ECB_PKCS1_PADDING);</span><br><span class="line">      cp.init(Cipher.ENCRYPT_MODE, keyPublic);</span><br><span class="line">      <span class="keyword">return</span> cp.doFinal(data);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、私钥加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 加密数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptByPrivateKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 得到私钥</span></span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(privateKey);</span><br><span class="line">        KeyFactory kf = KeyFactory.getInstance(RSA);</span><br><span class="line">        PrivateKey keyPrivate = kf.generatePrivate(keySpec);</span><br><span class="line">        <span class="comment">// 数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keyPrivate);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有加密自然也得有解密<br> 1、公钥解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 公钥解密</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data      待解密数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> publicKey 密钥</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> byte[] 解密数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPublicKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] publicKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 得到公钥</span></span><br><span class="line">       X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(publicKey);</span><br><span class="line">       KeyFactory kf = KeyFactory.getInstance(RSA);</span><br><span class="line">       PublicKey keyPublic = kf.generatePublic(keySpec);</span><br><span class="line">       <span class="comment">// 数据解密</span></span><br><span class="line">       Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING);</span><br><span class="line">       cipher.init(Cipher.DECRYPT_MODE, keyPublic);</span><br><span class="line">       <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2、私钥解密</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用私钥进行解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">decryptByPrivateKey</span>(<span class="params"><span class="keyword">byte</span>[] encrypted, <span class="keyword">byte</span>[] privateKey</span>) throws Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 得到私钥</span></span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(privateKey);</span><br><span class="line">        KeyFactory kf = KeyFactory.getInstance(RSA);</span><br><span class="line">        PrivateKey keyPrivate = kf.generatePrivate(keySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解密数据</span></span><br><span class="line">        Cipher cp = Cipher.getInstance(ECB_PKCS1_PADDING);</span><br><span class="line">        cp.init(Cipher.DECRYPT_MODE, keyPrivate);</span><br><span class="line">        <span class="keyword">byte</span>[] arr = cp.doFinal(encrypted);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用到的全局变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非对称加密密钥算法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RSA = <span class="string">"RSA"</span>;</span><br><span class="line">   <span class="comment">//加密填充方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ECB_PKCS1_PADDING = <span class="string">"RSA/ECB/PKCS1Padding"</span>;</span><br><span class="line">   <span class="comment">//秘钥默认长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line">   <span class="comment">// 当要加密的内容超过bufferSize，则采用partSplit进行分块加密</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] DEFAULT_SPLIT = <span class="string">"#PART#"</span>.getBytes();  </span><br><span class="line">    <span class="comment">// 当前秘钥支持加密的最大字节数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_BUFFERSIZE = (DEFAULT_KEY_SIZE / <span class="number">8</span>) - <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>关于加密填充方式：之前以为上面这些操作就能实现rsa加解密，以为万事大吉了，呵呵，这事还没完，悲剧还是发生了，Android这边加密过的数据，服务器端死活解密不了，<code>原来android系统的RSA实现是&quot;RSA/None/NoPadding&quot;，而标准JDK实现是&quot;RSA/None/PKCS1Padding&quot;</code>，这造成了在android机上加密后无法在服务器上解密的原因，所以在实现的时候这个一定要注意。</p><h2 id="二、DES加密"><a href="#二、DES加密" class="headerlink" title="二、DES加密"></a>二、DES加密</h2><h3 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h3><p>DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法。DES加密算法出自IBM的研究，后来被美国政府正式采用，之后开始广泛流传，但是近些年使用越来越少，因为DES使用56位密钥，以现代计算能力，24小时内即可被破解。</p><h4 id="划重点-：DES不太安全。"><a href="#划重点-：DES不太安全。" class="headerlink" title="划重点 ：DES不太安全。"></a>划重点 ：DES不太安全。</h4><h3 id="2、静态秘钥DES加密方式使用"><a href="#2、静态秘钥DES加密方式使用" class="headerlink" title="2、静态秘钥DES加密方式使用"></a>2、静态秘钥DES加密方式使用</h3><p>1）、DES加密代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *DES 加密</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param message 原文</span></span><br><span class="line"><span class="comment">    * @param key     密钥,长度不能够小于8位</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * @throws Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   public <span class="keyword">static</span> <span class="built_in">String</span> desEncrypt(<span class="built_in">String</span> message, <span class="built_in">String</span> key) throws Exception &#123;</span><br><span class="line">       Cipher cipher = Cipher.getInstance(<span class="string">"DES/CBC/PKCS5Padding"</span>);</span><br><span class="line">       DESKeySpec desKeySpec = <span class="keyword">new</span> DESKeySpec(key.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">       SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">       SecretKey secretKey = keyFactory.generateSecret(desKeySpec);</span><br><span class="line">       IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(key.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">       cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);</span><br><span class="line">       byte[] encryptbyte = cipher.doFinal(message.getBytes());</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>(Base64.encode(encryptbyte, Base64.DEFAULT)).trim();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2、DES解密代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param message 密文</span></span><br><span class="line"><span class="comment">     * @param key     密钥,长度不能够小于8位</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> desDecrypt(<span class="built_in">String</span> message, <span class="built_in">String</span> key) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        byte[] bytesrc = Base64.decode(message.getBytes(), Base64.DEFAULT);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"DES/CBC/PKCS5Padding"</span>);</span><br><span class="line">        DESKeySpec desKeySpec = <span class="keyword">new</span> DESKeySpec(key.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">        SecretKey secretKey = keyFactory.generateSecret(desKeySpec);</span><br><span class="line">        IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(key.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);</span><br><span class="line">        byte[] retByte = cipher.doFinal(bytesrc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>(retByte);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、动态秘钥加密方式"><a href="#3、动态秘钥加密方式" class="headerlink" title="3、动态秘钥加密方式"></a>3、动态秘钥加密方式</h3><p>1、DES加密常用的常量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> private <span class="keyword">final</span> <span class="keyword">static</span> <span class="built_in">String</span> HEX = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line"> <span class="comment">//DES是加密方式 CBC是工作模式 PKCS5Padding是填充模式</span></span><br><span class="line"> private <span class="keyword">final</span> <span class="keyword">static</span> <span class="built_in">String</span> TRANSFORMATION = <span class="string">"DES/CBC/PKCS5Padding"</span>;</span><br><span class="line"> <span class="comment">//初始化向量参数，AES 为16bytes. DES 为8bytes.</span></span><br><span class="line"> private <span class="keyword">final</span> <span class="keyword">static</span> <span class="built_in">String</span> IVPARAMETERSPEC = <span class="string">"01020304"</span>;</span><br><span class="line"> <span class="comment">//DES是加密方式</span></span><br><span class="line"> private <span class="keyword">final</span> <span class="keyword">static</span> <span class="built_in">String</span> ALGORITHM = <span class="string">"DES"</span>;</span><br><span class="line"><span class="comment">// SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法</span></span><br><span class="line"> private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> SHA1PRNG = <span class="string">"SHA1PRNG"</span>;</span><br></pre></td></tr></table></figure><p>2、动态生成秘钥</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 生成随机数，可以当做动态的密钥 加密和解密的密钥必须一致，不然将不能解密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateKey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           SecureRandom localSecureRandom = SecureRandom.getInstance(SHA1PRNG);</span><br><span class="line">           <span class="keyword">byte</span>[] bytes_key = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">           localSecureRandom.nextBytes(bytes_key);</span><br><span class="line">           String str_key = toHex(bytes_key);</span><br><span class="line">           <span class="keyword">return</span> str_key;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//二进制转字符</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHex</span>(<span class="params"><span class="keyword">byte</span>[] buf</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (buf == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       StringBuffer result = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * buf.length);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">           appendHex(result, buf[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result.toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHex</span>(<span class="params">StringBuffer sb, <span class="keyword">byte</span> b</span>) </span>&#123;</span><br><span class="line">       sb.append(HEX.charAt((b &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>)).append(HEX.charAt(b &amp; <span class="number">0x0f</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>3、处理秘钥<br> 方式一、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对密钥进行处理</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Key <span class="title">getRawKey</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      KeyGenerator kgen = KeyGenerator.getInstance(ALGORITHM);</span><br><span class="line">      <span class="comment">//for android</span></span><br><span class="line">      SecureRandom sr = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 在4.2以上版本中，SecureRandom获取方式发生了改变</span></span><br><span class="line">      <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= <span class="number">17</span>) &#123;</span><br><span class="line">          sr = SecureRandom.getInstance(SHA1PRNG, <span class="string">"Crypto"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sr = SecureRandom.getInstance(SHA1PRNG);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// for Java</span></span><br><span class="line">      <span class="comment">// secureRandom = SecureRandom.getInstance(SHA1PRNG);</span></span><br><span class="line">      sr.setSeed(key.getBytes());</span><br><span class="line">      kgen.init(<span class="number">64</span>, sr); <span class="comment">//DES固定格式为64bits，即8bytes。</span></span><br><span class="line">      SecretKey skey = kgen.generateKey();</span><br><span class="line">      <span class="keyword">byte</span>[] raw = skey.getEncoded();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(raw, ALGORITHM);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ 对密钥进行处理</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Key <span class="title">getRawKey</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DESKeySpec dks = <span class="keyword">new</span> DESKeySpec(key.getBytes());</span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generateSecret(dks);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、加密实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES算法，加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param data 待加密字符串</span></span><br><span class="line"><span class="comment">     * @param key  加密私钥，长度不能够小于8位</span></span><br><span class="line"><span class="comment">     * @return 加密后的字节数组，一般结合Base64编码使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> encode(<span class="built_in">String</span> key, <span class="built_in">String</span> data) &#123;</span><br><span class="line">        <span class="keyword">return</span> encode(key, data.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES算法，加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param data 待加密字符串</span></span><br><span class="line"><span class="comment">     * @param key  加密私钥，长度不能够小于8位</span></span><br><span class="line"><span class="comment">     * @return 加密后的字节数组，一般结合Base64编码使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> encode(<span class="built_in">String</span> key, byte[] data) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(TRANSFORMATION);</span><br><span class="line">            IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(IVPARAMETERSPEC.getBytes());</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, getRawKey(key), iv);</span><br><span class="line">            byte[] bytes = cipher.doFinal(data);</span><br><span class="line">            <span class="keyword">return</span> Base64.encodeToString(bytes, Base64.DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>5、解密实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取编码后的值</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key</span></span><br><span class="line"><span class="comment">    * @param data</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   public <span class="keyword">static</span> <span class="built_in">String</span> decode(<span class="built_in">String</span> key, <span class="built_in">String</span> data) &#123;</span><br><span class="line">       <span class="keyword">return</span> decode(key, Base64.decode(data, Base64.DEFAULT));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * DES算法，解密</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param data 待解密字符串</span></span><br><span class="line"><span class="comment">    * @param key  解密私钥，长度不能够小于8位</span></span><br><span class="line"><span class="comment">    * @return 解密后的字节数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   public <span class="keyword">static</span> <span class="built_in">String</span> decode(<span class="built_in">String</span> key, byte[] data) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Cipher cipher = Cipher.getInstance(TRANSFORMATION);</span><br><span class="line">           IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(IVPARAMETERSPEC.getBytes());</span><br><span class="line">           cipher.init(Cipher.DECRYPT_MODE, getRawKey(key), iv);</span><br><span class="line">           byte[] original = cipher.doFinal(data);</span><br><span class="line">           <span class="built_in">String</span> originalString = <span class="keyword">new</span> <span class="built_in">String</span>(original);</span><br><span class="line">           <span class="keyword">return</span> originalString;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="三、AES加密"><a href="#三、AES加密" class="headerlink" title="三、AES加密"></a>三、AES加密</h2><h3 id="1、简单介绍-1"><a href="#1、简单介绍-1" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h3><p>高级加密标准</p><h3 id="2、加密使用方法"><a href="#2、加密使用方法" class="headerlink" title="2、加密使用方法"></a>2、加密使用方法</h3><p>1、AES用到的常量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">final</span> <span class="keyword">static</span> <span class="built_in">String</span> HEX = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line"> <span class="comment">//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式</span></span><br><span class="line"> private  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> CBC_PKCS5_PADDING = <span class="string">"AES/CBC/PKCS5Padding"</span>;</span><br><span class="line"> <span class="comment">//AES 加密</span></span><br><span class="line"> private  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> AES = <span class="string">"AES"</span>;</span><br><span class="line"> <span class="comment">// SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法</span></span><br><span class="line"> private  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span>  SHA1PRNG=<span class="string">"SHA1PRNG"</span>;</span><br></pre></td></tr></table></figure><p>2、动态生成秘钥</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateKey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          SecureRandom localSecureRandom = SecureRandom.getInstance(SHA1PRNG);</span><br><span class="line">          <span class="keyword">byte</span>[] bytes_key = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">          localSecureRandom.nextBytes(bytes_key);</span><br><span class="line">          String str_key = toHex(bytes_key);</span><br><span class="line">          <span class="keyword">return</span> str_key;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、对秘钥进行处理</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">getRawKey</span>(<span class="params"><span class="keyword">byte</span>[] seed</span>) throws Exception </span>&#123;</span><br><span class="line">     KeyGenerator kgen = KeyGenerator.getInstance(AES);</span><br><span class="line">     <span class="comment">//for android</span></span><br><span class="line">     SecureRandom sr = <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">// 在4.2以上版本中，SecureRandom获取方式发生了改变</span></span><br><span class="line">     <span class="keyword">int</span> sdk_version = android.os.Build.VERSION.SDK_INT;</span><br><span class="line">     <span class="comment">// Android  6.0 以上</span></span><br><span class="line">     <span class="keyword">if</span>(sdk_version&gt;<span class="number">23</span>)&#123;</span><br><span class="line">         sr = SecureRandom.getInstance(SHA1PRNG,<span class="keyword">new</span> CryptoProvider());</span><br><span class="line">     <span class="comment">//4.2及以上</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(android.os.Build.VERSION.SDK_INT &gt;= <span class="number">17</span>)&#123;  </span><br><span class="line">         sr = SecureRandom.getInstance(SHA1PRNG, <span class="string">"Crypto"</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         sr = SecureRandom.getInstance(SHA1PRNG);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// for Java</span></span><br><span class="line">     <span class="comment">// secureRandom = SecureRandom.getInstance(SHA1PRNG);</span></span><br><span class="line">     sr.setSeed(seed);</span><br><span class="line">     <span class="comment">//256 bits or 128 bits,192bits</span></span><br><span class="line">     kgen.init(<span class="number">128</span>, sr); </span><br><span class="line">     <span class="comment">//AES中128位密钥版本有10个加密循环，192比特密钥版本有12个加密循环，256比特密钥版本则有14个加密循环。</span></span><br><span class="line">     SecretKey skey = kgen.generateKey();</span><br><span class="line">     <span class="keyword">byte</span>[] raw = skey.getEncoded();</span><br><span class="line">     <span class="keyword">return</span> raw;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>4、加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String encrypt(String key, String cleartext) &#123;</span><br><span class="line">       if (TextUtils.isEmpty(cleartext)) &#123;</span><br><span class="line">           return cleartext;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           byte[] result = encrypt(key, cleartext.getBytes());</span><br><span class="line">           return new String(Base64.encode(result,Base64.DEFAULT));</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">encrypt</span>(<span class="params">String key, <span class="keyword">byte</span>[] clear</span>) throws Exception </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] raw = getRawKey(key.getBytes());</span><br><span class="line">      SecretKeySpec skeySpec = <span class="keyword">new</span> SecretKeySpec(raw, AES);</span><br><span class="line">      Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);</span><br><span class="line">      cipher.init(Cipher.ENCRYPT_MODE, skeySpec, <span class="keyword">new</span> IvParameterSpec(<span class="keyword">new</span> <span class="keyword">byte</span>[cipher.getBlockSize()]));</span><br><span class="line">      <span class="keyword">byte</span>[] encrypted = cipher.doFinal(clear);</span><br><span class="line">      <span class="keyword">return</span> encrypted;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>5、解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static String decrypt(String key, String encrypted) &#123;</span><br><span class="line">       if (TextUtils.isEmpty(encrypted)) &#123;</span><br><span class="line">           return encrypted;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           byte[] enc = Base64.decode(encrypted,Base64.DEFAULT);</span><br><span class="line">           byte[] result = decrypt(key, enc);</span><br><span class="line">           return new String(result);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">decrypt</span>(<span class="params">String key, <span class="keyword">byte</span>[] encrypted</span>) throws Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] raw = getRawKey(key.getBytes());</span><br><span class="line">        SecretKeySpec skeySpec = <span class="keyword">new</span> SecretKeySpec(raw, AES);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, skeySpec, <span class="keyword">new</span> IvParameterSpec(<span class="keyword">new</span> <span class="keyword">byte</span>[cipher.getBlockSize()]));</span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = cipher.doFinal(encrypted);</span><br><span class="line">        <span class="keyword">return</span> decrypted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6、辅助方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//二进制转字符</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (buf == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       StringBuffer result = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * buf.length);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">           appendHex(result, buf[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result.toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHex</span><span class="params">(StringBuffer sb, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">       sb.append(HEX.charAt((b &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>)).append(HEX.charAt(b &amp; <span class="number">0x0f</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加  CryptoProvider  类</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">CryptoProvider</span> <span class="keyword">extends</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates a Provider and puts parameters</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">CryptoProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>(<span class="string">"Crypto"</span>, <span class="number">1.0</span>, <span class="string">"HARMONY (SHA1 digest; SecureRandom; SHA1withDSA signature)"</span>);</span><br><span class="line">           put(<span class="string">"SecureRandom.SHA1PRNG"</span>,</span><br><span class="line">                   <span class="string">"org.apache.harmony.security.provider.crypto.SHA1PRNG_SecureRandomImpl"</span>);</span><br><span class="line">           put(<span class="string">"SecureRandom.SHA1PRNG ImplementedIn"</span>, <span class="string">"Software"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>本文参考：<br> <a href="https://blog.csdn.net/Mingyueyixi/article/details/78501597" target="_blank" rel="noopener">《安卓AES加解密(兼容Android7.0)》</a><br> <a href="https://www.cnblogs.com/whoislcj/p/5470095.html" target="_blank" rel="noopener">《Android数据加密之Rsa加密》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Rsa加密&quot;&gt;&lt;a href=&quot;#一、Rsa加密&quot; class=&quot;headerlink&quot; title=&quot;一、Rsa加密&quot;&gt;&lt;/a&gt;一、Rsa加密&lt;/h2&gt;&lt;h3 id=&quot;1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；&quot;&gt;&lt;a href=&quot;#1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；&quot; class=&quot;headerlink&quot; title=&quot;1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；&quot;&gt;&lt;/a&gt;1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；&lt;/h3&gt;&lt;h3 id=&quot;2、算法原理：&quot;&gt;&lt;a href=&quot;#2、算法原理：&quot; class=&quot;headerlink&quot; title=&quot;2、算法原理：&quot;&gt;&lt;/a&gt;2、算法原理：&lt;/h3&gt;&lt;p&gt;1）、随机产生两个大的质数m、n且m！=n，计算K1=mn；&lt;br&gt; 2)、选择一个大于1小于k1的自然数k2，k2必须与(m-1)(n-1)互为素数；&lt;br&gt; 3)、计算得到d—&amp;gt;d x k2=1(mod(m-1)(n-1));&lt;br&gt; 4)、销毁mn；&lt;br&gt; 最终产生的k1和k2为“公钥”，d为“私钥”，发送方使用k1进行加密，接收方使用d进行解密。&lt;/p&gt;
&lt;h3 id=&quot;3、注意：&quot;&gt;&lt;a href=&quot;#3、注意：&quot; class=&quot;headerlink&quot; title=&quot;3、注意：&quot;&gt;&lt;/a&gt;3、注意：&lt;/h3&gt;&lt;p&gt;1、RSA的安全性依赖于大数分解，小于1024位的k1被认为是不安全的；&lt;br&gt; 2、RSA的计算速度慢。&lt;/p&gt;
&lt;h3 id=&quot;4、使用&quot;&gt;&lt;a href=&quot;#4、使用&quot; class=&quot;headerlink&quot; title=&quot;4、使用&quot;&gt;&lt;/a&gt;4、使用&lt;/h3&gt;&lt;p&gt;1、生成密钥对&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 随机生成RSA密钥对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @param keyLength 密钥长度，范围：512～2048&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *                  一般1024&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; KeyPair generateRSAKeyPair(&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; keyLength) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        KeyPairGenerator kpg = KeyPairGenerator.getInstance(RSA);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kpg.initialize(keyLength);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; kpg.genKeyPair();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (NoSuchAlgorithmException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>热修复原理</title>
    <link href="https://zhangmiao.cc/posts/181c4c4a.html"/>
    <id>https://zhangmiao.cc/posts/181c4c4a.html</id>
    <published>2019-11-27T02:58:10.000Z</published>
    <updated>2019-11-27T02:59:31.046Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191127105848.png" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191127105848.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>插件化原理</title>
    <link href="https://zhangmiao.cc/posts/60f13ddc.html"/>
    <id>https://zhangmiao.cc/posts/60f13ddc.html</id>
    <published>2019-11-27T02:55:27.000Z</published>
    <updated>2019-11-27T02:59:31.045Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191127105545.png" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191127105545.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>程序猿</title>
    <link href="https://zhangmiao.cc/posts/8266392b.html"/>
    <id>https://zhangmiao.cc/posts/8266392b.html</id>
    <published>2019-11-18T03:49:21.000Z</published>
    <updated>2019-11-18T03:58:37.925Z</updated>
    
    <content type="html"><![CDATA[<p>​        “先生不知何许人也，亦不详其姓字。时年二十有二，英俊朗逸，秀发蓬勃。始入IT大厂，朝九晚五，日食三餐。好读书，曰《X语言入门》、《X语言应用实践》、《X语言高阶编程》。</p><p>​        次年，二十有三，英俊尚可，然寡言少语，身影飄忽，秀发日疏。一人一烟一Computer，长坐不起，日复一日。所观者，《编程语言的科学与艺术》、《编程之美》、《编程之道》、《编程之禅》。</p><p>​        而今年约三十，不复俊逸。其目，炯炯然有所虑，其背，日益佝偻，其发，隐约可见地中海。常持杯，与沸水枸杞为伴，嗜书，然所读者与众不同，唤作《颈椎病康复指南》。</p><p>​        观其状，时人不解。或曰，必为程序猿也！”</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        “先生不知何许人也，亦不详其姓字。时年二十有二，英俊朗逸，秀发蓬勃。始入IT大厂，朝九晚五，日食三餐。好读书，曰《X语言入门》、《X语言应用实践》、《X语言高阶编程》。&lt;/p&gt;
&lt;p&gt;​        次年，二十有三，英俊尚可，然寡言少语，身影飄忽，秀发日疏。一人一烟一Computer，长坐不起，日复一日。所观者，《编程语言的科学与艺术》、《编程之美》、《编程之道》、《编程之禅》。&lt;/p&gt;
&lt;p&gt;​        而今年约三十，不复俊逸。其目，炯炯然有所虑，其背，日益佝偻，其发，隐约可见地中海。常持杯，与沸水枸杞为伴，嗜书，然所读者与众不同，唤作《颈椎病康复指南》。&lt;/p&gt;
&lt;p&gt;​        观其状，时人不解。或曰，必为程序猿也！”&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android知识点总结</title>
    <link href="https://zhangmiao.cc/posts/28ca84cb.html"/>
    <id>https://zhangmiao.cc/posts/28ca84cb.html</id>
    <published>2019-11-11T02:36:44.000Z</published>
    <updated>2019-11-11T02:45:01.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android进阶部分"><a href="#Android进阶部分" class="headerlink" title="Android进阶部分"></a>Android进阶部分</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111103856.png" alt></p><a id="more"></a><h2 id="Android-基础部分"><a href="#Android-基础部分" class="headerlink" title="Android 基础部分"></a>Android 基础部分</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111103822.png" alt></p><h2 id="Flutter部分"><a href="#Flutter部分" class="headerlink" title="Flutter部分"></a>Flutter部分</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111103927.png" alt></p><h2 id="Java-部分"><a href="#Java-部分" class="headerlink" title="Java 部分"></a>Java 部分</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111103951.png" alt></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111104019.png" alt></p><h2 id="数据结构-算法部分"><a href="#数据结构-算法部分" class="headerlink" title="数据结构/算法部分"></a>数据结构/算法部分</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111104040.png" alt></p><h2 id="给出一张完整的总结图"><a href="#给出一张完整的总结图" class="headerlink" title="给出一张完整的总结图"></a>给出一张完整的总结图</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111104114.png" alt></p><p>思维导图高清版地址：<a href="https://www.processon.com/view/link/5db934d6e4b0ece75943365a" target="_blank" rel="noopener">processon</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android进阶部分&quot;&gt;&lt;a href=&quot;#Android进阶部分&quot; class=&quot;headerlink&quot; title=&quot;Android进阶部分&quot;&gt;&lt;/a&gt;Android进阶部分&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20191111103856.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/categories/Android/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>android采用ChromeIntent方式实现从浏览器启动应用</title>
    <link href="https://zhangmiao.cc/posts/8e25ebb8.html"/>
    <id>https://zhangmiao.cc/posts/8e25ebb8.html</id>
    <published>2019-11-07T08:12:42.000Z</published>
    <updated>2019-11-07T08:32:21.261Z</updated>
    
    <content type="html"><![CDATA[<p>在很多应用中需要我们从浏览器中直接启动应用，而网上大多数采用的是scheme的方式，即在启动activity的mainfest文件中配置如下字段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.example.MainActivity"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"example"</span> <span class="attr">android:host</span>=<span class="string">"test"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在网页的连接设置为example://test/… 来启动应用，但是如果手机中没有应用，该url会跳转到一个错误的界面。</p><p>google官方在chrome中推出了一种Android Intents的方式来实现应用启动，通过在iframe中设置src为的方式，具体示例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intent:HOST/URI-path <span class="comment">// Optional host</span></span><br><span class="line">#Intent;</span><br><span class="line"><span class="keyword">package</span>=[string];</span><br><span class="line">action=[string];</span><br><span class="line">category=[string];</span><br><span class="line">component=[string]; </span><br><span class="line">scheme=[string];</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们定义一个a标签为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">name</span>=<span class="string">"code"</span> <span class="attr">class</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span> <span class="attr">name</span>=<span class="string">"code"</span> <span class="attr">class</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"intent://zhangmiao/#Intent;scheme=myapp;package=com.what.ever.myapp;end"</span>&gt;</span>Do Whatever<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在mainfest文件中定义要启动的activity</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".TestUrlScheme"</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 显示数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 定义成浏览器类型，有URL需要处理时会过滤 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 打开以whatever协议的URL,这个自己随便定义。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"myapp"</span> <span class="attr">android:host</span>=<span class="string">"zhangmiao"</span> <span class="attr">android:path</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在浏览器中点击a标签，就可以启动应用程序的对应activity了，如果手机中没有相应的应用，那么是否会跳转到错误页面呢，将a标签设置为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;S.browser_fallback_url=http%3A%2F%2Fzxing.org;end"</span>&gt;</span>Do Whatever<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样如果没有对应应用，该链接就会跳转到S.browser_fallback_url指定的url上。</p><p>其中参数的类型如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String =&gt; <span class="string">'S'</span></span><br><span class="line">Boolean =&gt;<span class="string">'B'</span></span><br><span class="line">Byte =&gt; <span class="string">'b'</span></span><br><span class="line">Character =&gt; <span class="string">'c'</span></span><br><span class="line">Double =&gt; <span class="string">'d'</span></span><br><span class="line">Float =&gt; <span class="string">'f'</span></span><br><span class="line">Integer =&gt; <span class="string">'i'</span></span><br><span class="line">Long =&gt; <span class="string">'l'</span></span><br><span class="line">Short =&gt; <span class="string">'s'</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent:<span class="comment">//RequestType/?name=zhangmiao&amp;age=18#Intent;scheme=appname;package=com.example.appname;S.browser_fallback_url=http%3A%2F%2Fzxing.org;end</span></span><br></pre></td></tr></table></figure><p>然后在启动activity的onCreate函数中利用bundle接收参数就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Bundle parametros = getIntent().getExtras();</span><br><span class="line"><span class="keyword">if</span> (extras != <span class="keyword">null</span>)&#123;</span><br><span class="line">    String name = extras.getString(<span class="string">"name"</span>);</span><br><span class="line">    Integer age = extras.getInt(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name!=<span class="keyword">null</span> &amp;&amp; age!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//do whatever you have to</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//no extras, get over it!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多应用中需要我们从浏览器中直接启动应用，而网上大多数采用的是scheme的方式，即在启动activity的mainfest文件中配置如下字段：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.example.MainActivity&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.intent.action.VIEW&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.intent.category.DEFAULT&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.intent.category.BROWSABLE&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:scheme&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;example&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:host&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后在网页的连接设置为example://test/… 来启动应用，但是如果手机中没有应用，该url会跳转到一个错误的界面。&lt;/p&gt;
&lt;p&gt;google官方在chrome中推出了一种Android Intents的方式来实现应用启动，通过在iframe中设置src为的方式，具体示例如下。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;intent:HOST/URI-path &lt;span class=&quot;comment&quot;&gt;// Optional host&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#Intent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt;=[string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;action=[string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category=[string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;component=[string]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scheme=[string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android渐变色xml文件</title>
    <link href="https://zhangmiao.cc/posts/2851801a.html"/>
    <id>https://zhangmiao.cc/posts/2851801a.html</id>
    <published>2019-10-30T06:05:35.000Z</published>
    <updated>2019-10-30T06:07:20.162Z</updated>
    
    <content type="html"><![CDATA[<p>在drawable目录下新建drawable resource file，修改xml代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    android:startColor="#aa000000"  渐变起始色值</span></span><br><span class="line"><span class="comment">    android:centerColor=""      渐变中间色值</span></span><br><span class="line"><span class="comment">    android:endColor="#ffffffff"    渐变结束颜色</span></span><br><span class="line"><span class="comment">    android:angle="45"      渐变的方向 默认为0 从做向右 ，90时从下向上 必须为45的整数倍</span></span><br><span class="line"><span class="comment">    android:type="radial"       渐变类型 有三种 线性linear 放射渐变radial 扫描线性渐变sweep</span></span><br><span class="line"><span class="comment">    android:centerX="0.5"       渐变中心相对X坐标只有渐变类型为放射渐变时有效</span></span><br><span class="line"><span class="comment">    android:centerY="0.5"       渐变中心相对Y坐标只有渐变类型为放射渐变时有效</span></span><br><span class="line"><span class="comment">    android:gradientRadius="100"    渐变半径 非线性放射有效</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gradient</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:startColor</span>=<span class="string">"#b7bbd9"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:endColor</span>=<span class="string">"#5CACEE"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:angle</span>=<span class="string">"90"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在drawable目录下新建drawable resource file，修改xml代码&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;shape&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns:android&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:startColor=&quot;#aa000000&quot;  渐变起始色值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:centerColor=&quot;&quot;      渐变中间色值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:endColor=&quot;#ffffffff&quot;    渐变结束颜色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:angle=&quot;45&quot;      渐变的方向 默认为0 从做向右 ，90时从下向上 必须为45的整数倍&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:type=&quot;radial&quot;       渐变类型 有三种 线性linear 放射渐变radial 扫描线性渐变sweep&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:centerX=&quot;0.5&quot;       渐变中心相对X坐标只有渐变类型为放射渐变时有效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:centerY=&quot;0.5&quot;       渐变中心相对Y坐标只有渐变类型为放射渐变时有效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    android:gradientRadius=&quot;100&quot;    渐变半径 非线性放射有效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;gradient&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:startColor&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;#b7bbd9&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:endColor&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;#5CACEE&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:angle&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;90&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;        /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;shape&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>日常代码写作规范及优化建议</title>
    <link href="https://zhangmiao.cc/posts/a54cde26.html"/>
    <id>https://zhangmiao.cc/posts/a54cde26.html</id>
    <published>2019-10-18T10:04:41.000Z</published>
    <updated>2019-10-18T10:06:29.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="批量数据处理"><a href="#批量数据处理" class="headerlink" title="批量数据处理"></a>批量数据处理</h2><p>每次读取数据时，批量读取，然后在应用中进行分组、分发，例如：</p><p>订单列表页涉及到用户、订单、商品等表，批量把当前页的订单、用户、商品一次性读取回来，然后在应用中进行数据的组装，以减少sql请求量，降低数据库压力，加快操作响应速度。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>建议尽量避免使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br></pre></td></tr></table></figure><p>注解，因为这个是共享了Spring提供的线程池，大量使用的时候，容易造成线程池溢出，建议使用自定义的线程池，并且估算好以下参数：</p><ul><li>核心线程数、最大线程数</li><li>存活时长</li><li>任务队列及长度</li><li>自定义ThreadFactory，指定线程名称</li><li>根据业务指定拒绝策略</li></ul><h2 id="HashMap不要在多线程环境下使用"><a href="#HashMap不要在多线程环境下使用" class="headerlink" title="HashMap不要在多线程环境下使用"></a>HashMap不要在多线程环境下使用</h2><p>应用默认都是多线程环境的，所以在定义HashMap对象的时候一定要清楚的知道当前有没有多线程的问题</p><h2 id="控制数据量大小"><a href="#控制数据量大小" class="headerlink" title="控制数据量大小"></a>控制数据量大小</h2><p>每次操作数据的时候，一定要清楚的知道当前操作的数据可能的量，并清楚的知道最大的量是多少、未来的增长数据和空间，以防止引起内存不足，我们的系统的内存大部分是4-8个G；</p><p>除非能确定数据量有限且不增长，否则都应该分批操作，保证每批数据的有限性，以防随着数据量大后造成系统风险。</p><p>对于需要较长时间的业务，比如导入数据、调用第三方接口之类，最好做成任务类型</p><a id="more"></a><h2 id="数据和操作的安全性、可追溯性"><a href="#数据和操作的安全性、可追溯性" class="headerlink" title="数据和操作的安全性、可追溯性"></a>数据和操作的安全性、可追溯性</h2><ul><li>App端：不允许通过前端传入用户ID来操作对应用户的数据；对用户的私有数据操作，一定要检查当前数据是否属于当前用户，包括但不限于：地址、订单、关注、购物车、评论、个人信息、账户余额等</li><li>Backend端：后台对用户的操作有权限校验，当前是基于URL做的，所以要确保当前操作的数据一定要在某个url之下，比如菜单url是/ic/item，那么点开这个菜单以后展现的界面里所有的操作对应的url，都要在/ic/item这个url之后（之下），比如/ic/item/to-add，/ic/item/do-add/_ajax</li><li>上传到OSS的内容，如果是公司私有的，一定不能使用公有读权限上传，以防造成信息泄露。</li><li>关键配置不要直接写在配置文件里，当前我们是写的启动脚本里（配置中心还没有做）</li><li>关键数据的操作和修改，一定要有对应的操作日志的记录，以确保可追溯</li></ul><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><ul><li>如果是定时执行的，约定只在整点或半点的时候执行，以便大家在发布系统的时候能知道在哪些时间点避免发布；</li><li>如果要是对过去一段时间的数据进行定时处理，请确保处理的数据的时间范围大两个（或更长时间）或以上的定时执行时间差内，以便让当前处理的数据能覆盖到上一次定时执行的数据范围，以便上次未执行或执行失败时，能做重试处理</li><li>App端不做任务定时任务，以确保APP端系统的稳定</li><li>根据自身业务情况，可以考虑放到redis队列里去，然后由多台机子一起跑这个队列里的数据，这样的话即使服务器频繁重启也不会中断任务。</li></ul><h2 id="配置的内外网之分"><a href="#配置的内外网之分" class="headerlink" title="配置的内外网之分"></a>配置的内外网之分</h2><p>为了加速操作的执行速度，在能使用内网的时候，一定使用内网连接，例如：Redis/Mysql/OSS等，请大家在添加或修改线上或测试环境配置的时候，一定要了解当前是否可以使用内网。</p><h2 id="外部服务调用"><a href="#外部服务调用" class="headerlink" title="外部服务调用"></a>外部服务调用</h2><p>如果有对外部服务的调用，一定要想好如果服务不可用、服务响应时间过长、或者服务响应结果有错，会不会对系统造成压力或影响；尤其是当该调用在事务方法中时，有可能造成事务时间过长，数据库连接被占满，系统不可用。</p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul><li>要清楚的理解当前操作是否需要事务，能避免事务操作的就不要使用事务</li><li>如果是使用事务，那就需要清楚的知道什么时候可以返回结果，什么时候应该抛出异常，以使事务生效</li><li>事务中尽量避免长时操作</li></ul><h2 id="延迟或异步给出不必要的数据"><a href="#延迟或异步给出不必要的数据" class="headerlink" title="延迟或异步给出不必要的数据"></a>延迟或异步给出不必要的数据</h2><p>对于非必要的数据，可以延迟或异步给出，以加快操作的响应速度。例如之前后台的订单详情页，除了加速订单相关数据外，还会加载订单的物流信息，造成整个订单详情页响应时间超长，后来优化了一下，延迟加载物流信息，整个响应速度就极大的提升了；又比如前端很多页面都有优有推荐数据，为了显示页面，除了要读取必要的数据，还要等待推荐数据的返回才能显示页面，就造成了整个页面的响应过慢。</p><h2 id="异步处理，加快响应速度"><a href="#异步处理，加快响应速度" class="headerlink" title="异步处理，加快响应速度"></a>异步处理，加快响应速度</h2><ul><li>对于有多个长时操作，但是互相之间没有依赖的，可以让每个操作异步处理，然后在最后再等待所有的操作结果返回，汇总结果，再输出，以加快操作的响应速度。</li><li>除此之外，尽量使用消息系统</li></ul><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>自己写的方法、接口，特别是比较重要的业务，一定要处理好幂等性，不管是消息的消费还是对外暴露的API等等。</p><h2 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h2><ul><li>对于耗时的操作，能使用缓存的尽量使用缓存</li><li>对于变动不频繁但是使用频繁的，可以使用缓存</li><li>对于不会变的数据，可以使用本地缓存，但是要注意缓存数据量的大小，以免造成内存压力</li></ul><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>写sql查数据的时候，除了要考虑数据量外，要检查是否有对应的索引使用，防止查询过慢。</p><p>一般一个表的索引不要超过6个，索引应建立在离散度比较高且在查询条件中出现频度较高的字段上，索引尽量在建表的时候考虑好，后期数据量大了再加索引的话会比较困难。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>使用集合时，估算出可能需要的容量，并以此指定集合的容量，以避免频繁扩容</li><li>字符串拼接时，建议使用StringBuilder（Java8中会自动使用）</li><li>数据库中存储时间，建议用时间戳（10位，到秒），鉴于历史问题，如果旧表使用的是dateTime，那么后续旧表加时间字段时也用dateTime类型。</li><li>读取数据库时间以及和前端交互时，注意时区的问题</li><li>数据库中存储金额，都使用分，计算过程涉及取舍时不能精确到分，总和会出现差距</li><li>调用方法都检查返回结果；提供方法时尽量避免null结果返回，区分集合和普通对象，处理好返回值为 null 的情况</li><li>方法和变量命名是直观且和它所对应的业务意义一至</li><li>对于业务逻辑，要写好注释，描述清楚代码所对应的业务逻辑，且注释和代码逻辑要真的一致，对于 map 一定要注释好 key 和 value 分别对应什么</li><li>关键的业务要记录好日志，谁，什么时候，做了什么事情，数据变化情况</li><li>logger.error 注意多个参数，可能丢失堆栈</li><li>异常处理：只捕获自己可以处理的异常，不能处理的不要捕获</li><li>java7 开始，jdk排序算法已改变，需要满足：自反性，传递性，对称性</li><li>集合类判断是否为空，使用 CollectionUtil 不要使用 size() &gt; 0</li></ul><h2 id="定期review"><a href="#定期review" class="headerlink" title="定期review"></a>定期review</h2><p>定期的去APM系统中或Kibana中检查操作的响应速度和耗时处</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;批量数据处理&quot;&gt;&lt;a href=&quot;#批量数据处理&quot; class=&quot;headerlink&quot; title=&quot;批量数据处理&quot;&gt;&lt;/a&gt;批量数据处理&lt;/h2&gt;&lt;p&gt;每次读取数据时，批量读取，然后在应用中进行分组、分发，例如：&lt;/p&gt;
&lt;p&gt;订单列表页涉及到用户、订单、商品等表，批量把当前页的订单、用户、商品一次性读取回来，然后在应用中进行数据的组装，以减少sql请求量，降低数据库压力，加快操作响应速度。&lt;/p&gt;
&lt;h2 id=&quot;线程池的使用&quot;&gt;&lt;a href=&quot;#线程池的使用&quot; class=&quot;headerlink&quot; title=&quot;线程池的使用&quot;&gt;&lt;/a&gt;线程池的使用&lt;/h2&gt;&lt;p&gt;建议尽量避免使用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Async&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注解，因为这个是共享了Spring提供的线程池，大量使用的时候，容易造成线程池溢出，建议使用自定义的线程池，并且估算好以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心线程数、最大线程数&lt;/li&gt;
&lt;li&gt;存活时长&lt;/li&gt;
&lt;li&gt;任务队列及长度&lt;/li&gt;
&lt;li&gt;自定义ThreadFactory，指定线程名称&lt;/li&gt;
&lt;li&gt;根据业务指定拒绝策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;HashMap不要在多线程环境下使用&quot;&gt;&lt;a href=&quot;#HashMap不要在多线程环境下使用&quot; class=&quot;headerlink&quot; title=&quot;HashMap不要在多线程环境下使用&quot;&gt;&lt;/a&gt;HashMap不要在多线程环境下使用&lt;/h2&gt;&lt;p&gt;应用默认都是多线程环境的，所以在定义HashMap对象的时候一定要清楚的知道当前有没有多线程的问题&lt;/p&gt;
&lt;h2 id=&quot;控制数据量大小&quot;&gt;&lt;a href=&quot;#控制数据量大小&quot; class=&quot;headerlink&quot; title=&quot;控制数据量大小&quot;&gt;&lt;/a&gt;控制数据量大小&lt;/h2&gt;&lt;p&gt;每次操作数据的时候，一定要清楚的知道当前操作的数据可能的量，并清楚的知道最大的量是多少、未来的增长数据和空间，以防止引起内存不足，我们的系统的内存大部分是4-8个G；&lt;/p&gt;
&lt;p&gt;除非能确定数据量有限且不增长，否则都应该分批操作，保证每批数据的有限性，以防随着数据量大后造成系统风险。&lt;/p&gt;
&lt;p&gt;对于需要较长时间的业务，比如导入数据、调用第三方接口之类，最好做成任务类型&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zhangmiao.cc/categories/Java/"/>
    
      <category term="基础" scheme="https://zhangmiao.cc/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://zhangmiao.cc/tags/Java/"/>
    
      <category term="规范" scheme="https://zhangmiao.cc/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>高效能人士的七个习惯</title>
    <link href="https://zhangmiao.cc/posts/f66419fe.html"/>
    <id>https://zhangmiao.cc/posts/f66419fe.html</id>
    <published>2019-10-18T05:19:27.000Z</published>
    <updated>2019-10-18T05:20:48.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/WechatIMG2009.jpeg" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/WechatIMG2009.jpeg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android混淆使用手册</title>
    <link href="https://zhangmiao.cc/posts/635b293f.html"/>
    <id>https://zhangmiao.cc/posts/635b293f.html</id>
    <published>2019-10-18T02:21:04.000Z</published>
    <updated>2019-10-18T02:23:25.871Z</updated>
    
    <content type="html"><![CDATA[<p>首先，这里说的的混淆其实是包括了代码压缩、代码混淆以及资源压缩等的优化过程。依靠 ProGuard，混淆流程将主项目以及依赖库中未被使用的类、类成员、方法、属性移除，这有助于规避64K方法数的瓶颈；同时，将类、类成员、方法重命名为无意义的简短名称，增加了逆向工程的难度。而依靠 Gradle 的 Android 插件，我们将移除未被使用的资源，可以有效减小 apk 安装包大小。</p><p>本文由两部分构成：</p><ul><li>第一部分给出混淆的最佳实践，力求让零基础的新手都可以直接使用混淆；</li><li>第二部分会介绍一下混淆的整体、自定义混淆规则的语法与实践、自定义资源保持的规则等。</li></ul><h2 id="一、Android混淆最佳实践"><a href="#一、Android混淆最佳实践" class="headerlink" title="一、Android混淆最佳实践"></a>一、Android混淆最佳实践</h2><h3 id="1-混淆配置"><a href="#1-混淆配置" class="headerlink" title="1. 混淆配置"></a>1. 混淆配置</h3><p>一般情况下，app module 的 <code>build.gradle</code> 文件默认会有如下结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为开启混淆会使编译时间变长，所以<code>debug</code>模式下不应该开启。我们需要做的是：</p><ol><li>将<code>release</code>下<code>minifyEnabled</code>的值改为<code>true</code>，打开混淆；</li><li>加上<code>shrinkResources true</code>，打开资源压缩。</li></ol><p>修改后文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-自定义混淆规则"><a href="#2-自定义混淆规则" class="headerlink" title="2. 自定义混淆规则"></a>2. 自定义混淆规则</h3><p>在 <code>app module</code> 下默认生成了项目的自定义混淆规则文件 <code>proguard-rules.pro</code>，多方调研后，一份适用于大部分项目的混淆规则最佳实践如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定压缩级别</span></span><br><span class="line">-optimizationpasses <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#不跳过非公共的库的类成员</span></span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line"></span><br><span class="line"><span class="comment">#混淆时采用的算法</span></span><br><span class="line">-optimizations !code/simplification/arithmetic,!field/*,!<span class="class"><span class="keyword">class</span>/<span class="title">merging</span>/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把混淆类中的方法名也混淆了</span></span><br><span class="line">-useuniqueclassmembernames</span><br><span class="line"></span><br><span class="line"><span class="comment">#优化时允许访问并修改有修饰符的类和类的成员 </span></span><br><span class="line">-allowaccessmodification</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文件来源重命名为“SourceFile”字符串</span></span><br><span class="line">-renamesourcefileattribute SourceFile</span><br><span class="line"><span class="comment">#保留行号</span></span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br><span class="line"><span class="comment">#保持泛型</span></span><br><span class="line">-keepattributes Signature</span><br><span class="line"></span><br><span class="line"><span class="comment">#保持所有实现 Serializable 接口的类成员</span></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></span><br><span class="line">    static final long serialVersionUID;</span><br><span class="line">    private static final java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream);</span><br><span class="line">    private void readObject(java.io.ObjectInputStream);</span><br><span class="line">    java.lang.Object writeReplace();</span><br><span class="line">    java.lang.Object readResolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fragment不需要在AndroidManifest.xml中注册，需要额外保护下</span></span><br><span class="line">-keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">app</span>.<span class="title">Fragment</span></span></span><br><span class="line">-keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持测试相关的代码</span></span><br><span class="line">-dontnote junit.framework.**</span><br><span class="line">-dontnote junit.runner.**</span><br><span class="line">-dontwarn android.test.**</span><br><span class="line">-dontwarn android.support.test.**</span><br><span class="line">-dontwarn org.junit.**</span><br></pre></td></tr></table></figure><p>真正通用的、需要添加的就是上面这些，除此之外，需要每个项目根据自身的需求添加一些混淆规则：</p><ul><li>第三方库所需的混淆规则。正规的第三方库一般都会在接入文档中写好所需混淆规则，使用时注意添加。</li><li>在运行时动态改变的代码，例如反射。比较典型的例子就是会与 json 相互转换的实体类。假如项目命名规范要求实体类都要放在<code>model</code>包下的话，可以添加类似这样的代码把所有实体类都保持住：<code>-keep public class **.*Model*.** {*;}</code></li><li><code>JNI</code>中调用的类。</li><li><code>WebView</code>中<code>JavaScript</code>调用的方法</li><li><code>Layout</code>布局使用的<code>View</code>构造函数、<code>android:onClick</code>等。</li></ul><h3 id="3-检查混淆结果"><a href="#3-检查混淆结果" class="headerlink" title="3. 检查混淆结果"></a>3. 检查混淆结果</h3><p>混淆过的包必须进行检查，避免因混淆引入的bug。</p><p>一方面，需要从代码层面检查。使用上文的配置进行混淆打包后在 <code>&lt;module-name&gt;/build/outputs/mapping/release/</code> 目录下会输出以下文件：</p><ul><li><code>dump.txt</code><br>描述APK文件中所有类的内部结构</li><li><code>mapping.txt</code><br>提供混淆前后类、方法、类成员等的对照表</li><li><code>seeds.txt</code><br>列出没有被混淆的类和成员</li><li><code>usage.txt</code><br>列出被移除的代码</li></ul><p>我们可以根据 <code>seeds.txt</code> 文件检查未被混淆的类和成员中是否已包含所有期望保留的，再根据 <code>usage.txt</code> 文件查看是否有被误移除的代码。</p><p>另一方面，需要从测试方面检查。将混淆过的包进行全方面测试，检查是否有 bug 产生。</p><h3 id="4-解出混淆栈"><a href="#4-解出混淆栈" class="headerlink" title="4. 解出混淆栈"></a>4. 解出混淆栈</h3><p>混淆后的类、方法名等等难以阅读，这固然会增加逆向工程的难度，但对追踪线上 crash 也造成了阻碍。我们拿到 crash 的堆栈信息后会发现很难定位，这时需要将混淆反解。</p><p>在 <code>&lt;sdk-root&gt;/tools/proguard/</code> 路径下有附带的的反解工具（Window 系统为 <code>proguardgui.bat</code>，Mac 或 Linux 系统为 <code>proguardgui.sh</code>）。</p><p>这里以 Window 平台为例。双击运行 <code>proguardgui.bat</code> 后，可以看到左侧的一行菜单。点击 <code>ReTrace</code>，选择该混淆包对应的 mapping 文件（混淆后在 <code>&lt;module-name&gt;/build/outputs/mapping/release/</code> 路径下会生成 <code>mapping.txt</code> 文件，它的作用是提供混淆前后类、方法、类成员等的对照表），再将 crash 的 <code>stack trace</code> 黏贴进输入框中，点击右下角的 <code>ReTrace</code> ，混淆后的堆栈信息就显示出来了。</p><p>以上使用 GUI 程序进行操作，另一种方式是利用该路径下的 <code>retrace</code> 工具通过命令行进行反解，命令是</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retrace.bat|retrace.sh [-verbose] mapping.txt [<span class="xml"><span class="tag">&lt;<span class="name">stacktrace_file</span>&gt;</span>]</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">retrace</span><span class="selector-class">.bat</span> <span class="selector-tag">-verbose</span> <span class="selector-tag">mapping</span><span class="selector-class">.txt</span> <span class="selector-tag">obfuscated_trace</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol><li>所有在 <code>AndroidManifest.xml</code> 涉及到的类已经自动被保持，因此不用特意去添加这块混淆规则。（很多老的混淆文件里会加，现在已经没必要）</li><li><code>proguard-android.txt</code> 已经存在一些默认混淆规则，没必要在 <code>proguard-rules.pro</code> 重复添加，该文件具体规则见附录1：</li></ol><h2 id="二、混淆简介"><a href="#二、混淆简介" class="headerlink" title="二、混淆简介"></a>二、混淆简介</h2><p>Android中的“混淆”可以分为两部分，一部分是 Java 代码的优化与混淆，依靠 proguard 混淆器来实现；另一部分是资源压缩，将移除项目及依赖的库中未被使用的资源(资源压缩严格意义上跟混淆没啥关系，但一般我们都会放一起讲)。</p><h3 id="1-代码压缩"><a href="#1-代码压缩" class="headerlink" title="1. 代码压缩"></a>1. 代码压缩</h3><p><img src="https://upload-images.jianshu.io/upload_images/1432874-22aaaa45ddc4e248.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>代码混淆是包含了代码压缩、优化、混淆等一系列行为的过程。如上图所示，混淆过程会有如下几个功能：</p><ol><li>压缩。移除无效的类、类成员、方法、属性等；</li><li>优化。分析和优化方法的二进制代码；根据proguard-android-optimize.txt中的描述，优化可能会造成一些潜在风险，不能保证在所有版本的Dalvik上都正常运行。</li><li>混淆。把类名、属性名、方法名替换为简短且无意义的名称；</li><li>预校验。添加预校验信息。这个预校验是作用在Java平台上的，Android平台上不需要这项功能，去掉之后还可以加快混淆速度。</li></ol><p>这四个流程默认开启。</p><p>在 Android 项目中我们可以选择将“优化”和“预校验”关闭，对应命令是<code>-dontoptimize</code>、<code>-dontpreverify</code>（当然，默认的 <code>proguard-android.txt</code> 文件已包含这两条混淆命令，不需要开发者额外配置）。</p><h3 id="2-资源压缩"><a href="#2-资源压缩" class="headerlink" title="2. 资源压缩"></a>2. 资源压缩</h3><p>资源压缩将移除项目及依赖的库中未被使用的资源，这在减少 apk 包体积上会有不错的效果，一般建议开启。具体做法是在 <code>build.grade</code> 文件中，将 <code>shrinkResources</code> 属性设置为 <code>true</code>。需要注意的是，<strong>只有在用minifyEnabled true开启了代码压缩后，资源压缩才会生效</strong>。</p><p>资源压缩包含了“合并资源”和“移除资源”两个流程。</p><p>“合并资源”流程中，名称相同的资源被视为重复资源会被合并。需要注意的是，<strong>这一流程不受shrinkResources属性控制，也无法被禁止，</strong> gradle 必然会做这项工作，因为假如不同项目中存在相同名称的资源将导致错误。gradle 在四处地方寻找重复资源：</p><ul><li><code>src/main/res/</code> 路径</li><li>不同的构建类型（debug、release等等）</li><li>不同的构建渠道</li><li>项目依赖的第三方库</li></ul><p>合并资源时按照如下优先级顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">依赖 -&gt; main -&gt; 渠道 -&gt; 构建类型</span><br></pre></td></tr></table></figure><p>举个例子，假如重复资源同时存在于<code>main</code>文件夹和不同渠道中，gradle 会选择保留渠道中的资源。</p><p>同时，如果重复资源在同一层次出现，比如<code>src/main/res/</code> 和 <code>src/main/res2/</code>，则 gradle 无法完成资源合并，这时会报资源合并错误。</p><p>“移除资源”流程则见名知意，需要注意的是，类似代码，混淆资源移除也可以定义哪些资源需要被保留，这点在下文给出。</p><h2 id="三、自定义混淆规则"><a href="#三、自定义混淆规则" class="headerlink" title="三、自定义混淆规则"></a>三、自定义混淆规则</h2><p>在上文“混淆配置”中有这样一行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br></pre></td></tr></table></figure><p>这行代码定义了混淆规则由两部分构成：位于 SDK 的 <code>tools/proguard/</code> 文件夹中的 <code>proguard-android.txt</code> 的内容以及默认放置于模块根目录的 <code>proguard-rules.pro</code> 的内容。前者是 SDK 提供的默认混淆文件（内容见附录1），后者是开发者自定义混淆规则的地方。</p><h3 id="1-常见混淆命令："><a href="#1-常见混淆命令：" class="headerlink" title="1. 常见混淆命令："></a>1. 常见混淆命令：</h3><ul><li>optimizationpasses</li><li>dontoptimize</li><li>dontusemixedcaseclassnames</li><li>dontskipnonpubliclibraryclasses</li><li>dontpreverify</li><li>dontwarn</li><li>verbose</li><li>optimizations</li><li>keep</li><li>keepnames</li><li>keepclassmembers</li><li>keepclassmembernames</li><li>keepclasseswithmembers</li><li>keepclasseswithmembernames</li></ul><p>在第一部分 Android 混淆最佳实践中已介绍部分需要使用到的混淆命令，这里不再赘述，详情请查阅<a href="https://link.jianshu.com/?t=http://proguard.sourceforge.net" target="_blank" rel="noopener">官网</a>。需要特别介绍的是与保持相关元素不参与混淆的规则相关的几种命令：</p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-keep</td><td align="left">防止类和成员被移除或者被重命名</td></tr><tr><td align="left">-keepnames</td><td align="left">防止类和成员被重命名</td></tr><tr><td align="left">-keepclassmembers</td><td align="left">防止成员被移除或者被重命名</td></tr><tr><td align="left">-keepnames</td><td align="left">防止成员被重命名</td></tr><tr><td align="left">-keepclasseswithmembers</td><td align="left">防止<strong>拥有该成员的</strong>类和成员被移除或者被重命名</td></tr><tr><td align="left">-keepclasseswithmembernames</td><td align="left">防止<strong>拥有该成员的</strong>类和成员被重命名</td></tr></tbody></table><h3 id="2-保持元素不参与混淆的规则"><a href="#2-保持元素不参与混淆的规则" class="headerlink" title="2. 保持元素不参与混淆的规则"></a>2. 保持元素不参与混淆的规则</h3><p>形如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">保持命令</span>] [类] &#123;</span><br><span class="line">    [<span class="meta">成员</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“类”代表类相关的限定条件，它将最终定位到某些符合该限定条件的类。它的内容可以使用：</p><ul><li>具体的类</li><li>访问修饰符（<code>public</code>、<code>protected</code>、<code>private</code>）</li><li>通配符<code>*</code>，匹配任意长度字符，但不含包名分隔符(.)</li><li>通配符<code>**</code>，匹配任意长度字符，并且包含包名分隔符(.)</li><li><code>extends</code>，即可以指定类的基类</li><li><code>implement</code>，匹配实现了某接口的类</li><li>$，内部类</li></ul><p>“成员”代表类成员相关的限定条件，它将最终定位到某些符合该限定条件的类成员。它的内容可以使用：</p><ul><li><init> 匹配所有构造器</init></li><li><fields> 匹配所有域</fields></li><li><methods> 匹配所有方法</methods></li><li>通配符<code>*</code>，匹配任意长度字符，但不含包名分隔符(.)</li><li>通配符<code>**</code>，匹配任意长度字符，并且包含包名分隔符(.)</li><li>通配符<code>***</code>，匹配任意参数类型</li><li><code>…</code>，匹配任意长度的任意类型参数。比如void test(…)就能匹配任意 <code>void test(String a)</code> 或者是 <code>void test(int a, String b)</code> 这些方法。</li><li>访问修饰符（<code>public</code>、<code>protected</code>、<code>private</code>）</li></ul><p>举个例子，假如需要将<code>name.huihui.test</code>包下所有继承<code>Activity</code>的<code>public</code>类及其构造函数都保持住，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">test</span>.** <span class="keyword">extends</span> <span class="title">Android</span>.<span class="title">app</span>.<span class="title">Activity</span> </span>&#123;</span><br><span class="line">    &lt;init&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-常用的自定义混淆规则"><a href="#3-常用的自定义混淆规则" class="headerlink" title="3. 常用的自定义混淆规则"></a>3. 常用的自定义混淆规则</h3><ul><li>不混淆某个类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">example</span>.<span class="title">Test</span> &#123;</span> *; &#125;</span><br></pre></td></tr></table></figure><ul><li>不混淆某个包所有的类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">test</span>.** &#123;</span> *; &#125;</span><br></pre></td></tr></table></figure><ul><li>不混淆某个类的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">example</span>.<span class="title">Test</span> </span>&#123; *; &#125;</span><br></pre></td></tr></table></figure><ul><li>不混淆所有类名中包含了“model”的类及其成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> **.*<span class="title">model</span>*.** &#123;</span>*;&#125;</span><br></pre></td></tr></table></figure><ul><li>不混淆某个接口的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">example</span>.<span class="title">TestInterface</span> </span>&#123; *; &#125;</span><br></pre></td></tr></table></figure><ul><li>不混淆某个类的构造方法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">example</span>.<span class="title">Test</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不混淆某个类的特定的方法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">example</span>.<span class="title">Test</span> &#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(java.lang.String)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不混淆某个类的内部类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">name</span>.<span class="title">huihui</span>.<span class="title">example</span>.<span class="title">Test</span>$* &#123;</span></span><br><span class="line">        *;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="四、自定义资源保持规则"><a href="#四、自定义资源保持规则" class="headerlink" title="四、自定义资源保持规则"></a>四、自定义资源保持规则</h2><h3 id="1-keep-xml"><a href="#1-keep-xml" class="headerlink" title="1. keep.xml"></a>1. keep.xml</h3><p>用<code>shrinkResources true</code>开启资源压缩后，所有未被使用的资源默认被移除。假如你需要定义哪些资源必须被保留，在 <code>res/raw/</code> 路径下创建一个 xml 文件，例如 <code>keep.xml</code>。</p><p>通过一些属性的设置可以实现定义资源保持的需求，可配置的属性有：</p><ul><li><code>tools:keep</code> 定义哪些资源需要被保留（资源之间用“,”隔开）</li><li><code>tools:discard</code> 定义哪些资源需要被移除（资源之间用“,”隔开）</li><li><code>tools:shrinkMode</code> 开启严格模式</li></ul><p>当代码中通过 <code>Resources.getIdentifier()</code> 用动态的字符串来获取并使用资源时，普通的资源引用检查就可能会有问题。例如，如下代码会导致所有以“img_”开头的资源都被标记为已使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="built_in">String</span>.format(<span class="string">"img_%1d"</span>, angle + <span class="number">1</span>);</span><br><span class="line">res = getResources().getIdentifier(name, <span class="string">"drawable"</span>, getPackageName());</span><br></pre></td></tr></table></figure><p>我们可以设置 <code>tools:shrinkMode</code> 为 <code>strict</code> 来开启严格模式，使只有确实被使用的资源被保留。</p><p>以上就是自定义资源保持规则相关的配置，举个例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:keep</span>=<span class="string">"@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:discard</span>=<span class="string">"@layout/unused2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:shrinkMode</span>=<span class="string">"strict"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-移除替代资源"><a href="#2-移除替代资源" class="headerlink" title="2. 移除替代资源"></a>2. 移除替代资源</h3><p>一些替代资源，例如多语言支持的 <code>strings.xml</code>，多分辨率支持的 <code>layout.xml</code> 等，在我们不需要使用又不想删除掉时，可以使用资源压缩将它们移除。</p><p>我们使用 <code>resConfig</code> 属性来指定需要支持的属性，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        resConfigs <span class="string">"en"</span>, <span class="string">"fr"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他未显式声明的语言资源将被移除。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://link.jianshu.com/?t=https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="noopener">Shrink Your Code and Resources</a></li><li><a href="https://link.jianshu.com/?t=http://proguard.sourceforge.net" target="_blank" rel="noopener">proguard</a></li><li><a href="https://link.jianshu.com/?t=http://blog.csdn.net/sinyu890807/article/details/50451259" target="_blank" rel="noopener">Android安全攻防战，反编译与混淆技术完全解析（下）</a></li><li><a href="https://www.jianshu.com/p/7436a1a32891" target="_blank" rel="noopener">Android混淆从入门到精通</a></li><li><a href="https://link.jianshu.com/?t=http://rensanning.iteye.com/blog/2224635" target="_blank" rel="noopener">Android代码混淆之ProGuard</a></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><code>proguard-android.txt</code>文件内容</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包名不混合大小写</span></span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"></span><br><span class="line"><span class="comment">#不跳过非公共的库的类</span></span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"></span><br><span class="line"><span class="comment">#混淆时记录日志</span></span><br><span class="line">-verbose</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭预校验</span></span><br><span class="line">-dontpreverify</span><br><span class="line"></span><br><span class="line"><span class="comment">#不优化输入的类文件</span></span><br><span class="line">-dontoptimize</span><br><span class="line"></span><br><span class="line"><span class="comment">#保护注解</span></span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line"></span><br><span class="line"><span class="comment">#保持所有拥有本地方法的类名及本地方法名</span></span><br><span class="line">-keepclasseswithmembernames <span class="class"><span class="keyword">class</span> * &#123;</span></span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#保持自定义View的get和set相关方法</span></span><br><span class="line">-keepclassmembers public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> &#123;</span></span><br><span class="line">   void set*(***);</span><br><span class="line">   *** get*();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#保持Activity中View及其子类入参的方法</span></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span> &#123;</span></span><br><span class="line">   public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#枚举</span></span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    **[] $VALUES;</span><br><span class="line">    public *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Parcelable</span></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="title">implements</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Parcelable</span> &#123;</span></span><br><span class="line">  public static final android.os.Parcelable$Creator CREATOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#R文件的静态成员</span></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>$* &#123;</span></span><br><span class="line">    public static &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-dontwarn android.support.**</span><br><span class="line"></span><br><span class="line"><span class="comment">#keep相关注解</span></span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">annotation</span>.<span class="title">Keep</span></span></span><br><span class="line"></span><br><span class="line">-keep @android.support.annotation.Keep <span class="class"><span class="keyword">class</span> * &#123;*;</span>&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers <span class="class"><span class="keyword">class</span> * &#123;</span></span><br><span class="line">    @android.support.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers <span class="class"><span class="keyword">class</span> * &#123;</span></span><br><span class="line">    @android.support.annotation.Keep &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers <span class="class"><span class="keyword">class</span> * &#123;</span></span><br><span class="line">    @android.support.annotation.Keep &lt;init&gt;(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，这里说的的混淆其实是包括了代码压缩、代码混淆以及资源压缩等的优化过程。依靠 ProGuard，混淆流程将主项目以及依赖库中未被使用的类、类成员、方法、属性移除，这有助于规避64K方法数的瓶颈；同时，将类、类成员、方法重命名为无意义的简短名称，增加了逆向工程的难度。而依靠 Gradle 的 Android 插件，我们将移除未被使用的资源，可以有效减小 apk 安装包大小。&lt;/p&gt;
&lt;p&gt;本文由两部分构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分给出混淆的最佳实践，力求让零基础的新手都可以直接使用混淆；&lt;/li&gt;
&lt;li&gt;第二部分会介绍一下混淆的整体、自定义混淆规则的语法与实践、自定义资源保持的规则等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、Android混淆最佳实践&quot;&gt;&lt;a href=&quot;#一、Android混淆最佳实践&quot; class=&quot;headerlink&quot; title=&quot;一、Android混淆最佳实践&quot;&gt;&lt;/a&gt;一、Android混淆最佳实践&lt;/h2&gt;&lt;h3 id=&quot;1-混淆配置&quot;&gt;&lt;a href=&quot;#1-混淆配置&quot; class=&quot;headerlink&quot; title=&quot;1. 混淆配置&quot;&gt;&lt;/a&gt;1. 混淆配置&lt;/h3&gt;&lt;p&gt;一般情况下，app module 的 &lt;code&gt;build.gradle&lt;/code&gt; 文件默认会有如下结构：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buildTypes &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        release &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minifyEnabled &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            proguardFiles getDefaultProguardFile(&lt;span class=&quot;string&quot;&gt;&#39;proguard-android.txt&#39;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&#39;proguard-rules.pro&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为开启混淆会使编译时间变长，所以&lt;code&gt;debug&lt;/code&gt;模式下不应该开启。我们需要做的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;release&lt;/code&gt;下&lt;code&gt;minifyEnabled&lt;/code&gt;的值改为&lt;code&gt;true&lt;/code&gt;，打开混淆；&lt;/li&gt;
&lt;li&gt;加上&lt;code&gt;shrinkResources true&lt;/code&gt;，打开资源压缩。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改后文件内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buildTypes &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        release &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minifyEnabled &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            shrinkResources &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            proguardFiles getDefaultProguardFile(&lt;span class=&quot;string&quot;&gt;&#39;proguard-android.txt&#39;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&#39;proguard-rules.pro&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android Activity标签属性</title>
    <link href="https://zhangmiao.cc/posts/9bf9542d.html"/>
    <id>https://zhangmiao.cc/posts/9bf9542d.html</id>
    <published>2019-10-17T03:40:27.000Z</published>
    <updated>2019-10-17T03:45:08.946Z</updated>
    
    <content type="html"><![CDATA[<p>Activity 是 Android 系统四大应用组件之一，用户可与 Activity 提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件等操作</p><p>开发者必须在清单文件中声明要使用的 Activity，这样系统才能访问它。声明方式是在 <strong>&lt; application &gt;</strong> 元素中添加 <strong>&lt; activity &gt;</strong> 子元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".Example"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以为<strong>&lt; activity &gt;</strong>元素设置多个属性值以定义 UI 风格或者运行属性。 <strong>android:name</strong> 属性是唯一必需的属性，用于指定 Activity 的类名</p><p>&lt; activity &gt;包含的属性如下所示</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:allowEmbedded=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:allowTaskReparenting=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:alwaysRetainTaskState=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:autoRemoveFromRecents=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:banner=<span class="string">"drawable resource"</span></span><br><span class="line">          android:clearTaskOnLaunch=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:configChanges=[<span class="string">"mcc"</span>, <span class="string">"mnc"</span>, <span class="string">"locale"</span>,</span><br><span class="line">                                 <span class="string">"touchscreen"</span>, <span class="string">"keyboard"</span>, <span class="string">"keyboardHidden"</span>,</span><br><span class="line">                                 <span class="string">"navigation"</span>, <span class="string">"screenLayout"</span>, <span class="string">"fontScale"</span>,</span><br><span class="line">                                 <span class="string">"uiMode"</span>, <span class="string">"orientation"</span>, <span class="string">"screenSize"</span>,</span><br><span class="line">                                 <span class="string">"smallestScreenSize"</span>]</span><br><span class="line">          android:documentLaunchMode=[<span class="string">"intoExisting"</span> | <span class="string">"always"</span> |</span><br><span class="line">                                  <span class="string">"none"</span> | <span class="string">"never"</span>]</span><br><span class="line">          android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:excludeFromRecents=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:finishOnTaskLaunch=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:hardwareAccelerated=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">          android:label=<span class="string">"string resource"</span></span><br><span class="line">          android:launchMode=[<span class="string">"standard"</span> | <span class="string">"singleTop"</span> |</span><br><span class="line">                              <span class="string">"singleTask"</span> | <span class="string">"singleInstance"</span>]</span><br><span class="line">          android:maxRecents=<span class="string">"integer"</span></span><br><span class="line">          android:multiprocess=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:name=<span class="string">"string"</span></span><br><span class="line">          android:noHistory=[<span class="string">"true"</span> | <span class="string">"false"</span>]  </span><br><span class="line">          android:parentActivityName=<span class="string">"string"</span> </span><br><span class="line">          android:permission=<span class="string">"string"</span></span><br><span class="line">          android:process=<span class="string">"string"</span></span><br><span class="line">          android:relinquishTaskIdentity=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:resizeableActivity=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:screenOrientation=[<span class="string">"unspecified"</span> | <span class="string">"behind"</span> |</span><br><span class="line">                                     <span class="string">"landscape"</span> | <span class="string">"portrait"</span> |</span><br><span class="line">                                     <span class="string">"reverseLandscape"</span> | <span class="string">"reversePortrait"</span> |</span><br><span class="line">                                     <span class="string">"sensorLandscape"</span> | <span class="string">"sensorPortrait"</span> |</span><br><span class="line">                                     <span class="string">"userLandscape"</span> | <span class="string">"userPortrait"</span> |</span><br><span class="line">                                     <span class="string">"sensor"</span> | <span class="string">"fullSensor"</span> | <span class="string">"nosensor"</span> |</span><br><span class="line">                                     <span class="string">"user"</span> | <span class="string">"fullUser"</span> | <span class="string">"locked"</span>]</span><br><span class="line">          android:stateNotNeeded=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:supportsPictureInPicture=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">          android:taskAffinity=<span class="string">"string"</span></span><br><span class="line">          android:theme=<span class="string">"resource or theme"</span></span><br><span class="line">          android:uiOptions=[<span class="string">"none"</span> | <span class="string">"splitActionBarWhenNarrow"</span>]</span><br><span class="line">          android:windowSoftInputMode=[<span class="string">"stateUnspecified"</span>,</span><br><span class="line">                                       <span class="string">"stateUnchanged"</span>, <span class="string">"stateHidden"</span>,</span><br><span class="line">                                       <span class="string">"stateAlwaysHidden"</span>, <span class="string">"stateVisible"</span>,</span><br><span class="line">                                       <span class="string">"stateAlwaysVisible"</span>, <span class="string">"adjustUnspecified"</span>,</span><br><span class="line">                                       <span class="string">"adjustResize"</span>, <span class="string">"adjustPan"</span>] &gt;                        </span><br><span class="line">&lt;<span class="regexp">/activity&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="一、android-allowEmbedded"><a href="#一、android-allowEmbedded" class="headerlink" title="一、android:allowEmbedded**"></a>一、android:allowEmbedded**</h2><p>表示该 Activity 可作为另一 Activity 的嵌入式子项启动。 它尤其适用于子项所在的容器（如 Display）为另一 Activity 所拥有的情况。 例如，用于 Wear 自定义通知的 Activity 必须声明此项，以便 Wear 在其上下文流中显示 Activity，后者位于另一进程中。该属性的默认值为 false</p><h2 id="二、android-allowTaskReparenting"><a href="#二、android-allowTaskReparenting" class="headerlink" title="二、android:allowTaskReparenting"></a><strong>二、android:allowTaskReparenting</strong></h2><p>当启动 Activity 的任务接下来转至前台时，Activity 是否能从该任务转移至与其有亲和关系的任务。“true”表示它可以转移，“false”表示它仍须留在启动它的任务处。如果未设置该属性，则对 Activity 采用由 <strong>&lt; application &gt;</strong> 元素的 <strong>allowTaskReparenting</strong> 属性设置的值。 默认值为“false”</p><p>正常情况下，当 Activity 启动时，会与启动它的任务关联，并在其整个生命周期中一直留在该任务处。可以利用该属性强制 Activity 在其当前任务不再显示时将其父项更改为与其有亲和关系的任务。该属性通常用于使应用的 </p><p>Activity 转移至与该应用关联的主任务<br>例如，如果电子邮件包含网页链接，则点击链接会调出可显示网页的 Activity。 该 Activity 由浏览器应用定义，但作为电子邮件任务的一部分启动。 如果将其父项更改为浏览器任务，它会在浏览器下一次转至前台时显示，当电子邮件任务再次转至前台时则会消失</p><p>Activity 的亲和关系由 <strong>taskAffinity</strong> 属性定义。 任务的亲和关系通过读取其根 Activity 的亲和关系来确定。因此，按照定义，根 Activity 始终位于具有相同亲和关系的任务之中。 由于具有“<strong>singleTask</strong>”或“<strong>singleInstance</strong>”启动模式的 Activity 只能位于任务的根，因此更改父项仅限于“<strong>standard</strong>”和“<strong>singleTop</strong>”模式</p><h2 id="三、android-alwaysRetainTaskState"><a href="#三、android-alwaysRetainTaskState" class="headerlink" title="三、android:alwaysRetainTaskState"></a><strong>三、android:alwaysRetainTaskState</strong></h2><p>系统是否始终保持 Activity 所在任务的状态 ，“true”表示保持，“false”表示允许系统在特定情况下将任务重置到其初始状态。 默认值为“false”。该属性只对任务的根 Activity 有意义，对于所有其他 Activity，均忽略该属性</p><p>正常情况下，当用户从主屏幕重新选择某个任务时，系统会在特定情况下清除该任务（从根 Activity 之上的堆栈中移除所有 Activity）。 系统通常会在用户一段时间（如 30 分钟）内未访问任务时执行此操作</p><p>不过，如果该属性的值是“true”，则无论用户如何到达任务，将始终返回到最后状态的任务。 例如，在网络浏览器这类存在大量用户不愿失去的状态（如多个打开的标签）的应用中，该属性会很有用</p><h2 id="四、android-autoRemoveFromRecents"><a href="#四、android-autoRemoveFromRecents" class="headerlink" title="四、android:autoRemoveFromRecents"></a><strong>四、android:autoRemoveFromRecents</strong></h2><p>由具有该属性的 Activity 启动的任务是否一直保留在概览屏幕中，直至任务中的最后一个 Activity 完成为止。 若为 true，则自动从概览屏幕中移除任务。 它会替换调用方使用的 <strong>FLAG_ACTIVITY_RETAIN_IN_RECENTS</strong></p><h2 id="五、android-banner"><a href="#五、android-banner" class="headerlink" title="五、android:banner"></a><strong>五、android:banner</strong></h2><p>一种为其关联项提供扩展图形化横幅的可绘制资源。 将其与 <strong>&lt; activity &gt;</strong> 标记联用可为特定 Activity 提供默认横幅，也可与 <strong>&lt; application &gt;</strong> 标记联用，为所有应用 Activity 提供横幅</p><p>系统使用横幅在 Android TV 主屏幕中表示应用。 由于横幅只显示在主屏幕中，因此只应由包含的 Activity 能够处理 <strong>CATEGORY_LEANBACK_LAUNCHER Intent</strong> 的应用指定</p><p>必须将该属性设置为对包含图像的可绘制资源的引用（例如 “@drawable/banner”），该属性没有默认值</p><h2 id="六、android-clearTaskOnLaunch"><a href="#六、android-clearTaskOnLaunch" class="headerlink" title="六、android:clearTaskOnLaunch"></a><strong>六、android:clearTaskOnLaunch</strong></h2><p>是否每当从主屏幕重新启动任务时都从中移除根 Activity 之外的所有 Activity ，“true”表示始终将任务清除到只剩其根 Activity，“false”表示不做清除。 默认值为“false”。该属性只对启动新任务的 Activity（根 Activity）有意义；对于任务中的所有其他 Activity，均忽略该属性</p><p>当值为“true”时，每次用户再次启动任务时，无论用户最后在任务中正在执行哪个 Activity，也无论用户是使用返回还是主屏幕按钮离开，都会将用户转至任务的根 Activity。 当值为“false”时，可在某些情况下清除任务中的 Activity（请参阅 <strong>alwaysRetainTaskState</strong> 属性），但并非一律可以</p><p>例如，假定有人从主屏幕启动了 Activity P，然后从那里转到 Activity Q。该用户接着按了主屏幕按钮，然后返回到 Activity P。正常情况下，用户将看到 Activity Q，因为那是其最后在 P 的任务中执行的 Activity。 不过，如果 P 将此标志设置为“true”，则当用户按下主屏幕将任务转入后台时，其上的所有 Activity（在本例中为 Q）都会被移除， 因此用户返回任务时只会看到 P</p><p>如果该属性和 <strong>allowTaskReparenting</strong> 的值均为“true”，则如上所述，任何可以更改父项的 Activity 都将转移到与其有亲和关系的任务，其余 Activity 随即被移除</p><h2 id="七、android-configChanges"><a href="#七、android-configChanges" class="headerlink" title="七、android:configChanges"></a><strong>七、android:configChanges</strong></h2><p>列出 Activity 将自行处理的配置更改。在运行时发生配置更改时，默认情况下会关闭 Activity 然后将其重新启动，但使用该属性声明配置将阻止 Activity 重新启动。 Activity 会保持运行状态，并且系统会调用其 <strong>onConfigurationChanged()</strong> 方法。应避免使用该属性，并且只应在万不得已的情况下使用</p><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mcc</td><td align="center">IMSI 移动国家/地区代码 (MCC) 发生了变化 - 检测到了 SIM 并更新了 MCC</td></tr><tr><td align="center">mnc</td><td align="center">IMSI 移动网络代码 (MNC) 发生了变化 - 检测到了 SIM 并更新了 MNC</td></tr><tr><td align="center">locale</td><td align="center">语言区域发生了变化 — 用户为文本选择了新的显示语言</td></tr><tr><td align="center">touchscreen</td><td align="center">触摸屏发生了变化（这种情况通常永远不会发生）</td></tr><tr><td align="center">keyboard</td><td align="center">键盘类型发生了变化 — 例如，用户插入了一个外置键盘</td></tr><tr><td align="center">keyboardHidden</td><td align="center">键盘无障碍功能发生了变化 — 例如，用户显示了硬件键盘</td></tr><tr><td align="center">navigation</td><td align="center">导航类型（轨迹球/方向键）发生了变化（这种情况通常永远不会发生）</td></tr><tr><td align="center">screenLayout</td><td align="center">屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致</td></tr><tr><td align="center">fontScale</td><td align="center">字体缩放系数发生了变化 — 用户选择了新的全局字号</td></tr><tr><td align="center">uiMode</td><td align="center">用户界面模式发生了变化 — 这可能是因用户将设备放入桌面/车载基座或夜间模式发生变化所致。 请参阅 UiModeManager。 此项为 API 级别 8 中新增配置</td></tr><tr><td align="center">orientation</td><td align="center">屏幕方向发生了变化 — 用户旋转了设备。注：如果您的应用面向 API 级别 13 或更高级别（按照 minSdkVersion 和 targetSdkVersion 属性所声明的级别），则还应声明 “screenSize” 配置，因为当设备在横向与纵向之间切换时，该配置也会发生变化</td></tr><tr><td align="center">screenSize</td><td align="center">当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。此项为 API 级别 13 中新增配置</td></tr><tr><td align="center">smallestScreenSize</td><td align="center">物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。 对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。此项为 API 级别 13 中新增配置</td></tr><tr><td align="center">layoutDirection</td><td align="center">布局方向发生了变化。例如，从从左至右 (LTR) 更改为从右至左 (RTL)。 此项为 API 级别 17 中新增配置</td></tr></tbody></table><p>所有这些配置变更都可能影响应用看到的资源值。 因此，调用 <strong>onConfigurationChanged()</strong> 时，通常有必要再次获取所有资源（包括视图布局、可绘制对象等）以正确处理变化</p><h2 id="八、android-documentLaunchMode"><a href="#八、android-documentLaunchMode" class="headerlink" title="八、android:documentLaunchMode"></a><strong>八、android:documentLaunchMode</strong></h2><p>指定每次启动任务时应如何向其中添加新的 Activity 实例。 该属性允许用户让多个来自同一应用的文档出现在概览屏幕中<br>该属性有四个值，会在用户使用该应用打开文档时产生以下效果：</p><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">intoExisting</td><td align="center">Activity 会为文档重复使用现有任务。使用该值与不设置 FLAG_ACTIVITY_MULTIPLE_TASK 标志、但设置 FLAG_ACTIVITY_NEW_DOCUMENT 标志所产生的效果相同，如使用 Intent 标志添加任务中所述</td></tr><tr><td align="center">always</td><td align="center">Activity 为文档创建新任务，即便文档已打开也是如此。 这与同时设置 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标志的效果相同</td></tr><tr><td align="center">none</td><td align="center">该 Activity 不会为 Activity 创建新任务。这是默认值，它只会在设置了 FLAG_ACTIVITY_NEW_TASK 时创建新任务。 概览屏幕将按其默认方式对待此 Activity：为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行</td></tr><tr><td align="center">never</td><td align="center">即使 Intent 包含 FLAG_ACTIVITY_NEW_DOCUMENT，该 Activity 也不会启动到新文档之中。 设置此值会替代 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标志的行为（如果在 Activity 中设置了其中一个标志），并且概览屏幕将为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行</td></tr></tbody></table><p>对于除“<strong>none</strong>”和“<strong>never</strong>”以外的值，必须使用 <strong>launchMode=”standard”</strong> 定义 Activity。 如果未指定此属性，则使用 <strong>documentLaunchMode=”none”</strong></p><h2 id="九、android-enabled"><a href="#九、android-enabled" class="headerlink" title="九、android:enabled"></a><strong>九、android:enabled</strong></h2><p>系统是否可将 Activity 实例化 — “true” 表示可以，“false”表示不可以。 默认值为“true”</p><p><strong>&lt; application &gt;</strong> 元素具有自己的 <strong>enabled</strong> 属性，该属性适用于所有应用组件，包括 Activity。 <strong>&lt; application &gt;</strong> 和 <strong>&lt; activity &gt;</strong> 属性必须都是“true”（因为它们都默认使用该值），系统才能将 Activity 实例化。 如果任何一个属性是“false”，则无法进行实例化</p><h2 id="十、android-excludeFromRecents"><a href="#十、android-excludeFromRecents" class="headerlink" title="十、android:excludeFromRecents"></a><strong>十、android:excludeFromRecents</strong></h2><p>是否应将该 Activity 启动的任务排除在最近使用的应用列表（即概览屏幕）之外。 也就是说，当该 Activity 是新任务的根 Activity 时，此属性确定任务是否应出现在最近使用的应用列表中。 如果应将任务排除在列表之外，请设置“true”，如果应将其包括在内，则设置“false”。 默认值为“false”</p><h2 id="十一、android-exported"><a href="#十一、android-exported" class="headerlink" title="十一、android:exported"></a><strong>十一、android:exported</strong></h2><p>Activity 是否可由其他应用的组件启动 ，“true”表示可以，“false”表示不可以。若为“false”，则 Activity 只能由同一应用的组件或使用同一用户 ID 的不同应用启动</p><p>默认值取决于 Activity 是否包含 Intent 过滤器。没有任何过滤器意味着 Activity 只能通过指定其确切的类名称进行调用。 这意味着 Activity 专供应用内部使用（因为其他应用不知晓其类名称）。 因此，在这种情况下，默认值为“false”。另一方面，至少存在一个过滤器意味着 Activity 专供外部使用，因此默认值为“true”</p><p>该属性并非限制 Activity 对其他应用开放度的唯一手段。 您还可以利用权限来限制哪些外部实体可以调用 Activity（请参阅 permission 属性）</p><h2 id="十二、android-finishOnTaskLaunch"><a href="#十二、android-finishOnTaskLaunch" class="headerlink" title="十二、android:finishOnTaskLaunch"></a><strong>十二、android:finishOnTaskLaunch</strong></h2><p>每当用户再次启动其任务（在主屏幕上选择任务）时，是否应关闭（完成）现有 Activity 实例，“true”表示应关闭，“false”表示不应关闭。 默认值为“false”<br>如果该属性和 <strong>allowTaskReparenting</strong> 均为“true”，则优先使用该属性。 Activity 的亲和关系会被忽略。 系统不是更改 Activity 的父项，而是将其销毁</p><h2 id="十三、android-hardwareAccelerated"><a href="#十三、android-hardwareAccelerated" class="headerlink" title="十三、android:hardwareAccelerated"></a><strong>十三、android:hardwareAccelerated</strong></h2><p>是否应为此 Activity 启用硬件加速渲染，“true”表示应启用，“false”表示不应启用。 默认值为“false”</p><p>从 Android 3.0 开始，为应用提供了硬件加速 OpenGL 渲染器，以改善许多常见 2D 图形运算的性能。 启用硬件加速渲染器时，Canvas、Paint、Xfermode、ColorFilter、Shader 和 Camera 中的大多数运算都会得到加速。这可以提高动画、滚动的流畅度和总体响应速度，即便是并不明确使用框架 OpenGL 库的应用也会受益。 由于启用硬件加速会增加资源消耗，因此应用将占用更多内存</p><p>请注意，并非所有 OpenGL 2D 运算都会得到加速。如果启用硬件加速渲染器，请对应用进行测试，以确保其在利用渲染器时不会出错</p><h2 id="十四、android-icon"><a href="#十四、android-icon" class="headerlink" title="十四、android:icon"></a><strong>十四、android:icon</strong></h2><p>Activity 的图标。该图标会在需要在屏幕上表示 Activity 时显示给用户。 例如，代表启动任务的 Activity 的图标显示在启动器窗口中。该图标通常附带标签（请参阅 android:label 属性）</p><p>必须将该属性设置为对包含图像定义的可绘制资源的引用。 如果未设置该属性，则改为使用为应用整体指定的图标（请参阅 &lt; application &gt; 元素的 icon 属性）</p><p>这个 Activity 的图标 — 无论设置于此处还是由 <strong>&lt; application &gt;</strong> 元素设置 — 同时也是 Activity 所有 Intent 过滤器的默认图标（请参阅 &lt; intent-filter &gt; 元素的 icon 属性）</p><h2 id="十五、android-label"><a href="#十五、android-label" class="headerlink" title="十五、android:label"></a><strong>十五、android:label</strong></h2><p>一种可由用户读取的 Activity 标签。该标签会在必须将 Activity 呈现给用户时显示在屏幕上。 它通常与 Activity 图标一并显示</p><p>如果未设置该属性，则改为使用为应用整体设置的标签（请参阅 &lt; application &gt; 元素的 label 属性）</p><p>这个 Activity 的标签 — 无论设置于此处还是由 <strong>&lt; application &gt;</strong> 元素设置 — 同时也是 Activity 所有 Intent 过滤器的默认标签（请参阅 &lt; intent-filter &gt; 元素的 label 属性）</p><p>应将该标签设置为对字符串资源的引用，以便可以像用户界面中的其他字符串那样进行本地化。不过，为便于开发应用，也可将其设置为原始字符串</p><h2 id="十六、android-launchMode"><a href="#十六、android-launchMode" class="headerlink" title="十六、android:launchMode"></a><strong>十六、android:launchMode</strong></h2><p>有关应如何启动 Activity 的指令。共有四种模式与 Intent 对象中的 Activity 标志（<em>FLAG_ACTIVITY_ 常量*</em>）协同工作，以确定在调用 Activity 处理 Intent 时应执行的操作。 这些模式是：standard 、singleTop 、singleTask 、singleInstance<br>默认模式是“standard”****</p><p>如下表所示，这些模式分为两大类，“standard”和“singleTop”Activity 为一类，“singleTask”和“singleInstance”为另一类。使用“standard”或“singleTop”启动模式的 Activity 可多次实例化。 实例可归属任何任务，并且可以位于 Activity 堆栈中的任何位置。 它们通常启动到名为 <strong>startActivity()</strong> 的任务之中（除非 Intent 对象包含 <strong>FLAG_ACTIVITY_NEW_TASK</strong> 指令，在此情况下会选择其他任务，请参阅 <strong>taskAffinity</strong> 属性）</p><p>相比之下，“singleTask”和“singleInstance”Activity 只能启动任务。 它们始终位于 Activity 堆栈的根位置。此外，设备一次只能保留一个 Activity 实例 — 只允许一个此类任务</p><p>“standard”和“singleTop”模式只在一个方面有差异： 每次“standard”Activity 有新的 Intent 时，系统都会创建新的类实例来响应该 Intent。每个实例处理单个 Intent。同理，也可创建新的“singleTop”Activity 实例来处理新的 Intent。 不过，如果目标任务在其堆栈顶部已有一个 Activity 实例，那么该实例将接收新 Intent（通过调用 <strong>onNewIntent()</strong>）；此时不会创建新实例。在其他情况下 — 例如，如果“singleTop”的一个现有实例虽在目标任务内，但未处于堆栈顶部，或者虽然位于堆栈顶部，但不在目标任务中 — 则系统会创建一个新实例并将其推送到堆栈上</p><p>同理，如果您向上导航到当前堆栈上的某个 Activity，该行为由父 Activity 的启动模式决定。 如果父 Activity 有启动模式 singleTop（或 <strong>up Intent</strong> 包含 <strong>FLAG_ACTIVITY_CLEAR_TOP</strong>），则系统会将该父项置于堆栈顶部，并保留其状态。 导航 Intent 由父 Activity 的 <strong>onNewIntent()</strong> 方法接收。 如果父 Activity 有启动模式 standard（并且 <strong>up Intent</strong> 不包含 <strong>FLAG_ACTIVITY_CLEAR_TOP</strong>），则系统会将当前 Activity 及其父项同时弹出堆栈，并创建一个新的父 Activity 实例来接收导航 Intent</p><p>“singleTask”和“singleInstance”模式同样只在一个方面有差异： “singleTask”Activity 允许其他 Activity 成为其任务的组成部分。 它始终位于其任务的根位置，但其他 Activity（必然是“standard”和“singleTop”Activity）可以启动到该任务中。 相反，“singleInstance”Activity 则不允许其他 Activity 成为其任务的组成部分。它是任务中唯一的 Activity。 如果它启动另一个 Activity，系统会将该 Activity 分配给其他任务 — 就好像 Intent 中包含 <strong>FLAG_ACTIVITY_NEW_TASK</strong> 一样。</p><table><thead><tr><th align="center">用例</th><th align="center">启动模式</th><th align="center">多个实例？</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">大多数 Activity 的正常启动</td><td align="center">standard</td><td align="center">是</td><td align="center">默认值。系统始终会在目标任务中创建新的 Activity 实例并向其传送 Intent</td></tr><tr><td align="center">大多数 Activity 的正常启动</td><td align="center">singleTop</td><td align="center">有条件</td><td align="center">如果目标任务的顶部已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例</td></tr><tr><td align="center">专用启动（不建议用作常规用途）</td><td align="center">singleTask</td><td align="center">否</td><td align="center">系统在新任务的根位置创建 Activity 并向其传送 Intent。 不过，如果已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例</td></tr><tr><td align="center">专用启动（不建议用作常规用途）</td><td align="center">singleInstance</td><td align="center">否</td><td align="center">与“singleTask””相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员</td></tr></tbody></table><p>如上表所示，standard 是默认模式，并且适用于大多数的 Activity 类型。对许多类型的 Activity 而言，SingleTop 也是一个常见并且有用的启动模式。 其他模式 — singleTask 和 singleInstance 不适合大多数应用因为它们所形成的交互模式可能让用户感到陌生，并且与大多数其他应用迥异。</p><p>无论选择哪一种启动模式，请务必在启动期间以及使用返回按钮从其他 Activity 和任务返回该 Activity 时对其进行易用性测试。</p><h2 id="十七、android-maxRecents"><a href="#十七、android-maxRecents" class="headerlink" title="十七、android:maxRecents"></a><strong>十七、android:maxRecents</strong></h2><p>概览屏幕中位于此 Activity 根位置的任务数上限。 达到该条目数时，系统会从概览屏幕中移除最近最少使用的实例。 该值必须是整数，有效值为 1-50（低内存设备使用 25），默认值为 16</p><h2 id="十八、android-multiprocess"><a href="#十八、android-multiprocess" class="headerlink" title="十八、android:multiprocess"></a><strong>十八、android:multiprocess</strong></h2><p>是否可以将 Activity 实例启动到启动该实例的组件进程内 ，“true”表示可以，“false”表示不可以。默认值为“false”<br>正常情况下，新的 Activity 实例会启动到定义它的应用进程内，因此所有 Activity 实例都在同一进程内运行。 不过，如果该标志设置为“true”，Activity 实例便可在多个进程内运行，这样系统就能在任何使用实例的地方创建实例（前提是权限允许这样做），但这几乎毫无必要性或可取之处</p><h2 id="十九、android-name"><a href="#十九、android-name" class="headerlink" title="十九、android:name"></a><strong>十九、android:name</strong></h2><p>实现 Activity 的类的名称，是 Activity 的子类。 该属性值应为完全限定类名称（例如，“<strong>com.example.project.ExtracurricularActivity</strong>”）。不过，为了简便起见，如果名称的第一个字符是句点（例如，“.ExtracurricularActivity”），则名称将追加到 <strong>&lt; manifest &gt;</strong> 元素中指定的软件包名称。开发者必须指定该名称</p><h2 id="二十、android-noHistory"><a href="#二十、android-noHistory" class="headerlink" title="二十、android:noHistory"></a><strong>二十、android:noHistory</strong></h2><p>当用户离开 Activity 并且其在屏幕上不再可见时，是否应从 Activity 堆栈中将其移除并调用其 finish() 方法。默认值为“false”，“true”值表示 Activity 不会留下历史轨迹。 它不会留在任务的 Activity 堆栈内，因此用户将无法返回 Activity。 在此情况下，如果启动另一个 Activity 来获取该 Activity 的结果，系统永远不会调用 <strong>onActivityResult()</strong>。该属性是在 API 级别 3 引入的</p><h2 id="二十一、android-parentActivityName"><a href="#二十一、android-parentActivityName" class="headerlink" title="二十一、android:parentActivityName"></a><strong>二十一、android:parentActivityName</strong></h2><p>Activity 逻辑父项的类名称。此处的名称必须与为相应 <strong>&lt; activity &gt;</strong> 元素的 <strong>android:name</strong> 属性指定的类名称一致</p><p>系统会读取该属性，以确定当用户按下操作栏中的“向上”按钮时应该启动哪一个 Activity。 系统还可以利用这些信息通过 <strong>TaskStackBuilder</strong> 合成 Activity 的返回栈</p><p>该属性是在 API 级别 16 引入的，要支持 API 级别 4 - 16，还可以使用为 “<strong>android.support.PARENT_ACTIVITY</strong>“ 指定值的 <strong>&lt; meta-data &gt;</strong> 元素来声明父 Activity。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.app.ChildActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/title_child_activity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:parentActivityName</span>=<span class="string">"com.example.app.MainActivity"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Parent activity meta-data to support API level 4+ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.PARENT_ACTIVITY"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">"com.example.app.MainActivity"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二十二、android-permission"><a href="#二十二、android-permission" class="headerlink" title="二十二、android:permission"></a><strong>二十二、android:permission</strong></h2><p>客户端启动 Activity 或以其他方式令其响应 Intent 而必须具备的权限的名称。 如果系统尚未向 <strong>startActivity()</strong> 或 <strong>startActivityForResult()</strong> 的调用方授予指定权限，其 Intent 将不会传递给 Activity<br>如果未设置该属性，则对 Activity 应用 <strong>&lt; application &gt;</strong> 元素的 <strong>permission</strong> 属性设置的权限。 如果这两个属性均未设置，则 Activity 不受权限保护</p><h2 id="二十三、android-process"><a href="#二十三、android-process" class="headerlink" title="二十三、android:process"></a><strong>二十三、android:process</strong></h2><p>应在其中运行 Activity 的进程的名称。正常情况下，应用的所有组件都在为应用创建的默认进程名称内运行，无需使用该属性。 但在必要时，可以使用该属性替换默认进程名称，以便让应用组件散布到多个进程中</p><p>如果为该属性分配的名称以冒号（“:”）开头，则会在需要时创建应用专用的新进程，并且 Activity 会在该进程中运行。如果进程名称以小写字符开头，Activity 将在该名称的全局进程中运行，前提是它拥有相应的权限。这可以让不同应用中的组件共享一个进程，从而减少资源占用</p><p><strong>&lt; application &gt;</strong> 元素的 process 属性可为所有组件设置一个不同的默认进程名称</p><h2 id="二十四、android-relinquishTaskIdentity"><a href="#二十四、android-relinquishTaskIdentity" class="headerlink" title="二十四、android:relinquishTaskIdentity"></a><strong>二十四、android:relinquishTaskIdentity</strong></h2><p>Activity 是否将其任务标识符交给任务栈中在其之上的 Activity。 如果任务根 Activity 的该属性设置为“true”，则任务会用其内的下一个 Activity 的 Intent 替换基本 Intent。 如果下一个 Activity 的该属性也设置为“true”，则该 Activity 会将基本 Intent 给予其在同一任务中启动的任何 Activity。 系统继续为每个 Activity 执行此过程，直至遇到的某个 Activity 将该属性设置为“false”为止。 默认值为“false”</p><p>如果该属性设置为“true”，则 Activity 还可利用 ActivityManager.TaskDescription 来更改概览屏幕中的标签、颜色和图标</p><h2 id="二十五、android-resizeableActivity"><a href="#二十五、android-resizeableActivity" class="headerlink" title="二十五、android:resizeableActivity"></a><strong>二十五、android:resizeableActivity</strong></h2><p>指定应用是否支持多窗口显示。您可以在 <strong>&lt; activity &gt;</strong> 或 <strong>&lt; application &gt;</strong> 元素中设置该属性</p><p>如果将该属性设置为 true，则用户可以分屏和自由形状模式启动 Activity。 如果将该属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示</p><p>该属性是在 API 级别 24 添加的，如果应用面向 API 级别 24 或更高级别，但未对该属性指定值，则该属性的值默认设为 true</p><h2 id="二十六、android-screenOrientation"><a href="#二十六、android-screenOrientation" class="headerlink" title="二十六、android:screenOrientation"></a><strong>二十六、android:screenOrientation</strong></h2><p>Activity 在设备上的显示方向。如果 Activity 是在多窗口模式下运行，系统会忽略该属性<br>其值可以是下列任一字符串：</p><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">unspecified</td><td align="center">默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文所做的选择可能有所差异</td></tr><tr><td align="center">behind</td><td align="center">与 Activity 栈中紧接着它的 Activity 的方向相同</td></tr><tr><td align="center">landscape</td><td align="center">横向方向（显示的宽度大于高度）</td></tr><tr><td align="center">portrait</td><td align="center">纵向方向（显示的高度大于宽度）</td></tr><tr><td align="center">reverseLandscape</td><td align="center">与正常横向方向相反的横向方向。API 级别 9 中的新增配置</td></tr><tr><td align="center">reversePortrait</td><td align="center">与正常纵向方向相反的纵向方向。API 级别 9 中的新增配置</td></tr><tr><td align="center">sensorLandscape</td><td align="center">横向方向，但根据设备传感器，可以是正常或反向的横向方向。API 级别 9 中的新增配置</td></tr><tr><td align="center">sensorPortrait</td><td align="center">纵向方向，但根据设备传感器，可以是正常或反向的纵向方向。API 级别 9 中的新增配置</td></tr><tr><td align="center">userLandscape</td><td align="center">横向方向，但根据设备传感器和用户的传感器首选项，可以是正常或反向的横向方向。 如果用户锁定了基于传感器的旋转，其行为与 landscape 相同，否则，其行为与 sensorLandscape 相同。API 级别 18 中的新增配置</td></tr><tr><td align="center">userPortrait</td><td align="center">纵向方向，但根据设备传感器和用户的传感器首选项，可以是正常或反向的纵向方向。 如果用户锁定了基于传感器的旋转，其行为与 portrait 相同，否则，其行为与 sensorPortrait 相同。API 级别 18 中的新增配置</td></tr><tr><td align="center">sensor</td><td align="center">方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。 但一些设备默认情况下不会旋转到所有四种可能的方向。要允许全部四种方向，请使用 “fullSensor”</td></tr><tr><td align="center">fullSensor</td><td align="center">方向由 4 种方向中任一方向的设备方向传感器决定。这与 “sensor” 类似，不同的是它允许所有 4 种可能的屏幕方向，无论设备正常情况下采用什么方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但它支持这些方向）。 API 级别 9 中的新增配置</td></tr><tr><td align="center">nosensor</td><td align="center">决定方向时不考虑物理方向传感器。传感器会被忽略，因此显示不会随用户对设备的移动而旋转。 除了这个区别，系统在选择方向时使用的政策与“unspecified”设置相同</td></tr><tr><td align="center">user</td><td align="center">用户当前的首选方向</td></tr><tr><td align="center">fullUser</td><td align="center">如果用户锁定了基于传感器的旋转，其行为与 user 相同，否则，其行为与 fullSensor 相同，允许所有 4 种可能的屏幕方向。 API 级别 18 中的新增配置</td></tr><tr><td align="center">locked</td><td align="center">将方向锁定在其当前的任意旋转方向。API 级别 18 中的新增配置</td></tr></tbody></table><p>如果声明其中一个横向或纵向值，系统将其视为对 Activity 运行方向的硬性要求。 因此，声明的值支持通过 Google Play 之类的服务进行过滤，这样就能将应用只提供给支持 Activity 所要求方向的设备。 例如，如果声明了 “landscape”、”reverseLandscape” 或 “sensorLandscape”，则应用将只提供给支持横向方向的设备。 不过，还应通过 <strong>&lt; uses-feature &gt;</strong> 元素明确声明，应用要求采用纵向或横向方向。 例如，<strong>&lt; uses-feature android:name=”android.hardware.screen.portrait”/ &gt;</strong>。这纯粹是 Google Play（以及其他支持它的服务）提供的一种过滤行为，平台本身并不能控制当设备仅支持特定方向时应用能否安装</p><h2 id="二十七、android-stateNotNeeded"><a href="#二十七、android-stateNotNeeded" class="headerlink" title="二十七、android:stateNotNeeded"></a><strong>二十七、android:stateNotNeeded</strong></h2><p>能否在不保存 Activity 状态的情况下将其终止并成功重新启动 ，“true”表示可在不考虑其之前状态的情况下重新启动，“false”表示需要之前状态。 默认值为“false”</p><p>正常情况下，为保存资源而暂时关闭 Activity 前，系统会调用其 <strong>onSaveInstanceState()</strong> 方法。 该方法将 Activity 的当前状态存储在一个 <strong>Bundle</strong> 对象中，然后在 Activity 重新启动时将其传递给 onCreate()。 如果该属性设置为“true”，系统可能不会调用 <strong>onSaveInstanceState()</strong>，并且会向 onCreate() 传递 null 而不是 Bundle，这与它在 Activity 首次启动时完全一样</p><p>“true”设置可确保 Activity 能够在未保留状态时重新启动。 例如，显示主屏幕的 Activity 可以使用该设置来确保其由于某种原因崩溃时不会被移除</p><h2 id="二十八、android-supportsPictureInPicture"><a href="#二十八、android-supportsPictureInPicture" class="headerlink" title="二十八、android:supportsPictureInPicture"></a><strong>二十八、android:supportsPictureInPicture</strong></h2><p>指定 Activity 是否支持画中画显示。如果 android:resizeableActivity 是 false，系统会忽略该属性。该属性是在 API 级别 24 添加的</p><h2 id="二十九、android-taskAffinity"><a href="#二十九、android-taskAffinity" class="headerlink" title="二十九、android:taskAffinity"></a><strong>二十九、android:taskAffinity</strong></h2><p>与 Activity 有着亲和关系的任务。从概念上讲，具有相同亲和关系的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。 任务的亲和关系由其根 Activity 的亲和关系确定</p><p>亲和关系确定两件事 - Activity 更改到的父项任务（请参阅 <strong>allowTaskReparenting</strong> 属性）和通过 <strong>FLAG_ACTIVITY_NEW_TASK</strong> 标志启动 Activity 时将用来容纳它的任务</p><p>默认情况下，应用中的所有 Activity 都具有相同的亲和关系。您可以设置该属性来以不同方式组合它们，甚至可以将在不同应用中定义的 Activity 置于同一任务内。 要指定 Activity 与任何任务均无亲和关系，请将其设置为空字符串</p><p>如果未设置该属性，则 Activity 继承为应用设置的亲和关系（请参阅 <strong>&lt; application &gt;</strong> 元素的 <strong>taskAffinity</strong> 属性）。 应用默认亲和关系的名称是 <strong>&lt; manifest &gt;</strong> 元素设置的软件包名称</p><h2 id="三十、android-theme"><a href="#三十、android-theme" class="headerlink" title="三十、android:theme"></a><strong>三十、android:theme</strong></h2><p>对定义 Activity 总体主题的样式资源的引用。它会自动将 Activity 的上下文设置为使用该主题，它还可以引发 Activity 启动前的“启动”动画以更加符合 Activity 的实际外观</p><p>如果未设置该属性，则 Activity 继承通过 <strong>&lt; application &gt;</strong> 元素的 theme 属性为应用整体设置的主题。 如果该属性也未设置，则使用默认系统主题</p><h2 id="三十一、android-uiOptions"><a href="#三十一、android-uiOptions" class="headerlink" title="三十一、android:uiOptions"></a><strong>三十一、android:uiOptions</strong></h2><p>针对 Activity UI 的附加选项，该属性是在 API 级别 14 添加的，必须是下列值之一</p><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">无附加 UI 选项。这是默认值</td></tr><tr><td align="center">splitActionBarWhenNarrow</td><td align="center">当水平空间受限时（例如在手持设备上的纵向模式下时）在屏幕底部添加一个栏以显示应用栏（也称为操作栏）中的操作项）。 应用栏不是以少量操作项形式出现在屏幕顶部的应用栏中，而是分成了顶部导航区和底部操作项栏。 这可以确保操作项以及顶部的导航和标题元素都能获得合理的空间。 菜单项不会拆分到两个栏中，它们始终一起出现</td></tr></tbody></table><h2 id="三十二、android-windowSoftInputMode"><a href="#三十二、android-windowSoftInputMode" class="headerlink" title="三十二、android:windowSoftInputMode"></a><strong>三十二、android:windowSoftInputMode</strong></h2><p>Activity 的主窗口与包含屏幕软键盘的窗口的交互方式。 该属性是在 API 级别 3 引入的<br>该属性的设置影响两个方面：</p><ul><li>当 Activity 成为用户注意的焦点时软键盘的状态 — 隐藏还是可见。</li><li>对 Activity 主窗口所做的调整 — 是否将其尺寸调小以为软键盘腾出空间，或者当窗口部分被软键盘遮挡时是否平移其内容以使当前焦点可见</li></ul><p>该设置必须是下表所列的值之一，或者是一个“state…”值加上一个“adjust…”值的组合。 在任一组中设置多个值（例如，多个“state…”值）都会产生未定义结果。各值之间使用垂直条“ | ”分隔</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:windowSoftInputMode</span>=<span class="string">"stateVisible|adjustResize"</span> <span class="attr">.</span> <span class="attr">.</span> <span class="attr">.</span> &gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">stateUnspecified</td><td align="center">不指定软键盘的状态（隐藏还是可见）。 将由系统选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置</td></tr><tr><td align="center">stateUnchanged</td><td align="center">当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏</td></tr><tr><td align="center">stateHidden</td><td align="center">当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 隐藏软键盘</td></tr><tr><td align="center">stateAlwaysHidden</td><td align="center">当 Activity 的主窗口有输入焦点时始终隐藏软键盘</td></tr><tr><td align="center">stateVisible</td><td align="center">在正常的适宜情况下（当用户向前导航到 Activity 的主窗口时）显示软键盘</td></tr><tr><td align="center">stateAlwaysVisible</td><td align="center">当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 显示软键盘</td></tr><tr><td align="center">adjustUnspecified</td><td align="center">不指定 Activity 的主窗口是否调整尺寸以为软键盘腾出空间，或者窗口内容是否进行平移以在屏幕上显露当前焦点。 系统会根据窗口的内容是否存在任何可滚动其内容的布局视图来自动选择其中一种模式。 如果存在这样的视图，窗口将进行尺寸调整，前提是可通过滚动在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置</td></tr><tr><td align="center">adjustResize</td><td align="center">始终调整 Activity 主窗口的尺寸来为屏幕上的软键盘腾出空间</td></tr><tr><td align="center">adjustPan</td><td align="center">不调整 Activity 主窗口的尺寸来为软键盘腾出空间， 而是自动平移窗口的内容，使当前焦点永远不被键盘遮盖，让用户始终都能看到其输入的内容。 这通常不如尺寸调正可取，因为用户可能需要关闭软键盘以到达被遮盖的窗口部分或与这些部分进行交互</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Activity 是 Android 系统四大应用组件之一，用户可与 Activity 提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件等操作&lt;/p&gt;
&lt;p&gt;开发者必须在清单文件中声明要使用的 Activity，这样系统才能访问它。声明方式是在 &lt;strong&gt;&amp;lt; application &amp;gt;&lt;/strong&gt; 元素中添加 &lt;strong&gt;&amp;lt; activity &amp;gt;&lt;/strong&gt; 子元素&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:allowBackup&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:icon&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@mipmap/ic_launcher&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:label&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@string/app_name&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:supportsRtl&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:theme&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@style/AppTheme&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;.Example&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以为&lt;strong&gt;&amp;lt; activity &amp;gt;&lt;/strong&gt;元素设置多个属性值以定义 UI 风格或者运行属性。 &lt;strong&gt;android:name&lt;/strong&gt; 属性是唯一必需的属性，用于指定 Activity 的类名&lt;/p&gt;
&lt;p&gt;&amp;lt; activity &amp;gt;包含的属性如下所示&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;activity android:allowEmbedded=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:allowTaskReparenting=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:alwaysRetainTaskState=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:autoRemoveFromRecents=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:banner=&lt;span class=&quot;string&quot;&gt;&quot;drawable resource&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:clearTaskOnLaunch=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:configChanges=[&lt;span class=&quot;string&quot;&gt;&quot;mcc&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;mnc&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;locale&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 &lt;span class=&quot;string&quot;&gt;&quot;touchscreen&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;keyboard&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;keyboardHidden&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 &lt;span class=&quot;string&quot;&gt;&quot;navigation&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;screenLayout&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;fontScale&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 &lt;span class=&quot;string&quot;&gt;&quot;uiMode&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;orientation&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;screenSize&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 &lt;span class=&quot;string&quot;&gt;&quot;smallestScreenSize&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:documentLaunchMode=[&lt;span class=&quot;string&quot;&gt;&quot;intoExisting&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;always&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;never&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:enabled=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:excludeFromRecents=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:exported=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:finishOnTaskLaunch=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:hardwareAccelerated=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:icon=&lt;span class=&quot;string&quot;&gt;&quot;drawable resource&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:label=&lt;span class=&quot;string&quot;&gt;&quot;string resource&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:launchMode=[&lt;span class=&quot;string&quot;&gt;&quot;standard&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;singleTop&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              &lt;span class=&quot;string&quot;&gt;&quot;singleTask&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;singleInstance&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:maxRecents=&lt;span class=&quot;string&quot;&gt;&quot;integer&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:multiprocess=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:name=&lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:noHistory=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:parentActivityName=&lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:permission=&lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:process=&lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:relinquishTaskIdentity=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:resizeableActivity=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:screenOrientation=[&lt;span class=&quot;string&quot;&gt;&quot;unspecified&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;behind&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     &lt;span class=&quot;string&quot;&gt;&quot;landscape&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;portrait&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     &lt;span class=&quot;string&quot;&gt;&quot;reverseLandscape&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;reversePortrait&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     &lt;span class=&quot;string&quot;&gt;&quot;sensorLandscape&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;sensorPortrait&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     &lt;span class=&quot;string&quot;&gt;&quot;userLandscape&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;userPortrait&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     &lt;span class=&quot;string&quot;&gt;&quot;sensor&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;fullSensor&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;nosensor&quot;&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     &lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;fullUser&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;locked&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:stateNotNeeded=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:supportsPictureInPicture=[&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:taskAffinity=&lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:theme=&lt;span class=&quot;string&quot;&gt;&quot;resource or theme&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:uiOptions=[&lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&quot;splitActionBarWhenNarrow&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          android:windowSoftInputMode=[&lt;span class=&quot;string&quot;&gt;&quot;stateUnspecified&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       &lt;span class=&quot;string&quot;&gt;&quot;stateUnchanged&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;stateHidden&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       &lt;span class=&quot;string&quot;&gt;&quot;stateAlwaysHidden&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;stateVisible&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       &lt;span class=&quot;string&quot;&gt;&quot;stateAlwaysVisible&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;adjustUnspecified&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       &lt;span class=&quot;string&quot;&gt;&quot;adjustResize&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;adjustPan&quot;&lt;/span&gt;] &amp;gt;                        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/activity&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>关于RecyclerView的解析</title>
    <link href="https://zhangmiao.cc/posts/e545b7b2.html"/>
    <id>https://zhangmiao.cc/posts/e545b7b2.html</id>
    <published>2019-09-29T08:42:22.000Z</published>
    <updated>2019-09-29T08:52:10.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在日常开发中，大伙或多或少都会接触到 RecyclerView，但通常，也就是写写 adapter，用个系统提供的 LayoutManager，写写点击事件，处理处理复杂的 item 布局。</p><p>也就是说，大部分场景下，我们其实并不会去接触到 RecyclerView 的大部分其他功能，比如自定义 LayoutManager ，自定义 Item 动画，自定义边界样式，自定义滑动效果，自定义回收策略等等之类的功能。</p><p>那么，本篇就专门来试用下这些功能，力求将 RecyclerView 支持的所有功能都试一遍，只有清楚了这个控件都支持哪些功能效果，那么分析起它的架构、原理才会有一个比较清晰的脉络。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。</p><p>另外，由于有些平台可能不支持 `` 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。</p><blockquote><p>1.<strong>LayoutManager</strong></p><p>1.1 <strong>LinearLayoutManager</strong></p><ul><li>基本效果介绍</li><li>findFirstCompletelyVisibleItemPosition()</li><li>findFirstVisibleItemPosition()</li><li>findLastCompletelyVisibleItemPosition()</li><li>findLastVisibleItemPosition()</li><li>setRecycleChildrenOnDetach()</li></ul><p>1.2 <strong>GridLayoutManager</strong></p><ul><li>基本效果介绍</li><li>setSpanSizeLookUp()</li></ul><p>1.3 <strong>StaggeredGridLayoutManager</strong></p><ul><li>基本效果介绍</li><li>setFullSpan()</li><li>findXXX() 系列方法介绍</li></ul><p>2.<strong>ViewHolder</strong></p><ul><li>getAdapterPosition()</li><li>getLayoutPosition()</li><li>setIsRecyclable()</li></ul><p>3.<strong>LayoutParams</strong></p><p>4.<strong>Adapter</strong></p><ul><li>基本用法介绍</li><li>onViewRecycled()</li><li>onViewAttachedFromWindow()</li><li>onViewDetachedFromWindow()</li><li>onAttachedToRecyclerView()</li><li>onDetachedFromRecyclerView()</li><li>registerAdapterDataObserver()</li><li>unregisterAdapterDataObserver()</li></ul><p>5.<strong>RecyclerView</strong></p><ul><li>addOnItemTouchListener()</li><li>addOnScrollListener()</li><li>setHasFixedSize()</li><li>setLayoutFrozen()</li><li>setPreserveFocusAfterLayout()</li><li>findChildViewUnder()</li><li>findContainingItemView()</li><li>findContainingViewHolder()</li><li>findViewHolderXXX()</li></ul><p>6.<strong>Recycler</strong></p><ul><li>setItemViewCacheSize()</li><li>setViewCacheExtension()</li><li>setRecycledViewPool()</li><li>setRecyclerListener()</li></ul><p>7.<strong>ItemAnimator</strong></p><ul><li><p>SimpleItemAnimator</p></li><li><p>DefaultItemAnimator</p></li></ul><p>8.<strong>ItemDecoration</strong></p><ul><li><p>DividerItemDecoration</p></li><li><p>ItemTouchHelper</p></li><li><p>FastScroller</p></li></ul><p>9.<strong>OnFlingListener</strong></p><ul><li><p>SnapHelper</p></li><li><p>LinearSnapHelper</p></li><li><p>PagerSnapHelper</p></li></ul></blockquote><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>阅读须知：</p><ul><li>本篇力求列举 RecyclerView 所有功能的使用示例，由于篇幅原因，并不会将实现代码全部贴出，只贴出关键部分的代码。</li><li>本篇所使用的 RecyclerView 的版本是 26.0.0。</li><li>下列标题中，但凡是斜体字，表示该知识点目前暂时没理清楚，留待后续继续补充。</li></ul><h3 id="1-LayoutManager"><a href="#1-LayoutManager" class="headerlink" title="1. LayoutManager"></a>1. LayoutManager</h3><p>RecyclerView 的 support 包里默认提供了三个 LayoutManager，分别是下列三个，可用于实现大部分场景的布局需求：线性布局、网格布局、瀑布流布局等等。</p><h4 id="1-1-LinearLayoutManager"><a href="#1-1-LinearLayoutManager" class="headerlink" title="1.1 LinearLayoutManager"></a>1.1 LinearLayoutManager</h4><p>线性布局，用它可以来实现横竖自由切换的线性布局，先来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">LayoutManager</span> <span class="keyword">implements</span> <span class="title">ItemTouchHelper</span>.<span class="title">ViewDropHandler</span>, <span class="title">RecyclerView</span>.<span class="title">SmoothScroller</span>.<span class="title">ScrollVectorProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, VERTICAL, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> orientation, <span class="keyword">boolean</span> reverseLayout)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总共三个，我们分别来看看它们各自的使用场景：</p><ul><li><strong>第一个构造函数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法(在Activity里初始化控件后)：</span></span><br><span class="line">LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(layoutManager);</span><br></pre></td></tr></table></figure><p>很简单，这种时候默认就是竖直方向的线性布局，效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-8ad93d1d803f9c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="竖直LinearLayoutManager示例.png"></p><p>在 Tv 应用中，这种竖直方向的 LinearLayoutManager 使用场景大多都是用于显示菜单项，使用频率并不是特别高，但在手机应用中，这种的使用频率算是特别高的了，几乎每个 app 都会有竖直方向的滑动列表控件。</p><ul><li><strong>第二个构造函数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法(在Activity里初始化控件后)：</span></span><br><span class="line"><span class="comment">//第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式</span></span><br><span class="line">LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(layoutManager);</span><br></pre></td></tr></table></figure><p>第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式，来看看效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-3076dcee4df3758e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平LinearLayoutManager.png"></p><p>在 Tv 应用中，这种布局就比较常见了，常见的还有网格布局，多行布局等等；而在手机应用中，水平滑动的列表控件也还是有，但会比竖直的少见一些。</p><ul><li><strong>第三个构造函数</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//xml文件：</span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/recycler_main"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layoutManager</span>=<span class="string">"LinearLayoutManager"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式基本没见过吧，我也是看了 LinearLayoutManager 源码的构造函数，才发现，原来还有这种方式，可以直接在 xml 布局文件中指定 RecyclerView 的 LayoutManager，这时候，android:orientation 就是用来指定 LinearLayoutManager 的布局方向了。</p><p>那么使用这种 xml 方式时，还有哪些属性可以配置呢？直接去看对应的 LayoutManager 的源码就清楚了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor used when layout manager is set in XML by RecyclerView attribute</span></span><br><span class="line"><span class="comment"> * "layoutManager". Defaults to vertical orientation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_android_orientation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_reverseLayout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@attr</span> ref android.support.v7.recyclerview.R.styleable#RecyclerView_stackFromEnd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//上面是源码的注释，当在 xml 中通过 app:layoutManager="LinearLayoutManager" 之后，那么此时就还可以再使用三个属性来配置 LinearLayoutManager,如下：</span></span><br><span class="line"><span class="comment">//android:orientation="horizontal"</span></span><br><span class="line"><span class="comment">//app:reverseLayout="false"</span></span><br><span class="line"><span class="comment">//app:stackFromEnd="false"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    Properties properties = getProperties(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    setOrientation(properties.orientation);</span><br><span class="line">    setReverseLayout(properties.reverseLayout);</span><br><span class="line">    setStackFromEnd(properties.stackFromEnd);</span><br><span class="line">    setAutoMeasureEnabled(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外两个 LayoutManager 同理。</p><p>以上，仅仅就是 LinearLayoutManager 支持的布局样式，我们只需要设置布局方向后，其他都不用管了。那么，LinearLayoutManager 是否还有提供其他一些可选功能来让我们使用呢？接下去就一起再看看：</p><ul><li><strong>setOrientation()</strong></li></ul><p>用于设置布局方向，如果不通过构造函数来指定，也可以通过该方法指定，就两个值：<br>LinearLayoutManager.HORIZONTAL<br>LinearLayoutManager.VERTICAL</p><ul><li><strong>findFirstCompletelyVisibleItemPosition()</strong></li><li><strong>findFirstVisibleItemPosition()</strong></li><li><strong>findLastCompletelyVisibleItemPosition()</strong></li><li><strong>findLastVisibleItemPosition()</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-0d420ec9bbfc29c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="findItem示例.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-09a7678bb91a7d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="findItem日志.png"></p><p>上述四个方法作用从方法命名就可以很直观的理解了，但有些<strong>细节需要注意</strong>一下：</p><p>两个查找全部可见的 item 方法并不是我们正常意义上的全部可见，而是指在布局方向上是否已全部可见。说得白点，如果是 HORIZONTAL 水平样式，如上图，那么它只会去计算左右方向上是否全部可见来判定，比如我们特意在代码中通过 layout_marginTop=”-100dp” 来将控件移出屏幕一部分，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-7fa0f3a1efeb3c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="部分可见.png"></p><p>此时，按照我们正常意义上来理解是没有一个 item 处于全部可见的，因为每个 item 的上半部分都被移出屏幕了。但是调用那两个查找全部可见的 item 方法，仍然会返回 0 和 4，因为它只去判断水平方向是否全部可见。</p><p>findFirst 就是判断左边第一个 item 的左边界是否可见，findLast 就是判断右边最后一个 item 的右边界是否可见。如果布局方向是竖直的，那么同样的道理。这点细节需要注意一下。</p><p>还有另外两个查找第一个或最后一个可见的 item 方法也有个细节需要注意一下，如果这个 item 是有设置了 ItemDecoration，那么如果 ItemDecoration 这部分区域是可见的，也会判定该 item 是可见的。</p><ul><li><strong>setRecycleChildrenOnDetach()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set whether LayoutManager will recycle its children when it is detached from</span></span><br><span class="line"><span class="comment"> * RecyclerView.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If you are using a &#123;<span class="doctag">@link</span> RecyclerView.RecycledViewPool&#125;, it might be a good idea to set</span></span><br><span class="line"><span class="comment"> * this flag to &lt;code&gt;true&lt;/code&gt; so that views will be available to other RecyclerViews</span></span><br><span class="line"><span class="comment"> * immediately.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that, setting this flag will result in a performance drop if RecyclerView</span></span><br><span class="line"><span class="comment"> * is restored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recycleChildrenOnDetach Whether children should be recycled in detach or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRecycleChildrenOnDetach</span><span class="params">(<span class="keyword">boolean</span> recycleChildrenOnDetach)</span> </span>&#123;</span><br><span class="line">    mRecycleChildrenOnDetach = recycleChildrenOnDetach;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看源码注释，注释里说了，这个方法是用来设置，当它（LinearLayoutManager）从 RecyclerView 上面 detached 时是否要回收所有的 item。而且，它还建议我们，如果我们项目里有复用 RecyclerViewPool 的话，那么开启这个功能会是一个很好的辅助，它可以将这些 item 回收起来给其他 RecyclerView 用。最后，还指明了一点，开启这个功能的话，当 RecyclerView 恢复时，也就是从 detached 又变回 attached，那么会消耗一定的性能来绘制。</p><p>有<strong>两种场景</strong>会导致 LinearLayoutManager 从 RecyclerView 上被 detached，一种是：<code>setLayoutManager()</code>，而另外一种是：RecyclerView 从视图树上被 remove 掉。</p><p>但经过测试（你也可以去看源码），<code>setLayoutManager()</code> 时，如果之前有设置过 LayoutManger，那么内部会自动先去将之前 LayoutManager 的所有 item 回收，然后再给新的 LayoutManager 复用。此时，这个方法并没有什么卵用。</p><p>也就是说，上面说了有两种场景会触发到该方法开启的回收工作，但实际上，第一种场景内部默认的工作中就包含了回收工作，那么有没有通过这个方法来开启并没有任何影响。只有第二种场景下，要不要去处理回收工作才是由该方法来控制。</p><p>所以我怀疑是不是 Google 工程师太懒了，没有同步更新这个方法的注释。注释的第一句 when 后面应该改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set whether LayoutManager will recycle its children when RecyclerView is detached from Window.</span><br></pre></td></tr></table></figure><p>我觉得这样才比较合理一点，但纯属个人观点哈，也许是我某个地方理解错了。</p><p><strong>那么这个方法开启的回收工作到底有什么使用场景呢？</strong></p><p>这类场景还是有的，我举个例子，比如当前页面是通过 ViewPager + Fragment 来实现的，每个 Fragment 里又有 RecyclerView 控件，那么如果当页面布局信息需要更新时，有时候是直接暴力的通过 ViewPager 的 <code>setAdapter()</code> 来刷新，那么此时，旧的 fragment 其实就全被移除掉了，然后 new 了新的 fragment 绘制新的布局信息。</p><p>这样，新的 fragment 里新的 RecyclerView 的 item 就又需要全部重新创建了，如果用这个方法开启了回收工作，那么当旧的 fragment 被移除时会触发到 RecyclerView 的 detachedFromWindow 的回调，那么此时这个回收工作就会去将 item 回收到 RecyclerViewPool 中，如果新的 fragment 里的 RecyclerView 复用了这个 RecyclerViewPool，就可以省掉重新创建 item 的消耗，达到直接复用 item 的效果。</p><p>小结一下，其实也就是 RecyclerView 有更换新的实例对象时，这个方法开启的回收工作是有一定的好处的。但如果同一个 RecyclerView 实例对象存在从 attached 到 detached 又到 attached 的场景，默认没有开启回收工作时，由于 item 一直都附着在 RecyclerView 上，所以当重新 attached 时就可以直接显示出来了。但如果用该方法开启了回收工作，等于是要重新在 onBind 一次了，这点也是在注释中有提到的。</p><p>所以，这是一把双刃剑，有好有坏，有符合的场景下再去开启使用吧。</p><ul><li><strong>RecyclerView 内嵌 RecyclerView</strong></li></ul><p>另外，LayoutManager 里还有许多 public 的接口，这些方法涉及的方面是 RecyclerView 内嵌 RecyclerView 的场景，比如：<br><code>collectInitialPrefetchPositions()</code><br><code>setInitialPrefetchItemCount()</code><br>等等，但目前还没搞懂这些相关方法的用法及效果，等待后续补充。</p><h4 id="1-2-GridLayoutManager"><a href="#1-2-GridLayoutManager" class="headerlink" title="1.2 GridLayoutManager"></a>1.2 GridLayoutManager</h4><p>网格样式的布局管理器，同样，先来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意看，GridLayoutManager 是继承的 LinearLayoutManger 的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GridLayoutManager</span> <span class="keyword">extends</span> <span class="title">LinearLayoutManager</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> spanCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        setSpanCount(spanCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> spanCount, <span class="keyword">int</span> orientation, <span class="keyword">boolean</span> reverseLayout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, orientation, reverseLayout);</span><br><span class="line">        setSpanCount(spanCount);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GridLayoutManager 继承自 LinearLayoutManager， 并在它的继承上补充了 spanCount 的概念，也就是说 LinearLayoutManager 是只支持线性布局，要么一行，要么一列。而 GridLayoutManager 补充了 spanCount 概念后，支持多行或者多列，这就是网格布局了。</p><p>使用方面跟 LinearLayoutManager 基本一样，只是在构造函数内需要多传一个 spanCount 参数，来指定多少行或多少列，来看看效果图：</p><ul><li>2 行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">2</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-5df7cee852f08ce6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两行.png"></p><ul><li>4 列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">4</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-f4decf7689865af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列.png"></p><p>这种网格布局不管是 Tv 应用还是手机应用都挺常见的，Tv 上经常需要有多行或多列的形式来展示各个卡位信息，而手机上一些类似于九宫格之类的布局也可以用这个实现。</p><p>但有一些<strong>细节同样需要注意</strong>一下：</p><p>如果指定 HORIZONTAL 样式，即以多行形式进行布局，那么 item 布局的顺序则是以竖直方向来进行，如上图中标注的 item 序号，并且，此时的 RecyclerView 只支持水平方向的滑动，不支持竖直方向。如果指定 VERTICAL 样式，则相反。</p><p>其实想想也很容易理解，GridLayoutManager 是继承自 LinearLayoutManager，只是在它基础上补充了 spanCount 概念，滑动的实现还是延用 LinearLayoutManager 的逻辑，那么如果指定水平样式，自然就只有水平方向可滑动。</p><p>当设置成水平样式，水平方向可滑动的话，那么水平方向的长度自然就是可根据 item 数量动态增加的，此时自然要按照竖直方向来进行 item 布局，否则还以行为优先的话，哪里知道尽头是哪里，什么时候该换行布局了。</p><p>还有一点细节需要注意，当使用 GridLayoutManager 时，RecyclerView 的宽高在 match_parent 和 wrap_content 两种情况下的表现完全不一样，具体表现怎样，有兴趣的可以去试一下，这里就简单举个例子给大伙有个直观印象：</p><ul><li>4 列，RecycerView 宽高为 wrap_content 模式，item 设置具体宽高数值</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-f4decf7689865af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列.png"></p><ul><li>4 列，RecyclerView 宽高为 match_parent 模式，item 设置具体宽高数值</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-afe2db4b56586054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四列2.png"></p><p>简单点说，就是在 match_parent 模式下，如果指定了水平样式，那么在竖直方向上，GridLayoutManager 会保证让所有行都显示出来，如果 item 指定了具体宽高，全部显示出来还不足以铺满 RecyclerView，那么会自动将剩余空间平均分配到每个 item 之间的间隙。</p><p>如果 RecyclerView 高度不足以让所有行都显示出来，那么就会出现 item 重叠现象。这就是在 match_parent 下的表现，至于 wrap_content 则完全根据 item 设定的宽高来考虑了，不会再有自动分配剩余空间或者 Item 重叠之类的工作了。</p><p>所以，使用 GridLayoutManager 时，RecyclerView 的宽高模式需要注意一下。</p><ul><li><strong>setSpanCount()</strong></li></ul><p>通过构造函数指定了 spanCount 后也还可以继续通过该方法进行修改</p><ul><li><strong>LinearLayoutManager 的方法</strong></li></ul><p>由于是继承关系，所有 LinearLayoutManager 中的四个 <strong>findFirstCompletelyVisibleItemPosition()</strong> 方法一样可以使用，但在 LinearLayoutManager 一节中对这四个方法所讲的注意事项在这里就更加明显了，使用时需要注意一下。</p><ul><li><strong>setSpanSizeLookup()</strong></li></ul><p>通常情况下，网格布局样式下，每个小格的大小基本都是一样的，但如果我们想实现如下的效果呢：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-cbb3595bd767d01a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网格示例.png"></p><p>区别于常见的网格布局，这里有的小格就占据了多个网格，这种效果就可以通过该方法来实现了。</p><p>上述布局是设定了 HORIZONTAL 水平方向的 GridLayoutManager，并且设定为 3 行，默认情况下每个 item 占据一个小格，按照竖直方向依次布局。</p><p>通过 <code>setSpanSizeLookup()</code> 方法就可以自定义为每个 item 指定它在竖直方向要占据多少个小格，最多不超过设定的行数，上述例子中每个 item 最多就只能占据 3 行的高度。如果在该列的剩余空间不足 item 设定占据的行数，那么会将该列剩余的空间空闲出来，将该 item 移到下列进行布局。</p><p>同样的道理，当设定为 VERTICAL 竖直方向的样式时，那么可以自定义为每个 item 设定要占据的列数，最多不超过指定的列数。</p><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager gridLayoutManager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">3</span>, LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//自定义item占据的小格大小时需要重写 getSpanSize()，返回值就是占据的小格数量</span></span><br><span class="line">gridLayoutManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//以下代码仅为上图示例为写，具体场景中应该根据需求具体编写</span></span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个方法也很重要，但我还没搞清楚它的具体效果，从注释上来看，该方法是用于指定 item 在该行或该列上具体哪个位置，比如将GridLayoutManager设置为3行水平样式，那么第1个卡位就是在第一列的 0 位置，第2个卡位 1，一次类推。但该方法具体被调用的场景还没理清</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanIndex</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> spanCount)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.getSpanIndex(position, spanCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//官方建议说，如果延用默认的 getSpanIndxe() 的实现逻辑的话，那么建议调用下述方法来进行优化，否则每次布局计算时会很耗性能。 </span></span><br><span class="line">gridLayoutManager.getSpanSizeLookup().setSpanIndexCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">mRecyclerView.setLayoutManager(gridLayoutManager);</span><br></pre></td></tr></table></figure><p>虽然提供了该方法让网格布局可以更加多样化布局，但仍然<strong>无法满足一些场景</strong>，比如当设定为多行的样式时，此时就只支持自定义每个 item 占据的行数，只有行数！也就是说，所有的卡位顶多只会在高度方面不一样，同一列的卡位的宽度都是一样的。那么，如果需求是五花八门的网格布局，每个卡位都有可能占据多行的情况下又占据多列，用这个就没法实现了。</p><h4 id="1-3-StaggeredGridLayoutManager"><a href="#1-3-StaggeredGridLayoutManager" class="headerlink" title="1.3 StaggeredGridLayoutManager"></a>1.3 StaggeredGridLayoutManager</h4><p>英文直译过来是：交错式的网格布局管理者，不过我还是喜欢网上大伙的说法：瀑布流。</p><p>首先，也还是来看看它的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaggeredGridLayoutManager</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">LayoutManager</span> <span class="keyword">implements</span> <span class="title">RecyclerView</span>.<span class="title">SmoothScroller</span>.<span class="title">ScrollVectorProvider</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaggeredGridLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaggeredGridLayoutManager</span><span class="params">(<span class="keyword">int</span> spanCount, <span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有两个构造方法，第一个跟 LinearLayoutManager 一样，用于在 xml 布局文件中直接指定 LayoutManager 时用的。</p><p>第二个构造方法才是我们经常使用它的入口，两个参数，说白点就是用来设置成多行的瀑布流或者多列的瀑布流样式。</p><p>这里顺便提一点不怎么重要的，注意到没有，这里的构造方法是不需要 Context，那么为啥另外两个 LayoutManager 却需要呢？它们之间有什么不同么？</p><p>哈哈哈，答案是没啥不同，LinearLayoutManager 实际上也是不需要 Context 的，看看它的源码就会发现它根本没使用这个参数，可能是早期版本有需要用到，然后新版不需要了，为了让开发者兼容旧代码，就一直留着的吧。</p><ul><li><strong>竖直方向瀑布流</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StaggeredGridLayoutManager staggeredGridLayoutManager = <span class="keyword">new</span> StaggeredGridLayoutManager(<span class="number">3</span>, StaggeredGridLayoutManager.VERTICAL);</span><br><span class="line">mRecyclerView.setLayoutManager(staggeredGridLayoutManager);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-c73aef159fb6e264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="瀑布流.png"></p><p>瀑布流的样式在手机应用上比较常见，尤其图片查看相关的应用，在 Tv 应用上这种瀑布流布局就比较少见了。</p><p>瀑布流的方向可以选择水平或者竖直，两者只是方向上的区别而已，水平方向的效果图就不贴了。</p><p>有点<strong>细节需要注意</strong>一下，瀑布流样式在布局 item 时，并不是说一定按照某个方向某个顺序来布局。当设定为竖直方向时，以水平方向为顺序，寻找水平方向上最靠近顶端的位置来布局 item，所以并不是说一定按照第 1 列、第 2 列、第 3 列这种顺序来布局。</p><ul><li><strong>瀑布流样式和网格样式的区别</strong></li></ul><p>也许有人会疑惑，瀑布流就是设置下几行或者几列，然后设定下方向而已。网格样式时不也一样是设置下几行或几列，也一样是要再设置个方向。那么为什么瀑布流不可以直接用网格样式来实现呢？它们两者有什么区别么？</p><p>有去尝试过的就清楚了，这是两种完全不一样的布局样式。下面以两者都设置为竖直方向多列的样式来区分：</p><ol><li>网格样式每一行中的所有 item 高度是一致的，不同行可以不一样，但同行的都是一样的，因此它就实现不了瀑布流的样式了；瀑布流所有的 item 高度都允许不一样，所有能实现瀑布流样式。</li><li>网格样式支持 item 占据多列的宽度；瀑布流支持 item 占据总列数的宽度，不支持只占据其中几列。</li><li>当设置为水平方向样式时，以上结论中行列对调，宽度高度对调。</li></ol><ul><li><strong>setFullSpan()</strong></li></ul><p>该方法是 StaggeredGridLayoutManager 内部类 LayoutParams 的方法，用这个方法可以设置 item 是否要占据总宽度或总高度，当瀑布流中有某个 item 需要横穿的场景时，可以使用这个方法，效果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-453cb36deed55957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="瀑布流示例.png"></p><ul><li><strong>setOrientation()</strong></li><li><strong>setSpanCount()</strong></li></ul><p>不解释，上面两个 LayoutManager 中介绍过了。</p><ul><li><strong>findFirstCompletelyVisibleItemPositions()</strong></li><li><strong>findFirstVisibleItemPositions()</strong></li><li><strong>findLastCompletelyVisibleItemPositions()</strong></li><li><strong>findLastVisibleItemPositions()</strong></li></ul><p>作用跟 LinearLayoutManager 的一样，但有些许区别，因为这里需要传入 int[] 类型的参数，返回的结果也是 int[] 类型的。</p><p>就以上上图的布局为例，来看下打出来的日志：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-d1df0bab15cb2e0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志.png"></p><p>得到的结果是个数组，数组的大小就是构造方法中传入的 spanCount。</p><p>简单点说，上面四个方法的作用，是以每行或每列为单位来寻找相对应的首个（末个）可见或完全可见的 item。</p><p><strong>为什么要这么做呢？</strong></p><p>我想了想，还是想不出比较合理的解释，大概硬套了下，感觉也许是因为瀑布流的布局下是没办法确定 item 的大小的，如果还像 LinearLayoutManager 只寻找首个或末个完全可见的 item 时，也许它并不是处于当前屏的最顶部或最底部，就像上图日志中的 position=7 的 item，它虽然是最后完全可见的 item，但并不是位于最底部，最底部是 6 的 item。</p><p>在这种场景下，如果我们的需求是要找到处于最底部的 item 时，如果还只是像 LinearLayoutManager 只寻找最后完全可见的 item 时，就没办法做到了。那么，如果你想说，那干脆将寻找最后一个完全可见 item 改成寻找位于最底部的完全可见的 item，不就好了。那如果这时我的需求是要寻找最后一个 item 而不是最底部的呢？</p><p>所以，瀑布流它直接以每行或每列为单位，将该行/列的首（末）个可见或完全可见的 item 信息都全部给我们，我们需要哪些数据，是最后一个，还是最底部一个，就自行去处理这些信息好了。</p><p>以上，纯属个人观点。</p><ul><li><strong>setGapStrategy()</strong></li><li><strong>invalidateSpanAssignments()</strong></li></ul><p>这两个方法还没理清它们是干嘛用的，网上有资料说是用于解决滑动时 item 自动变换位置以及顶部留白问题，但我不是很清楚，后续有时间再继续查证。</p><h3 id="2-ViewHolder"><a href="#2-ViewHolder" class="headerlink" title="2. ViewHolder"></a>2. ViewHolder</h3><p>ViewHolder 大伙也不陌生了，但没想到我会单独开个小节来讲吧，也是，平时使用时顶多就是继承它，然后重写一下构造方法而已，但其实，它本身携带着很多信息，利用得当的话，可以方便我们处理很多事情。</p><ul><li><strong>getAdapterPosition()</strong></li><li><strong>getLayoutPosition()</strong></li></ul><p>将这两个放在一起讲，因为这两个很类似，不理清它们之间的区别的话，很容易搞乱，源码中的注释其实已经说得很清楚了。</p><p>在大部分场景下，这两个的值都是一样的，但在涉及到刷新时，由于 Android 是每隔 16.6 ms 刷新一次屏幕，如果在某一帧开始时，adapter 关联的数据源发生的变化，item 被移除或者新增了，我们一般都会调用 <code>notifyDataSetChanged()</code> 或者 <code>notifyItem系列()</code> 方法来刷新，但 RecyclerView 会直到下个帧来的时候才会去刷新界面。</p><p>那么，从调用了 <code>notifyDataSetChanged()</code> 到界面刷新这之间就会存在一定的时间差，在这段时间内，数据源与界面呈现的 Item 就不是一致性的了，如果这时候有需要区分实际数据源的 Item 和界面呈现 Item 的需求，那么这两个方法就派上用场了。</p><p><code>getLayoutPosition()</code>：返回的一直是界面上呈现的 Item 的位置信息，即使某个 Item 已经从数据源中被移除。</p><p><code>getAdapterPosition()</code>：当数据源发生变化，且界面已经刷新过后即 <code>onBindViewHolder()</code> 已经被调用了后，返回的值跟 <code>getLayoutPosition()</code> 一致；但当数据源发生变化，且在 <code>onBindViewHolder()</code> 被调用之前，如果调用了 <code>notifyDataSetChanged()</code>, 那么将返回无效的位置标志 -1；如果调用了 <code>notifyItem系列()</code>，那么将返回 Item 在数据源中的位置信息。</p><p><strong>示例场景：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mDataList.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//1. 场景1</span></span><br><span class="line">mAdapter.notifyDataSetChanged();</span><br><span class="line">logPosition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 场景2</span></span><br><span class="line">mAdapter.notifyItemRemove(<span class="number">0</span>);</span><br><span class="line">logPosition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 场景3</span></span><br><span class="line">mAdapter.notifyItemRemove(<span class="number">0</span>);</span><br><span class="line">mRecyclerView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mRecyclerView.getChildCount(); i++) &#123;</span><br><span class="line">        View view = mRecyclerView.getChildAt(i);</span><br><span class="line">        <span class="keyword">int</span> layPosi = mRecyclerView.findContainingViewHolder(view).getLayoutPosition();</span><br><span class="line">        <span class="keyword">int</span> adapterPosi = mRecyclerView.findContainingViewHolder(view).getAdapterPosition();</span><br><span class="line">        <span class="keyword">int</span> oldPosi = mRecyclerView.findContainingViewHolder(view).getOldPosition();</span><br><span class="line">        LogUtils.d(TAG, <span class="string">"getLayoutPosition = "</span> + layPosi);</span><br><span class="line">        LogUtils.d(TAG, <span class="string">"getAdapterPosition = "</span> + adapterPosi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景1：</strong>由于数据源发生变化后，调用了 <code>notifyDataSetChanged()</code>，在这之后马上去遍历界面上的 Item 元素，分别输出 ViewHolder 的几个方法，那么打日志的时间点肯定是在界面刷新之前，所以可以看到这些方法的区别：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-e61bb62656167372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景1日志.png"></p><p>0 position 的 Item 明明已经从数据源中被移除掉了，但由于日志打印的时机是在界面刷新之前，因此可以看到通过 <code>getLayoutPosition()</code> 获取到的是界面上还未刷新之前的 Item 的信息，而由于是调用了 <code>notifyDataSetChanged()</code> 去通知，因此 <code>getAdapterPosition()</code> 对于所有 Item 都返回无效的位置标志 -1。</p><p><strong>场景2：</strong>同理，这次也是在数据源发生变化，界面刷新之前就去打印日志了，但是是通过 <code>notifyItemRemove()</code> 通知，这个时候 <code>getAdapterPosition()</code> 方法返回的值跟上面就有所差别了：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-9ffe280f22db0d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景2日志.png"></p><p>由于这次是通过 <code>notifyItemRemove()</code> 方法来通知的，因此，此时可以通过 <code>getAdapterPositon()</code> 来获取到界面还未刷新之前的 Item 的实际在数据源中的 position 信息。position = 0 的 Item 由于已经从数据源中移除，因此返回 -1，之后的所有 Item 位置自动向前移 1 位。</p><p><strong>场景3：</strong>上面讲解时一直强调说，只有在数据源发生变化且界面刷新之前，这两个方法才会有所区别，所以场景 3 就来模拟一下，通过 <code>mRecyclerView.post()</code> 的工作由于消息队列的同步屏障机制会被延迟到下一帧的屏幕刷新之后才执行（详情翻看我的历史博客），所以可以来比较下两次日志的区别，你就清楚了：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-0733bf5c3aa038d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景3日志.png"></p><p>左边的日志是场景 2 所打的日志，右边的日志是场景 3 下的日志。由于场景 3 将日志的执行时机延迟到下一帧的界面刷新之后，所有，可以看到，界面刷新之后，原本的第一个 Item 就被移除掉了。既然界面已经刷新了，那么数据源和界面的呈现其实就是一致的了，所以 <code>getLayoutPosition()</code> 返回的值就跟 <code>getAdapterPosition()</code> 是一致的了。</p><p><strong>小结：</strong>说得白点，<code>getLayoutPosition()</code> 会返回 Item 在界面上呈现的位置信息，不管数据源有没有发生变化，界面是否已刷新，总之你在界面上看到的 Item 在哪个位置，这个方法就会返回那个位置信息，注释里也说了，我们大部分场景下，使用这个方法即可。</p><p><code>getAdapterPosition()</code> 的使用场景是，当数据源发生变化，且界面刷新之前，你又需要获取 Item 在数据源中的实际位置时才需要考虑使用该方法。另外，使用该方法时，还要注意你是用哪种 notifyXXX 来通知刷新。这个方法的实际应用场景我还没遇到过，后续有用到再继续补充。</p><ul><li><strong>getOldPosition()</strong></li></ul><p>这个看注释说是用于处理动画时用的，但还没找到相关的场景，也没理解具体有啥样，后续再继续研究。</p><ul><li><strong>getItemId()</strong></li></ul><p>返回在 adapter 中通过 <code>getItemId(int position)</code> 为该 item 生成的 id，没有在 adapter 重写那个方法的话，就返回 RecyclerView.NO_ID。</p><p>用途在 adapter 一节讲解。</p><ul><li><strong>getItemViewType()</strong></li></ul><p>返回在 adapter 中通过 <code>getItemViewType()</code> 为该 item 设定的 type，没有在 adapter 重写那个方法的话，默认就是单一类型的 item type。</p><p>item type 是用于实现不同 item 样式。</p><ul><li><strong>setIsRecyclable()</strong></li></ul><p>RecyclerView 最大的特性就是它内部实现了一套高效的回收复用机制，而回收复用是以 ViewHolder 为单位进行管理的，每个 item 都会对应一个 ViewHolder，默认都是会参与进回收复用机制中。</p><p>但可以通过该方法来标志该 ViewHolder 不会被回收</p><h3 id="3-LayoutParams"><a href="#3-LayoutParams" class="headerlink" title="3. LayoutParams"></a>3. LayoutParams</h3><p>RecyclerView 自定义了 LayoutParams 内部类，在每个 Item 的 LayoutParams 携带了一些额外的信息，需要的话，我们也可以通过这里来获取这些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">ViewGroup</span>.<span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">viewNeedsUpdate</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewInvalid</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemRemoved</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemChanged</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewLayoutPosition</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewAdapterPosition</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公开的接口有以上几个，也就是说，我们可以通过 LayoutParams 获取到 item 的 position 信息、状态信息，是否需要刷新，是否被移除等等。</p><p>更多的应用场景留待后续补充。</p><h3 id="4-Adapter"><a href="#4-Adapter" class="headerlink" title="4. Adapter"></a>4. Adapter</h3><p>adapter 大伙肯定是最熟悉的了，写 RecyclerView 打交道最多的也就是 adapter 了，所以一些基本知识我就一笔带过了，本节着重介绍各种可选功能。</p><ul><li><strong>onCreateViewHolder()</strong></li><li><strong>onBindViewHolder()</strong></li><li><strong>getItemCount()</strong></li><li><strong>RecyclerView.ViewHolder</strong></li></ul><p>以上是写一个 adapter 时必须实现的四点，它们决定了 item 长啥样，填充啥数据，以及有多少个 item，有了这些信息，一个 RecyclerView 列表也就出来了。</p><ul><li><strong>notifyDataSetChanged()</strong></li><li><strong>notifyItemChanged()</strong></li><li><strong>notifyItemXXX() 系列</strong></li></ul><p>以上是用于刷新 item，当数据源发生变化时，我们手动去刷新 item。官方说了， item 的更新分两种，一种是数据需要更新，这类刷新不涉及到 item 的位置变化；而另一种属于结构刷新，就是涉及到 item 的位置变化。</p><p>使用 <strong>notifyDataSetChanged()</strong> 时，它不管你分哪种形式的刷新，强制所有 item 重新绑定数据，重新布局操作。</p><p>以上都属于常用的基本功能，一句话带过，下面介绍一些可选功能：</p><ul><li><strong>onViewRecycled()</strong></li><li><strong>onViewAttachedFromWindow()</strong></li><li><strong>onViewDetachedFromWindow()</strong></li><li><strong>onAttachedToRecyclerView()</strong></li><li><strong>onDetachedFromRecyclerView()</strong></li></ul><p>这些方法基本都是 item 或 adapter 的一些生命周期的回调，所以分别来看看每个方法都是什么时候会被回调的，可以用来处理什么场景，做些啥工作：</p><p><strong>onViewRecycled()</strong>：当 ViewHolder 已经确认被回收，且要放进 RecyclerViewPool 中前，该方法会被回调。</p><p>首先需要明确，RecyclerView 的回收机制在工作时，会先将移出屏幕的 ViewHolder 放进一级缓存中，当一级缓存空间已满时，才会考虑将一级缓存中已有的 ViewHolder 移到 RecyclerViewPool 中去。所以，并不是所有刚被移出屏幕的 ViewHoder 都会回调该方法。</p><p>另外，注释中也说了，该方法的回调是在 ViewHolder 放进 RecyclerViewPool 中前，而 ViewHolder 在放进 Pool 中时会被 reset，因为上一节中也说过，其实 ViewHolder 本身携带着很多信息。那么，在该方法回调时，这些信息还没被重置掉，官方建议我们可以在这里释放一些耗内存资源的工作，如 bitmap 的释放。</p><p><strong>onViewAttachedFromWindow()</strong><br><strong>onViewDetachedFromWindow()</strong>：</p><p>RecyclerView 本质上也是一个 ViewGroup，那么它的 Item 要显示出来，自然要 <code>addView()</code> 进来，移出屏幕时，自然要 <code>removeView()</code> 出去，对应的就是这两个方法的回调。</p><p>所以，当 Item 移出屏幕时，<code>onViewRecycled()</code> 不一定会回调，但 <code>onViewDetachedFromWindow()</code> 肯定会回调。相反，当 Item 移进屏幕内时，另一个方法则会回调。</p><p>那么，其实，在一定场景下，可以通过这两个回调来处理一些 Item 移出屏幕，移进屏幕所需要的工作。为什么说一定场景下呢，因为如果调用了 <code>notifyDataSetChanged()</code> 的话，会触发所有 Item 的 detached 回调先触发再触发 onAttached 回调。</p><p><strong>onAttachedToRecyclerView()</strong><br><strong>onDetachedFromRecyclerView()</strong>：</p><p>这两个回调则是当 RecyclerView 调用了 <code>setAdapter()</code> 时会触发，旧的 adapter 回调 onDetached，新的 adapter 回调 onAttached。</p><p>我们同样可以在这里来做一些资源回收工作，更多其他应用场景留待后续补充。</p><ul><li><strong>registerAdapterDataObserver()</strong></li><li><strong>unregisterAdapterDataObserver()</strong></li></ul><p>用于注册监听 <code>notifyXXX()</code> 系列方法的事件，当调用了 <code>notifyXXX()</code> 系列的方法时，注册监听后就可以接收到回调。</p><ul><li><strong>setHasStableIds()</strong></li><li><strong>getItemId()</strong></li></ul><p>这两方法看注释是说用于回收复用机制中，给 ViewHoler 设置一个唯一的标识符，但具体的使用场景还不清楚，后续有用到，再补充。</p><p>另，<code>setHasStableIds()</code> 必须在 <code>setAdapter()</code> 方法之前调用，否则会抛异常。</p><h3 id="5-RecyclerView"><a href="#5-RecyclerView" class="headerlink" title="5. RecyclerView"></a>5. RecyclerView</h3><h4 id="5-1-addOnItemTouchListener"><a href="#5-1-addOnItemTouchListener" class="headerlink" title="5.1 addOnItemTouchListener()"></a>5.1 addOnItemTouchListener()</h4><p>咋一看到这个方法，我还以为 RecyclerView 也把 item 的点击事件封装好了，终于不用我们自己去写了呢。看了下源码注释才发现，这个方法的作用是用于根据情况是否拦截触屏事件的分发。先看一下它的参数类型：OnItemTouchListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemTouchListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRequestDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉接口里的方法很熟悉，没错，就是触屏事件分发流程中的拦截和处理的两个方法。</p><p>通常我们都说在自定义 View 中重写这几个方法来将触屏事件拦截，交由自己处理。RecyclerView 也是一个 View，如果你有 RecyclerView 需要拦截触屏事件自己处理的需求，那么你可以选择继承 RecyclerView，也可以选择调用这个方法。</p><h4 id="5-2-addOnScrollListener"><a href="#5-2-addOnScrollListener" class="headerlink" title="5.2 addOnScrollListener()"></a>5.2 addOnScrollListener()</h4><p>RecyclerView 是一个列表控件，自然会涉及到滑动，所以它提供了滑动状态的监听接口，当我们需要在滑动状态变化时相对应的工作时，可以调用该方法注册滑动监听。来看看它的参数：OnScrollListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnScrollListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Callback method to be invoked when RecyclerView's scroll state changes.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> recyclerView The RecyclerView whose scroll state has changed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newState     The updated scroll state. One of &#123;<span class="doctag">@link</span> #SCROLL_STATE_IDLE&#125;,</span></span><br><span class="line"><span class="comment">    *                     &#123;<span class="doctag">@link</span> #SCROLL_STATE_DRAGGING&#125; or &#123;<span class="doctag">@link</span> #SCROLL_STATE_SETTLING&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onScrolled()</code>：滑动的实现本质上就是每一帧时要么通过动画，要么通过修改属性，一帧帧内处理一小段滑动，整个过程连起来就是一个流畅的滑动效果。这个方法就是每帧内处理的滑动距离，理想状态下，每帧都会回调一次，直到滑动结束。</p><p>如果想得到滑动的距离，方向的话，可以在这个方法里做。</p><p><code>onScrollStateChanged()</code>：该方法则是滑动状态变化时的回调，一共设置了三种状态：</p><ul><li>SCROLL_STATE_IDLE：停止滑动时的状态</li><li>SCROLL_STATE_DRAGGING：手指拖动时的状态</li><li>SCROLL_STATE_SETTLING：惯性滑动时的状态（这是我的理解）</li></ul><p>在手机应用上和 Tv 应用上，这些状态的回调还是有所区别的，所以分开来说一下：</p><ul><li>手机应用：</li></ul><p>手机上的 RecyclerView 列表控件，通常都是通常手指拖动来触发滑动的，因此在手指触摸并拖动的那个时刻，这个方法会被回调，参数传入 SCROLL_STATE_DRAGGING 表示进入拖动状态。</p><p>当手指放开的时候，分两种情况，一是手指放开后 RecyclerView 又根据惯性滑动了一段距离，只要有稍微滑动就算，那么这个时候进入惯性滑动时该方法会被回调，参数传入 SCROLL_STATE_SETTLING 表示进入了惯性滑动状态。当最终停止滑动后，该方法还会被回调，参数传入 SCROLL_STATE_IDLE。</p><p>另外一种情况是，手指放开后，RecyclerView 并没有任何滑动了，通常是手指很慢的拖动情况下放开，这时候该方法就会只回调一次，参数传入 SCROLL_STATE_IDLE，因为在手指还没放开前就已经停止滑动了，放开后更不会滑动，所以直接进入停止滑动状态。</p><p>所以，在手机应用上，ReyclerView 的滑动状态变化有两种，一是从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_SETTLING 再到 SCROLL_STATE_IDLE；另外一种是直接从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_IDLE。</p><ul><li>Tv 应用：</li></ul><p>由于 Tv 应用没有触摸事件，只有遥控器事件，因此 RecyclerView 滑动的触发都是由遥控器方向键操作后由于焦点的变化来触发的，所以在 Tv 应用上不会有 SCROLL_STATE_DRAGGING 这个状态。</p><p>每次滑动都是从 SCROLL_STATE_SETTLING 到 SCROLL_STATE_IDLE。</p><p>两者有所区别，需要注意一下，如果从事 Tv 应用开发的话。</p><h4 id="5-3-setHasFixedSize"><a href="#5-3-setHasFixedSize" class="headerlink" title="5.3 setHasFixedSize()"></a>5.3 setHasFixedSize()</h4><p>看方法注释，它是说，当你能够确定后续通过 <code>notifyItemXXX()</code> 系列方法来刷新界面时，RecyclerView 控件的宽高不会因为 item 而发生变化，那么这时候可以通过该方法来让 ReyclerView 每次刷新界面时不用去重新计算它本身的宽高。</p><p>从代码层面上来看，也就是说，当调用该方法设置了后，之后通过 <code>notifyItemXXX()</code> 系列方法刷新界面时，RecyclerView 的 <code>onMeasure()</code>, <code>onLayout()</code> 就不会被调用了，而是直接调用 LayoutManager 的 <code>onMeasure()</code>。</p><p>但这样做具体有什么好处，提高性能一点，但其他的就不清楚了。想了想，当 ReyclerView 控件的宽高模式是 match_parent 时，其实这个方法可以使用，因为此时它的宽高就不会受到 item 的因素影响了。如果模式为 wrap_content，那这个方法就不要用了。</p><h4 id="5-4-setLayoutFrozen"><a href="#5-4-setLayoutFrozen" class="headerlink" title="5.4 setLayoutFrozen()"></a>5.4 setLayoutFrozen()</h4><p>这方法可以禁掉 RecyclerView 的布局请求操作，而 RecyclerView 的滑动，item 的添加或移除本质上都会触发 RecyclerView 的重新测量、布局操作。</p><p>所以，调用该方法，其实等效于关闭了 ReyclerView 的刷新，不管数据源发生了何种变化，不管用户滑动了多长距离，都不会去刷新界面，看起来就像是不响应一样，但等到再次调用该方法参数传入 false 后，就会立马去根据变化后的数据源来刷新界面了。</p><p>使用场景还是有的，假如有些场景暂时不想让 RecyclerView 去刷新，比如此时有其他动画效果正在执行中，RecyclerView 刷新多少会有些耗时，万一导致了当前动画的卡顿，那么体验就不好了。所以，这个时候可以暂时将 ReyclerView 的刷新关闭掉，但后面记得要重新开启。</p><h4 id="5-5-setPreserveFocusAfterLayout"><a href="#5-5-setPreserveFocusAfterLayout" class="headerlink" title="5.5 setPreserveFocusAfterLayout()"></a>5.5 <em>setPreserveFocusAfterLayout()</em></h4><p>这个还没搞清它的应用场景是什么，注释是说，当在进行布局工作时，有些时候，会由于 item 的状态发生改变，或者由于动画等原因，导致焦点丢失。通过该方法可以再这些工作之后，再继续保持之前 item 的焦点状态。这个方法默认就是开启的。</p><p>但我测试了下，不管有没有开启这个方法，<code>notifyDataSetChanged()</code> 时，焦点仍然会乱飘，后续再继续查证。</p><h4 id="5-6-findChildViewUnder"><a href="#5-6-findChildViewUnder" class="headerlink" title="5.6 findChildViewUnder()"></a>5.6 findChildViewUnder()</h4><p>方法参数是 (float x, float y)，作用是查找指定坐标点 (x, y) 落于 RecyclerView 的哪个子 View 上面，这里的坐标点是以 RecyclerView 控件作为坐标轴，并不是以屏幕左上角作为坐标原点。</p><p>具体应用场景，目前还没遇到过，后续补充。</p><h4 id="5-7-findContainingItemView"><a href="#5-7-findContainingItemView" class="headerlink" title="5.7 findContainingItemView()"></a>5.7 findContainingItemView()</h4><p>该方法参数是 （View view），作用正如命名上的理解，查找含有指定 View 的 ItemView，而 ItemView 是指 RecyclerView 的直接子 View。</p><p>通常，RecyclerView 的 Item 布局都不会简单到直接就是一个具体的 TextView，往往都挺复杂的，比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-45b91396cbc6db60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Item布局.png"></p><p>Item 布局的结构至少如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种 item 已经算是很简单的了，那么如果我们当前拿到的是 TextView 对象，通过该方法就可以找到这个 TextView 的根布局，即 RecyclerView 的直接子 View，这里是 RelativeLayout 对象。</p><p><strong>应用场景：</strong></p><p>我想到一种应用场景，通常我们点击事件都是作用于具体的某个 View，比如上面的 TextView，那我们在点击事件的回调中就只能拿到 TextView 对象而已。而通过这个方法，我们可以拿到这个 TextView 所属的 ItemView。拿到 ItemView 之后可以做些什么呢？</p><p>看需求场景，反正总有些场景是需要用到根布局的。还有一点就是，RecyclerView 内部其实自定义了一个 LayoutParams，作用于它的直接子 View。所以只要我们可以拿到 RecyclerView 的直接子 View，就可以拿到它对应的 LayoutParams，那么就可以通过 LayoutParams 拿到一些这个 item 的信息，比如 position 等等。</p><h4 id="5-8-findContainingViewHolder"><a href="#5-8-findContainingViewHolder" class="headerlink" title="5.8 findContainingViewHolder()"></a>5.8 findContainingViewHolder()</h4><p>该方法参数是 （View view），作用跟上述方法类似，用于查找含有指定 View 的 ItemView 所对应的 ViewHolder。</p><p>这里就不展开介绍了，该方法跟上述的方法基本一模一样，区别就仅仅是一个用于查找 ItemView，一个用于查找 ItemView 对应的 ViewHoler。</p><p>至于应用场景，拿到 ViewHolder 能做的事就更多了，而是 LayoutParams 提供的信息其实内部也是去 ViewHolder 中拿的，所以实际上 Item 携带的各种信息基本都在 ViewHolder 上面了。</p><h4 id="5-9-findViewHolderXXX"><a href="#5-9-findViewHolderXXX" class="headerlink" title="5.9 findViewHolderXXX()"></a>5.9 findViewHolderXXX()</h4><p>既然 ViewHolder 携带着大量 Item 的相关信息，RecyclerView 自然也就提供了各种方式来获取 ViewHolder，这个系列的方法如下：</p><ul><li><strong>findViewHolderForAdapterPosition()</strong></li><li><strong>findViewHolderForLayoutPosition()</strong></li><li><strong>findViewHolderForItemId()</strong></li><li><strong>findContainingViewHolder()</strong></li></ul><p>通过 position, id, view 都可以获取到对应的 ViewHolder 对象。</p><h3 id="6-Recycler"><a href="#6-Recycler" class="headerlink" title="6. Recycler"></a>6. Recycler</h3><p>Recycler 是 RecyclerView 的一个内部类，主要职责就是处理回收复用相关工作的。</p><p>回收复用的单位是 ViewHolder，至于 Item 移出屏幕是怎样回收，回收到哪里，Item 移进屏幕时是怎样复用，整个流程是先复用再回收，还是先回收再复用，还是两边同时进行等等一系列的工作都是交由 Recycler 来处理。</p><p>关于回收复用机制的部分原理，基于滑动场景解析RecyclerView的回收复用机制原理](<a href="https://www.jianshu.com/p/9306b365da57)，感兴趣的可以先去看看。" target="_blank" rel="noopener">https://www.jianshu.com/p/9306b365da57)，感兴趣的可以先去看看。</a></p><p>本篇侧重点是介绍各个接口的含义和使用场景，至于回收复用机制，后续肯定还会继续深入去分析，敬请期待。</p><h4 id="6-1-setItemViewCacheSize"><a href="#6-1-setItemViewCacheSize" class="headerlink" title="6.1 setItemViewCacheSize()"></a>6.1 setItemViewCacheSize()</h4><p>有看到上面链接那篇文章的应该就清楚，当 item 被移出屏幕外时，其实这个 item 的 ViewHolder 会被回收掉，而 Recycler 里有一种分级缓存的概念。</p><p>分级缓存，说得白点，就是不同的容器，容器之间有优先级，回收时先将 ViewHolder 缓存到高优先级的容器中，容器满了的话，那就将容器腾出个位置来，被腾出来的 ViewHolder 这时就可以放到优先级较低的容器中。分级缓存的概念就是这样。</p><p>移出屏幕的 ViewHolder 会被缓存到两个容器中，按优先级高到低分别是：<strong>mCachedViews</strong> 和 <strong>mRecyclerPool</strong></p><p>该方法就是用于设置 <strong>mCachedViews</strong> 容器的大小，默认值为 2，可通过该方法随时改变缓存容器的大小。</p><p><strong>应用场景</strong>：</p><p>要搞清楚应用场景，那得先明白 <strong>mCachedViews</strong> 这一级的缓存有什么作用，建议还是到上面给出的链接的那篇文章看一看，就明白了。</p><p>这里大概说一下，个人对于 <strong>mCachedViews</strong> 这一级缓存的理解：这一级的缓存仅仅就只是用来缓存而已，里面存储的 ViewHolder 并没有通用的能力。换句话说也就是，只有原来位置的 Item 可复用这级容器里的 ViewHolder，其他位置的 Item 没办法使用。效果就好像是 ViewPager 之类的缓存一样，所以我才说它仅仅只有缓存的功能。</p><p>这样能达到的效果就是：当某个 Item 刚被移出屏幕外，下一步又立马移进屏幕时，此时并不会去触发到 Adapter 的 onBindXXX 的调用，也就是说，这一级缓存里的 ViewHolder 可直接 addView 到 RecyclerView 上面，不需要重新去设置数据，因为它原本携带的数据都还处于正常状态，并没有被重置掉。</p><h4 id="6-2-setViewCacheExtension"><a href="#6-2-setViewCacheExtension" class="headerlink" title="6.2 setViewCacheExtension()"></a>6.2 setViewCacheExtension()</h4><p>当 Item 要被移进屏幕时，Recycler 会先去那些不需要重新调用 onBindViewHolder() 的缓存容器中寻找是否有可直接复用的 Item，如果没找到，那么会接着调用开发者自定义扩展的复用工作，如果在这里也没找到，那么才会去 RecyclerViewPool 中根据 type 来寻找可复用的，再没找到最后就直接调用 onCreateViewHolder() 新建一个来使用。</p><p>先来看看开发者要怎么自定义扩展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我删了一些注释，留下一些困惑的点</span></span><br><span class="line"><span class="comment"> * 1. Note that, Recycler never sends Views to this method to be cached. It is developers</span></span><br><span class="line"><span class="comment"> * responsibility to decide whether they want to keep their Views in this custom cache</span></span><br><span class="line"><span class="comment"> * or let the default recycling policy handle it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCacheExtension</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.This method should not create a new View. Instead, it is expected to return</span></span><br><span class="line"><span class="comment">     * an already created View that can be re-used for the given type and position.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">getViewForPositionAndType</span><span class="params">(Recycler recycler, <span class="keyword">int</span> position, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着好像很简单是吧，就只需要实现一个方法，返回指定 position 和 type 下的 Item 的 View 即可，网上所有分析到回收复用机制时也全部都是这么一笔带过。</p><p><strong>但实际上，存在很多困惑点，这个到底该怎么用？</strong></p><p>注释 1 里说了，Recycler 永远也不会将 ItemView 发送到这个类里来缓存，然后还说由开发者自行决定是要自己维护这些缓存还说交由 Recycler 来处理。</p><p><strong>困惑1：</strong>交由 Recycler 来处理我能理解，毕竟 Recycler 只在复用的过程中开了个接口给开发者扩展使用，但回收的过程并没有开任何接口给开发者扩展。也正是基于这点，我就不理解官方说的让开发者自行维护，怎么维护？</p><p>注释 2 中，官方告诉我们在这个方法中，不要去新建一个新的 ItemView，而是直接从旧的里面拿一个复用。</p><p><strong>困惑2：</strong>我又不知道怎么自己去维护 ViewHolder，那不新建一个 ItemView 又该如何使用，直接借助 Recycler？但 Recycler 不是只开放了 getViewForPosition()？本来内部在复用时就是自己调了这个方法，我们在这个方法内部走到开发者扩展自定义扩展的流程时再重新调一下？那不是就陷入嵌套循环里了？有什么意义或者应用场景么？</p><p>最最困惑的一点，国内居然找不到任何一篇讲解如何使用这个自定义缓存的相关文章！？</p><p>不清楚是由于他们文章的标题太过抽象没加入我的关键词过滤中，还是我关键词提取太烂，总之就是找不到任何一篇相关文章。所以，这小节先埋个坑，我打算后续抽时间自己来研究一下，到底应该如何使用自定义 RecyclerView 的缓存策略，到底都有哪些应用场景。</p><h4 id="6-3-setRecycledViewPool"><a href="#6-3-setRecycledViewPool" class="headerlink" title="6.3 setRecycledViewPool()"></a>6.3 setRecycledViewPool()</h4><p>最后一级缓存就是 RecyclerViewPool，这个容器有三个特性：</p><ul><li>缓存到 RecyclerViewPool 中的 ViewHolder，携带的信息都会被重置，因此从这个容器中取 ViewHolder 去复用时，都会触发 <code>onBindViewHolder()</code> 重新绑定数据。</li><li>多个 RecyclerView 可共用同一个 RecyclerViewPool 容器。</li><li>该容器以 Item 的 type 区分缓存，每种 type 的默认存储容量为 5。</li></ul><p>一般当我们需要修改这个缓存容器的大小，或者需要设置多个 RecyclerView 共用一个 RecyclerViewPool 时才需要调用到该方法。并且，官方在注释中也给出一种应用场景：使用 ViewPager 时各页面中的 RecyclerView 有相同的 Item 布局结构。</p><p><strong>应用场景：</strong></p><p>我们来举个例子，就不用官方给的例子了，我额外补充一种场景：界面上存在多行可分别左右滑动的列表控件，即每行是一个 RecyclerView，每行里的 Item 布局样式一致，这时候就可以让每一行的 RecyclerView 共用一个 RecyclerViewPool 缓存池了，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-9e528ee638e837a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多行可局部滑动.png"></p><p>以上布局的实现是外层一个竖直方向的 RecyclerView，它的每一个 Item 都是占据一行的水平方向的 RecyclerView，也就是嵌套 RecyclerView 的方式，实现可上下滑动且每一行均可左右滑动的效果。</p><p>这里的每一行的 RecyclerView 里的每个 Item 项的样式均一致，那么这种场景下，可以让每一行的 RecyclerView 都共用同一个 RecyclerViewPool 缓存池。这样的好处是，当某一行被移出屏幕时，可以将这一行的每个卡位都回收起来，供其他行使用，而不至于每一行每次都是重新创建。</p><p>但有些<strong>注意事项</strong>：</p><ul><li>外层 RecyclerView 缓存复用的应该仅仅是每一行的 RecyclerView 控件而已，不应该包括每一行 RecyclerView 内部的卡位控件，因为各行卡位的个数并不一定相同。</li><li>对于外层 RecyclerView 来说，它的 Item 是每一行的 RecyclerView 控件，所以当某一行被移出屏幕时，它仅仅是将这一行的 RecyclerView 控件从它本身 remove 掉，并回收起来。因此，此时这一行的 RecyclerView 还是携带着它的卡位子 View 的，所以需要我们手动去将这些卡位回收、并从父控件上 remove 掉。</li><li>这个操作可以在外层 RecyclerView 的 adapter 的 <code>onViewRecycled()</code> 回调中进行，也可以在内层每个 RecyclerView 的 adapter 的 <code>onViewDetachedFromWindow()</code> 回调中进行。</li><li>移除并回收卡位可通过 <code>setAdapter(null)</code> 配合 RecyclerView 本身的 <code>removeAllView()</code> 或者 LayoutManager 的 <code>removeAllView()</code> 实现 。或者直接使用 LinearLayoutManager 的 <code>setRecycleChildrenOnDetach()</code> 功能。</li></ul><h4 id="6-4-setRecyclerListener"><a href="#6-4-setRecyclerListener" class="headerlink" title="6.4 setRecyclerListener()"></a>6.4 setRecyclerListener()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RecyclerView$Recycler#</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchViewRecycled</span><span class="params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRecyclerListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRecyclerListener.onViewRecycled(holder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAdapter.onViewRecycled(holder);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这个方法设置的监听 Item 的回收，回调的时机跟 adapter 的 onViewRecycled() 一模一样，都是在 mCachedViews 容器满了之后，放入 RecyclerViewPool 之前被回调。</p><h3 id="7-ItemAnimator"><a href="#7-ItemAnimator" class="headerlink" title="7. ItemAnimator"></a>7. ItemAnimator</h3><p>RecyclerView 是支持对每个 item 做各种各样动画的，那么什么时候才该去执行这些 item 动画呢？说白了，也就是 adapter 数据源发生变化的时候，那么变化的方式无外乎就是四种：add, remove, change, move。相对应的，也就是这些状态时的 item 动画。</p><p>所以当要自定义实现 ItemAnimator 时，需要实现的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateDisappearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animatePersistence</span><span class="params">(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateChange</span><span class="params">(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">runPendingAnimations</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">(ViewHolder item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endAnimations</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>看起来，要实现一个自定义的 Item 好像很复杂，要实现这么多方法。网上这方面的文章已经非常多了，也都跟你说清了每个方法的含义是什么，在这里写些什么，甚至流程都帮你列出来了。</p><p>但大伙会不会好奇，这帮牛人是咋这么清楚的呢？</p><p>其实，Google 内部已经封装好了一个默认动画的实现，有时间大伙可以自己过一下源码，看看默认动画是怎么做的，理解清楚了后，举一反三下，其实也就懂了。</p><p>我目前也不懂，但我就是带着这么一种想法，也是打算这么去做的。虽然跟着大神的文章，最后确实能实现想要的效果，但其实掌握并不是很牢，并不大清楚为什么需要这么写，只是因为大神说这里这么写，然后就这么写了。</p><p>所以，有时间有精力，还是建议深入源码中去学习，自己梳理出来的知识终归是自己的。</p><h4 id="7-1-SimpleItemAnimator"><a href="#7-1-SimpleItemAnimator" class="headerlink" title="7.1 SimpleItemAnimator"></a>7.1 SimpleItemAnimator</h4><p>当 adapter 数据源发生变化，通知了 RecyclerView 去刷新界面时，RecyclerView 会去通知 ItemAnimaotr 此时相应的动画行为。</p><p>比如 add 了一个 Item，那么就会去触发 ItemAnimator 的 <code>animateAppearance()</code> 方法，并将这个 ItemView 在刷新前后不同的信息，如默认携带的信息是 RecyclerView 内部类 ItemHolderInfo，这个类里有关于这个 Item 的坐标信息。</p><p>那么，开发者就可以在这些回调方法里自行判断刷新前后的 Item 的不同信息来决定是否需要进行相对应的动画。</p><p><strong>而 SimpleItemAnimator 其实就是帮忙处理这件事，也就是说，它在四个回调中，如 animateAppearance() 中，根据 Item 前后的坐标信息来判断该 Item 需要进行的动画类型</strong>。</p><p>比如 <code>animateAppearance()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLayoutInfo != <span class="keyword">null</span> &amp;&amp; (preLayoutInfo.left != postLayoutInfo.left</span><br><span class="line">        || preLayoutInfo.top != postLayoutInfo.top)) &#123;</span><br><span class="line">         <span class="comment">// slide items in if before/after locations differ</span></span><br><span class="line">         <span class="keyword">return</span> animateMove(viewHolder, preLayoutInfo.left, preLayoutInfo.top,</span><br><span class="line">                postLayoutInfo.left, postLayoutInfo.top);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> animateAdd(viewHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 RecyclerView 回调了 <code>animateAppearance()</code> 方法后，SimpleItemAnimator 内部对其进行的分类，根据参数判断，最终是要执行 <code>animateMove()</code> 类型的动画，还是执行 <code>animateAdd()</code> 类型的动画。</p><p>同理，对于另外三个回调方法，SimpleItemAnimator 内部同样对其进行了封装处理，简单的通过刷新前后 Item 的坐标信息来进行动画类型的区分。</p><p>所以，这个类并没有实现任何动画的逻辑，它只是将动画的准备工作做好，简化开发者开发。所以，如果想要自定义 ItemAnimator，其实没必要从零开始继承自 ItemAnimator 自己写，是可以借助 SimpleItemAnimator 这个类的。</p><h4 id="7-2-DefaultItemAnimator"><a href="#7-2-DefaultItemAnimator" class="headerlink" title="7.2 DefaultItemAnimator"></a>7.2 DefaultItemAnimator</h4><p>RecyclerView 默认有提供 Item 的动画，而 SimpleItemAnimator 只是处理跟动画无关的准备工作，那么具体的默认动画的实现就是在 DefaultItemAnimator 这个类中实现的了。</p><p>先看一下这个类的结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-06de56724562ea79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DefaultItemAnimagtor结构.png"></p><p>它是继承自 SimpleItemAnimator 的，我们如果想要自定义实现一些 Item 动画，需要写的东西，大概就跟上图类似。</p><p>想要自定义 Item 动画，真的可以来参考、借鉴这个类的实现，能学到的东西很多。</p><p>我也还没深入去仔细学习，大概过了一眼，这里就大概说下：</p><p>这个类用了很多集合来维护各种不同类型的动画，在四个 <code>animateXXX()</code> 方法中通过集合记录相对应类型的动画和做了动画的初始化工作。</p><p>然后在 <code>runPendingAnimations()</code> 方法中，依次遍历这些集合，将记录的动画取出来执行，动画的实现方式是通过 <code>View.animate()</code> 方式实现，这种方式的动画本质上是借助了 ValueAnimator 机制，在每帧的回调过程中手动调用 <code>setXXX()</code> 来实现的动画效果。具体分析可参考一篇文章：<a href="https://www.jianshu.com/p/b43cf452afc1" target="_blank" rel="noopener">View.animate()动画ViewPropertyAnimator原理解析</a>。</p><p>大体上的流程原理就是这样，当然，这个类做的事肯定不止这些，还包括了集合的清理维护工作，动画的维护等等，所以很值得去借鉴学习一番。但这里就只给出大概的流程，本篇重点不在这里。</p><p>下面就来列举下，默认实现的各类型的动画分别是什么：</p><p><strong>animateAdd</strong> -&gt; 透明度 0 ~ 1 的动画，默认动画时长 120 ms</p><p><strong>animateChange</strong> -&gt; 涉及两个 ItemView，旧的跟新的，默认动画时长 250ms</p><p>旧 ItemView：透明度从原有值 ~ 0，位置从原坐标移动到新 ItemView 坐标的动画组合</p><p>新 ItemView：透明度从 0 ~ 1，位置从旧 ItemView 坐标移动到新坐标的动画组合</p><p><strong>animateMove</strong> -&gt; 从原坐标位置移动到新坐标位置的移动动画，默认动画时长 250 ms</p><p><strong>animateRemove</strong> -&gt; 从原有透明度 ~ 0 的动画，默认动画时长 120 ms</p><p>所以，RecyclerView 默认的 Item 动画其实也就透明度和移动动画两种，而且大多数情况下都只是单一的动画，只有 change 类型时才会是组合动画。</p><p><strong>效果展示：</strong></p><p>首先，可通过下列方式修改动画时长，这里将动画时长延长，方便查看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.getItemAnimator().setAddDuration(1000);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1924341-baf6b6217218ae9f.gif?imageMogr2/auto-orient/strip" alt="20180702_162126.gif"></p><p>可以看到，动画基本就只有透明度动画跟移动动画两种。</p><p>另外，只有通过 <code>notifyItemXXX()</code> 方式更新数据源时才会触发动画行为，如果是通过 <code>notifyDataSetChange()</code> 方式，则不会触发动画。</p><h3 id="8-ItemDecoration"><a href="#8-ItemDecoration" class="headerlink" title="8. ItemDecoration"></a>8. ItemDecoration</h3><p>RecyclerView 支持为每个 Item 之间自定义间隔样式，是要空段距离，还是要以分割线隔开，还是要唯美唯幻的边框，想长啥样都行，自己写得出来就可以了，它给我们提供了这个接口。</p><p>本节就先介绍下系统内置的几种样式，内置里一共有三个类继承该类，分别是 DividerItemDecoration，ItemTouchHelper，FastScroller。前两个都是 public 权限，最后一个包权限，下面分别看看它们都有哪些效果，最后再来看看如何自定义。</p><h4 id="8-1-DividerItemDecoration"><a href="#8-1-DividerItemDecoration" class="headerlink" title="8.1 DividerItemDecoration"></a>8.1 DividerItemDecoration</h4><p>看一下这个类的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DividerItemDecoration is a &#123;<span class="doctag">@link</span> RecyclerView.ItemDecoration&#125; that can be used as a divider</span></span><br><span class="line"><span class="comment"> * between items of a &#123;<span class="doctag">@link</span> LinearLayoutManager&#125;. It supports both &#123;<span class="doctag">@link</span> #HORIZONTAL&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #VERTICAL&#125; orientations.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     mDividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(),</span></span><br><span class="line"><span class="comment"> *             mLayoutManager.getOrientation());</span></span><br><span class="line"><span class="comment"> *     recyclerView.addItemDecoration(mDividerItemDecoration);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DividerItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the &#123;<span class="doctag">@link</span> Drawable&#125; for this divider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawable Drawable that should be used as a divider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawable</span><span class="params">(@NonNull Drawable drawable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (drawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Drawable cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mDivider = drawable;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么用，类注释也给我们示例了，有点可惜的是，它只能用于 LinearLayoutManager 这种布局，而 GridLayoutManager 继承自 LinearLayoutManager，所以它也可以用，但需要注意的是，它只有一个方向会生效。来看看如何使用和效果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DividerItemDecoration itemDecoration = <span class="keyword">new</span> DividerItemDecoration(mContext, LinearLayoutManager.HORIZONTAL);</span><br><span class="line">itemDecoration.setDrawable(getResources().getDrawable(R.drawable.divider_space));</span><br><span class="line">mRecyclerView.addItemDecoration(itemDecoration);</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.drawable.divider_space</span></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;shape xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;size android:width=<span class="string">"20dp"</span> android:height=<span class="string">"20dp"</span>/&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure><p>我们在 xml 中写宽度为 20dp 的空隙，然后调用 <code>setDrawable()</code> 应用，看看效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-02ae65a7f2cce81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="空隙示例.png"></p><p>这样就可以达到将 item 隔离开的效果了，中间这个空隙的样式你可以自己通过 xml 写，也可以直接使用图片，都可以，只要是 Drawable 类型的即可。</p><p>虽然说，RecyclerView 不像 ListView 只要设置个属性就可以达到设置 Item 之间空隙的样式，但它也内置了基本的实现，其实也已经方便了我们的使用。</p><h4 id="8-2-ItemTouchHelper"><a href="#8-2-ItemTouchHelper" class="headerlink" title="8.2 ItemTouchHelper"></a>8.2 <em>ItemTouchHelper</em></h4><p>这是一个工具类，也是 Google 为了方便开发人员实现 item 的拖拽和移动等等效果所提供的一个辅助工具类。借助这个类可以很容易实现 item 的侧滑删除、长按拖拽等功能。</p><p>由于这部分我没有研究过，日常也较少接触，所以暂时先从网上搜索一篇文章，以下的效果图来自大神的博客，会给出链接，侵权删。后续有接触相关需求时再自行来研究一番。</p><p><a href="https://blog.csdn.net/wuyuxing24/article/details/78985026" target="_blank" rel="noopener">推荐博客： ItemTouchHelper源码分析</a></p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-470540d87bab3787.gif?imageMogr2/auto-orient/strip" alt="20180105202851329.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-36ecbcb6385c86cc.gif?imageMogr2/auto-orient/strip" alt="20180105202823469.gif"></p><h4 id="8-3-FastScroller"><a href="#8-3-FastScroller" class="headerlink" title="8.3 FastScroller"></a>8.3 <em>FastScroller</em></h4><p>这个类也是继承自 ItemDecoration，但它的类权限只是包权限，不开放给外部使用，稍微看了下注释，说是用来处理动画以及快速滑动相关的支持，具体原理是什么，如何生效，留待后续深入研究时再来分析。</p><h4 id="8-4-自定义ItemDecoration"><a href="#8-4-自定义ItemDecoration" class="headerlink" title="8.4 自定义ItemDecoration"></a>8.4 自定义ItemDecoration</h4><p>上面说过系统默认提供的 DividerItemDecoration 只支持用于 LinearLayoutManager，而如果用于 GridLayoutManager 时，只有一个方向会生效，那么下面我们就以 GridLayoutManager 为例，来看看，如何自定义写 ItemDecoration。</p><p>用 GridLayoutManager 实现一个四列的布局，然后让除了四个边的 Item 外，内部的每个 Item 之间相互间隔 20 dp 的空隙。为了能更明显看出，将 20dp 的空隙用红色绘制出来。</p><p>先来看下效果：</p><ul><li>4 列布局 &amp; 2 行布局</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1924341-4c6b0f5f95f53602.gif?imageMogr2/auto-orient/strip" alt="20180619_200035.gif"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> spanCount;<span class="comment">//几行或几列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orientation;<span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> itemSpace;<span class="comment">//空隙大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Rect mBounds = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;<span class="comment">//用来将空隙绘制成红色的画笔</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyItemDecoration</span><span class="params">(GridLayoutManager gridLayoutManager)</span> </span>&#123;</span><br><span class="line">        spanCount = gridLayoutManager.getSpanCount();</span><br><span class="line">        orientation = gridLayoutManager.getOrientation();</span><br><span class="line">        initPaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">        mPaint.setColor(Color.RED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemSpace</span><span class="params">(<span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">        itemSpace = space;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        c.save();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = parent.getChildAt(i);</span><br><span class="line">            parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds);</span><br><span class="line">            c.drawRect(mBounds, mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">        c.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前view的layoutPosition</span></span><br><span class="line">        <span class="keyword">int</span> itemPosition = parent.getChildLayoutPosition(view);</span><br><span class="line">        <span class="comment">//计算该View位于哪一行哪一列</span></span><br><span class="line">        <span class="keyword">int</span> positionOfGroup = itemPosition % spanCount;</span><br><span class="line">        <span class="keyword">int</span> itemGroup = itemPosition / spanCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据不同方向进行不同处理，最终效果都要实现除四周的View 外，内部的View之间横竖都以相同空隙间隔开</span></span><br><span class="line">        <span class="comment">//实现方式，以水平方向为例：</span></span><br><span class="line">        <span class="comment">//每个view的left和bottom都设置相同间隙</span></span><br><span class="line">        <span class="comment">//去掉第1列的left，和最后一行的bottom，也就实现了除四周外内部view都以相同间隙空隔开</span></span><br><span class="line">        <span class="keyword">if</span> (orientation == LinearLayoutManager.HORIZONTAL) &#123;</span><br><span class="line">            outRect.set(itemSpace, <span class="number">0</span>, <span class="number">0</span>, itemSpace);</span><br><span class="line">            <span class="keyword">if</span> (itemGroup == <span class="number">0</span>) &#123;</span><br><span class="line">                outRect.left = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positionOfGroup == (spanCount - <span class="number">1</span>)) &#123;</span><br><span class="line">                outRect.bottom = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == LinearLayoutManager.VERTICAL) &#123;</span><br><span class="line">            outRect.set(<span class="number">0</span>, itemSpace, itemSpace, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (itemGroup == <span class="number">0</span>) &#123;</span><br><span class="line">                outRect.top = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positionOfGroup == (spanCount - <span class="number">1</span>)) &#123;</span><br><span class="line">                outRect.right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：由于 GridLayoutManager 会根据设置的 Orientation 方向，默认为 VERTICAL 数值方向，以及 RecyclerView 的宽高模式来决定是否自动将某一方向的空隙平均分配给各 Item，这点需要注意一下。</p><p>以上的例子想说明，如果要自定义写 Iiem 间的空隙，那么关键点在于重写两个方法：</p><ul><li><code>getItemOffsets()</code></li><li><code>onDraw()</code></li></ul><p>第 1 个方法会携带很多参数，最重要的是 outRect 这个参数，它是一个 Rect 类型的对象，重写这个方法并设置了这个 outRect 的 left, top, right, bottom，就相当于设置了对应这个 view 的四周分别有多大的空隙。</p><p>其他的参数是用来给我们辅助使用，如果不需要区分对待，每个 item 的四周都是同样的间隔空隙，那直接设置 outRect 即可。</p><p>如果需要像上述例子那样，要求四周的 Item 的间隙要区别于内部 item 的间隙，那么就需要判断出这个 View 的位置，因此可以通过其他参数辅助配合实现。</p><p><code>onDraw()</code> 这个方法就是用于绘制，注意这个方法参数只给了 RecyclerView，而绘制 item 的 Decoration 是针对于每个 item 而言的，所以内部需要通过遍历子 View 来对每个 item 进行绘制操作。</p><p>当然，我这里写得很粗糙，考虑到性能优化方面，绘制过度方面等等因素，通常是需要使用到 canvas.clipRect()。这部分代码建议可以参考 DividerItemDecoration 内部的实现。</p><h3 id="9-OnFlingListener"><a href="#9-OnFlingListener" class="headerlink" title="9. OnFlingListener"></a>9. <em>OnFlingListener</em></h3><p>RecyclerView 是可滑动控件，在平常使用过程中，我们可能就是上滑，下滑，左边滑滑，右边滑滑，能够刷新更多列表即可，通常都没太过去注意到滑动的细节。</p><p>但其实，滑动策略也是支持多样化的。</p><p>比如，如果想要实现不管以多大的加速度滑动，滑多长距离，最终停下来时都系统有个 ItemView 是居中显示的效果。</p><p>再比如，只希望翻页滑动，当手指滑动距离小于翻页时，自动滑回原位进行翻页等等。</p><p>这些滑动策略其实就可以直接借助内置的两个类来实现：LinearSnapHelper 和 PagerSnapHelper</p><p><strong>ps：本来以为这种滑动策略也是支持由焦点触发的滑动行为的，最后测试时才发现，原来只支持手指触摸式的滑动行为。由于我是搞 Tv 应用开发的，Tv 应用没有触摸事件，只有遥控器事件，滑动是由于焦点的变化触发的滑动行为。而在 Tv 上，Item 居中的需求也非常常见，但利用这个是无法实现的。所以，我就先不打算深入了解这块了，后续有时间再来慢慢研究。附上鸿神公众号中的一篇文章，大伙看这篇就行了。</strong></p><p><a href="https://www.jianshu.com/p/ef3a3b8d0a77" target="_blank" rel="noopener">Android中使用RecyclerView + SnapHelper实现类似ViewPager效果</a></p><p><img src="https://upload-images.jianshu.io/upload_images/3513995-aafe6c4113148c23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><h4 id="9-1-SnapHelper"><a href="#9-1-SnapHelper" class="headerlink" title="9.1 SnapHelper"></a>9.1 <em>SnapHelper</em></h4><h4 id="9-2-LinearSnapHelper"><a href="#9-2-LinearSnapHelper" class="headerlink" title="9.2 LinearSnapHelper"></a>9.2 <em>LinearSnapHelper</em></h4><h4 id="9-3-PagerSnapHelper"><a href="#9-3-PagerSnapHelper" class="headerlink" title="9.3 PagerSnapHelper"></a>9.3 <em>PagerSnapHelper</em></h4>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;虽然在日常开发中，大伙或多或少都会接触到 RecyclerView，但通常，也就是写写 adapter，用个系统提供的 LayoutManager，写写点击事件，处理处理复杂的 item 布局。&lt;/p&gt;
&lt;p&gt;也就是说，大部分场景下，我们其实并不会去接触到 RecyclerView 的大部分其他功能，比如自定义 LayoutManager ，自定义 Item 动画，自定义边界样式，自定义滑动效果，自定义回收策略等等之类的功能。&lt;/p&gt;
&lt;p&gt;那么，本篇就专门来试用下这些功能，力求将 RecyclerView 支持的所有功能都试一遍，只有清楚了这个控件都支持哪些功能效果，那么分析起它的架构、原理才会有一个比较清晰的脉络。&lt;/p&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;p&gt;由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。&lt;/p&gt;
&lt;p&gt;另外，由于有些平台可能不支持 `` 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.&lt;strong&gt;LayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.1 &lt;strong&gt;LinearLayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;findFirstCompletelyVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findFirstVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findLastCompletelyVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findLastVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;setRecycleChildrenOnDetach()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.2 &lt;strong&gt;GridLayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;setSpanSizeLookUp()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.3 &lt;strong&gt;StaggeredGridLayoutManager&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;setFullSpan()&lt;/li&gt;
&lt;li&gt;findXXX() 系列方法介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;strong&gt;ViewHolder&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getAdapterPosition()&lt;/li&gt;
&lt;li&gt;getLayoutPosition()&lt;/li&gt;
&lt;li&gt;setIsRecyclable()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;strong&gt;LayoutParams&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;Adapter&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本用法介绍&lt;/li&gt;
&lt;li&gt;onViewRecycled()&lt;/li&gt;
&lt;li&gt;onViewAttachedFromWindow()&lt;/li&gt;
&lt;li&gt;onViewDetachedFromWindow()&lt;/li&gt;
&lt;li&gt;onAttachedToRecyclerView()&lt;/li&gt;
&lt;li&gt;onDetachedFromRecyclerView()&lt;/li&gt;
&lt;li&gt;registerAdapterDataObserver()&lt;/li&gt;
&lt;li&gt;unregisterAdapterDataObserver()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.&lt;strong&gt;RecyclerView&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;addOnItemTouchListener()&lt;/li&gt;
&lt;li&gt;addOnScrollListener()&lt;/li&gt;
&lt;li&gt;setHasFixedSize()&lt;/li&gt;
&lt;li&gt;setLayoutFrozen()&lt;/li&gt;
&lt;li&gt;setPreserveFocusAfterLayout()&lt;/li&gt;
&lt;li&gt;findChildViewUnder()&lt;/li&gt;
&lt;li&gt;findContainingItemView()&lt;/li&gt;
&lt;li&gt;findContainingViewHolder()&lt;/li&gt;
&lt;li&gt;findViewHolderXXX()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6.&lt;strong&gt;Recycler&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setItemViewCacheSize()&lt;/li&gt;
&lt;li&gt;setViewCacheExtension()&lt;/li&gt;
&lt;li&gt;setRecycledViewPool()&lt;/li&gt;
&lt;li&gt;setRecyclerListener()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7.&lt;strong&gt;ItemAnimator&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SimpleItemAnimator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DefaultItemAnimator&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;8.&lt;strong&gt;ItemDecoration&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DividerItemDecoration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ItemTouchHelper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FastScroller&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9.&lt;strong&gt;OnFlingListener&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SnapHelper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LinearSnapHelper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PagerSnapHelper&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="RecyclerView" scheme="https://zhangmiao.cc/tags/RecyclerView/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android判断当前应用是否开启消息通知</title>
    <link href="https://zhangmiao.cc/posts/7299f542.html"/>
    <id>https://zhangmiao.cc/posts/7299f542.html</id>
    <published>2019-09-28T10:48:43.000Z</published>
    <updated>2019-09-28T10:51:55.192Z</updated>
    
    <content type="html"><![CDATA[<p>当APP有推送功能时，需要判断当前app在手机中是否开启了允许消息推送，否则即使添加了推送代码仍然收不到通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotificationEnabled</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> isOpened = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           isOpened = NotificationManagerCompat.from(context).areNotificationsEnabled();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           isOpened = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> isOpened;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Api24以上，NotificationManagerCompat中提供了areNotificationsEnabled()方法。该方法中已经对API19以下，API19-24，API24以上，这三种情况做了判断。直接使用其返回值即可。</p><p>该方法如果返回true表示打开了消息通知，如果返回false则没有打开。没有打开则跳转设置界面。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gotoSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">    <span class="comment">// android 8.0引导</span></span><br><span class="line">    intent.setAction(<span class="string">"android.settings.APP_NOTIFICATION_SETTINGS"</span>);</span><br><span class="line">      intent.putExtra(<span class="string">"android.provider.extra.APP_PACKAGE"</span>, getPackageName());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">    <span class="comment">// android 5.0-7.0</span></span><br><span class="line">    intent.setAction(<span class="string">"android.settings.APP_NOTIFICATION_SETTINGS"</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"app_package"</span>, getPackageName());</span><br><span class="line">    intent.putExtra(<span class="string">"app_uid"</span>, getApplicationInfo().uid);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他</span></span><br><span class="line">    intent.setAction(<span class="string">"android.settings.APPLICATION_DETAILS_SETTINGS"</span>);</span><br><span class="line">    intent.setData(Uri.fromParts(<span class="string">"package"</span>, getPackageName(), <span class="keyword">null</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">  startActivity(intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以在Activity的onCreate中进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断该app是否打开了通知，如果没有的话就打开手机设置页面</span></span><br><span class="line"><span class="keyword">if</span> (!isNotificationEnabled()) &#123;</span><br><span class="line"> gotoSet();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">//当前app允许消息通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当APP有推送功能时，需要判断当前app在手机中是否开启了允许消息推送，否则即使添加了推送代码仍然收不到通知&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isNotificationEnabled&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isOpened = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           isOpened = NotificationManagerCompat.from(context).areNotificationsEnabled();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           isOpened = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isOpened;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Api24以上，NotificationManagerCompat中提供了areNotificationsEnabled()方法。该方法中已经对API19以下，API19-24，API24以上，这三种情况做了判断。直接使用其返回值即可。&lt;/p&gt;
&lt;p&gt;该方法如果返回true表示打开了消息通知，如果返回false则没有打开。没有打开则跳转设置界面。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;gotoSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	  Intent intent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= &lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// android 8.0引导&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setAction(&lt;span class=&quot;string&quot;&gt;&quot;android.settings.APP_NOTIFICATION_SETTINGS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      intent.putExtra(&lt;span class=&quot;string&quot;&gt;&quot;android.provider.extra.APP_PACKAGE&quot;&lt;/span&gt;, getPackageName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// android 5.0-7.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setAction(&lt;span class=&quot;string&quot;&gt;&quot;android.settings.APP_NOTIFICATION_SETTINGS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.putExtra(&lt;span class=&quot;string&quot;&gt;&quot;app_package&quot;&lt;/span&gt;, getPackageName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.putExtra(&lt;span class=&quot;string&quot;&gt;&quot;app_uid&quot;&lt;/span&gt;, getApplicationInfo().uid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// 其他&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setAction(&lt;span class=&quot;string&quot;&gt;&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	intent.setData(Uri.fromParts(&lt;span class=&quot;string&quot;&gt;&quot;package&quot;&lt;/span&gt;, getPackageName(), &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	startActivity(intent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们可以在Activity的onCreate中进行判断：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//判断该app是否打开了通知，如果没有的话就打开手机设置页面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isNotificationEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	gotoSet();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;comment&quot;&gt;//当前app允许消息通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android调用系统分享</title>
    <link href="https://zhangmiao.cc/posts/c19f18fd.html"/>
    <id>https://zhangmiao.cc/posts/c19f18fd.html</id>
    <published>2019-09-27T05:54:31.000Z</published>
    <updated>2019-09-27T06:04:36.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取Android系统分享列表"><a href="#获取Android系统分享列表" class="headerlink" title="获取Android系统分享列表"></a>获取Android系统分享列表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;AppInfoVo&gt; <span class="title">getShareApps</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        PackageManager packageManager = context.getPackageManager();</span><br><span class="line">        List&lt;AppInfoVo&gt; appInfoVos = <span class="keyword">new</span> ArrayList&lt;AppInfoVo&gt;();</span><br><span class="line">        List&lt;ResolveInfo&gt; resolveInfos = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND, <span class="keyword">null</span>);</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">        intent.setType(<span class="string">"*/*"</span>);</span><br><span class="line">        PackageManager pManager = context.getPackageManager();</span><br><span class="line">        resolveInfos = pManager.queryIntentActivities(intent, PackageManager</span><br><span class="line">                .COMPONENT_ENABLED_STATE_DEFAULT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resolveInfos.size(); i++) &#123;</span><br><span class="line">            AppInfoVo appInfoVo = <span class="keyword">new</span> AppInfoVo();</span><br><span class="line">            ResolveInfo resolveInfo = resolveInfos.get(i);</span><br><span class="line">            appInfoVo.setAppName(resolveInfo.loadLabel(packageManager).toString());</span><br><span class="line">            appInfoVo.setIcon(resolveInfo.loadIcon(packageManager));</span><br><span class="line">            appInfoVo.setPackageName(resolveInfo.activityInfo.packageName);</span><br><span class="line">            appInfoVo.setLauncherName(resolveInfo.activityInfo.name);</span><br><span class="line">            appInfoVos.add(appInfoVo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appInfoVos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分享文本信息"><a href="#分享文本信息" class="headerlink" title="分享文本信息"></a>分享文本信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT,<span class="string">"This is a text"</span>);</span><br><span class="line">startActivity(Intent.createChooser(intent,<span class="string">"Share"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享单张图片"><a href="#分享单张图片" class="headerlink" title="分享单张图片"></a>分享单张图片</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".png"</span>);<span class="comment">//这里test.png是sd卡根目录下的一个图片文件</span></span><br><span class="line">Uri imageUri = Uri.fromFile(file);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, imageUri);</span><br><span class="line">startActivity(Intent.createChooser(intent, <span class="string">"Share"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享视频"><a href="#分享视频" class="headerlink" title="分享视频"></a>分享视频</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".mp4"</span>);</span><br><span class="line">Uri audioUri = Uri.fromFile(file);</span><br><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mobileqq"</span>, <span class="string">"com.tencent.mobileqq.activity.JumpActivity"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">shareIntent.putExtra(Intent.EXTRA_STREAM, audioUri);</span><br><span class="line">shareIntent.setType(<span class="string">"audio/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享视频"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享多个文件"><a href="#分享多个文件" class="headerlink" title="分享多个文件"></a>分享多个文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Uri&gt; imageUris = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".png"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path, <span class="string">"test2"</span> + <span class="string">".png"</span>);</span><br><span class="line">Uri imageUri = Uri.fromFile(file);</span><br><span class="line">Uri imageUri2 = Uri.fromFile(file2);</span><br><span class="line">imageUris.add(imageUri);</span><br><span class="line">imageUris.add(imageUri2);</span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND_MULTIPLE);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,imageUris);</span><br><span class="line">startActivity(Intent.createChooser(intent, <span class="string">"Share"</span>));</span><br></pre></td></tr></table></figure><h2 id="指定分享到微信朋友"><a href="#指定分享到微信朋友" class="headerlink" title="指定分享到微信朋友"></a>指定分享到微信朋友</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mm"</span>, <span class="string">"com.tencent.mm.ui.tools.ShareImgUI"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);            </span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);</span><br><span class="line">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class="line">shareIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享多张图片"</span>));</span><br></pre></td></tr></table></figure><h2 id="指定分享到微信朋友圈"><a href="#指定分享到微信朋友圈" class="headerlink" title="指定分享到微信朋友圈"></a>指定分享到微信朋友圈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mm"</span>, <span class="string">"com.tencent.mm.ui.tools.ShareToTimeLineUI"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);   </span><br><span class="line">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class="line">shareIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享多张图片"</span>));</span><br></pre></td></tr></table></figure><h2 id="指定分享到QQ好友"><a href="#指定分享到QQ好友" class="headerlink" title="指定分享到QQ好友"></a>指定分享到QQ好友</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.tencent.mobileqq"</span>, <span class="string">"com.tencent.mobileqq.activity.JumpActivity"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);  </span><br><span class="line">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class="line">shareIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享多张图片"</span>));</span><br></pre></td></tr></table></figure><h2 id="视频指定分享到QQ空间"><a href="#视频指定分享到QQ空间" class="headerlink" title="视频指定分享到QQ空间"></a>视频指定分享到QQ空间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String path = Environment.getExternalStorageDirectory() + File.separator;<span class="comment">//sd根目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(path, <span class="string">"test"</span> + <span class="string">".mp4"</span>);</span><br><span class="line">Uri audioUri = Uri.fromFile(file);</span><br><span class="line">ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.qzone"</span>, <span class="string">"com.qzonex.module.maxvideo.activity.QzonePublishVideoActivity"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">shareIntent.setComponent(comp);</span><br><span class="line">shareIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">shareIntent.putExtra(Intent.EXTRA_STREAM, audioUri);</span><br><span class="line">shareIntent.setType(<span class="string">"video/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(shareIntent, <span class="string">"分享视频"</span>));</span><br></pre></td></tr></table></figure><h2 id="分享到指定程序"><a href="#分享到指定程序" class="headerlink" title="分享到指定程序"></a>分享到指定程序</h2><p>只要获得包名和相应Activity即可</p><h3 id="微信朋友圈"><a href="#微信朋友圈" class="headerlink" title="微信朋友圈"></a>微信朋友圈</h3><p>“com.tencent.mm”<br>“com.tencent.mm.ui.tools.ShareToTimeLineUI”</p><h3 id="微信朋友"><a href="#微信朋友" class="headerlink" title="微信朋友"></a>微信朋友</h3><p>“com.tencent.mm”<br>“com.tencent.mm.ui.tools.ShareImgUI”</p><h3 id="QQ好友"><a href="#QQ好友" class="headerlink" title="QQ好友"></a>QQ好友</h3><p>“com.tencent.mobileqq”<br>“com.tencent.mobileqq.activity.JumpActivity”</p><h3 id="QQ空间分享视频"><a href="#QQ空间分享视频" class="headerlink" title="QQ空间分享视频"></a>QQ空间分享视频</h3><p>“com.qzone”<br>“com.qzonex.module.maxvideo.activity.QzonePublishVideoActivity”</p><h3 id="QQ空间分享图片、文字"><a href="#QQ空间分享图片、文字" class="headerlink" title="QQ空间分享图片、文字"></a>QQ空间分享图片、文字</h3><p>“com.qzone”<br>“com.qzonex.module.operation.ui.QZonePublishMoodActivity”</p><h3 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h3><p>“com.sina.weibo”<br>“com.sina.weibo.composerinde.ComposerDispatchActivity”</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;获取Android系统分享列表&quot;&gt;&lt;a href=&quot;#获取Android系统分享列表&quot; class=&quot;headerlink&quot; title=&quot;获取Android系统分享列表&quot;&gt;&lt;/a&gt;获取Android系统分享列表&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;AppInfoVo&amp;gt; &lt;span class=&quot;title&quot;&gt;getShareApps&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PackageManager packageManager = context.getPackageManager();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;AppInfoVo&amp;gt; appInfoVos = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;AppInfoVo&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;ResolveInfo&amp;gt; resolveInfos = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;ResolveInfo&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Intent intent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_SEND, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        intent.addCategory(Intent.CATEGORY_DEFAULT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        intent.setType(&lt;span class=&quot;string&quot;&gt;&quot;*/*&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PackageManager pManager = context.getPackageManager();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resolveInfos = pManager.queryIntentActivities(intent, PackageManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .COMPONENT_ENABLED_STATE_DEFAULT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; resolveInfos.size(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AppInfoVo appInfoVo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AppInfoVo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ResolveInfo resolveInfo = resolveInfos.get(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setAppName(resolveInfo.loadLabel(packageManager).toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setIcon(resolveInfo.loadIcon(packageManager));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setPackageName(resolveInfo.activityInfo.packageName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVo.setLauncherName(resolveInfo.activityInfo.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            appInfoVos.add(appInfoVo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; appInfoVos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="代码片段" scheme="https://zhangmiao.cc/categories/Android/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="分享" scheme="https://zhangmiao.cc/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
