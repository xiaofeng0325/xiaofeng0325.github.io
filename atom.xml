<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2019-09-11T08:48:22.852Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android_build.gradle配置详解</title>
    <link href="https://zhangmiao.cc/posts/aaeab884.html"/>
    <id>https://zhangmiao.cc/posts/aaeab884.html</id>
    <published>2019-09-11T08:42:16.000Z</published>
    <updated>2019-09-11T08:48:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>Android Studio是采用gradle来构建项目的，gradle是基于groovy语言的，如果只是用它构建普通Android项目的话，是可以不去学groovy的。当我们创建一个Android项目时会包含两个Android build.gradle配置详解文件，如下图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164601.png" alt></p><a id="more"></a><h2 id="一、Project的build-gradle文件："><a href="#一、Project的build-gradle文件：" class="headerlink" title="一、Project的build.gradle文件："></a>一、Project的build.gradle文件：</h2><p>对应的build.gradle代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;<span class="comment">//这里是gradle脚本执行所需依赖，分别是对应的maven库和插件</span></span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()<span class="comment">//从Android Studio3.0后新增了google()配置，可以引用google上的开源项目</span></span><br><span class="line">        jcenter()<span class="comment">//是一个类似于github的代码托管仓库，声明了jcenter()配置，可以轻松引用 jcenter上的开源项目</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.0.0'</span><span class="comment">////此处是android的插件gradle，gradle是一个强大的项目构建工具</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;<span class="comment">//这里是项目本身需要的依赖，比如项目所需的maven库</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行gradle clean时，执行此处定义的task任务。</span></span><br><span class="line"><span class="comment">// 该任务继承自Delete，删除根目录中的build目录。</span></span><br><span class="line"><span class="comment">// 相当于执行Delete.delete(rootProject.buildDir)。</span></span><br><span class="line"><span class="comment">// gradle使用groovy语言，调用method时可以不用加（）。</span></span><br><span class="line">task clean(<span class="keyword">type</span>: Delete) &#123;</span><br><span class="line">    <span class="built_in">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>buildscript{}闭包里是gradle脚本执行所需依赖，分别是对应的maven库和插件。</li><li>allprojects{}闭包里是项目本身需要的依赖，比如项目所需的maven库。</li><li>task clean(type: Delete){}是运行gradle clean时，执行此处定义的task任务，该任务继承自Delete，删除根目录中的build目录。其中buildscript包含repositories闭包和dependencies闭包。</li></ul><h4 id="repositories-闭包：配置远程仓库"><a href="#repositories-闭包：配置远程仓库" class="headerlink" title="repositories{}闭包：配置远程仓库"></a>repositories{}闭包：配置远程仓库</h4><p>该闭包中声明了jcenter()和google()的配置，其中jcenter是一个代码托管仓库，上面托管了很多Android开源项目，在这里配置了jcenter后我们可以在项目中方便引用jcenter上的开源项目，从Android Studio3.0后新增了google()配置，可以引用google上的开源项目。</p><h4 id="dependencies-闭包：配置构建工具"><a href="#dependencies-闭包：配置构建工具" class="headerlink" title="dependencies{}闭包：配置构建工具"></a>dependencies{}闭包：配置构建工具</h4><p>该闭包使用classpath声明了一个Gradle插件，由于Gradle并不只是用来构建Android项目，因此此处引入相关插件来构建Android项目，其中’3.0.0’为该插件的版本号，可以根据最新的版本号来调整。</p><h2 id="二、Module的build-gradle文件："><a href="#二、Module的build-gradle文件：" class="headerlink" title="二、Module的build.gradle文件："></a>二、Module的build.gradle文件：</h2><p>从文件内容可以看出，主要分为三大部分，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164623.png" alt></p><h4 id="1、apply-plugin："><a href="#1、apply-plugin：" class="headerlink" title="1、apply plugin："></a>1、apply plugin：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明是Android程序，</span></span><br><span class="line"><span class="comment">//com.android.application 表示这是一个应用程序模块</span></span><br><span class="line"><span class="comment">//com.android.library 标识这是一个库模块</span></span><br><span class="line"><span class="comment">//而这区别：前者可以直接运行，后着是依附别的应用程序运行</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br></pre></td></tr></table></figure><p>文件中第一行使用apply plugin表示应用了一个插件，该插件一般有两种值可选：</p><ul><li>‘com.android.application’，表示该模块为应用程序模块，可以直接运行，打包得到的是.apk文件</li><li>‘com.android.library’，表示该模块为库模块，只能作为代码库依附于别的应用程序模块来运行，打包得到的是.aar文件</li></ul><h4 id="2、android-闭包："><a href="#2、android-闭包：" class="headerlink" title="2、android{}闭包："></a>2、android{}闭包：</h4><p>这个闭包主要为了配置项目构建的各种属性：</p><h5 id="2-1、添加signingConfigs-闭包："><a href="#2-1、添加signingConfigs-闭包：" class="headerlink" title="2.1、添加signingConfigs{}闭包："></a>2.1、添加signingConfigs{}闭包：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;<span class="comment">// 自动化打包配置</span></span><br><span class="line">    release &#123;<span class="comment">// 线上环境</span></span><br><span class="line">        keyAlias <span class="string">'test'</span></span><br><span class="line">        keyPassword <span class="string">'123456'</span></span><br><span class="line">        storeFile file(<span class="string">'test.keystore'</span>)</span><br><span class="line">        storePassword <span class="string">'123456'</span></span><br><span class="line">    &#125;</span><br><span class="line">    debug &#123;<span class="comment">// 开发环境</span></span><br><span class="line">        keyAlias <span class="string">'test'</span></span><br><span class="line">        keyPassword <span class="string">'123456'</span></span><br><span class="line">        storeFile file(<span class="string">'test.keystore'</span>)</span><br><span class="line">        storePassword <span class="string">'123456'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以手动添加签名配置，也可以通过Project Structure 选中app，点击Singing添加，具体步骤如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164646.png" alt></p><p>签名配置完成后可以方便带签名打包，在module的Build Variants中有两个Type，分别是debug和release，可以选择任意一个类型进行打包，并且他们会利用各自配置的Key进行打包，执行 Run app或者Build-&gt;Build apk就会自动在module name/app/build/outputs/apk路径下生成Apk文件。另一种打包方式是Build-&gt;Generate Signed APK填写签名信息生成Apk。</p><h5 id="2-2、compileSdkVersion：设置编译时用的Android版本"><a href="#2-2、compileSdkVersion：设置编译时用的Android版本" class="headerlink" title="2.2、compileSdkVersion：设置编译时用的Android版本"></a>2.2、compileSdkVersion：设置编译时用的Android版本</h5><p>2.3、buildToolsVersion：设置编译时使用的构建工具的版本，Android Studio3.0后去除此项配置</p><h5 id="2-4、defaultConfig-闭包："><a href="#2-4、defaultConfig-闭包：" class="headerlink" title="2.4、defaultConfig{}闭包："></a>2.4、defaultConfig{}闭包：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compileSdkVersion <span class="number">27</span><span class="comment">//设置编译时用的Android版本</span></span><br><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId <span class="string">"com.billy.myapplication"</span><span class="comment">//项目的包名</span></span><br><span class="line">    minSdkVersion <span class="number">16</span><span class="comment">//项目最低兼容的版本</span></span><br><span class="line">    targetSdkVersion <span class="number">27</span><span class="comment">//项目的目标版本</span></span><br><span class="line">    versionCode <span class="number">1</span><span class="comment">//版本号</span></span><br><span class="line">    versionName <span class="string">"1.0"</span><span class="comment">//版本名称</span></span><br><span class="line">    testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span><span class="comment">//表明要使用AndroidJUnitRunner进行单元测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>applicationId</strong>：指定了项目的包名。</li><li><strong>minSdkVersion</strong>：指定项目最低兼容的版本，如果设备小于这个版本或者大于maxSdkVersion(一般不用)将无法安装这个应用，这里指定为16，表示最低兼容到Android 4.1系统。</li><li><strong>targetSdkVersion</strong>：指定项目的目标版本，表示在该目标版本上已经做过充分测试，系统会为该应用启动一些对应该目标系统的最新功能特性，Android系统平台的行为变更，只有targetSdkVersion的属性值被设置为大于或等于该系统平台的API版本时，才会生效。例如，若指定targetSdkVersion值为22，则表示该程序最高只在Android5.1版本上做过充分测试，在Android6.0系统上（对应targetSdkVersion为23）拥有的新特性如系统运行时权限等功能就不会被启用。</li><li><strong>versionCode</strong>：表示版本号，一般每次打包上线时该值只能增加，打包后看不见。</li><li><strong>versionName</strong>：表示版本名称，展示在应用市场上。</li><li><strong>testInstrumentationRunner</strong> “android.support.test.runner.AndroidJUnitRunner”表明要使用AndroidJUnitRunner进行单元测试。</li></ul><h5 id="2-5、-buildTypes-闭包："><a href="#2-5、-buildTypes-闭包：" class="headerlink" title="2.5、 buildTypes{}闭包："></a>2.5、 buildTypes{}闭包：</h5><p>这个闭包主要指定生成安装文件的主要配置，一般包含两个子闭包，一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写；另一个是release闭包，用于指定生成正式版安装文件的配置。两者能配置的参数相同，最大的区别默认属性配置不一样，两种模式支持的属性配置如下图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164659.png" alt></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;<span class="comment">// 生产/测试环境配置</span></span><br><span class="line">    release &#123;<span class="comment">// 生产环境</span></span><br><span class="line">        buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">        buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://release.cn/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">        minifyEnabled <span class="literal">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">        signingConfig signingConfigs.release<span class="comment">//设置签名信息</span></span><br><span class="line">        pseudoLocalesEnabled <span class="literal">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">        zipAlignEnabled <span class="literal">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">        applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">    &#125;</span><br><span class="line">    debug &#123;<span class="comment">// 测试环境</span></span><br><span class="line">        buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">        buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://test.com/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">        minifyEnabled <span class="literal">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">        signingConfig signingConfigs.debug<span class="comment">//设置签名信息</span></span><br><span class="line">        debuggable <span class="literal">false</span><span class="comment">//是否支持断点调试</span></span><br><span class="line">        jniDebuggable <span class="literal">false</span><span class="comment">//是否可以调试NDK代码</span></span><br><span class="line">        renderscriptDebuggable <span class="literal">false</span><span class="comment">//是否开启渲染脚本就是一些c写的渲染方法</span></span><br><span class="line">        zipAlignEnabled <span class="literal">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">        pseudoLocalesEnabled <span class="literal">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">        applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="release-闭包和debug-闭包两者能配置的参数相同，最大的区别默认属性配置不一样："><a href="#release-闭包和debug-闭包两者能配置的参数相同，最大的区别默认属性配置不一样：" class="headerlink" title="release{}闭包和debug{}闭包两者能配置的参数相同，最大的区别默认属性配置不一样："></a>release{}闭包和debug{}闭包两者能配置的参数相同，最大的区别默认属性配置不一样：</h5><ul><li><strong>minifyEnabled</strong>：表明是否对代码进行混淆，true表示对代码进行混淆，false表示对代码不进行混淆，默认的是false。</li><li><strong>proguardFiles</strong>：指定混淆的规则文件，这里指定了proguard-android.txt文件和proguard-rules.pro文件两个文件，proguard-android.txt文件为默认的混淆文件，里面定义了一些通用的混淆规则。proguard-rules.pro文件位于当前项目的根目录下，可以在该文件中定义一些项目特有的混淆规则。</li><li><strong>buildConfigField</strong>：用于解决Beta版本服务和Release版本服务地址不同或者一些Log打印需求控制的。例如：配置buildConfigField(“boolean”, “LOG_DEBUG”, “true”)，这个方法接收三个非空的参数，第一个：确定值的类型，第二个：指定key的名字，第三个：传值，调用的时候BuildConfig.LOG_DEBUG即可调用。</li><li><strong>debuggable</strong>：表示是否支持断点调试，release默认为false，debug默认为true。</li><li><strong>jniDebuggable</strong>：表示是否可以调试NDK代码，使用lldb进行c和c++代码调试，release默认为false</li><li><strong>signingConfig</strong>：设置签名信息，通过signingConfigs.release或者signingConfigs.debug，配置相应的签名，但是添加此配置前必须先添加signingConfigs闭包，添加相应的签名信息。</li><li><strong>renderscriptDebuggable</strong>：表示是否开启渲染脚本就是一些c写的渲染方法，默认为false。</li><li><strong>renderscriptOptimLevel</strong>：表示渲染等级，默认是3。</li><li><strong>pseudoLocalesEnabled</strong>：是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多。</li><li><strong>applicationIdSuffix</strong>：和defaultConfig中配置是一的，这里是在applicationId 中添加了一个后缀，一般使用的不多。</li><li><strong>versionNameSuffix</strong>：表示添加版本名称的后缀，一般使用的不多。</li><li><strong>zipAlignEnabled</strong>：表示是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率，release和debug默认都为true。</li></ul><h5 id="2-6、sourceSets-闭包：配置目录指向"><a href="#2-6、sourceSets-闭包：配置目录指向" class="headerlink" title="2.6、sourceSets{}闭包：配置目录指向"></a>2.6、sourceSets{}闭包：配置目录指向</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;<span class="comment">//目录指向配置</span></span><br><span class="line">    main &#123;</span><br><span class="line">        jniLibs.srcDirs = [<span class="string">'libs'</span>]<span class="comment">//指定lib库目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 jniLibs.srcDirs = [‘libs’]，可以在Android studio的Android视图下生成jniLibs文件夹，可以方便我们存放jar包和库文件，其中Android视图下的jniLibs和project视图下的libs指向同一文件夹（app→libs），如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164716.png" alt></p><h5 id="2-7、packagingOptions-闭包：打包时的相关配置"><a href="#2-7、packagingOptions-闭包：打包时的相关配置" class="headerlink" title="2.7、packagingOptions{}闭包：打包时的相关配置"></a>2.7、packagingOptions{}闭包：打包时的相关配置</h5><p>当项目中依赖的第三方库越来越多时，有可能会出现两个依赖库中存在同一个（名称）文件。如果这样，Gradle在打包时就会提示错误（警告）。那么就可以根据提示，然后使用以下方法将重复的文件剔除，比较常用的是通过exclude去除重复的文件，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">packagingOptions&#123;</span><br><span class="line">    <span class="comment">//pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk</span></span><br><span class="line">    <span class="comment">// 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时  只用第一个 这样打包就不会报错</span></span><br><span class="line">    pickFirsts = [<span class="string">'META-INF/LICENSE'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//merges何必 当出现重复文件时 合并重复的文件 然后打包入apk</span></span><br><span class="line">    <span class="comment">//这个是有默认值得 merges = [] 这样会把默默认值去掉  所以我们用下面这种方式 在默认值后添加</span></span><br><span class="line">    merge <span class="string">'META-INF/LICENSE'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。</span></span><br><span class="line">    exclude <span class="string">'META-INF/services/javax.annotation.processing.Processor'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-8、productFlavors-闭包：多个渠道配置"><a href="#2-8、productFlavors-闭包：多个渠道配置" class="headerlink" title="2.8、productFlavors{}闭包：多个渠道配置"></a>2.8、productFlavors{}闭包：多个渠道配置</h5><p>这个配置是经常会使用到的，通常在适配多个渠道的时候，需要为特定的渠道做部分特殊的处理，比如设置不同的包名、应用名等。场景：当我们使用友盟统计时，通常需要设置一个渠道ID，那么我们就可以利用productFlavors来生成对应渠道信息的包，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        wandoujia &#123;</span><br><span class="line">            <span class="comment">//豌豆荚渠道包配置</span></span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"wandoujia"</span>]</span><br><span class="line">            <span class="comment">//manifestPlaceholders的使用在后续章节（AndroidManifest里的占位符）中介绍</span></span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"xiaomi"</span>]</span><br><span class="line">            applicationId <span class="string">"com.wiky.gradle.xiaomi"</span> <span class="comment">//配置包名</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        _360 &#123;</span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"_360"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也有更简洁的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        _360 &#123;&#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123; </span><br><span class="line">        <span class="comment">//批量修改，类似一个循序遍历</span></span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完之后，在命令行窗口中（Terminal）中输入gradlew assembleRelease（windows）即可开始打包，在Mac系统中对应指令应该是./gradlew assembleRelease。当然，如果想要debug版本的包，将指令中assembleRelease改为assembleDebug即可。最后生成的包还是在app/build/outputs/apk中，默认命名格式如app-wandoujia-release-unsigned.apk，在module的Build Variants中可以选择相应的渠道。<br><strong>注：</strong>Android Studio3.0需在主app的build.gradle里面的<br>defaultConfig {<br>targetSdkVersion：*<br>minSdkVersion ：*<br>versionCode：*<br>versionName ：*<br>//版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了<br>flavorDimensions “versionCode”<br>}</p><h5 id="2-9、lintOptions-闭包：代码扫描分析"><a href="#2-9、lintOptions-闭包：代码扫描分析" class="headerlink" title="2.9、lintOptions{}闭包：代码扫描分析"></a>2.9、lintOptions{}闭包：代码扫描分析</h5><p>Lint 是Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构/质量问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。</p><p>Lint 发现的每个问题都有描述信息和等级（和测试发现 bug 很相似），我们可以很方便地定位问题，同时按照严重程度进行解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关</span></span><br><span class="line">lintOptions &#123;</span><br><span class="line">    abortOnError <span class="literal">false</span> <span class="comment">//即使报错也不会停止打包</span></span><br><span class="line">    checkReleaseBuilds <span class="literal">false</span>  <span class="comment">//打包release版本的时候进行检测</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、dependencies-闭包："><a href="#3、dependencies-闭包：" class="headerlink" title="3、dependencies{}闭包："></a>3、dependencies{}闭包：</h4><p>该闭包定义了项目的依赖关系，一般项目都有三种依赖方式：本地依赖、库依赖和远程依赖。本地依赖可以对本地的jar包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖可以对jcener库上的开源项目添加依赖关系。<code>从Android Studio3.0后compile引入库不在使用，而是通过api和implementation，api完全等同于以前的compile，用api引入的库整个项目都可以使用，用implementation引入的库只有对应的Module能使用，其他Module不能使用，由于之前的项目统一用compile依赖，导致的情况就是模块耦合性太高，不利于项目拆解，使用implementation之后虽然使用起来复杂了但是做到降低偶合兴提高安全性。</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;<span class="comment">//项目的依赖关系</span></span><br><span class="line">    implementation fileTree(<span class="keyword">include</span>: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)<span class="comment">//本地jar包依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:27.1.1'</span><span class="comment">//远程依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span><span class="comment">//声明测试用例库</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>implementation</strong> fileTree(include: [‘*.jar’], dir: ‘libs’)：implementation fileTree是一个本地依赖声明，表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。</li><li><strong>implementation ‘com.android.support:appcompat-v7:27.1.1’</strong>：implementation语句为 远程依赖声明，’com.android.support:appcompat-v7:27.1.1’为一个标准的远程依赖库格式，其中com.android.support为域名部分，用于区分不同公司的库；appcompat-v7为组件名称，用于区分同一个公司的不同库；27.1.1为版本号，用于区分同一个库的不同版本。加上这句声明后，Gradle在构建项目时会先检查一下本地是否已经缓存过该库，若没有缓存则自动联网下载，下载后自动添加到项目的构建路径中去。</li><li><strong>testImplementation和androidTestImplementation</strong>：表示声明测试用例库。</li></ul><h2 id="Module完整的build-gradle配置如下："><a href="#Module完整的build-gradle配置如下：" class="headerlink" title="Module完整的build.gradle配置如下："></a>Module完整的build.gradle配置如下：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明是Android程序，</span></span><br><span class="line"><span class="comment">//com.android.application 表示这是一个应用程序模块</span></span><br><span class="line"><span class="comment">//com.android.library 标识这是一个库模块</span></span><br><span class="line"><span class="comment">//而这区别：前者可以直接运行，后着是依附别的应用程序运行</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;<span class="comment">// 自动化打包配置</span></span><br><span class="line">        release &#123;<span class="comment">// 线上环境</span></span><br><span class="line">            keyAlias <span class="string">'test'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            storeFile file(<span class="string">'test.jks'</span>)</span><br><span class="line">            storePassword <span class="string">'123456'</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;<span class="comment">// 开发环境</span></span><br><span class="line">            keyAlias <span class="string">'test'</span></span><br><span class="line">            keyPassword <span class="string">'123456'</span></span><br><span class="line">            storeFile file(<span class="string">'test.jks'</span>)</span><br><span class="line">            storePassword <span class="string">'123456'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileSdkVersion <span class="number">27</span><span class="comment">//设置编译时用的Android版本</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.billy.myapplication"</span><span class="comment">//项目的包名</span></span><br><span class="line">        minSdkVersion <span class="number">16</span><span class="comment">//项目最低兼容的版本</span></span><br><span class="line">        targetSdkVersion <span class="number">27</span><span class="comment">//项目的目标版本</span></span><br><span class="line">        versionCode <span class="number">1</span><span class="comment">//版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span><span class="comment">//版本名称</span></span><br><span class="line">        flavorDimensions <span class="string">"versionCode"</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span><span class="comment">//表明要使用AndroidJUnitRunner进行单元测试</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;<span class="comment">// 生产/测试环境配置</span></span><br><span class="line">        release &#123;<span class="comment">// 生产环境</span></span><br><span class="line">            buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://release.cn/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">            signingConfig signingConfigs.release<span class="comment">//设置签名信息</span></span><br><span class="line">            pseudoLocalesEnabled <span class="keyword">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">            applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">            versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;<span class="comment">// 测试环境</span></span><br><span class="line">            buildConfigField(<span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span>)<span class="comment">//配置Log日志</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"URL_PERFIX"</span>, <span class="string">"\"https://test.com/\""</span>)<span class="comment">// 配置URL前缀</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span><span class="comment">//是否对代码进行混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//指定混淆的规则文件</span></span><br><span class="line">            signingConfig signingConfigs.debug<span class="comment">//设置签名信息</span></span><br><span class="line">            debuggable <span class="keyword">false</span><span class="comment">//是否支持断点调试</span></span><br><span class="line">            jniDebuggable <span class="keyword">false</span><span class="comment">//是否可以调试NDK代码</span></span><br><span class="line">            renderscriptDebuggable <span class="keyword">false</span><span class="comment">//是否开启渲染脚本就是一些c写的渲染方法</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span><span class="comment">//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率</span></span><br><span class="line">            pseudoLocalesEnabled <span class="keyword">false</span><span class="comment">//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多</span></span><br><span class="line">            applicationIdSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">            versionNameSuffix <span class="string">'test'</span><span class="comment">//在applicationId 中添加了一个后缀，一般使用的不多</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;<span class="comment">//目录指向配置</span></span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]<span class="comment">//指定lib库目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packagingOptions&#123;<span class="comment">//打包时的相关配置</span></span><br><span class="line">        <span class="comment">//pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk</span></span><br><span class="line">        <span class="comment">// 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时  只用第一个 这样打包就不会报错</span></span><br><span class="line">        pickFirsts = [<span class="string">'META-INF/LICENSE'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">//merges何必 当出现重复文件时 合并重复的文件 然后打包入apk</span></span><br><span class="line">        <span class="comment">//这个是有默认值得 merges = [] 这样会把默默认值去掉  所以我们用下面这种方式 在默认值后添加</span></span><br><span class="line">        merge <span class="string">'META-INF/LICENSE'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。</span></span><br><span class="line">        exclude <span class="string">'META-INF/services/javax.annotation.processing.Processor'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        _360 &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line">            <span class="comment">//批量修改，类似一个循序遍历</span></span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [IFLYTEK_CHANNEL: name]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关</span></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">        <span class="comment">//即使报错也不会停止打包</span></span><br><span class="line">        checkReleaseBuilds <span class="keyword">false</span></span><br><span class="line">        <span class="comment">//打包release版本的时候进行检测</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//项目的依赖关系</span></span><br><span class="line">    implementation fileTree(<span class="keyword">include</span>: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span><br><span class="line">    <span class="comment">//本地jar包依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:27.1.1'</span></span><br><span class="line">    <span class="comment">//远程依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="comment">//声明测试用例库</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Studio是采用gradle来构建项目的，gradle是基于groovy语言的，如果只是用它构建普通Android项目的话，是可以不去学groovy的。当我们创建一个Android项目时会包含两个Android build.gradle配置详解文件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190911164601.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Gradle" scheme="https://zhangmiao.cc/categories/Android/Gradle/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Gradle" scheme="https://zhangmiao.cc/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android_Studio_3.5：稳步推进ProjectMarble计划</title>
    <link href="https://zhangmiao.cc/posts/4fc3338f.html"/>
    <id>https://zhangmiao.cc/posts/4fc3338f.html</id>
    <published>2019-09-10T03:39:37.000Z</published>
    <updated>2019-09-10T03:54:24.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910115202.png" alt></p><p>我们在 Android Studio 3.5 中引入了许多质量变更，请参阅《<a href="https://developer.android.google.cn/studio/releases#3-5-0" target="_blank" rel="noopener">Android Studio 3.5 Beta 现已发布</a>》或者 <a href="https://android-developers.googleblog.com/2019/05/android-studio-35-beta.html" target="_blank" rel="noopener">Android Studio 版本说明</a>，查看完整版变更列表。当然，您也可以先阅读一下这篇文章或收看下方视频，快速了解一下其中的若干重要变更:</p><ul><li><strong>腾讯视频链接:</strong> <a href="https://link.juejin.im?target=https%3A%2F%2Fv.qq.com%2Fx%2Fpage%2Fw0919w56970.html" target="_blank" rel="noopener">v.qq.com/x/page/w091…</a></li><li><strong>Bilibili 视频链接:</strong> <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav65716536%2F" target="_blank" rel="noopener">www.bilibili.com/video/av657…</a></li></ul><h2 id="系统健康"><a href="#系统健康" class="headerlink" title="系统健康"></a>系统健康</h2><p>Project Marble 计划中系统健康方面的改进包括: 内存性能、输入与用户界面冻结、构建速度、CPU 使用以及 I/O 性能。我们针对这五点分别设计了新的监测机制，以便在开发过程中更准确地识别问题，此外，流程上的优化也让团队得以更好地分析用户反馈，从开发者自愿分享的统计数据和错误报告中获取更多洞见。</p><p>尽管系统健康的许多优化项可能并不为大家所熟知，不过其中还是有几个比较明显的变更，其中包括:</p><p><strong>自动推荐内存设置</strong></p><p>在 Android Studio 3.5 中，IDE 会识别出一个应用项目在 RAM 容量更高的机器上何时需要更多的 RAM，并在通知开发者增加内存堆大小；或者您也可以在 Appearance &amp; Behavior → Memory Settings 下自行调整设置。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114337.png" alt></p><p><strong>用户界面冻结</strong></p><p>在 Project Marble 计划开发期间，我们在产品分析数据中发现 IDE 中的 XML 代码编辑速度明显较慢。我们基于这个数据点优化了 XML 输入，使得 Android Studio 3.5 的性能表现有了极大的提升。从以下两张图中您可以发现，得益于输入延迟的改进，使用 XML 编辑数据绑定表达式的速度明显加快了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/29/16cdb222b4adbb4e?imageslim" alt="img">改进前: 在 Android Studio 3.4 中编辑代码</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/29/16cdb228e68e5701?imageslim" alt="img">改进后: 在 Android Studio 3.5 中编辑代码</p><p><strong>构建速度</strong></p><p>为了提高 Android Studio 3.5 的构建速度，我们采取了许多措施，其中最为重要的一项变更是为<a href="https://developer.android.google.cn/studio/build/optimize-your-build.html#annotation_processors" target="_blank" rel="noopener">顶级注释处理器</a>添加增量构建支持，这些处理器包括 Glide、AndroidX data binding、Dagger、Realm 和 Kotlin (KAPT)。增量支持能够显著提高构建速度。更多内容，请阅读<a href="https://mp.weixin.qq.com/s/AyBkfNL_vodQVLgaZOD6kQ" target="_blank" rel="noopener">《在 Android Studio 中加快构建速度</a>》。</p><p><strong>磁盘 I/O 文件访问速度</strong></p><p>Android Studio 的许多用户都在使用微软旗下的 Windows 系统。我们发现与其他平台相比，Windows 的磁盘 I/O 文件访问耗时明显更久。深度分析数据后，我们发现在一些杀毒程序在默认设置下，并未将 Android Studio 的构建输出文件夹 (build output folder) 排除在扫描范围之外。在 Android Studio 3.5 中，一旦系统监测到这个情况，Studio 将通过弹窗引导您进行最优设置。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114351.png" alt></p><h2 id="特性优化"><a href="#特性优化" class="headerlink" title="特性优化"></a>特性优化</h2><p>除改善系统健康之外，我们还重新检查了一些关键用户流程， 修复了一些错误以及若干导致不良用户体验的问题，涉及领域包括: 数据绑定、布局、Chrome OS 支持和项目升级，而应用部署流则是其中较为关键的一项改进。</p><p><strong>Apply Changes</strong></p><p>在 Project Marble 计划期间，我们移除了 Instant Run，然后在 Android Studio 3.5 中重新构建并实现了一个更加实用的替代方案，即 <a href="https://developer.android.google.cn/studio/run#apply-changes" target="_blank" rel="noopener">Apply Changes</a>。Apply Changes 使用 Android Oreo 及以上版本中的平台特定 API 来确保可靠且一致的系统行为。与 Instant Run 的机制不同，更改系统配置并不会重写您的 APK 文件。为了支持此项变更，我们重构了整个部署管道，以此提升部署速度；与此同时，我们还微调了工具栏中的运行与部署按钮，希望借此为您提供更为精简的开发体验。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114405.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114418.png" alt></p><p>总结一下，Android Studio 3.5 共修复几百个错误，并针对以下核心领域引入了若干关键变更:</p><p><strong>系统健康</strong></p><ul><li>内存设置</li><li>内存使用报告</li><li>减少异常</li><li>用户界面冻结</li><li>构建速度</li><li>IDE 速度</li><li>Lint 代码分析</li><li>I/O 文件访问</li><li>模拟器 CPU 使用</li></ul><p><strong>特性优化</strong></p><ul><li>Apply Changes</li><li>Gradle 同步</li><li>项目更新</li><li>布局编辑器</li><li>数据绑定</li><li>应用部署</li><li>C++ 改进</li><li>Intellij 2019 平台升级</li><li>动态特性支持之条件交付</li><li>模拟器对可折叠设备及 Google Pixel 设备的支持</li><li>Chrome OS 支持</li></ul><p>更多内容，请参阅<a href="https://developer.android.google.cn/studio/releases#3-5-0" target="_blank" rel="noopener"> Android Studio 版本说明</a>，或阅读下列与 Project Marble 计划相关的深度学习专栏或收看 Google I/O 专题分享会:</p><ul><li>Project Marble 计划: Apply Changes： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-studio-project-marble-apply-changes-e3048662e8cd" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>在 Android Studio 中加快构建速度： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fimproving-build-speed-in-android-studio-3e1425274837" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Android 模拟器: Project Marble 计划改进项： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-emulator-project-marble-improvements-1175a934941e" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Android Studio Project Marble 计划: Lint 性能： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-studio-project-marble-lint-performance-8baedbff2521" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Android Studio Project Marble 计划: 布局编辑器： <a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fandroiddevelopers%2Fandroid-studio-project-marble-layout-editor-608b6704957a" target="_blank" rel="noopener">medium.com/androiddeve…</a></li><li>Google I/O: Marble 计划 — Android 开发工具有哪些更新? <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D8rfvfojtRss" target="_blank" rel="noopener">www.youtube.com/watch?v=8rf…</a></li></ul><h2 id="自愿数据分享与反馈"><a href="#自愿数据分享与反馈" class="headerlink" title="自愿数据分享与反馈"></a>自愿数据分享与反馈</h2><p>我们基于开发者提交的反馈与指标数据，判断 Android Studio 中有哪些内容适用于 Project Marble 计划，并决定具体的优化项目和实现手段。开发者可自愿在 Android Studio 内勾选数据分享，收集上来的数据将帮助团队判定产品是否含有波及全体用户的问题，接着在此基础上，调整功能开发工作的顺序，优先解决最令用户头疼的问题。为了获取最优洞见，我们在产品整合了多种不同的反馈渠道，指标数据分享是其中最基本的一款反馈工具，您可通过以下路径在 Android Studio 中启用该功能 Preferences /Settings → Appearance &amp; Behavior → Data Sharing。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114430.png" alt></p><p> 不知道您今年是否留意到 IDE 右下角的用户心情标志。Android Studio 通过这个小小的心情标志，了解用户的使用感受，并获取与实际用例相关的反馈。这是用户向团队提交错误报告最快的途径。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910114442.png" alt></p><h2 id="即刻体验"><a href="#即刻体验" class="headerlink" title="即刻体验"></a>即刻体验</h2><p><strong>下载</strong></p><p>请前往<a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">下载页面</a>，获取 Android Studio 3.5。如果您当前正在使用旧版本的 Android Studio，请直接进行升级操作即可。</p><p>如需使用上述 Android 模拟器特性，请确保您正在运行通过 Android Studio SDK 管理器下载的 Android 模拟器 v29.1.9 或更高版本。</p><p>非常感谢大家继续踊跃反馈，与我们分享您的所感所想，建议与意见，或者任何您期望看到的新特性。如果您遇到任何错误或问题，请<a href="https://source.android.google.cn/source/report-bugs#developer-tools" target="_blank" rel="noopener">提交错误报告</a>，或在评论区留言。</p><p><a href="[http://services.google.cn/fb/forms/yourquestions/](http://services.google.cn/fb/forms/yourquestions/)">点击这里</a>提交产品反馈建议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190910115202.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我们在 Android Studio 3.5 中引入了许多质量变更，请参阅《&lt;a href=&quot;https://developer.android.google.cn/studio/releases#3-5-0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio 3.5 Beta 现已发布&lt;/a&gt;》或者 &lt;a href=&quot;https://android-developers.googleblog.com/2019/05/android-studio-35-beta.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio 版本说明&lt;/a&gt;，查看完整版变更列表。当然，您也可以先阅读一下这篇文章或收看下方视频，快速了解一下其中的若干重要变更:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;腾讯视频链接:&lt;/strong&gt; &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fv.qq.com%2Fx%2Fpage%2Fw0919w56970.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v.qq.com/x/page/w091…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bilibili 视频链接:&lt;/strong&gt; &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav65716536%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.bilibili.com/video/av657…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;系统健康&quot;&gt;&lt;a href=&quot;#系统健康&quot; class=&quot;headerlink&quot; title=&quot;系统健康&quot;&gt;&lt;/a&gt;系统健康&lt;/h2&gt;&lt;p&gt;Project Marble 计划中系统健康方面的改进包括: 内存性能、输入与用户界面冻结、构建速度、CPU 使用以及 I/O 性能。我们针对这五点分别设计了新的监测机制，以便在开发过程中更准确地识别问题，此外，流程上的优化也让团队得以更好地分析用户反馈，从开发者自愿分享的统计数据和错误报告中获取更多洞见。&lt;/p&gt;
&lt;p&gt;尽管系统健康的许多优化项可能并不为大家所熟知，不过其中还是有几个比较明显的变更，其中包括:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动推荐内存设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Android Studio 3.5 中，IDE 会识别出一个应用项目在 RAM 容量更高的机器上何时需要更多的 RAM，并在通知开发者增加内存堆大小；或者您也可以在 Appearance &amp;amp; Behavior → Memory Settings 下自行调整设置。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="Android Studio" scheme="https://zhangmiao.cc/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器输入URL回车之后发生了什么</title>
    <link href="https://zhangmiao.cc/posts/d674143a.html"/>
    <id>https://zhangmiao.cc/posts/d674143a.html</id>
    <published>2019-09-09T03:43:23.000Z</published>
    <updated>2019-09-09T04:15:51.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅.</p><p><strong>注意：</strong>本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><p><strong>大致流程</strong></p><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><a id="more"></a><h3 id="URL-解析"><a href="#URL-解析" class="headerlink" title="URL 解析"></a>URL 解析</h3><h4 id="地址解析："><a href="#地址解析：" class="headerlink" title="地址解析："></a>地址解析：</h4><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><h4 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h4><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<strong>你所不知道的 HSTS</strong>[1]。</p><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><h4 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120457.png" alt></p><h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120545.png" alt></p><h4 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h4><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><h4 id="2-操作系统缓存"><a href="#2-操作系统缓存" class="headerlink" title="2. 操作系统缓存"></a>2. 操作系统缓存</h4><p>操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><h4 id="3-路由器缓存"><a href="#3-路由器缓存" class="headerlink" title="3. 路由器缓存"></a>3. 路由器缓存</h4><p>路由器也有自己的缓存。</p><h4 id="4-ISP-DNS-缓存"><a href="#4-ISP-DNS-缓存" class="headerlink" title="4. ISP DNS 缓存"></a>4. ISP DNS 缓存</h4><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><h4 id="根域名服务器查询"><a href="#根域名服务器查询" class="headerlink" title="根域名服务器查询"></a>根域名服务器查询</h4><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120558.png" alt></p><p>根域名服务器（维基百科）</p><h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</li><li>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><h3 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909120712.png" alt></p><h4 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a>1. 应用层：发送 HTTP 请求</h4><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h4 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a>2. 传输层：TCP 传输报文</h4><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>“</p><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p><p>相关知识点：</p><ol><li>SYN 泛洪攻击</li></ol><p>”</p></blockquote><h4 id="3-网络层：IP协议查询Mac地址"><a href="#3-网络层：IP协议查询Mac地址" class="headerlink" title="3. 网络层：IP协议查询Mac地址"></a>3. 网络层：IP协议查询Mac地址</h4><p>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>“</p><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p><p>”</p></blockquote><h4 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a>4. 链路层：以太网协议</h4><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><p><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p><strong>注意</strong>：接收方回应是单播。</p><blockquote><p>“</p><p>相关知识点：</p><ol><li>ARP 攻击</li></ol><p>”</p></blockquote><h4 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a>服务器接受请求</h4><p>接受过程就是把以上步骤逆转过来，参见上图。</p><h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><h4 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121029.png" alt></p><h4 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h4><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>假如服务器配置了 HTTP 重定向，就会返回一个 <code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>“</p><p>关于更多：<strong>详见这篇文章</strong>[2]</p><p>”</p></blockquote><h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h3 id="浏览器接受响应"><a href="#浏览器接受响应" class="headerlink" title="浏览器接受响应"></a>浏览器接受响应</h3><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 <strong>MIME</strong>[3] 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121308.png" alt></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121319.png" alt></p><h4 id="6-1-HTML-解析"><a href="#6-1-HTML-解析" class="headerlink" title="6.1. HTML 解析"></a>6.1. HTML 解析</h4><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><p><strong>① 解码（encoding）</strong></p><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p><p><strong>② 预解析（pre-parsing）</strong></p><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p><p><strong>③ 符号化（Tokenization）</strong></p><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p><p><strong>④ 构建树（tree construction）</strong></p><blockquote><p>“</p><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p><p>”</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;    &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;h1&gt;Web page parsing&lt;/h1&gt;        &lt;p&gt;This is an example Web page.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121435.png" alt></p><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p><h4 id="6-2-CSS-解析"><a href="#6-2-CSS-解析" class="headerlink" title="6.2. CSS 解析"></a>6.2. CSS 解析</h4><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<strong>语法规范</strong>[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><h4 id="6-3-渲染树"><a href="#6-3-渲染树" class="headerlink" title="6.3. 渲染树"></a>6.3. 渲染树</h4><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>“</p><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p><p>”</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p><ol><li>标签名、class、id</li><li>是否内联样式</li><li><code>!important</code></li></ol><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong></p><p>当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<strong>这篇文章</strong>[5]</p><h4 id="6-4-布局与绘制"><a href="#6-4-布局与绘制" class="headerlink" title="6.4. 布局与绘制"></a>6.4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="6-5-合并渲染层"><a href="#6-5-合并渲染层" class="headerlink" title="6.5. 合并渲染层"></a>6.5. 合并渲染层</h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-6-回流与重绘"><a href="#6-6-回流与重绘" class="headerlink" title="6.6. 回流与重绘"></a>6.6. 回流与重绘</h4><p><strong>回流(reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p><p>reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li></ul><h4 id="6-7-JavaScript-编译执行"><a href="#6-7-JavaScript-编译执行" class="headerlink" title="6.7. JavaScript 编译执行"></a>6.7. JavaScript 编译执行</h4><p><strong>大致流程</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121453.png" alt></p><p>可以分为三个阶段：</p><h5 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h5><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将<code>var a = 2</code>，，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h5 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h5><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong></p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li><p>创建变量对象</p></li><li><ul><li>参数、函数、变量</li></ul></li><li><p>建立作用域链</p></li><li><ul><li>确认当前执行环境是否能访问变量</li></ul></li><li><p>确定 This 指向</p></li></ul><h5 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h5><p><strong>JS 线程</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121506.png" alt></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>“</p><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p><p>”</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong></p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li></ul><p><strong>微任务</strong></p><p>微任务是ES6和Node环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190909121522.png" alt></p><p><strong>代码例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;); // 宏任务 同步</span><br><span class="line">setTimeout(function() &#123;    console.log(&apos;2&apos;); // 宏任务 异步&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;    console.log(&apos;3&apos;); // 宏任务 同步    resolve();&#125;).then(function() &#123;    console.log(&apos;4&apos;) // 微任务&#125;)</span><br><span class="line">console.log(&apos;5&apos;) // 宏任务 同步</span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><p><strong>参考文档</strong></p><p>[1] 你所不知道的 HSTS: <a href="http://t.cn/AiR8pTqx" target="_blank" rel="noopener">http://t.cn/AiR8pTqx</a></p><p>[2] 详见这篇文章: <a href="http://t.cn/AiR8pnEC" target="_blank" rel="noopener">http://t.cn/AiR8pnEC</a></p><p>[3] MIME: <a href="http://t.cn/AiR8prtm" target="_blank" rel="noopener">http://t.cn/AiR8prtm</a></p><p>[4] 语法规范: <a href="http://t.cn/AiR80GdO" target="_blank" rel="noopener">http://t.cn/AiR80GdO</a></p><p>[5] 这篇文章: <a href="http://t.cn/AiR80c1k" target="_blank" rel="noopener">http://t.cn/AiR80c1k</a></p><p>[6] what-happens-when-zh_CN: <a href="http://t.cn/AiR80xb5" target="_blank" rel="noopener">http://t.cn/AiR80xb5</a></p><p>[7] Tags to DOM:<a href="http://t.cn/AiR80djX" target="_blank" rel="noopener">http://t.cn/AiR80djX</a></p><p>[8] 彻底理解浏览器的缓存机制: <a href="http://t.cn/AiR8Ovob" target="_blank" rel="noopener">http://t.cn/AiR8Ovob</a></p><p>[9] 浏览器的工作原理：新式网络浏览器幕后揭秘: <a href="http://t.cn/AiR8Oz06" target="_blank" rel="noopener">http://t.cn/AiR8Oz06</a></p><p>[10] 深入浅出浏览器渲染原理: <a href="http://t.cn/AiR8O4fO" target="_blank" rel="noopener">http://t.cn/AiR8O4fO</a></p><p>[11] js引擎的执行过程（一）:<a href="http://t.cn/AiR8Ot3s" target="_blank" rel="noopener">http://t.cn/AiR8Ot3s</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。&lt;/p&gt;
&lt;p&gt;这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大致流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;URL 解析&lt;/li&gt;
&lt;li&gt;DNS 查询&lt;/li&gt;
&lt;li&gt;TCP 连接&lt;/li&gt;
&lt;li&gt;处理请求&lt;/li&gt;
&lt;li&gt;接受响应&lt;/li&gt;
&lt;li&gt;渲染页面&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="前端" scheme="https://zhangmiao.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="tips" scheme="https://zhangmiao.cc/categories/%E5%89%8D%E7%AB%AF/tips/"/>
    
    
      <category term="前端" scheme="https://zhangmiao.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="tips" scheme="https://zhangmiao.cc/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Google终于发布了Android 10正式版</title>
    <link href="https://zhangmiao.cc/posts/3609d6c4.html"/>
    <id>https://zhangmiao.cc/posts/3609d6c4.html</id>
    <published>2019-09-05T01:53:46.000Z</published>
    <updated>2019-09-05T07:08:16.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>9月4号凌晨，Google终于发布了Android 10正式版！</p><p>全新的Logo，依然沿用经典机器人，但在图标，颜色及细节上都有明显变动。新的设计是为了更加现代，更加易用。特别是文字从绿色改为了黑色，这样的变更对视觉障碍者更加友好。</p><p>除了Logo的变化，新版Android系统的命名也有重大变动。现有的命名规则是安装英文字母顺序依次选区甜品或零食来命名。如果从09年的Cupcake算起，不算08年开始的alpha和beat测试版，到现在已经用了10年。</p><p>在新的版本中将打破甜品，零食的命名规则，可能改为Android 10。David表示：“改变命名是为了避免全球不同地区的误解，某些语言里L和R是没有区分的。另外有些地方馅饼也不是甜点，棉花糖虽然味道不错，但是在世界上有很多地区是不受欢迎的食物。”</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826095720.png" alt></p><a id="more"></a><h3 id="1-创新体验"><a href="#1-创新体验" class="headerlink" title="1. 创新体验"></a>1. 创新体验</h3><p>本次Android 10带来了全新的用户体验，包括：</p><ul><li>暗黑主题</li><li>智能回复</li><li>5G网络支持</li><li>可折叠</li></ul><h4 id="1-1-暗黑主题"><a href="#1-1-暗黑主题" class="headerlink" title="1.1 暗黑主题"></a>1.1 暗黑主题</h4><p>对于用户来说（特别是低视力 &amp; 强光敏感），可提高屏幕内容可见度 &amp; 保护性。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150439.png" alt></p><h4 id="1-2-智能回复"><a href="#1-2-智能回复" class="headerlink" title="1.2 智能回复"></a>1.2 智能回复</h4><ul><li>使用机器学习来预测你在回复信息时可能会说些什么，从而提供对信息的回复建议 &amp; 建议操作</li><li>如朋友约吃饭，Google会建议你发送回应短信 &amp; 在 Google 地图中直接显示位置信息</li></ul><blockquote><p>注：本在 Android P 中已提供，但仅限于谷歌专用的应用程序；本次Android 10 中，已内置到整个通知系统中。</p></blockquote><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150534.png" alt></p><h4 id="1-3-5G网络"><a href="#1-3-5G网络" class="headerlink" title="1.3 5G网络"></a>1.3 5G网络</h4><p>针对之前已公布的5G网络，Android 10增加了对5G网络通信支持（提供了检测连接性的API），从而使得用户可以获得更加快速的网络冲凉体验。</p><h4 id="1-4-可折叠支持"><a href="#1-4-可折叠支持" class="headerlink" title="1.4 可折叠支持"></a>1.4 可折叠支持</h4><p>针对应用程序窗口的多任务处理，Android 10增加了对可折叠屏的支持：设备折叠 / 展开时提供屏幕连续性来维护应用程序状态，通过优化可折叠设备，为当今的创新设备提供无缝体验。</p><hr><h3 id="2-隐私保护"><a href="#2-隐私保护" class="headerlink" title="2. 隐私保护"></a>2. 隐私保护</h3><p>近年来，Google对于用户的隐私保护十分看重。Android 10更新中，对于隐私保护也是核心关注点，主要包括以下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150612.png" alt></p><hr><h3 id="3-安全加强"><a href="#3-安全加强" class="headerlink" title="3. 安全加强"></a>3. 安全加强</h3><p>由于Android碎片化，系统的安全性一直被诟病。在Android 10中，引入了更多的确定用户安全的特性，具体如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150700.png" alt></p><hr><h3 id="4-系统优化"><a href="#4-系统优化" class="headerlink" title="4. 系统优化"></a>4. 系统优化</h3><p>主要包括ART优化 &amp; 神经网络升级</p><h4 id="4-1-ART优化"><a href="#4-1-ART优化" class="headerlink" title="4.1 ART优化"></a>4.1 ART优化</h4><p>ART运行时的改进可以帮助您的应用程序启动得更快、消耗更少的内存、运行得更流畅。Google对ART进行了优化：</p><ul><li>在运行前，就预先编译应用程序的部分</li><li>在运行时，分代垃圾收集使垃圾收集在时间 &amp; CPU方面更高效，减少jank，并帮助应用程序在低端设备上更好地运行。</li></ul><p>以下是优化对比：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190905150725.png" alt></p><h4 id="4-2-神经网络升级"><a href="#4-2-神经网络升级" class="headerlink" title="4.2 神经网络升级"></a>4.2 神经网络升级</h4><ul><li>增加了大量在神经网络方面的新操作，包括ARGMAX、ARGMIN、量化LSTM &amp; 一系列性能优化</li><li>这使得加速更大范围的模型奠定了基础，比如用于目标检测和图像分割的模型</li><li>正在与硬件供应商和流行的机器学习框架（如TensorFlow）合作，优化和推出对NNAPI 1.2的支持</li></ul><hr><h3 id="关于更新推送"><a href="#关于更新推送" class="headerlink" title="关于更新推送"></a>关于更新推送</h3><ul><li>Google首先面向自身的Pixel系列设备推送</li><li>对于国内，小米成为国内第一家提供Android 10更新的公司 - 其旗下的Redmi K20 Pro 首批接收到了基于 Android 10 的 MIUI 更新</li></ul><hr><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li>每次Anroid新版本的到来，就意味着我们要进行适配。</li></ul><h3 id="回顾历史版本"><a href="#回顾历史版本" class="headerlink" title="回顾历史版本"></a>回顾历史版本</h3><p>让我们一起回忆这10年来陪伴我们的Android点心。这是每个Android 开发者的青春。</p><h3 id="Cupcake-1-5-（纸杯蛋糕）–-2009年4月"><a href="#Cupcake-1-5-（纸杯蛋糕）–-2009年4月" class="headerlink" title="Cupcake 1.5 （纸杯蛋糕）– 2009年4月"></a>Cupcake 1.5 （纸杯蛋糕）– 2009年4月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100017.png" alt></p><h3 id="Donut-1-6（甜甜圈）–-2009年9月"><a href="#Donut-1-6（甜甜圈）–-2009年9月" class="headerlink" title="Donut 1.6（甜甜圈）– 2009年9月"></a>Donut 1.6（甜甜圈）– 2009年9月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100053.png" alt></p><h3 id="Eclair-2-0-1（泡芙）–-2009年10月26日"><a href="#Eclair-2-0-1（泡芙）–-2009年10月26日" class="headerlink" title="Eclair 2.0-1（泡芙）– 2009年10月26日"></a>Eclair 2.0-1（泡芙）– 2009年10月26日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100113.png" alt></p><h3 id="Froyo-2-2（冻酸奶）–-2010年5月"><a href="#Froyo-2-2（冻酸奶）–-2010年5月" class="headerlink" title="Froyo 2.2（冻酸奶）– 2010年5月"></a>Froyo 2.2（冻酸奶）– 2010年5月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100132.png" alt></p><h3 id="Gingerbread-2-3（姜饼）–-2010年12月"><a href="#Gingerbread-2-3（姜饼）–-2010年12月" class="headerlink" title="Gingerbread 2.3（姜饼）– 2010年12月"></a>Gingerbread 2.3（姜饼）– 2010年12月</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100132.png" alt></p><h3 id="Honeycomb-3-0-2（蜂巢）–-2011年2月2日"><a href="#Honeycomb-3-0-2（蜂巢）–-2011年2月2日" class="headerlink" title="Honeycomb 3.0-2（蜂巢）– 2011年2月2日"></a>Honeycomb 3.0-2（蜂巢）– 2011年2月2日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100503.png" alt></p><h3 id="Ice-Cream-Sandwich-4-0（冰淇淋三明治）–-2011年10月19日"><a href="#Ice-Cream-Sandwich-4-0（冰淇淋三明治）–-2011年10月19日" class="headerlink" title="Ice Cream Sandwich 4.0（冰淇淋三明治）– 2011年10月19日"></a>Ice Cream Sandwich 4.0（冰淇淋三明治）– 2011年10月19日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100523.png" alt></p><h3 id="Jelly-Bean-4-1-3（果冻豆）–-2012年6月28日"><a href="#Jelly-Bean-4-1-3（果冻豆）–-2012年6月28日" class="headerlink" title="Jelly Bean 4.1-3（果冻豆）– 2012年6月28日"></a>Jelly Bean 4.1-3（果冻豆）– 2012年6月28日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100541.png" alt></p><h3 id="KitKat-4-4（日本巧克力品牌）–-2013年11月01日"><a href="#KitKat-4-4（日本巧克力品牌）–-2013年11月01日" class="headerlink" title="KitKat 4.4（日本巧克力品牌）– 2013年11月01日"></a>KitKat 4.4（日本巧克力品牌）– 2013年11月01日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100603.png" alt></p><h3 id="Lollipop-5-0-1（棒棒糖）–-2014年10月15日"><a href="#Lollipop-5-0-1（棒棒糖）–-2014年10月15日" class="headerlink" title="Lollipop 5.0-1（棒棒糖）– 2014年10月15日"></a>Lollipop 5.0-1（棒棒糖）– 2014年10月15日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100631.png" alt></p><h3 id="Marshmallow-6-0（棉花糖）–-2015年9月30日"><a href="#Marshmallow-6-0（棉花糖）–-2015年9月30日" class="headerlink" title="Marshmallow 6.0（棉花糖）– 2015年9月30日"></a>Marshmallow 6.0（棉花糖）– 2015年9月30日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100652.png" alt></p><h3 id="Nougat-7-0-1（牛轧糖）–-2016年8月22日"><a href="#Nougat-7-0-1（牛轧糖）–-2016年8月22日" class="headerlink" title="Nougat 7.0-1（牛轧糖）– 2016年8月22日"></a>Nougat 7.0-1（牛轧糖）– 2016年8月22日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100800.png" alt></p><h3 id="Oreo-8-0-1（奥利奥）–-2017-年-8-月-22-日"><a href="#Oreo-8-0-1（奥利奥）–-2017-年-8-月-22-日" class="headerlink" title="Oreo 8.0-1（奥利奥）– 2017 年 8 月 22 日"></a>Oreo 8.0-1（奥利奥）– 2017 年 8 月 22 日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100819.png" alt></p><h3 id="Pie-9-0（果馅派）–-2018-年-5月-9日"><a href="#Pie-9-0（果馅派）–-2018-年-5月-9日" class="headerlink" title="Pie 9.0（果馅派）– 2018 年 5月 9日"></a>Pie 9.0（果馅派）– 2018 年 5月 9日</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826100845.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;9月4号凌晨，Google终于发布了Android 10正式版！&lt;/p&gt;
&lt;p&gt;全新的Logo，依然沿用经典机器人，但在图标，颜色及细节上都有明显变动。新的设计是为了更加现代，更加易用。特别是文字从绿色改为了黑色，这样的变更对视觉障碍者更加友好。&lt;/p&gt;
&lt;p&gt;除了Logo的变化，新版Android系统的命名也有重大变动。现有的命名规则是安装英文字母顺序依次选区甜品或零食来命名。如果从09年的Cupcake算起，不算08年开始的alpha和beat测试版，到现在已经用了10年。&lt;/p&gt;
&lt;p&gt;在新的版本中将打破甜品，零食的命名规则，可能改为Android 10。David表示：“改变命名是为了避免全球不同地区的误解，某些语言里L和R是没有区分的。另外有些地方馅饼也不是甜点，棉花糖虽然味道不错，但是在世界上有很多地区是不受欢迎的食物。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826095720.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="Android版本" scheme="https://zhangmiao.cc/tags/Android%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>优雅解决Android软键盘弹出时把布局顶上去</title>
    <link href="https://zhangmiao.cc/posts/f2eb3913.html"/>
    <id>https://zhangmiao.cc/posts/f2eb3913.html</id>
    <published>2019-08-27T08:12:51.000Z</published>
    <updated>2019-08-27T08:14:44.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>在你的activity中的oncreate中setContentView之前写上这个代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">getWindow</span>()<span class="selector-class">.setSoftInputMode</span>(<span class="selector-tag">WindowManager</span><span class="selector-class">.LayoutParams</span><span class="selector-class">.SOFT_INPUT_ADJUST_PAN</span>);</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>在项目的AndroidManifest.xml文件中界面对应的<activity>里加入android:windowSoftInputMode=”stateVisible|adjustResize”，这样会让屏幕整体上移。如果加上的是<br>android:windowSoftInputMode=”adjustPan”这样键盘就会覆盖屏幕。</activity></p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>把顶级的layout替换成ScrollView，或者说在顶级的Layout上面再加一层ScrollView的封装。这样就会把软键盘和输入框一起滚动了，软键盘会一直处于底部。</p><a id="more"></a><h3 id="主窗口与软键盘窗口交互设置值如下："><a href="#主窗口与软键盘窗口交互设置值如下：" class="headerlink" title="主窗口与软键盘窗口交互设置值如下："></a>主窗口与软键盘窗口交互设置值如下：</h3><table><thead><tr><th>将覆盖在主题中设置的值</th><th>值描述</th></tr></thead><tbody><tr><td>“stateUnspecified”</td><td>软键盘的状态(是否它是隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。这个是为了软件盘行为默认的设置。</td></tr><tr><td>“stateUnchanged”</td><td>软键盘被保持无论它上次是什么状态，是否可见或隐藏，当主窗口出现在前面时。</td></tr><tr><td>“stateHidden”</td><td>当用户选择该Activity时，软键盘被隐藏——也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。</td></tr><tr><td>“stateAlwaysHidden”</td><td>软键盘总是被隐藏的，当该Activity主窗口获取焦点时。</td></tr><tr><td>“stateVisible”</td><td>软键盘是可见的，当那个是正常合适的时(当用户导航到Activity主窗口时)。</td></tr><tr><td>“stateAlwaysVisible”</td><td>当用户选择这个Activity时，软键盘是可见的——也就是，也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。</td></tr><tr><td>“adjustUnspecified”</td><td>它不被指定是否该 Activity主窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局视图能够滚动他们的内容。如果有这样的一个视图，这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为设置。</td></tr><tr><td>“adjustResize”</td><td>该Activity主窗口总是被调整屏幕的大小以便留出软键盘的空间</td></tr><tr><td>“adjustPan”</td><td>该Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;h3 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerlink&quot; title=&quot;方法一：&quot;&gt;&lt;/a&gt;方法一：&lt;/h3&gt;&lt;p&gt;在你的activity中的oncreate中setContentView之前写上这个代码&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;getWindow&lt;/span&gt;()&lt;span class=&quot;selector-class&quot;&gt;.setSoftInputMode&lt;/span&gt;(&lt;span class=&quot;selector-tag&quot;&gt;WindowManager&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LayoutParams&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.SOFT_INPUT_ADJUST_PAN&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;方法二：&quot;&gt;&lt;a href=&quot;#方法二：&quot; class=&quot;headerlink&quot; title=&quot;方法二：&quot;&gt;&lt;/a&gt;方法二：&lt;/h3&gt;&lt;p&gt;在项目的AndroidManifest.xml文件中界面对应的&lt;activity&gt;里加入android:windowSoftInputMode=”stateVisible|adjustResize”，这样会让屏幕整体上移。如果加上的是&lt;br&gt;android:windowSoftInputMode=”adjustPan”这样键盘就会覆盖屏幕。&lt;/activity&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法三：&quot;&gt;&lt;a href=&quot;#方法三：&quot; class=&quot;headerlink&quot; title=&quot;方法三：&quot;&gt;&lt;/a&gt;方法三：&lt;/h3&gt;&lt;p&gt;把顶级的layout替换成ScrollView，或者说在顶级的Layout上面再加一层ScrollView的封装。这样就会把软键盘和输入框一起滚动了，软键盘会一直处于底部。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="软键盘" scheme="https://zhangmiao.cc/tags/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Android APK 安装的原理</title>
    <link href="https://zhangmiao.cc/posts/2da5bed1.html"/>
    <id>https://zhangmiao.cc/posts/2da5bed1.html</id>
    <published>2019-08-26T02:15:08.000Z</published>
    <updated>2019-08-26T02:17:48.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家有没有想过一个应用的APK是怎么被安装到安卓手机上的，安装的本质是什么？我们知道，Windows应用程序的安装包是一个可执行的压缩包，安装的过程是把压缩包中的数据和依赖库拷贝到安装目录，再在桌面或启动栏创建快捷方式，那么安卓的APK安装过程是不是也是这样的呢？本文将为大家解答这些问题。</p><h3 id="APK包的构成"><a href="#APK包的构成" class="headerlink" title="APK包的构成"></a>APK包的构成</h3><p>首先，我看一下APK包的构成，Android的APK包和Windows应用程序安装包是不同的，它只是个简单的压缩包，没有可执行的能力，我们还可以用zip工具直接解压它。</p><p>一个APK包含以下这些文件：</p><ul><li>META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF）</li><li>assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取</li><li>res目录：包含那些没有被编译到resources.arsc的资源</li><li>lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips</li><li>resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片</li><li>classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。</li><li>AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。</li></ul><p>这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。</p><a id="more"></a><h3 id="安装APK"><a href="#安装APK" class="headerlink" title="安装APK"></a>安装APK</h3><p>我们安装应用程序，最常用的方法就是在PC上运行命令adb install 加APK的文件路径，回车等待Android设备安装完成，安装成功命令行会显示Success。那么其内部是怎样的一个过程呢？</p><h4 id="1-将APK包push到手机"><a href="#1-将APK包push到手机" class="headerlink" title="1. 将APK包push到手机"></a>1. 将APK包push到手机</h4><p>首先，adb会将PC端的APK文件push到Android设备的/data/local/tmp目录下，一些手机会将拷贝的进度反馈给adb客户端，于是PC上的命令行会展示拷贝的进度。</p><h4 id="2-执行pm命令"><a href="#2-执行pm命令" class="headerlink" title="2. 执行pm命令"></a>2. 执行pm命令</h4><p>PC端的adb程序会向Android端的adbd发送shell:pm命令，于是adbd会向系统的PackageManagerService（PMS）进程发送消息，通知其安装apk包。这里我有两个理解：<br>理解一：我们平常也可以在adb shell上执行pm命令与PMS交互，那么pm应该是个独立的进程，adbd执行pm命令，是启动了pm这个进程，这个进程再向PMS进程发送消息，通知其安装APK。<br>理解二：adbd直接向PMS进程发送消息，通知其安装APK。<br>不知哪个正确，这个有待继续研究，如果有童鞋了解这个，希望能不吝赐教。</p><h4 id="3-触发安装过程"><a href="#3-触发安装过程" class="headerlink" title="3. 触发安装过程"></a>3. 触发安装过程</h4><p>PMS首先将APK包拷贝到另外一个目录/data/app，这个目录是非系统应用的apk存放的目录，与之相对应的，系统应用的apk存放的目录是/system/frameworks、/system/app和/vendor/app。<br>PMS内部有个AppDirObserver类，其监听着/data/app目录的变化，当apk被复制到/data/app目录之后，该类随即触发PMS对APK进行解析。</p><h4 id="4-APK的解析"><a href="#4-APK的解析" class="headerlink" title="4. APK的解析"></a>4. APK的解析</h4><p>我们可以先想想，Android系统是如何启动一个APP的？比如点击屏幕上的应用图标，然后一个Activity就被启动了。这个过程中，桌面程序Launcher先是向ActivityManagerService（AMS）进程发送了一个Intent，AMS随即会将这个Intent扔给PMS，PMS则解析这个Intent得到Activity的信息给到AMS，然后AMS会启动一个空进程，并通知该进程创建该Activity。那么PMS为什么会有这个Activity的信息呢？</p><p>这就是PMS解析APK要做的事情了，而解析APK的时机又要分成两种场景：</p><p><strong>1. 系统启动时解析APK</strong><br>Android系统在启动的时候，会启动一个system_server进程，这个进程驻留着系统多个重要的服务，其中便包含了与APK最相关的PackageManagerService服务，这个服务在启动的时候，会扫描Android系统中几个目标文件夹中的APK，对每个APK进行解析。</p><p><strong>2. 安装过程中解析APK</strong><br>安装一个apk的过程，PMS也会对这个APK进行解析，其调用的是PackageManagerService.java的scanPackageLI()方法，其实在系统启动时扫描全部apk的过程也是调用该方法。</p><p>可以这样理解，系统启动的时候，是解析已经安装的所有APK，而安装单个APK时，则是用同样的方法解析这个APK，过程是一样的。</p><p><strong>那么解析APK具体做的是什么事情呢？</strong></p><p>其中主要的过程就是解析APK中的AndroidManifest.xml文件，将APK的关键信息四大组件信息、权限信息等存储在内存中的PackageParser对象中，PackageParser对象的结构如图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826101647.png" alt></p><p>这个PackageParser包含了IntentFilter的信息，使得PMS可以根据Intent来获取一个Activity的信息。那么，PMS在得到PackageParser对象之后，接着会将这个APK的信息加入到PMS自身管理中去，比如将Activity的数据保存在mActivities对象中，将Provider的数据保存在mProviders对象中等，PKMS提供了好几个重要数据结构来保存这些数据，这些数据结构的相关信息如图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190826101712.png" alt></p><p>除了解析和保存APK的核心数据，PMS还会创建应用程序目录：/data/data/包名，同时提取apk中的dex文件并保存到/data/dalvik-cache中，如果该APK包含了native动态库，则需要将它们从APK文件中解压并复制到对应目录中，以及对APK进行dex优化，还有其它一些细节比如APK签名的校验，杀死APK所在进程（覆盖安装的情况）等，安装过程的最后，会发送ACTION_PACKAGE_ADDED广播，通知所有其它应用有新应用安装了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，APK安装过程就结束了。纵观整个过程，apk安装的关键就是解析AndroidManifest.xml，将重要的信息保存在PMS进程的内存中，以保证后续启动这个应用程序的组件时，可以在PMS中找到这个组件的信息。我们本来认为的更重要的代码只是进行dex优化后简单地提取到一个目录中而已，另外，APK中的资源并没有被处理，而是在启动应用进程的时候，动态去从APK包中加载而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大家有没有想过一个应用的APK是怎么被安装到安卓手机上的，安装的本质是什么？我们知道，Windows应用程序的安装包是一个可执行的压缩包，安装的过程是把压缩包中的数据和依赖库拷贝到安装目录，再在桌面或启动栏创建快捷方式，那么安卓的APK安装过程是不是也是这样的呢？本文将为大家解答这些问题。&lt;/p&gt;
&lt;h3 id=&quot;APK包的构成&quot;&gt;&lt;a href=&quot;#APK包的构成&quot; class=&quot;headerlink&quot; title=&quot;APK包的构成&quot;&gt;&lt;/a&gt;APK包的构成&lt;/h3&gt;&lt;p&gt;首先，我看一下APK包的构成，Android的APK包和Windows应用程序安装包是不同的，它只是个简单的压缩包，没有可执行的能力，我们还可以用zip工具直接解压它。&lt;/p&gt;
&lt;p&gt;一个APK包含以下这些文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF）&lt;/li&gt;
&lt;li&gt;assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取&lt;/li&gt;
&lt;li&gt;res目录：包含那些没有被编译到resources.arsc的资源&lt;/li&gt;
&lt;li&gt;lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips&lt;/li&gt;
&lt;li&gt;resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片&lt;/li&gt;
&lt;li&gt;classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。&lt;/li&gt;
&lt;li&gt;AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="Android版本" scheme="https://zhangmiao.cc/tags/Android%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>静态代码lint常见报错处理</title>
    <link href="https://zhangmiao.cc/posts/db4fcd4.html"/>
    <id>https://zhangmiao.cc/posts/db4fcd4.html</id>
    <published>2019-08-23T01:48:58.000Z</published>
    <updated>2019-08-23T01:56:16.413Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周做了一些关于Android静态代码检测的东西，对于一些常见的lint警告做了记录,其实对于常见的lint警告我们得处理步骤可以分为如下：</p><blockquote><ul><li>查看lint报错的错误类型</li><li>追踪到代码处，确定是否代码自身问题</li><li>分析该类错误影响范围</li><li>确定解决方式(规范代码、添加注解、添加规则)</li></ul></blockquote><h5 id="规范代码"><a href="#规范代码" class="headerlink" title="规范代码"></a>规范代码</h5><p>一般是由于开发者在开发时，不细心造成误写等，或者是某些API过时，需要进行手动修改。</p><h4 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h4><p>对于某些特殊需求，可以通过加注解来避免lint报错,以下给出常见的添加注解的地方</p><h5 id="java源代码"><a href="#java源代码" class="headerlink" title="java源代码"></a>java源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"xxxx"</span>) <span class="comment">// xxxx代表某种lint检测类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h5><p>首先添加命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace xmlns:tools="http://schemas.android.com/tools"</span><br></pre></td></tr></table></figure><p>然后在报错地方添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xxxx代表某种lint检测类型,或者可以是直接all,禁止掉所有检测类型--&gt;</span></span><br><span class="line">tools:ignore="xxxx"</span><br></pre></td></tr></table></figure><h4 id="添加规则-lint-xml文件"><a href="#添加规则-lint-xml文件" class="headerlink" title="添加规则(lint.xml文件)"></a>添加规则(lint.xml文件)</h4><p>对于某些大规模类型的，或者是知道自己必须这么干时，就可以添加规则来规避某种类型的所有lint报错或者是指定路径，亦或者是通过正则指定。<br> 添加规则格式为：<br> <strong>规避一种类型</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xxxx代表某种lint检测类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"xxxx"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>指定路径</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--xxxx代表某种lint检测类型--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--****代表指定路径或者是文件--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--####通过正则来指定相关文件或者属性等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"xxxx"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ignore</span> <span class="attr">path</span>=<span class="string">"****"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ignore</span> <span class="attr">regexp</span>=<span class="string">"####"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">issue</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>改变lint检测类型</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--xxxx代表某种lint检测类型--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--severity有不同种程度的类型  Fatal、Error 、Warning 、Information 、Ignore--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"xxxx"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>接下来记录下我见到和处理的一些报错类型</p><h4 id="1-Missing-commit-on-SharedPreference-editor"><a href="#1-Missing-commit-on-SharedPreference-editor" class="headerlink" title="1. Missing commit() on SharedPreference editor"></a>1. Missing commit() on SharedPreference editor</h4><p>缺少commit()方法调用，添加即可;但是你或许会遇到下面这个问题,它依然会lint检测报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SharedPreferencesUtils.apply(dataStore.edit() .putString(xxx, xxx));</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(SharedPreferences.Editor editor)</span> </span>&#123;</span><br><span class="line">        editor.apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是这样的话，建议到指定方法调用处添加注解</p><blockquote><p>@SuppressLint(“CommitPrefEdits”)</p></blockquote><h4 id="2-Use-apply-on-SharedPreferences"><a href="#2-Use-apply-on-SharedPreferences" class="headerlink" title="2. Use apply() on SharedPreferences"></a>2. Use apply() on SharedPreferences</h4><p>建议使用apply()替换commit(),对于两个方法的区别，建议看看<a href="https://www.cnblogs.com/dd-dd/p/5688991.html" target="_blank" rel="noopener">这里</a></p><h4 id="3-Mismatched-Styleable-Custom-View-Name"><a href="#3-Mismatched-Styleable-Custom-View-Name" class="headerlink" title="3. Mismatched Styleable/Custom View Name"></a>3. Mismatched Styleable/Custom View Name</h4><p>建议在自定义View的时候，尽量保证View名称与&lt;declare-styleable 的name一致,<br> 若有特殊需求需要对指定进行添加注解.</p><blockquote><p>@SuppressLint(“CustomViewStyleable”)<br> 若存在特殊需求，则更建议在lint.xml中添加规则:<br> <issue id="CustomViewStyleable" severity="ignore"></issue></p></blockquote><h4 id="4-Duplicate-ids-across-layouts-combined-with-include-tags"><a href="#4-Duplicate-ids-across-layouts-combined-with-include-tags" class="headerlink" title="4. Duplicate ids across layouts combined with include tags"></a>4. Duplicate ids across layouts combined with include tags</h4><p>在布局中，通过<include>进来的layout，存在和父布局中相同id的view，修改建议，修改布局中id命名.</include></p><h4 id="5-Using-android-media-ExifInterface"><a href="#5-Using-android-media-ExifInterface" class="headerlink" title="5. Using android.media.ExifInterface"></a>5. Using android.media.ExifInterface</h4><p>Avoid using android.media.ExifInterface;use android.support.media.ExifInterface from the support library instead.<br> 使用support包相关替换</p><h4 id="6-Hardcoded-reference-to-sdcard"><a href="#6-Hardcoded-reference-to-sdcard" class="headerlink" title="6. Hardcoded reference to /sdcard"></a>6. Hardcoded reference to /sdcard</h4><p>Do not hardcode “/data/“; use Context.getFilesDir().getPath() instead<br> lint 给出的修改建议是使用Context.getFilesDir().getPath() 替换直接通过路径拼接，但是根据场景可以自变吧；若不想通过这种方式可以直接忽略，添加注解<br> 类似错误场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbCopyHelper</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_PATH = <span class="string">"/data/data/"</span> + BuildConfig.APPLICATION_ID + <span class="string">"/databases/"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Context context, String dbName, <span class="keyword">boolean</span> force)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(DB_PATH);</span><br></pre></td></tr></table></figure><blockquote><p>@SuppressLint(“ SdCardPath”)<br> 若存在特殊需求，则更建议在lint.xml中添加规则:<br> <issue id="SdCardPath" severity="ignore"></issue></p></blockquote><h4 id="7-Attribute-unused-on-older-versions"><a href="#7-Attribute-unused-on-older-versions" class="headerlink" title="7. Attribute unused on older versions"></a>7. Attribute unused on older versions</h4><p>建议添加规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xxxx代表某个属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"UnusedAttribute"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ignore</span> <span class="attr">regexp</span>=<span class="string">".*xxxxx.*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">issue</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-Appcompat-Custom-Widgets"><a href="#8-Appcompat-Custom-Widgets" class="headerlink" title="8. Appcompat Custom Widgets"></a>8. Appcompat Custom Widgets</h4><p>This custom view should extend android.support.v7.widget.AppCompatTextView instead<br> 建议:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加规则</span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"AppCompatCustomView"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br><span class="line">或者是添加注解</span><br><span class="line">@SuppressLint(“AppCompatCustomView”)</span><br></pre></td></tr></table></figure><h4 id="9-Restricted-API"><a href="#9-Restricted-API" class="headerlink" title="9. Restricted API"></a>9. Restricted API</h4><p>xxx can only be called from within the same library group<br> 方法只能在同一个library group中调用<br> 添加注解:</p><blockquote><p>@SuppressLint(“RestrictedApi”)<br> 或者是规则</p></blockquote><h4 id="10-Invalid-format-string"><a href="#10-Invalid-format-string" class="headerlink" title="10. Invalid format string"></a>10. Invalid format string</h4><p>在进行字符串格式化处理的时候，需要注意formatted=“false” 的影响<br> 直接添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略string的format--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"StringFormatInvalid"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于formatted=“false”的理解,在进行string.xml编写的时候，注意内容的占位符号，如果大于等于2个占位符的时候，建议使用formatted=“false”，或者使用正则方式%n$m。</p><h4 id="11-Insecure-HostnameVerifier"><a href="#11-Insecure-HostnameVerifier" class="headerlink" title="11. Insecure HostnameVerifier"></a>11. Insecure HostnameVerifier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;                    </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>场景是直接均返回true，被认为是不安全的操作，若知道自己在干什么，可以直接添加注解</p><blockquote><p>@SuppressLint(“AllowAllHostnameVerifier”)</p></blockquote><p>或者添加规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略业务中总是返回true--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"BadHostnameVerifier"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="12-Insecure-TLS-SSL-trust-manager"><a href="#12-Insecure-TLS-SSL-trust-manager" class="headerlink" title="12. Insecure TLS/SSL trust manager"></a>12. Insecure TLS/SSL trust manager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">       CertificateException </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议添加规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略信任X509TrustManager带来的危险--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"TrustAllX509TrustManager"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="13-Obsolete-layout-params"><a href="#13-Obsolete-layout-params" class="headerlink" title="13. Obsolete layout params"></a>13. Obsolete layout params</h4><p>Invalid layout param in a LinearLayout: layout_centerInParent<br> 建议开发中，对布局的使用注意可用性，在参考代码的时候，注意删除修改后不可用的属性</p><h4 id="14-Static-Field-Leaks"><a href="#14-Static-Field-Leaks" class="headerlink" title="14. Static Field Leaks"></a>14. Static Field Leaks</h4><p>注意在书写单例的时候，避免使用局部context.均转换为全局上下文</p><h4 id="15-Node-can-be-replaced-by-a-TextView-with-compound-drawables"><a href="#15-Node-can-be-replaced-by-a-TextView-with-compound-drawables" class="headerlink" title="15. Node can be replaced by a TextView with compound drawables"></a>15. Node can be replaced by a TextView with compound drawables</h4><p>这个警告的产生，主要是在一个线性布局中存在一个textView和一个ImageView，认为一个textView可以实现类似的功能，而不用添加多余的嵌套和View；<br> 但是对于特定的需求，不能保证能实现想要的效果，因此建议添加规则忽略：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略对linearlayout(包含TextView和ImageView)使用的误报--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"UseCompoundDrawables"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="16-View-Holder-Candidates"><a href="#16-View-Holder-Candidates" class="headerlink" title="16. View Holder Candidates"></a>16. View Holder Candidates</h4><p>Unconditional layout inflation from view adapter: Should use View Holder pattern (use recycled view passed into this method as the second parameter) for smoother scrolling<br> 建议使用ViewHolder</p><h4 id="17-Missing-baselineAligned-attribute"><a href="#17-Missing-baselineAligned-attribute" class="headerlink" title="17. Missing baselineAligned attribute"></a>17. Missing baselineAligned attribute</h4><p>缺少baselineAligned这个属性，建议看看<a href="https://www.jianshu.com/p/07ba80fdd86a" target="_blank" rel="noopener">这里</a>，这个警告可以根据需求自行添加属性与否，或者是添加规则和注解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--忽略建议 Set android:baselineAligned="false"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issue</span> <span class="attr">id</span>=<span class="string">"DisableBaselineAlignment"</span> <span class="attr">severity</span>=<span class="string">"ignore"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="18-Inefficient-layout-weight"><a href="#18-Inefficient-layout-weight" class="headerlink" title="18. Inefficient layout weight"></a>18. Inefficient layout weight</h4><p>在使用layout weight属性的时候，应保持相应属性为0dp;或者是在copy代码的时候忘记删除layout_weight代码导致lint检测报错</p><h4 id="19-Nested-layout-weights"><a href="#19-Nested-layout-weights" class="headerlink" title="19. Nested layout weights"></a>19. Nested layout weights</h4><p>在布局进行嵌套使用时，父布局与子布局都使用了android:layout_weight，根据需求进行修改;</p><h4 id="20-Useless-parent-layout"><a href="#20-Useless-parent-layout" class="headerlink" title="20. Useless parent layout"></a>20. Useless parent layout</h4><p>警告有未使用的父布局，或者是无用的父布局。<br> 根据实际需求进行忽略或者是删除相应布局</p><h4 id="21-Unused-namespace"><a href="#21-Unused-namespace" class="headerlink" title="21. Unused namespace"></a>21. Unused namespace</h4><p>命名空间重复添加，或者是删除对应属性后，命名空间未删除，删除.</p><h4 id="22-Hyphen-can-be-replaced-with-dash"><a href="#22-Hyphen-can-be-replaced-with-dash" class="headerlink" title="22. Hyphen can be replaced with dash"></a>22. Hyphen can be replaced with dash</h4><p>Replace “-“ with an “en dash” character (–, –)<br> 为了符合人性化的开发，建议直接添加规则忽略</p><h4 id="23-H-Ellipsis-string-can-be-replaced-with-ellipsis-character"><a href="#23-H-Ellipsis-string-can-be-replaced-with-ellipsis-character" class="headerlink" title="23. H Ellipsis string can be replaced with ellipsis character"></a>23. H Ellipsis string can be replaced with ellipsis character</h4><p>处理同上</p><h4 id="24-Duplicated-icons-under-different-names"><a href="#24-Duplicated-icons-under-different-names" class="headerlink" title="24. Duplicated icons under different names"></a>24. Duplicated icons under different names</h4><p>存在不同命名的同文件的icons<br> 目前的处理是添加规则忽略</p><h4 id="25-Missing-accessibility-label"><a href="#25-Missing-accessibility-label" class="headerlink" title="25. Missing accessibility label"></a>25. Missing accessibility label</h4><p>对EditTextView的使用，建议添加一个它的标签View<br> 根据需要进行忽略  或者添加android:labelfor</p><h4 id="26-Keyboard-inaccessible-widget"><a href="#26-Keyboard-inaccessible-widget" class="headerlink" title="26. Keyboard inaccessible widget"></a>26. Keyboard inaccessible widget</h4><p>一个控件（比如图片），如果没有定义focusable(可聚焦的)，却定义了是clickable（可点击的），那么是不能通过键盘访问的。所以，需要添加一个focusable=“true”;相当于指定可获取焦点.</p><h4 id="27-Usage-of-showAsAction-always"><a href="#27-Usage-of-showAsAction-always" class="headerlink" title="27. Usage of showAsAction=always"></a>27. Usage of showAsAction=always</h4><p>建议使用”ifRoom”替换”always”<br> 根据需求进行修改或者忽略</p><h4 id="28-Missing-inputType"><a href="#28-Missing-inputType" class="headerlink" title="28. Missing inputType"></a>28. Missing inputType</h4><p>This text field does not specify an inputType<br> 建议为EditText指定inputType属性</p><h4 id="29-Overdraw-Painting-regions-more-than-once"><a href="#29-Overdraw-Painting-regions-more-than-once" class="headerlink" title="29. Overdraw: Painting regions more than once"></a>29. Overdraw: Painting regions more than once</h4><p>Possible overdraw: Root element paints background @color/actionbar_color with a theme that also paints a background (inferred theme is @style/ActionTheme_NoTitle)<br> 存在过度绘制的可能性<br> 但是这个报警有点牵强，所以还是先添加规则给过滤吧</p><h4 id="30-Hardware-Id-Usage"><a href="#30-Hardware-Id-Usage" class="headerlink" title="30. Hardware Id Usage"></a>30. Hardware Id Usage</h4><p>获取设备相关信息，可以查看官方API,使用其替换方法</p><h4 id="31-Incompatible-Gradle-Versions"><a href="#31-Incompatible-Gradle-Versions" class="headerlink" title="31. Incompatible Gradle Versions"></a>31. Incompatible Gradle Versions</h4><p>不兼容依赖版本库，可通过打依赖树，进行查找</p><h4 id="贴出常见的lint-issueid和秒速，以供对照"><a href="#贴出常见的lint-issueid和秒速，以供对照" class="headerlink" title="贴出常见的lint issueid和秒速，以供对照"></a>贴出常见的lint issueid和秒速，以供对照</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"ContentDescription"</span>: Image without contentDescription</span><br><span class="line"><span class="string">"AddJavascriptInterface"</span>: addJavascriptInterface Called</span><br><span class="line"><span class="string">"ShortAlarm"</span>: Short <span class="keyword">or</span> Frequent Alarm</span><br><span class="line"><span class="string">"AllCaps"</span>: Combining textAllCaps <span class="keyword">and</span> markup</span><br><span class="line"><span class="string">"AllowAllHostnameVerifier"</span>: Insecure HostnameVerifier</span><br><span class="line"><span class="string">"AlwaysShowAction"</span>: Usage of showAsAction=always</span><br><span class="line"><span class="string">"InvalidUsesTagAttribute"</span>: Invalid <span class="keyword">name</span> attribute <span class="keyword">for</span> uses element.</span><br><span class="line"><span class="string">"MissingIntentFilterForMediaSearch"</span>: Missing intent-filter with action</span><br><span class="line">      android.media.action.MEDIA_PLAY_FROM_SEARCH</span><br><span class="line"><span class="string">"MissingMediaBrowserServiceIntentFilter"</span>: Missing intent-filter with action</span><br><span class="line">      android.media.browse.MediaBrowserService.</span><br><span class="line"><span class="string">"MissingOnPlayFromSearch"</span>: Missing onPlayFromSearch.</span><br><span class="line"><span class="string">"ImpliedTouchscreenHardware"</span>: Hardware feature touchscreen <span class="keyword">not</span> explicitly</span><br><span class="line">      marked as optional</span><br><span class="line"><span class="string">"MissingTvBanner"</span>: TV Missing Banner</span><br><span class="line"><span class="string">"MissingLeanbackLauncher"</span>: Missing Leanback Launcher Intent Filter.</span><br><span class="line"><span class="string">"MissingLeanbackSupport"</span>: Missing Leanback Support.</span><br><span class="line"><span class="string">"PermissionImpliesUnsupportedHardware"</span>: Permission Implies Unsupported</span><br><span class="line">      Hardware</span><br><span class="line"><span class="string">"UnsupportedTvHardware"</span>: Unsupported TV Hardware Feature</span><br><span class="line"><span class="string">"SupportAnnotationUsage"</span>: Incorrect support annotation usage</span><br><span class="line"><span class="string">"ShiftFlags"</span>: Dangerous Flag Constant Declaration</span><br><span class="line"><span class="string">"LocalSuppress"</span>: @SuppressLint <span class="keyword">on</span> invalid element</span><br><span class="line"><span class="string">"SwitchIntDef"</span>: Missing @IntDef in Switch</span><br><span class="line"><span class="string">"UniqueConstants"</span>: Overlapping Enumeration Constants</span><br><span class="line"><span class="string">"InlinedApi"</span>: <span class="keyword">Using</span> inlined constants <span class="keyword">on</span> older versions</span><br><span class="line"><span class="string">"Override"</span>: Method conflicts with <span class="keyword">new</span> inherited method</span><br><span class="line"><span class="string">"ObsoleteSdkInt"</span>: Obsolete SDK_INT Version Check</span><br><span class="line"><span class="string">"NewApi"</span>: Calling <span class="keyword">new</span> methods <span class="keyword">on</span> older versions</span><br><span class="line"><span class="string">"UnusedAttribute"</span>: Attribute unused <span class="keyword">on</span> older versions</span><br><span class="line"><span class="string">"AppCompatMethod"</span>: <span class="keyword">Using</span> Wrong AppCompat Method</span><br><span class="line"><span class="string">"AppCompatCustomView"</span>: Appcompat Custom Widgets</span><br><span class="line"><span class="string">"AppCompatResource"</span>: Menu namespace</span><br><span class="line"><span class="string">"GoogleAppIndexingApiWarning"</span>: Missing support <span class="keyword">for</span> Firebase App Indexing Api</span><br><span class="line"><span class="string">"GoogleAppIndexingWarning"</span>: Missing support <span class="keyword">for</span> Firebase App Indexing</span><br><span class="line"><span class="string">"AppLinksAutoVerifyError"</span>: App Links <span class="keyword">Auto</span> Verification Failure</span><br><span class="line"><span class="string">"AppLinksAutoVerifyWarning"</span>: Potential App Links <span class="keyword">Auto</span> Verification Failure</span><br><span class="line"><span class="string">"AppLinkUrlError"</span>: URL <span class="keyword">not</span> supported by app <span class="keyword">for</span> Firebase App Indexing</span><br><span class="line"><span class="string">"TestAppLink"</span>: Unmatched URLs</span><br><span class="line"><span class="string">"InconsistentArrays"</span>: Inconsistencies in array element counts</span><br><span class="line"><span class="string">"Assert"</span>: Assertions</span><br><span class="line"><span class="string">"BadHostnameVerifier"</span>: Insecure HostnameVerifier</span><br><span class="line"><span class="string">"BatteryLife"</span>: Battery Life Issues</span><br><span class="line"><span class="string">"BackButton"</span>: Back button</span><br><span class="line"><span class="string">"ButtonCase"</span>: Cancel/OK dialog button capitalization</span><br><span class="line"><span class="string">"ButtonOrder"</span>: Button order</span><br><span class="line"><span class="string">"ButtonStyle"</span>: Button should be borderless</span><br><span class="line"><span class="string">"ByteOrderMark"</span>: Byte order mark inside <span class="keyword">files</span></span><br><span class="line"><span class="string">"MissingSuperCall"</span>: Missing Super <span class="keyword">Call</span></span><br><span class="line"><span class="string">"AdapterViewChildren"</span>: AdapterViews cannot have children in XML</span><br><span class="line"><span class="string">"ScrollViewCount"</span>: ScrollViews can have only one child</span><br><span class="line"><span class="string">"PermissionImpliesUnsupportedChromeOsHardware"</span>: Permission Implies Unsupported</span><br><span class="line">      Chrome OS Hardware</span><br><span class="line"><span class="string">"UnsupportedChromeOsHardware"</span>: Unsupported Chrome OS Hardware Feature</span><br><span class="line"><span class="string">"GetInstance"</span>: Cipher.getInstance with ECB</span><br><span class="line"><span class="string">"CommitTransaction"</span>: Missing commit() <span class="keyword">calls</span></span><br><span class="line"><span class="string">"Recycle"</span>: Missing recycle() <span class="keyword">calls</span></span><br><span class="line"><span class="string">"CommitPrefEdits"</span>: Missing commit() <span class="keyword">on</span> SharedPreference editor</span><br><span class="line"><span class="string">"ApplySharedPref"</span>: Use apply() <span class="keyword">on</span> SharedPreferences</span><br><span class="line"><span class="string">"ClickableViewAccessibility"</span>: Accessibility in Custom Views</span><br><span class="line"><span class="string">"EasterEgg"</span>: Code contains easter egg</span><br><span class="line"><span class="string">"StopShip"</span>: Code contains STOPSHIP marker</span><br><span class="line"><span class="string">"MissingConstraints"</span>: Missing Constraints in ConstraintLayout</span><br><span class="line"><span class="string">"VulnerableCordovaVersion"</span>: Vulnerable Cordova Version</span><br><span class="line"><span class="string">"CustomViewStyleable"</span>: Mismatched Styleable/Custom <span class="keyword">View</span> <span class="keyword">Name</span></span><br><span class="line"><span class="string">"CutPasteId"</span>: Likely cut &amp; paste mistakes</span><br><span class="line"><span class="string">"SimpleDateFormat"</span>: Implied locale in date format</span><br><span class="line"><span class="string">"SetTextI18n"</span>: TextView Internationalization</span><br><span class="line"><span class="string">"Deprecated"</span>: <span class="keyword">Using</span> deprecated resources</span><br><span class="line"><span class="string">"MissingPrefix"</span>: Missing Android XML namespace</span><br><span class="line"><span class="string">"MangledCRLF"</span>: Mangled file <span class="keyword">line</span> endings</span><br><span class="line"><span class="string">"DuplicateIncludedIds"</span>: Duplicate ids across layouts combined with include</span><br><span class="line">      tags</span><br><span class="line"><span class="string">"DuplicateIds"</span>: Duplicate ids within a single layout</span><br><span class="line"><span class="string">"DuplicateDefinition"</span>: Duplicate definitions of resources</span><br><span class="line"><span class="string">"ReferenceType"</span>: Incorrect reference types</span><br><span class="line"><span class="string">"StringEscaping"</span>: Invalid string escapes</span><br><span class="line"><span class="string">"UnpackedNativeCode"</span>: Missing android:extractNativeLibs=false</span><br><span class="line"><span class="string">"UnsafeDynamicallyLoadedCode"</span>: <span class="keyword">load</span> used <span class="keyword">to</span> dynamically <span class="keyword">load</span> code</span><br><span class="line"><span class="string">"UnsafeNativeCodeLocation"</span>: Native code outside library directory</span><br><span class="line"><span class="string">"EllipsizeMaxLines"</span>: Combining Ellipsize <span class="keyword">and</span> Maxlines</span><br><span class="line"><span class="string">"ExifInterface"</span>: <span class="keyword">Using</span> android.media.ExifInterface</span><br><span class="line"><span class="string">"ExtraText"</span>: Extraneous text in resource <span class="keyword">files</span></span><br><span class="line"><span class="string">"FieldGetter"</span>: <span class="keyword">Using</span> getter instead of <span class="keyword">field</span></span><br><span class="line"><span class="string">"InvalidAnalyticsName"</span>: Invalid Analytics <span class="keyword">Name</span></span><br><span class="line"><span class="string">"MissingFirebaseInstanceTokenRefresh"</span>: Missing Firebase Instance ID Token</span><br><span class="line">      Refresh</span><br><span class="line"><span class="string">"FontValidationError"</span>: Validation of font <span class="keyword">files</span></span><br><span class="line"><span class="string">"FontValidationWarning"</span>: Validation of font <span class="keyword">files</span></span><br><span class="line"><span class="string">"FullBackupContent"</span>: Valid Full Backup Content File</span><br><span class="line"><span class="string">"ValidFragment"</span>: Fragment <span class="keyword">not</span> instantiatable</span><br><span class="line"><span class="string">"GetContentDescriptionOverride"</span>: Overriding getContentDescription() <span class="keyword">on</span> a <span class="keyword">View</span></span><br><span class="line"><span class="string">"PackageManagerGetSignatures"</span>: Potential Multiple Certificate Exploit</span><br><span class="line"><span class="string">"AccidentalOctal"</span>: Accidental Octal</span><br><span class="line"><span class="string">"UseOfBundledGooglePlayServices"</span>: Use of bundled version of Google <span class="keyword">Play</span></span><br><span class="line">      services</span><br><span class="line"><span class="string">"GradleCompatible"</span>: Incompatible Gradle Versions</span><br><span class="line"><span class="string">"GradleDependency"</span>: Obsolete Gradle Dependency</span><br><span class="line"><span class="string">"GradleDeprecated"</span>: Deprecated Gradle Construct</span><br><span class="line"><span class="string">"DevModeObsolete"</span>: Dev Mode Obsolete</span><br><span class="line"><span class="string">"DuplicatePlatformClasses"</span>: Duplicate Platform Classes</span><br><span class="line"><span class="string">"GradleGetter"</span>: Gradle Implicit Getter <span class="keyword">Call</span></span><br><span class="line"><span class="string">"GradlePluginVersion"</span>: Incompatible Android Gradle Plugin</span><br><span class="line"><span class="string">"HighAppVersionCode"</span>: VersionCode too high</span><br><span class="line"><span class="string">"GradleIdeError"</span>: Gradle IDE Support Issues</span><br><span class="line"><span class="string">"GradlePath"</span>: Gradle Path Issues</span><br><span class="line"><span class="string">"GradleDynamicVersion"</span>: Gradle Dynamic Version</span><br><span class="line"><span class="string">"NotInterpolated"</span>: Incorrect Interpolation</span><br><span class="line"><span class="string">"StringShouldBeInt"</span>: String should be <span class="keyword">int</span></span><br><span class="line"><span class="string">"NewerVersionAvailable"</span>: Newer Library Versions Available</span><br><span class="line"><span class="string">"MinSdkTooLow"</span>: API Version Too Low</span><br><span class="line"><span class="string">"GridLayout"</span>: GridLayout validation</span><br><span class="line"><span class="string">"HandlerLeak"</span>: Handler reference leaks</span><br><span class="line"><span class="string">"HardcodedDebugMode"</span>: Hardcoded value of android:debuggable in the manifest</span><br><span class="line"><span class="string">"HardcodedText"</span>: Hardcoded text</span><br><span class="line"><span class="string">"HardwareIds"</span>: Hardware Id Usage</span><br><span class="line"><span class="string">"IconDuplicatesConfig"</span>: Identical bitmaps across various configurations</span><br><span class="line"><span class="string">"IconDuplicates"</span>: Duplicated icons under different names</span><br><span class="line"><span class="string">"GifUsage"</span>: <span class="keyword">Using</span> .gif format <span class="keyword">for</span> bitmaps is discouraged</span><br><span class="line"><span class="string">"IconColors"</span>: Icon colors do <span class="keyword">not</span> follow the recommended visual style</span><br><span class="line"><span class="string">"IconDensities"</span>: Icon densities validation</span><br><span class="line"><span class="string">"IconDipSize"</span>: Icon density-independent size validation</span><br><span class="line"><span class="string">"IconExpectedSize"</span>: Icon has incorrect size</span><br><span class="line"><span class="string">"IconExtension"</span>: Icon format does <span class="keyword">not</span> match the file extension</span><br><span class="line"><span class="string">"IconLauncherShape"</span>: The launcher icon shape should use a distinct silhouette</span><br><span class="line"><span class="string">"IconLocation"</span>: Image defined in density-independent drawable folder</span><br><span class="line"><span class="string">"IconMissingDensityFolder"</span>: Missing density folder</span><br><span class="line"><span class="string">"IconMixedNinePatch"</span>: Clashing PNG <span class="keyword">and</span> <span class="number">9</span>-PNG <span class="keyword">files</span></span><br><span class="line"><span class="string">"IconNoDpi"</span>: Icon appears in both -nodpi <span class="keyword">and</span> dpi folders</span><br><span class="line"><span class="string">"IconXmlAndPng"</span>: Icon is specified both as .xml file <span class="keyword">and</span> as a bitmap</span><br><span class="line"><span class="string">"ConvertToWebp"</span>: Convert <span class="keyword">to</span> WebP</span><br><span class="line"><span class="string">"WebpUnsupported"</span>: WebP Unsupported</span><br><span class="line"><span class="string">"IncludeLayoutParam"</span>: Ignored layout params <span class="keyword">on</span> include</span><br><span class="line"><span class="string">"DisableBaselineAlignment"</span>: Missing baselineAligned attribute</span><br><span class="line"><span class="string">"InefficientWeight"</span>: Inefficient layout weight</span><br><span class="line"><span class="string">"NestedWeights"</span>: Nested layout weights</span><br><span class="line"><span class="string">"Orientation"</span>: Missing explicit orientation</span><br><span class="line"><span class="string">"Suspicious0dp"</span>: Suspicious <span class="number">0d</span>p dimension</span><br><span class="line"><span class="string">"InstantApps"</span>: Instant App Issues</span><br><span class="line"><span class="string">"DuplicateDivider"</span>: Unnecessary Divider Copy</span><br><span class="line"><span class="string">"TrustAllX509TrustManager"</span>: Insecure TLS/SSL trust manager</span><br><span class="line"><span class="string">"InvalidImeActionId"</span>: Invalid imeActionId declaration</span><br><span class="line"><span class="string">"InvalidPackage"</span>: Package <span class="keyword">not</span> included in Android</span><br><span class="line"><span class="string">"DrawAllocation"</span>: Memory allocations within drawing code</span><br><span class="line"><span class="string">"UseSparseArrays"</span>: HashMap can be replaced with SparseArray</span><br><span class="line"><span class="string">"UseValueOf"</span>: Should use valueOf instead of <span class="keyword">new</span></span><br><span class="line"><span class="string">"JavascriptInterface"</span>: Missing @JavascriptInterface <span class="keyword">on</span> methods</span><br><span class="line"><span class="string">"JobSchedulerService"</span>: JobScheduler problems</span><br><span class="line"><span class="string">"KeyboardInaccessibleWidget"</span>: Keyboard inaccessible widget</span><br><span class="line"><span class="string">"LabelFor"</span>: Missing labelFor attribute</span><br><span class="line"><span class="string">"InconsistentLayout"</span>: Inconsistent Layouts</span><br><span class="line"><span class="string">"InflateParams"</span>: Layout Inflation without a Parent</span><br><span class="line"><span class="string">"StaticFieldLeak"</span>: Static <span class="keyword">Field</span> Leaks</span><br><span class="line"><span class="string">"DefaultLocale"</span>: Implied default locale in case conversion</span><br><span class="line"><span class="string">"LocaleFolder"</span>: Wrong locale <span class="keyword">name</span></span><br><span class="line"><span class="string">"GetLocales"</span>: Locale crash</span><br><span class="line"><span class="string">"InvalidResourceFolder"</span>: Invalid Resource Folder</span><br><span class="line"><span class="string">"WrongRegion"</span>: Suspicious Language/Region Combination</span><br><span class="line"><span class="string">"UseAlpha2"</span>: <span class="keyword">Using</span> <span class="number">3</span>-letter Codes</span><br><span class="line"><span class="string">"LogConditional"</span>: Unconditional Logging <span class="keyword">Calls</span></span><br><span class="line"><span class="string">"LongLogTag"</span>: Too Long <span class="keyword">Log</span> Tags</span><br><span class="line"><span class="string">"LogTagMismatch"</span>: Mismatched <span class="keyword">Log</span> Tags</span><br><span class="line"><span class="string">"AllowBackup"</span>: AllowBackup/FullBackupContent Problems</span><br><span class="line"><span class="string">"MissingApplicationIcon"</span>: Missing application icon</span><br><span class="line"><span class="string">"DeviceAdmin"</span>: Malformed Device Admin</span><br><span class="line"><span class="string">"DuplicateActivity"</span>: Activity registered more than once</span><br><span class="line"><span class="string">"DuplicateUsesFeature"</span>: Feature declared more than once</span><br><span class="line"><span class="string">"GradleOverrides"</span>: Value overridden by Gradle build script</span><br><span class="line"><span class="string">"IllegalResourceRef"</span>: <span class="keyword">Name</span> <span class="keyword">and</span> version must be integer <span class="keyword">or</span> string, <span class="keyword">not</span></span><br><span class="line">      resource</span><br><span class="line"><span class="string">"MipmapIcons"</span>: Use Mipmap Launcher Icons</span><br><span class="line"><span class="string">"MockLocation"</span>: <span class="keyword">Using</span> mock location provider in production</span><br><span class="line"><span class="string">"MultipleUsesSdk"</span>: Multiple &lt;uses-sdk&gt; elements in the manifest</span><br><span class="line"><span class="string">"ManifestOrder"</span>: Incorrect order of elements in manifest</span><br><span class="line"><span class="string">"MissingVersion"</span>: Missing application <span class="keyword">name</span>/version</span><br><span class="line"><span class="string">"OldTargetApi"</span>: Target SDK attribute is <span class="keyword">not</span> targeting latest version</span><br><span class="line"><span class="string">"UniquePermission"</span>: Permission names are <span class="keyword">not</span> unique</span><br><span class="line"><span class="string">"UsesMinSdkAttributes"</span>: Minimum SDK <span class="keyword">and</span> target SDK attributes <span class="keyword">not</span> defined</span><br><span class="line"><span class="string">"WearableBindListener"</span>: Usage of Android Wear BIND_LISTENER is deprecated</span><br><span class="line"><span class="string">"WrongManifestParent"</span>: Wrong manifest parent</span><br><span class="line"><span class="string">"InvalidPermission"</span>: Invalid Permission Attribute</span><br><span class="line"><span class="string">"ManifestResource"</span>: Manifest Resource References</span><br><span class="line"><span class="string">"ManifestTypo"</span>: Typos in manifest tags</span><br><span class="line"><span class="string">"FloatMath"</span>: <span class="keyword">Using</span> FloatMath instead of Math</span><br><span class="line"><span class="string">"MergeMarker"</span>: Code contains <span class="keyword">merge</span> marker</span><br><span class="line"><span class="string">"MergeRootFrame"</span>: FrameLayout can be replaced with &lt;<span class="keyword">merge</span>&gt; tag</span><br><span class="line"><span class="string">"IncompatibleMediaBrowserServiceCompatVersion"</span>: Obsolete version of</span><br><span class="line">      MediaBrowserServiceCompat</span><br><span class="line"><span class="string">"InnerclassSeparator"</span>: Inner classes should use $ rather than .</span><br><span class="line"><span class="string">"Instantiatable"</span>: Registered class is <span class="keyword">not</span> instantiatable</span><br><span class="line"><span class="string">"MissingRegistered"</span>: Missing registered class</span><br><span class="line"><span class="string">"MissingId"</span>: Fragments should specify an id <span class="keyword">or</span> tag</span><br><span class="line"><span class="string">"LibraryCustomView"</span>: Custom views in libraries should use res-<span class="keyword">auto</span>-namespace</span><br><span class="line"><span class="string">"ResAuto"</span>: Hardcoded Package in Namespace</span><br><span class="line"><span class="string">"NamespaceTypo"</span>: Misspelled namespace declaration</span><br><span class="line"><span class="string">"UnusedNamespace"</span>: Unused namespace</span><br><span class="line"><span class="string">"NegativeMargin"</span>: Negative Margins</span><br><span class="line"><span class="string">"NestedScrolling"</span>: Nested scrolling widgets</span><br><span class="line"><span class="string">"NetworkSecurityConfig"</span>: Valid Network Security Config File</span><br><span class="line"><span class="string">"MissingBackupPin"</span>: Missing Backup Pin</span><br><span class="line"><span class="string">"PinSetExpiry"</span>: Validate &lt;pin-set&gt; expiration attribute</span><br><span class="line"><span class="string">"NfcTechWhitespace"</span>: Whitespace in NFC tech lists</span><br><span class="line"><span class="string">"UnlocalizedSms"</span>: SMS phone number missing country code</span><br><span class="line"><span class="string">"ObjectAnimatorBinding"</span>: Incorrect ObjectAnimator Property</span><br><span class="line"><span class="string">"AnimatorKeep"</span>: Missing @Keep <span class="keyword">for</span> Animated Properties</span><br><span class="line"><span class="string">"ObsoleteLayoutParam"</span>: Obsolete layout params</span><br><span class="line"><span class="string">"OnClick"</span>: onClick method does <span class="keyword">not</span> exist</span><br><span class="line"><span class="string">"Overdraw"</span>: Overdraw: Painting regions more than once</span><br><span class="line"><span class="string">"DalvikOverride"</span>: Method considered overridden by Dalvik</span><br><span class="line"><span class="string">"OverrideAbstract"</span>: <span class="keyword">Not</span> overriding abstract methods <span class="keyword">on</span> older platforms</span><br><span class="line"><span class="string">"ParcelCreator"</span>: Missing Parcelable CREATOR <span class="keyword">field</span></span><br><span class="line"><span class="string">"UnusedQuantity"</span>: Unused quantity translations</span><br><span class="line"><span class="string">"MissingQuantity"</span>: Missing quantity translation</span><br><span class="line"><span class="string">"ImpliedQuantity"</span>: Implied Quantities</span><br><span class="line"><span class="string">"ExportedPreferenceActivity"</span>: PreferenceActivity should <span class="keyword">not</span> be exported</span><br><span class="line"><span class="string">"PrivateApi"</span>: <span class="keyword">Using</span> Private APIs</span><br><span class="line"><span class="string">"PackagedPrivateKey"</span>: Packaged private <span class="keyword">key</span></span><br><span class="line"><span class="string">"PrivateResource"</span>: <span class="keyword">Using</span> private resources</span><br><span class="line"><span class="string">"ProguardSplit"</span>: Proguard.cfg file contains generic Android rules</span><br><span class="line"><span class="string">"Proguard"</span>: <span class="keyword">Using</span> obsolete ProGuard configuration</span><br><span class="line"><span class="string">"PropertyEscape"</span>: Incorrect property escapes</span><br><span class="line"><span class="string">"UsingHttp"</span>: <span class="keyword">Using</span> HTTP instead of HTTPS</span><br><span class="line"><span class="string">"SpUsage"</span>: <span class="keyword">Using</span> dp instead of sp <span class="keyword">for</span> text sizes</span><br><span class="line"><span class="string">"InOrMmUsage"</span>: <span class="keyword">Using</span> mm <span class="keyword">or</span> in dimensions</span><br><span class="line"><span class="string">"PxUsage"</span>: <span class="keyword">Using</span> <span class="comment">'px' dimension</span></span><br><span class="line"><span class="string">"SmallSp"</span>: Text size is too small</span><br><span class="line"><span class="string">"ParcelClassLoader"</span>: Default Parcel Class Loader</span><br><span class="line"><span class="string">"PendingBindings"</span>: Missing Pending Bindings</span><br><span class="line"><span class="string">"RecyclerView"</span>: RecyclerView Problems</span><br><span class="line"><span class="string">"Registered"</span>: Class is <span class="keyword">not</span> registered in the manifest</span><br><span class="line"><span class="string">"RelativeOverlap"</span>: Overlapping items in RelativeLayout</span><br><span class="line"><span class="string">"RequiredSize"</span>: Missing layout_width <span class="keyword">or</span> layout_height attributes</span><br><span class="line"><span class="string">"AaptCrash"</span>: Potential AAPT crash</span><br><span class="line"><span class="string">"ResourceCycle"</span>: Cycle in resource definitions</span><br><span class="line"><span class="string">"ResourceName"</span>: Resource with Wrong Prefix</span><br><span class="line"><span class="string">"ValidRestrictions"</span>: Invalid Restrictions Descriptor</span><br><span class="line"><span class="string">"RtlCompat"</span>: Right-<span class="keyword">to</span>-left text compatibility issues</span><br><span class="line"><span class="string">"RtlEnabled"</span>: <span class="keyword">Using</span> RTL attributes without enabling RTL support</span><br><span class="line"><span class="string">"RtlSymmetry"</span>: Padding <span class="keyword">and</span> margin symmetry</span><br><span class="line"><span class="string">"RtlHardcoded"</span>: <span class="keyword">Using</span> left/right instead of start/<span class="keyword">end</span> attributes</span><br><span class="line"><span class="string">"ScrollViewSize"</span>: ScrollView size validation</span><br><span class="line"><span class="string">"SdCardPath"</span>: Hardcoded reference <span class="keyword">to</span> /sdcard</span><br><span class="line"><span class="string">"SecureRandom"</span>: <span class="keyword">Using</span> a fixed seed with SecureRandom</span><br><span class="line"><span class="string">"TrulyRandom"</span>: Weak RNG</span><br><span class="line"><span class="string">"ExportedContentProvider"</span>: Content provider does <span class="keyword">not</span> require permission</span><br><span class="line"><span class="string">"ExportedReceiver"</span>: Receiver does <span class="keyword">not</span> require permission</span><br><span class="line"><span class="string">"ExportedService"</span>: Exported service does <span class="keyword">not</span> require permission</span><br><span class="line"><span class="string">"SetWorldReadable"</span>: File.setReadable() used <span class="keyword">to</span> make file world-readable</span><br><span class="line"><span class="string">"SetWorldWritable"</span>: File.setWritable() used <span class="keyword">to</span> make file world-writable</span><br><span class="line"><span class="string">"GrantAllUris"</span>: Content provider shares everything</span><br><span class="line"><span class="string">"WorldReadableFiles"</span>: openFileOutput() <span class="keyword">or</span> similar <span class="keyword">call</span> passing</span><br><span class="line">      MODE_WORLD_READABLE</span><br><span class="line"><span class="string">"WorldWriteableFiles"</span>: openFileOutput() <span class="keyword">or</span> similar <span class="keyword">call</span> passing</span><br><span class="line">      MODE_WORLD_WRITEABLE</span><br><span class="line"><span class="string">"ServiceCast"</span>: Wrong <span class="keyword">system</span> service casts</span><br><span class="line"><span class="string">"WifiManagerLeak"</span>: WifiManager Leak</span><br><span class="line"><span class="string">"WifiManagerPotentialLeak"</span>: WifiManager Potential Leak</span><br><span class="line"><span class="string">"SetJavaScriptEnabled"</span>: <span class="keyword">Using</span> setJavaScriptEnabled</span><br><span class="line"><span class="string">"SignatureOrSystemPermissions"</span>: signatureOrSystem permissions declared</span><br><span class="line"><span class="string">"SQLiteString"</span>: <span class="keyword">Using</span> STRING instead of TEXT</span><br><span class="line"><span class="string">"SSLCertificateSocketFactoryCreateSocket"</span>: Insecure <span class="keyword">call</span> <span class="keyword">to</span></span><br><span class="line">      SSLCertificateSocketFactory.createSocket()</span><br><span class="line"><span class="string">"SSLCertificateSocketFactoryGetInsecure"</span>: <span class="keyword">Call</span> <span class="keyword">to</span></span><br><span class="line">      SSLCertificateSocketFactory.getInsecure()</span><br><span class="line"><span class="string">"StateListReachable"</span>: Unreachable state in a &lt;selector&gt;</span><br><span class="line"><span class="string">"AuthLeak"</span>: Code might contain an auth leak</span><br><span class="line"><span class="string">"StringFormatCount"</span>: Formatting argument types incomplete <span class="keyword">or</span> inconsistent</span><br><span class="line"><span class="string">"StringFormatMatches"</span>: <span class="string">"String.format string doesn't match the XML format</span></span><br><span class="line"><span class="string">      string"</span></span><br><span class="line"><span class="string">"StringFormatInvalid"</span>: Invalid format string</span><br><span class="line"><span class="string">"PluralsCandidate"</span>: Potential Plurals</span><br><span class="line"><span class="string">"UseCheckPermission"</span>: <span class="keyword">Using</span> the result of check permission <span class="keyword">calls</span></span><br><span class="line"><span class="string">"CheckResult"</span>: Ignoring results</span><br><span class="line"><span class="string">"ResourceAsColor"</span>: Should pass resolved <span class="keyword">color</span> instead of resource id</span><br><span class="line"><span class="string">"MissingPermission"</span>: Missing Permissions</span><br><span class="line"><span class="string">"Range"</span>: Outside Range</span><br><span class="line"><span class="string">"ResourceType"</span>: Wrong Resource Type</span><br><span class="line"><span class="string">"RestrictedApi"</span>: Restricted API</span><br><span class="line"><span class="string">"WrongThread"</span>: Wrong Thread</span><br><span class="line"><span class="string">"WrongConstant"</span>: Incorrect constant</span><br><span class="line"><span class="string">"VisibleForTests"</span>: Visible Only <span class="keyword">For</span> Tests</span><br><span class="line"><span class="string">"ProtectedPermissions"</span>: <span class="keyword">Using</span> <span class="keyword">system</span> app permission</span><br><span class="line"><span class="string">"TextFields"</span>: Missing inputType <span class="keyword">or</span> hint</span><br><span class="line"><span class="string">"TextViewEdits"</span>: TextView should probably be an EditText instead</span><br><span class="line"><span class="string">"SelectableText"</span>: Dynamic text should probably be selectable</span><br><span class="line"><span class="string">"MenuTitle"</span>: Missing menu title</span><br><span class="line"><span class="string">"ShowToast"</span>: Toast created but <span class="keyword">not</span> shown</span><br><span class="line"><span class="string">"TooDeepLayout"</span>: Layout hierarchy is too deep</span><br><span class="line"><span class="string">"TooManyViews"</span>: Layout has too many views</span><br><span class="line"><span class="string">"ExtraTranslation"</span>: Extra translation</span><br><span class="line"><span class="string">"MissingTranslation"</span>: Incomplete translation</span><br><span class="line"><span class="string">"Typos"</span>: Spelling <span class="keyword">error</span></span><br><span class="line"><span class="string">"TypographyDashes"</span>: Hyphen can be replaced with dash</span><br><span class="line"><span class="string">"TypographyEllipsis"</span>: Ellipsis string can be replaced with ellipsis character</span><br><span class="line"><span class="string">"TypographyFractions"</span>: Fraction string can be replaced with fraction</span><br><span class="line">      character</span><br><span class="line"><span class="string">"TypographyOther"</span>: Other typographical problems</span><br><span class="line"><span class="string">"TypographyQuotes"</span>: Straight quotes can be replaced with curvy quotes</span><br><span class="line"><span class="string">"UnsafeProtectedBroadcastReceiver"</span>: Unsafe Protected BroadcastReceiver</span><br><span class="line"><span class="string">"UnprotectedSMSBroadcastReceiver"</span>: Unprotected SMS BroadcastReceiver</span><br><span class="line"><span class="string">"UnusedResources"</span>: Unused resources</span><br><span class="line"><span class="string">"UnusedIds"</span>: Unused id</span><br><span class="line"><span class="string">"UseCompoundDrawables"</span>: Node can be replaced by a TextView with compound</span><br><span class="line">      drawables</span><br><span class="line"><span class="string">"UselessLeaf"</span>: Useless leaf layout</span><br><span class="line"><span class="string">"UselessParent"</span>: Useless parent layout</span><br><span class="line"><span class="string">"EnforceUTF8"</span>: Encoding used in resource <span class="keyword">files</span> is <span class="keyword">not</span> UTF-<span class="number">8</span></span><br><span class="line"><span class="string">"VectorRaster"</span>: Vector Image Generation</span><br><span class="line"><span class="string">"VectorDrawableCompat"</span>: <span class="keyword">Using</span> VectorDrawableCompat</span><br><span class="line"><span class="string">"VectorPath"</span>: Long vector paths</span><br><span class="line"><span class="string">"InvalidVectorPath"</span>: Invalid vector paths</span><br><span class="line"><span class="string">"ViewConstructor"</span>: Missing <span class="keyword">View</span> constructors <span class="keyword">for</span> XML inflation</span><br><span class="line"><span class="string">"ViewHolder"</span>: <span class="keyword">View</span> Holder Candidates</span><br><span class="line"><span class="string">"ViewTag"</span>: Tagged object leaks</span><br><span class="line"><span class="string">"WrongViewCast"</span>: Mismatched <span class="keyword">view</span> type</span><br><span class="line"><span class="string">"FindViewByIdCast"</span>: Add Explicit Cast</span><br><span class="line"><span class="string">"Wakelock"</span>: Incorrect WakeLock usage</span><br><span class="line"><span class="string">"WakelockTimeout"</span>: <span class="keyword">Using</span> wakeLock without timeout</span><br><span class="line"><span class="string">"InvalidWearFeatureAttribute"</span>: Invalid attribute <span class="keyword">for</span> Wear uses-feature</span><br><span class="line"><span class="string">"WearStandaloneAppFlag"</span>: Invalid <span class="keyword">or</span> missing Wear standalone app flag</span><br><span class="line"><span class="string">"WebViewLayout"</span>: WebViews in wrap_content parents</span><br><span class="line"><span class="string">"WrongCall"</span>: <span class="keyword">Using</span> wrong <span class="keyword">draw</span>/layout method</span><br><span class="line"><span class="string">"WrongCase"</span>: Wrong case <span class="keyword">for</span> <span class="keyword">view</span> tag</span><br><span class="line"><span class="string">"InvalidId"</span>: Invalid ID declaration</span><br><span class="line"><span class="string">"NotSibling"</span>: RelativeLayout Invalid Constraints</span><br><span class="line"><span class="string">"UnknownId"</span>: Reference <span class="keyword">to</span> an unknown id</span><br><span class="line"><span class="string">"UnknownIdInLayout"</span>: Reference <span class="keyword">to</span> an id that is <span class="keyword">not</span> in the current layout</span><br><span class="line"><span class="string">"SuspiciousImport"</span>: import android.R statement</span><br><span class="line"><span class="string">"WrongFolder"</span>: Resource file in the wrong res folder</span><br><span class="line"><span class="string">"WrongThreadInterprocedural"</span>: Wrong Thread (Interprocedural)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>还有遇到一些简单代码规范的问题，平时注意，就能规避，比如常见的宽高，写成了sp、xp；总之就是sp、xp、dp使用混乱等一些规范问题，或者是内存泄漏风险.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一周做了一些关于Android静态代码检测的东西，对于一些常见的lint警告做了记录,其实对于常见的lint警告我们得处理步骤可以分为如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查看lint报错的错误类型&lt;/li&gt;
&lt;li&gt;追踪到代码处，确定是否代码自身问题&lt;/li&gt;
&lt;li&gt;分析该类错误影响范围&lt;/li&gt;
&lt;li&gt;确定解决方式(规范代码、添加注解、添加规则)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;规范代码&quot;&gt;&lt;a href=&quot;#规范代码&quot; class=&quot;headerlink&quot; title=&quot;规范代码&quot;&gt;&lt;/a&gt;规范代码&lt;/h5&gt;&lt;p&gt;一般是由于开发者在开发时，不细心造成误写等，或者是某些API过时，需要进行手动修改。&lt;/p&gt;
&lt;h4 id=&quot;添加注解&quot;&gt;&lt;a href=&quot;#添加注解&quot; class=&quot;headerlink&quot; title=&quot;添加注解&quot;&gt;&lt;/a&gt;添加注解&lt;/h4&gt;&lt;p&gt;对于某些特殊需求，可以通过加注解来避免lint报错,以下给出常见的添加注解的地方&lt;/p&gt;
&lt;h5 id=&quot;java源代码&quot;&gt;&lt;a href=&quot;#java源代码&quot; class=&quot;headerlink&quot; title=&quot;java源代码&quot;&gt;&lt;/a&gt;java源代码&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SuppressLint&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;xxxx&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// xxxx代表某种lint检测类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
      <category term="lint" scheme="https://zhangmiao.cc/tags/lint/"/>
    
  </entry>
  
  <entry>
    <title>正确的提问方式</title>
    <link href="https://zhangmiao.cc/posts/6cc70a12.html"/>
    <id>https://zhangmiao.cc/posts/6cc70a12.html</id>
    <published>2019-08-22T07:10:34.000Z</published>
    <updated>2019-08-22T07:17:08.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提问之前"><a href="#提问之前" class="headerlink" title="提问之前"></a>提问之前</h2><ol><li>你是否在谷歌/百度/论坛上搜索过？</li><li>你是否查过手册/文档？</li><li>你是否阅读过源码？</li></ol><h2 id="正确提问"><a href="#正确提问" class="headerlink" title="正确提问"></a>正确提问</h2><ol><li>你想做什么？遇到了什么问题？你做过什么？尝试过什么解决方案？结果是什么？</li><li>附上log，代码等</li></ol><p><strong>Ps：提供越多有效信息，越能得到帮助</strong></p><h2 id="错误提问"><a href="#错误提问" class="headerlink" title="错误提问"></a>错误提问</h2><ol><li>有大佬在吗？有人在吗？有人会吗？有人懂吗？</li><li>这个怎么解决？为什么会出现这个？这是怎麽回事？有没有人帮我解决这个问题？</li></ol><p><strong>Ps：大家都忙，请尊重彼此的时间</strong></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;提问之前&quot;&gt;&lt;a href=&quot;#提问之前&quot; class=&quot;headerlink&quot; title=&quot;提问之前&quot;&gt;&lt;/a&gt;提问之前&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;你是否在谷歌/百度/论坛上搜索过？&lt;/li&gt;
&lt;li&gt;你是否查过手册/文档？&lt;/li&gt;
&lt;li&gt;你是否阅读过源码？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;正确提问&quot;&gt;&lt;a href=&quot;#正确提问&quot; class=&quot;headerlink&quot; title=&quot;正确提问&quot;&gt;&lt;/a&gt;正确提问&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;你想做什么？遇到了什么问题？你做过什么？尝试过什么解决方案？结果是什么？&lt;/li&gt;
&lt;li&gt;附上log，代码等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Ps：提供越多有效信息，越能得到帮助&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;错误提问&quot;&gt;&lt;a href=&quot;#错误提问&quot; class=&quot;headerlink&quot; title=&quot;错误提问&quot;&gt;&lt;/a&gt;错误提问&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;有大佬在吗？有人在吗？有人会吗？有人懂吗？&lt;/li&gt;
&lt;li&gt;这个怎么解决？为什么会出现这个？这是怎麽回事？有没有人帮我解决这个问题？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Ps：大家都忙，请尊重彼此的时间&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>为Hexo添加CNZZ统计</title>
    <link href="https://zhangmiao.cc/posts/fb66bb1.html"/>
    <id>https://zhangmiao.cc/posts/fb66bb1.html</id>
    <published>2019-08-22T02:17:39.000Z</published>
    <updated>2019-08-22T02:28:03.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚开始弄NexT主题的时候，一直都是用不蒜子的统计，但是不蒜子统计的内容太过简单了，不能够看到其他的一些数据，最近把友盟的统计给加上了。</p><p><strong>友盟+ 传送门</strong>：<a href="https://passport.umeng.com/login?appId=cnzz" target="_blank" rel="noopener">https://passport.umeng.com/login?appId=cnzz</a></p><h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p>登录之后，选择右上角的添加站点，配置好你的站点信息</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190822102053.png" alt></p><a id="more"></a><h3 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h3><p>获取友盟提供给你的代码，友盟提供了很多的样式，随便复制一份就行。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190822102153.png" alt></p><p>在<code>\themes\next\layout\_third-party\analytics\cnzz-analytics.swig</code>中将原来的代码全部删除，复制下面的代码：<br>ps：如果没有该文件，请自行创建然后复制修改下面的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.cnzz_siteid %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 填写你的友盟代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> cnzz_protocol = ((<span class="string">"https:"</span> == <span class="built_in">document</span>.location.protocol) ? <span class="string">" https://"</span> : <span class="string">" http://"</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="built_in">unescape</span>(<span class="string">"%3Cspan id='cnzz_stat_icon_12'%3E%3C/span%3E%3Cscript </span></span></span><br><span class="line"><span class="javascript">src=<span class="string">'" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D12%2show%3Dpic'</span> </span></span><br><span class="line"><span class="javascript">type=<span class="string">'text/javascript'</span>%<span class="number">3</span>E%<span class="number">3</span>C/script%<span class="number">3</span>E<span class="string">"));</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 你的友盟代码 end --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>添加了代码之后，还需要修改next的配置文件才能够生效。注意是主题配置文件<br>打开<code>\themes\next</code>目录下的<code>_config.yml</code>，按<code>ctrl + F</code>搜索<code>CNZZ</code>,找到之后将注释的内容打开，并设置成true，注意空格</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CNZZ count</span><br><span class="line">cnzz_siteid: true</span><br></pre></td></tr></table></figure><p>这样就可以成功的使用CNZZ进行统计了。建议使用<code>hexo s</code>在本地测试，看是否有问题再部署上去。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;刚开始弄NexT主题的时候，一直都是用不蒜子的统计，但是不蒜子统计的内容太过简单了，不能够看到其他的一些数据，最近把友盟的统计给加上了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友盟+ 传送门&lt;/strong&gt;：&lt;a href=&quot;https://passport.umeng.com/login?appId=cnzz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://passport.umeng.com/login?appId=cnzz&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置站点信息&quot;&gt;&lt;a href=&quot;#配置站点信息&quot; class=&quot;headerlink&quot; title=&quot;配置站点信息&quot;&gt;&lt;/a&gt;配置站点信息&lt;/h3&gt;&lt;p&gt;登录之后，选择右上角的添加站点，配置好你的站点信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190822102053.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://zhangmiao.cc/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="Hexo" scheme="https://zhangmiao.cc/tags/Hexo/"/>
    
      <category term="建站" scheme="https://zhangmiao.cc/tags/%E5%BB%BA%E7%AB%99/"/>
    
      <category term="博客" scheme="https://zhangmiao.cc/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Mac Os，iphone，ipad绑定阿里云邮箱</title>
    <link href="https://zhangmiao.cc/posts/94899ee0.html"/>
    <id>https://zhangmiao.cc/posts/94899ee0.html</id>
    <published>2019-08-21T07:15:28.000Z</published>
    <updated>2019-08-21T07:26:22.446Z</updated>
    
    <content type="html"><![CDATA[<p>在 MacOS iPhone  iPad 上面设置可能有差别，但是关键参数如下。</p><p>以Mac OS为例，打开设置，前往互联网账户，添加其他账户，邮件账户，按自己的阿里邮箱，或者你们公司给你的以你们公司名后缀结束的邮箱（其实还是阿里邮箱），填写邮箱密码。</p><hr><p><strong>接着选择账户类型：pop</strong></p><p><strong>收件服务器：pop3.aliyun.com</strong></p><p><strong>发件服务器：smtp.aliyun.com</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821151548.png" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 MacOS iPhone  iPad 上面设置可能有差别，但是关键参数如下。&lt;/p&gt;
&lt;p&gt;以Mac OS为例，打开设置，前往互联网账户，添加其他账户，邮件账户，按自己的阿里邮箱，或者你们公司给你的以你们公司名后缀结束的邮箱（其实还是阿里邮箱），填写邮箱密码。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;接着选择账户类型：pop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收件服务器：pop3.aliyun.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发件服务器：smtp.aliyun.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821151548.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://zhangmiao.cc/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://zhangmiao.cc/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-9.0进阶指南</title>
    <link href="https://zhangmiao.cc/posts/e2baf374.html"/>
    <id>https://zhangmiao.cc/posts/e2baf374.html</id>
    <published>2019-08-21T06:25:10.000Z</published>
    <updated>2019-08-21T06:44:42.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国内从去年开始就有消息说，应用上架或者更新要求TargetSdkVersion最低要为26以上，也就是最低也要适配到8.0。今年来也都逐步地开始落实。</p><table><thead><tr><th align="center"><a href="https://link.juejin.im/?target=https%3A%2F%2Fdev.mi.com%2Fconsole%2Fdoc%2Fdetail%3FpId%3D1695" target="_blank" rel="noopener">小米应用商店公告</a></th><th align="center"><a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fdistribute%2Fbest-practices%2Fdevelop%2Ftarget-sdk%3Fhl%3Dzh-cn" target="_blank" rel="noopener">Google Play的要求</a></th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142559.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142744.png" alt></td></tr></tbody></table><p>还包括从8月份开始在Google Play上发布的应用必须支持64位架构。可以看到适配工作真的不能像以前一样随心所欲了。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>进入正题，首先将我们项目中的<code>targetSdkVersion</code>改为 28。接下来运行你的项目，看有没中枪。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="Http请求失败"><a href="#Http请求失败" class="headerlink" title="Http请求失败"></a>Http请求失败</h3><p>在9.0中默认情况下启用网络传输层安全协议 (TLS)，默认情况下已停用明文支持。也就是不允许使用http请求，要求使用https。</p><p>比如我使用的是okhttp，会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.UnknownServiceException: CLEARTEXT communication to xxxx not permitted by network security policy</span><br></pre></td></tr></table></figure><p>解决方法是需要我们添加网络安全配置。首先在 <code>res</code> 目录下新建<code>xml</code>文件夹，添加<code>network_security_config.xml</code>文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>AndroidManifest.xml</code>中的<code>application</code>添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config"</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上这是一种简单粗暴的配置方法，要么支持http，要么不支持http。为了安全灵活，我们可以指定支持的http域名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Android 9.0 上部分域名时使用 http --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>secure.example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>cdn.example1.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然不止这些配置，还有抓包配置、设置自定义CA以及各种场景下灵活的配置，详细的方法可以查看<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Ftraining%2Farticles%2Fsecurity-config.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="Apache-HTTP-客户端弃用"><a href="#Apache-HTTP-客户端弃用" class="headerlink" title="Apache HTTP 客户端弃用"></a>Apache HTTP 客户端弃用</h3><p>在 Android 6.0 时，就已经取消了对 <code>Apache HTTP</code> 客户端的支持。 从 Android 9.0 开始，默认情况下该库已从 <code>bootclasspath</code> 中移除。但是耐不住有些SDK中还在使用，比如我见到的<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.umeng.com%2Fdocs%2F66750%2Fdetail%2F94386" target="_blank" rel="noopener">友盟QQ分享报错问题</a>。</p><p>所以要想继续使用<code>Apache HTTP</code>，需要在应用的 AndroidManifest.xml 文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-library</span> <span class="attr">android:name</span>=<span class="string">"org.apache.http.legacy"</span> <span class="attr">android:required</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><p>可以试着搜索一下你的代码，看是否有调用<code>startForegroundService</code> 方法来启动一个前台服务。</p><p><code>startForegroundService</code> 主要来源估计都是8.0适配时候加上的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    startForegroundService(intentService);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startService(intentService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.0 要求创建一个前台服务需要请求 <code>FOREGROUND_SERVICE</code> 权限，否则系统会引发 <code>SecurityException</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to start service com.weilu.test.MyService@81795be with Intent &#123; cmp=com.weilu.test/.MyService &#125;: </span><br><span class="line">java.lang.SecurityException: Permission Denial: startForeground from pid=28631, uid=10626 requires android.permission.FOREGROUND_SERVICE</span><br><span class="line">        at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:3723)</span><br><span class="line">        at android.app.ActivityThread.access$1700(ActivityThread.java:201)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1705)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:207)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6820)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)</span><br></pre></td></tr></table></figure><p>解决方法就是<code>AndroidManifest.xml</code>中添加<code>FOREGROUND_SERVICE</code>权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.FOREGROUND_SERVICE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h2><p>在9.0 中，不能直接非 <code>Activity</code> 环境中（比如<code>Service</code>，<code>Application</code>）启动 <code>Activity</code>，否则会崩溃报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to create service com.weilu.test.MyService: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br><span class="line">        at android.app.ActivityThread.handleCreateService(ActivityThread.java:3578)</span><br><span class="line">        at android.app.ActivityThread.access$1400(ActivityThread.java:201)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:207)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6820)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)</span><br></pre></td></tr></table></figure><p>这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标<code>FLAG_ACTIVITY_NEW_TASK</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h2 id="异形屏适配"><a href="#异形屏适配" class="headerlink" title="异形屏适配"></a>异形屏适配</h2><p>这类异形屏叫法很多，刘海屏、水滴屏、挖孔屏、美人尖。。</p><ol><li>其实如果你的页面不需要全屏显示，那么不需要额外的适配工作。</li><li>如果页面是全屏显示（比如启动页）。为了防止你的内容被遮挡，大部分场景下都是可以使用获取状态栏高度来处理遮挡的适配问题。因为状态栏的高度都是大于等于刘海的高度。</li></ol><p>当然，如果你想利用起来刘海区域，就需要获取刘海位置等信息进行适配。在Android 9.0中官方提供了<code>DisplayCutout</code> 类，可以确定刘海区域的位置，国内的部分厂商在8.0就有了自己的适配方案。</p><p>具体的我就不过多介绍了，推荐大家看以下文章：</p><ul><li><a href="https://juejin.im/post/5b1930835188257d7541ba33#heading-26" target="_blank" rel="noopener">Android P 刘海屏适配全攻略</a></li><li><a href="https://juejin.im/post/5cf635846fb9a07f0c466ea7" target="_blank" rel="noopener">Android刘海屏、水滴屏全面屏适配方案</a></li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>首先是权限组的变更：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821144142.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821144220.png" alt></p><p>上图可以看到，在9.0 中新增权限组<code>CALL_LOG</code> 并将 <code>READ_CALL_LOG</code>、<code>WRITE_CALL_LOG</code> 和 <code>PROCESS_OUTGOING_CALLS</code> 权限从<code>PHONE</code>中移入该组。</p><h3 id="限制访问通话记录"><a href="#限制访问通话记录" class="headerlink" title="限制访问通话记录"></a>限制访问通话记录</h3><p>如果应用需要访问通话记录或者需要处理去电，则您必须向 <code>CALL_LOG</code>权限组明确请求这些权限。 否则会发生 <code>SecurityException</code>。</p><h3 id="限制访问电话号码"><a href="#限制访问电话号码" class="headerlink" title="限制访问电话号码"></a>限制访问电话号码</h3><ul><li><p>要通过 <code>PHONE_STATE</code> Intent 操作读取电话号码，同时需要 <code>READ_CALL_LOG</code> 权限和 <code>READ_PHONE_STATE</code> 权限。</p></li><li><p>要从 <code>PhoneStateListener的onCallStateChanged()</code> 中读取电话号码，只需要 <code>READ_CALL_LOG</code> 权限。 不需要 <code>READ_PHONE_STATE</code> 权限。</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>在 Android 9 中，调用<code>Build.SERIAL</code> 会始终返回 <code>UNKNOWN</code> 以保护用户的隐私。如果你的应用需要访问设备的硬件序列号，那么需要先请求 <code>READ_PHONE_STATE</code> 权限，然后调用 <code>Build.getSerial()</code>。</p></li><li><p>注意非 SDK 接口的限制。主要是一些热修复、插件化框架涉及比较多，注意及时升级新版本。</p></li><li><p>多进程使用<code>WebView</code>注意无法共用同一数据目录。 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fabout%2Fversions%2Fpie%2Fandroid-9.0-changes-28%23web-data-dirs" target="_blank" rel="noopener">详细点击查看</a></p></li></ul><p>总的来说，9.0的适配工作需要改动和注意的点相比较以前版本的适配来说并不多，从本篇的篇幅就可以看出来，详细的变化可以参看文末的链接。后面如果遇到什么坑，我也会及时补充进来。感谢你的阅读！！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fabout%2Fversions%2Fpie%2Fandroid-9.0" target="_blank" rel="noopener">Android 9.0 行为变更</a></li><li><a href="https://juejin.im/post/5d36c2d26fb9a07ea33c562e#heading-6" target="_blank" rel="noopener">targetSdkVersion升级28</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;国内从去年开始就有消息说，应用上架或者更新要求TargetSdkVersion最低要为26以上，也就是最低也要适配到8.0。今年来也都逐步地开始落实。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fdev.mi.com%2Fconsole%2Fdoc%2Fdetail%3FpId%3D1695&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小米应用商店公告&lt;/a&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fdistribute%2Fbest-practices%2Fdevelop%2Ftarget-sdk%3Fhl%3Dzh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Play的要求&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142559.png&quot; alt&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821142744.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;还包括从8月份开始在Google Play上发布的应用必须支持64位架构。可以看到适配工作真的不能像以前一样随心所欲了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-8.0详解</title>
    <link href="https://zhangmiao.cc/posts/cd8b8392.html"/>
    <id>https://zhangmiao.cc/posts/cd8b8392.html</id>
    <published>2019-08-21T05:52:29.000Z</published>
    <updated>2019-08-21T06:17:00.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>将我们项目中的<code>targetSdkVersion</code>改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android P怎么适配（滑稽）。</p><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p>首先<a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes#rmp" target="_blank" rel="noopener">引用</a>官方的原文。</p><blockquote><p>在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。<br>对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。<br>例如，假设某个应用在其清单中列出<code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code>。应用请求 <code>READ_EXTERNAL_STORAGE</code>，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予<code>WRITE_EXTERNAL_STORAGE</code>，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 <code>READ_EXTERNAL_STORAGE</code>；不过，如果该应用后来又请求 <code>WRITE_EXTERNAL_STORAGE</code>，则系统会立即授予该权限，而不会提示用户。</p></blockquote><a id="more"></a><p>所谓权限组如下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821135542.png" alt></p><p>所以总结下来，如果你之前是用什么权限就去申请什么权限，那么恭喜你，这个变化不会影响到你。如果你只申请了权限组中的某些权限，却用了同组的其他权限，那么你就需要去适配一下了。</p><p>那么怎么适配呢，如果你去检查之前每个申请权限的地方，未免太过麻烦。那么你可以根据你项目中的<code>Manifest</code>文件中需要的权限与权限组去对比，整理出你需要申请的各个权限组。比如你需要<code>android.permission.CALL_PHONE</code>(打电话)与<code>android.permission.READ_PHONE_STATE</code>(读取手机状态) 这两个权限。那么你就整理出了类似下面的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Phone权限</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String[] PHONE = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">          Manifest.permission.READ_PHONE_STATE, </span><br><span class="line">          Manifest.permission.CALL_PHONE</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到时在申请权限时就可以直接获取它，一次将它们都申请了。这样就防止了遗漏某个权限，导致的异常。</p><p>注意：<code>8.0中PHONE</code>权限组新增两个权限：</p><p>``ANSWER_PHONE_CALLS<code>：允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用</code>acceptRingingCall() `函数。</p><p><code>READ_PHONE_NUMBERS</code> ：权限允许您的应用读取设备中存储的电话号码。</p><h2 id="通知适配"><a href="#通知适配" class="headerlink" title="通知适配"></a>通知适配</h2><p>其实8.0在通知这里变化还挺多的，比如<strong>通知渠道</strong>、<strong>通知标志</strong>、<strong>通知超时</strong>、<strong>背景颜色</strong>的等，详细的说明可以去看官方的<a href="https://developer.android.google.cn/about/versions/oreo/android-8.0#notifications" target="_blank" rel="noopener">Android 8.0 功能和 API</a>。虽然变化很多，但是国内的机子貌似支持的不多。。。我在小米的文档中了解到，Android 已将通知渠道的逻辑纳入 Android Compatibility Definition Document (CDD) 中，意味着所有 Android 厂商都必须支持。所以我们可以放心的去适配。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821135800.png" alt></p><blockquote><p>通知渠道：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。</p></blockquote><p>我个人很喜欢这个新特性。也就是说，我们可以将我们给用户的通知进行分类，我用高德地图app来举例</p><table><thead><tr><th align="center">小米(MIUI10)</th><th align="center">华为(EMUI 8.1.0)</th><th align="center">一加(氢OS 5.1)</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140019.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140114.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140151.png" alt></td></tr></tbody></table><p>可以看到高德地图分的很细致，分为四个组共13个类别(华为貌似对组不生效)。这样有个好处，我们可以控制我们想收到的通知，比如我不喜欢运营活动通知，那我就可以把它关闭。这样避免大量的不必要通知，否则使得用户觉得烦，一棒子打死。直接关闭你的允许通知。当然了，大量app都还没有适配，适配的也都分的不是很细致，比如下图的QQ。(没有对比就没有伤害)</p><table><thead><tr><th align="center">小米(MIUI10)</th><th align="center">一加(氢OS 5.1)</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140256.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140332.png" alt></td></tr></tbody></table><p>当然更重要的问题是，如果不去适配，可能通知都不会弹出来。那么适配的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNotificationChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line"></span><br><span class="line">            NotificationManager notificationManager = (NotificationManager)</span><br><span class="line">                    getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分组（可选）</span></span><br><span class="line">            <span class="comment">//groupId要唯一</span></span><br><span class="line">            String groupId = <span class="string">"group_001"</span>;</span><br><span class="line">            NotificationChannelGroup group = <span class="keyword">new</span> NotificationChannelGroup(groupId, <span class="string">"广告"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建group</span></span><br><span class="line">            notificationManager.createNotificationChannelGroup(group);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//channelId要唯一</span></span><br><span class="line">            String channelId = <span class="string">"channel_001"</span>;</span><br><span class="line"></span><br><span class="line">            NotificationChannel adChannel = <span class="keyword">new</span> NotificationChannel(channelId,</span><br><span class="line">                    <span class="string">"推广信息"</span>, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">            <span class="comment">//补充channel的含义（可选）</span></span><br><span class="line">            adChannel.setDescription(<span class="string">"推广信息"</span>);</span><br><span class="line">            <span class="comment">//将渠道添加进组（先创建组才能添加）</span></span><br><span class="line">            adChannel.setGroup(groupId);</span><br><span class="line">            <span class="comment">//创建channel</span></span><br><span class="line">            notificationManager.createNotificationChannel(adChannel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建通知时，标记你的渠道id</span></span><br><span class="line">            Notification notification = <span class="keyword">new</span> Notification.Builder(MainActivity.<span class="keyword">this</span>, channelId)</span><br><span class="line">                    .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">                    .setContentTitle(<span class="string">"一条新通知"</span>)</span><br><span class="line">                    .setContentText(<span class="string">"这是一条测试消息"</span>)</span><br><span class="line">                    .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            notificationManager.notify(<span class="number">1</span>, notification);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th align="center">小米(MIUI10)</th><th align="center">华为(EMUI 8.1.0)</th><th align="center">一加(氢OS 5.1)</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140658.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140501.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821140530.png" alt></td></tr></tbody></table><p>华为手机当只有一个渠道时，不会显示，会当做默认通知处理，除非一个以上。</p><blockquote><p><strong>注意</strong>：当Channel已经存在时，后面的<code>createNotificationChannel</code>方法仅能更新其name/description，以及对importance进行降级，其余配置均无法更新。所以如果有必要的修改只能创建新的渠道，删除旧渠道</p></blockquote><p>删除渠道代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNotificationChannel</span><span class="params">(String channelId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            NotificationManager mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">            mNotificationManager.deleteNotificationChannel(channelId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="悬浮窗适配"><a href="#悬浮窗适配" class="headerlink" title="悬浮窗适配"></a>悬浮窗适配</h2><p>使用 <code>SYSTEM_ALERT_WINDOW</code> 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口:</p><ul><li>TYPE_PHONE</li><li>TYPE_PRIORITY_PHONE</li><li>TYPE_SYSTEM_ALERT</li><li>TYPE_SYSTEM_OVERLAY</li><li>TYPE_SYSTEM_ERROR</li></ul><p>相反，应用必须使用名为 <code>TYPE_APPLICATION_OVERLAY</code> 的新窗口类型。</p><p>也就是说需要在之前的基础上判断一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然记得需要有权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_OVERLAY_WINDOW"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再进行判断</p><h2 id="安装APK"><a href="#安装APK" class="headerlink" title="安装APK"></a>安装APK</h2><p>Android 8.0去除了“允许未知来源”选项，所以如果我们的App有安装App的功能（检查更新之类的），那么会无法正常安装。</p><p>首先在<code>AndroidManifest</code>文件中添加安装未知来源应用的权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.REQUEST_INSTALL_PACKAGES"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样系统会自动询问用户完成授权。当然你也可以先使用 <code>canRequestPackageInstalls()</code>查询是否有此权限，如果没有的话使用<code>Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES</code>这个action将用户引导至安装未知应用权限界面去授权。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE_UNKNOWN_APP = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installAPK</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasInstallPermission = getPackageManager().canRequestPackageInstalls();</span><br><span class="line">            <span class="keyword">if</span> (hasInstallPermission) &#123;</span><br><span class="line">                <span class="comment">//安装应用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//跳转至“安装未知应用”权限界面，引导用户开启权限</span></span><br><span class="line">                Uri selfPackageUri = Uri.parse(<span class="string">"package:"</span> + <span class="keyword">this</span>.getPackageName());</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri);</span><br><span class="line">                startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//安装应用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收“安装未知应用”权限的开启结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123;</span><br><span class="line">            installAPK();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于权限组、悬浮窗还有安装未知来源应用的权限适配，我们也可以使用<a href="https://github.com/yanzhenjie/AndPermission" target="_blank" rel="noopener">AndPermission</a>。这样更加便捷。</p><h2 id="透明主题的Activity"><a href="#透明主题的Activity" class="headerlink" title="透明主题的Activity"></a>透明主题的Activity</h2><p>这个是在targetSdk=27，Android为8.0的手机时，出现的bug（因为官方已经在8.1修复）。问题的探究可以<a href="https://www.jianshu.com/p/e6b5e7261c25" target="_blank" rel="noopener">查看这里</a>。</p><p>只有全屏不透明的activity才可以设置方向。否则报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation</span><br><span class="line">at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2957)</span><br><span class="line">at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3032)</span><br><span class="line">at android.app.ActivityThread.-wrap11(Unknown Source:0)</span><br><span class="line">at adroid.app.ActivityThread$H.handleMessage(ActivityThread.java:1696)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:105)</span><br><span class="line">at android.os.Looper.loop(Looper.java:164)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:6944)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:327)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1374)</span><br></pre></td></tr></table></figure><p>容易中枪的比如微信分享、支付的回调页面，我们习惯设为透明。</p><p>解决办法：</p><ol><li>要么去掉对应activity中的 <code>screenOrientation</code> 属性，或者对应设置方向的代码。</li><li>要么舍弃透明效果，在它的<code>Theme</code>中添加：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="集合的处理"><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>现在，<code>AbstractCollection.removeAll(null)</code>和<code>AbstractCollection.retainAll(null)</code>始终引发 <code>NullPointerException</code>；之前，当集合为空时不会引发 <code>NullPointerException</code>。所以我们需要做判空处理。</p><h2 id="后台执行限制"><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h2><p>应用在两个方面受到限制：</p><ul><li><p>后台服务限制：处于空闲状态时，应用可以使用的后台服务存在限制。 这些限制不适用于前台服务，因为前台服务更容易引起用户注意。</p></li><li><p>广播限制：除了有限的例外情况，应用无法使用清单注册隐式广播。 它们仍然可以在运行时注册这些广播，并且可以使用清单注册专门针对它们的显式广播。</p></li></ul><p>在大多数情况下，应用都可以使用 <code>JobScheduler</code> 克服这些限制。 这种方式让应用安排为在未活跃运行时执行工作，不过仍能够使系统可以在不影响用户体验的情况下安排这些作业。关于的用法可以参考官方例子：<a href="https://github.com/googlesamples/android-JobScheduler" target="_blank" rel="noopener">android-JobScheduler</a>。</p><p>后台任务google推荐方案使用 <code>WorkManager</code>，<code>WorkManager</code>可以自动维护后台任务，同时可适应不同的条件，同时满足后台<code>Service</code>和静态广播，内部维护着<code>JobScheduler</code>，而在6.0以下系统版本则可自动切换为<code>AlarmManager</code>！有兴趣的可以<a href="https://my.oschina.net/JiangTun/blog/1923680" target="_blank" rel="noopener">了解一下</a>。</p><p>当然还有<a href="https://developer.android.google.cn/about/versions/oreo/background-location-limits" target="_blank" rel="noopener">后台位置的限制</a>需要去注意。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>1.<a href="https://dev.mi.com/console/doc/detail?pId=1303" target="_blank" rel="noopener">MIUI 10 通知类别 / Channel 适配</a></li><li>2.<a href="https://developer.android.google.cn/training/notify-user/channels" target="_blank" rel="noopener">Create and Manage Notification Channels</a></li><li>3.<a href="https://source.android.google.cn/compatibility/8.0/android-8.0-cdd#3_8_user_interface_compatibility" target="_blank" rel="noopener">Presentation of Notifications</a></li><li>4.<a href="https://blog.csdn.net/mq2856992713/article/details/79688587" target="_blank" rel="noopener">Android 实现应用更新适配 Android O</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;将我们项目中的&lt;code&gt;targetSdkVersion&lt;/code&gt;改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android P怎么适配（滑稽）。&lt;/p&gt;
&lt;h2 id=&quot;运行时权限&quot;&gt;&lt;a href=&quot;#运行时权限&quot; class=&quot;headerlink&quot; title=&quot;运行时权限&quot;&gt;&lt;/a&gt;运行时权限&lt;/h2&gt;&lt;p&gt;首先&lt;a href=&quot;https://developer.android.google.cn/about/versions/oreo/android-8.0-changes#rmp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引用&lt;/a&gt;官方的原文。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。&lt;br&gt;对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。&lt;br&gt;例如，假设某个应用在其清单中列出&lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; 和&lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;。应用请求 &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt;，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予&lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt;；不过，如果该应用后来又请求 &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;，则系统会立即授予该权限，而不会提示用户。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-7.0的踩坑之路</title>
    <link href="https://zhangmiao.cc/posts/a6a9da5d.html"/>
    <id>https://zhangmiao.cc/posts/a6a9da5d.html</id>
    <published>2019-08-21T04:10:33.000Z</published>
    <updated>2019-08-21T05:53:17.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装时解析错误"><a href="#安装时解析错误" class="headerlink" title="安装时解析错误"></a>安装时解析错误</h2><p>我们的App通常会有检查更新的功能。用户在收到提示更新并且下载完后，会自动打开安装页面让用户来去安装。这时就会出现安装错误的问题，这类的问题的可能性比较多。比如较低版本的App想要覆盖已有的较高版本App会提示安装未完成，或是签名不一致导致的。不过7.0上常见的有以下两种情况。</p><h3 id="应用间共享文件"><a href="#应用间共享文件" class="headerlink" title="应用间共享文件"></a>应用间共享文件</h3><p>在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 <a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件</a> 这篇文章。</p><h3 id="APK-signature-scheme-v2"><a href="#APK-signature-scheme-v2" class="headerlink" title="APK signature scheme v2"></a>APK signature scheme v2</h3><blockquote><p>Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。详细看<a href="https://developer.android.google.cn/about/versions/nougat/android-7.0.html#apk_signature_v2" target="_blank" rel="noopener">安卓官方说明</a>。</p></blockquote><p>简单地说就是任何方式的篡改APK 文件，在利用了V2签名的apk上会失效。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/WechatIMG163.png" alt></p><p>可以看到默认是V1 和V2选中的。</p><p>1）只勾选v1签名就是传统方案签署，但是在7.0上不会使用V2安全的验证方式。<br>2）只勾选V2签名7.0以下会显示未安装，7.0上则会使用了V2安全的验证方式。<br>3）同时勾选V1和V2则所有版本都没问题。</p><h2 id="PopupWindow位置不正确"><a href="#PopupWindow位置不正确" class="headerlink" title="PopupWindow位置不正确"></a>PopupWindow位置不正确</h2><p>7.0系统的手机上，PopupWindow弹出位置不正确。有两种可能：</p><p><strong>第一种：</strong></p><p>我们使用了<code>update</code>方法，同时设置了<code>Gravity</code>（<code>Gravity.NO_GRAVITY</code>没事）。因为在<code>update</code>方法中有调用<code>computeGravity</code>方法去获取<code>Gravity</code>。（7.0以下没有获取<code>Gravity</code>进行更新判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> newGravity = computeGravity();</span><br><span class="line">       <span class="keyword">if</span> (newGravity != p.gravity) &#123;</span><br><span class="line">           p.gravity = newGravity;</span><br><span class="line">           update = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (update) &#123;</span><br><span class="line">           setLayoutDirectionFromAnchor();</span><br><span class="line">           mWindowManager.updateViewLayout(mDecorView, p);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Android 7.1<code>computeGravity</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeGravity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gravity = mGravity == Gravity.NO_GRAVITY ?  Gravity.START | Gravity.TOP : mGravity;</span><br><span class="line">    <span class="keyword">if</span> (mIsDropdown &amp;&amp; (mClipToScreen || mClippingEnabled)) &#123;</span><br><span class="line">        gravity |= Gravity.DISPLAY_CLIP_VERTICAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gravity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然在7.0上我们设置的<code>Gravity</code>被覆盖了。解决就很简单了，不使用<code>update</code>方法。如果你真的要使用可以参考<a href="http://www.jianshu.com/p/0df10893bf5b" target="_blank" rel="noopener">这篇文章</a>的方法。</p><p><strong>第二种：</strong></p><p><code>PopupWindow</code>高度为<code>MATCH_PARENT</code>，在显示的时候调用<code>showAsLocation</code>方法时，<code>PopupWindow</code>并没有在指定控件的下方显示。如果使用<code>showAsDropDown</code>，会全屏显示。</p><p>解决方法：</p><p>1.最简单的解决方法就是指定 <code>PopupWindow</code> 的高度为 <code>WRAP_CONTENT</code>, 调用 <code>showAsDropDown</code>方法。</p><p>2.或者弹出时做一下判断处理（代码来自<a href="https://github.com/tianma8023/PopupWindowCompat" target="_blank" rel="noopener">PopupWindowCompat</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123; <span class="comment">// Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性</span></span><br><span class="line">    <span class="keyword">int</span>[] location = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">// 记录anchor在屏幕中的位置</span></span><br><span class="line">    anchor.getLocationOnScreen(location);</span><br><span class="line">    <span class="keyword">int</span> offsetY = location[<span class="number">1</span>] + anchor.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">25</span>) &#123; <span class="comment">// Android 7.1 ,8.0中，PopupWindow高度为 match_parent 时，会占据整个屏幕</span></span><br><span class="line">        <span class="comment">// 故而需要在 Android 7.1上再做特殊处理</span></span><br><span class="line">        <span class="keyword">int</span> screenHeight = ScreenUtils.getScreenHeight(context); <span class="comment">// 获取屏幕高度</span></span><br><span class="line">        popupWindow.setHeight(screenHeight - offsetY); <span class="comment">// 重新设置 PopupWindow 的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, <span class="number">0</span>, offsetY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    popupWindow.showAsDropDown(anchor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后台优化"><a href="#后台优化" class="headerlink" title="后台优化"></a>后台优化</h2><p>小伙伴们都知道在Android中有一些隐式广播，使用这些隐式广播可以做一些特定的功能，如，当手机网络变成WiFi时自动下载更新包等。 但，这些隐式广播会在后台频繁启动已注册侦听这些广播的应用，从而带来很大的电量消耗，为缓解这一问题来提升设备性能和用户体验，在Android 7.0中删除了三项隐式广播，以帮助优化内存使用和电量消耗。</p><p>Android 7.0 应用了以下优化措施：</p><ul><li>在 Android 7.0上 应用不会收到 CONNECTIVITY_ACTION 广播，即使你在manifest清单文件中设置了请求接受这些事件的通知。 但，在前台运行的应用如果使用BroadcastReceiver 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。</li><li>在 Android 7.0上应用无法发送或接收 ACTION_NEW_PICTURE 或ACTION_NEW_VIDEO 类型的广播。</li></ul><blockquote><p>应对策略：Android 框架提供多个解决方案来缓解对这些隐式广播的需求。 例如，<a href="https://developer.android.google.cn/reference/android/app/job/JobScheduler.html" target="_blank" rel="noopener">JobScheduler API</a><br>提供了一个稳健可靠的机制来安排满足指定条件（例如连入无线流量网络）时所执行的网络操作。 您甚至可以使用 <a href="https://developer.android.google.cn/reference/android/app/job/JobScheduler.html" target="_blank" rel="noopener">JobScheduler API</a> 来适应内容提供程序变化。</p></blockquote><p>另外，大家如果想了解更多关于后台的优化可查阅<a href="https://developer.android.google.cn/preview/features/background-optimization.html" target="_blank" rel="noopener">后台优化</a></p><p>移动设备会经历频繁的连接变更，例如在 Wi-Fi 和移动数据之间切换时。 目前，可以通过在应用清单中注册一个接收器来侦听隐式 CONNECTIVITY_ACTION 广播，<br>让应用能够监控这些变更。 由于很多应用会注册接收此广播，因此单次网络切换即会导致所有应用被唤醒并同时处理此广播。<br>以上内容来自<a href="https://github.com/crazycodeboy/crazycodeboy.github.io/blob/master/_posts/2016-9-28-Android7.0适配心得.md#后台优化" target="_blank" rel="noopener">这里</a></p><h2 id="多语言特性"><a href="#多语言特性" class="headerlink" title="多语言特性"></a>多语言特性</h2><p>首先是官方的API指南：<a href="https://weilu.blog.csdn.net/article/details/n/guide/topics/resources/multilingual-support.html" target="_blank" rel="noopener">语言和语言区域</a></p><ul><li><p>变化对比：<a href="http://blog.csdn.net/cekiasoo/article/details/53012646" target="_blank" rel="noopener"> Android 7.0多语言支持开发浅析</a></p></li><li><p>实现功能： <a href="http://blog.csdn.net/cekiasoo/article/details/54933135" target="_blank" rel="noopener">Android 实现应用内置语言切换</a></p></li></ul><h2 id="通知栏适配"><a href="#通知栏适配" class="headerlink" title="通知栏适配"></a>通知栏适配</h2><p>这里有一篇非常详细的通知栏介绍与适配，分享给大家：<a href="http://iluhcm.com/2017/03/12/experience-of-adapting-to-android-notifications/" target="_blank" rel="noopener">Android通知栏介绍与适配总结</a></p><h2 id="WebView问题"><a href="#WebView问题" class="headerlink" title="WebView问题"></a>WebView问题</h2><ul><li><a href="http://blog.csdn.net/u012347067/article/details/70829013" target="_blank" rel="noopener">Android 7.0 WebView 部分机型打不开</a></li><li><a href="http://www.jianshu.com/p/07b781795b78" target="_blank" rel="noopener">Android 7.0 WebView 二级跳转后界面空白</a></li></ul><h2 id="Toast导致的BadTokenException"><a href="#Toast导致的BadTokenException" class="headerlink" title="Toast导致的BadTokenException"></a>Toast导致的BadTokenException</h2><ul><li><a href="https://blog.csdn.net/Dovar_66/article/details/84799894" target="_blank" rel="noopener">同学，你的系统Toast可能需要修复一下</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装时解析错误&quot;&gt;&lt;a href=&quot;#安装时解析错误&quot; class=&quot;headerlink&quot; title=&quot;安装时解析错误&quot;&gt;&lt;/a&gt;安装时解析错误&lt;/h2&gt;&lt;p&gt;我们的App通常会有检查更新的功能。用户在收到提示更新并且下载完后，会自动打开安装页面让用户来去安装。这时就会出现安装错误的问题，这类的问题的可能性比较多。比如较低版本的App想要覆盖已有的较高版本App会提示安装未完成，或是签名不一致导致的。不过7.0上常见的有以下两种情况。&lt;/p&gt;
&lt;h3 id=&quot;应用间共享文件&quot;&gt;&lt;a href=&quot;#应用间共享文件&quot; class=&quot;headerlink&quot; title=&quot;应用间共享文件&quot;&gt;&lt;/a&gt;应用间共享文件&lt;/h3&gt;&lt;p&gt;在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 &lt;a href=&quot;https://blog.csdn.net/lmj623565791/article/details/72859156&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 7.0 行为变更 通过FileProvider在应用间共享文件&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;h3 id=&quot;APK-signature-scheme-v2&quot;&gt;&lt;a href=&quot;#APK-signature-scheme-v2&quot; class=&quot;headerlink&quot; title=&quot;APK signature scheme v2&quot;&gt;&lt;/a&gt;APK signature scheme v2&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。详细看&lt;a href=&quot;https://developer.android.google.cn/about/versions/nougat/android-7.0.html#apk_signature_v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安卓官方说明&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地说就是任何方式的篡改APK 文件，在利用了V2签名的apk上会失效。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-6.0的动态权限管理</title>
    <link href="https://zhangmiao.cc/posts/eea8a783.html"/>
    <id>https://zhangmiao.cc/posts/eea8a783.html</id>
    <published>2019-08-21T03:10:33.000Z</published>
    <updated>2019-08-21T05:54:12.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都知道Android 6.0的新特性之一就是应用权限的管理。也就是说凡是涉及用户隐私的权限，用户可以自己去设置管理了。然而在6.0以前，我们安装一款APP是默认同意此APP所需的所有权限（比如定位、访问通讯录），不同意就不能安装。当然，国内的一些手机厂商基于Android定制的系统中，可以实现在6.0以前关闭指定的权限。如下图：</p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/F1139AC38851B1B3F95BC8D301BA75A4.jpg" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/00E7B3451E21BB3E9A5428062F7D9473.jpg" alt></td></tr></tbody></table><a id="more"></a><h2 id="危险权限列表-Dangerous-Permission"><a href="#危险权限列表-Dangerous-Permission" class="headerlink" title="危险权限列表(Dangerous Permission)"></a>危险权限列表(Dangerous Permission)</h2><p>Dangerous Permission一般都是涉及用户隐私的权限。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190821111740.png" alt></p><p>从上面的图片中可以看到，摄像头、电话、定位等等都是我们平常开发中常用的权限。</p><h2 id="可以在6-0不适配权限管理吗？"><a href="#可以在6-0不适配权限管理吗？" class="headerlink" title="可以在6.0不适配权限管理吗？"></a>可以在6.0不适配权限管理吗？</h2><p>答案是可以，但是不推荐。</p><p>首先说怎么不适配，那就是设置targetSdkVersion小于23（Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果您APP设置的targetSdkVersion低于23，在运行时也不会崩溃。）</p><p>有人一看这不是挺好的嘛，解决问题。那么我想告诉你，首先这不是长久之计，早晚都要面对的。你不可能永远targetSdkVersion低于23。其次，它是有一个前提，那就是用户自己不去操作权限。要知道如果用户是6.0以上的手机或是国内部分6.0以前的手机，他可以自己在设置中关闭权限，那么到时APP因为没有权限获取数据异常，导致空指针的异常时，APP就会崩溃。</p><h2 id="怎么适配"><a href="#怎么适配" class="headerlink" title="怎么适配"></a>怎么适配</h2><p>首先Android Studio：<br>在build.gradle中声明targetSdkVersion为23及以上。</p><p>Eclipse：<br>在AndroidManifest.xml中声明targetSdkVersion为23及以上。</p><p>这里引用高德定位Demo的CheckPermissionsActivity类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承了Activity，实现Android6.0的运行时权限检测</span></span><br><span class="line"><span class="comment"> * 需要进行运行时权限检测的Activity可以继承这个类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @创建时间：2016年5月27日 下午3:01:31 </span></span><br><span class="line"><span class="comment"> * @项目名称： AMapLocationDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hongming.wang</span></span><br><span class="line"><span class="comment"> * @文件名称：PermissionsChecker.java</span></span><br><span class="line"><span class="comment"> * @类型名称：PermissionsChecker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckPermissionsActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要进行检测的权限数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String[] needPermissions = &#123;</span><br><span class="line">Manifest.permission.ACCESS_COARSE_LOCATION,</span><br><span class="line">Manifest.permission.ACCESS_FINE_LOCATION,</span><br><span class="line">Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">Manifest.permission.READ_PHONE_STATE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERMISSON_REQUESTCODE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要检测，防止不停的弹框</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isNeedCheck = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onResume();</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span></span><br><span class="line">&amp;&amp; getApplicationInfo().targetSdkVersion &gt;= <span class="number">23</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">checkPermissions(needPermissions);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permissions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> * requestPermissions方法是请求某一权限，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(String... permissions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span></span><br><span class="line">&amp;&amp; getApplicationInfo().targetSdkVersion &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">List&lt;String&gt; needRequestPermissonList = findDeniedPermissions(permissions);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != needRequestPermissonList</span><br><span class="line">&amp;&amp; needRequestPermissonList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">String[] array = needRequestPermissonList.toArray(<span class="keyword">new</span> String[needRequestPermissonList.size()]);</span><br><span class="line">Method method = getClass().getMethod(<span class="string">"requestPermissions"</span>, <span class="keyword">new</span> Class[]&#123;String[].class,</span><br><span class="line"><span class="keyword">int</span>.class&#125;);</span><br><span class="line"></span><br><span class="line">method.invoke(<span class="keyword">this</span>, array, PERMISSON_REQUESTCODE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取权限集中需要申请权限的列表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permissions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> * checkSelfPermission方法是在用来判断是否app已经获取到某一个权限</span></span><br><span class="line"><span class="comment">     * shouldShowRequestPermissionRationale方法用来判断是否</span></span><br><span class="line"><span class="comment">     * 显示申请权限对话框，如果同意了或者不在询问则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">findDeniedPermissions</span><span class="params">(String[] permissions)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; needRequestPermissonList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span></span><br><span class="line">&amp;&amp; getApplicationInfo().targetSdkVersion &gt;= <span class="number">23</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (String perm : permissions) &#123;</span><br><span class="line">Method checkSelfMethod = getClass().getMethod(<span class="string">"checkSelfPermission"</span>, String.class);</span><br><span class="line">Method shouldShowRequestPermissionRationaleMethod = getClass().getMethod(<span class="string">"shouldShowRequestPermissionRationale"</span>,</span><br><span class="line">String.class);</span><br><span class="line"><span class="keyword">if</span> ((Integer)checkSelfMethod.invoke(<span class="keyword">this</span>, perm) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">|| (Boolean)shouldShowRequestPermissionRationaleMethod.invoke(<span class="keyword">this</span>, perm)) &#123;</span><br><span class="line">needRequestPermissonList.add(perm);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> needRequestPermissonList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测是否所有的权限都已经授权</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grantResults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifyPermissions</span><span class="params">(<span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> result : grantResults) &#123;</span><br><span class="line"><span class="keyword">if</span> (result != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 申请权限结果的回调方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@TargetApi</span>(<span class="number">23</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">String[] permissions, <span class="keyword">int</span>[] paramArrayOfInt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (requestCode == PERMISSON_REQUESTCODE) &#123;</span><br><span class="line"><span class="keyword">if</span> (!verifyPermissions(paramArrayOfInt)) &#123;</span><br><span class="line">showMissingPermissionDialog();</span><br><span class="line">isNeedCheck = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示提示信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMissingPermissionDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>);</span><br><span class="line">builder.setTitle(R.string.notifyTitle);</span><br><span class="line">builder.setMessage(R.string.notifyMsg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝, 退出应用</span></span><br><span class="line">builder.setNegativeButton(R.string.cancel,</span><br><span class="line"><span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">builder.setPositiveButton(R.string.setting,</span><br><span class="line"><span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">startAppSettings();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">builder.setCancelable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">builder.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  启动应用的设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAppSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(</span><br><span class="line">Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(keyCode == KeyEvent.KEYCODE_BACK)&#123;</span><br><span class="line"><span class="keyword">this</span>.finish();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在上面的类中，自己加入了一些注释，大家仔细看就可以明白了。</p><p>补充：小米手机在动态权限这里还需要一些兼容，我们需要注意一下。当然对于国内部分6.0以前手机，只能在需要权限去去捕获异常来处理了。</p><blockquote><p>当然不止上面一种实现方法，github上有许多大神开源的封装库，可以很方便的实现权限适配。我推荐两个库，大家根据需求选择：</p></blockquote><ol><li><p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher" target="_blank" rel="noopener">PermissionsDispatcher</a></p></li><li><p><a href="https://github.com/hongyangAndroid/MPermissions" target="_blank" rel="noopener">鸿洋大神的MPermissions</a></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.jianshu.com/p/e1ab1a179fbb" target="_blank" rel="noopener">Android M 新的运行时权限开发者需要知道的一切</a></p></li><li><p><a href="https://lbs.amap.com/api/android-location-sdk/guide/utilities/permission/" target="_blank" rel="noopener">高德地图定位API</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大家都知道Android 6.0的新特性之一就是应用权限的管理。也就是说凡是涉及用户隐私的权限，用户可以自己去设置管理了。然而在6.0以前，我们安装一款APP是默认同意此APP所需的所有权限（比如定位、访问通讯录），不同意就不能安装。当然，国内的一些手机厂商基于Android定制的系统中，可以实现在6.0以前关闭指定的权限。如下图：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/F1139AC38851B1B3F95BC8D301BA75A4.jpg&quot; alt&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/00E7B3451E21BB3E9A5428062F7D9473.jpg&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/categories/Android/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="适配" scheme="https://zhangmiao.cc/tags/%E9%80%82%E9%85%8D/"/>
    
      <category term="动态权限" scheme="https://zhangmiao.cc/tags/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>开箱即用的自定义Banner</title>
    <link href="https://zhangmiao.cc/posts/108df6b8.html"/>
    <id>https://zhangmiao.cc/posts/108df6b8.html</id>
    <published>2019-08-19T09:59:59.000Z</published>
    <updated>2019-08-19T10:14:16.291Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/640112319204sda.gif" alt></p><a id="more"></a><h2 id="自定义Banner用法明细"><a href="#自定义Banner用法明细" class="headerlink" title="自定义Banner用法明细"></a>自定义Banner用法明细</h2><p>支持XML自定义属性：</p><ul><li><p>bv_viewHeight：Banner视图区域的高度，小于等于0时为该布局的高度</p></li><li><p>bv_viewCornerRadius：视图区域圆角的半径</p></li><li><p>bv_itemViewWidthRatio：根据该布局宽度的百分比设置ItemView的宽度</p></li><li><p>bv_itemViewMargin：设置ItemView之间的间距</p></li><li><p>bv_intervalInMillis：Banner轮换时间（在SMOOTH模式下为Banner从右匀速到左的时间）</p></li><li><p>bv_pageHoldInMillis：手指滑动后，页面停留的时长（只在SMOOTH模式下生效）</p></li><li><p>bv_scrollMode：设置Banner滚动模式</p></li><li><ul><li>INTERVAL：间隔切换模式</li><li>SMOOTH：匀速滚动模式</li></ul></li><li><p>bv_itemViewAlign：ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置）</p></li><li><ul><li>CENTER_HORIZONTAL：水平居中</li><li>ALIGN_PARENT_LEFT：居左对齐</li><li>ALIGN_PARENT_RIGHT：居右对齐</li></ul></li></ul><p>暴露的API有：</p><ul><li>setBannerViewImpl(impl: IBannerView)：设置Banner必须的实现类</li><li>startAutoScroll()：开始自动滚动（页面数量小于1时不会滚动）</li><li>stopAutoScroll()：停止自动滚动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义页面切换回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnPageChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">onPageSelected</span><span class="params">(position: Int)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">interface IBannerViewBase </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getCount</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemView</span><span class="params">(context: Context)</span>: View</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">onBindView</span><span class="params">(itemView: View, position: Int)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * BannerView依赖的外部实现</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">interface IBannerView : OnPageChangeListener, IBannerViewBase </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当count为0时的默认view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">getDefaultView</span><span class="params">(context: Context)</span>: View? </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认关闭自动滚动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">isDefaultAutoScroll</span><span class="params">()</span>: Boolean </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onPageSelected</span><span class="params">(position: Int)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址：</p><blockquote><p><a href="https://github.com/drawf/SourceSet/tree/master/app/src/main/java/me/erwa/sourceset/view/banner" target="_blank" rel="noopener">https://github.com/drawf/SourceSet/tree/master/app/src/main/java/me/erwa/sourceset/view/banner</a></p></blockquote><h2 id="思考分析"><a href="#思考分析" class="headerlink" title="思考分析"></a>思考分析</h2><p><strong>NOTE：</strong>这篇文章我们专注于BannerView的封装与实现，关于更底层的PagerSnapHelper的原理部分不在范围内，但在文末我<strong>拜读的文章</strong>中贴出了一份链接，大家可自行食用。</p><p>前路漫漫，我们先梳理下需求：</p><ol><li>要支持两种滚动模式，间隔切换、平滑滚动</li><li>要支持设置视图区域圆角</li><li>要支持设置条目视图圆角（ItemView）（该需求本次未做实现，下文会自动忽略该需求）</li><li>要支持无限循环滚动</li><li>要支持根据BannerView的宽的比值设置ItemView的宽</li><li>要支持设置ItemView之间的间距</li><li>要支持设置滚动间隔，匀速模式要支持设置滚动一页的时间</li><li>要支持设置匀速模式下，手指滑动后，页面停留的时长</li><li>要支持设置ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置）</li><li>要支持设置默认是否开启滚动</li><li>要支持设置数据源为空时的默认View</li><li>要支持数据源只有1张banner时，禁止滚动</li><li>要暴露API控制Banner的自动滚动与暂停</li><li>要支持设置指示器（Indicator），且能灵活控制指示器位置，且与BannerView解耦</li></ol><p>🤩这么多需求，不要怕，我们根据需求来理一遍核心技术点：</p><ol><li><code>平滑滚动模式</code>可以使用RecyclerView+PagerSnapHelper实现，<code>间隔滚动模式</code>可以继续使用ViewPager实现，也可以使用前者方式实现。（本文统一使用RecyclerView+PagerSnapHelper方式，不过代码中也留出了接口，可用ViewPager做实现）</li><li>设置圆角还是采用<code>Xfermode</code>做裁剪合成即可。（该方式在之前的文章<strong>ShadowLayout</strong>中使用过，故本文不再赘述）</li><li>需求[4]将adpter中getItemCount()返回Int.MAX_VALUE，再在绑定View时候，用当前的position与真实count求余数，作为真实的position去绑定数据，即可实现。</li><li>需求[4]到[13]，都没有技术复杂度，但有业务复杂度，做常规实现即可。</li><li>需求[14]可定义Indicator涉及的接口做代码解耦，并将BannerView继承RelativeLayout，这样Indicator作为子View在xml中可灵活控制位置。</li></ol><p>这样一来，实现我们想要的BannerView只是耐心+时间的问题了。以下，我会挑本次实现中重要的几点来做说明，如下：</p><ol><li>RecyclerView+PagerSnapHelper实现的<strong>PagerRecyclerView</strong></li><li>生成PagerView实例的工厂<strong>PagerViewFactory</strong></li><li>Indicator的解耦实现</li></ol><h2 id="PagerRecyclerView"><a href="#PagerRecyclerView" class="headerlink" title="PagerRecyclerView"></a>PagerRecyclerView</h2><p>看名字便知这是一个用RecyclerView实现ViewPager功能的类，所以继承自RecyclerView。</p><p>它作为BannerView的核心功能实现类，为了与上层解耦（也就是方便切换为其它实现，比如用ViewPager做实现）所以定义接口<code>IPagerViewInstance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PagerView功能实例需实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPagerViewInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自动滚动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervalInMillis: Int 在INTERVAL模式下为页面切换间隔 在SMOOTH模式下为滚动一页所需时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">startAutoScroll</span><span class="params">(intervalInMillis: Int)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 停止自动滚动</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">stopAutoScroll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 获取当前Item的位置（List的索引）</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">getCurrentPosition</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 获取当前真实的Item的位置（List的索引）</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">getRealCurrentPosition</span><span class="params">(realCount: Int)</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 设置平滑模式是否开启，否则为间隔切换模式</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">setSmoothMode</span><span class="params">(enabled: Boolean)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 设置页面停留时长</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">setPageHoldInMillis</span><span class="params">(pageHoldInMillis: Int)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 设置页面切换回调</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">setOnPageChangeListener</span><span class="params">(listener: OnPageChangeListener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 通知数据刷新</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">notifyDataSetChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>关于<code>PagerSnapHelper</code>的使用极其简单，只需创建出实例，attachToRecyclerView一下，即可让RecyclerView摇身一变成为ViewPager一样。（这里实在让人惊叹！！我们都应该追求这种API的极致设计）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动到具体位置帮助器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> var mSnapHelper: PagerSnapHelper = PagerSnapHelper()</span><br><span class="line">... 省略代码</span><br><span class="line">init &#123;</span><br><span class="line">    mSnapHelper.attachToRecyclerView(<span class="keyword">this</span>)</span><br><span class="line">    ... 省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>间隔切换模式 匀速滚动模式</code>的实现主要是在<code>startTimer()</code>方法中，两者的区别在于Timer的间隔时间不同、回调中执行的方法不同。其中匀速模式的Timer间隔时间需要使用<code>外部设置的滚动一屏的时间、一屏的宽度、每次scrollBy的距离</code>计算而来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">startTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTimer?.cancel()</span><br><span class="line">    <span class="keyword">if</span> (mWidth &gt; <span class="number">0</span> &amp;&amp; mFlagStartTimer &amp;&amp; context != <span class="keyword">null</span> &amp;&amp; context is Activity) &#123;</span><br><span class="line">        mTimer = timer(initialDelay = mDelayedTime, period = mPeriodTime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mScrollState == SCROLL_STATE_IDLE) &#123;</span><br><span class="line">                (context as Activity).runOnUiThread &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mSmoothMode) &#123;</span><br><span class="line">                        scrollBy(DEFAULT_PERIOD_SCROLL_PIXEL, <span class="number">0</span>)</span><br><span class="line">                        triggerOnPageSelected()</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        smoothScrollToPosition(++mOldPosition)</span><br><span class="line">                        mPageChangeListener?.onPageSelected(mOldPosition)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">onSizeChanged</span><span class="params">(w: Int, h: Int, oldw: Int, oldh: Int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">    mWidth = (w - paddingLeft - paddingRight).toFloat()</span><br><span class="line">    mHeight = (h - paddingTop - paddingBottom).toFloat()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算匀速滚动的时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (mSmoothMode) &#123;</span><br><span class="line">        mPeriodTime = (mSmoothSpeed / (mWidth / DEFAULT_PERIOD_SCROLL_PIXEL)).toLong()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        startTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>页面选中</strong>是根据PagerSnapHelper中提供的findSnapView方法，先找到Snap（就是当前的目标View），再找它的位置，当然还需用一个变量记录一下，防止多次触发回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发OnPageSelected回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">triggerOnPageSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val layoutManager = getLinearLayoutManager()</span><br><span class="line">    val view = mSnapHelper.findSnapView(layoutManager)</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        val position = layoutManager.getPosition(view)</span><br><span class="line">        <span class="comment">//防止同一位置多次触发</span></span><br><span class="line">        <span class="keyword">if</span> (position != mOldPosition) &#123;</span><br><span class="line">            mOldPosition = position</span><br><span class="line">            mPageChangeListener?.onPageSelected(position)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个值得说道的点是初始化时需要矫正<strong>Snap</strong>的位置，因为<strong>PagerSnapHelper</strong>手指滑动的时候才工作让RecyclerView滑动出ViewPager的感觉，所以初始化时不矫正会发现选中的页面不居中显示，还是一个RecyclerView的样子。那如何矫正呢？这里去看了<strong>PagerSnapHelper</strong>实现，搬过来，稍加修改即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矫正首次初始化时SnapView的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">correctSnapViewPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val layoutManager = getLinearLayoutManager()</span><br><span class="line">    val snapView = mSnapHelper.findSnapView(layoutManager)</span><br><span class="line">    <span class="keyword">if</span> (snapView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        val snapDistance = mSnapHelper.calculateDistanceToFinalSnap(layoutManager, snapView)</span><br><span class="line">        <span class="keyword">if</span> (snapDistance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapDistance[<span class="number">0</span>] != <span class="number">0</span> || snapDistance[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//我们把源码的smoothScrollBy改为scrollBy，这样视觉上觉察不出矫正过程</span></span><br><span class="line">                scrollBy(snapDistance[<span class="number">0</span>], snapDistance[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//首次触发回调</span></span><br><span class="line">            triggerOnPageSelected()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是源码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snapToTargetExistingView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mRecyclerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LayoutManager layoutManager = <span class="keyword">this</span>.mRecyclerView.getLayoutManager();</span><br><span class="line">        <span class="keyword">if</span> (layoutManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            View snapView = <span class="keyword">this</span>.findSnapView(layoutManager);</span><br><span class="line">            <span class="keyword">if</span> (snapView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] snapDistance = <span class="keyword">this</span>.calculateDistanceToFinalSnap(layoutManager, snapView);</span><br><span class="line">                <span class="keyword">if</span> (snapDistance[<span class="number">0</span>] != <span class="number">0</span> || snapDistance[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mRecyclerView.smoothScrollBy(snapDistance[<span class="number">0</span>], snapDistance[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我认为PagerRecyclerView较为关键的点，其它部分均为业务逻辑的处理与实现，大家可打开源码自行食用。</p><h2 id="PagerViewFactory"><a href="#PagerViewFactory" class="headerlink" title="PagerViewFactory"></a>PagerViewFactory</h2><p>这里采用了<strong>工厂方法模式</strong>来创建Banner底层的核心实现。</p><p>首先定义了BannerView实例接口，它将作为工厂实例的构造方法参数，用于区分创建底层实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBannerViewBase</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getCount</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemView</span><span class="params">(context: Context)</span>: View</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">onBindView</span><span class="params">(itemView: View, position: Int)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 定义BannerView实例接口</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">interface IBannerViewInstance : IBannerViewBase </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">getContext</span><span class="params">()</span>: Context</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">isSmoothMode</span><span class="params">()</span>: Boolean</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemViewWidth</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemViewMargin</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    fun <span class="title">getItemViewAlign</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>工厂有个getPagerView()的方法，来创建Banner核心实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂根据参数创建对应PagerView实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">override fun <span class="title">getPagerView</span><span class="params">()</span>: IPagerViewInstance </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (bannerView.isSmoothMode()) &#123;</span><br><span class="line">        casePagerRecycler(<span class="keyword">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervalUseViewPager) &#123;</span><br><span class="line">            <span class="comment">//这里可以根据需要用ViewPager做底层实现</span></span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">"这里未使用ViewPager做底层实现"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            casePagerRecycler(<span class="keyword">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是创建了之前写好的PagerRecyclerView，其实就是创建配置使用一个RecyclerView的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理PagerRecyclerView</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">casePagerRecycler</span><span class="params">(isSmoothMode: Boolean)</span>: IPagerViewInstance </span>&#123;</span><br><span class="line">    val recyclerView = PagerRecyclerView(bannerView.getContext())</span><br><span class="line">    recyclerView.layoutManager = LinearLayoutManager(bannerView.getContext(), LinearLayoutManager.HORIZONTAL, <span class="keyword">false</span>)</span><br><span class="line">    recyclerView.adapter = object : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">        <span class="function">override fun <span class="title">getItemCount</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Int.MAX_VALUE</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">onBindViewHolder</span><span class="params">(holder: RecyclerView.ViewHolder, position: Int)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isActivityDestroyed(holder.itemView.context)) &#123;</span><br><span class="line">                val realPos = position % bannerView.getCount()</span><br><span class="line">                bannerView.onBindView(holder.itemView.findViewById(R.id.id_real_item_view), realPos)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">onCreateViewHolder</span><span class="params">(parent: ViewGroup, viewType: Int)</span>: RecyclerView.ViewHolder </span>&#123;</span><br><span class="line">            val itemWrapper = LayoutInflater.from(parent.context).inflate(</span><br><span class="line">                R.layout.layout_banner_item_wrapper,</span><br><span class="line">                parent,</span><br><span class="line">                <span class="keyword">false</span></span><br><span class="line">            ) as RelativeLayout</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理ItemViewWrapper的宽</span></span><br><span class="line">            itemWrapper.layoutParams.width = bannerView.getItemViewWidth() + bannerView.getItemViewMargin()</span><br><span class="line"></span><br><span class="line">            <span class="comment">//外部实际的ItemView</span></span><br><span class="line">            val itemView = bannerView.getItemView(parent.context)</span><br><span class="line">            itemView.id = R.id.id_real_item_view</span><br><span class="line">            val ivParams = RelativeLayout.LayoutParams(</span><br><span class="line">                bannerView.getItemViewWidth(),</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">            )</span><br><span class="line">            ivParams.addRule(bannerView.getItemViewAlign())</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加ItemView到Wrapper</span></span><br><span class="line">            itemWrapper.addView(itemView, ivParams)</span><br><span class="line">            <span class="keyword">return</span> object : RecyclerView.ViewHolder(itemWrapper) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化位置</span></span><br><span class="line">    recyclerView.scrollToPosition(bannerView.getCount() * <span class="number">100</span>)</span><br><span class="line">    recyclerView.setSmoothMode(isSmoothMode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recyclerView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Indicator的解耦实现"><a href="#Indicator的解耦实现" class="headerlink" title="Indicator的解耦实现"></a>Indicator的解耦实现</h2><p>解耦的惯用套路就是抽象方法定义接口。所以我们定义了两个接口，一个是<strong>指示器实例需实现的接口</strong>，一个是<strong>指示器依赖的外部实现</strong>。所以使用这两个接口，可以自定义实现想要的样式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指示器实例需实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IIndicatorInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置外部实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">setIndicator</span><span class="params">(impl: IIndicator)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 重新布局</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">doRequestLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 重新绘制</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">doInvalidate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 指示器依赖的外部实现</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">interface IIndicator </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取adapter总数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">fun <span class="title">getCount</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">     * 获取当前选中页面的索引</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function">    fun <span class="title">getCurrentIndex</span><span class="params">()</span>: Int</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>对于我们这次实现的CrossBarIndicator，它就是一个常规的自定义View，这里已没有什么好说的啦。重点要说的是需求中有<strong>一条且能灵活控制指示器位置</strong>，如何实现呢？需求分析时说了，我们的BannerView是一个RelativeLayout，Indicator作为其子View可以很方便的控制其位置。</p><p>然后，看下BannerView中的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate()</span><br><span class="line">    findIndicator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在子View中找到指示器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">findIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until childCount) &#123;</span><br><span class="line">        val child = getChildAt(i)</span><br><span class="line">        <span class="keyword">if</span> (child is IIndicatorInstance) &#123;</span><br><span class="line">            <span class="comment">//布局填充完毕时，找到子View中的Indicator，并保存下来</span></span><br><span class="line">            mIndicator = child</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBannerViewImpl != <span class="keyword">null</span> &amp;&amp; mWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        val bvImpl = mBannerViewImpl!!</span><br><span class="line">        removeAllViews()</span><br><span class="line"></span><br><span class="line">        ... 省略代码</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化指示器</span></span><br><span class="line">        <span class="keyword">if</span> (mIndicator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mIndicator?.setIndicator(object : IIndicator &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function">override fun <span class="title">getCount</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> bvImpl.getCount()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">override fun <span class="title">getCurrentIndex</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> mPagerViewInstance.getRealCurrentPosition(bvImpl.getCount())</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//把指示器再添加回去</span></span><br><span class="line">            addView(mIndicator as View)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>到这里整体要说的就完结了，整个BannerView的实现细节、逻辑还是很多的，不过复杂度倒没那么高，建议食用源码~ O(∩_∩)O哈哈~</p><p><strong>个人能力有限，如有不正之处欢迎大家批评指出，我会虚心接受并第一时间修改，以不误导大家。</strong></p><h2 id="拜读的文章"><a href="#拜读的文章" class="headerlink" title="拜读的文章"></a><strong>拜读的文章</strong></h2><p>SnapHelper硬核讲解：</p><blockquote><p><a href="https://juejin.im/post/5cbe78ae5188250a6b183872" target="_blank" rel="noopener">https://juejin.im/post/5cbe78ae5188250a6b183872</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/640112319204sda.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
      <category term="Banner" scheme="https://zhangmiao.cc/tags/Banner/"/>
    
  </entry>
  
  <entry>
    <title>Android Context细节解析</title>
    <link href="https://zhangmiao.cc/posts/b902250c.html"/>
    <id>https://zhangmiao.cc/posts/b902250c.html</id>
    <published>2019-08-19T09:37:48.000Z</published>
    <updated>2019-08-19T09:52:41.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Context到底是啥？"><a href="#Context到底是啥？" class="headerlink" title="Context到底是啥？"></a>Context到底是啥？</h2><p>Context 本身是一个抽象类，它的实现类为 ContextImpl。</p><p>另外有子类 ContextWrapper 和 ContextThemeWrapper，这两个子类都是 Context 的代理类，主要区别是 ContextThemeWrapper 有自己的主题资源。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819173910.png" alt></p><p>一个 Context 意味着一个<strong>场景</strong>，一个场景就是我们和软件进行<strong>交互的一个过程</strong>。</p><p>从安卓程序的角度来看，其实一个 Activity 就是一个 Context ，一个 Service 也是一个 Context。</p><a id="more"></a><h2 id="Context有啥作用？"><a href="#Context有啥作用？" class="headerlink" title="Context有啥作用？"></a>Context有啥作用？</h2><p>有啥用？要看它能做啥，看看主要提供了哪些接口了。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174053.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174212.png" alt></p><p>还挺多的，看起来管得挺多，四大组件都管着，像个 Application 大管家。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174304.png" alt></p><h2 id="一个app里有多少个Context？"><a href="#一个app里有多少个Context？" class="headerlink" title="一个app里有多少个Context？"></a>一个app里有多少个Context？</h2><p>前面说啦，一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。</p><h2 id="ContextImpl和ContextWrapper有啥区别？"><a href="#ContextImpl和ContextWrapper有啥区别？" class="headerlink" title="ContextImpl和ContextWrapper有啥区别？"></a>ContextImpl和ContextWrapper有啥区别？</h2><p>看下ContextWrapper：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174343.png" alt></p><p>再看下ContextImpl：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174949.png" alt></p><p>比较下：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174503.png" alt></p><p>不同组件创建ContextImpl的方式：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174546.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819174608.png" alt></p><p>Context相当于Application的大管家；</p><p>ContextWrapper、ContextThemWrapper都是Context的代理类，ContextImpl是Context的主要实现类，是个实力派！</p><p>参考:</p><p><a href="https://juejin.im/post/5c1fab7d5188254eb05fbe48" target="_blank" rel="noopener">https://juejin.im/post/5c1fab7d5188254eb05fbe48</a></p><p><a href="https://juejin.im/post/5865bfa1128fe10057e57c63" target="_blank" rel="noopener">https://juejin.im/post/5865bfa1128fe10057e57c63</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Context到底是啥？&quot;&gt;&lt;a href=&quot;#Context到底是啥？&quot; class=&quot;headerlink&quot; title=&quot;Context到底是啥？&quot;&gt;&lt;/a&gt;Context到底是啥？&lt;/h2&gt;&lt;p&gt;Context 本身是一个抽象类，它的实现类为 ContextImpl。&lt;/p&gt;
&lt;p&gt;另外有子类 ContextWrapper 和 ContextThemeWrapper，这两个子类都是 Context 的代理类，主要区别是 ContextThemeWrapper 有自己的主题资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190819173910.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;一个 Context 意味着一个&lt;strong&gt;场景&lt;/strong&gt;，一个场景就是我们和软件进行&lt;strong&gt;交互的一个过程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从安卓程序的角度来看，其实一个 Activity 就是一个 Context ，一个 Service 也是一个 Context。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Android 中东阿拉伯语适配</title>
    <link href="https://zhangmiao.cc/posts/c080be13.html"/>
    <id>https://zhangmiao.cc/posts/c080be13.html</id>
    <published>2019-08-17T13:44:25.000Z</published>
    <updated>2019-08-17T14:08:53.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RTL-语言由来"><a href="#RTL-语言由来" class="headerlink" title="RTL 语言由来"></a>RTL 语言由来</h3><p>RTL 是 Right-to-left(从右向左) 的缩写。其意为人们书写阅读习惯是从右向左，朝左继续的，常见的 RTL 语言有阿拉伯语，希伯来语等。</p><p>看一下对比：</p><table><thead><tr><th align="center">LTR</th><th align="center">RTL</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817215957.png" alt></td><td align="center"><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817220045.png" alt></td></tr></tbody></table><p>那么对于这种从右到左的习惯，在 Android 布局中有没有支持呢？</p><p>答案是有的：从 Android 4.2 即 SDK 17 开始，提供了全面的本地布局支持，允许镜像布局，可以同时支持 RTL 和 LTR。</p><a id="more"></a><p>接下来我将介绍如何一步一步适配阿拉伯语。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>name</th><th>desc</th><th>chinese</th></tr></thead><tbody><tr><td>android:layoutDirection</td><td>attribute for setting the direction of a component’s layout</td><td>设置组件的布局排列方向</td></tr><tr><td>android:textDirection</td><td>attribute for setting the direction of a component’s text</td><td>设置组件的文字排列方向</td></tr><tr><td>android:textAlignment</td><td>attribute for setting the alignment of a component’s text</td><td>设置文字的对齐方式</td></tr><tr><td>getLayoutDirectionFromLocale()</td><td>method for getting the Locale-specified direction</td><td>获取指定地区的惯用布局方式</td></tr></tbody></table><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在 AndroidManifest.xml 文件中 application 节点添加支持从右到左布局方式代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="切换语言"><a href="#切换语言" class="headerlink" title="切换语言"></a>切换语言</h3><p>相关链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2900023%2Fchange-language-programmatically-in-android" target="_blank" rel="noopener">change-language-programmatically-in-android</a><br> 对应国家语言代码: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F7973023%2Fwhat-is-the-list-of-supported-languages-locales-on-android" target="_blank" rel="noopener">what-is-the-list-of-supported-languages-locales-on-android</a><br> 下面切换语言方式 updateConfiguration 方法在 Api 25 已经过时, 新的切换方式实例 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FDroidKaigi%2Fconference-app-2017%2Fpull%2F315%2Ffiles" target="_blank" rel="noopener">地址</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String languageToLoad  = <span class="string">"ar"</span>; <span class="comment">// your language</span></span><br><span class="line">Resources res = getResources(); </span><br><span class="line">DisplayMetrics dm = res.getDisplayMetrics();</span><br><span class="line">Locale locale = <span class="keyword">new</span> Locale(languageToLoad); </span><br><span class="line">Locale.setDefault(locale);</span><br><span class="line">Configuration config = <span class="keyword">new</span> Configuration();</span><br><span class="line">config.locale = locale;</span><br><span class="line">res.updateConfiguration(conf, dm);</span><br></pre></td></tr></table></figure><h3 id="AS-一键适配"><a href="#AS-一键适配" class="headerlink" title="AS 一键适配"></a>AS 一键适配</h3><p>AS 支持一键适配 RTL，主要是在原来 Layout 中设置 Left 和 Right 属性的补充添加 Start 和 End 属性（你们在写布局的时候是不是很少用到 paddingStart、marginStart？接下来你们写布局的时候可不能再偷懒了，该加的还是得加上)</p><p>Start 属性在 LTR 中对应 Left，在 RTL 中对应 Right，在API 17开始支持，为了兼容低版本，需要同时有 Left 和 Start。从市场来看，Android 4.2 系统以下的手机用户已经不多了，我的建议是可以不兼容，具体还得你们看自家产品在 4.2 系统以下用户数。</p><blockquote><p>Refactor &gt; Add RTL Support Where Possible…</p></blockquote><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817215036.png" alt></p><h3 id="利用第三方插件"><a href="#利用第三方插件" class="headerlink" title="利用第三方插件"></a>利用第三方插件</h3><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fznyang%2Fgradle-android-rtl" target="_blank" rel="noopener">gradle-android-rtl</a></td><td align="center">自动修复布局文件中未添加RTL支持的标签</td></tr></tbody></table><p>与 AS 插件的比较：</p><ul><li>性能更好。在处理大批量文件修改时，用AS工具会出现卡顿</li><li>支持padding标签的补齐</li></ul><h3 id="使用全局样式"><a href="#使用全局样式" class="headerlink" title="使用全局样式"></a>使用全局样式</h3><h4 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h4><p>发现 EditText 控件基本都需要设置下面两个属性<br> 相关链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F10903647%2Fset-a-consistent-style-to-all-edittext-for-e-g" target="_blank" rel="noopener">set-a-consistent-style-to-all-edittext-for-e-g</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:textAlignment="viewStart"</span><br><span class="line">android:gravity="start"</span><br></pre></td></tr></table></figure><p>那我们就可以在 style.xml 样式中全部 EditText 都设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"editTextStyle"</span>&gt;</span>@style/EditTextStyle.Alignment<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"EditTextStyle.Alignment"</span> <span class="attr">parent</span>=<span class="string">"@android:style/Widget.EditText"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textAlignment"</span>&gt;</span>viewStart<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:gravity"</span>&gt;</span>start<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textDirection"</span>&gt;</span>locale<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h4><p>全局给所有 TextView 添加一个 RTL 属性<br> 相关链接:<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F3078081%2Fsetting-global-styles-for-views-in-android" target="_blank" rel="noopener">setting-global-styles-for-views-in-android</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textViewStyle"</span>&gt;</span>@style/TextViewStyle.TextDirection<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">       ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"TextViewStyle.TextDirection"</span> <span class="attr">parent</span>=<span class="string">"android:Widget.TextView"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textDirection"</span>&gt;</span>locale<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="判断是否是-RTL-布局"><a href="#判断是否是-RTL-布局" class="headerlink" title="判断是否是 RTL 布局"></a>判断是否是 RTL 布局</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextUtilsCompat.getLayoutDirectionFromLocale(Locale.getDefault()) == LayoutDirection.RTL</span><br></pre></td></tr></table></figure><h3 id="对集合进行倒序处理"><a href="#对集合进行倒序处理" class="headerlink" title="对集合进行倒序处理"></a>对集合进行倒序处理</h3><p>在某些场合下, 这个方法很有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(List&lt;?&gt; list);</span><br></pre></td></tr></table></figure><h3 id="代码动态设置控件-setMargins"><a href="#代码动态设置控件-setMargins" class="headerlink" title="代码动态设置控件 setMargins"></a>代码动态设置控件 setMargins</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FrameLayout.LayoutParams params = <span class="keyword">new</span> FrameLayout.LayoutParams(</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">params.setMargins(<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">params.setMarginEnd(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h3><p>相关链接: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F37196714%2Ftabs-swipe-direction-in-right-to-left-android-app" target="_blank" rel="noopener">tabs-swipe-direction-in-right-to-left-android-app</a></p><blockquote><p>Android 官方控件大多支持 RTL，ViewPager 除外，GitHub 上面有人对 ViewPager 进行修改支持 RTL, <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fdiego-gomez-olvera%2FRtlViewPager" target="_blank" rel="noopener">地址</a></p></blockquote><h3 id="适配总结"><a href="#适配总结" class="headerlink" title="适配总结"></a>适配总结</h3><ol><li>横向布局 LinearLayout ，可以使用 FrameLayout，控件需要靠左或靠右可以使用 layout_gravity 设置对应属性</li><li>切换阿拉伯语时，网格布局 item 之间的距离会出现增大问题，处理方法是：网格分割线 ItemDecoration 需要加入语言来判断，调换原来设置左右的边距即可</li><li>禁止掉之前的侧滑返回，以免出现冲突</li><li>一些方向图标，重新做一个相对方向的放到 mipmap-ldrtl-xxxhdpi 包下</li><li>动画翻转, 放在 anim-ldrtl 将对应的动画进行反向处理</li><li>布局里如果设置了 paddingLeft、drawableLeft 等等这些属性更改为一个支持 RTL 的属性 paddingStart、drawableStart；但是有些地方可以不加的，例如：购物车上的数量徽章，加了之后感觉怪怪的，所以还是不加了</li><li>利用在 AS 右边的预览布局工具中的语言切换工具，切换成阿拉伯语，能实时看到布局的效果图</li><li>EditText 添加 android:layoutDirection=”locale” ，如果外面有 TextInputLayout 的需给它设置 android:textDirection=”locale” ，如果输入类型时密码时还需添加一个属性 android:textAlignment=”viewStart”</li><li>TextView 需要加上 android:textAlignment=”viewStart 或 viewEnd” 以及 android:textDirection=”locale”</li><li>RecyclerView 网络布局的可以考虑使用 StaggeredGridLayoutManager ，如果数量太多的网格布局，不太建议使用，可能会出现滑动混乱</li><li>阿拉伯语目录下的 String.xml 文件, 出现占位符 d% 需要注意改为 %d, 但又并不是所有都改成这样, 目前我发现当代码中使用了 Toast 和 SpannableString 属性的就需要更改为 %d</li></ol><h3 id="建议计划"><a href="#建议计划" class="headerlink" title="建议计划"></a>建议计划</h3><ol><li>从基础类开始入手，判断是否是阿拉伯语，如果是需要将界面设置为从右到左的显示方式</li><li>分模块进行适配</li><li>复杂的模块，可以放到 layout-ldrtl 包下，单独做一个布局来适配阿拉伯语，例如详情页</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fandroid-developers.googleblog.com%2F2013%2F03%2Fnative-rtl-support-in-android-42.html" target="_blank" rel="noopener">https://android-developers.googleblog.com/2013/03/native-rtl-support-in-android-42.html</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmedium.com%2F%40zhangqichuan%2Frtl-support-in-android-898e11f31561" target="_blank" rel="noopener">https://medium.com/@zhangqichuan/rtl-support-in-android-898e11f31561</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmobikul.com%2Fjust-few-steps-to-make-your-app-rtl-supportable%2F" target="_blank" rel="noopener">https://mobikul.com/just-few-steps-to-make-your-app-rtl-supportable/</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.robustastudio.com%2Ffeatured%2Fandroid-rtl-support%2F" target="_blank" rel="noopener">https://blog.robustastudio.com/featured/android-rtl-support/</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Ffigo0423%2Farticle%2Fdetails%2F50241363" target="_blank" rel="noopener">http://blog.csdn.net/figo0423/article/details/50241363</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fwxx614817%2Farticle%2Fdetails%2F50586388" target="_blank" rel="noopener">http://blog.csdn.net/wxx614817/article/details/50586388</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fjiajixin.cn%2F2016%2F10%2F08%2Fandroid_adapt_rtl%2F" target="_blank" rel="noopener">http://jiajixin.cn/2016/10/08/android_adapt_rtl/</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.apkbus.com%2Fblog-327085-57866.html" target="_blank" rel="noopener">http://www.apkbus.com/blog-327085-57866.html</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdroidyue.com%2Fblog%2F2014%2F07%2F07%2Fsupport-rtl-in-android%2Findex.html" target="_blank" rel="noopener">http://droidyue.com/blog/2014/07/07/support-rtl-in-android/index.html</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fchuansong.me%2Fn%2F920084451521" target="_blank" rel="noopener">http://chuansong.me/n/920084451521</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RTL-语言由来&quot;&gt;&lt;a href=&quot;#RTL-语言由来&quot; class=&quot;headerlink&quot; title=&quot;RTL 语言由来&quot;&gt;&lt;/a&gt;RTL 语言由来&lt;/h3&gt;&lt;p&gt;RTL 是 Right-to-left(从右向左) 的缩写。其意为人们书写阅读习惯是从右向左，朝左继续的，常见的 RTL 语言有阿拉伯语，希伯来语等。&lt;/p&gt;
&lt;p&gt;看一下对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;LTR&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;RTL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817215957.png&quot; alt&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817220045.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;那么对于这种从右到左的习惯，在 Android 布局中有没有支持呢？&lt;/p&gt;
&lt;p&gt;答案是有的：从 Android 4.2 即 SDK 17 开始，提供了全面的本地布局支持，允许镜像布局，可以同时支持 RTL 和 LTR。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="阿拉伯语" scheme="https://zhangmiao.cc/tags/%E9%98%BF%E6%8B%89%E4%BC%AF%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>轻量级存储框架MMKV</title>
    <link href="https://zhangmiao.cc/posts/4770b281.html"/>
    <id>https://zhangmiao.cc/posts/4770b281.html</id>
    <published>2019-08-17T13:14:35.000Z</published>
    <updated>2019-08-17T14:21:21.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>APP 的性能优化之路是永无止境的, 这里学习一个<strong>腾讯开源用于提升本地存储效率的轻量级存储框架</strong> <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV" target="_blank" rel="noopener">MMKV</a></p><p>目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR</p><p>网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了</p><p>因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架</p><h2 id="二、集成与测试"><a href="#二、集成与测试" class="headerlink" title="二、集成与测试"></a>二、集成与测试</h2><p>以下介绍简单的使用方式, 更多详情请查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn" target="_blank" rel="noopener">Wiki</a></p><h3 id="2-1-依赖注入"><a href="#2-1-依赖注入" class="headerlink" title="2.1 依赖注入"></a>2.1 依赖注入</h3><p>在 App 模块的 build.gradle 文件里添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.tencent:mmkv:1.0.22&apos;</span><br><span class="line">    // replace &quot;1.0.22&quot; with any available version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置初始化的根目录</span></span><br><span class="line">String dir = getFilesDir().getAbsolutePath() + <span class="string">"/mmkv_2"</span>;</span><br><span class="line">String rootDir = MMKV.initialize(dir);</span><br><span class="line">Log.i(<span class="string">"MMKV"</span>, <span class="string">"mmkv root: "</span> + rootDir);</span><br></pre></td></tr></table></figure><h3 id="2-3-获取实例"><a href="#2-3-获取实例" class="headerlink" title="2.3 获取实例"></a>2.3 获取实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认的全局实例</span></span><br><span class="line">MMKV kv = MMKV.defaultMMKV();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据业务区别存储, 附带一个自己的 ID</span></span><br><span class="line">MMKV kv = MMKV.mmkvWithID(<span class="string">"MyID"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多进程同步支持</span></span><br><span class="line">MMKV kv = MMKV.mmkvWithID(<span class="string">"MyID"</span>, MMKV.MULTI_PROCESS_MODE);</span><br></pre></td></tr></table></figure><h3 id="2-4-CURD"><a href="#2-4-CURD" class="headerlink" title="2.4 CURD"></a>2.4 CURD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加/更新数据</span></span><br><span class="line">kv.encode(key, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">int</span> tmp = kv.decodeInt(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">kv.removeValueForKey(key);</span><br></pre></td></tr></table></figure><h3 id="2-5-SP-的迁移"><a href="#2-5-SP-的迁移" class="headerlink" title="2.5 SP 的迁移"></a>2.5 SP 的迁移</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testImportSharedPreferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MMKV mmkv = MMKV.mmkvWithID(<span class="string">"myData"</span>);</span><br><span class="line">    SharedPreferences old_man = getSharedPreferences(<span class="string">"myData"</span>, MODE_PRIVATE);</span><br><span class="line">    <span class="comment">// 迁移旧数据</span></span><br><span class="line">    mmkv.importFromSharedPreferences(old_man);</span><br><span class="line">    <span class="comment">// 清空旧数据</span></span><br><span class="line">    old_man.edit().clear().commit();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-数据测试"><a href="#2-6-数据测试" class="headerlink" title="2.6 数据测试"></a>2.6 数据测试</h3><p>以下是 MMKV、SharedPreferences 和 SQLite 同步写入 1000 条数据的测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV</span></span><br><span class="line">MMKV: MMKV write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">12</span> ms</span><br><span class="line">MMKV: MMKV read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">3</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: MMKV write String: loop[<span class="number">1000</span>]: <span class="number">7</span> ms</span><br><span class="line">MMKV: MMKV read String: loop[<span class="number">1000</span>]: <span class="number">4</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// SharedPreferences</span></span><br><span class="line">MMKV: SharedPreferences write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">119</span> ms</span><br><span class="line">MMKV: SharedPreferences read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">3</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: SharedPreferences write String: loop[<span class="number">1000</span>]: <span class="number">187</span></span><br><span class="line">MMKV: SharedPreferences read String: loop[<span class="number">1000</span>]: <span class="number">2</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQLite</span></span><br><span class="line">MMKV: sqlite write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">101</span> ms</span><br><span class="line">MMKV: sqlite read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">136</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: sqlite write String: loop[<span class="number">1000</span>]: <span class="number">29</span> ms</span><br><span class="line">MMKV: sqlite read String: loop[<span class="number">1000</span>]: <span class="number">93</span> ms</span><br></pre></td></tr></table></figure><p>可以看到 MMKV 无论是对比 SP 还是 SQLite, 在性能上都有非常大的优势, 官方提供的数据测试结果如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817211812.png" alt></p><p>更详细的性能测试见 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_benchmark_cn" target="_blank" rel="noopener">wiki</a></p><p>了解 MMKV 的使用方式和测试结果, 让我对其实现原理产生了很大的好奇心, 接下来便看看它是如何将性能做到这个地步的, 这里对主要对 MMKV 的基本操作进行剖析</p><ul><li>初始化</li><li>实例化</li><li>encode</li><li>decode</li><li>进程读写的同步</li></ul><p>我们从初始化的流程开始分析</p><h2 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call on program start</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initialize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String root = context.getFilesDir().getAbsolutePath() + <span class="string">"/mmkv"</span>;</span><br><span class="line">        <span class="keyword">return</span> initialize(root, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> String rootDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initialize</span><span class="params">(String rootDir, LibLoader loader)</span> </span>&#123;</span><br><span class="line">        ...... <span class="comment">// 省略库文件加载器相关代码</span></span><br><span class="line">        <span class="comment">// 保存根目录</span></span><br><span class="line">        MMKV.rootDir = rootDir;</span><br><span class="line">        <span class="comment">// Native 层初始化</span></span><br><span class="line">        jniInitialize(MMKV.rootDir);</span><br><span class="line">        <span class="keyword">return</span> rootDir;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">jniInitialize</span><span class="params">(String rootDir)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MMKV 的初始化, 主要是将根目录通过 jniInitialize 传入了 Native 层, 接下来看看 Native 的初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line">    </span><br><span class="line"><span class="function">MMKV_JNI <span class="keyword">void</span> <span class="title">jniInitialize</span><span class="params">(JNIEnv *env, jobject obj, jstring rootDir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootDir) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *kstr = env-&gt;GetStringUTFChars(rootDir, nullptr);</span><br><span class="line">    <span class="keyword">if</span> (kstr) &#123;</span><br><span class="line">        MMKV::initializeMMKV(kstr);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(rootDir, kstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> unordered_map&lt;std::string, MMKV *&gt; *g_instanceDic;</span><br><span class="line"><span class="keyword">static</span> ThreadLock g_instanceLock;</span><br><span class="line"><span class="keyword">static</span> std::string g_rootDir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.1 获取一个 unordered_map, 类似于 Java 中的 HashMap</span></span><br><span class="line">    g_instanceDic = <span class="keyword">new</span> unordered_map&lt;std::string, MMKV *&gt;;</span><br><span class="line">    <span class="comment">// 1.2 初始化线程锁</span></span><br><span class="line">    g_instanceLock = ThreadLock();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MMKV::initializeMMKV(<span class="keyword">const</span> std::string &amp;rootDir) &#123;</span><br><span class="line">    <span class="comment">// 由 Linux Thread 互斥锁和条件变量保证 initialize 函数在一个进程内只会执行一次</span></span><br><span class="line">    <span class="comment">// https://blog.csdn.net/zhangxiao93/article/details/51910043</span></span><br><span class="line">    <span class="keyword">static</span> pthread_once_t once_control = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="comment">// 1. 进行初始化操作</span></span><br><span class="line">    pthread_once(&amp;once_control, initialize);</span><br><span class="line">    <span class="comment">// 2. 将根目录保存到全局变量</span></span><br><span class="line">    g_rootDir = rootDir;</span><br><span class="line">    <span class="comment">// 拷贝字符串</span></span><br><span class="line">    <span class="keyword">char</span> *path = strdup(g_rootDir.c_str());</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">        <span class="comment">// 3. 根据路径, 生成目标地址的目录</span></span><br><span class="line">        mkPath(path);</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        free(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 initializeMMKV 中主要任务是初始化数据, 以及创建根目录</p><ul><li>pthread_once_t: 类似于 Java 的单例, 其 initialize 方法在进程内只会执行一次 <ul><li>创建 MMKV 对象的缓存散列表 g_instanceDic</li><li>创建一个线程锁 g_instanceLock</li></ul></li><li>mkPath: 根据字符串创建文件目录</li></ul><p>接下来我们看看这个目录创建的过程</p><h3 id="3-1-目录的创建"><a href="#3-1-目录的创建" class="headerlink" title="3.1 目录的创建"></a>3.1 目录的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MmapedFile.cpp</span></span><br><span class="line"><span class="function">bool <span class="title">mkPath</span><span class="params">(<span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 stat 结构体用于描述文件的属性</span></span><br><span class="line">    struct stat sb = &#123;&#125;;</span><br><span class="line">    bool done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 指向字符串起始地址</span></span><br><span class="line">    <span class="keyword">char</span> *slash = path;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="comment">// 移动到第一个非 "/" 的下标处</span></span><br><span class="line">        slash += strspn(slash, <span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// 移动到第一个 "/" 下标出处</span></span><br><span class="line">        slash += strcspn(slash, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        done = (*slash == <span class="string">'\0'</span>);</span><br><span class="line">        *slash = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stat(path, &amp;sb) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行创建文件夹的操作, C 中无 mkdirs 的操作, 需要一个一个文件夹的创建</span></span><br><span class="line">            <span class="keyword">if</span> (errno != ENOENT || mkdir(path, <span class="number">0777</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                MMKVWarning(<span class="string">"%s : %s"</span>, path, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若非文件夹, 则说明为非法路径</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">            MMKVWarning(<span class="string">"%s: %s"</span>, path, strerror(ENOTDIR));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *slash = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 Native 层创建文件路径的通用代码, 逻辑很清晰</p><p>好的, 文件目录创建好了之后, Native 层的初始化操作便结束了, 接下来看看 MMKV 实例构建的过程</p><h2 id="四、实例化"><a href="#四、实例化" class="headerlink" title="四、实例化"></a>四、实例化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MMKV <span class="title">mmkvWithID</span><span class="params">(String mmapID, <span class="keyword">int</span> mode, String cryptKey, String relativePath)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 执行 Native 初始化, 获取句柄值</span></span><br><span class="line">        <span class="keyword">long</span> handle = getMMKVWithID(mmapID, mode, cryptKey, relativePath);</span><br><span class="line">        <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建一个 Java 的壳对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MMKV(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">    getMMKVWithID(String mmapID, <span class="keyword">int</span> mode, String cryptKey, String relativePath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// jni</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nativeHandle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MMKV</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">        nativeHandle = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 MMKV 实例构建的主要逻辑通过 getMMKVWithID 方法实现, 看它内部做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">MMKV_JNI jlong <span class="title">getMMKVWithID</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JNIEnv *env, jobject, jstring mmapID, jint mode, jstring cryptKey, jstring relativePath)</span> </span>&#123;</span><br><span class="line">    MMKV *kv = nullptr;</span><br><span class="line">    <span class="keyword">if</span> (!mmapID) &#123;</span><br><span class="line">        <span class="keyword">return</span> (jlong) kv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取独立存储 id</span></span><br><span class="line">    string str = jstring2string(env, mmapID);</span><br><span class="line"></span><br><span class="line">    bool done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (cryptKey) &#123;</span><br><span class="line">        <span class="comment">// 获取秘钥</span></span><br><span class="line">        string crypt = jstring2string(env, cryptKey);</span><br><span class="line">        <span class="keyword">if</span> (crypt.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (relativePath) &#123;</span><br><span class="line">                <span class="comment">// 获取相对路径</span></span><br><span class="line">                string path = jstring2string(env, relativePath);</span><br><span class="line">                <span class="comment">// 通过 mmkvWithID 函数获取一个 MMKV 的对象</span></span><br><span class="line">                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, &amp;path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, nullptr);</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 强转成句柄, 返回到 Java</span></span><br><span class="line">    <span class="keyword">return</span> (jlong) kv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终通过  MMKV::mmkvWithID 函数获取到 MMKV 的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">MMKV *MMKV::mmkvWithID(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mmapID.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPEDLOCK(g_instanceLock);</span><br><span class="line">    <span class="comment">// 1. 通过 mmapID 和 relativePath, 组成最终的 mmap 文件路径的 key</span></span><br><span class="line">    auto mmapKey = mmapedKVKey(mmapID, relativePath);</span><br><span class="line">    <span class="comment">// 2. 从全局缓存中查找</span></span><br><span class="line">    auto itr = g_instanceDic-&gt;find(mmapKey);</span><br><span class="line">    <span class="keyword">if</span> (itr != g_instanceDic-&gt;end()) &#123;</span><br><span class="line">        MMKV *kv = itr-&gt;second;</span><br><span class="line">        <span class="keyword">return</span> kv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 创建缓存文件</span></span><br><span class="line">    <span class="keyword">if</span> (relativePath) &#123;</span><br><span class="line">        <span class="comment">// 根据 mappedKVPathWithID 获取 mmap 的最终文件路径</span></span><br><span class="line">        <span class="comment">// mmapID 使用 md5 加密</span></span><br><span class="line">        auto filePath = mappedKVPathWithID(mmapID, mode, relativePath);</span><br><span class="line">        <span class="comment">// 不存在则创建一个文件</span></span><br><span class="line">        <span class="keyword">if</span> (!isFileExist(filePath)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!createFile(filePath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 创建实例对象</span></span><br><span class="line">    auto kv = <span class="keyword">new</span> MMKV(mmapID, size, mode, cryptKey, relativePath);</span><br><span class="line">    <span class="comment">// 5. 缓存这个 mmapKey</span></span><br><span class="line">    (*g_instanceDic)[mmapKey] = kv;</span><br><span class="line">    <span class="keyword">return</span> kv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mmkvWithID 函数的实现流程非常的清晰, 这里我们主要关注一下实例对象的创建流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">MMKV::MMKV(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath)</span><br><span class="line">    : m_mmapID(mmapedKVKey(mmapID, relativePath)) </span><br><span class="line">    <span class="comment">// 拼装文件的路径</span></span><br><span class="line">    , m_path(mappedKVPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    <span class="comment">// 拼装 .crc 文件路径</span></span><br><span class="line">    , m_crcPath(crcPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    <span class="comment">// 1. 将文件映射到内存</span></span><br><span class="line">    , m_metaFile(m_crcPath, DEFAULT_MMAP_SIZE, (mode &amp; MMKV_ASHMEM) ? MMAP_ASHMEM : MMAP_FILE)</span><br><span class="line">    ......</span><br><span class="line">    , m_sharedProcessLock(&amp;m_fileLock, SharedLockType)</span><br><span class="line">    ......</span><br><span class="line">    , m_isAshmem((mode &amp; MMKV_ASHMEM) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 判断是否为 Ashmem 跨进程匿名共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (m_isAshmem) &#123;</span><br><span class="line">        <span class="comment">// 创共享内存的文件</span></span><br><span class="line">        m_ashmemFile = <span class="keyword">new</span> MmapedFile(m_mmapID, static_cast&lt;size_t&gt;(size), MMAP_ASHMEM);</span><br><span class="line">        m_fd = m_ashmemFile-&gt;getFd();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_ashmemFile = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 cryptKey 创建 AES 加解密的引擎</span></span><br><span class="line">    <span class="keyword">if</span> (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        m_crypter = <span class="keyword">new</span> AESCrypt((<span class="keyword">const</span> unsigned <span class="keyword">char</span> *) cryptKey-&gt;data(), cryptKey-&gt;length());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// sensitive zone</span></span><br><span class="line">    &#123;</span><br><span class="line">        SCOPEDLOCK(m_sharedProcessLock);</span><br><span class="line">        <span class="comment">// 2. 根据 m_mmapID 来加载文件中的数据</span></span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从 MMKV 的构造函数中看到很多有趣的信息, <strong>MMKV 是支持 Ashmem 共享内存的, 这意味着即使是跨进程大数据的传输, 它也能够提供很好的性能支持</strong></p><p>不过这里我们主要关注两个关键点</p><ul><li>m_metaFile 文件的映射</li><li>loadFromFile 数据的载入</li></ul><p>接下来我们先看看, 文件的映射</p><h3 id="4-1-文件映射到内存"><a href="#4-1-文件映射到内存" class="headerlink" title="4.1 文件映射到内存"></a>4.1 文件映射到内存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MmapedFile.cpp</span></span><br><span class="line">MmapedFile::MmapedFile(<span class="keyword">const</span> std::string &amp;path, size_t size, bool fileType)</span><br><span class="line">    : m_name(path), m_fd(-<span class="number">1</span>), m_segmentPtr(nullptr), m_segmentSize(<span class="number">0</span>), m_fileType(fileType) &#123;</span><br><span class="line">    <span class="comment">// 用于内存映射的文件</span></span><br><span class="line">    <span class="keyword">if</span> (m_fileType == MMAP_FILE) &#123;</span><br><span class="line">        <span class="comment">// 1. 打开文件</span></span><br><span class="line">        m_fd = open(m_name.c_str(), O_RDWR | O_CREAT, S_IRWXU);</span><br><span class="line">        <span class="keyword">if</span> (m_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            MMKVError(<span class="string">"fail to open:%s, %s"</span>, m_name.c_str(), strerror(errno));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 创建文件锁</span></span><br><span class="line">            <span class="function">FileLock <span class="title">fileLock</span><span class="params">(m_fd)</span></span>;</span><br><span class="line">            <span class="function">InterProcessLock <span class="title">lock</span><span class="params">(&amp;fileLock, ExclusiveLockType)</span></span>;</span><br><span class="line">            SCOPEDLOCK(lock);</span><br><span class="line">            <span class="comment">// 获取文件的信息</span></span><br><span class="line">            struct stat st = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (fstat(m_fd, &amp;st) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取文件大小</span></span><br><span class="line">                m_segmentSize = static_cast&lt;size_t&gt;(st.st_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 验证文件的大小是否小于一个内存页, 一般为 4kb</span></span><br><span class="line">            <span class="keyword">if</span> (m_segmentSize &lt; DEFAULT_MMAP_SIZE) &#123;</span><br><span class="line">                m_segmentSize = static_cast&lt;size_t&gt;(DEFAULT_MMAP_SIZE);</span><br><span class="line">                <span class="comment">// 3.1 通过 ftruncate 将文件大小对其到内存页</span></span><br><span class="line">                <span class="comment">// 3.2 通过 zeroFillFile 将文件对其后的空白部分用 0 填充</span></span><br><span class="line">                <span class="keyword">if</span> (ftruncate(m_fd, m_segmentSize) != <span class="number">0</span> || !zeroFillFile(m_fd, <span class="number">0</span>, m_segmentSize)) &#123;</span><br><span class="line">                    <span class="comment">// 说明文件拓展失败了, 移除这个文件</span></span><br><span class="line">                    close(m_fd);</span><br><span class="line">                    m_fd = -<span class="number">1</span>;</span><br><span class="line">                    removeFile(m_name);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 通过 mmap 将文件映射到内存, 获取内存首地址</span></span><br><span class="line">            m_segmentPtr =</span><br><span class="line">                (<span class="keyword">char</span> *) mmap(nullptr, m_segmentSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (m_segmentPtr == MAP_FAILED) &#123;</span><br><span class="line">                MMKVError(<span class="string">"fail to mmap [%s], %s"</span>, m_name.c_str(), strerror(errno));</span><br><span class="line">                close(m_fd);</span><br><span class="line">                m_fd = -<span class="number">1</span>;</span><br><span class="line">                m_segmentPtr = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于共享内存的文件</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MmapedFile 的构造函数处理的事务如下</p><ul><li>打开指定的文件</li><li>创建这个文件锁</li><li>修正文件大小, 最小为 4kb <ul><li>前 4kb 用于统计数据总大小</li></ul></li><li>通过 mmap 将文件映射到内存</li></ul><p>好的, 通过 MmapedFile 的构造函数, 我们便能够获取到映射后的内存首地址了, 操作这块内存时 Linux 内核会负责将内存中的数据同步到文件中</p><p>比起 SP 的数据同步, mmap 显然是要优雅的多, <strong>即使进程意外死亡, 也能够通过 Linux 内核的保护机制, 将进行了文件映射的内存数据刷入到文件中, 提升了数据写入的可靠性</strong></p><p>结下来看看数据的载入</p><h3 id="4-2-数据的载入"><a href="#4-2-数据的载入" class="headerlink" title="4.2 数据的载入"></a>4.2 数据的载入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// MMKV.cpp</span><br><span class="line">void MMKV::loadFromFile() &#123;</span><br><span class="line">    </span><br><span class="line">    ......// 忽略匿名共享内存相关代码</span><br><span class="line">    </span><br><span class="line">    // 若已经进行了文件映射</span><br><span class="line">    if (m_metaFile.isFileValid()) &#123;</span><br><span class="line">        // 则获取相关数据</span><br><span class="line">        m_metaInfo.read(m_metaFile.getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取文件描述符</span><br><span class="line">    m_fd = open(m_path.c_str(), O_RDWR | O_CREAT, S_IRWXU);</span><br><span class="line">    if (m_fd &lt; 0) &#123;</span><br><span class="line">        MMKVError(&quot;fail to open:%s, %s&quot;, m_path.c_str(), strerror(errno));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 1. 获取文件大小</span><br><span class="line">        m_size = 0;</span><br><span class="line">        struct stat st = &#123;0&#125;;</span><br><span class="line">        if (fstat(m_fd, &amp;st) != -1) &#123;</span><br><span class="line">            m_size = static_cast&lt;size_t&gt;(st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        // 1.1 将文件大小对其到内存页的整数倍</span><br><span class="line">        if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 获取文件映射后的内存地址</span><br><span class="line">        m_ptr = (char *) mmap(nullptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0);</span><br><span class="line">        if (m_ptr == MAP_FAILED) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 3. 读取内存文件的前 32 位, 获取存储数据的真实大小</span><br><span class="line">            memcpy(&amp;m_actualSize, m_ptr, Fixed32Size);</span><br><span class="line">            ......</span><br><span class="line">            bool loadFromFile = false, needFullWriteback = false;</span><br><span class="line">            if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                // 4. 验证文件的长度</span><br><span class="line">                if (m_actualSize &lt; m_size &amp;&amp; m_actualSize + Fixed32Size &lt;= m_size) &#123;</span><br><span class="line">                    // 5. 验证文件 CRC 的正确性</span><br><span class="line">                    if (checkFileCRCValid()) &#123;</span><br><span class="line">                        loadFromFile = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 若不正确, 则回调异常 CRC 异常</span><br><span class="line">                        auto strategic = mmkv::onMMKVCRCCheckFail(m_mmapID);</span><br><span class="line">                        if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                            loadFromFile = true;</span><br><span class="line">                            needFullWriteback = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 回调文件长度异常</span><br><span class="line">                    auto strategic = mmkv::onMMKVFileLengthError(m_mmapID);</span><br><span class="line">                    if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                        writeAcutalSize(m_size - Fixed32Size);</span><br><span class="line">                        loadFromFile = true;</span><br><span class="line">                        needFullWriteback = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 6. 需要从文件获取数据</span><br><span class="line">            if (loadFromFile) &#123;</span><br><span class="line">                ......</span><br><span class="line">                // 构建输入缓存</span><br><span class="line">                MMBuffer inputBuffer(m_ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);</span><br><span class="line">                if (m_crypter) &#123;</span><br><span class="line">                    // 解密输入缓冲中的数据</span><br><span class="line">                    decryptBuffer(*m_crypter, inputBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">                // 从输入缓冲中将数据读入 m_dic</span><br><span class="line">                m_dic.clear();</span><br><span class="line">                MiniPBCoder::decodeMap(m_dic, inputBuffer);</span><br><span class="line">                // 构建输出数据</span><br><span class="line">                m_output = new CodedOutputData(m_ptr + Fixed32Size + m_actualSize,</span><br><span class="line">                                               m_size - Fixed32Size - m_actualSize);</span><br><span class="line">                // 进行重整回写, 剔除重复的数据</span><br><span class="line">                if (needFullWriteback) &#123;</span><br><span class="line">                    fullWriteback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            // 7. 说明文件中没有数据, 或者校验失败了</span><br><span class="line">            else &#123;</span><br><span class="line">                SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">                // 清空文件中的数据</span><br><span class="line">                if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                    writeAcutalSize(0);</span><br><span class="line">                &#125;</span><br><span class="line">                m_output = new CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size);</span><br><span class="line">                // 重新计算 CRC</span><br><span class="line">                recaculateCRCDigest();</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    m_needLoadFromFile = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 可以看到 loadFromFile 中对于 CRC 验证通过的文件, 会将文件中的数据读入到 m_dic 中缓存, 否则则会清空文件</p><ul><li><p>因此用户恶意修改文件之后, 会破坏 CRC 的值, 这个存储数据便会被作废, 这一点要尤为注意</p></li><li><p>从文件中读取数据到 m_dic 之后, 会将 mdic 回写到文件中</p><p>, 其重写的目的是为了剔除重复的数据 </p><ul><li>关于为什么会出现重复的数据, 在后面 encode 操作中再分析</li></ul></li></ul><h3 id="4-3-回顾"><a href="#4-3-回顾" class="headerlink" title="4.3 回顾"></a>4.3 回顾</h3><p>到这里 MMKV 实例的构建就完成了, 有了 m_dic 这个内存缓存, 我们进行数据查询的效率就大大提升了</p><p>从最终的结果来看它与 SP 是一致的, 都是初次加载时会将文件中所有的数据加载到散列表中, 不过 MMKV 多了一步数据回写的操作, 因此当数据量比较大时, 对实例构建的速度有一定的影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 写入 1000 条数据之后, MMVK 和 SharedPreferences 实例化的时间对比</span><br><span class="line">E/TAG: create MMKV instance time is 4 ms</span><br><span class="line">E/TAG: create SharedPreferences instance time is 1 ms</span><br></pre></td></tr></table></figure><p>从结果上来看, MMVK 的确在实例构造速度上有一定的劣势, 不过得益于是将 m_dic 中的数据写入到 mmap 的内存, 其真正进行文件写入的时机由 Linux 内核决定, 再加上文件的页缓存机制, 所以速度上虽有劣势, 但不至于无法接受</p><h2 id="五、encode"><a href="#五、encode" class="headerlink" title="五、encode"></a>五、encode</h2><p>关于 <strong>encode 即数据的添加与更新</strong>的流程, 这里以 encodeString 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">encode</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encodeString(nativeHandle, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">encodeString</span><span class="params">(<span class="keyword">long</span> handle, String key, String value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看 native 层的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">MMKV_JNI jboolean <span class="title">encodeString</span><span class="params">(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue)</span> </span>&#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        <span class="comment">// 若是 value 非 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (oValue) &#123;</span><br><span class="line">            <span class="comment">// 通过 setStringForKey 函数, 将数据存入</span></span><br><span class="line">            string value = jstring2string(env, oValue);</span><br><span class="line">            <span class="keyword">return</span> (jboolean) kv-&gt;setStringForKey(value, key);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 若是 value 为 NULL, 则移除 key 对应的 value 值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            kv-&gt;removeValueForKey(key);</span><br><span class="line">            <span class="keyword">return</span> (jboolean) <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (jboolean) <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要分析一下 setStringForKey 这个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::setStringForKey(<span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 将数据编码成 ProtocolBuffer</span></span><br><span class="line">    auto data = MiniPBCoder::encodeDataWithObject(value);</span><br><span class="line">    <span class="comment">// 2. 更新键值对</span></span><br><span class="line">    <span class="keyword">return</span> setDataForKey(std::move(data), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要分为两步操作</p><ul><li>数据编码</li><li>更新键值对</li></ul><h3 id="5-1-数据的编码"><a href="#5-1-数据的编码" class="headerlink" title="5.1 数据的编码"></a>5.1 数据的编码</h3><p>MMKV 采用的是 ProtocolBuffer 编码方式, 这里就不做过多介绍了, 具体请查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fencoding" target="_blank" rel="noopener">Google 官方文档</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MiniPBCoder.cpp</span></span><br><span class="line">MMBuffer MiniPBCoder::getEncodeData(<span class="keyword">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建编码条目的集合</span></span><br><span class="line">    m_encodeItems = <span class="keyword">new</span> vector&lt;PBEncodeItem&gt;();</span><br><span class="line">    <span class="comment">// 2. 为集合填充数据</span></span><br><span class="line">    size_t index = prepareObjectForEncode(str);</span><br><span class="line">    PBEncodeItem *oItem = (index &lt; m_encodeItems-&gt;size()) ? &amp;(*m_encodeItems)[index] : nullptr;</span><br><span class="line">    <span class="keyword">if</span> (oItem &amp;&amp; oItem-&gt;compiledSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 开辟一个内存缓冲区, 用于存放编码后的数据</span></span><br><span class="line">        m_outputBuffer = <span class="keyword">new</span> MMBuffer(oItem-&gt;compiledSize);</span><br><span class="line">        <span class="comment">// 4. 创建一个编码操作对象</span></span><br><span class="line">        m_outputData = <span class="keyword">new</span> CodedOutputData(m_outputBuffer-&gt;getPtr(), m_outputBuffer-&gt;length());</span><br><span class="line">        <span class="comment">// 执行 protocolbuffer 编码, 并输出到缓冲区</span></span><br><span class="line">        writeRootObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用移动构造函数, 重新创建实例返回</span></span><br><span class="line">    <span class="keyword">return</span> move(*m_outputBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t MiniPBCoder::prepareObjectForEncode(<span class="keyword">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="comment">// 2.1 创建 PBEncodeItem 对象用来描述待编码的条目, 并添加到 vector 集合</span></span><br><span class="line">    m_encodeItems-&gt;push_back(PBEncodeItem());</span><br><span class="line">    <span class="comment">// 2.2 获取 PBEncodeItem 对象</span></span><br><span class="line">    PBEncodeItem *encodeItem = &amp;(m_encodeItems-&gt;back());</span><br><span class="line">    <span class="comment">// 2.3 记录索引位置</span></span><br><span class="line">    size_t index = m_encodeItems-&gt;size() - <span class="number">1</span>;</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 2.4 填充编码类型</span></span><br><span class="line">        encodeItem-&gt;type = PBEncodeItemType_String;</span><br><span class="line">        <span class="comment">// 2.5 填充要编码的数据</span></span><br><span class="line">        encodeItem-&gt;value.strValue = &amp;str;</span><br><span class="line">        <span class="comment">// 2.6 填充数据大小</span></span><br><span class="line">        encodeItem-&gt;valueSize = static_cast&lt;int32_t&gt;(str.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.7 计算编码后的大小</span></span><br><span class="line">    encodeItem-&gt;compiledSize = pbRawVarint32Size(encodeItem-&gt;valueSize) + encodeItem-&gt;valueSize;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 再未进行编码操作之前, 编码后的数据大小就已经确定好了, 并且将它保存在了 encodeItem-&gt;compiledSize 中, 接下来我们看看执行数据编码并输出到缓冲区的操作流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MiniPBCoder.cpp</span></span><br><span class="line"><span class="keyword">void</span> MiniPBCoder::writeRootObject() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t index = <span class="number">0</span>, total = m_encodeItems-&gt;size(); index &lt; total; index++) &#123;</span><br><span class="line">        PBEncodeItem *encodeItem = &amp;(*m_encodeItems)[index];</span><br><span class="line">        <span class="keyword">switch</span> (encodeItem-&gt;type) &#123;</span><br><span class="line">            <span class="comment">// 主要关心编码 String</span></span><br><span class="line">            <span class="keyword">case</span> PBEncodeItemType_String: &#123;</span><br><span class="line">                m_outputData-&gt;writeString(*(encodeItem-&gt;value.strValue));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CodedOutputData.cpp</span></span><br><span class="line"><span class="keyword">void</span> CodedOutputData::writeString(<span class="keyword">const</span> string &amp;value) &#123;</span><br><span class="line">    size_t numberOfBytes = value.size();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1. 按照 varint 方式编码字符串长度, 会改变 m_position 的值</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;writeRawVarint32((int32_t) numberOfBytes);</span><br><span class="line">    <span class="comment">// 2. 将字符串的数据拷贝到编码好的长度后面</span></span><br><span class="line">    memcpy(m_ptr + m_position, ((uint8_t *) value.data()), numberOfBytes);</span><br><span class="line">    <span class="comment">// 更新 position 的值</span></span><br><span class="line">    m_position += numberOfBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 CodedOutputData 的 writeString 中按照 protocol buffer 进行了字符串的编码操作</p><p>其中 m_ptr 是上面开辟的内存缓冲区的地址, 也就是说 writeString 执行结束之后, 数据就已经被写入缓冲区了</p><p>有了编码好的数据缓冲区, 接下来看看更新键值对的操作</p><h3 id="5-2键值对的更新"><a href="#5-2键值对的更新" class="headerlink" title="5.2键值对的更新"></a>5.2键值对的更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::setStringForKey(<span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 编码数据获取存放数据的缓冲区</span></span><br><span class="line">    auto data = MiniPBCoder::encodeDataWithObject(value);</span><br><span class="line">    <span class="comment">// 更新键值对</span></span><br><span class="line">    <span class="keyword">return</span> setDataForKey(std::move(data), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将键值对写入 mmap 文件映射的内存中</span></span><br><span class="line">    auto ret = appendDataWithKey(data, key);</span><br><span class="line">    <span class="comment">// 写入成功, 更新散列数据</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        m_dic[key] = std::move(data);</span><br><span class="line">        m_hasFullWriteback = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MMKV::appendDataWithKey(<span class="keyword">const</span> MMBuffer &amp;data, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 1. 计算 key + value 的 ProtocolBuffer 编码后的长度</span></span><br><span class="line">    size_t keyLength = key.length();</span><br><span class="line">    size_t size = keyLength + pbRawVarint32Size((int32_t) keyLength);</span><br><span class="line">    size += data.length() + pbRawVarint32Size((int32_t) data.length());</span><br><span class="line">    SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 验证是否有足够的空间, 不足则进行数据重整与扩容操作</span></span><br><span class="line">    bool hasEnoughSize = ensureMemorySize(size);</span><br><span class="line">    <span class="keyword">if</span> (!hasEnoughSize || !isFileValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 更新文件头的数据总大小</span></span><br><span class="line">    writeAcutalSize(m_actualSize + size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 将 key 和编码后的 value 写入到文件映射的内存</span></span><br><span class="line">    m_output-&gt;writeString(key);</span><br><span class="line">    m_output-&gt;writeData(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 获取文件映射内存当前 &lt;key, value&gt; 的起始位置</span></span><br><span class="line">    auto ptr = (uint8_t *) m_ptr + Fixed32Size + m_actualSize - size;</span><br><span class="line">    <span class="keyword">if</span> (m_crypter) &#123;</span><br><span class="line">        <span class="comment">// 加密这块区域</span></span><br><span class="line">        m_crypter-&gt;encrypt(ptr, ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 更新 CRC</span></span><br><span class="line">    updateCRCDigest(ptr, size, KeepSequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 可以看到更新键值对的操作还是比较复杂的, 首先将键值对数据写入到文件映射的内存中, 写入成功之后更新散列数据</p><p>关于写入到文件映射的过程, 上面代码中的注释也非常的清晰, 接下来我们 ensureMemorySize 是如何进行数据的重整与扩容的</p><h5 id="5-2-1-数据的重整与扩容"><a href="#5-2-1-数据的重整与扩容" class="headerlink" title="5.2.1 数据的重整与扩容"></a>5.2.1 数据的重整与扩容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::ensureMemorySize(size_t newSize) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 计算新键值对的大小</span></span><br><span class="line">    constexpr size_t ItemSizeHolderSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_dic.empty()) &#123;</span><br><span class="line">        newSize += ItemSizeHolderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据重写: </span></span><br><span class="line">    <span class="comment">// 1. 文件剩余空闲空间少于新的键值对</span></span><br><span class="line">    <span class="comment">// 2. 散列为空</span></span><br><span class="line">    <span class="keyword">if</span> (newSize &gt;= m_output-&gt;spaceLeft() || m_dic.empty()) &#123;</span><br><span class="line">        <span class="comment">// 计算所需的数据空间</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> offset = pbFixed32Size(<span class="number">0</span>);</span><br><span class="line">        MMBuffer data = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">        size_t lenNeeded = data.length() + offset + newSize;</span><br><span class="line">        <span class="keyword">if</span> (m_isAshmem) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="comment">// 计算每个键值对的平均大小</span></span><br><span class="line">            size_t avgItemSize = lenNeeded / std::max&lt;size_t&gt;(<span class="number">1</span>, m_dic.size());</span><br><span class="line">            <span class="comment">// 计算未来可能会使用的大小(类似于 1.5 倍)</span></span><br><span class="line">            size_t futureUsage = avgItemSize * std::max&lt;size_t&gt;(<span class="number">8</span>, (m_dic.size() + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 1. 所需空间 &gt;= 当前文件总大小</span></span><br><span class="line">            <span class="comment">// 2. 所需空间的 1.5 倍 &gt;= 当前文件总大小</span></span><br><span class="line">            <span class="keyword">if</span> (lenNeeded &gt;= m_size || (lenNeeded + futureUsage) &gt;= m_size) &#123;</span><br><span class="line">                <span class="comment">// 扩容为 2 倍</span></span><br><span class="line">                size_t oldSize = m_size;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    m_size *= <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (lenNeeded + futureUsage &gt;= m_size);</span><br><span class="line">                .......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 进行数据的重写</span></span><br><span class="line">        writeAcutalSize(data.length());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以了解到</p><ul><li>数据的重写时机<ul><li>文件剩余空间少于新的键值对大小</li><li>散列为空</li></ul></li><li>文件扩容时机<ul><li>所需空间的 1.5 倍超过了当前文件的总大小时, 扩容为之前的两倍</li></ul></li></ul><h3 id="5-3回顾"><a href="#5-3回顾" class="headerlink" title="5.3回顾"></a>5.3回顾</h3><p>至此 encode 的流程我们就走完了, 回顾一下整个 encode 的流程</p><ul><li><p>使用 ProtocolBuffer 编码 value</p></li><li><p>将 </p><p>key</p><p> 和 </p><p>编码后的 value</p><p> 使用 ProtocolBuffer 的格式 append 到文件映射区内存的尾部 </p><ul><li>文件空间不足 <ul><li>判断是否需要扩容</li><li>进行数据的回写</li></ul></li><li>即在文件后进行追加</li></ul></li><li><p>对这个键值对区域进行统一的加密</p></li><li><p>更新 CRC 的值</p></li><li><p>将 key 和 value 对应的 ProtocolBuffer 编码内存区域, 更新到散列表 m_dic 中</p></li></ul><p>通过 encode 的分析, 我们得知 MMKV 文件的存储方式如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212352.png" alt></p><p>接下来看看 decode 的流程</p><h2 id="六、decode"><a href="#六、decode" class="headerlink" title="六、decode"></a>六、decode</h2><p>decode 的过程同样以 decodeString 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">MMKV_JNI jstring</span><br><span class="line">decodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) &#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        <span class="comment">// 通过 getStringForKey, 将数据输出到传出参数中 value 中</span></span><br><span class="line">        string value;</span><br><span class="line">        bool hasValue = kv-&gt;getStringForKey(key, value);</span><br><span class="line">        <span class="keyword">if</span> (hasValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> string2jstring(env, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oDefaultValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::getStringForKey(<span class="keyword">const</span> std::string &amp;key, std::string &amp;result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPEDLOCK(m_lock);</span><br><span class="line">    <span class="comment">// 1. 从内存缓存中获取数据</span></span><br><span class="line">    auto &amp;data = getDataForKey(key);</span><br><span class="line">    <span class="keyword">if</span> (data.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 解析 data 对应的 ProtocolBuffer 数据</span></span><br><span class="line">        result = MiniPBCoder::decodeString(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MMBuffer &amp;MMKV::getDataForKey(<span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 从散列表中获取 key 对应的 value</span></span><br><span class="line">    auto itr = m_dic.find(key);</span><br><span class="line">    <span class="keyword">if</span> (itr != m_dic.end()) &#123;</span><br><span class="line">        <span class="keyword">return</span> itr-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MMBuffer <span class="title">nan</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> nan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的可以看到 decode 的流程比较简单, 先从内存缓存中获取 key 对应的 value 的 ProtocolBuffer 内存区域, 再解析这块内存区域, 从中获取真正的 value 值</p><h3 id="6-1-思考"><a href="#6-1-思考" class="headerlink" title="6.1 思考"></a>6.1 思考</h3><p>看到这里可能会有一个疑问, <strong>为什么 m_dic 不直接存储 key 和 value 原始数据呢, 这样查询效率不是更快吗?</strong></p><ul><li>如此一来查询效率的确会更快, 因为少了 ProtocolBuffer 解码的过程</li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212418.png" alt></p><p>从图上的结果可以看出, MMKV 的读取性能时略低于 SharedPreferences 的, 这里笔者给出自己的思考</p><ul><li><strong>m_dic 在数据重整中也起到了非常重要的作用, 需要依靠 m_dic 将数据写入到 mmap 的文件映射区</strong>, 这个过程是非常耗时的, 若是原始的 value, 则需要对所有的 value 再进行一次 ProtocolBuffer 编码操作, 尤其是当数据量比较庞大时, 其带来的性能损耗更是无法忽略的</li></ul><p>既然 m_dic 还承担着方便数据复写的功能, 那<strong>能否再添加一个内存缓存专门用于存储原始的 value 呢?</strong></p><ul><li>当然可以, 这样 MMKV 的读取定是能够达到 SharedPreferences 的水平, 不过 value 的内存消耗则会加倍, <strong>MMKV 作为一个轻量级缓存的框架, 查询时时间的提升幅度还不足以用内存加倍的代价去换取</strong>, 我想这是 Tencent 在进行多方面权衡之后, 得到的一个比较合理的解决方案</li></ul><h2 id="七、进程读写的同步"><a href="#七、进程读写的同步" class="headerlink" title="七、进程读写的同步"></a>七、进程读写的同步</h2><p>说起进程间读写同步, 我们很自然的想到 Linux 的共享内存配合信号量使用的案例, 但是这种方式有一个弊端, 那就是<strong>当持有锁的进程意外死亡的时候, 并不会释放其拥有的信号量, 若多进程之间存在竞争, 那么阻塞的进程将不会被唤醒</strong>, 这是非常危险的</p><p>MMKV 是采用 <strong>文件锁</strong> 的方式来进行进程间的同步操作</p><ul><li><strong>LOCK_SH(共享锁)</strong>: 多个进程可以使用同一把锁, 常被用作读共享锁</li><li><strong>LOCK_EX(排他锁)</strong>: 同时只允许一个进程使用, 常被用作写锁</li><li><strong>LOCK_UN</strong>: 释放锁</li></ul><p>接下来我看看 MMKV 加解锁的操作</p><h3 id="7-1-文件共享锁"><a href="#7-1-文件共享锁" class="headerlink" title="7.1 文件共享锁"></a>7.1 文件共享锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MMKV::MMKV(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath)</span><br><span class="line">    : m_mmapID(mmapedKVKey(mmapID, relativePath))</span><br><span class="line">    <span class="comment">// 创建文件锁的描述</span></span><br><span class="line">    , m_fileLock(m_metaFile.getFd())</span><br><span class="line">    <span class="comment">// 描述共享锁</span></span><br><span class="line">    , m_sharedProcessLock(&amp;m_fileLock, SharedLockType)</span><br><span class="line">    <span class="comment">// 描述排它锁</span></span><br><span class="line">    , m_exclusiveProcessLock(&amp;m_fileLock, ExclusiveLockType)</span><br><span class="line">    <span class="comment">// 判读是否为进程间通信</span></span><br><span class="line">    , m_isInterProcess((mode &amp; MMKV_MULTI_PROCESS) != <span class="number">0</span> || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != <span class="number">0</span>)</span><br><span class="line">    , m_isAshmem((mode &amp; MMKV_ASHMEM) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据是否跨进程操作判断共享锁和排它锁的开关</span></span><br><span class="line">    m_sharedProcessLock.m_enable = m_isInterProcess;</span><br><span class="line">    m_exclusiveProcessLock.m_enable = m_isInterProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sensitive zone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文件读操作, 启用了文件共享锁</span></span><br><span class="line">        SCOPEDLOCK(m_sharedProcessLock);</span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在我们前面分析过的构造函数中, MMKV 对文件锁进行了初始化, 并且创建了共享锁和排它锁, 并在跨进程操作时开启, 当进行读操作时, 启动了共享锁</p><h3 id="7-2-文件排它锁"><a href="#7-2-文件排它锁" class="headerlink" title="7.2 文件排它锁"></a>7.2 文件排它锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::fullWriteback() &#123;</span><br><span class="line">    ......</span><br><span class="line">    auto allData = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">    <span class="comment">// 启动了排它锁</span></span><br><span class="line">    SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">    <span class="keyword">if</span> (allData.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allData.length() + Fixed32Size &lt;= m_size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_crypter) &#123;</span><br><span class="line">                m_crypter-&gt;reset();</span><br><span class="line">                auto ptr = (unsigned <span class="keyword">char</span> *) allData.getPtr();</span><br><span class="line">                m_crypter-&gt;encrypt(ptr, ptr, allData.length());</span><br><span class="line">            &#125;</span><br><span class="line">            writeAcutalSize(allData.length());</span><br><span class="line">            delete m_output;</span><br><span class="line">            m_output = <span class="keyword">new</span> CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size);</span><br><span class="line">            m_output-&gt;writeRawData(allData); <span class="comment">// note: don't write size of data</span></span><br><span class="line">            recaculateCRCDigest();</span><br><span class="line">            m_hasFullWriteback = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ensureMemorySize will extend file &amp; full rewrite, no need to write back again</span></span><br><span class="line">            <span class="keyword">return</span> ensureMemorySize(allData.length() + Fixed32Size - m_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行数据回写的函数中, 启动了排它锁</p><h3 id="7-3-读写效率表现"><a href="#7-3-读写效率表现" class="headerlink" title="7.3 读写效率表现"></a>7.3 读写效率表现</h3><p>其进程同步读写的性能表现如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212512.png" alt></p><p>可以看到进程同步读写的效率也是非常 nice 的</p><p>关于跨进程同步就介绍到这里, 当然 MMKV 的文件锁并没有表面上那么简单, 因为文件锁为状态锁, 无论加了多少次锁, 一个解锁操作就全解除, 显然无法应对子函数嵌套调用的问题, <strong>MMKV 内部通过了自行实现计数器来实现锁的可重入性</strong>, 更多的细节可以查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_ipc" target="_blank" rel="noopener">wiki</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析, 我们对 MMKV 有了一个整体上的把控, 其具体的表现如下所示</p><table><thead><tr><th>项目</th><th>评价</th><th>描述</th></tr></thead><tbody><tr><td>正确性</td><td>优</td><td>支持多进程安全, 使用 mmap, 由操作系统保证数据回写的正确性</td></tr><tr><td>时间开销</td><td>优</td><td>使用 mmap 实现, 减少了用户空间数据到内核空间的拷贝</td></tr><tr><td>空间开销</td><td>中</td><td>使用 protocl buffer 存储数据, 同样的数据会比 xml 和 json 消耗空间小   使用的是数据追加到末尾的方式, 只有到达一定阈值之后才会触发键值合并, 不合并之前会导致同一个 key 存在多份</td></tr><tr><td>安全</td><td>中</td><td>使用 crc 校验, 甄别文件系统和操作系统不稳定导致的异常数据</td></tr><tr><td>开发成本</td><td>优</td><td>使用方式较为简单</td></tr><tr><td>兼容性</td><td>优</td><td>各个安卓版本都前后兼容</td></tr></tbody></table><p>虽然 MMKV 一些场景下比 SP 稍慢(如: 首次实例化会进行数据的复写剔除重复数据, 比 SP 稍慢, 查询数据时存在 ProtocolBuffer 解码, 比 SP 稍慢), 但其<strong>逆天的数据写入速度、mmap Linux 内核保证数据的同步, 以及 ProtocolBuffer 编码带来的更小的本地存储空间占用等都是非常棒的闪光点</strong></p><p>在分析 MMKV 的代码的过程中, 从中学习到了很多知识, 非常感谢 Tencent 为开源社区做出的贡献</p><h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn" target="_blank" rel="noopener">github.com/Tencent/MMK…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fencoding" target="_blank" rel="noopener">developers.google.com/protocol-bu…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Farticle%2F76677" target="_blank" rel="noopener">time.geekbang.org/column/arti…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fkex1n%2Fp%2F7100107.html" target="_blank" rel="noopener">www.cnblogs.com/kex1n/p/710…</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;APP 的性能优化之路是永无止境的, 这里学习一个&lt;strong&gt;腾讯开源用于提升本地存储效率的轻量级存储框架&lt;/strong&gt; &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MMKV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR&lt;/p&gt;
&lt;p&gt;网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了&lt;/p&gt;
&lt;p&gt;因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架&lt;/p&gt;
&lt;h2 id=&quot;二、集成与测试&quot;&gt;&lt;a href=&quot;#二、集成与测试&quot; class=&quot;headerlink&quot; title=&quot;二、集成与测试&quot;&gt;&lt;/a&gt;二、集成与测试&lt;/h2&gt;&lt;p&gt;以下介绍简单的使用方式, 更多详情请查看 &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-依赖注入&quot;&gt;&lt;a href=&quot;#2-1-依赖注入&quot; class=&quot;headerlink&quot; title=&quot;2.1 依赖注入&quot;&gt;&lt;/a&gt;2.1 依赖注入&lt;/h3&gt;&lt;p&gt;在 App 模块的 build.gradle 文件里添加:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.tencent:mmkv:1.0.22&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // replace &amp;quot;1.0.22&amp;quot; with any available version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/categories/Android/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>BannerViewPage</title>
    <link href="https://zhangmiao.cc/posts/6831bdd1.html"/>
    <id>https://zhangmiao.cc/posts/6831bdd1.html</id>
    <published>2019-08-13T10:13:23.000Z</published>
    <updated>2019-08-13T10:17:35.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BannerViewPage"><a href="#BannerViewPage" class="headerlink" title="BannerViewPage"></a><a href="https://github.com/zhangmiaocc/BannerViewPage" target="_blank" rel="noopener">BannerViewPage</a></h1><p>Banner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/aaa.gif" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BannerViewPage&quot;&gt;&lt;a href=&quot;#BannerViewPage&quot; class=&quot;headerlink&quot; title=&quot;BannerViewPage&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/zhangmiaocc/BannerViewPage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BannerViewPage&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;Banner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/aaa.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>关于OKR的解读</title>
    <link href="https://zhangmiao.cc/posts/5b77eb6.html"/>
    <id>https://zhangmiao.cc/posts/5b77eb6.html</id>
    <published>2019-07-31T06:56:33.000Z</published>
    <updated>2019-07-31T07:00:21.114Z</updated>
    
    <content type="html"><![CDATA[<p>OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。</p><p>具体拆解如下：</p><p>1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。</p><p>2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。</p><ul><li>以季度（或者其他预先规定的周期）为单位刷新OKR；</li><li>仔细确认结果达成情况；</li><li>如有必要，持续修正现行战略和商业模式；</li><li>结果导向。</li></ul><p>3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。</p><p>4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。</p><p>5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。</p><p>6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。&lt;/p&gt;
&lt;p&gt;具体拆解如下：&lt;/p&gt;
&lt;p&gt;1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。&lt;/p&gt;
&lt;p&gt;2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以季度（或者其他预先规定的周期）为单位刷新OKR；&lt;/li&gt;
&lt;li&gt;仔细确认结果达成情况；&lt;/li&gt;
&lt;li&gt;如有必要，持续修正现行战略和商业模式；&lt;/li&gt;
&lt;li&gt;结果导向。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。&lt;/p&gt;
&lt;p&gt;4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。&lt;/p&gt;
&lt;p&gt;5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。&lt;/p&gt;
&lt;p&gt;6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。&lt;/p&gt;
    
    </summary>
    
      <category term="awsome" scheme="https://zhangmiao.cc/categories/awsome/"/>
    
    
      <category term="awsome" scheme="https://zhangmiao.cc/tags/awsome/"/>
    
  </entry>
  
</feed>
