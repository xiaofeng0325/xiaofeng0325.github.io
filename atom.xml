<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2019-08-17T13:33:49.899Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>轻量级存储框架MMKV</title>
    <link href="https://zhangmiao.cc/posts/4770b281.html"/>
    <id>https://zhangmiao.cc/posts/4770b281.html</id>
    <published>2019-08-17T13:14:35.000Z</published>
    <updated>2019-08-17T13:33:49.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>APP 的性能优化之路是永无止境的, 这里学习一个<strong>腾讯开源用于提升本地存储效率的轻量级存储框架</strong> <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV" target="_blank" rel="noopener">MMKV</a></p><p>目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR</p><p>网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了</p><p>因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架</p><h2 id="集成与测试"><a href="#集成与测试" class="headerlink" title="集成与测试"></a>集成与测试</h2><p>以下介绍简单的使用方式, 更多详情请查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn" target="_blank" rel="noopener">Wiki</a></p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>在 App 模块的 build.gradle 文件里添加:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.tencent:mmkv:1.0.22&apos;</span><br><span class="line">    // replace &quot;1.0.22&quot; with any available version</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置初始化的根目录</span></span><br><span class="line">String dir = getFilesDir().getAbsolutePath() + <span class="string">"/mmkv_2"</span>;</span><br><span class="line">String rootDir = MMKV.initialize(dir);</span><br><span class="line">Log.i(<span class="string">"MMKV"</span>, <span class="string">"mmkv root: "</span> + rootDir);</span><br></pre></td></tr></table></figure><h4 id="获取实例"><a href="#获取实例" class="headerlink" title="获取实例"></a>获取实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取默认的全局实例</span></span><br><span class="line">MMKV kv = MMKV.defaultMMKV();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据业务区别存储, 附带一个自己的 ID</span></span><br><span class="line">MMKV kv = MMKV.mmkvWithID(<span class="string">"MyID"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多进程同步支持</span></span><br><span class="line">MMKV kv = MMKV.mmkvWithID(<span class="string">"MyID"</span>, MMKV.MULTI_PROCESS_MODE);</span><br></pre></td></tr></table></figure><h4 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加/更新数据</span></span><br><span class="line">kv.encode(key, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">int</span> tmp = kv.decodeInt(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">kv.removeValueForKey(key);</span><br></pre></td></tr></table></figure><h4 id="SP-的迁移"><a href="#SP-的迁移" class="headerlink" title="SP 的迁移"></a>SP 的迁移</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testImportSharedPreferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MMKV mmkv = MMKV.mmkvWithID(<span class="string">"myData"</span>);</span><br><span class="line">    SharedPreferences old_man = getSharedPreferences(<span class="string">"myData"</span>, MODE_PRIVATE);</span><br><span class="line">    <span class="comment">// 迁移旧数据</span></span><br><span class="line">    mmkv.importFromSharedPreferences(old_man);</span><br><span class="line">    <span class="comment">// 清空旧数据</span></span><br><span class="line">    old_man.edit().clear().commit();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据测试"><a href="#数据测试" class="headerlink" title="数据测试"></a>数据测试</h4><p>以下是 MMKV、SharedPreferences 和 SQLite 同步写入 1000 条数据的测试结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MMKV</span></span><br><span class="line">MMKV: MMKV write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">12</span> ms</span><br><span class="line">MMKV: MMKV read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">3</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: MMKV write String: loop[<span class="number">1000</span>]: <span class="number">7</span> ms</span><br><span class="line">MMKV: MMKV read String: loop[<span class="number">1000</span>]: <span class="number">4</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// SharedPreferences</span></span><br><span class="line">MMKV: SharedPreferences write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">119</span> ms</span><br><span class="line">MMKV: SharedPreferences read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">3</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: SharedPreferences write String: loop[<span class="number">1000</span>]: <span class="number">187</span></span><br><span class="line">MMKV: SharedPreferences read String: loop[<span class="number">1000</span>]: <span class="number">2</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQLite</span></span><br><span class="line">MMKV: sqlite write <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">101</span> ms</span><br><span class="line">MMKV: sqlite read <span class="keyword">int</span>: loop[<span class="number">1000</span>]: <span class="number">136</span> ms</span><br><span class="line"></span><br><span class="line">MMKV: sqlite write String: loop[<span class="number">1000</span>]: <span class="number">29</span> ms</span><br><span class="line">MMKV: sqlite read String: loop[<span class="number">1000</span>]: <span class="number">93</span> ms</span><br></pre></td></tr></table></figure><p>可以看到 MMKV 无论是对比 SP 还是 SQLite, 在性能上都有非常大的优势, 官方提供的数据测试结果如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817211812.png" alt=""></p><p>更详细的性能测试见 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_benchmark_cn" target="_blank" rel="noopener">wiki</a></p><p>了解 MMKV 的使用方式和测试结果, 让我对其实现原理产生了很大的好奇心, 接下来便看看它是如何将性能做到这个地步的, 这里对主要对 MMKV 的基本操作进行剖析</p><ul><li>初始化</li><li>实例化</li><li>encode</li><li>decode</li><li>进程读写的同步</li></ul><p>我们从初始化的流程开始分析</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call on program start</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initialize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String root = context.getFilesDir().getAbsolutePath() + <span class="string">"/mmkv"</span>;</span><br><span class="line">        <span class="keyword">return</span> initialize(root, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> String rootDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initialize</span><span class="params">(String rootDir, LibLoader loader)</span> </span>&#123;</span><br><span class="line">        ...... <span class="comment">// 省略库文件加载器相关代码</span></span><br><span class="line">        <span class="comment">// 保存根目录</span></span><br><span class="line">        MMKV.rootDir = rootDir;</span><br><span class="line">        <span class="comment">// Native 层初始化</span></span><br><span class="line">        jniInitialize(MMKV.rootDir);</span><br><span class="line">        <span class="keyword">return</span> rootDir;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">jniInitialize</span><span class="params">(String rootDir)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MMKV 的初始化, 主要是将根目录通过 jniInitialize 传入了 Native 层, 接下来看看 Native 的初始化操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line">    </span><br><span class="line"><span class="function">MMKV_JNI <span class="keyword">void</span> <span class="title">jniInitialize</span><span class="params">(JNIEnv *env, jobject obj, jstring rootDir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootDir) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *kstr = env-&gt;GetStringUTFChars(rootDir, nullptr);</span><br><span class="line">    <span class="keyword">if</span> (kstr) &#123;</span><br><span class="line">        MMKV::initializeMMKV(kstr);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(rootDir, kstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> unordered_map&lt;std::string, MMKV *&gt; *g_instanceDic;</span><br><span class="line"><span class="keyword">static</span> ThreadLock g_instanceLock;</span><br><span class="line"><span class="keyword">static</span> std::string g_rootDir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.1 获取一个 unordered_map, 类似于 Java 中的 HashMap</span></span><br><span class="line">    g_instanceDic = <span class="keyword">new</span> unordered_map&lt;std::string, MMKV *&gt;;</span><br><span class="line">    <span class="comment">// 1.2 初始化线程锁</span></span><br><span class="line">    g_instanceLock = ThreadLock();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MMKV::initializeMMKV(<span class="keyword">const</span> std::string &amp;rootDir) &#123;</span><br><span class="line">    <span class="comment">// 由 Linux Thread 互斥锁和条件变量保证 initialize 函数在一个进程内只会执行一次</span></span><br><span class="line">    <span class="comment">// https://blog.csdn.net/zhangxiao93/article/details/51910043</span></span><br><span class="line">    <span class="keyword">static</span> pthread_once_t once_control = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="comment">// 1. 进行初始化操作</span></span><br><span class="line">    pthread_once(&amp;once_control, initialize);</span><br><span class="line">    <span class="comment">// 2. 将根目录保存到全局变量</span></span><br><span class="line">    g_rootDir = rootDir;</span><br><span class="line">    <span class="comment">// 拷贝字符串</span></span><br><span class="line">    <span class="keyword">char</span> *path = strdup(g_rootDir.c_str());</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">        <span class="comment">// 3. 根据路径, 生成目标地址的目录</span></span><br><span class="line">        mkPath(path);</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        free(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 initializeMMKV 中主要任务是初始化数据, 以及创建根目录</p><ul><li>pthread_once_t: 类似于 Java 的单例, 其 initialize 方法在进程内只会执行一次 <ul><li>创建 MMKV 对象的缓存散列表 g_instanceDic</li><li>创建一个线程锁 g_instanceLock</li></ul></li><li>mkPath: 根据字符串创建文件目录</li></ul><p>接下来我们看看这个目录创建的过程</p><h4 id="目录的创建"><a href="#目录的创建" class="headerlink" title="目录的创建"></a>目录的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MmapedFile.cpp</span></span><br><span class="line"><span class="function">bool <span class="title">mkPath</span><span class="params">(<span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 stat 结构体用于描述文件的属性</span></span><br><span class="line">    struct stat sb = &#123;&#125;;</span><br><span class="line">    bool done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 指向字符串起始地址</span></span><br><span class="line">    <span class="keyword">char</span> *slash = path;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        <span class="comment">// 移动到第一个非 "/" 的下标处</span></span><br><span class="line">        slash += strspn(slash, <span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// 移动到第一个 "/" 下标出处</span></span><br><span class="line">        slash += strcspn(slash, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        done = (*slash == <span class="string">'\0'</span>);</span><br><span class="line">        *slash = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stat(path, &amp;sb) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行创建文件夹的操作, C 中无 mkdirs 的操作, 需要一个一个文件夹的创建</span></span><br><span class="line">            <span class="keyword">if</span> (errno != ENOENT || mkdir(path, <span class="number">0777</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                MMKVWarning(<span class="string">"%s : %s"</span>, path, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若非文件夹, 则说明为非法路径</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">            MMKVWarning(<span class="string">"%s: %s"</span>, path, strerror(ENOTDIR));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *slash = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 Native 层创建文件路径的通用代码, 逻辑很清晰</p><p>好的, 文件目录创建好了之后, Native 层的初始化操作便结束了, 接下来看看 MMKV 实例构建的过程</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MMKV <span class="title">mmkvWithID</span><span class="params">(String mmapID, <span class="keyword">int</span> mode, String cryptKey, String relativePath)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 执行 Native 初始化, 获取句柄值</span></span><br><span class="line">        <span class="keyword">long</span> handle = getMMKVWithID(mmapID, mode, cryptKey, relativePath);</span><br><span class="line">        <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建一个 Java 的壳对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MMKV(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">    getMMKVWithID(String mmapID, <span class="keyword">int</span> mode, String cryptKey, String relativePath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// jni</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nativeHandle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MMKV</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">        nativeHandle = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 MMKV 实例构建的主要逻辑通过 getMMKVWithID 方法实现, 看它内部做了什么</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">MMKV_JNI jlong <span class="title">getMMKVWithID</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JNIEnv *env, jobject, jstring mmapID, jint mode, jstring cryptKey, jstring relativePath)</span> </span>&#123;</span><br><span class="line">    MMKV *kv = nullptr;</span><br><span class="line">    <span class="keyword">if</span> (!mmapID) &#123;</span><br><span class="line">        <span class="keyword">return</span> (jlong) kv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取独立存储 id</span></span><br><span class="line">    string str = jstring2string(env, mmapID);</span><br><span class="line"></span><br><span class="line">    bool done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (cryptKey) &#123;</span><br><span class="line">        <span class="comment">// 获取秘钥</span></span><br><span class="line">        string crypt = jstring2string(env, cryptKey);</span><br><span class="line">        <span class="keyword">if</span> (crypt.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (relativePath) &#123;</span><br><span class="line">                <span class="comment">// 获取相对路径</span></span><br><span class="line">                string path = jstring2string(env, relativePath);</span><br><span class="line">                <span class="comment">// 通过 mmkvWithID 函数获取一个 MMKV 的对象</span></span><br><span class="line">                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, &amp;path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, nullptr);</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 强转成句柄, 返回到 Java</span></span><br><span class="line">    <span class="keyword">return</span> (jlong) kv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终通过  MMKV::mmkvWithID 函数获取到 MMKV 的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">MMKV *MMKV::mmkvWithID(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mmapID.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPEDLOCK(g_instanceLock);</span><br><span class="line">    <span class="comment">// 1. 通过 mmapID 和 relativePath, 组成最终的 mmap 文件路径的 key</span></span><br><span class="line">    auto mmapKey = mmapedKVKey(mmapID, relativePath);</span><br><span class="line">    <span class="comment">// 2. 从全局缓存中查找</span></span><br><span class="line">    auto itr = g_instanceDic-&gt;find(mmapKey);</span><br><span class="line">    <span class="keyword">if</span> (itr != g_instanceDic-&gt;end()) &#123;</span><br><span class="line">        MMKV *kv = itr-&gt;second;</span><br><span class="line">        <span class="keyword">return</span> kv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 创建缓存文件</span></span><br><span class="line">    <span class="keyword">if</span> (relativePath) &#123;</span><br><span class="line">        <span class="comment">// 根据 mappedKVPathWithID 获取 mmap 的最终文件路径</span></span><br><span class="line">        <span class="comment">// mmapID 使用 md5 加密</span></span><br><span class="line">        auto filePath = mappedKVPathWithID(mmapID, mode, relativePath);</span><br><span class="line">        <span class="comment">// 不存在则创建一个文件</span></span><br><span class="line">        <span class="keyword">if</span> (!isFileExist(filePath)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!createFile(filePath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 创建实例对象</span></span><br><span class="line">    auto kv = <span class="keyword">new</span> MMKV(mmapID, size, mode, cryptKey, relativePath);</span><br><span class="line">    <span class="comment">// 5. 缓存这个 mmapKey</span></span><br><span class="line">    (*g_instanceDic)[mmapKey] = kv;</span><br><span class="line">    <span class="keyword">return</span> kv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mmkvWithID 函数的实现流程非常的清晰, 这里我们主要关注一下实例对象的创建流程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">MMKV::MMKV(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath)</span><br><span class="line">    : m_mmapID(mmapedKVKey(mmapID, relativePath)) </span><br><span class="line">    <span class="comment">// 拼装文件的路径</span></span><br><span class="line">    , m_path(mappedKVPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    <span class="comment">// 拼装 .crc 文件路径</span></span><br><span class="line">    , m_crcPath(crcPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    <span class="comment">// 1. 将文件映射到内存</span></span><br><span class="line">    , m_metaFile(m_crcPath, DEFAULT_MMAP_SIZE, (mode &amp; MMKV_ASHMEM) ? MMAP_ASHMEM : MMAP_FILE)</span><br><span class="line">    ......</span><br><span class="line">    , m_sharedProcessLock(&amp;m_fileLock, SharedLockType)</span><br><span class="line">    ......</span><br><span class="line">    , m_isAshmem((mode &amp; MMKV_ASHMEM) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 判断是否为 Ashmem 跨进程匿名共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (m_isAshmem) &#123;</span><br><span class="line">        <span class="comment">// 创共享内存的文件</span></span><br><span class="line">        m_ashmemFile = <span class="keyword">new</span> MmapedFile(m_mmapID, static_cast&lt;size_t&gt;(size), MMAP_ASHMEM);</span><br><span class="line">        m_fd = m_ashmemFile-&gt;getFd();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_ashmemFile = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 cryptKey 创建 AES 加解密的引擎</span></span><br><span class="line">    <span class="keyword">if</span> (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        m_crypter = <span class="keyword">new</span> AESCrypt((<span class="keyword">const</span> unsigned <span class="keyword">char</span> *) cryptKey-&gt;data(), cryptKey-&gt;length());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// sensitive zone</span></span><br><span class="line">    &#123;</span><br><span class="line">        SCOPEDLOCK(m_sharedProcessLock);</span><br><span class="line">        <span class="comment">// 2. 根据 m_mmapID 来加载文件中的数据</span></span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从 MMKV 的构造函数中看到很多有趣的信息, <strong>MMKV 是支持 Ashmem 共享内存的, 这意味着即使是跨进程大数据的传输, 它也能够提供很好的性能支持</strong></p><p>不过这里我们主要关注两个关键点</p><ul><li>m_metaFile 文件的映射</li><li>loadFromFile 数据的载入</li></ul><p>接下来我们先看看, 文件的映射</p><h4 id="文件映射到内存"><a href="#文件映射到内存" class="headerlink" title="文件映射到内存"></a>文件映射到内存</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MmapedFile.cpp</span></span><br><span class="line">MmapedFile::MmapedFile(<span class="keyword">const</span> std::string &amp;path, size_t size, bool fileType)</span><br><span class="line">    : m_name(path), m_fd(-<span class="number">1</span>), m_segmentPtr(nullptr), m_segmentSize(<span class="number">0</span>), m_fileType(fileType) &#123;</span><br><span class="line">    <span class="comment">// 用于内存映射的文件</span></span><br><span class="line">    <span class="keyword">if</span> (m_fileType == MMAP_FILE) &#123;</span><br><span class="line">        <span class="comment">// 1. 打开文件</span></span><br><span class="line">        m_fd = open(m_name.c_str(), O_RDWR | O_CREAT, S_IRWXU);</span><br><span class="line">        <span class="keyword">if</span> (m_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            MMKVError(<span class="string">"fail to open:%s, %s"</span>, m_name.c_str(), strerror(errno));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 创建文件锁</span></span><br><span class="line">            <span class="function">FileLock <span class="title">fileLock</span><span class="params">(m_fd)</span></span>;</span><br><span class="line">            <span class="function">InterProcessLock <span class="title">lock</span><span class="params">(&amp;fileLock, ExclusiveLockType)</span></span>;</span><br><span class="line">            SCOPEDLOCK(lock);</span><br><span class="line">            <span class="comment">// 获取文件的信息</span></span><br><span class="line">            struct stat st = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (fstat(m_fd, &amp;st) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取文件大小</span></span><br><span class="line">                m_segmentSize = static_cast&lt;size_t&gt;(st.st_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 验证文件的大小是否小于一个内存页, 一般为 4kb</span></span><br><span class="line">            <span class="keyword">if</span> (m_segmentSize &lt; DEFAULT_MMAP_SIZE) &#123;</span><br><span class="line">                m_segmentSize = static_cast&lt;size_t&gt;(DEFAULT_MMAP_SIZE);</span><br><span class="line">                <span class="comment">// 3.1 通过 ftruncate 将文件大小对其到内存页</span></span><br><span class="line">                <span class="comment">// 3.2 通过 zeroFillFile 将文件对其后的空白部分用 0 填充</span></span><br><span class="line">                <span class="keyword">if</span> (ftruncate(m_fd, m_segmentSize) != <span class="number">0</span> || !zeroFillFile(m_fd, <span class="number">0</span>, m_segmentSize)) &#123;</span><br><span class="line">                    <span class="comment">// 说明文件拓展失败了, 移除这个文件</span></span><br><span class="line">                    close(m_fd);</span><br><span class="line">                    m_fd = -<span class="number">1</span>;</span><br><span class="line">                    removeFile(m_name);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 通过 mmap 将文件映射到内存, 获取内存首地址</span></span><br><span class="line">            m_segmentPtr =</span><br><span class="line">                (<span class="keyword">char</span> *) mmap(nullptr, m_segmentSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (m_segmentPtr == MAP_FAILED) &#123;</span><br><span class="line">                MMKVError(<span class="string">"fail to mmap [%s], %s"</span>, m_name.c_str(), strerror(errno));</span><br><span class="line">                close(m_fd);</span><br><span class="line">                m_fd = -<span class="number">1</span>;</span><br><span class="line">                m_segmentPtr = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于共享内存的文件</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MmapedFile 的构造函数处理的事务如下</p><ul><li>打开指定的文件</li><li>创建这个文件锁</li><li>修正文件大小, 最小为 4kb <ul><li>前 4kb 用于统计数据总大小</li></ul></li><li>通过 mmap 将文件映射到内存</li></ul><p>好的, 通过 MmapedFile 的构造函数, 我们便能够获取到映射后的内存首地址了, 操作这块内存时 Linux 内核会负责将内存中的数据同步到文件中</p><p>比起 SP 的数据同步, mmap 显然是要优雅的多, <strong>即使进程意外死亡, 也能够通过 Linux 内核的保护机制, 将进行了文件映射的内存数据刷入到文件中, 提升了数据写入的可靠性</strong></p><p>结下来看看数据的载入</p><h4 id="数据的载入"><a href="#数据的载入" class="headerlink" title="数据的载入"></a>数据的载入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MMKV.cpp</span><br><span class="line">void MMKV::loadFromFile() &#123;</span><br><span class="line">    </span><br><span class="line">    ......// 忽略匿名共享内存相关代码</span><br><span class="line">    </span><br><span class="line">    // 若已经进行了文件映射</span><br><span class="line">    if (m_metaFile.isFileValid()) &#123;</span><br><span class="line">        // 则获取相关数据</span><br><span class="line">        m_metaInfo.read(m_metaFile.getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取文件描述符</span><br><span class="line">    m_fd = open(m_path.c_str(), O_RDWR | O_CREAT, S_IRWXU);</span><br><span class="line">    if (m_fd &lt; 0) &#123;</span><br><span class="line">        MMKVError(&quot;fail to open:%s, %s&quot;, m_path.c_str(), strerror(errno));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 1. 获取文件大小</span><br><span class="line">        m_size = 0;</span><br><span class="line">        struct stat st = &#123;0&#125;;</span><br><span class="line">        if (fstat(m_fd, &amp;st) != -1) &#123;</span><br><span class="line">            m_size = static_cast&lt;size_t&gt;(st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        // 1.1 将文件大小对其到内存页的整数倍</span><br><span class="line">        if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 获取文件映射后的内存地址</span><br><span class="line">        m_ptr = (char *) mmap(nullptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0);</span><br><span class="line">        if (m_ptr == MAP_FAILED) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 3. 读取内存文件的前 32 位, 获取存储数据的真实大小</span><br><span class="line">            memcpy(&amp;m_actualSize, m_ptr, Fixed32Size);</span><br><span class="line">            ......</span><br><span class="line">            bool loadFromFile = false, needFullWriteback = false;</span><br><span class="line">            if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                // 4. 验证文件的长度</span><br><span class="line">                if (m_actualSize &lt; m_size &amp;&amp; m_actualSize + Fixed32Size &lt;= m_size) &#123;</span><br><span class="line">                    // 5. 验证文件 CRC 的正确性</span><br><span class="line">                    if (checkFileCRCValid()) &#123;</span><br><span class="line">                        loadFromFile = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 若不正确, 则回调异常 CRC 异常</span><br><span class="line">                        auto strategic = mmkv::onMMKVCRCCheckFail(m_mmapID);</span><br><span class="line">                        if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                            loadFromFile = true;</span><br><span class="line">                            needFullWriteback = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 回调文件长度异常</span><br><span class="line">                    auto strategic = mmkv::onMMKVFileLengthError(m_mmapID);</span><br><span class="line">                    if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                        writeAcutalSize(m_size - Fixed32Size);</span><br><span class="line">                        loadFromFile = true;</span><br><span class="line">                        needFullWriteback = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 6. 需要从文件获取数据</span><br><span class="line">            if (loadFromFile) &#123;</span><br><span class="line">                ......</span><br><span class="line">                // 构建输入缓存</span><br><span class="line">                MMBuffer inputBuffer(m_ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);</span><br><span class="line">                if (m_crypter) &#123;</span><br><span class="line">                    // 解密输入缓冲中的数据</span><br><span class="line">                    decryptBuffer(*m_crypter, inputBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">                // 从输入缓冲中将数据读入 m_dic</span><br><span class="line">                m_dic.clear();</span><br><span class="line">                MiniPBCoder::decodeMap(m_dic, inputBuffer);</span><br><span class="line">                // 构建输出数据</span><br><span class="line">                m_output = new CodedOutputData(m_ptr + Fixed32Size + m_actualSize,</span><br><span class="line">                                               m_size - Fixed32Size - m_actualSize);</span><br><span class="line">                // 进行重整回写, 剔除重复的数据</span><br><span class="line">                if (needFullWriteback) &#123;</span><br><span class="line">                    fullWriteback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            // 7. 说明文件中没有数据, 或者校验失败了</span><br><span class="line">            else &#123;</span><br><span class="line">                SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">                // 清空文件中的数据</span><br><span class="line">                if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                    writeAcutalSize(0);</span><br><span class="line">                &#125;</span><br><span class="line">                m_output = new CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size);</span><br><span class="line">                // 重新计算 CRC</span><br><span class="line">                recaculateCRCDigest();</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    m_needLoadFromFile = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 可以看到 loadFromFile 中对于 CRC 验证通过的文件, 会将文件中的数据读入到 m_dic 中缓存, 否则则会清空文件</p><ul><li><p>因此用户恶意修改文件之后, 会破坏 CRC 的值, 这个存储数据便会被作废, 这一点要尤为注意</p></li><li><p>从文件中读取数据到 m_dic 之后, 会将 mdic 回写到文件中</p><p>, 其重写的目的是为了剔除重复的数据 </p><ul><li>关于为什么会出现重复的数据, 在后面 encode 操作中再分析</li></ul></li></ul><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>到这里 MMKV 实例的构建就完成了, 有了 m_dic 这个内存缓存, 我们进行数据查询的效率就大大提升了</p><p>从最终的结果来看它与 SP 是一致的, 都是初次加载时会将文件中所有的数据加载到散列表中, 不过 MMKV 多了一步数据回写的操作, 因此当数据量比较大时, 对实例构建的速度有一定的影响</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 写入 1000 条数据之后, MMVK 和 SharedPreferences 实例化的时间对比</span><br><span class="line">E/TAG: create MMKV instance time is 4 ms</span><br><span class="line">E/TAG: create SharedPreferences instance time is 1 ms</span><br></pre></td></tr></table></figure><p>从结果上来看, MMVK 的确在实例构造速度上有一定的劣势, 不过得益于是将 m_dic 中的数据写入到 mmap 的内存, 其真正进行文件写入的时机由 Linux 内核决定, 再加上文件的页缓存机制, 所以速度上虽有劣势, 但不至于无法接受</p><h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p>关于 <strong>encode 即数据的添加与更新</strong>的流程, 这里以 encodeString 为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMKV</span> <span class="keyword">implements</span> <span class="title">SharedPreferences</span>, <span class="title">SharedPreferences</span>.<span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">encode</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encodeString(nativeHandle, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">encodeString</span><span class="params">(<span class="keyword">long</span> handle, String key, String value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看 native 层的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">namespace mmkv &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">MMKV_JNI jboolean <span class="title">encodeString</span><span class="params">(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue)</span> </span>&#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        <span class="comment">// 若是 value 非 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (oValue) &#123;</span><br><span class="line">            <span class="comment">// 通过 setStringForKey 函数, 将数据存入</span></span><br><span class="line">            string value = jstring2string(env, oValue);</span><br><span class="line">            <span class="keyword">return</span> (jboolean) kv-&gt;setStringForKey(value, key);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 若是 value 为 NULL, 则移除 key 对应的 value 值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            kv-&gt;removeValueForKey(key);</span><br><span class="line">            <span class="keyword">return</span> (jboolean) <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (jboolean) <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要分析一下 setStringForKey 这个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::setStringForKey(<span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 将数据编码成 ProtocolBuffer</span></span><br><span class="line">    auto data = MiniPBCoder::encodeDataWithObject(value);</span><br><span class="line">    <span class="comment">// 2. 更新键值对</span></span><br><span class="line">    <span class="keyword">return</span> setDataForKey(std::move(data), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要分为两步操作</p><ul><li>数据编码</li><li>更新键值对</li></ul><h4 id="数据的编码"><a href="#数据的编码" class="headerlink" title="数据的编码"></a>数据的编码</h4><p>MMKV 采用的是 ProtocolBuffer 编码方式, 这里就不做过多介绍了, 具体请查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fencoding" target="_blank" rel="noopener">Google 官方文档</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MiniPBCoder.cpp</span></span><br><span class="line">MMBuffer MiniPBCoder::getEncodeData(<span class="keyword">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建编码条目的集合</span></span><br><span class="line">    m_encodeItems = <span class="keyword">new</span> vector&lt;PBEncodeItem&gt;();</span><br><span class="line">    <span class="comment">// 2. 为集合填充数据</span></span><br><span class="line">    size_t index = prepareObjectForEncode(str);</span><br><span class="line">    PBEncodeItem *oItem = (index &lt; m_encodeItems-&gt;size()) ? &amp;(*m_encodeItems)[index] : nullptr;</span><br><span class="line">    <span class="keyword">if</span> (oItem &amp;&amp; oItem-&gt;compiledSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 开辟一个内存缓冲区, 用于存放编码后的数据</span></span><br><span class="line">        m_outputBuffer = <span class="keyword">new</span> MMBuffer(oItem-&gt;compiledSize);</span><br><span class="line">        <span class="comment">// 4. 创建一个编码操作对象</span></span><br><span class="line">        m_outputData = <span class="keyword">new</span> CodedOutputData(m_outputBuffer-&gt;getPtr(), m_outputBuffer-&gt;length());</span><br><span class="line">        <span class="comment">// 执行 protocolbuffer 编码, 并输出到缓冲区</span></span><br><span class="line">        writeRootObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用移动构造函数, 重新创建实例返回</span></span><br><span class="line">    <span class="keyword">return</span> move(*m_outputBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t MiniPBCoder::prepareObjectForEncode(<span class="keyword">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="comment">// 2.1 创建 PBEncodeItem 对象用来描述待编码的条目, 并添加到 vector 集合</span></span><br><span class="line">    m_encodeItems-&gt;push_back(PBEncodeItem());</span><br><span class="line">    <span class="comment">// 2.2 获取 PBEncodeItem 对象</span></span><br><span class="line">    PBEncodeItem *encodeItem = &amp;(m_encodeItems-&gt;back());</span><br><span class="line">    <span class="comment">// 2.3 记录索引位置</span></span><br><span class="line">    size_t index = m_encodeItems-&gt;size() - <span class="number">1</span>;</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 2.4 填充编码类型</span></span><br><span class="line">        encodeItem-&gt;type = PBEncodeItemType_String;</span><br><span class="line">        <span class="comment">// 2.5 填充要编码的数据</span></span><br><span class="line">        encodeItem-&gt;value.strValue = &amp;str;</span><br><span class="line">        <span class="comment">// 2.6 填充数据大小</span></span><br><span class="line">        encodeItem-&gt;valueSize = static_cast&lt;int32_t&gt;(str.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.7 计算编码后的大小</span></span><br><span class="line">    encodeItem-&gt;compiledSize = pbRawVarint32Size(encodeItem-&gt;valueSize) + encodeItem-&gt;valueSize;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 再未进行编码操作之前, 编码后的数据大小就已经确定好了, 并且将它保存在了 encodeItem-&gt;compiledSize 中, 接下来我们看看执行数据编码并输出到缓冲区的操作流程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MiniPBCoder.cpp</span></span><br><span class="line"><span class="keyword">void</span> MiniPBCoder::writeRootObject() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t index = <span class="number">0</span>, total = m_encodeItems-&gt;size(); index &lt; total; index++) &#123;</span><br><span class="line">        PBEncodeItem *encodeItem = &amp;(*m_encodeItems)[index];</span><br><span class="line">        <span class="keyword">switch</span> (encodeItem-&gt;type) &#123;</span><br><span class="line">            <span class="comment">// 主要关心编码 String</span></span><br><span class="line">            <span class="keyword">case</span> PBEncodeItemType_String: &#123;</span><br><span class="line">                m_outputData-&gt;writeString(*(encodeItem-&gt;value.strValue));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CodedOutputData.cpp</span></span><br><span class="line"><span class="keyword">void</span> CodedOutputData::writeString(<span class="keyword">const</span> string &amp;value) &#123;</span><br><span class="line">    size_t numberOfBytes = value.size();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1. 按照 varint 方式编码字符串长度, 会改变 m_position 的值</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;writeRawVarint32((int32_t) numberOfBytes);</span><br><span class="line">    <span class="comment">// 2. 将字符串的数据拷贝到编码好的长度后面</span></span><br><span class="line">    memcpy(m_ptr + m_position, ((uint8_t *) value.data()), numberOfBytes);</span><br><span class="line">    <span class="comment">// 更新 position 的值</span></span><br><span class="line">    m_position += numberOfBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 CodedOutputData 的 writeString 中按照 protocol buffer 进行了字符串的编码操作</p><p>其中 m_ptr 是上面开辟的内存缓冲区的地址, 也就是说 writeString 执行结束之后, 数据就已经被写入缓冲区了</p><p>有了编码好的数据缓冲区, 接下来看看更新键值对的操作</p><h4 id="键值对的更新"><a href="#键值对的更新" class="headerlink" title="键值对的更新"></a>键值对的更新</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::setStringForKey(<span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 编码数据获取存放数据的缓冲区</span></span><br><span class="line">    auto data = MiniPBCoder::encodeDataWithObject(value);</span><br><span class="line">    <span class="comment">// 更新键值对</span></span><br><span class="line">    <span class="keyword">return</span> setDataForKey(std::move(data), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将键值对写入 mmap 文件映射的内存中</span></span><br><span class="line">    auto ret = appendDataWithKey(data, key);</span><br><span class="line">    <span class="comment">// 写入成功, 更新散列数据</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        m_dic[key] = std::move(data);</span><br><span class="line">        m_hasFullWriteback = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MMKV::appendDataWithKey(<span class="keyword">const</span> MMBuffer &amp;data, <span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 1. 计算 key + value 的 ProtocolBuffer 编码后的长度</span></span><br><span class="line">    size_t keyLength = key.length();</span><br><span class="line">    size_t size = keyLength + pbRawVarint32Size((int32_t) keyLength);</span><br><span class="line">    size += data.length() + pbRawVarint32Size((int32_t) data.length());</span><br><span class="line">    SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 验证是否有足够的空间, 不足则进行数据重整与扩容操作</span></span><br><span class="line">    bool hasEnoughSize = ensureMemorySize(size);</span><br><span class="line">    <span class="keyword">if</span> (!hasEnoughSize || !isFileValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 更新文件头的数据总大小</span></span><br><span class="line">    writeAcutalSize(m_actualSize + size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 将 key 和编码后的 value 写入到文件映射的内存</span></span><br><span class="line">    m_output-&gt;writeString(key);</span><br><span class="line">    m_output-&gt;writeData(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 获取文件映射内存当前 &lt;key, value&gt; 的起始位置</span></span><br><span class="line">    auto ptr = (uint8_t *) m_ptr + Fixed32Size + m_actualSize - size;</span><br><span class="line">    <span class="keyword">if</span> (m_crypter) &#123;</span><br><span class="line">        <span class="comment">// 加密这块区域</span></span><br><span class="line">        m_crypter-&gt;encrypt(ptr, ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 更新 CRC</span></span><br><span class="line">    updateCRCDigest(ptr, size, KeepSequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的, 可以看到更新键值对的操作还是比较复杂的, 首先将键值对数据写入到文件映射的内存中, 写入成功之后更新散列数据</p><p>关于写入到文件映射的过程, 上面代码中的注释也非常的清晰, 接下来我们 ensureMemorySize 是如何进行数据的重整与扩容的</p><h5 id="数据的重整与扩容"><a href="#数据的重整与扩容" class="headerlink" title="数据的重整与扩容"></a>数据的重整与扩容</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::ensureMemorySize(size_t newSize) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 计算新键值对的大小</span></span><br><span class="line">    constexpr size_t ItemSizeHolderSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_dic.empty()) &#123;</span><br><span class="line">        newSize += ItemSizeHolderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据重写: </span></span><br><span class="line">    <span class="comment">// 1. 文件剩余空闲空间少于新的键值对</span></span><br><span class="line">    <span class="comment">// 2. 散列为空</span></span><br><span class="line">    <span class="keyword">if</span> (newSize &gt;= m_output-&gt;spaceLeft() || m_dic.empty()) &#123;</span><br><span class="line">        <span class="comment">// 计算所需的数据空间</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> offset = pbFixed32Size(<span class="number">0</span>);</span><br><span class="line">        MMBuffer data = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">        size_t lenNeeded = data.length() + offset + newSize;</span><br><span class="line">        <span class="keyword">if</span> (m_isAshmem) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="comment">// 计算每个键值对的平均大小</span></span><br><span class="line">            size_t avgItemSize = lenNeeded / std::max&lt;size_t&gt;(<span class="number">1</span>, m_dic.size());</span><br><span class="line">            <span class="comment">// 计算未来可能会使用的大小(类似于 1.5 倍)</span></span><br><span class="line">            size_t futureUsage = avgItemSize * std::max&lt;size_t&gt;(<span class="number">8</span>, (m_dic.size() + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 1. 所需空间 &gt;= 当前文件总大小</span></span><br><span class="line">            <span class="comment">// 2. 所需空间的 1.5 倍 &gt;= 当前文件总大小</span></span><br><span class="line">            <span class="keyword">if</span> (lenNeeded &gt;= m_size || (lenNeeded + futureUsage) &gt;= m_size) &#123;</span><br><span class="line">                <span class="comment">// 扩容为 2 倍</span></span><br><span class="line">                size_t oldSize = m_size;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    m_size *= <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (lenNeeded + futureUsage &gt;= m_size);</span><br><span class="line">                .......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 进行数据的重写</span></span><br><span class="line">        writeAcutalSize(data.length());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以了解到</p><ul><li>数据的重写时机<ul><li>文件剩余空间少于新的键值对大小</li><li>散列为空</li></ul></li><li>文件扩容时机<ul><li>所需空间的 1.5 倍超过了当前文件的总大小时, 扩容为之前的两倍</li></ul></li></ul><h4 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h4><p>至此 encode 的流程我们就走完了, 回顾一下整个 encode 的流程</p><ul><li><p>使用 ProtocolBuffer 编码 value</p></li><li><p>将 </p><p>key</p><p> 和 </p><p>编码后的 value</p><p> 使用 ProtocolBuffer 的格式 append 到文件映射区内存的尾部 </p><ul><li>文件空间不足 <ul><li>判断是否需要扩容</li><li>进行数据的回写</li></ul></li><li>即在文件后进行追加</li></ul></li><li><p>对这个键值对区域进行统一的加密</p></li><li><p>更新 CRC 的值</p></li><li><p>将 key 和 value 对应的 ProtocolBuffer 编码内存区域, 更新到散列表 m_dic 中</p></li></ul><p>通过 encode 的分析, 我们得知 MMKV 文件的存储方式如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212352.png" alt=""></p><p>接下来看看 decode 的流程</p><h2 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h2><p>decode 的过程同样以 decodeString 为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// native-bridge.cpp</span></span><br><span class="line">MMKV_JNI jstring</span><br><span class="line">decodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) &#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        <span class="comment">// 通过 getStringForKey, 将数据输出到传出参数中 value 中</span></span><br><span class="line">        string value;</span><br><span class="line">        bool hasValue = kv-&gt;getStringForKey(key, value);</span><br><span class="line">        <span class="keyword">if</span> (hasValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> string2jstring(env, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oDefaultValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MMKV.cpp</span></span><br><span class="line">bool MMKV::getStringForKey(<span class="keyword">const</span> std::string &amp;key, std::string &amp;result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPEDLOCK(m_lock);</span><br><span class="line">    <span class="comment">// 1. 从内存缓存中获取数据</span></span><br><span class="line">    auto &amp;data = getDataForKey(key);</span><br><span class="line">    <span class="keyword">if</span> (data.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 解析 data 对应的 ProtocolBuffer 数据</span></span><br><span class="line">        result = MiniPBCoder::decodeString(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MMBuffer &amp;MMKV::getDataForKey(<span class="keyword">const</span> std::string &amp;key) &#123;</span><br><span class="line">    <span class="comment">// 从散列表中获取 key 对应的 value</span></span><br><span class="line">    auto itr = m_dic.find(key);</span><br><span class="line">    <span class="keyword">if</span> (itr != m_dic.end()) &#123;</span><br><span class="line">        <span class="keyword">return</span> itr-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MMBuffer <span class="title">nan</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> nan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的可以看到 decode 的流程比较简单, 先从内存缓存中获取 key 对应的 value 的 ProtocolBuffer 内存区域, 再解析这块内存区域, 从中获取真正的 value 值</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>看到这里可能会有一个疑问, <strong>为什么 m_dic 不直接存储 key 和 value 原始数据呢, 这样查询效率不是更快吗?</strong></p><ul><li>如此一来查询效率的确会更快, 因为少了 ProtocolBuffer 解码的过程</li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212418.png" alt=""></p><p>从图上的结果可以看出, MMKV 的读取性能时略低于 SharedPreferences 的, 这里笔者给出自己的思考</p><ul><li><strong>m_dic 在数据重整中也起到了非常重要的作用, 需要依靠 m_dic 将数据写入到 mmap 的文件映射区</strong>, 这个过程是非常耗时的, 若是原始的 value, 则需要对所有的 value 再进行一次 ProtocolBuffer 编码操作, 尤其是当数据量比较庞大时, 其带来的性能损耗更是无法忽略的</li></ul><p>既然 m_dic 还承担着方便数据复写的功能, 那<strong>能否再添加一个内存缓存专门用于存储原始的 value 呢?</strong></p><ul><li>当然可以, 这样 MMKV 的读取定是能够达到 SharedPreferences 的水平, 不过 value 的内存消耗则会加倍, <strong>MMKV 作为一个轻量级缓存的框架, 查询时时间的提升幅度还不足以用内存加倍的代价去换取</strong>, 我想这是 Tencent 在进行多方面权衡之后, 得到的一个比较合理的解决方案</li></ul><h2 id="进程读写的同步"><a href="#进程读写的同步" class="headerlink" title="进程读写的同步"></a>进程读写的同步</h2><p>说起进程间读写同步, 我们很自然的想到 Linux 的共享内存配合信号量使用的案例, 但是这种方式有一个弊端, 那就是<strong>当持有锁的进程意外死亡的时候, 并不会释放其拥有的信号量, 若多进程之间存在竞争, 那么阻塞的进程将不会被唤醒</strong>, 这是非常危险的</p><p>MMKV 是采用 <strong>文件锁</strong> 的方式来进行进程间的同步操作</p><ul><li><strong>LOCK_SH(共享锁)</strong>: 多个进程可以使用同一把锁, 常被用作读共享锁</li><li><strong>LOCK_EX(排他锁)</strong>: 同时只允许一个进程使用, 常被用作写锁</li><li><strong>LOCK_UN</strong>: 释放锁</li></ul><p>接下来我看看 MMKV 加解锁的操作</p><h4 id="文件共享锁"><a href="#文件共享锁" class="headerlink" title="文件共享锁"></a>文件共享锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MMKV::MMKV(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;mmapID, <span class="keyword">int</span> size, MMKVMode mode, string *cryptKey, string *relativePath)</span><br><span class="line">    : m_mmapID(mmapedKVKey(mmapID, relativePath))</span><br><span class="line">    <span class="comment">// 创建文件锁的描述</span></span><br><span class="line">    , m_fileLock(m_metaFile.getFd())</span><br><span class="line">    <span class="comment">// 描述共享锁</span></span><br><span class="line">    , m_sharedProcessLock(&amp;m_fileLock, SharedLockType)</span><br><span class="line">    <span class="comment">// 描述排它锁</span></span><br><span class="line">    , m_exclusiveProcessLock(&amp;m_fileLock, ExclusiveLockType)</span><br><span class="line">    <span class="comment">// 判读是否为进程间通信</span></span><br><span class="line">    , m_isInterProcess((mode &amp; MMKV_MULTI_PROCESS) != <span class="number">0</span> || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != <span class="number">0</span>)</span><br><span class="line">    , m_isAshmem((mode &amp; MMKV_ASHMEM) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据是否跨进程操作判断共享锁和排它锁的开关</span></span><br><span class="line">    m_sharedProcessLock.m_enable = m_isInterProcess;</span><br><span class="line">    m_exclusiveProcessLock.m_enable = m_isInterProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sensitive zone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文件读操作, 启用了文件共享锁</span></span><br><span class="line">        SCOPEDLOCK(m_sharedProcessLock);</span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在我们前面分析过的构造函数中, MMKV 对文件锁进行了初始化, 并且创建了共享锁和排它锁, 并在跨进程操作时开启, 当进行读操作时, 启动了共享锁</p><h4 id="文件排它锁"><a href="#文件排它锁" class="headerlink" title="文件排它锁"></a>文件排它锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bool MMKV::fullWriteback() &#123;</span><br><span class="line">    ......</span><br><span class="line">    auto allData = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">    <span class="comment">// 启动了排它锁</span></span><br><span class="line">    SCOPEDLOCK(m_exclusiveProcessLock);</span><br><span class="line">    <span class="keyword">if</span> (allData.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allData.length() + Fixed32Size &lt;= m_size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_crypter) &#123;</span><br><span class="line">                m_crypter-&gt;reset();</span><br><span class="line">                auto ptr = (unsigned <span class="keyword">char</span> *) allData.getPtr();</span><br><span class="line">                m_crypter-&gt;encrypt(ptr, ptr, allData.length());</span><br><span class="line">            &#125;</span><br><span class="line">            writeAcutalSize(allData.length());</span><br><span class="line">            delete m_output;</span><br><span class="line">            m_output = <span class="keyword">new</span> CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size);</span><br><span class="line">            m_output-&gt;writeRawData(allData); <span class="comment">// note: don't write size of data</span></span><br><span class="line">            recaculateCRCDigest();</span><br><span class="line">            m_hasFullWriteback = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ensureMemorySize will extend file &amp; full rewrite, no need to write back again</span></span><br><span class="line">            <span class="keyword">return</span> ensureMemorySize(allData.length() + Fixed32Size - m_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行数据回写的函数中, 启动了排它锁</p><h4 id="读写效率表现"><a href="#读写效率表现" class="headerlink" title="读写效率表现"></a>读写效率表现</h4><p>其进程同步读写的性能表现如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190817212512.png" alt=""></p><p>可以看到进程同步读写的效率也是非常 nice 的</p><p>关于跨进程同步就介绍到这里, 当然 MMKV 的文件锁并没有表面上那么简单, 因为文件锁为状态锁, 无论加了多少次锁, 一个解锁操作就全解除, 显然无法应对子函数嵌套调用的问题, <strong>MMKV 内部通过了自行实现计数器来实现锁的可重入性</strong>, 更多的细节可以查看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_ipc" target="_blank" rel="noopener">wiki</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析, 我们对 MMKV 有了一个整体上的把控, 其具体的表现如下所示</p><table><thead><tr><th>项目</th><th>评价</th><th>描述</th></tr></thead><tbody><tr><td>正确性</td><td>优</td><td>支持多进程安全, 使用 mmap, 由操作系统保证数据回写的正确性</td></tr><tr><td>时间开销</td><td>优</td><td>使用 mmap 实现, 减少了用户空间数据到内核空间的拷贝</td></tr><tr><td>空间开销</td><td>中</td><td>使用 protocl buffer 存储数据, 同样的数据会比 xml 和 json 消耗空间小   使用的是数据追加到末尾的方式, 只有到达一定阈值之后才会触发键值合并, 不合并之前会导致同一个 key 存在多份</td></tr><tr><td>安全</td><td>中</td><td>使用 crc 校验, 甄别文件系统和操作系统不稳定导致的异常数据</td></tr><tr><td>开发成本</td><td>优</td><td>使用方式较为简单</td></tr><tr><td>兼容性</td><td>优</td><td>各个安卓版本都前后兼容</td></tr></tbody></table><p>虽然 MMKV 一些场景下比 SP 稍慢(如: 首次实例化会进行数据的复写剔除重复数据, 比 SP 稍慢, 查询数据时存在 ProtocolBuffer 解码, 比 SP 稍慢), 但其<strong>逆天的数据写入速度、mmap Linux 内核保证数据的同步, 以及 ProtocolBuffer 编码带来的更小的本地存储空间占用等都是非常棒的闪光点</strong></p><p>在分析 MMKV 的代码的过程中, 从中学习到了很多知识, 非常感谢 Tencent 为开源社区做出的贡献</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn" target="_blank" rel="noopener">github.com/Tencent/MMK…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fencoding" target="_blank" rel="noopener">developers.google.com/protocol-bu…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Farticle%2F76677" target="_blank" rel="noopener">time.geekbang.org/column/arti…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fkex1n%2Fp%2F7100107.html" target="_blank" rel="noopener">www.cnblogs.com/kex1n/p/710…</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;APP 的性能优化之路是永无止境的, 这里学习一个&lt;strong&gt;腾讯开源用于提升本地存储效率的轻量级存储框架&lt;/strong&gt; &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MMKV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR&lt;/p&gt;
&lt;p&gt;网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了&lt;/p&gt;
&lt;p&gt;因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架&lt;/p&gt;
&lt;h2 id=&quot;集成与测试&quot;&gt;&lt;a href=&quot;#集成与测试&quot; class=&quot;headerlink&quot; title=&quot;集成与测试&quot;&gt;&lt;/a&gt;集成与测试&lt;/h2&gt;&lt;p&gt;以下介绍简单的使用方式, 更多详情请查看 &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FTencent%2FMMKV%2Fwiki%2Fandroid_setup_cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;依赖注入&quot;&gt;&lt;a href=&quot;#依赖注入&quot; class=&quot;headerlink&quot; title=&quot;依赖注入&quot;&gt;&lt;/a&gt;依赖注入&lt;/h4&gt;&lt;p&gt;在 App 模块的 build.gradle 文件里添加:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.tencent:mmkv:1.0.22&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // replace &amp;quot;1.0.22&amp;quot; with any available version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;复制代码&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/categories/Android/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>BannerViewPage</title>
    <link href="https://zhangmiao.cc/posts/6831bdd1.html"/>
    <id>https://zhangmiao.cc/posts/6831bdd1.html</id>
    <published>2019-08-13T10:13:23.000Z</published>
    <updated>2019-08-13T10:17:35.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BannerViewPage"><a href="#BannerViewPage" class="headerlink" title="BannerViewPage"></a><a href="https://github.com/zhangmiaocc/BannerViewPage" target="_blank" rel="noopener">BannerViewPage</a></h1><p>Banner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/aaa.gif" alt=""></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BannerViewPage&quot;&gt;&lt;a href=&quot;#BannerViewPage&quot; class=&quot;headerlink&quot; title=&quot;BannerViewPage&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/zhangmiaocc/BannerViewPage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BannerViewPage&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;Banner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/aaa.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="View" scheme="https://zhangmiao.cc/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>关于OKR的解读</title>
    <link href="https://zhangmiao.cc/posts/5b77eb6.html"/>
    <id>https://zhangmiao.cc/posts/5b77eb6.html</id>
    <published>2019-07-31T06:56:33.000Z</published>
    <updated>2019-07-31T07:00:21.114Z</updated>
    
    <content type="html"><![CDATA[<p>OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。</p><p>具体拆解如下：</p><p>1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。</p><p>2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。</p><ul><li>以季度（或者其他预先规定的周期）为单位刷新OKR；</li><li>仔细确认结果达成情况；</li><li>如有必要，持续修正现行战略和商业模式；</li><li>结果导向。</li></ul><p>3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。</p><p>4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。</p><p>5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。</p><p>6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。&lt;/p&gt;
&lt;p&gt;具体拆解如下：&lt;/p&gt;
&lt;p&gt;1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。&lt;/p&gt;
&lt;p&gt;2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以季度（或者其他预先规定的周期）为单位刷新OKR；&lt;/li&gt;
&lt;li&gt;仔细确认结果达成情况；&lt;/li&gt;
&lt;li&gt;如有必要，持续修正现行战略和商业模式；&lt;/li&gt;
&lt;li&gt;结果导向。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。&lt;/p&gt;
&lt;p&gt;4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。&lt;/p&gt;
&lt;p&gt;5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。&lt;/p&gt;
&lt;p&gt;6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。&lt;/p&gt;
    
    </summary>
    
      <category term="awsome" scheme="https://zhangmiao.cc/categories/awsome/"/>
    
    
      <category term="awsome" scheme="https://zhangmiao.cc/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>什么是灰度发布，灰度测试</title>
    <link href="https://zhangmiao.cc/posts/5b196854.html"/>
    <id>https://zhangmiao.cc/posts/5b196854.html</id>
    <published>2019-07-30T07:36:54.000Z</published>
    <updated>2019-07-30T07:40:29.370Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是灰度发布？"><a href="#什么是灰度发布？" class="headerlink" title="什么是灰度发布？"></a>什么是灰度发布？</h4><p>灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><p>灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。</p><h4 id="灰度发布的意义"><a href="#灰度发布的意义" class="headerlink" title="灰度发布的意义"></a>灰度发布的意义</h4><p>灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。</p><h4 id="灰度发布步骤"><a href="#灰度发布步骤" class="headerlink" title="灰度发布步骤"></a>灰度发布步骤</h4><ol><li>定义目标</li><li>选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等</li><li>筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等</li><li>部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调</li><li>发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表</li><li>产品完善</li><li>新一轮灰度发布或完整发布</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是灰度发布？&quot;&gt;&lt;a href=&quot;#什么是灰度发布？&quot; class=&quot;headerlink&quot; title=&quot;什么是灰度发布？&quot;&gt;&lt;/a&gt;什么是灰度发布？&lt;/h4&gt;&lt;p&gt;灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。&lt;/p&gt;
&lt;p&gt;灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。&lt;/p&gt;
&lt;p&gt;灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。&lt;/p&gt;
&lt;h4 id=&quot;灰度发布的意义&quot;&gt;&lt;a href=&quot;#灰度发布的意义&quot; class=&quot;headerlink&quot; title=&quot;灰度发布的意义&quot;&gt;&lt;/a&gt;灰度发布的意义&lt;/h4&gt;&lt;p&gt;灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。&lt;/p&gt;
&lt;h4 id=&quot;灰度发布步骤&quot;&gt;&lt;a href=&quot;#灰度发布步骤&quot; class=&quot;headerlink&quot; title=&quot;灰度发布步骤&quot;&gt;&lt;/a&gt;灰度发布步骤&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;定义目标&lt;/li&gt;
&lt;li&gt;选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等&lt;/li&gt;
&lt;li&gt;筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等&lt;/li&gt;
&lt;li&gt;部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调&lt;/li&gt;
&lt;li&gt;发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表&lt;/li&gt;
&lt;li&gt;产品完善&lt;/li&gt;
&lt;li&gt;新一轮灰度发布或完整发布&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="awsome" scheme="https://zhangmiao.cc/categories/awsome/"/>
    
    
      <category term="awsome" scheme="https://zhangmiao.cc/tags/awsome/"/>
    
  </entry>
  
  <entry>
    <title>java.lang.ClassNotFoundException:&quot;org.apache.http.ProtocolVersion&quot;</title>
    <link href="https://zhangmiao.cc/posts/c7a54c5f.html"/>
    <id>https://zhangmiao.cc/posts/c7a54c5f.html</id>
    <published>2019-07-26T03:38:39.000Z</published>
    <updated>2019-07-26T03:46:34.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行项目遇到以下问题："><a href="#运行项目遇到以下问题：" class="headerlink" title="运行项目遇到以下问题："></a>运行项目遇到以下问题：</h3><blockquote><p>Caused by: java.lang.ClassNotFoundException: Didn’t find class “org.apache.http.ProtocolVersion” on path: DexPathList[[zip file “/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk”],nativeLibraryDirectories=[/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk!/lib/arm64-v8a, /system/lib64, /product/lib64]]</p></blockquote><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p><strong>1.在清单文件增加代码:</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:usesCleartextTraffic</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.在清单文件清单再加一句代码：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:usesCleartextTraffic</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">uses-library</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"org.apache.http.legacy"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:required</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，重新运行解决了.<br>最根本的做法是使用https进行接口访问，毕竟涉及数据的安全性。当然了，这需要服务器的支持。还有第三方sdk，也需要使用https。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;运行项目遇到以下问题：&quot;&gt;&lt;a href=&quot;#运行项目遇到以下问题：&quot; class=&quot;headerlink&quot; title=&quot;运行项目遇到以下问题：&quot;&gt;&lt;/a&gt;运行项目遇到以下问题：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Caused by: java.lang.ClassNotFoundException: Didn’t find class “org.apache.http.ProtocolVersion” on path: DexPathList[[zip file “/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk”],nativeLibraryDirectories=[/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk!/lib/arm64-v8a, /system/lib64, /product/lib64]]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决方案：&quot;&gt;&lt;a href=&quot;#解决方案：&quot; class=&quot;headerlink&quot; title=&quot;解决方案：&quot;&gt;&lt;/a&gt;解决方案：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.在清单文件增加代码:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;android:usesCleartextTraffic&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2.在清单文件清单再加一句代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;android:usesCleartextTraffic&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;uses-library&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;org.apache.http.legacy&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;android:required&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好了，重新运行解决了.&lt;br&gt;最根本的做法是使用https进行接口访问，毕竟涉及数据的安全性。当然了，这需要服务器的支持。还有第三方sdk，也需要使用https。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Exception" scheme="https://zhangmiao.cc/categories/Android/Exception/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Exception" scheme="https://zhangmiao.cc/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>GoogleMap使用介绍</title>
    <link href="https://zhangmiao.cc/posts/50fe3b5b.html"/>
    <id>https://zhangmiao.cc/posts/50fe3b5b.html</id>
    <published>2019-07-25T08:17:10.000Z</published>
    <updated>2019-07-25T08:48:12.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过本文，你可以知道如何使用 GoogleMap 相关 API、定位当前位置、获取当前所在城市、获取当前位置附近的地点、导航、地点搜索等内容。大致内容，可以查看如下思维导图。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/GoogleMapXmind.png" alt=""></p><a id="more"></a><h3 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a><strong>特别注意</strong>：</h3><p>demo 使用的 GoogleMap key 对应我自己电脑的 keystore，如果重新编译项目，生成的apk使用的是你的电脑的 keystore，和我的 keystore 是不一样的，所以要正常运行，</p><ol><li>直接下载我编译好的 apk；</li><li>用我的项目包名，和你自己的 keystore 的 SHA-1 去申请新的 GoogleMap key。（方法在下面，往下看哈）</li></ol><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>因为国内众所周知的网络问题，谷歌地图的页面加载和 API 的使用会出现无效的情况，如果你要使用或调试，首先要确保是可以科学上网的。</p><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>Android 设备，必须<strong>安装了 Google 服务</strong>。</p><h3 id="谷歌账号"><a href="#谷歌账号" class="headerlink" title="谷歌账号"></a>谷歌账号</h3><p>作为用户，不需要拥有或者登录你的 Google 账号。网络和 Google 服务正常即可。</p><p>作为开发者，必须拥有一个 Google 账号。要知道，谷歌地图是不开源的，要使用他的 API ，必须用你的包名，和编译 Android app 的 keystore 的 SHA-1，去申请App 对应的 Google Map Key。获取 Key 的教程官网讲得很详细，<a href="https://developers.google.com/maps/documentation/android-api/signup" target="_blank" rel="noopener">请看这里</a></p><p><a href="https://console.developers.google.com/project/_/apiui/credential" target="_blank" rel="noopener">Google API Console</a> 设置完成后，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190725162411.png" alt=""></p><p>设置好后，还要确保已经 <strong>Enable</strong>了对应的API，<strong>不然会出现数据访问不到的情况</strong>。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190725162433.png" alt=""></p><p>把这个 API key 填入 <em>AndroidManifest.xml</em> ：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.google.android.geo.API_KEY"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"your key"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Map-相关"><a href="#Map-相关" class="headerlink" title="Map 相关"></a>Map 相关</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><h5 id="初始化-Google-Map"><a href="#初始化-Google-Map" class="headerlink" title="初始化 Google Map"></a>初始化 Google Map</h5><h6 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h6><p>在你的布局文件里面，只需要如下方式声明一个 Fragment，这个 Fragment 是可以放在 LinearLayout 或 RelativeLayout 下面的。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/map"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">map:uiZoomControls</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">map:uiCompass</span> = <span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.google.android.gms.maps.SupportMapFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@id/layout_btn"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h6 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h6><p>在 <em>onCreate</em> 的时候，进行初始化操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> GoogleMap mMap;</span><br><span class="line">SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()</span><br><span class="line">        .findFragmentById(map);</span><br><span class="line">mapFragment.getMapAsync(<span class="keyword">new</span> OnMapReadyCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapReady</span><span class="params">(GoogleMap googleMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化完 GoogleMap</span></span><br><span class="line">        mMap = googleMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="确保-GoogleMap-实例化"><a href="#确保-GoogleMap-实例化" class="headerlink" title="确保 GoogleMap 实例化"></a>确保 GoogleMap 实例化</h5><p>在使用 GoogleMap 相关接口前，必须确保 GoogleMap 已经实例化，即已经在 <em>onMapReady</em>回调中获取了 GoogleMap实例。</p><h4 id="开关类"><a href="#开关类" class="headerlink" title="开关类"></a>开关类</h4><h5 id="定位按钮"><a href="#定位按钮" class="headerlink" title="定位按钮"></a>定位按钮</h5><p>定位功能必须获取用户的位置权限，判断是非获取了用户权限，没有获取则手动请求权限。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 检查定位权限，如果未授权则请求该权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  true：已经授权； false：未授权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkLocationPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_FINE_LOCATION)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="comment">// Permission to access the location is missing.</span></span><br><span class="line">        PermissionUtils.requestPermission(<span class="keyword">this</span>, LOCATION_PERMISSION_REQUEST_CODE,</span><br><span class="line">                Manifest.permission.ACCESS_FINE_LOCATION, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">requestPermission</span><span class="params">(FragmentActivity activity, <span class="keyword">int</span> requestId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String permission, <span class="keyword">boolean</span> finishActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) &#123;</span><br><span class="line">        <span class="comment">// Display a dialog with rationale.</span></span><br><span class="line">        PermissionUtils.RationaleDialog.newInstance(requestId, finishActivity)</span><br><span class="line">                .show(activity.getSupportFragmentManager(), <span class="string">"dialog"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Location permission has not been granted yet, request it.</span></span><br><span class="line">        ActivityCompat.requestPermissions(activity, <span class="keyword">new</span> String[]&#123;permission&#125;, requestId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让地图上显示开关按钮，只需要设置<code>mMap.setMyLocationEnabled(true);</code></p><p>点击此按钮，地图的摄像头就会开始移动，定位到当前设备所在位置，如果要获取点击此按钮的回调，可以设置监听器 <code>mMap.setOnMyLocationButtonClickListener</code></p><h5 id="放大／缩小按钮"><a href="#放大／缩小按钮" class="headerlink" title="放大／缩小按钮"></a>放大／缩小按钮</h5><p>地图的放大缩小，就以摄像头焦点（地图中心）进行缩放。要出现这个开关，只需要</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setZoomControlsEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h5 id="指南针按钮"><a href="#指南针按钮" class="headerlink" title="指南针按钮"></a>指南针按钮</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setCompassEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h5 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h5><ol><li><p>旋转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setRotateGesturesEnabled(mRotateGesturesEnabled);</span><br></pre></td></tr></table></figure></li><li><p>平移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UiSettings uiSettings = mMap.getUiSettings();</span><br><span class="line">uiSettings.setScrollGesturesEnabled(mScrollGesturesEnabled);</span><br></pre></td></tr></table></figure></li></ol><h4 id="自定义标注"><a href="#自定义标注" class="headerlink" title="自定义标注"></a>自定义标注</h4><h5 id="清除标注"><a href="#清除标注" class="headerlink" title="清除标注"></a>清除标注</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mMap.clear();</span><br></pre></td></tr></table></figure><h5 id="新增标注"><a href="#新增标注" class="headerlink" title="新增标注"></a>新增标注</h5><p>增加一个标注，只需要把当前的经纬度，图标，标题等信息传入 <em>MarkerOptions</em> ，之后在 <em>addMarker</em> 到 map对象即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LatLng latLng = <span class="keyword">new</span> LatLng(latitude, longitude);</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记当前坐标</span></span><br><span class="line">mMap.addMarker(<span class="keyword">new</span> MarkerOptions()</span><br><span class="line">        .position(latLng)</span><br><span class="line">        .icon(BitmapDescriptorFactory.fromResource(R.drawable.icon_position_small))</span><br><span class="line">        .title(getString(R.string.map_camera_center_location)));</span><br></pre></td></tr></table></figure><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><h5 id="当前位置"><a href="#当前位置" class="headerlink" title="当前位置"></a>当前位置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前摄像头中心点的坐标</span></span><br><span class="line"><span class="keyword">double</span> latitude = mMap.getCameraPosition().target.latitude;</span><br><span class="line"><span class="keyword">double</span> longitude = mMap.getCameraPosition().target.longitude;</span><br></pre></td></tr></table></figure><h5 id="移动相关监听"><a href="#移动相关监听" class="headerlink" title="移动相关监听"></a>移动相关监听</h5><ol><li><p>开始监听</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摄像头开始滑动监听</span></span><br><span class="line">mMap.setOnCameraMoveStartedListener(<span class="keyword">new</span> GoogleMap.OnCameraMoveStartedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraMoveStarted</span><span class="params">(<span class="keyword">int</span> reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reason == GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE) &#123;</span><br><span class="line">            <span class="comment">//表示摄像头移动是为了响应用户在地图上做出的手势，如平移、倾斜、通过捏合手指进行缩放或旋转地图</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reason == GoogleMap.OnCameraMoveStartedListener</span><br><span class="line">                .REASON_API_ANIMATION) &#123;</span><br><span class="line">            <span class="comment">//表示 API 移动摄像头是为了响应非手势用户操作，如点按 zoom 按钮、点按 My Location 按钮或点击标记</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reason == GoogleMap.OnCameraMoveStartedListener</span><br><span class="line">                .REASON_DEVELOPER_ANIMATION) &#123;</span><br><span class="line">            <span class="comment">//表示您的应用已发起摄像头移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></li><li><p>取消</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摄像头移动停止状态的监听</span></span><br><span class="line">mMap.setOnCameraIdleListener(<span class="keyword">new</span> GoogleMap.OnCameraIdleListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>停止</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摄像头移动中被取消时的监听</span></span><br><span class="line">mMap.setOnCameraMoveCanceledListener(<span class="keyword">new</span> GoogleMap.OnCameraMoveCanceledListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraMoveCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="点击监听"><a href="#点击监听" class="headerlink" title="点击监听"></a>点击监听</h4><h5 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击地图上某个坐标</span></span><br><span class="line">mMap.setOnMapClickListener(<span class="keyword">new</span> GoogleMap.OnMapClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapClick</span><span class="params">(LatLng latLng)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MapActivity.<span class="keyword">this</span>,</span><br><span class="line">                getString(R.string.map_click_tip, latLng.latitude, latLng.longitude),</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="长按"><a href="#长按" class="headerlink" title="长按"></a>长按</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//长按地图上某个坐标</span></span><br><span class="line">mMap.setOnMapLongClickListener(<span class="keyword">new</span> GoogleMap.OnMapLongClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapLongClick</span><span class="params">(LatLng latLng)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MapActivity.<span class="keyword">this</span>,</span><br><span class="line">                getString(R.string.map_long_click_tip, latLng.latitude, latLng.longitude),</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="点击景点"><a href="#点击景点" class="headerlink" title="点击景点"></a>点击景点</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击地图上某个景点</span></span><br><span class="line">mMap.setOnPoiClickListener(<span class="keyword">new</span> GoogleMap.OnPoiClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPoiClick</span><span class="params">(PointOfInterest pointOfInterest)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MapActivity.<span class="keyword">this</span>,</span><br><span class="line">                getString(R.string.map_place_click_tip, pointOfInterest.name, pointOfInterest.placeId, pointOfInterest.latLng.latitude, pointOfInterest.latLng.longitude),</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>快照分两种，一种是直接不管地图有没有加载完，就把当前的地图截屏，如果此时地图未加载完，截取的图片会出现模糊的情况；另外一种是判断地图是否在加载中，如果是，则等加载完毕再截图，如果不是，就直接截图。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否等待地图加载完毕</span></span><br><span class="line"><span class="keyword">if</span> (mWaitForMapLoaded) &#123;</span><br><span class="line">    <span class="comment">//获取加载完的高清图片</span></span><br><span class="line">    mMap.setOnMapLoadedCallback(<span class="keyword">new</span> GoogleMap.OnMapLoadedCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMapLoaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != mMap) &#123;</span><br><span class="line">                mMap.snapshot(<span class="keyword">new</span> GoogleMap.SnapshotReadyCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSnapshotReady</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//获取bitmap</span></span><br><span class="line">                    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//未加载完，就执行快照功能，会导致截取模糊图片</span></span><br><span class="line">    mMap.snapshot(<span class="keyword">new</span> GoogleMap.SnapshotReadyCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSnapshotReady</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取bitmap</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GoogleApiClient"><a href="#GoogleApiClient" class="headerlink" title="GoogleApiClient"></a>GoogleApiClient</h3><h4 id="前提-1"><a href="#前提-1" class="headerlink" title="前提"></a>前提</h4><ol><li><p>初始化 GoogleApiClient</p><p>在 onCreate 的时候进行初始化操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 google client 用于获取地点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createGoogleApiClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGoogleApiClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mGoogleApiClient = <span class="keyword">new</span> GoogleApiClient</span><br><span class="line">                .Builder(<span class="keyword">this</span>)</span><br><span class="line">                .addApi(Places.GEO_DATA_API)</span><br><span class="line">                .addApi(Places.PLACE_DETECTION_API)</span><br><span class="line">                .addApi(LocationServices.API)</span><br><span class="line">                .addConnectionCallbacks(<span class="keyword">new</span> GoogleApiClient.ConnectionCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnected</span><span class="params">(@Nullable Bundle bundle)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接成功</span></span><br><span class="line">                        mConnected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionSuspended</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接暂停</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .addOnConnectionFailedListener(<span class="keyword">new</span> GoogleApiClient.OnConnectionFailedListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionFailed</span><span class="params">(@NonNull ConnectionResult connectionResult)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接失败</span></span><br><span class="line">                        mConnected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .enableAutoManage(<span class="keyword">this</span>, <span class="keyword">new</span> GoogleApiClient.OnConnectionFailedListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionFailed</span><span class="params">(@NonNull ConnectionResult connectionResult)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//连接失败</span></span><br><span class="line">                        mConnected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 onStart() 的时候连接，在 onStop() 的时候，断开连接。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mGoogleApiClient) &#123;</span><br><span class="line">        mGoogleApiClient.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mGoogleApiClient) &#123;</span><br><span class="line">        mGoogleApiClient.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用位置相关 API 的前提，必须确保用户授予位置权限。方法同上的 <em>checkLocationPermission()</em></p></li></ol><h4 id="获取当前定位的经纬度坐标"><a href="#获取当前定位的经纬度坐标" class="headerlink" title="获取当前定位的经纬度坐标"></a>获取当前定位的经纬度坐标</h4><h5 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h5><ul><li><p>WGS-84</p><p>国际标准的坐标系，国际标准的 GPS 设备定位获取的就是这种坐标。简称 <strong>地球坐标系</strong>。</p></li><li><p>GCJ-02</p><p>在我们国家，据说是为了保密，我们不使用 WGS-84 坐标，而是使用经过加密的 GCJ-02，高德地图，谷歌地图（国内板块）都是使用这个坐标系。这个就是俗称的 <strong>火星坐标系</strong>。</p></li><li><p>其他坐标系</p><p>比如百度地图，他用的是他们家的 BD-09 坐标，这个只适用于百度相关产品。搜狗地图也有自己的坐标。</p></li><li><p>格式<br>注意到谷歌地图的坐标是 latitude, longitude 格式，即 纬度，经度 格式。和国内的百度，高德坐标写法是反过来的。国内的一般是 经度，纬度 的方式。</p></li></ul><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Location lastLocation = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != lastLocation) &#123;</span><br><span class="line">    <span class="keyword">double</span> latitude = lastLocation.getLatitude();</span><br><span class="line">    <span class="keyword">double</span> longitude = lastLocation.getLongitude();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始我也以为这么简单就可以了，在测试设备上确实可以获取到坐标，但是实际上，大多数情况，在第一次运行定位的时候，获取的 Location 对象是为null。所以还需要注册位置变化的监听。等监听到位置信息后，移除此监听，防止不断监听引起高耗电现象。这部分百度地图用得很方便，他封装好了，但是谷歌地图就要自己实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> UPDATE_INTERVAL = <span class="number">10</span> * <span class="number">1000</span>;  <span class="comment">/* 10 secs */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> FASTEST_INTERVAL = <span class="number">1500</span>; <span class="comment">/* 1.5 sec */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TIME = <span class="number">2</span>; <span class="comment">//最多定位次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != lastLocation) &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果获取不到位置信息，注册位置变化监听</span></span><br><span class="line">regLocationUpdates();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">regLocationUpdates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkLocationPermission()) &#123;</span><br><span class="line">        showContentText(getString(R.string.cilent_permission_failed));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LocationRequest locationRequest = LocationRequest.create()</span><br><span class="line">            .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)</span><br><span class="line">            .setInterval(UPDATE_INTERVAL)</span><br><span class="line">            .setFastestInterval(FASTEST_INTERVAL);</span><br><span class="line"></span><br><span class="line">    LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient,</span><br><span class="line">            locationRequest, <span class="keyword">new</span> LocationListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLocationChanged</span><span class="params">(Location location)</span> </span>&#123;</span><br><span class="line">                    time++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果获取到位置信息，则移除位置变化监听</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != location) &#123;</span><br><span class="line">                        LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, <span class="keyword">this</span>);</span><br><span class="line">                        <span class="comment">//获取定位的经纬度</span></span><br><span class="line">                        <span class="keyword">double</span> latitude = location.getLatitude();</span><br><span class="line">                        <span class="keyword">double</span> longitude = location.getLongitude();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果超过最大的定位次数则停止位置变化监听</span></span><br><span class="line">                    <span class="keyword">if</span> (time == MAX_TIME) &#123;</span><br><span class="line">                        <span class="comment">//移除位置变化监听</span></span><br><span class="line">                        LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//获取当前位置失败</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在终于获取到定位坐标了，等等，好像不太对，这个坐标和我实际位置好像有不少的偏差…..我打开了 GoogleMap 这个官方的 APP，点击了他的定位。这下就懵逼了，怎么官方的这个是没问题了，误差很小….</p><p>我明明用的是 GoogleMap 的 API，为什么定位会不一样？</p><p>原因在刚才的坐标系里面，谷歌地图的国内板块是用 GCJ-02，但是定位 API 获取的坐标是国际标准坐标 WGS-84，所以需要把 WGS-84 转化 GCJ-02。</p><p>那谷歌地图 APP 上为什么可以呢？</p><p>我猜测，谷歌地图在访问网络的时候，会进行位置判断，如果是国内坐标，就进行转换，国外坐标就不转换。</p><p><strong>WGS-84 转化 GCJ-02 方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> a = <span class="number">6378245.0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> ee = <span class="number">0.00669342162296594323</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把 WGS-84 转换成 GCJ-02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wgLoc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LatLng <span class="title">transformFromWGSToGCJ</span><span class="params">(LatLng wgLoc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果在国外，则默认不进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (outOfChina(wgLoc.latitude, wgLoc.longitude)) &#123;</span><br><span class="line">        <span class="comment">//return new LatLng(wgLoc.latitude, wgLoc.longitude);</span></span><br><span class="line">        <span class="keyword">return</span> wgLoc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> dLat = transformLat(wgLoc.longitude - <span class="number">105.0</span>,</span><br><span class="line">            wgLoc.latitude - <span class="number">35.0</span>);</span><br><span class="line">    <span class="keyword">double</span> dLon = transformLon(wgLoc.longitude - <span class="number">105.0</span>,</span><br><span class="line">            wgLoc.latitude - <span class="number">35.0</span>);</span><br><span class="line">    <span class="keyword">double</span> radLat = wgLoc.latitude / <span class="number">180.0</span> * Math.PI;</span><br><span class="line">    <span class="keyword">double</span> magic = Math.sin(radLat);</span><br><span class="line">    magic = <span class="number">1</span> - ee * magic * magic;</span><br><span class="line">    <span class="keyword">double</span> sqrtMagic = Math.sqrt(magic);</span><br><span class="line">    dLat = (dLat * <span class="number">180.0</span>)/ ((a * (<span class="number">1</span> - ee)) / (magic * sqrtMagic) * Math.PI);</span><br><span class="line">    dLon = (dLon * <span class="number">180.0</span>) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LatLng(wgLoc.latitude + dLat, wgLoc.longitude + dLon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">transformLat</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = -<span class="number">100.0</span> + <span class="number">2.0</span> * x + <span class="number">3.0</span> * y + <span class="number">0.2</span> * y * y + <span class="number">0.1</span> * x * y</span><br><span class="line">            + <span class="number">0.2</span> * Math.sqrt(x &gt; <span class="number">0</span> ? x : -x);</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(<span class="number">6.0</span> * x * Math.PI) + <span class="number">20.0</span> * Math.sin(<span class="number">2.0</span> * x</span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(y * Math.PI) + <span class="number">40.0</span> * Math.sin(y / <span class="number">3.0</span></span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">160.0</span> * Math.sin(y / <span class="number">12.0</span> * Math.PI) + <span class="number">320</span> * Math.sin(y</span><br><span class="line">            * Math.PI / <span class="number">30.0</span>)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">transformLon</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">300.0</span> + x + <span class="number">2.0</span> * y + <span class="number">0.1</span> * x * x + <span class="number">0.1</span> * x * y + <span class="number">0.1</span></span><br><span class="line">            * Math.sqrt(x &gt; <span class="number">0</span> ? x : -x);</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(<span class="number">6.0</span> * x * Math.PI) + <span class="number">20.0</span> * Math.sin(<span class="number">2.0</span> * x</span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">20.0</span> * Math.sin(x * Math.PI) + <span class="number">40.0</span> * Math.sin(x / <span class="number">3.0</span></span><br><span class="line">            * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    ret += (<span class="number">150.0</span> * Math.sin(x / <span class="number">12.0</span> * Math.PI) + <span class="number">300.0</span> * Math.sin(x</span><br><span class="line">            / <span class="number">30.0</span> * Math.PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否在中国以外</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">outOfChina</span><span class="params">(<span class="keyword">double</span> lat, <span class="keyword">double</span> lon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lon &lt; <span class="number">72.004</span> || lon &gt; <span class="number">137.8347</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (lat &lt; <span class="number">0.8293</span> || lat &gt; <span class="number">55.8271</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据经纬度获取附近地点"><a href="#根据经纬度获取附近地点" class="headerlink" title="根据经纬度获取附近地点"></a>根据经纬度获取附近地点</h4><p>通过经纬度获取对应的地理位置信息，这个叫做<strong>反地理编码请求</strong>，以前百度地图有个 API <code>mGeoCoder.reverseGeoCode(mReverseGeoCodeOption);</code>可以直接使用，Google地图也有类似的，只不过在我使用过程中存在 bug。</p><p>心急想马上能用的，可以自己调到 <strong>Web API</strong> 中的 【根据经纬度获取附近地点】章节。</p><p>此处存在的问题：如果坐标切换为国外，就会造成获取数据为null。即使修改地区 mGeocoder = new Geocoder(this, Locale.JAPAN) 也无效。</p><ol><li><p>初始化 <strong>Geocoder</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mGeocoder = <span class="keyword">new</span> Geocoder(<span class="keyword">this</span>, Locale.getDefault());</span><br><span class="line"><span class="comment">//设置区域</span></span><br><span class="line"><span class="comment">//mGeocoder = new Geocoder(this, Locale.JAPAN);</span></span><br></pre></td></tr></table></figure></li><li><p>在子线程获取数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Address&gt; addressList =  mGeocoder.getFromLocation(latitude, longitude, maxResult);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != addressList &amp;&amp; addressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历获取附近地点信息</span></span><br><span class="line">    <span class="keyword">for</span> (Address address : addressList) &#123;</span><br><span class="line">    <span class="comment">//省</span></span><br><span class="line">    String adminArea = address.getAdminArea();</span><br><span class="line">    <span class="comment">//市</span></span><br><span class="line">    String city = address.getLocality();</span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    String feature = address.getFeatureName();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//获取附近地点失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="startActivity方式"><a href="#startActivity方式" class="headerlink" title="startActivity方式"></a>startActivity方式</h3><h4 id="地点搜索"><a href="#地点搜索" class="headerlink" title="地点搜索"></a>地点搜索</h4><ol><li><p>打开 Activity</p><p><code>private static final int REQUEST_CODE_AUTOCOMPLETE = 2;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开搜索的 Activity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openAutocompleteActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// MODE_FULLSCREEN 全屏方式启动一个 Activity</span></span><br><span class="line">        <span class="comment">// MODE_OVERLAY 启动浮在界面上的控件</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> PlaceAutocomplete.IntentBuilder(PlaceAutocomplete.MODE_OVERLAY)</span><br><span class="line">                .build(<span class="keyword">this</span>);</span><br><span class="line">        startActivityForResult(intent, REQUEST_CODE_AUTOCOMPLETE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GooglePlayServicesRepairableException e) &#123;</span><br><span class="line">        GoogleApiAvailability.getInstance().getErrorDialog(<span class="keyword">this</span>, e.getConnectionStatusCode(), <span class="number">0</span>).show();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GooglePlayServicesNotAvailableException e) &#123;</span><br><span class="line">        String message = <span class="string">"Google Play Services is not available: "</span> +</span><br><span class="line">                GoogleApiAvailability.getInstance().getErrorString(e.errorCode);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, message, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <em>onActivityResult</em> 回调中获取搜索的地点信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (requestCode == REQUEST_CODE_AUTOCOMPLETE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                Place place = PlaceAutocomplete.getPlace(<span class="keyword">this</span>, data);</span><br><span class="line">                String placeText = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != place) &#123;</span><br><span class="line">                    placeText = <span class="string">"place.getId() = "</span> + place.getId()</span><br><span class="line">                              + <span class="string">"\nplace.getName() = "</span> + place.getName()</span><br><span class="line">                              + <span class="string">"\nplace.getLatLng().latitude = "</span> + place.getLatLng().latitude</span><br><span class="line">                              + <span class="string">"\nplace.getLatLng().longitude = "</span> + place.getLatLng().longitude</span><br><span class="line">                              + <span class="string">"\nplace.getAddress() = "</span> +place.getAddress()</span><br><span class="line">                              + <span class="string">"\nplace.getPhoneNumber() = "</span> + place.getPhoneNumber()</span><br><span class="line">                              + <span class="string">"\nplace.getLocale() = "</span> + place.getLocale()</span><br><span class="line">                              + <span class="string">"\n......."</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, getString(R.string.start_by_activity_btn_search_place_result, placeText), Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultCode == PlaceAutocomplete.RESULT_ERROR) &#123;</span><br><span class="line">            <span class="comment">//错误码</span></span><br><span class="line">                Status status = PlaceAutocomplete.getStatus(<span class="keyword">this</span>, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultCode == RESULT_CANCELED) &#123;</span><br><span class="line">            <span class="comment">//取消</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启导航</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNavigation</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Uri gmmIntentUri = Uri.parse(<span class="string">"google.navigation:q="</span>+latitude+<span class="string">","</span>+longitude+<span class="string">"&amp;mode=d"</span>);</span><br><span class="line">        Intent mapIntent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, gmmIntentUri);</span><br><span class="line">        mapIntent.setPackage(<span class="string">"com.google.android.apps.maps"</span>);</span><br><span class="line">        startActivity(mapIntent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//提示未安装google map</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//开启google map下载界面</span></span><br><span class="line">        showGoogleMapDownloadView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启google map下载界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showGoogleMapDownloadView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"market://details?id=com.google.android.apps.maps"</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri);</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附近地点"><a href="#附近地点" class="headerlink" title="附近地点"></a>附近地点</h4><ol><li><p>获取定位权限</p><p>获取方法和前面一样，使用 <em>checkLocationPermission()</em></p></li><li><p>打开 Activity，开启附近地点选择</p><p><code>private static final int PLACE_PICKER_REQUEST = 3;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PlacePicker.IntentBuilder builder = <span class="keyword">new</span> PlacePicker.IntentBuilder();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    startActivityForResult(builder.build(<span class="keyword">this</span>), PLACE_PICKER_REQUEST);</span><br><span class="line">&#125; <span class="keyword">catch</span> (GooglePlayServicesRepairableException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (GooglePlayServicesNotAvailableException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 onActivityResult 获取选择的地点信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (requestCode == PLACE_PICKER_REQUEST) &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">          Place place = PlacePicker.getPlace(<span class="keyword">this</span>, data);</span><br><span class="line">          <span class="comment">//place.getName() .... </span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Places"><a href="#Places" class="headerlink" title="Places"></a>Places</h2><h3 id="当前位置及附近地点"><a href="#当前位置及附近地点" class="headerlink" title="当前位置及附近地点"></a>当前位置及附近地点</h3><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mMaxEntries = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前位置及附近地点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCurrentPlaces</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mConnected) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkLocationPermission()) &#123;</span><br><span class="line">    <span class="comment">//未授权定位</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PendingResult&lt;PlaceLikelihoodBuffer&gt; result = Places.PlaceDetectionApi</span><br><span class="line">            .getCurrentPlace(mGoogleApiClient, <span class="keyword">null</span>);</span><br><span class="line">    result.setResultCallback(<span class="keyword">new</span> ResultCallback&lt;PlaceLikelihoodBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(@NonNull PlaceLikelihoodBuffer likelyPlaces)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            String[] likelyPlaceNames = <span class="keyword">new</span> String[mMaxEntries];</span><br><span class="line">            String[] likelyPlaceAddresses = <span class="keyword">new</span> String[mMaxEntries];</span><br><span class="line">            String[] likelyPlaceAttributions = <span class="keyword">new</span> String[mMaxEntries];</span><br><span class="line">            LatLng[] likelyPlaceLatLngs = <span class="keyword">new</span> LatLng[mMaxEntries];</span><br><span class="line">            <span class="keyword">for</span> (PlaceLikelihood placeLikelihood : likelyPlaces) &#123;</span><br><span class="line">                <span class="comment">// Build a list of likely places to show the user. Max 5.</span></span><br><span class="line">                likelyPlaceNames[i] = (String) placeLikelihood.getPlace().getName();</span><br><span class="line">                likelyPlaceAddresses[i] = (String) placeLikelihood.getPlace().getAddress();</span><br><span class="line">                likelyPlaceAttributions[i] = (String) placeLikelihood.getPlace()</span><br><span class="line">                        .getAttributions();</span><br><span class="line">                likelyPlaceLatLngs[i] = placeLikelihood.getPlace().getLatLng();</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//String placeId = (String) placeLikelihood.getPlace().getId();</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &gt; (mMaxEntries - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            likelyPlaces.release();</span><br><span class="line"></span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String placeName : likelyPlaceNames) &#123;</span><br><span class="line">                builder.append(placeName + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//显示地点列表</span></span><br><span class="line">            <span class="comment">//builder.toString()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据-PlaceID-获取对应地点"><a href="#根据-PlaceID-获取对应地点" class="headerlink" title="根据 PlaceID 获取对应地点"></a>根据 PlaceID 获取对应地点</h3><p>在 <em>onResult</em> 返回的 places 一般只有一个，所以取第一个元素，就是 id 对应的地点信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过placeId获取对应的位置信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> placeId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">getPlaceById</span><span class="params">(String placeId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(placeId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Places.GeoDataApi.getPlaceById(mGoogleApiClient, placeId)</span><br><span class="line">            .setResultCallback(<span class="keyword">new</span> ResultCallback&lt;PlaceBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(PlaceBuffer places)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (places.getStatus().isSuccess() &amp;&amp; places.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Place myPlace = places.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="comment">//获取id对应的Place</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//没有获取到数据</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    places.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h2><p>这里说的 Web API 是指：通过拼接 url 的方式，向 Google 服务器请求数据，服务器会返回一段 JSON，我们本地再用 fastjson 解析，获取对应的数据。</p><h3 id="根据坐标获取所在城市"><a href="#根据坐标获取所在城市" class="headerlink" title="根据坐标获取所在城市"></a>根据坐标获取所在城市</h3><p>这里的 URL 可以这样拼接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GOOGLE_MAP_URL = <span class="string">"https://maps.google.com/maps/api/geocode/json?language=%1$s&amp;sensor=true&amp;latlng=%2$s,%3$s"</span>;</span><br></pre></td></tr></table></figure><p>其中 <em>%1$s</em> 对应的是语言，比如我要返回的是中文，那么对于的就是 <em>zh-CN</em>，<em>%2$s %3$s</em> 对应的就是纬度和经度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LANGUAGE = <span class="string">"zh-CN"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拼接url(默认设置语言为中文)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getGoogleMapUrl</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(GOOGLE_MAP_URL, DEFAULT_LANGUAGE, Double.valueOf(latitude), Double.valueOf(longitude));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，外面只需要直接调这个方法，参数传入纬度、经度，就会返回拼接好的 URL。</p><p>获取了 URL，我们就可以异步访问网络，去获取数据了。这里主要讲下思路，详细代码，可以自己查看 <a href="https://github.com/ansuote/GoogleMapDemo" target="_blank" rel="noopener">Demo</a>。</p><p>以Demo为例，拼接的URL为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//maps.google.com/maps/api/geocode/json?language=zh-CN&amp;sensor=true&amp;latlng=22.536817569098282,113.97451490163802</span></span><br></pre></td></tr></table></figure><p>获取的 JSON 如下</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"results"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"address_components"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"9028"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"9028"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"street_number"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"深南大道"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"深南大道"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"route"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"华侨城"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"华侨城"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"neighborhood"</span>,</span><br><span class="line">                        <span class="string">"political"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"南山区"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"南山区"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"political"</span>,</span><br><span class="line">                        <span class="string">"sublocality"</span>,</span><br><span class="line">                        <span class="string">"sublocality_level_1"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"深圳市"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"深圳市"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"locality"</span>,</span><br><span class="line">                        <span class="string">"political"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"long_name"</span>: <span class="string">"广东省"</span>,</span><br><span class="line">                    <span class="attr">"short_name"</span>: <span class="string">"广东省"</span>,</span><br><span class="line">                    <span class="attr">"types"</span>: [</span><br><span class="line">                        <span class="string">"administrative_area_level_1"</span>,</span><br><span class="line">                        <span class="string">"political"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                /**</span><br><span class="line">                 * 篇幅原因，省略其余数据</span><br><span class="line">                 */</span><br><span class="line">    <span class="string">"status"</span>: <span class="string">"OK"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 type 对应的值是 <strong>locality</strong> 的就是<strong>城市名字</strong>，<strong>political</strong> 代表<strong>政治实体</strong>。</p><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据经纬度获取对应的城市</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCityByLatlngWeb</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    String urlString = GoogleMapUrlUtil.getGoogleMapUrl(latitude, longitude);</span><br><span class="line">    <span class="keyword">if</span> (URLUtil.isNetworkUrl(urlString)) &#123;</span><br><span class="line">        <span class="keyword">new</span> GeocodeTask().execute(urlString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeocodeTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">JSONObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> com.alibaba.fastjson.<span class="function">JSONObject <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//请求网络，并且转化为 JSONObject 对象</span></span><br><span class="line">        <span class="keyword">return</span> GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(com.alibaba.fastjson.JSONObject result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != result) &#123;</span><br><span class="line">            JSONArray jsonArray = result.getJSONArray(<span class="string">"results"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jsonArray) &#123;</span><br><span class="line">                Object firstObj = jsonArray.get(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != firstObj) &#123;</span><br><span class="line">                    GeocodeBean bean = JSON.parseObject(firstObj.toString(), GeocodeBean.class);</span><br><span class="line">                    <span class="comment">//获取所在城市</span></span><br><span class="line">                    String city = getLocality(bean);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeocodeBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;AddressComponent&gt; address_components;</span><br><span class="line">    <span class="keyword">private</span> String formatted_address;</span><br><span class="line">    <span class="comment">//geometry</span></span><br><span class="line">    <span class="keyword">private</span> String place_id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; types;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//set, get 方法自己补充哈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据集里面获取所在城市</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getLocality</span><span class="params">(GeocodeBean bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != bean) &#123;</span><br><span class="line">        List&lt;AddressComponent&gt; list = bean.getAddress_components();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != list) &#123;</span><br><span class="line">            <span class="keyword">for</span> (AddressComponent address : list) &#123;</span><br><span class="line">                List&lt;String&gt; types = address.getTypes();</span><br><span class="line">                <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"locality"</span>.equals(type)) &#123;</span><br><span class="line">                        isFound = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isFound) &#123;</span><br><span class="line">                    <span class="keyword">return</span> address.getShort_name();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据经纬度获取附近地点-1"><a href="#根据经纬度获取附近地点-1" class="headerlink" title="根据经纬度获取附近地点"></a>根据经纬度获取附近地点</h3><p>前面获取对应城市中用的 URL 很方便，基本上没有限制。但是获取附近地点的就没这么好了，在拼接 URL 的时候，需要加上谷歌授权给你的 <em>Web API key</em>。这个是官方推荐的做法，详情可以查看<a href="https://developers.google.com/maps/documentation/geocoding/intro" target="_blank" rel="noopener">官网的介绍</a></p><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>这里有一点要特别注意的，这里说的 <em>Web API key</em> 必须要重新申请的。之前我们使用 GoogleMap 的时候已经申请了 KEY，但是选项选择的是<strong>【Android apps】</strong>，只是作用于 Android Map 相关 API，这个时候访问 Web API 必须重新申请多一个 KEY。申请方法和前面一样，只是选项为<strong>【None】</strong>即可。</p><p>设置完之后如果一般间隔几分钟就可以调用，如果不行，就要手动开启服务。<a href="https://console.developers.google.com/apis/api/places_backend?project=_" target="_blank" rel="noopener">点击此处开启</a>,选择对应的项目，<strong>【启用】</strong> <em>Google Places API Web Service</em> 服务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GOOGLE_MAP_PLACES_URL = <span class="string">"https://maps.googleapis.com/maps/api/place/nearbysearch/json?language=%1$s&amp;location=%2$s,%3$s&amp;radius=%4$s&amp;type=%5$s&amp;key=%6$s"</span>;</span><br></pre></td></tr></table></figure><p>这下参数有点多了哈，前面3个和之前一样，分别对应语言、纬度、经度。第四个参数是查询地点的半径多大，第五个是类型，这里我使用的是 <strong>point_of_interest</strong> 意思是<strong>已经命名的景点</strong>，<a href="https://developers.google.com/maps/documentation/geocoding/intro#Types" target="_blank" rel="noopener">其他类型可以查看官网</a>，最后一个参数是你的 APP 申请的 Key值。</p><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取经纬度对应的附近地点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPlacesByLatLngWeb</span><span class="params">(<span class="keyword">double</span> latitude, <span class="keyword">double</span> longitude)</span> </span>&#123;</span><br><span class="line">    String url = GoogleMapUrlUtil.getGoogleMapPlacesUrl(latitude, longitude);</span><br><span class="line">    <span class="keyword">if</span> (URLUtil.isNetworkUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">new</span> NearbyPlacesTask().execute(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyPlacesTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">JSONObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JSONObject <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(JSONObject result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != result) &#123;</span><br><span class="line">            JSONArray jsonArray = result.getJSONArray(<span class="string">"results"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jsonArray) &#123;</span><br><span class="line">                List&lt;NearbyPlaceBean&gt; list = JSON.parseArray(jsonArray.toString(), NearbyPlaceBean.class);</span><br><span class="line">                <span class="comment">//遍历 list 可以获取对应的附近地点信息</span></span><br><span class="line">                <span class="comment">//list的size能比较大，可以根据项目需求，指截取前面10个。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NearbyPlaceBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//geometry</span></span><br><span class="line">    <span class="comment">//icon</span></span><br><span class="line">    <span class="keyword">private</span> String id;      <span class="comment">//1f7541b5f729cdc8bc8bb546f205848c50315af7</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//澎柏白金假日公寓</span></span><br><span class="line">    <span class="comment">//photos</span></span><br><span class="line">    <span class="keyword">private</span> String place_id;    <span class="comment">//ChIJX9_kRAXsAzQRKmc97njB67c</span></span><br><span class="line">    <span class="comment">//reference</span></span><br><span class="line">    <span class="comment">//scope</span></span><br><span class="line">    <span class="comment">//types</span></span><br><span class="line">    <span class="keyword">private</span> String vicinity;    <span class="comment">//深圳市宝安区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GeometryBean geometry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set，get 自己补充哈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战：附近地点推荐"><a href="#实战：附近地点推荐" class="headerlink" title="实战：附近地点推荐"></a>实战：附近地点推荐</h2><p>可以像上面那样使用 Activity 的方式，弹出 Google 自带的地点推荐／选取界面，但是这样的UI定制性低，不能按照项目需求显示界面。所以根据上面学习到的东西，我重新写了个类似的界面，实现地点推荐、搜索、选择和截图功能的功能。考虑到频繁调接口会损耗请求次数，所以我设置了个半径，超过半径的才重新请求数据。</p><h2 id="限制／收费"><a href="#限制／收费" class="headerlink" title="限制／收费"></a>限制／收费</h2><p>前面我把类型分为 Map，Places主要原因就是，他们的收费标准是不同的。<a href="https://developers.google.com/maps/pricing-and-plans/#details" target="_blank" rel="noopener">详情可见</a></p><table><thead><tr><th style="text-align:left">Android</th><th style="text-align:left">标准方案</th><th style="text-align:left">高级</th></tr></thead><tbody><tr><td style="text-align:left">Google Maps Android API</td><td style="text-align:left">不受限制地免费使用。<a href="https://developers.google.com/maps/pricing-and-plans/#sup_1" target="_blank" rel="noopener">1</a></td><td style="text-align:left">定价基于所需数量。如需了解详细信息，请参阅<a href="https://developers.google.com/maps/premium/usage-limits" target="_blank" rel="noopener">Premium Plan使用率和限制</a>。</td></tr><tr><td style="text-align:left">Google Places API for Android</td><td style="text-align:left">默认每天 1,000 次免费请求，<a href="https://developers.google.com/places/android-api/usage#query-limits" target="_blank" rel="noopener">信用卡验证</a>后可增至每天 150,000 次免费请求。符合要求的应用可免费提升。<a href="https://developers.google.com/places/android-api/usage" target="_blank" rel="noopener">详情</a></td><td style="text-align:left">—-</td></tr></tbody></table><table><thead><tr><th style="text-align:left">Web 服务</th><th style="text-align:left">标准</th><th style="text-align:left">高级</th></tr></thead><tbody><tr><td style="text-align:left">Google Places API Web Service</td><td style="text-align:left">每天 150,000 次免费请求（<a href="https://developers.google.com/places/web-service/usage" target="_blank" rel="noopener">信用卡验证</a>后）。</td><td style="text-align:left">定价基于所需数量。如需了解详细信息，请参阅<a href="https://developers.google.com/maps/premium/usage-limits" target="_blank" rel="noopener">Premium Plan使用率和限制</a>。</td></tr></tbody></table><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><h3 id="官方-Demo"><a href="#官方-Demo" class="headerlink" title="官方 Demo"></a>官方 Demo</h3><p>官方 Demo 要跑起来，必须像前面的方式一样，去申请对应的 Key。</p><h4 id="android-samples-apiDemos"><a href="#android-samples-apiDemos" class="headerlink" title="android-samples-apiDemos"></a><a href="https://github.com/googlemaps/android-samples/tree/master/ApiDemos" target="_blank" rel="noopener">android-samples-apiDemos</a></h4><p>介绍 Map 相关 API。</p><h4 id="android-play-places"><a href="#android-play-places" class="headerlink" title="android-play-places"></a><a href="https://github.com/googlesamples/android-play-places/" target="_blank" rel="noopener">android-play-places</a></h4><p>介绍 Places 相关 API 。包括地点搜索，附近地点选择，地点补全等。</p><h4 id="android-maps-utils"><a href="#android-maps-utils" class="headerlink" title="android-maps-utils"></a><a href="https://github.com/googlemaps/android-maps-utils" target="_blank" rel="noopener">android-maps-utils</a></h4><p><strong>点聚合 Clustering</strong> 可以通过这个 demo 学习，GoogleMap的点聚合和百度是一样的用法，外层代码基本上是一样的。</p><h3 id="工具类网页"><a href="#工具类网页" class="headerlink" title="工具类网页"></a>工具类网页</h3><ol><li><a href="https://console.developers.google.com/apis/credentials?project=savvy-generator-167702" target="_blank" rel="noopener">API Console</a> （Key 管理控制台）</li><li><a href="https://developers.google.com/android/reference/com/google/android/gms/maps/package-summary" target="_blank" rel="noopener">Google Map API 查询</a></li><li>坐标反查 (通过经纬度查对应地点)<br><a href="https://www.google.com/maps" target="_blank" rel="noopener">GoogleMap</a><br>(谷歌地图直接把经纬度输入输入框即可查询，例如输入：22.536817569098282,113.97451490163802 )<br><a href="http://lbs.amap.com/console/show/picker" target="_blank" rel="noopener">高德地图</a><br><a href="http://api.map.baidu.com/lbsapi/getpoint/" target="_blank" rel="noopener">百度地图</a></li></ol><h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><p>[1]官方 Map 教程 <a href="https://developers.google.com/maps/documentation/android-api/" target="_blank" rel="noopener">https://developers.google.com/maps/documentation/android-api/</a><br>[2]官方 Places 教程 <a href="https://developers.google.com/places/android-api/" target="_blank" rel="noopener">https://developers.google.com/places/android-api/</a><br>[3]启动 GoogleMap <a href="https://developers.google.com/maps/documentation/android-api/intents" target="_blank" rel="noopener">https://developers.google.com/maps/documentation/android-api/intents</a><br>[4]Android使用intent调取导航或者地图 <a href="https://blog.csdn.net/qwer4755552/article/details/51659833" target="_blank" rel="noopener">https://blog.csdn.net/qwer4755552/article/details/51659833</a><br>[5]关于地图和偏移的那些事 <a href="https://blog.csdn.net/sanjay_f/article/details/48493699" target="_blank" rel="noopener">https://blog.csdn.net/sanjay_f/article/details/48493699</a><br>[6]地图坐标转换大全 <a href="http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=332419" target="_blank" rel="noopener">http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=332419</a><br>[7]Show Popup when Location access is disable by user (Andorid Google Maps) <a href="https://stackoverflow.com/questions/24160472/show-popup-when-location-access-is-disable-by-user-andorid-google-maps" target="_blank" rel="noopener">https://stackoverflow.com/questions/24160472/show-popup-when-location-access-is-disable-by-user-andorid-google-maps</a><br>[8]How to show enable location dialog like Google maps? <a href="https://stackoverflow.com/questions/29801368/how-to-show-enable-location-dialog-like-google-maps" target="_blank" rel="noopener">https://stackoverflow.com/questions/29801368/how-to-show-enable-location-dialog-like-google-maps</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;通过本文，你可以知道如何使用 GoogleMap 相关 API、定位当前位置、获取当前所在城市、获取当前位置附近的地点、导航、地点搜索等内容。大致内容，可以查看如下思维导图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/GoogleMapXmind.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Map" scheme="https://zhangmiao.cc/categories/Android/Map/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Map" scheme="https://zhangmiao.cc/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>最新Android框架排行榜，上百项资源汇总不容错过</title>
    <link href="https://zhangmiao.cc/posts/b0de6447.html"/>
    <id>https://zhangmiao.cc/posts/b0de6447.html</id>
    <published>2019-07-22T03:30:00.000Z</published>
    <updated>2019-07-22T03:36:29.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android框架排行榜"><a href="#Android框架排行榜" class="headerlink" title="Android框架排行榜"></a>Android框架排行榜</h4><h5 id="1-Retrofit"><a href="#1-Retrofit" class="headerlink" title="1.Retrofit　　"></a>1.Retrofit　　</h5><blockquote><p>一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言</p></blockquote><p>上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。</p><ul><li>官网地址：<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">http://square.github.io/retrofit/</a></li><li>github：<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">https://github.com/square/retrofit</a></li><li>作者：square团队</li></ul><h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;</span><br></pre></td></tr></table></figure><h5 id="2-okhttp"><a href="#2-okhttp" class="headerlink" title="2.okhttp"></a>2.okhttp</h5><blockquote><p>一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端</p></blockquote><p>上榜理由，okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。</p><ul><li>官网地址：<a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">http://square.github.io/okhttp/</a></li><li>github：<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">https://github.com/square/okhttp</a></li><li>作者：square团队</li></ul><h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.squareup.okhttp3:okhttp:3.9.1&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="3-Butter-Knife"><a href="#3-Butter-Knife" class="headerlink" title="3.Butter Knife"></a>3.Butter Knife</h5><blockquote><p>一句话介绍：Butter Knife所提供了一种能力——使用注解生成模板代码，将view与方法和参数绑定。</p></blockquote><p>上榜理由：github上16.5K个star，配合Androidstudio提供的Butter Knife插件，帮助开发者省却了频繁findviewbyid的烦恼，最新的Butter Knife还提供了onclick绑定以及字符串的初始化，初学者可以查阅Butter Knife以及Butter Knife插件进一步学习！</p><ul><li>官网地址：<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">http://jakewharton.github.io/butterknife/</a></li><li>github：<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">https://github.com/JakeWharton/butterknife</a></li><li>作者：JakeWharton ，也是square团队成员之一</li></ul><h5 id="使用：-2"><a href="#使用：-2" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;com.jakewharton:butterknife:8.8.1&apos;  </span><br><span class="line">  annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-MPAndroidChart"><a href="#4-MPAndroidChart" class="headerlink" title="4.MPAndroidChart"></a>4.MPAndroidChart</h5><blockquote><p>一句话介绍：MPAndroidChart是一款图表框架</p></blockquote><p>上榜理由：github上16.1K个star，以快速、简洁。强大著称的图表框架</p><ul><li>官网地址：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart</a></li><li>github：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart</a></li><li>作者：PhilJay</li></ul><h5 id="使用：-3"><a href="#使用：-3" class="headerlink" title="使用："></a>使用：</h5><p>在AS中加入Gradle依赖</p><p>在根目录的 build.gradle上加入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">            maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app的build.gradle上加入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.github.PhilJay:MPAndroidChart:v3.0.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-glide"><a href="#5-glide" class="headerlink" title="5.glide"></a>5.glide</h5><blockquote><p>一句话介绍：glide是一款专注于提供流畅划动能力的“图片加载和缓存框架”</p></blockquote><p>上榜理由：15.9k个star，图片加载类框架排名第一的框架，google 在2014开发者大会上演示的camera app就是基于gilde框架开发的</p><ul><li>github：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></li><li>作者：Bump Technologies团队</li></ul><h5 id="使用：-4"><a href="#使用：-4" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.github.bumptech.glide:glide:4.5.0&apos;   </span><br><span class="line">    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.5.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-leakcanary"><a href="#6-leakcanary" class="headerlink" title="6.leakcanary"></a>6.leakcanary</h5><blockquote><p>一句话介绍：一款内存检测框架，服务于java和android客户端</p></blockquote><p>上榜理由：方便，简洁是leakcanary最大的特点，只需在应用的apllication中集成，就可以直接使用它；15.5k个star说明了它有多么受欢迎</p><ul><li>github：<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a></li><li>作者：square团队</li></ul><h5 id="使用：-5"><a href="#使用：-5" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;   </span><br><span class="line">   releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;   </span><br><span class="line">   testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Application 中写入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExampleApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void onCreate() &#123; </span><br><span class="line">    super.onCreate();    </span><br><span class="line">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;      </span><br><span class="line">      // This process is dedicated to LeakCanary for heap analysis.      </span><br><span class="line">      // You should not init your app in this process.      </span><br><span class="line">      return;    </span><br><span class="line">    &#125;    </span><br><span class="line">    LeakCanary.install(this);    </span><br><span class="line">    // Normal app init code...  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-Android-Universal-Image-Loader"><a href="#7-Android-Universal-Image-Loader" class="headerlink" title="7.Android-Universal-Image-Loader"></a>7.Android-Universal-Image-Loader</h5><blockquote><p>一句话介绍：曾经的图片加载框架王者，android开发老手都用过它</p></blockquote><p>上榜理由:android端图片加载框架的老大哥了，15.3k个star足以证明它的热门，UIL与gilde最大区别是可定制，UIL提供了大量配置方式，图片加载状态的回调（成功，失败，进行中），加载动画等；以及提供了移动端图片加载框架的缓存思路：三级缓存策略 sd卡-内存-网络；值得注意的是，UIL以及两年未更新了，但笔者仍推荐各位使用！</p><ul><li>github：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">https://github.com/nostra13/Android-Universal-Image-Loader</a></li><li>作者：nostra13</li></ul><h6 id="使用：-6"><a href="#使用：-6" class="headerlink" title="使用："></a>使用：</h6><ul><li>下载地址  universal-image-loader-1.9.5.jar</li></ul><h5 id="8-EventBus"><a href="#8-EventBus" class="headerlink" title="8.EventBus"></a>8.EventBus</h5><blockquote><p>一句话介绍：EventBus是一款本地组件间通信框架</p></blockquote><p>上榜理由：组件间通信框架star量第一：14.8k，在大型项目的Activities，fragments，Threads，Services都可以看到它的使用场景，尽管EventBus在向未创建的组件传递事件时有些局限，仅适合在“活着的”组件间传递消息，但仍不妨碍它活跃在各个大型项目各个场景里。</p><ul><li>官网地址：<a href="http://greenrobot.org/eventbus/documentation/how-to-get-started/" target="_blank" rel="noopener">http://greenrobot.org/eventbus/documentation/how-to-get-started/</a></li><li>github：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a></li><li>作者：greenrobot</li></ul><h5 id="使用：-7"><a href="#使用：-7" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br></pre></td></tr></table></figure><h5 id="9-zxing"><a href="#9-zxing" class="headerlink" title="9.zxing"></a>9.zxing</h5><blockquote><p>一句话介绍：条码图像处理库</p></blockquote><p>上榜理由：如果你用过二维码，你肯定已经间接使用过大名鼎鼎的zxing了。13.9K的star量，让它排在本榜单第九，实至名归，如果你有了解二维码的需求，不妨从了解、修改它源码入手。</p><ul><li>github：<a href="https://github.com/zxing/zxing" target="_blank" rel="noopener">https://github.com/zxing/zxing</a></li><li>作者：Sean Owen</li></ul><h5 id="10-picasso"><a href="#10-picasso" class="headerlink" title="10.picasso"></a>10.picasso</h5><blockquote><p>一句话介绍：强力的图片下载、缓存框架</p></blockquote><p>上榜理由：本榜单出现的第三款图片类框架，不同的是picasso更强调图片下载，你可以将picasso集成进你的项目中，你也可以结合gilde和UIL与picasso，三者一齐封装至你的项目中，按需所用。</p><ul><li>官网地址：<a href="http://square.github.io/picasso/" target="_blank" rel="noopener">http://square.github.io/picasso/</a></li><li>github：<a href="https://github.com/square/picasso" target="_blank" rel="noopener">https://github.com/square/picasso</a></li><li>作者：square团队</li></ul><h5 id="使用：-8"><a href="#使用：-8" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.squareup.picasso:picasso:2.5.2&apos;</span><br></pre></td></tr></table></figure><p>或者下载jar包</p><h5 id="11-lottie-android"><a href="#11-lottie-android" class="headerlink" title="11.lottie-android"></a>11.lottie-android</h5><blockquote><p>一句话介绍：一款可以在Android端快速展示Adobe Afeter Effect（AE）工具所作动画的框架</p></blockquote><p>上榜理由：动画类框架第一名，github上13.3k个star证明了他的优越性，利用json文件快速实现动画效果是它最大的便利，而这个json文件也是由Adobe提供的After Effects（AE）工具制作的，在AE中装一个Bodymovin的插件，使用这个插件最终将动画效果生成json文件，这个json文件即可由LottieAnimationView解析并生成绚丽的动画效果。而且它还支持跨平台哟。</p><ul><li>github：<a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">https://github.com/airbnb/lottie-android</a></li><li>作者：Airbnb 团队</li></ul><h5 id="12-fresco"><a href="#12-fresco" class="headerlink" title="12.fresco"></a>12.fresco</h5><blockquote><p>一句话介绍：一款可以管理图片内存的框架</p></blockquote><p>上榜理由:github上12.8k个star，图片类排行榜第四名，facebook的出身证明了它并非是重复造的轮子，在管理图片内存领域上有着它的一片天地，渐进式加载、加载gif都是它与前三位相比独有的特性</p><ul><li>官网地址：<a href="https://www.fresco-cn.org/" target="_blank" rel="noopener">https://www.fresco-cn.org/</a></li><li>github：<a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">https://github.com/facebook/fresco</a></li><li>作者：facebook</li></ul><h5 id="使用：-9"><a href="#使用：-9" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 其他依赖  </span><br><span class="line">  compile &apos;com.facebook.fresco:fresco:0.12.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的依赖需要根据需求添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 在 API &lt; 14 上的机器支持 WebP 时，需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:animated-base-support:0.12.0&apos;  </span><br><span class="line"></span><br><span class="line">  // 支持 GIF 动图，需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:animated-gif:0.12.0&apos;  </span><br><span class="line"></span><br><span class="line">  // 支持 WebP （静态图+动图），需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:animated-webp:0.12.0&apos;  </span><br><span class="line">  compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos;  </span><br><span class="line"></span><br><span class="line">  // 仅支持 WebP 静态图，需要添加  </span><br><span class="line">  compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="13-RxAndroid"><a href="#13-RxAndroid" class="headerlink" title="13.RxAndroid"></a>13.RxAndroid</h5><blockquote><p>一句话介绍：一款Android客户端组件间异步通信的框架</p></blockquote><p>上榜理由：github上12.7k个star，位居组件通信框架的第二名，仅在EventBus之后，如果要问两者的区别，Eventbus是用来取代组件间繁琐的interface，RxAndroid是用来取代AnsyTask的，并不冲突；当然RxAndroid的优点并不仅限于此，更多优雅的实现，可以去官网查阅！</p><ul><li>github：<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">https://github.com/ReactiveX/RxAndroid</a></li><li>作者：JakeWharton</li></ul><h5 id="使用：-10"><a href="#使用：-10" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</span><br><span class="line">compile &apos;io.reactivex.rxjava2:rxjava:2.1.0&apos;</span><br></pre></td></tr></table></figure><h5 id="14-SlidingMenu"><a href="#14-SlidingMenu" class="headerlink" title="14.SlidingMenu"></a>14.SlidingMenu</h5><blockquote><p>一句话介绍：侧滑菜单栏框架</p></blockquote><p>上榜理由：与Userval-Image-loader 齐名的上古神器框架——为你的app提供侧滑菜单栏的功能；github闪更有10.5k个star，证明了它的经久不衰，即使在Google推出了NavigationDrawer，仍然没有减少开发者对SildingMenu的拥簇，经典总是经得起考验的，这个上古神兽已经四年没有更新了；有太多太多的app使用过它，这些都可以在软件的开源许可上看到！</p><ul><li>github：<a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="noopener">https://github.com/jfeinstein10/SlidingMenu</a></li><li>作者：Jeremy Feinstein</li></ul><h5 id="使用：-11"><a href="#使用：-11" class="headerlink" title="使用："></a>使用：</h5><p>在gihub上fork源码，集成进项目中</p><h5 id="15-PhotoView"><a href="#15-PhotoView" class="headerlink" title="15.PhotoView"></a>15.PhotoView</h5><blockquote><p>一句话介绍：一款ImageView展示框架，支持缩放，响应手势</p></blockquote><p>上榜理由：10.3k的star数量，位于图片类框架排行榜第五位，PhotoView与前四位不同的是这次带来的是图片的展示能力，你一定好奇微信的头像点击放大是如何实现的，很多App的图片显示响应手势按压是如何实现的，了解PhotoView，你一定会开心的！（笔者也不会告诉你ImageView的点击放大效果在Android的sample也有）</p><ul><li>github：<a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="noopener">https://github.com/chrisbanes/PhotoView</a></li><li>作者：chrisbanes</li></ul><h5 id="使用：-12"><a href="#使用：-12" class="headerlink" title="使用："></a>使用：</h5><p>在app根目录的build.gradle中加入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app的module目录的build.gralde中加入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.github.chrisbanes:PhotoView:latest.release.here&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;com.github.chrisbanes.photoview.PhotoView</span><br><span class="line">    android:id=&quot;@+id/photo_view&quot;    </span><br><span class="line">    android:layout_width=&quot;match_parent&quot;    </span><br><span class="line">    android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PhotoView photoView = (PhotoView) findViewById(R.id.photo_view);</span><br><span class="line">photoView.setImageResource(R.drawable.image);</span><br></pre></td></tr></table></figure><h5 id="16-material-dialogs"><a href="#16-material-dialogs" class="headerlink" title="16.material-dialogs"></a>16.material-dialogs</h5><blockquote><p>一句话介绍：一款自定义dialog框架</p></blockquote><p>上榜理由：9.9k个star，也是继PhotoView，SlidingMenu之后第三款自定义View框架，也许你还是自定义View的新人，对Dialog使用的还有点生疏，你可以通过它提升你的Dilaog使用能力</p><ul><li>github：<a href="https://github.com/afollestad/material-dialogs" target="_blank" rel="noopener">https://github.com/afollestad/material-dialogs</a></li><li>作者：Aidan Follestad</li></ul><h5 id="使用：-13"><a href="#使用：-13" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // ... other dependencies here    </span><br><span class="line">    compile &apos;com.afollestad.material-dialogs:core:0.9.4.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="17-droid-async-http"><a href="#17-droid-async-http" class="headerlink" title="17.droid-async-http"></a>17.droid-async-http</h5><blockquote><p>一句话介绍：一款基于Http协议的异步请求的网络框架，</p></blockquote><p>上榜理由：虽然你有无数个使用retrofit+okhttp的理由，但9.8k个star，证明它仍然值得你深入学习。值得注意的是，它也已经有两年没更新了，你尽管拿去当你懒惰的理由！</p><ul><li>github：<a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">https://github.com/loopj/android-async-http</a></li><li>作者：James Smith</li></ul><h5 id="使用：-14"><a href="#使用：-14" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  maven &#123; </span><br><span class="line">    url &apos;https://oss.sonatype.org/content/repositories/snapshots/&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;com.loopj.android:android-async-http:1.5.0-SNAPSHOT&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="18-androidannotations"><a href="#18-androidannotations" class="headerlink" title="18.androidannotations"></a>18.androidannotations</h5><blockquote><p>一句话介绍：一款基于注解的快速开发框架</p></blockquote><p>上榜理由：与Butterknife一样基于注解，利用注解快速完成view的初始化，不同的是androidannotations提供了更多的能力：简单的线程模型等；笔者只接触过Butterknife，无法更进一步叙述androidannotations的优势，如果你志在深入了解注解的妙用，可以尝试探索一下！</p><ul><li>官网地址：<a href="http://androidannotations.org/" target="_blank" rel="noopener">http://androidannotations.org/</a></li><li>github：<a href="https://github.com/androidannotations/androidannotations" target="_blank" rel="noopener">https://github.com/androidannotations/androidannotations</a></li><li>作者：WonderCsabo</li></ul><h5 id="19-fastjson"><a href="#19-fastjson" class="headerlink" title="19.fastjson"></a>19.fastjson</h5><blockquote><p>一句话介绍:一款基于json解析、生成的框架</p></blockquote><p>上榜理由：从它的名字不难看出，快速是它最大的特性，阿里巴巴的出身保证了代码的质量和优越，9.4k的star数量，也是榜单里第一个出现的中国开源框架，涉及网络的app都会用到json，fastjson值得作为你的首选！</p><ul><li>github：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a></li><li>作者：alibaba</li></ul><h5 id="使用：-15"><a href="#使用：-15" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.alibaba:fastjson:1.1.58.android&apos;</span><br></pre></td></tr></table></figure><h5 id="20-Material-Animations"><a href="#20-Material-Animations" class="headerlink" title="20.Material-Animations"></a>20.Material-Animations</h5><blockquote><p>一句话介绍：一款提供场景转换过渡能力的动画框架</p></blockquote><p>上榜理由：Android动画框架排行榜第二名，9.3k个star数量，与动画框架榜单第一名lottie-android不同的是，Material-Animations提供的是场景切换的动画效果。Android 官网sample中已经提供了部分Transition （转场动画）的展示，作为初学者很难快速拓展到自己项目中，Material-Animations的示例出现为开发者省去了此类麻烦，直接照搬应用到自己的App中吧。</p><ul><li>github：<a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">https://github.com/lgvalle/Material-Animations</a></li><li>作者：Luis G. Valle</li></ul><h5 id="使用：-16"><a href="#使用：-16" class="headerlink" title="使用："></a>使用：</h5><p>down源码，修改学习</p><h5 id="21-tinker"><a href="#21-tinker" class="headerlink" title="21.tinker"></a>21.tinker</h5><blockquote><p>一句话介绍：它是微信官网的Android热补丁解决方案</p></blockquote><p>上榜理由：9.1k个star，微信在用的热补丁方案，心动不如行动</p><ul><li>官网地址：<a href="http://www.tinkerpatch.com/Docs/intro" target="_blank" rel="noopener">http://www.tinkerpatch.com/Docs/intro</a></li><li>github：<a href="https://github.com/Tencent/tinker" target="_blank" rel="noopener">https://github.com/Tencent/tinker</a></li><li>作者：Tencent</li></ul><h5 id="22-ViewPagerIndicator"><a href="#22-ViewPagerIndicator" class="headerlink" title="22.ViewPagerIndicator"></a>22.ViewPagerIndicator</h5><blockquote><p>一句话介绍：一款基于ViewPager的页面指示器开源框架</p></blockquote><p>上榜理由：上古神器，尽管已经五年未更新了，但你仍然可以在淘宝等app中看到它的使用场景，8.9K的star量让它不愠不火的在矗立在榜单里</p><ul><li>官网地址：<a href="http://viewpagerindicator.com/" target="_blank" rel="noopener">http://viewpagerindicator.com/</a></li><li>github：<a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blank" rel="noopener">https://github.com/JakeWharton/ViewPagerIndicator</a></li><li>作者：JakeWharton</li></ul><h5 id="使用：-17"><a href="#使用：-17" class="headerlink" title="使用："></a>使用：</h5><p>下载地址：<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master" target="_blank" rel="noopener">https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master</a></p><h5 id="23-Android-CleanArchitecture"><a href="#23-Android-CleanArchitecture" class="headerlink" title="23.Android-CleanArchitecture"></a>23.Android-CleanArchitecture</h5><blockquote><p>一句话介绍：一个讲解设计框架的demo</p></blockquote><p>上榜理由：它不是框架，你可以把它当作一本书，它将教会你如何设计简洁的架构，工程里有一个sample app，配合图文讲解，你将对Android客户端的架构有更深一层的认识。8.8k的star数量，证明了它是一本“好书”哟。</p><ul><li>github：<a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">https://github.com/android10/Android-CleanArchitecture</a></li><li>作者：Fernando Cejas</li></ul><h5 id="24-Android-PullToRefresh"><a href="#24-Android-PullToRefresh" class="headerlink" title="24.Android-PullToRefresh"></a>24.Android-PullToRefresh</h5><blockquote><p>一句话介绍：一款为普通视图提供刷新UI的视图框架</p></blockquote><p>上榜理由：8.2K的star数量使它位居刷新类UI框架榜首，强大的兼容能力，该框架支持ListView，GrdiView，WebViewScrollView，ViewPager等众多View增加刷新的能力，如果你有增加上拉加载，下拉加载的需求，你应该考虑它了！</p><ul><li>github：<a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="noopener">https://github.com/chrisbanes/Android-PullToRefresh</a></li><li>作者：Chris Banes</li></ul><h5 id="使用：-18"><a href="#使用：-18" class="headerlink" title="使用："></a>使用：</h5><p>github fork源码，集成到项目中</p><h5 id="25-flexbox-layout"><a href="#25-flexbox-layout" class="headerlink" title="25.flexbox-layout"></a>25.flexbox-layout</h5><blockquote><p>一句话介绍：一款弹性伸缩布局</p></blockquote><p>上榜理由：8.1k个star，前端H5开发者转Android开发的福音，FlexboxLayout作为LinearLayout和RelativeLayout的替代者，值得各位一试，与其一同推出的还有ConstraintLayout。</p><ul><li>github：<a href="https://github.com/google/flexbox-layout" target="_blank" rel="noopener">https://github.com/google/flexbox-layout</a></li><li>作者：Google</li></ul><h5 id="使用：-19"><a href="#使用：-19" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.google.android:flexbox:0.3.0-alpha3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="26-AndroidSwipeLayout"><a href="#26-AndroidSwipeLayout" class="headerlink" title="26.AndroidSwipeLayout"></a>26.AndroidSwipeLayout</h5><blockquote><p>一句话介绍：非常强大滑动式布局</p></blockquote><p>上榜理由:滑动删除是国产app常见需求，商品详情的上下滑动需求作为开发者的我们也经常遇到，AndroidSwipeLayout在github上拥有8K个star，证明它经受住了检验，各位值得一试</p><ul><li>github：<a href="https://github.com/daimajia/AndroidSwipeLayout" target="_blank" rel="noopener">https://github.com/daimajia/AndroidSwipeLayout</a></li><li>作者：daimajia</li></ul><h5 id="使用：-20"><a href="#使用：-20" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.android.support:recyclerview-v7:21.0.0&apos;    </span><br><span class="line">    compile &apos;com.android.support:support-v4:20.+&apos;    </span><br><span class="line">    compile &quot;com.daimajia.swipelayout:library:1.2.0@aar&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="或下载"><a href="#或下载" class="headerlink" title="或下载"></a>或下载</h5><p>AndroidSwipeLayout-v1.1.8.jar</p><h5 id="27-realm-java"><a href="#27-realm-java" class="headerlink" title="27.realm-java"></a>27.realm-java</h5><blockquote><p>一句话介绍：Realm是一款移动端数据库框架</p></blockquote><p>上榜理由：核心数据引擎C++打造，比普通的Sqlite型数据库快的多。笔者猜测正是如此，realm以7892个star数让它位于大名鼎鼎的数据库框架GreenDao（7877）之前</p><ul><li>官网地址：<a href="https://realm.io/cn/" target="_blank" rel="noopener">https://realm.io/cn/</a></li><li>github：<a href="https://github.com/realm/realm-java" target="_blank" rel="noopener">https://github.com/realm/realm-java</a></li><li>作者：Realm团队</li></ul><h5 id="使用：-21"><a href="#使用：-21" class="headerlink" title="使用："></a>使用：</h5><p><a href="https://realm.io/docs/java/latest/" target="_blank" rel="noopener">https://realm.io/docs/java/latest/</a></p><h5 id="28-greenDAO"><a href="#28-greenDAO" class="headerlink" title="28.greenDAO"></a>28.greenDAO</h5><blockquote><p>一句话介绍：greenDAO是一款高效、快速的SQLite型数据库</p></blockquote><p>上榜理由：greenDAO的star数量与Realm不相上下，且与EventBus师出同门，也是由greenrobot团队开发维护的，质量有所保证，但若拷问笔者Realm与greenDao两者的优劣性，只能具体到实际使用当中，模拟线上的使用情形，进行高强度测试后才能下判断，故在此不能一言两语说完，深表遗憾</p><ul><li>官网地址：<a href="http://greenrobot.org/greendao/" target="_blank" rel="noopener">http://greenrobot.org/greendao/</a></li><li>github：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">https://github.com/greenrobot/greenDAO</a></li></ul><h5 id="使用：-22"><a href="#使用：-22" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()        </span><br><span class="line">        mavenCentral() // add repository    </span><br><span class="line">    &#125;    </span><br><span class="line">    dependencies &#123; </span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.1&apos;        </span><br><span class="line">        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin </span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="29-stetho"><a href="#29-stetho" class="headerlink" title="29.stetho"></a>29.stetho</h5><blockquote><p>一句话介绍：一款提供在Chrome开发者工具上调试Android app能力的开源框架</p></blockquote><p>上榜理由：上古时期Android程序员要调试本地数据库，需要进入Android Device Monitor找到/data/data/com.xxx.xxx/databases里面的db文件，导出到PC端，用PC的数据工具查看，现在使用stetho省却了如此的麻烦；如今的Android程序员如果想调试网络请求响应过程中的报文段，需要在请求中加入Log语句，一个信息一个信息打印出来，相当繁琐，现在请使用stetho，省却诸如此类的麻烦把！7.8K个star数，广大Android开发者调试的福音，你值得拥有！</p><ul><li>官网地址：<a href="http://facebook.github.io/stetho/" target="_blank" rel="noopener">http://facebook.github.io/stetho/</a></li><li>github：<a href="https://github.com/facebook/stetho" target="_blank" rel="noopener">https://github.com/facebook/stetho</a></li><li>作者：FaceBook</li></ul><h5 id="使用：-23"><a href="#使用：-23" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile ‘com.facebook.stetho:stetho:1.5.0’</span><br></pre></td></tr></table></figure><h5 id="30-BaseRecyclerViewAdapterHelper"><a href="#30-BaseRecyclerViewAdapterHelper" class="headerlink" title="30.BaseRecyclerViewAdapterHelper"></a>30.BaseRecyclerViewAdapterHelper</h5><blockquote><p>一句话介绍：强大、流畅的Recyvlerview通用适配器</p></blockquote><p>上榜理由：如果你是RecyclerView的拥簇者，你一定要体验这款专门服务该view的适配器，7.7K个star，让这个家伙位于github上Android 适配器排行榜第一，还有很多惊喜等你去探寻！</p><ul><li>官网地址：<a href="http://www.recyclerview.org/" target="_blank" rel="noopener">http://www.recyclerview.org/</a></li></ul><p>使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123; </span><br><span class="line">        ...       </span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot;&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.CymChad:BaseRecyclerViewAdapterHelper:VERSION_CODE&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="31-AndroidViewAnimations"><a href="#31-AndroidViewAnimations" class="headerlink" title="31.AndroidViewAnimations"></a>31.AndroidViewAnimations</h5><blockquote><p>一句话介绍：一款提供可爱动画集合的框架</p></blockquote><p>上榜理由：正如作者所说，它囊括了开发需求过程中所有的动画效果，集成进了这个简洁可爱的动画框架。7.6K的star数，证明了它在动画框架领域的战斗力，让它仅仅位列lottie-android和Material-Animations两个动画框架霸主之后，屈居第三名</p><ul><li>github：<a href="https://github.com/daimajia/AndroidViewAnimations" target="_blank" rel="noopener">https://github.com/daimajia/AndroidViewAnimations</a></li><li>作者：daimajia</li></ul><h5 id="使用：-24"><a href="#使用：-24" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.android.support:support-compat:25.1.1&apos;        </span><br><span class="line">        compile &apos;com.daimajia.easing:library:2.0@aar&apos;        </span><br><span class="line">        compile &apos;com.daimajia.androidanimations:library:2.2@aar&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sample：</span><br><span class="line">YoYo.with(Techniques.Tada)</span><br><span class="line">    .duration(700)    </span><br><span class="line">    .repeat(5)    </span><br><span class="line">    .playOn(findViewById(R.id.edit_area));</span><br></pre></td></tr></table></figure><h5 id="32-MaterialDrawer"><a href="#32-MaterialDrawer" class="headerlink" title="32.MaterialDrawer"></a>32.MaterialDrawer</h5><blockquote><p>一句话介绍：强大的塑料风格的抽屉框架</p></blockquote><p>上榜理由：7.6K的star数量，作者的持续更新状态，如果你还在犹豫上手SlidingMenu遇到bug没人管的困境，那么你可以入手它作为你的抽屉布局</p><ul><li>github：<a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="noopener">https://github.com/mikepenz/MaterialDrawer</a></li><li>作者：Mike Penz</li></ul><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用:"></a>使用:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(&apos;com.mikepenz:materialdrawer:5.9.2@aar&apos;) &#123;</span><br><span class="line">    transitive = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new DrawerBuilder().withActivity(this).build();</span><br></pre></td></tr></table></figure><h5 id="33-Android-ObservableScrollView"><a href="#33-Android-ObservableScrollView" class="headerlink" title="33.Android-ObservableScrollView"></a>33.Android-ObservableScrollView</h5><blockquote><p>一句话介绍：一款让视图滑动更具有视觉效果的滑动式框架</p></blockquote><p>上榜理由：7.5K的star数量，证明了它曾经的价值，github上提供了12种滑动效果，你可以用它弥补其他框架的不足，提升你的App体验！</p><ul><li>github：<a href="https://github.com/ksoichiro/Android-ObservableScrollView" target="_blank" rel="noopener">https://github.com/ksoichiro/Android-ObservableScrollView</a></li><li>作者：Soichiro Kashima</li></ul><h5 id="使用：-25"><a href="#使用：-25" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile com.github.ksoichiro:android-observablescrollview</span><br></pre></td></tr></table></figure><h5 id="34-CircleImageView"><a href="#34-CircleImageView" class="headerlink" title="34.CircleImageView"></a>34.CircleImageView</h5><blockquote><p>一句话介绍：圆角ImageView</p></blockquote><p>上榜理由：也许你已经听说过无数种展示圆角图片的方法，但如果你不尝试尝试CircleImageView，那么你的知识库会因为少了它黯然失色，有的时候完成需求是开发者优先考虑的，不同实现方法牵扯到的性能差异更值得让人深思，如果你有心在图片性能上有所涉猎，那么CircleImageView绝对不会让你败兴而归。最后别忘了记得去看Romain Guy的建议哟。</p><ul><li>github：<a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">https://github.com/hdodenhof/CircleImageView</a></li><li>作者：Henning Dodenhof</li></ul><h5 id="使用：-26"><a href="#使用：-26" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...    </span><br><span class="line">    compile &apos;de.hdodenhof:circleimageview:2.1.0&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;de.hdodenhof.circleimageview.CircleImageView</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:id=&quot;@+id/profile_image&quot;</span><br><span class="line">    android:layout_width=&quot;96dp&quot;</span><br><span class="line">    android:layout_height=&quot;96dp&quot;</span><br><span class="line">    android:src=&quot;@drawable/profile&quot;</span><br><span class="line">    app:civ_border_width=&quot;2dp&quot;    </span><br><span class="line">    app:civ_border_color=&quot;#FF000000&quot;/&gt;</span><br></pre></td></tr></table></figure><h5 id="35-logger"><a href="#35-logger" class="headerlink" title="35.logger"></a>35.logger</h5><blockquote><p>一句话介绍：一款让log日志优雅显示的框架</p></blockquote><p>上榜理由：logger作为调试框架，并未给出很强大的能力，它最大的亮点是优雅的输出log信息，并且支持多种格式：线程、Json、Xml、List、Map等，如果你整日沉迷于汪洋大海般的log信息不能自拔，logger就是你的指路明灯！6.6k个star让他位列调试框架第二名，屈居facebook的stetho之后</p><ul><li>github：<a href="https://github.com/orhanobut/logger" target="_blank" rel="noopener">https://github.com/orhanobut/logger</a></li><li>作者：Orhan Obut</li></ul><p>使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.orhanobut:logger:2.1.1&apos;</span><br><span class="line"></span><br><span class="line">Logger.d(MAP);</span><br><span class="line">Logger.d(SET);</span><br><span class="line">Logger.d(LIST);</span><br><span class="line">Logger.d(ARRAY);</span><br><span class="line">Logger.json(JSON_CONTENT);</span><br><span class="line">Logger.xml(XML_CONTENT);</span><br></pre></td></tr></table></figure><h5 id="36-agera"><a href="#36-agera" class="headerlink" title="36.agera"></a>36.agera</h5><blockquote><p>一句话介绍:一款服务于Android平台的响应式编程框架</p></blockquote><p>上榜理由：google专门推出一套响应式编程框架服务于Android开发者，相比于之响应式编程框架榜首的 RxJava RxAndroid，它更轻量，两者最大的不同点在于agera基于push event、pull data （VS Rx系列 push data）。</p><ul><li>github：<a href="https://github.com/google/agera" target="_blank" rel="noopener">https://github.com/google/agera</a></li><li>作者：Google</li></ul><h5 id="使用：-27"><a href="#使用：-27" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.google.android.agera:agera:1.3.0&apos;</span><br></pre></td></tr></table></figure><h5 id="扩展能力"><a href="#扩展能力" class="headerlink" title="扩展能力"></a>扩展能力</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.google.android.agera:content:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:database:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:net:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:rvadapter:1.3.0&apos;  </span><br><span class="line">compile &apos;com.google.android.agera:rvdatabinding:1.3.0&apos;</span><br></pre></td></tr></table></figure><h5 id="37-BottmBar"><a href="#37-BottmBar" class="headerlink" title="37.BottmBar"></a>37.BottmBar</h5><blockquote><p>一句话介绍：一款底部导航栏视图框架</p></blockquote><p>上榜理由：底部栏里的王者框架，6.3K的star数量，证明了它的优秀，完全遵循材料设计规范，上手非常方便。如果说缺点，无法设置icon与titile的间距，无法自定义视图的大小等，但这些都可以通过修改源代码解决，笔者献丑也修改了一套符合国内开发者的底部导航框架，即将开源。</p><ul><li>github：<a href="https://github.com/roughike/BottomBar" target="_blank" rel="noopener">https://github.com/roughike/BottomBar</a></li><li>作者：Iiro Krankka</li></ul><h5 id="使用：-28"><a href="#使用：-28" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.roughike:bottom-bar:2.3.1&apos;</span><br></pre></td></tr></table></figure><h5 id="38-Calligraphy"><a href="#38-Calligraphy" class="headerlink" title="38.Calligraphy"></a>38.Calligraphy</h5><blockquote><p>一句话介绍：一款自定义字体框架</p></blockquote><p>上榜理由：如果你还在为一键修改App内所有字体样式而烦恼，6.3K个star的Calligraphy就值得你拥有，它可以同时修改整个整个项目的Textview字体，也可以单独 设置某个Textview的字体，还在等什么，快来试试吧！</p><ul><li>github：<a href="https://github.com/chrisjenx/Calligraphy" target="_blank" rel="noopener">https://github.com/chrisjenx/Calligraphy</a></li><li>作者：Christopher Jenkins</li></ul><h5 id="使用：-29"><a href="#使用：-29" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;uk.co.chrisjenx:calligraphy:2.3.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="39-AndroidSlidingUpPanel"><a href="#39-AndroidSlidingUpPanel" class="headerlink" title="39.AndroidSlidingUpPanel"></a>39.AndroidSlidingUpPanel</h5><blockquote><p>一句话介绍：可拖动的滑动面板视图框架</p></blockquote><p>上榜理由：如果你的项目需要一个可拖拽的滑动式面板（展示某些详情信息，播放音乐，地图信息等），那么推荐你使用它，6.3k个star，来自创业公司umano的作品，证明它是用心推出的杰作</p><ul><li>github：<a href="https://github.com/umano/AndroidSlidingUpPanel" target="_blank" rel="noopener">https://github.com/umano/AndroidSlidingUpPanel</a></li><li>作者：umano</li></ul><h5 id="使用：-30"><a href="#使用：-30" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    repositories &#123;    </span><br><span class="line">       mavenCentral()    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    compile &apos;com.sothree.slidinguppanel:library:3.3.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="40-AppIntro"><a href="#40-AppIntro" class="headerlink" title="40.AppIntro"></a>40.AppIntro</h5><blockquote><p>一句话介绍：一款提供快速制作欢迎页的框架</p></blockquote><p>上榜理由：笔者从未把打算把欢迎页框架纳入排行榜当中，作为国内开发者，ViewPager开发App的欢迎页已经是手到擒来的需求，为何一个开源的欢迎页框架会在github上拥有6.3k个star？也许你会不屑一顾，是的，往往就在不屑一顾的瞬间，机遇就悄悄溜走了。</p><ul><li>github：<a href="https://github.com/apl-devs/AppIntro" target="_blank" rel="noopener">https://github.com/apl-devs/AppIntro</a></li><li>作者：Paolo Rotolo</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;  </span><br><span class="line">   repositories &#123;      </span><br><span class="line">       ...            </span><br><span class="line">       maven &#123; url &apos;https://jitpack.io&apos;&#125; </span><br><span class="line">   &#125;      </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">dependencies &#123;     </span><br><span class="line">        compile &apos;com.github.apl-devs:appintro:v4.2.0&apos;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="41-recyclerview-animators"><a href="#41-recyclerview-animators" class="headerlink" title="41.recyclerview-animators"></a>41.recyclerview-animators</h5><blockquote><p>一句话介绍：一款为Recyclerview提供扩展动画能力的框架</p></blockquote><p>上榜理由：有一句老话：如果有天你失去对新事物的兴趣，那就说明你老了。recyclerview已经推出快三年了，还在用listview的人们，是否已经发掘自己渐渐变老；不要灰心，快为你的项目加入recyclerview-animators框架吧，为“自己”加入新鲜的血液和能量！（笔者备注：6.2K个star）</p><ul><li>github：<a href="https://github.com/wasabeef/recyclerview-animators" target="_blank" rel="noopener">https://github.com/wasabeef/recyclerview-animators</a></li><li>作者：<a href="https://github.com/wasabeef" target="_blank" rel="noopener">https://github.com/wasabeef</a></li></ul><h5 id="使用：-31"><a href="#使用：-31" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // jCenter  </span><br><span class="line">  compile &apos;jp.wasabeef:recyclerview-animators:2.2.6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="42-dagger"><a href="#42-dagger" class="headerlink" title="42.dagger"></a>42.dagger</h5><blockquote><p>一句话介绍：一款通过依赖注入降低程序间耦合的开发框架</p></blockquote><p>上榜理由：github 上dagger1版本 有6.2k个star ， dagger2版本有7.3k个；由square完成的dagger1版本，到如今google团队接手的dagger2版本，强力开发团队保证了代码在设计上的优越性；如果你想探究Android 领域的设计模式，这也是不错的选择。</p><ul><li>官网地址：<a href="https://google.github.io/dagger/" target="_blank" rel="noopener">https://google.github.io/dagger/</a></li><li>github：<a href="https://github.com/google/dagger" target="_blank" rel="noopener">https://github.com/google/dagger</a></li><li>作者：google</li></ul><h5 id="使用：-32"><a href="#使用：-32" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;com.google.dagger:dagger:2.x&apos;  </span><br><span class="line">  annotationProcessor &apos;com.google.dagger:dagger-compiler:2.x&apos;</span><br><span class="line">&#125;</span><br><span class="line">If you&apos;re using classes in dagger.android you&apos;ll also want to include:</span><br><span class="line"></span><br><span class="line">compile &apos;com.google.dagger:dagger-android:2.x&apos;</span><br><span class="line">compile &apos;com.google.dagger:dagger-android-support:2.x&apos; </span><br><span class="line">annotationProcessor &apos;com.google.dagger:dagger-android-processor:2.x&apos;</span><br></pre></td></tr></table></figure><h5 id="43-Android-Bootstarp"><a href="#43-Android-Bootstarp" class="headerlink" title="43.Android-Bootstarp"></a>43.Android-Bootstarp</h5><blockquote><p>一句话介绍：一款提供在Android应用上实现Bootstrap（web框架）所作出效果的框架</p></blockquote><p>上榜理由：榜单上第二款响应web技术的Android 端框架，还记得第一名是谁吗——flexbox-layout，作为Android开发者，你有必要去了解Web技术了。5.9k个star，证明它不容小觑</p><ul><li>github：<a href="https://github.com/Bearded-Hen/Android-Bootstrap" target="_blank" rel="noopener">https://github.com/Bearded-Hen/Android-Bootstrap</a></li><li>作者：Bearded-Hen团队</li></ul><h5 id="使用：-33"><a href="#使用：-33" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile &apos;com.beardedhen:androidbootstrap:&#123;X.X.X&#125;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="44-RxBinding"><a href="#44-RxBinding" class="headerlink" title="44.RxBinding"></a>44.RxBinding</h5><p>一句话介绍：一款提供UI组件事件响应能力的框架</p><p>上榜理由：如果你还未开始RxAndroid 之旅，RxBinding可以作为你的第一站，通过RXBinding，你将理解响应式编程的快乐，让项目里的事件流程更清晰。5.6K个star，RxAndroid作者亲自操刀，快来试用吧！</p><ul><li>github：<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">https://github.com/JakeWharton/RxBinding</a></li><li>作者：JakeWharton</li></ul><h5 id="Platform-bindings"><a href="#Platform-bindings" class="headerlink" title="Platform bindings:"></a>Platform bindings:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding:2.0.0&apos;</span><br><span class="line">&apos;support-v4&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-support-v4:2.0.0&apos;</span><br><span class="line">&apos;appcompat-v7&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-appcompat-v7:2.0.0&apos;</span><br><span class="line">&apos;design&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-design:2.0.0&apos;</span><br><span class="line">&apos;recyclerview-v7&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:2.0.0&apos;</span><br><span class="line">&apos;leanback-v17&apos; library bindings:</span><br><span class="line"></span><br><span class="line">compile &apos;com.jakewharton.rxbinding2:rxbinding-leanback-v17:2.0.0&apos;</span><br></pre></td></tr></table></figure><h5 id="45-ListViewAnimations"><a href="#45-ListViewAnimations" class="headerlink" title="45.ListViewAnimations"></a>45.ListViewAnimations</h5><blockquote><p>一句话介绍：一款为ListView提供动展示画效果能力的框架</p></blockquote><p>上榜理由：如果有一天我承认自己老了，我还会排排我的兄弟——ListView，证明我和它一起战斗过。ListViewAnimations的存在就是证明我们这些“老年人”仍有用武之地，也许你有说不出口的难处，无法体会到RecyclerView里动画的快乐，拥有ListViewAnimations，你一样可以骄傲的说，我的孩子（每个item）也有自己的动效啦。（笔者备注 5.6K个star）</p><ul><li>github：<a href="https://github.com/nhaarman/ListViewAnimations" target="_blank" rel="noopener">https://github.com/nhaarman/ListViewAnimations</a></li><li>作者：nhaarman</li></ul><h5 id="使用：-34"><a href="#使用：-34" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.nhaarman.listviewanimations:lib-core:3.1.0@aar&apos;    </span><br><span class="line">    compile &apos;com.nhaarman.listviewanimations:lib-manipulation:3.1.0@aar&apos;    </span><br><span class="line">    compile &apos;com.nhaarman.listviewanimations:lib-core-slh:3.1.0@aar&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="46-UItimateRecyclerView"><a href="#46-UItimateRecyclerView" class="headerlink" title="46.UItimateRecyclerView"></a>46.UItimateRecyclerView</h5><blockquote><p>一句话介绍：一款提供刷新、加载更多、动画特效等额外能力的RecyclerView框架</p></blockquote><p>上榜理由：榜单上第三次出现RecyclerView的身影，足以证明RecyclerView的优异性，5.5K个star，框架里所提供众多的能力，如果你是个功利开发者，那么此框架会为你节省很多学习时间，它可以完成多item式布局的大多数需求，值得注意的是，这个项目也是在其他项目的思路上二次开发的。</p><ul><li>github：<a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="noopener">https://github.com/cymcsg/UltimateRecyclerView</a></li><li>作者：MarshalChen</li></ul><h5 id="使用：-35"><a href="#使用：-35" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()    </span><br><span class="line">    &#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...    </span><br><span class="line">    compile &apos;com.marshalchen.ultimaterecyclerview:library:0.7.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="47-uCrop"><a href="#47-uCrop" class="headerlink" title="47.uCrop"></a>47.uCrop</h5><blockquote><p>一句话介绍：一款优雅的图片裁剪框架</p></blockquote><p>上榜理由：5.3K个star，图片编辑模块单独拎出来也是一款优雅的App。</p><ul><li>github：<a href="https://github.com/Yalantis/uCrop" target="_blank" rel="noopener">https://github.com/Yalantis/uCrop</a></li><li>作者：Yalantis</li></ul><h5 id="使用：-36"><a href="#使用：-36" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">   repositories &#123;  </span><br><span class="line">      jcenter()      </span><br><span class="line">      maven &#123; url &quot;https://jitpack.io&quot; &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile &apos;com.github.yalantis:ucrop:2.2.1&apos;</span><br></pre></td></tr></table></figure><h5 id="48-RxJava-Android-Samples"><a href="#48-RxJava-Android-Samples" class="headerlink" title="48.RxJava-Android-Samples"></a>48.RxJava-Android-Samples</h5><blockquote><p>一句话介绍：一款介绍RxJava使用场景的app</p></blockquote><p>上榜理由：榜单出现的第一个“仅仅为告诉你如何使用另一个项目”的开源项目，它可以说是RxJava的用例，你想得到的想不到的RxJava用法这里都有，这就是为什么它以5.2k个star矗立在这份榜单里的原因。遗憾自己没有创作这么一个受人追捧的demo？赶快动手写个其他的“XX项目用例吧”</p><ul><li>github：<a href="https://github.com/kaushikgopal/RxJava-Android-Samples" target="_blank" rel="noopener">https://github.com/kaushikgopal/RxJava-Android-Samples</a></li><li>作者：kaushikgopal</li></ul><h5 id="使用：-37"><a href="#使用：-37" class="headerlink" title="使用："></a>使用：</h5><p>clone到本地慢慢探索吧</p><h5 id="49-AndroidAutoLayout"><a href="#49-AndroidAutoLayout" class="headerlink" title="49.AndroidAutoLayout"></a>49.AndroidAutoLayout</h5><blockquote><p>一句话介绍：一个提供适配能力的框架</p></blockquote><p>上榜理由：5.2K个star，鸿洋老弟的作品，适合小项目的开发团队，拿到设计MM的px像素设计稿是不是很头疼捏？这个框架一键式搞定你的问题，它有很多的不足，但在追求完美适配的路上，你值得探索和了解它！笔者并不推荐把它应用到已经成熟运行的项目中，毕竟市面上已经有太多的适配解决方案了，适配问题就像是个大杂烩，想炒一盘好菜，就得备好各种佐料（适配小方案），当你把各种小佐料用的炉火纯青的时候，你离美食大厨就不远了。</p><ul><li>github：<a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="noopener">https://github.com/hongyangAndroid/AndroidAutoLayout</a></li><li>作者：张鸿洋</li></ul><h5 id="使用：-38"><a href="#使用：-38" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.zhy:autolayout:1.4.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="50-EffectiveAndroidUI"><a href="#50-EffectiveAndroidUI" class="headerlink" title="50.EffectiveAndroidUI"></a>50.EffectiveAndroidUI</h5><blockquote><p>一句话介绍：一款讲解高效展示UI的教学型App</p></blockquote><p>上榜理由：编程新手很难对MVC MVP,MVVM等模式有深刻的理解，如果有一个示例型app，那对初学者会有很大裨益，笔者在遇到它时也是相见恨晚。4.8K个star，证明了它经受了广大开发者的考验与审视，其中Effective UI的编程思想更是与Android官方课程里的Effective UI课程不谋而合，并且，此项目还包含了fragment、dagger、主题样式、Butterknife等众多小知识点，作为编程初学者的学习用例再适合不过了</p><ul><li>github：<a href="https://github.com/pedrovgs/EffectiveAndroidUI" target="_blank" rel="noopener">https://github.com/pedrovgs/EffectiveAndroidUI</a></li><li>作者：Pedro Vicente</li></ul><h5 id="使用：-39"><a href="#使用：-39" class="headerlink" title="使用："></a>使用：</h5><p>clone项目到本地</p><h5 id="51-Luban"><a href="#51-Luban" class="headerlink" title="51.Luban"></a>51.Luban</h5><blockquote><p>一句话介绍：最接近微信的图片压缩框架</p></blockquote><p>上榜理由：好的思路总是可以让你大放异彩，Luban仅以图片压缩单一功能，俘获了4.8K个star，证明了它在图片压缩上的造诣，它可能不是最优秀的，但它是让你我最接近伟大的项目</p><ul><li>github：<a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">https://github.com/Curzibn/Luban</a></li><li>作者：Curzibn</li></ul><h5 id="使用：-40"><a href="#使用：-40" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;top.zibin:Luban:1.1.1&apos;</span><br></pre></td></tr></table></figure><h5 id="52-DroidPlugin"><a href="#52-DroidPlugin" class="headerlink" title="52.DroidPlugin"></a>52.DroidPlugin</h5><blockquote><p>一句话介绍：一款热门的插件化开发框架</p></blockquote><p>上榜理由：4.8K个star，插件化框架榜单第一名，，360团队出品，框架质量有保证，有成功案例——360手机助手，并且持续维护着</p><ul><li>github：<a href="https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md" target="_blank" rel="noopener">https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md</a></li><li>作者：Andy Zhang</li></ul><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用:"></a>使用:</h5><p>clone项目到本地</p><h5 id="53-otto"><a href="#53-otto" class="headerlink" title="53.otto"></a>53.otto</h5><blockquote><p>一句话介绍:一款老旧且强大的事件总线框架</p></blockquote><p>上榜理由：4.8K个star，是square团队早先推出的事件响应型框架，淘宝app的事件驱动也是基于此框架封装的，如今square已经建议开发者采用RxJava RxAndroid来代替otto了。但otto仍有与EventBus横向对比的价值，纵向来说，otto与square自家开发的Rx系列框架的差异同样值得开发者们去探究。</p><ul><li>github <a href="https://github.com/square/otto" target="_blank" rel="noopener">https://github.com/square/otto</a></li><li>作者：square</li></ul><h5 id="使用：-41"><a href="#使用：-41" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()    </span><br><span class="line">    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile &apos;com.michaelpardo:activeandroid:3.1.0-SNAPSHOT&apos;</span><br></pre></td></tr></table></figure><h5 id="54-u2020"><a href="#54-u2020" class="headerlink" title="54.u2020"></a>54.u2020</h5><blockquote><p>一句话介绍：一款提供Dagger的高级教学示例的app（额，名字是有点绕）</p></blockquote><p>上榜理由：4.7K个star，JakeWharton牵头开发的教学类app，教你使用Dagger在其他高级框架的用法，它展示了Dagger与ButterKnife、Retrofit、Moshi、Picasso、Okhttp、RxJava、Timber、Madge、LeakCanar等众多优秀框架结合起来的高级用法，你也可以借鉴到自己的项目当中</p><ul><li>github：<a href="https://github.com/JakeWharton/u2020" target="_blank" rel="noopener">https://github.com/JakeWharton/u2020</a></li><li>作者：JakeWharton</li></ul><h5 id="55-buck"><a href="#55-buck" class="headerlink" title="55.buck"></a>55.buck</h5><blockquote><p>一句话介绍：buck是一个快速构建系统</p></blockquote><p>上榜理由：facebook+google出身的作者，对构建代码的出色理解，加上大型团队的维护，以及增量更新时的快速高效，让buck成为了微信Android团队构建项目的首选，构建大型项目时，它比gradle更快，然而中小公司并不适合此框架，但作为立志在框架设计领域有一番作为的人们，欢迎来一探究竟</p><ul><li>官网地址：<a href="https://buckbuild.com/" target="_blank" rel="noopener">https://buckbuild.com/</a></li><li>github：<a href="https://github.com/facebook/buck" target="_blank" rel="noopener">https://github.com/facebook/buck</a></li><li>作者：facebook</li></ul><h5 id="使用：-42"><a href="#使用：-42" class="headerlink" title="使用："></a>使用：</h5><p>linux or mac system  +docs</p><h5 id="56-PermissionsDispatcher"><a href="#56-PermissionsDispatcher" class="headerlink" title="56.PermissionsDispatcher"></a>56.PermissionsDispatcher</h5><blockquote><p>一句话介绍：一款基于注解的提供解决运行时危险权限方案的框架</p></blockquote><p>上榜理由：自Android6.0 Google提出危险权限一词起，用户安全性被提到一定的高度，一些运行时对用户较为危险的权限将不再自动被开发者获取，需要经过用户批准，开发者才可以继续使用该权限，如果你曾经被权限问题搞的抓耳挠腮，建议你试试这个框架，它足够解决你的问题</p><ul><li>官网地址：<a href="https://hotchemi.github.io/PermissionsDispatcher/" target="_blank" rel="noopener">https://hotchemi.github.io/PermissionsDispatcher/</a></li><li>github：<a href="https://github.com/hotchemi/PermissionsDispatcher" target="_blank" rel="noopener">https://github.com/hotchemi/PermissionsDispatcher</a></li><li>作者：Shintaro Katafuchi</li></ul><h5 id="使用：-43"><a href="#使用：-43" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile(&apos;com.github.hotchemi:permissionsdispatcher:$&#123;latest.version&#125;&apos;) &#123;</span><br><span class="line">        exclude module: &quot;support-v13&quot;  </span><br><span class="line">  &#125;  </span><br><span class="line">  annotationProcessor &apos;com.github.hotchemi:permissionsdispatcher-processor:$&#123;latest.version&#125;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  jcenter()  </span><br><span class="line">  maven &#123; url &apos;http://oss.jfrog.org/artifactory/oss-snapshot-local/&apos; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="57-android-gif-drawable"><a href="#57-android-gif-drawable" class="headerlink" title="57.android-gif-drawable"></a>57.android-gif-drawable</h5><blockquote><p>一句话介绍:一款提供展示GIF动画能力的视图框架</p></blockquote><p>上榜理由：据我所查国内著名App——知乎使用了android-gif-drawable，因此证明了它的存在价值，尽管在榜单第十一位介绍了lottie-android直接应用AE动画的示例，但AE设计师不是每个公司都配备的，GIF的存在，就必然存在了展示GIF的需要，它值得你拥有！</p><ul><li>github：<a href="https://github.com/koral--/android-gif-drawable" target="_blank" rel="noopener">https://github.com/koral--/android-gif-drawable</a></li><li>作者：Karol Wrótniak</li></ul><h5 id="使用：-44"><a href="#使用：-44" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()    </span><br><span class="line">    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;pl.droidsonroids.gif:android-gif-drawable:1.2.+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="58-Apktool"><a href="#58-Apktool" class="headerlink" title="58.Apktool"></a>58.Apktool</h5><blockquote><p>一句话介绍：一款反编译apk的工具</p></blockquote><p>上榜理由：开源的反编译工具，对于志在了解apk逆向破解的诸位，值得拥有，4.5k个star，逆向破解apk神器！</p><ul><li>github：<a href="https://github.com/iBotPeaches/Apktool" target="_blank" rel="noopener">https://github.com/iBotPeaches/Apktool</a></li><li>官网地址：<a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">https://ibotpeaches.github.io/Apktool/</a></li><li>作者：Connor Tumbleson</li></ul><h5 id="59-dynamic-load-apk"><a href="#59-dynamic-load-apk" class="headerlink" title="59.dynamic-load-apk"></a>59.dynamic-load-apk</h5><blockquote><p>一句话介绍：插件化开发框架</p></blockquote><p>上榜理由：4.5k个star，位于插件化开发框架第二名（第一名来自360团队），全面的文档介绍让你很快就能上手插件化开发，如果你喜欢大段文字讲解，那么这个项目一定适合你</p><ul><li>github：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">https://github.com/singwhatiwanna/dynamic-load-apk</a></li><li>作者：singwhatiwanna</li></ul><h5 id="使用：-45"><a href="#使用：-45" class="headerlink" title="使用："></a>使用：</h5><p>github上的文档配合作者博客更配哟</p><h5 id="60-atlas"><a href="#60-atlas" class="headerlink" title="60.atlas"></a>60.atlas</h5><blockquote><p>一句话介绍：淘宝推出的组件化开发框架</p></blockquote><p>上榜理由：淘宝团队所出的精品，atlas框架提供了解耦、组件、动态的开发能力，4.5k个star让他位列组件化开发框架第一名</p><ul><li>github：<a href="https://github.com/alibaba/atlas" target="_blank" rel="noopener">https://github.com/alibaba/atlas</a></li><li>作者：alibaba</li></ul><h5 id="61-volley"><a href="#61-volley" class="headerlink" title="61.volley"></a>61.volley</h5><blockquote><p>一句话介绍：google推荐使用的Android端网络请求框架</p></blockquote><p>上榜理由：4.4k个star，并不是他不够优秀，而是使用volley已经渐渐成为广大开发者的习惯</p><ul><li>github：<a href="https://github.com/google/volley（新版volley地址）" target="_blank" rel="noopener">https://github.com/google/volley（新版volley地址）</a></li><li>作者：google</li></ul><h5 id="使用：-46"><a href="#使用：-46" class="headerlink" title="使用："></a>使用：</h5><p>clone源码到本地</p><h5 id="62-androidmvp"><a href="#62-androidmvp" class="headerlink" title="62.androidmvp"></a>62.androidmvp</h5><blockquote><p>一句话介绍：一款展示Android端Mvp设计的demo</p></blockquote><p>上榜理由：榜单里为数不多、仅凭展示某种设计模式就获得4.2K个star的项目，如果你有尝试mvp的打算，androidmvp可以作为你的前哨站</p><ul><li>github：<a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="noopener">https://github.com/antoniolg/androidmvp</a></li><li>作者：Antonio Leiva</li></ul><h5 id="使用：-47"><a href="#使用：-47" class="headerlink" title="使用："></a>使用：</h5><p>clone到本地</p><h5 id="63-SwipeBackLayout"><a href="#63-SwipeBackLayout" class="headerlink" title="63.SwipeBackLayout"></a>63.SwipeBackLayout</h5><blockquote><p>一句话介绍:一款可以让你通过滑动手势关闭页面的的框架</p></blockquote><p>上榜理由：仿微信滑动退出当前聊天界面的效果，提供了activity的滑动关闭能力，通过这种思路，实现fragment的滑动关闭轻而易举;笔者坚持建议诸位clone源码到本地探索一番；4.2k个star证明很多人都喜爱它</p><ul><li>github：<a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="noopener">https://github.com/ikew0ng/SwipeBackLayout</a></li><li>作者：ike_w0ng</li></ul><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用:"></a>使用:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;me.imid.swipebacklayout.lib:library:1.0.0&apos;</span><br></pre></td></tr></table></figure><h5 id="64-FlycoTabLayout"><a href="#64-FlycoTabLayout" class="headerlink" title="64.FlycoTabLayout"></a>64.FlycoTabLayout</h5><blockquote><p>一句话介绍：一款可以让作出多种多样指示器效果的框架</p></blockquote><p>上榜理由：尽管我们没有理由为了给app加入页面指示器功能就集成2.5M的依赖库，但是作为了解viewpager或swip views的指示器设计原理的优秀框架，你值得打开它试试，笔者建议单独拆分所需源码，加入到自己的项目中去。4.1K个star，二次开发的作品，仍然推荐！</p><ul><li>github：<a href="https://github.com/H07000223/FlycoTabLayout" target="_blank" rel="noopener">https://github.com/H07000223/FlycoTabLayout</a></li><li>作者：Flyco</li></ul><h5 id="65-android-testing"><a href="#65-android-testing" class="headerlink" title="65.android-testing"></a>65.android-testing</h5><blockquote><p>一句话介绍：一款展示四大自动化测试框架用例的demo（Espresso，UiAutomator，AndroidJunitRunner，JUnit4）</p></blockquote><p>上榜理由：学习者经常会陷入似懂非懂的境地，如果你有幸学习过Android Testing Support Library site的课程，那么你一定对android的四大测试框架迫不及待，这款demo非常适合你，快来学习这个4.1k个star的明星项目吧</p><ul><li>github：<a href="https://github.com/googlesamples/android-testing" target="_blank" rel="noopener">https://github.com/googlesamples/android-testing</a></li><li>作者：googlesampes团队</li></ul><h5 id="66-FileDownloader"><a href="#66-FileDownloader" class="headerlink" title="66.FileDownloader"></a>66.FileDownloader</h5><blockquote><p>一句话介绍：一款高效、稳定、灵活、易用的文件下载引擎</p></blockquote><p>上榜理由：4.1k证明了它有多受人喜爱，文件下载看似简单的背后暗藏了多少的坑坑点点，我知道你有能力自己实现文件下载功能，但优秀的框架可以提升你的设计编码能力，这款框架可以提升你的实力！</p><ul><li>github：<a href="https://github.com/lingochamp/FileDownloader" target="_blank" rel="noopener">https://github.com/lingochamp/FileDownloader</a></li><li>作者：LingoChamp团队</li></ul><h5 id="使用：-48"><a href="#使用：-48" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.liulishuo.filedownloader:library:1.5.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="67-JieCaoVideoPlayer"><a href="#67-JieCaoVideoPlayer" class="headerlink" title="67.JieCaoVideoPlayer"></a>67.JieCaoVideoPlayer</h5><blockquote><p>一句话介绍：基于MediaPlayer api——VideoView 的多媒体播放框架</p></blockquote><p>上榜理由：榜单里第三款多媒体播放框架，它以灵巧的身姿挤入本榜单，精巧是它最大的优点，不到100k，拥有它，你就可以快速开发类似今日头条那样的视频播放效果，4k个star，证明它值得一试</p><ul><li>github：<a href="https://github.com/lipangit/JieCaoVideoPlayer" target="_blank" rel="noopener">https://github.com/lipangit/JieCaoVideoPlayer</a></li><li>作者：Nathen</li></ul><h5 id="使用：-49"><a href="#使用：-49" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;fm.jiecao:jiecaovideoplayer:5.5.4&apos;</span><br></pre></td></tr></table></figure><h5 id="68-glide-transformations"><a href="#68-glide-transformations" class="headerlink" title="68.glide-transformations"></a>68.glide-transformations</h5><blockquote><p>一句话介绍：为众多著名图片加载框架提供图片形状变幻能力的框架</p></blockquote><p>上榜理由：在榜单靠前的部分已经介绍过glide，Picasso，Fresco等图片加载框架，glide-transformations就是一款为他们提供图片变形能力的框架，使用起来非常简单，因此受到了大家的喜爱，github上有3.8K个star</p><ul><li>github：<a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="noopener">https://github.com/wasabeef/glide-transformations</a></li><li>作者：Daichi Furiya</li></ul><h5 id="使用：-50"><a href="#使用：-50" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;jp.wasabeef:glide-transformations:2.0.2&apos;    </span><br><span class="line">    // If you want to use the GPU Filters    </span><br><span class="line">    compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Glide里设置变幻效果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set Glide Transform.</span><br><span class="line"></span><br><span class="line">Glide.with(this).load(R.drawable.demo) </span><br><span class="line">       .bitmapTransform(new BlurTransformation(context))        </span><br><span class="line">       .into((ImageView) findViewById(R.id.image));</span><br></pre></td></tr></table></figure><h5 id="69-android-gpuimage"><a href="#69-android-gpuimage" class="headerlink" title="69.android-gpuimage"></a>69.android-gpuimage</h5><blockquote><p>一句话介绍：一款基于OpenGL的图片渲染引擎</p></blockquote><p>上榜理由：放下GpuImage在IOS平台的荣誉不谈，Android版的android-gpuimage就提供多达70多种图片渲染效果，你还在好奇美图秀秀是如何实现图片变幻的？有了它，一切都不是问题。如果你是美图工具类的工程师，此框架的建设思路也会对你大有裨益。笔者也是通过android-gpuimage仿造了美图App并俘获女友芳心的，再次为它的实力点赞。ios版+android版一共19k个star，已经证明了它的实力，还在等什么呢？</p><ul><li>github：<a href="https://github.com/CyberAgent/android-gpuimage" target="_blank" rel="noopener">https://github.com/CyberAgent/android-gpuimage</a></li><li>作者：CyberAgent 团队</li></ul><h5 id="使用：-51"><a href="#使用：-51" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的改造方法，还需要阅读Ios的编程文档，对于有毅力的小伙伴强力推荐！</p><h5 id="70-RxPermissions"><a href="#70-RxPermissions" class="headerlink" title="70.RxPermissions"></a>70.RxPermissions</h5><blockquote><p>一句话介绍：一款基于RxJava完成权限申请的框架</p></blockquote><p>上榜理由：榜单里第二款提供权服务的框架，基于RxJava的设计，让你可以专心写业务，3.7K个star已经证明了它的实用价值</p><ul><li>github：<a href="https://github.com/tbruyelle/RxPermissions" target="_blank" rel="noopener">https://github.com/tbruyelle/RxPermissions</a></li><li>作者：Thomas Bruyelle</li></ul><h5 id="使用：-52"><a href="#使用：-52" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter() // If not already there</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅的使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RxPermissions rxPermissions = new RxPermissions(this); </span><br><span class="line"></span><br><span class="line">rxPermissions</span><br><span class="line">    .request(Manifest.permission.CAMERA)    </span><br><span class="line">    .subscribe(granted -&gt; &#123;   </span><br><span class="line">        if (granted) &#123; // I can control the camera now        </span><br><span class="line">        &#125; else &#123;       </span><br><span class="line">           // Oups permission denied       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h5 id="71-freeline"><a href="#71-freeline" class="headerlink" title="71.freeline"></a>71.freeline</h5><blockquote><p>一句话介绍：一款动态替换的编译构建框架</p></blockquote><p>上榜理由：继Facebook的Buck，Androdi官方的InstRun之后，蚂蚁金服推出了Freeline编译框架，官网宣称Freeline与业内主流构建方式相比仍然有数倍的速度领先;排行有先后，编译速度并不在本榜单排序的考据因素中，因此freeline以3.7个star，暂列编译框架第二名</p><ul><li>官网地址：<a href="https://www.freelinebuild.com/" target="_blank" rel="noopener">https://www.freelinebuild.com/</a></li><li>github：<a href="https://github.com/alibaba/freeline" target="_blank" rel="noopener">https://github.com/alibaba/freeline</a></li><li>作者：alibaba</li></ul><h5 id="使用：-53"><a href="#使用：-53" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;   </span><br><span class="line">        jcenter()   </span><br><span class="line">    &#125;    </span><br><span class="line">    dependencies &#123; </span><br><span class="line">       classpath &apos;com.antfortune.freeline:gradle:0.8.7&apos;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;com.antfortune.freeline&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>File → Settings… → Plugins → Browse repositories →freeline.</p></blockquote><h5 id="72-RxLifecycle"><a href="#72-RxLifecycle" class="headerlink" title="72.RxLifecycle"></a>72.RxLifecycle</h5><blockquote><p>一句话介绍：一款提供在使用RxJava过程中管理Activity和Fragment生命周期能力的框架</p></blockquote><p>上榜理由：在榜单靠前的部分，你已经了解RxJava和RxAndroid的强大之处，但部分粗心的开发者因为没有及时取消订阅而产生严重的内存泄漏，不要担心，RxLifecycle可以为你解决难题，在gtihub上拥有3.7K个star，国内知名软件——知乎和淘宝也都在使用它</p><ul><li>github：<a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">https://github.com/trello/RxLifecycle</a></li><li>作者：trello团队</li></ul><h5 id="使用：-54"><a href="#使用：-54" class="headerlink" title="使用："></a>使用：</h5><p>clone源码到本地</p><h5 id="73-classyshark"><a href="#73-classyshark" class="headerlink" title="73.classyshark"></a>73.classyshark</h5><blockquote><p>一句话介绍：一款可执行文件浏览器</p></blockquote><p>上榜理由：榜单里继Apktool之后第二款apk逆向工具，如果你喜欢优雅的图形数据展示，那么你一定不能错过他，classyshark可以将破解的结果以图形化展示用户，方便分析，3.7K个star，让它暂列apk逆向工具第二位！</p><ul><li>github：<a href="https://github.com/google/android-classyshark" target="_blank" rel="noopener">https://github.com/google/android-classyshark</a></li><li>作者：google</li></ul><h5 id="使用：-55"><a href="#使用：-55" class="headerlink" title="使用："></a>使用：</h5><p>下载 JAR</p><h5 id="74-acra"><a href="#74-acra" class="headerlink" title="74.acra"></a>74.acra</h5><blockquote><p>一句话介绍：一款提供记录APP崩溃日志能力的框架</p></blockquote><p>上榜理由：如果你面临着收集APP崩溃日志的需求，那么acra是个不错的选择。3.7K个star，让acra位列崩溃日志框架排行榜第一名，acra有足够的能力记录线上APP，并且发回服务端，acra也提供了相当棒的崩溃日志统计服务端框架Acralyzer，cralyzer工作在Apache CouchDB之上，所以除了CouchDB之外，没有必要安装任何额外的软件，移动端开发者也可以借此学习服务端的建设，一举两得！</p><ul><li>github：<a href="https://github.com/ACRA/acra" target="_blank" rel="noopener">https://github.com/ACRA/acra</a></li><li>服务端github：<a href="https://github.com/ACRA/acralyzer" target="_blank" rel="noopener">https://github.com/ACRA/acralyzer</a></li><li>作者：acra团队</li></ul><h5 id="使用：-56"><a href="#使用：-56" class="headerlink" title="使用："></a>使用：</h5><p>没有什么方法比clone源码到本地更方便了</p><h5 id="75-DiskLruCache"><a href="#75-DiskLruCache" class="headerlink" title="75.DiskLruCache"></a>75.DiskLruCache</h5><blockquote><p>一句话介绍：一款提供磁盘文件缓存管理能力的框架</p></blockquote><p>上榜理由：3.7k个star并不足以说明DiskLruCache的优秀，仅仅以管理磁盘文件能力单独拎出来成为一个框架，作者需要很大的勇气，很幸运，作者做到了，并且也成为Google官网提倡的缓存  ；如还记得上次做“一键清除缓存”、“查看缓存文件大小”功能是什么时候吗？DiskLruCache一句话就可以搞定！</p><ul><li>github：<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">https://github.com/JakeWharton/DiskLruCache</a></li><li>作者：JakeWharton</li></ul><h5 id="使用：-57"><a href="#使用：-57" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.jakewharton:disklrucache:2.0.2&apos;</span><br></pre></td></tr></table></figure><p>或者下载 latest .jar</p><h5 id="76-dexposed"><a href="#76-dexposed" class="headerlink" title="76.dexposed"></a>76.dexposed</h5><blockquote><p>一句话介绍：一款支撑阿里大部分App客户端热修复、线上调试能力的框架</p></blockquote><p>上榜理由：榜单上再次出现热修复框架的身影，证明App热修复技术的火热，dexposed提供图形化的性能监控、在线热修复bug漏洞、支持AOP编程思想等，不论你是企业热修复技术的设计者还是打算在热修复领域一探究竟的新人，这款框架很适合你。3.5k个star，证明它作为一门技术框架的存在，是多么令人喜爱！</p><ul><li>github：<a href="https://github.com/alibaba/dexposed" target="_blank" rel="noopener">https://github.com/alibaba/dexposed</a></li><li>作者：alibaba</li></ul><h5 id="使用：-58"><a href="#使用：-58" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.taobao.android:dexposed:0.1.1@aar&apos;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="77-Litho"><a href="#77-Litho" class="headerlink" title="77.Litho"></a>77.Litho</h5><blockquote><p>一句话介绍：一款提供高效构建UI能力的框架</p></blockquote><p>上榜理由：作为一款专门构建UI的框架，Litho高效的地方在于：单独开辟了用于渲染和布局的线程，然后将创建好的组件传递给UI线程去完成最终的渲染，使用更少的视图层级，来提升界面的滚动速度，值得注意的是，它仅支持开发者作出不可改变的UI组件 ,3.5K个star，证明了它在构建UI领域的价值，更多的妙处，期待你亲自去发掘！</p><ul><li>github：<a href="https://github.com/facebook/litho" target="_blank" rel="noopener">https://github.com/facebook/litho</a></li><li>作者：facebook</li></ul><h5 id="使用：-59"><a href="#使用：-59" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // ...  </span><br><span class="line">  // Litho  </span><br><span class="line">  compile &apos;com.facebook.litho:litho-core:0.3.1&apos;  </span><br><span class="line">  compile &apos;com.facebook.litho:litho-widget:0.3.1&apos;  </span><br><span class="line">  provided &apos;com.facebook.litho:litho-annotations:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  annotationProcessor &apos;com.facebook.litho:litho-processor:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  // SoLoader  </span><br><span class="line">  compile &apos;com.facebook.soloader:soloader:0.2.0&apos;  </span><br><span class="line"></span><br><span class="line">  // Optional  </span><br><span class="line">  // For debugging  </span><br><span class="line">  debugCompile &apos;com.facebook.litho:litho-stetho:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  // For integration with Fresco  </span><br><span class="line">  compile &apos;com.facebook.litho:litho-fresco:0.3.1&apos;  </span><br><span class="line"></span><br><span class="line">  // For testing  </span><br><span class="line">  testCompile &apos;com.facebook.litho:litho-testing:0.3.1&apos;&#125;</span><br></pre></td></tr></table></figure><h5 id="78-mosby"><a href="#78-mosby" class="headerlink" title="78.mosby"></a>78.mosby</h5><blockquote><p>一句话介绍：一款提供构建MVP项目能力的框架</p></blockquote><p>上榜理由：榜单靠前的部分已经介绍了MVC,MVVM,MVP的框架项目，想必此时你在构建企业项目架构上，选择或者开发一款合适的MVP框架迫在眉睫，mosby可以作为你的第一步参考，你可以封装它，也可以照抄它，无论如何，3.4K个star，证明了它在框架设计上有多受开发者的喜爱</p><ul><li>github：<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="noopener">https://github.com/sockeqwe/mosby</a></li><li>作者：Hannes Dorfmann</li></ul><h5 id="使用：-60"><a href="#使用：-60" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">  compile &apos;com.hannesdorfmann.mosby3:mvi:3.0.4&apos; // Model-View-Intent  </span><br><span class="line">  // or  </span><br><span class="line">  compile &apos;com.hannesdorfmann.mosby3:mvp:3.0.4&apos; // Plain MVP  </span><br><span class="line">  // or  </span><br><span class="line">  compile &apos;com.hannesdorfmann.mosby3:viewstate:3.0.4&apos; // MVP + ViewState support</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">      ...    </span><br><span class="line"></span><br><span class="line">      maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="79-AndResGuard"><a href="#79-AndResGuard" class="headerlink" title="79.AndResGuard"></a>79.AndResGuard</h5><blockquote><p>一句话介绍：一款提供资源文件路径混淆 的工具</p></blockquote><p>上榜理由：如果你是个对APK大小很敏感的人，那么AndResGuard一定适合你，它的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a，3.4K个star，证明了在优化APK道路上，你不是一个人在战斗！</p><ul><li>github：<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">https://github.com/shwenzhang/AndResGuard</a></li><li>作者：wechat team</li></ul><h5 id="使用：-61"><a href="#使用：-61" class="headerlink" title="使用："></a>使用：</h5><p>clone项目到本地，其实也就是个三两句话的文档</p><h5 id="80-StatusBarUtil"><a href="#80-StatusBarUtil" class="headerlink" title="80.StatusBarUtil"></a>80.StatusBarUtil</h5><blockquote><p>一句话介绍：一款提供设置沉浸式状态栏样式能力的框架</p></blockquote><p>上榜理由：设计师MM总是抱怨系统状态栏不优雅？那就给她一个完美的沉浸式状态栏。StatusBarUtil可以随心所欲的设置状态栏样式，3.3K个star，足以说明它有多受设计MM的喜爱</p><ul><li>github：<a href="https://github.com/laobie/StatusBarUtil" target="_blank" rel="noopener">https://github.com/laobie/StatusBarUtil</a></li><li>作者：Jaeger</li></ul><h5 id="使用：-62"><a href="#使用：-62" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.jaeger.statusbarutil:library:1.4.0&apos;</span><br></pre></td></tr></table></figure><h5 id="81-robolectric"><a href="#81-robolectric" class="headerlink" title="81.robolectric"></a>81.robolectric</h5><blockquote><p>一句话介绍：一款不依赖于Android设备的单元测试框架，</p></blockquote><p>上榜理由：sample中列举了如何对Android四大组件和常见功能测试的用例，3.2K个star，值得充满好奇心的人尝试</p><ul><li>官网地址：<a href="http://robolectric.org/" target="_blank" rel="noopener">http://robolectric.org/</a></li><li>github：<a href="https://github.com/robolectric/robolectric" target="_blank" rel="noopener">https://github.com/robolectric/robolectric</a></li><li>作者：robolectric</li></ul><h5 id="使用：-63"><a href="#使用：-63" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">testCompile &quot;org.robolectric:robolectric:3.3.2&quot;</span><br></pre></td></tr></table></figure><h5 id="82-Fragmentation"><a href="#82-Fragmentation" class="headerlink" title="82.Fragmentation"></a>82.Fragmentation</h5><blockquote><p>一句话介绍:一款提供管理Fragmen嵌套t能力的框架</p></blockquote><p>上榜理由：对于Activity和Fragment使用，你一定得心应手，但如果要做一套通用的Activity&amp;Fragment嵌套设计，想必你有点手足无措了，Fragmentation可以作为你设计Fragment管理上的第一步，3.2K个star，笔者认为有点名副其实了，项目介绍里说的是Fragment的管理能力，但并未提供Fragment&amp;Activity生命周期、任务栈的管理能力，因此很难直接应用到企业项目当中，但源码当中的设计思路，值得笔者与诸位借鉴，拾人牙慧留有余香！</p><ul><li>github：<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="noopener">https://github.com/YoKeyword/Fragmentation</a></li><li>作者：YoKey</li></ul><h5 id="使用：-64"><a href="#使用：-64" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// appcompat v7包是必须的compile ‘me.yokeyword:fragmentation:0.10.7’// 如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，请再添加下面的库// compile ‘me.yokeyword:fragmentation-swipeback:0.10.4’</span><br></pre></td></tr></table></figure><h5 id="83-Small"><a href="#83-Small" class="headerlink" title="83.Small"></a>83.Small</h5><blockquote><p>一句话介绍：轻巧的插件化框架</p></blockquote><p>上榜理由：作为插件框架榜单的新成员，Small的优点是轻巧，适合作为小团队的插件开发方案，3.1K个star，让它获得了酷狗音乐等著名开发团队的青睐，如果你们的团队想逐步实施插件化开发，Small是个不错的选择！</p><ul><li>官网地址：<a href="http://code.wequick.net/Small/cn/cases" target="_blank" rel="noopener">http://code.wequick.net/Small/cn/cases</a></li><li>github：<a href="https://github.com/wequick/Small" target="_blank" rel="noopener">https://github.com/wequick/Small</a></li><li>作者：wequick 团队</li></ul><h5 id="使用：-65"><a href="#使用：-65" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript  &#123;</span><br><span class="line">    dependencies &#123;  </span><br><span class="line">          classpath &apos;net.wequick.tools.build:gradle-small:1.2.0-alpha6&apos;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;net.wequick.small&apos;small &#123; </span><br><span class="line">   aarVersion = &apos;1.2.0-alpha6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="84-JsBridge"><a href="#84-JsBridge" class="headerlink" title="84.JsBridge"></a>84.JsBridge</h5><blockquote><p>一句话介绍：一款提供WebView和Javascript通信能力的框架</p></blockquote><p>上榜理由：该框架提供给了允许H5页面调用通过JS调用App方法的能力；3.1K个star，简洁的通讯方式，值得每一个WebHybrid App开发者尝试</p><ul><li>gtihub：<a href="https://github.com/lzyzsd/JsBridge" target="_blank" rel="noopener">https://github.com/lzyzsd/JsBridge</a></li><li>作者：hi大头鬼hi</li></ul><h5 id="使用：-66"><a href="#使用：-66" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    // ...    </span><br><span class="line">    maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; </span><br><span class="line">   compile &apos;com.github.lzyzsd:jsbridge:1.0.4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="85-richeditor-android"><a href="#85-richeditor-android" class="headerlink" title="85.richeditor-android"></a>85.richeditor-android</h5><blockquote><p>一句话介绍：一款强大的富文本编辑框架</p></blockquote><p>上榜理由：2.8k个star，榜单里第一个为TextView提供扩展能力的框架，你暂时不需要它，但不能不知道它</p><ul><li>github：<a href="https://github.com/wasabeef/richeditor-android" target="_blank" rel="noopener">https://github.com/wasabeef/richeditor-android</a></li><li>作者：Daichi Furiya</li></ul><h5 id="使用：-67"><a href="#使用：-67" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;jp.wasabeef:richeditor-android:1.2.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="86-Transitions-Everywhere"><a href="#86-Transitions-Everywhere" class="headerlink" title="86.Transitions-Everywhere"></a>86.Transitions-Everywhere</h5><blockquote><p>一句话介绍：一款教你正确使用Transitions API（Android 转场动画API）的教学型项目</p></blockquote><p>上榜理由：你可能还未尝试过Android API的Transitions 框架，可能听过，但却无法做出优雅奇妙的动效——别担心，Transitions-Everywhere正如它的名字一样，它将带你全面体验Transitions 的强大之处</p><ul><li>github：<a href="https://github.com/andkulikov/Transitions-Everywhere" target="_blank" rel="noopener">https://github.com/andkulikov/Transitions-Everywhere</a></li><li>作者：Andrey Kulikov</li></ul><h5 id="使用：-68"><a href="#使用：-68" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;com.andkulikov:transitionseverywhere:1.7.4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="87-android-viewbadger"><a href="#87-android-viewbadger" class="headerlink" title="87.android-viewbadger"></a>87.android-viewbadger</h5><blockquote><p>一句话介绍：能够快速的为Android 视图加入“勋章”能力的框架</p></blockquote><p>上榜理由：如果说勋章一词听起来陌生，那么显示已读未读个数、小红点标记信息这一类词语你一定不太陌生，笔者相信在诸位实际开发中经常遇到为某些item加入小红点标记的需求，聪明的各位一定有着各种实现方案，为什么不能快速优雅的完成呢？android-viewbadger可以帮你实现，当然，在某些情况下，你需要具备修改源码的能力，以符合设计MM的需求！值得注意的是，这宽项目已经五年没有更新了！</p><ul><li>github：<a href="https://github.com/jgilfelt/android-viewbadger" target="_blank" rel="noopener">https://github.com/jgilfelt/android-viewbadger</a></li><li>作者：Jeff Gilfelt</li></ul><h5 id="使用：-69"><a href="#使用：-69" class="headerlink" title="使用："></a>使用：</h5><p>clone源码到本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View target = findViewById(R.id.target_view);</span><br><span class="line">BadgeView badge = new BadgeView(this, target);</span><br><span class="line">badge.setText(&quot;1&quot;);</span><br><span class="line">badge.show();</span><br></pre></td></tr></table></figure><h5 id="88-AndroidWiFiADB"><a href="#88-AndroidWiFiADB" class="headerlink" title="88.AndroidWiFiADB"></a>88.AndroidWiFiADB</h5><blockquote><p>一句话介绍：一款不用数据线也可以让你调试手机设备APP的插件项目</p></blockquote><p>上榜理由：你是否还在担心测试过程中高强度的拔插数据线对手机电池和USB端口造成终生难以弥补的损害？别担心，有wifi有AndroidWiFiADB，无须数据线也可以调试应用了，更有趣的是，在测试工程师一边拿着手机一边找你聊bug的时候，你已经偷偷在它的手机上修复了bug，深藏功与名！</p><ul><li>github：<a href="https://github.com/pedrovgs/AndroidWiFiADB" target="_blank" rel="noopener">https://github.com/pedrovgs/AndroidWiFiADB</a></li><li>作者：Pedro Vicente Gómez Sánchez</li></ul><h5 id="使用：-70"><a href="#使用：-70" class="headerlink" title="使用："></a>使用：</h5><blockquote><p>Preferences/Settings-&gt;Plugins-&gt;Browse Repositories-&gt;serch AndroidWiFiADB</p></blockquote><h5 id="89-emojicon"><a href="#89-emojicon" class="headerlink" title="89.emojicon"></a>89.emojicon</h5><blockquote><p>一句话介绍：一款提供在TextView、EdiText展示表情包能力的框架</p></blockquote><p>上榜理由：2.7k个star，,榜单第二款增强TextView显示能力的框架，这款专为表情包设计，如果你曾经好奇微信、QQ的表情显示是如何做到的？这款框架一定能满足你的求知欲。</p><h5 id="90-packer-ng-plugin"><a href="#90-packer-ng-plugin" class="headerlink" title="90.packer-ng-plugin"></a>90.packer-ng-plugin</h5><blockquote><p>一句话介绍：一款打爆工具插件</p></blockquote><p>上榜利用：笔者尽力维护榜单涉及范围的全面性，因此引入此插件项目——项目号称完成100个渠道包只需要10秒钟，在市面上各种各样多渠道打包方案的今天，选择一款适合自己团队的，才是上上选择</p><ul><li>github：<a href="https://github.com/mcxiaoke/packer-ng-plugin" target="_blank" rel="noopener">https://github.com/mcxiaoke/packer-ng-plugin</a></li><li>作者：Xiaoke Zhang</li></ul><h5 id="使用：-71"><a href="#使用：-71" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ......    </span><br><span class="line">    dependencies&#123;    </span><br><span class="line">    // add packer-ng </span><br><span class="line">       classpath &apos;com.mcxiaoke.gradle:packer-ng:1.0.9&apos;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">apply plugin: &apos;packer&apos; </span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.mcxiaoke.gradle:packer-helper:1.0.9&apos;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">android &#123;    //...    signingConfigs &#123;</span><br><span class="line">      release &#123;          </span><br><span class="line">      // 满足下面两个条件时需要此配置          </span><br><span class="line">      // 1. Gradle版本 &gt;= 2.14.1          </span><br><span class="line">      // 2. Android Gradle Plugin 版本 &gt;= 2.2.0          </span><br><span class="line">      // 作用是只使用旧版签名，禁用V2版签名模式        </span><br><span class="line">      v2SigningEnabled false       &#125;    &#125;  &#125;</span><br></pre></td></tr></table></figure><h5 id="91-android-priority-jobqueue"><a href="#91-android-priority-jobqueue" class="headerlink" title="91.android-priority-jobqueue"></a>91.android-priority-jobqueue</h5><blockquote><p>一句话介绍：一款提供后台任务管理能力的框架</p></blockquote><p>上榜理由：如果你是个志在深入研究多线程操作的开发者，这个项目一定不要错过，不论是Activity重新加载、Service使用线程池时的任务优先级和并发问题，都不要担心，Job Manage会照顾优先级，持久性，负载平衡，延迟，网络控制，分组，2.4K个star，优秀的多线程管理能力，况且它依赖的第三方框架很少，值得你一试</p><ul><li>github：<a href="https://github.com/yigit/android-priority-jobqueue" target="_blank" rel="noopener">https://github.com/yigit/android-priority-jobqueue</a></li><li>作者：Yigit Boyar</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android框架排行榜&quot;&gt;&lt;a href=&quot;#Android框架排行榜&quot; class=&quot;headerlink&quot; title=&quot;Android框架排行榜&quot;&gt;&lt;/a&gt;Android框架排行榜&lt;/h4&gt;&lt;h5 id=&quot;1-Retrofit&quot;&gt;&lt;a href=&quot;#1-Retrofit&quot; class=&quot;headerlink&quot; title=&quot;1.Retrofit　　&quot;&gt;&lt;/a&gt;1.Retrofit　　&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官网地址：&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://square.github.io/retrofit/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github：&lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/square/retrofit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：square团队&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;使用：&quot;&gt;&lt;a href=&quot;#使用：&quot; class=&quot;headerlink&quot; title=&quot;使用：&quot;&gt;&lt;/a&gt;使用：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.squareup.retrofit2:retrofit:2.3.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;2-okhttp&quot;&gt;&lt;a href=&quot;#2-okhttp&quot; class=&quot;headerlink&quot; title=&quot;2.okhttp&quot;&gt;&lt;/a&gt;2.okhttp&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上榜理由，okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官网地址：&lt;a href=&quot;http://square.github.io/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://square.github.io/okhttp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github：&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/square/okhttp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：square团队&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;使用：-1&quot;&gt;&lt;a href=&quot;#使用：-1&quot; class=&quot;headerlink&quot; title=&quot;使用：&quot;&gt;&lt;/a&gt;使用：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.squareup.okhttp3:okhttp:3.9.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/categories/Android/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="框架" scheme="https://zhangmiao.cc/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android面试总结</title>
    <link href="https://zhangmiao.cc/posts/27a6e4df.html"/>
    <id>https://zhangmiao.cc/posts/27a6e4df.html</id>
    <published>2019-07-10T06:29:31.000Z</published>
    <updated>2019-07-22T09:19:05.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试大纲"><a href="#面试大纲" class="headerlink" title="面试大纲"></a>面试大纲</h3><ul><li>java基础、面向对象、集合、线程使用；</li><li>Android 机型适配、SDK适配、内存优化、内存溢出、内存泄漏；</li><li>MVC/MVP/MVVM的使用场景；</li><li>了解并能使用最新流行开源库RXjava+Retrofit+OKHttp、Glide、EventBus等；</li><li>JNI及NDK的使用、熟悉Framework。</li></ul><a id="more"></a><h3 id="频繁面试题"><a href="#频繁面试题" class="headerlink" title="频繁面试题"></a>频繁面试题</h3><ul><li>1.面向对象（OOP） </li><li>2.数据类型 </li><li>3.equal和==的区别 </li><li>4.字符串运行速度：StringBuilder、StringBuffer、 String </li><li>5.Queue 队列、Stack 栈 </li><li>6.ListView机制 </li><li>7.Fragment生命周期</li><li>8.四大引用类型 </li><li>9.线程、进程及其通信方式 </li><li>10.PackageManagerService </li><li>11.binder机制 </li><li>12.launcher的实现 </li><li>13.Android 版本特性 </li><li>14.BroadcastReceiver广播 </li><li>15.RecycleView </li><li>16.各种集合比较SparseArray、HashMap、ArrayMap、LinkedList、ArrayList </li><li>17.SQLite升级 </li><li>18.Bitmap </li><li>19.Handler机制 </li><li>20.性能优化技巧 </li><li>21.ANR </li><li>22.自定义View </li><li>23.MVC、MVP、MVVM三种架构设计 </li><li>24.APP 启动流程 </li><li>25.插件化 </li><li>26.Kotlin 多平台应用的静态编程语言 </li><li>27.Framework 工作原理 </li><li>28.Android 屏幕适配 </li><li>29.事件分发机制 </li><li>30.Android 动画分类：视图，属性，帧，gif </li><li>31.Android 进程 </li><li>32.Android 五大存储方式 </li><li>33.屏幕旋转Activity生命周期</li><li>34.Activity 四大启动模式 </li><li>35.CPU、GPU工作原理 </li><li>36.UI卡顿原因 </li><li>37.Application的生命周期 </li><li>38.如何避免因引入的开源库导致的安全性和稳定性？ </li><li>39.简单的音频/视频格式 </li><li>40.线程同步的方法</li><li>41.线程安全的单例 </li><li>42.Serializable、Parcelelable </li><li>43.Service启动方式和生命周期 </li><li>44.Android 常见布局 </li><li>45.Http、Https、Volley、OkHttp、RxJava + Retrofit + OkHttp、TCP、UDP </li><li>46.如何节省内存使用，主动回收内存？ </li><li>47.Activity如何生成View？ </li><li>48.为什么要使用多线程？ </li><li>49.现场保护 </li><li>50.内存溢出、内存泄漏</li><li>51.JNI和NDK</li><li>52.常用的设计模式及其实现思想和作用</li><li>53.HashMap、 HashTable、HashSet的异同</li><li>54.Android 中内存泄漏原因及优化方案</li><li>55.LeakCanary 内存泄漏检查的开源工具</li><li>56.多线程、线程池</li><li>57.腾讯 Bugly</li><li>58.Glide</li><li>59.Fresco</li><li>60.React</li></ul><h3 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h3><h4 id="1-面向对象（OOP）"><a href="#1-面向对象（OOP）" class="headerlink" title="1.面向对象（OOP）"></a>1.面向对象（OOP）</h4><p>针对业务处理过程的实体及其属性和行为进行抽象封装以获得高效清晰的逻辑单元划分。  </p><p><strong>三大特性：①封装</strong>（隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变量隔离便于使用，提高代码的服用小和安全性）；②<strong>继承</strong>（提高代码的复用性，继承是多态的前提）；③<strong>多态</strong>（父类或接口定义的引用变量可以指向子类或具体实现类的形象，提高了程序的拓展性）。</p><p><strong>五大原则：</strong>单一职责、开放封闭、里氏替换、依赖倒置、接口分离。</p><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p>byte 1个字符，short 、char2 个字符，int 、float 4个字符，long 、double 8个字符。**</p><p><strong>volatile是一个类型修饰符（type specifier）volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。（from百度）</strong></p><p>volatile的变量是说这变量可能会被意想不到地改变，这样，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E7%BC%96%E8%AF%91%E5%99%A8%2F8853067" target="_blank" rel="noopener">编译器</a>就不会去假设这个变量的值了。</p><p>在JDK1.7之前，switch语句仅支持byte、short、char、int，<strong>在JDK1.7之后，枚举、字符串类型都可以，通过String.hashcode转成int进行判断。</strong></p><p><strong>String不可变原因：字符串常量池的需要；运行String对象缓存HashCode，提高效率；多线程安全。</strong></p><p><strong>String 转integer的方法和原理</strong></p><p> <strong>①</strong>Integer.parseInt（String str）调用Integer内部的；</p><p>②Integer.parseInt（String s, int radix）parseInt内部首先判断字符串是否包含符号（-或者+），则对相应的negative和limit进行赋值，然后再循环字符串，对单个char进行数值计算</p><p>③Character.digit(char ch, int radix) 返回指定基数中字符表示的数值。函数肯定进入到0-9字符的判断（相对于string转换到int），否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。</p><p><strong>限定参数类型的上界：参数类型必须是T或T的子类型</strong></p><p><strong>&lt;? super T&gt; 限定参数类型的下界：参数类型必须是T或T的超类型</strong></p><h4 id="3-equal和-的区别：equal-比较对象，-比较原生类型"><a href="#3-equal和-的区别：equal-比较对象，-比较原生类型" class="headerlink" title="3.equal和==的区别：equal 比较对象，==比较原生类型"></a>3.equal和==的区别：equal 比较对象，==比较原生类型</h4><p>equal：存储空间的值是否相同，字符串内容比较，<strong>值是否相同</strong></p><p>==：是否为同一内存空间，内存空间是否相同，引用是否相同</p><p><strong>如果一个类重写了equals()方法，则一定也要重写hashCode()方法</strong>，原因是：虽然equals()方法重写可以保证正确判断两个对象在逻辑是否相同，但是hashCode()方法映射的物理地址是不相同的，依然会将逻辑上相同的两个元素存入集合，但是第二个对象的内容会是Null.</p><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fnesnes%2Fp%2F9863664.html" target="_blank" rel="noopener">关于java中Object类中的equals()和hashCode()方法的使用个人总结 - 张森（ZhangSen） - 博客园</a></p><h4 id="4-字符串运行速度：StringBuilder-gt-StringBuffer-（线程安全）-gt-String-，String为常量，其它为变量，所以运行慢。"><a href="#4-字符串运行速度：StringBuilder-gt-StringBuffer-（线程安全）-gt-String-，String为常量，其它为变量，所以运行慢。" class="headerlink" title="4.字符串运行速度：StringBuilder &gt; StringBuffer （线程安全）&gt; String ，String为常量，其它为变量，所以运行慢。"></a>4.字符串运行速度：StringBuilder &gt; StringBuffer （线程安全）&gt; String ，String为常量，其它为变量，所以运行慢。</h4><h4 id="5-Queue-队列：先进先出，Stack-栈：后进先出。Collect-–-gt-List-Set-Map"><a href="#5-Queue-队列：先进先出，Stack-栈：后进先出。Collect-–-gt-List-Set-Map" class="headerlink" title="5.Queue 队列：先进先出，Stack 栈：后进先出。Collect –&gt;List/Set/Map"></a>5.Queue 队列：先进先出，Stack 栈：后进先出。Collect –&gt;List/Set/Map</h4><h4 id="6-ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter"><a href="#6-ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter" class="headerlink" title="6.ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter"></a>6.ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapter</h4><p>BaseAdapter 重写的方法getCount()、getItem()、getItemId()、getView()，<strong>每绘制一次就调用一次getView()</strong>，在getView()中将事先定好的layout布局确定显示的效果并返回一个view对象作为一个item 显示出来，getItem()、getItemId()在调用LIstView响应方法时调用。</p><h4 id="7-Fragment生命周期"><a href="#7-Fragment生命周期" class="headerlink" title="7.Fragment生命周期"></a>7.Fragment生命周期</h4><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_36882793%2Farticle%2Fdetails%2F82151686" target="_blank" rel="noopener">Fragment各种情况的生命周期 - 猫吻鱼的博客 - CSDN博客</a></p><p>onAttach()： 完成Fragment和Activity的绑定，参数中的Activity即为要绑定的Activity，可以进行赋值等操作。</p><p>onCreate() : 完成Fragment的初始化</p><p>onCreateView() : 加载Fragment布局，绑定布局文件</p><p>onActivityCreated() : 表名与Fragment绑定的Activity已经执行完成了onCreate，可以与Activity进行交互操作。</p><p>onStart() : Fragment变为可见状态</p><p>onResume() : Fragment变为可交互状态</p><p>onPause()： Fragment变为不可交互状态(不代表不可见)</p><p>onSaveInstanceState()：保存当前Fragment的状态。记录一些数据，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本。</p><p>onStop(): Fragment变为不可见状态</p><p>onDestroyView() : 销毁Fragment的有关视图，但并未和Activity解绑，可以通过onCreateView()重新创建视图。Fragment销毁时或者ViewPager+Fragment情况下会调用</p><p>onDestroy() : 销毁Fragment时调用</p><p>onDetach() : 解除和Activity的绑定。Fragmen销毁最后一步。</p><h4 id="8-四大引用类型"><a href="#8-四大引用类型" class="headerlink" title="8.四大引用类型"></a>8.四大引用类型</h4><p><strong>强引用</strong>： 是指创建一个对象并把这个对象赋给一个引用变量。 强引用有<strong>引用变量指向时永远不会被垃圾回收</strong>，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</p><p><strong>软引用</strong>（SoftReference）：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。</p><p><strong>弱引用</strong>（WeakReference）：<strong>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象</strong>。在java中，用java.lang.ref.WeakReference类来表示。</p><p><strong>虚引用</strong>（PhantomReference）：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。<strong>如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收</strong>。要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p><h4 id="9-线程是进程的子集，一个进程可有多个线程。"><a href="#9-线程是进程的子集，一个进程可有多个线程。" class="headerlink" title="9.线程是进程的子集，一个进程可有多个线程。"></a>9.线程是进程的子集，一个进程可有多个线程。</h4><p><strong>线程间通讯方式</strong>：①共享变量；②管道；③handler；④runOnUiThread(Runnable)；⑤view.post(Runnable)。</p><p> <strong>进程间通讯方式</strong>：①管道；②FIFO；③消息队列；④信号量；⑤共享内存区；⑥套接字socket信号。</p><p> <strong>Activity间的通信方式</strong>：①Intent；②借助类的静态变量；③借助全局变量/Application；④借助外部工具（SharedPreference、SQLite、File、剪贴板）；⑤借助Service。</p><h4 id="10-PackageManagerService-APP安装有关的service，WindowManagerService-APP调用窗口相关的service，ActivityManagerService-系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。"><a href="#10-PackageManagerService-APP安装有关的service，WindowManagerService-APP调用窗口相关的service，ActivityManagerService-系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。" class="headerlink" title="10.PackageManagerService APP安装有关的service，WindowManagerService APP调用窗口相关的service，ActivityManagerService 系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。"></a>10.PackageManagerService APP安装有关的service，WindowManagerService APP调用窗口相关的service，ActivityManagerService 系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。</h4><p>自定义系统服务：在ServiceManager注册，在Framework/base增加JNI，C++ 文件，在build 配置mk文件，全部编译，才可调用。</p><h4 id="11-binder机制"><a href="#11-binder机制" class="headerlink" title="11.binder机制"></a>11.binder机制</h4><p>Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，<strong>它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁</strong>。</p><h4 id="12-launcher的实现"><a href="#12-launcher的实现" class="headerlink" title="12.launcher的实现"></a>12.launcher的实现</h4><p>Manifest 配置launcher，PackageManager、ActivityManager<strong>对应包的管理和应用进程的管理</strong>。</p><h4 id="13-Android-版本特性"><a href="#13-Android-版本特性" class="headerlink" title="13.Android 版本特性"></a>13.Android 版本特性</h4><p><strong>6.0需要代码请求权限checkPermissions，7.0应用间文件共享限制，系统广播删除，8.0通知渠道、悬浮窗、透明窗口不允许屏幕旋转，9.0明文流量的网络请求（Https加密）</strong></p><p><strong>Android SDK兼容</strong>：<strong>minSdkVersion必须</strong>，targetSdkVersion针对某版本，maxSdkVersion非必需。</p><p>详细特性可见转载文档：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fccw0054%2Farticle%2Fdetails%2F83061841" target="_blank" rel="noopener">Android 各版本新特性介绍 - 落叶Ex的博客 - CSDN博客</a></p><h4 id="14-BroadcastReceiver广播"><a href="#14-BroadcastReceiver广播" class="headerlink" title="14.BroadcastReceiver广播"></a>14.BroadcastReceiver广播</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722160840.png" alt=""></p><p>BroadcastReceiver比较</p><p>特别注意：<strong>动态广播最好在Activity 的 onResume()注册、onPause()注销。</strong></p><p>原因：对于动态广播，有注册就必然得有注销，否则会导致<strong>内存泄露，</strong>重复注册、重复注销也不允许</p><p>广播的类型主要分为5类：</p><p><strong>普通广播</strong>（Normal Broadcast）：开发者自身定义 intent的广播（最常用），<strong>sendBroadcast(intent);</strong></p><p><strong>系统广播</strong>（System Broadcast）：涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播，每个广播都有特定的Intent - Filter（包括具体的action）</p><p><strong>有序广播</strong>（Ordered Broadcast）：<strong>发送出去的广播被广播接收者按照先后顺序接收，按照Priority属性值从大-小排序；Priority属性相同者，动态注册的广播优先</strong>；</p><p><strong>sendOrderedBroadcast(intent);</strong></p><p>特点</p><p>接收广播按顺序接收</p><p>先接收的广播接收者可以<strong>对广播进行截断</strong>，即后接收的广播接收者不再接收到此广播；</p><p>先接收的广播接收者可以<strong>对广播进行修改</strong>，那么后接收的广播接收者将接收到被修改后的广播</p><p>App应用内广播（Local Broadcast）：<a href="https://www.jianshu.com/p/6f1ea19a17ed" target="_blank" rel="noopener">Android高效安全的本地广播LocalBroadcast完全解析 - 简书</a></p><p>粘性广播（Sticky Broadcast）：由于在Android5.0 &amp; API 21中已经失效，所以不建议使用</p><h4 id="15-RecycleView"><a href="#15-RecycleView" class="headerlink" title="15.RecycleView"></a>15.RecycleView</h4><p>方法：<strong>onCreateViewHolder() 、onBinderViewHolder()、getItemCount()</strong></p><p>三种布局：<strong>垂直or水平、网格、瀑布流</strong></p><p>需要自定义分割线、易于回收、View复用、便于实现添加和删除item动画。</p><h4 id="16-各种集合比较"><a href="#16-各种集合比较" class="headerlink" title="16.各种集合比较"></a>16.各种集合比较</h4><p><strong>SparseArray稀疏数组与HashMap相比</strong>，正序插入快，逆序插入慢，查找慢占用内存少于HashMap；</p><p><strong>HashMap和ArrayMap的区别</strong></p><p>①查找效率   HashMap依据HashCode查找，效率增加；ArrayMap使用二分法查找，效率下降。数量大时用HashMap</p><p>②扩展数量   HashMap初始值16个长度，每次扩容申请双倍的数组空间；A扩容申请空间更少</p><p>③扩容效率  ArrayMap更好</p><p>④内存消耗  数据量小时，ArrayMap更节省内存</p><p>总结：数据量小时，并需要频繁使用map存储时，用ArrayMap，数据量大时，用HashMap。</p><p><strong>HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p><p>HashMap 的实例有两个参数影响其性能：初始容量和加载因子。容量是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">哈希表</a>中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。在Java编程语言中，加载因子默认值为0.75，默认哈希表元为101</p><p>hashMap的默认加载因子为0.75，<strong>加载因子</strong>表示Hsah表中元素的填满的程度。加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。冲突的机会越大,则查找的成本越高。反之,查找的成本越小。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p><p>参考文章：<a href="https://www.jianshu.com/p/dff8f4641814" target="_blank" rel="noopener">为什么java Hashmap 中的加载因子是默认为0.75 - 简书</a></p><p><strong>LinkedList 链表结构</strong>，查找慢，插入快；</p><p><strong>ArrayList 数组结构</strong>，查找快，插入慢。</p><h4 id="17-SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade-方法中判断oldVersion对数据库进行增删改查以实现数据库升级。"><a href="#17-SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade-方法中判断oldVersion对数据库进行增删改查以实现数据库升级。" class="headerlink" title="17.SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade()方法中判断oldVersion对数据库进行增删改查以实现数据库升级。"></a>17.SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade()方法中判断oldVersion对数据库进行增删改查以实现数据库升级。</h4><h4 id="18-Bitmap"><a href="#18-Bitmap" class="headerlink" title="18.Bitmap"></a>18.Bitmap</h4><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fwinter-is-coming%2Fp%2F9112192.html" target="_blank" rel="noopener">Android Bitmap详解 - 小爷宋 - 博客园</a></p><p>位图包括图片的像素、长宽、颜色等描述，可通过这些信息计算出图像占用内存的大小。作为花架，可对图片做一些处理，位图文件显示效果好，但是非压缩格式，需要占用较大存储空间。</p><p>①<strong>Config：表示图片像素类型</strong></p><p>②三种压缩格式：<strong>Bitmap.CompressFormat.JPEG、Bitmap.CompressFormat.PNG、Bitmap.CompressFormat.WEBP</strong></p><p><strong>③</strong>BitmapFactory提供了四类加载方法：<strong>decodeFile、decodeResource、decodeStream、decodeByteArray。巨图加载：BitmapRegionDecoder，可以按照区域进行加载。高效加载：核心其实也很简单，主要是采样压缩、缓存策略、异步加载等</strong></p><p>④<strong>内存优化</strong>：缓存LRU、缩放、Config、Compress选择、内存管理、缓存方式等等方面入手。、内存管理、内存优化、缩放、config、compress</p><p>开源框架：ImageLoader、Glide（google）、Fresco（FaceBook）、Picasso（Square）</p><p><strong>图片优化：异步加载，压缩处理bitmapFactory.options，设置内存大小，缓存于内存、SD卡，没有内存再从网络取</strong>。</p><p><strong>Picasso包体积小、清晰，但功能有局限不能加载gif、只能缓存全尺寸；</strong></p><p><strong>Glide功能全面，擅长大型图片流，体积较大；</strong></p><p><strong>Fresco内存优化，减少oom，体积更大。</strong></p><p><strong>如何处理大图：BitmapFactory.Options，把inJustDecodeBounds这个属性设为true，计算inSampleSize。参考文章：官方推荐方法，如何有效率的加载大图Bitmap - 月毛毛的专栏 - CSDN博客</strong></p><h4 id="19-Handler机制"><a href="#19-Handler机制" class="headerlink" title="19.Handler机制"></a>19.Handler机制</h4><p><strong>主线程不能进行耗时操作，子线程不能更新UI，Handler实现线程间通信，将要发送的消息保存到Message中，Handler调用sendMessage()方法将message发送到MessageQueue，Looper对象不断调用loop()方法，不断从MessageQueue中取出message交给handler处理，从而实现线程间的通信。</strong></p><p>主线程handler不需要调用Looper.prepare()，Looper.loop()，通过sendMessage将message添加到messagequeue。</p><p>子线程可以new Handler。</p><p><strong>总结：当创建Handler时将通过ThreadLocal在当前线程绑定一个Looper对象，而Looper持有MessageQueue对象。执行Handler.sendMessage(Message)方法将一个待处理的Message插入到MessageQueue中，这时候通过Looper.loop()方法获取到队列中Message，然后再交由Handler.handleMessage(Message)来处理。</strong></p><h4 id="20-性能优化技巧"><a href="#20-性能优化技巧" class="headerlink" title="20.性能优化技巧"></a>20.性能优化技巧</h4><p>启动速度优化，布局优化，内存、电量、APP大小优化、列表滑动优化等等。</p><p>性能优化工具：TraceView、Hierarchy Viewer。</p><h4 id="21-ANR（Application-Not-Responding）"><a href="#21-ANR（Application-Not-Responding）" class="headerlink" title="21.ANR（Application Not Responding）"></a>21.ANR（Application Not Responding）</h4><p>扩展文链接：<a href="https://www.jianshu.com/p/54f945a15acb" target="_blank" rel="noopener">深入理解ANR - 简书</a></p><p>Android应用程序有一段时间响应不够灵敏，系统会向用户显示应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现ANR，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。<strong>默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</strong></p><p>原因：<strong>主线程做耗时操作；主线程被其他线程锁；CPU被其他进程占用，该进程没有分配CPU资源；OnReceiver过多操作，IO操作，如数据库、文件、网络</strong>。</p><h4 id="22-自定义View"><a href="#22-自定义View" class="headerlink" title="22.自定义View"></a>22.自定义View</h4><p>扩展文链接：<a href="https://www.jianshu.com/p/705a6cb6bfee" target="_blank" rel="noopener">Android自定义View全解 - 简书</a></p><p>自定义组合控件  多个控件组合成为一个新的控件，方便多处复用</p><p>继承系统View控件  继承自TextView等系统控件，在系统控件的基础功能上进行扩展</p><p>继承View  不复用系统控件逻辑，继承View进行功能定义</p><p>继承系统ViewGroup  继承自LinearLayout等系统控件，在系统控件的基础功能上进行扩展</p><p>继承ViewViewGroup  不复用系统控件逻辑，继承ViewGroup进行功能定义</p><p> <strong>View绘制流程基本由measure()、layout()、draw()这个三个函数完成</strong></p><p>函数作用相关方法</p><p><strong>measure()测量View的宽高measure(),setMeasuredDimension(),onMeasure()</strong></p><p><strong>layout()计算当前View以及子View的位置layout(),onLayout(),setFrame()</strong></p><p><strong>draw()视图的绘制工作draw(),onDraw()</strong></p><p><strong>自定义View的注意事项   参考文章：Android自定义View注意事项 - 简书</strong></p><p><strong>①需要在onMeasure方法中处理wrap_content的方法，让View支持wrap_content；</strong></p><p><strong>②避免padding和子元素的margin失效，让View支持padding；</strong></p><p><strong>③尽量不要在View中使用Handler，View中已提供了post系列方法，可替代Handler作用；</strong></p><p><strong>④避免造成内存泄漏，View中如果有线程或者动画，需要及时停止。</strong></p><h4 id="23-MVC、MVP、MVVM三种架构设计"><a href="#23-MVC、MVP、MVVM三种架构设计" class="headerlink" title="23.MVC、MVP、MVVM三种架构设计"></a>23.MVC、MVP、MVVM三种架构设计</h4><p>扩展文链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Flihaoxiang123%2Farticle%2Fdetails%2F78977181" target="_blank" rel="noopener">Android高精战争（MVC、MVP、MVVM） - lihaoxiang123的博客 - CSDN博客</a></p><p>MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p>其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。</p><p>MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。</p><p>MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）：</p><p>View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity)</p><p>Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合)</p><p>Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</p><p>View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试</p><p>MVC 与MVP的区别</p><p>（最主要区别）<strong>View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互</strong></p><p><strong>通常View与Presenter是一对一的</strong>，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View</p><p><strong>Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。</strong></p><p>在MVP中，Activity的代码不臃肿；</p><p>在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会；</p><p>在MVP中，IUserView这个接口可以实现方便地对Presenter的测试；</p><p>在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。</p><p>MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。</p><h4 id="24-APP-启动流程"><a href="#24-APP-启动流程" class="headerlink" title="24.APP 启动流程"></a>24.APP 启动流程</h4><p>点击桌面图标，launcher进程启动主Activity以Binder方式发送给AMS服务，交付给ActivityManagerService处理Intent和flag信息，通过prepareMainLooper()方法loop处理消息</p><h4 id="25-插件化"><a href="#25-插件化" class="headerlink" title="25.插件化"></a>25.插件化</h4><p><strong>解除代码耦合，插件支持热插拔，静默升级，从根本上解决65k属性和方法的bug，进行自定义classLoader。</strong></p><p>插件化和热修复都是动态加载技术，使用场景不同，<strong>热修复为解决线上问题或者小功能更新，插件化解决应用上的大问题。</strong></p><p><strong>组件化：为了解耦，把复杂系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</strong></p><p>26.Kotlin 是一个用于现代<strong>多平台应用的静态编程语言</strong>，由 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FJetBrains" target="_blank" rel="noopener">JetBrains</a> 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。</p><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 <strong>flutter。</strong></p><h4 id="27-Framework-工作原理"><a href="#27-Framework-工作原理" class="headerlink" title="27.Framework 工作原理"></a>27.Framework 工作原理</h4><p><strong>Android 系统对Linux、kernel、lib库等封装，提供WMS、AMS、binder机制，handler-message机制等方式，供APP使用。Framework 就是提供APP生存环境。</strong></p><h4 id="28-Android-屏幕适配"><a href="#28-Android-屏幕适配" class="headerlink" title="28.Android 屏幕适配"></a>28.Android 屏幕适配</h4><p>各种dp文件，使用各种尺寸屏幕</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722160920.png" alt=""></p><p><strong>布局文件中view设置高宽时不限定大小，尽量使用wrap_content，match_parent；代码中设置高宽前可获取屏幕大小，如果是线性布局可设置view在LinearLayout的weight；单位dp适配屏幕，单位sp适用字体，多图片，多布局。</strong></p><h4 id="29-事件分发机制"><a href="#29-事件分发机制" class="headerlink" title="29.事件分发机制"></a>29.事件分发机制</h4><p>dispatchTouchEvent() 负责事件分发。当点击事件产生后，事件首先传递给当前Activity，调用Activity的dispatchTouchEvent()方法，返回值为true则表示View或子View消费了此事件，如果返回true，则表示没有消费事件，并调用父View的onTouchEvent方法。</p><p>onTouchEvent()用于处理事件，返回值决定当前控件是否消费了这个事件，也就是说在当前控件在<strong>调用父View的onTouchEvent方法</strong>完Touch事件后，是否还允许Touch事件继续向上（父控件）传递，一但返回True，则父控件不用操心自己来处理Touch事件。返回true，则向上传递给父控件。</p><p>onInterceptTouchEvent() ViewGroup的一个方法，用于处理事件（类似于预处理，当然也可以不处理）并改变事件的传递方向，也就是决定是否允许Touch事件继续向下（子控件）传递，一但返回True（代表事件在当前的viewGroup中会被处理），则向下传递之路被截断（所有子控件将没有机会参与Touch事件），同时把事件传递给当前的控件的onTouchEvent()处理；返回false，则把事件交给子控件的onInterceptTouchEvent()。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722160945.png" alt=""></p><p>事件分发机制原理图</p><p>当一个Touch事件(触摸事件为例)到达根节点，即Acitivty的ViewGroup时，它会依次下发，下发的过程是调用子View(ViewGroup)的dispatchTouchEvent方法实现的。简单来说，就是ViewGroup遍历它包含着的子View，调用每个View的dispatchTouchEvent方法，而当子View为ViewGroup时，又会通过调用ViwGroup的dispatchTouchEvent方法继续调用其内部的View的dispatchTouchEvent方法。上述例子中的消息下发顺序是这样的：①-②-⑤-⑥-⑦-③-④。dispatchTouchEvent方法只负责事件的分发，它拥有boolean类型的返回值，当返回为true时，顺序下发会中断。</p><p>小结：onInterceptTouchEvent()默认返回false，不做截获。返回true之后，事件流的后端控件就没有机会处理touch事件。view的onTouchEvent()返回了false，那么该事件将被传递至其上一层次的view的onTouchEvent()处理，如果onTouchEvent()返回了true，那么后续事件将可以继续传递给该view的onTouchEvent()处理。</p><h4 id="30-Android-动画分类：视图，属性，帧，gif。"><a href="#30-Android-动画分类：视图，属性，帧，gif。" class="headerlink" title="30.Android 动画分类：视图，属性，帧，gif。"></a>30.Android 动画分类：视图，属性，帧，gif。</h4><h4 id="31-Android-进程"><a href="#31-Android-进程" class="headerlink" title="31.Android 进程"></a>31.Android 进程</h4><p>一般大体分为<strong>前台进程，后台进程，可见进程，服务进程，空进程</strong>这五大进程。其中<strong>空进程优先级最低</strong>，调用startService()让service所在进程成为前台进程，service的onDestory()里重新启动自己可避免后台进程被杀死。</p><p><strong>一个应用允许多个进程</strong>，在清单文件配置的service为一个进程，Android:process就可以配置；</p><p><strong>多进程会引起的异常</strong>：静态成员和单例模式会失效，线程同步机制完全失效，SharedPreferences可靠性下降，Application会多次创建。</p><h4 id="32-Android-五大存储方式"><a href="#32-Android-五大存储方式" class="headerlink" title="32.Android 五大存储方式"></a>32.Android 五大存储方式</h4><p>使用SharedPreferences存储数据； 文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据。</p><p>当APP没有获取文件存储权限时，当需要存储大文件时，可以保存在APP-data-cache目录里。</p><p><strong>ContentProvider</strong>：抽象类，为不同应用数据提供数据共享，提供统一接口，<strong>通过uri标识要访问的数据。</strong></p><h4 id="33-屏幕旋转Activity生命周期"><a href="#33-屏幕旋转Activity生命周期" class="headerlink" title="33.屏幕旋转Activity生命周期"></a>33.屏幕旋转Activity生命周期</h4><p>参考文章链接：<a href="https://www.jianshu.com/p/8c40829905ec" target="_blank" rel="noopener">Activity横竖屏切换生命周期变化 - 简书</a></p><p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行1次，切竖屏时会执行1次</p><p>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p><p>3、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><p>4、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏切记要加上screenSize,否则4.0版本以上生命周期不生效</p><h4 id="34-Activity-四大启动模式"><a href="#34-Activity-四大启动模式" class="headerlink" title="34.Activity 四大启动模式"></a>34.Activity 四大启动模式</h4><p><strong>standard 启动模式</strong></p><p> Activity 默认的启动模式，每次 startActivity 都会在栈顶创建一个新的实例，在同一个任务中可以存在多个Activity 的实例。</p><p><strong>singleTop 启动模式</strong></p><p><strong>栈顶复用</strong>，也就是说，要启动 singleTop 模式的 Activity，如果它恰好在当前栈顶，那么直接复用，执行其 onNewIntent 方法。否则，就重新创建一个实例入栈。</p><p>singleTask 启动模式</p><p>在系统中<strong>只有一个实例</strong>，当再次启动该 Activity 时，会重用已存在的任务和实例，并且会调用这个实例的 onNewIntent()方法，将 Intent 实例传递到该实例中。</p><p>singleInstance 启动模式</p><p><strong>总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他 Activity 会自动运行于另一个任务中。</strong>当再次启动该 Activity 的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将 Intent 实例传递到该实例中。</p><p>总结：<strong>①standard每一次都会创建新的实例；②singleTop栈顶复用。和standard相似，但是如果栈顶已有实例，复用该实例，回调onNewIntent()方法；③singleTask栈内复用。查找栈内有没有该实例，有则复用回调onNewIntent()方法，如果没有，新建Activity，并入栈；④singleInstance单例模式，全局唯一。具备singleTask所有特性，独占一个任务栈。</strong></p><h4 id="35-CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。"><a href="#35-CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。" class="headerlink" title="35.CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。"></a><strong>35.CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。</strong></h4><h4 id="36-UI卡顿原因"><a href="#36-UI卡顿原因" class="headerlink" title="36.UI卡顿原因"></a>36.UI卡顿原因</h4><p>每16ms绘制一次Activity，如果由于一些原因导致了我们的逻辑、CPU耗时、GPU耗时大于16ms(<strong>应用卡顿的根源就在于16ms内不能完成绘制渲染合成过程,16ms需要完成视图树的所有测量、布局、绘制渲染及合成</strong>)，UI就无法完成一次绘制，那么就会造成卡顿。<strong>①内存抖动问题，②方法耗时，③view本身卡顿。</strong></p><p><strong>解决办法：修改方法，使其不耗时，放到子线程中，如网络访问，大文件操作等，防止ANR，避免GPU过度绘制。</strong></p><h4 id="37-Application的生命周期"><a href="#37-Application的生命周期" class="headerlink" title="37.Application的生命周期"></a><strong>37.Application的生命周期</strong></h4><p><strong>参考文章：Android中Application的用途及生命周期<em>YY小爬虫</em>新浪博客</strong></p><p>①onCreate0 在创建应用程序时创建；</p><p>②onTerminate()  在模拟环境下执行。当终止应用程序对象时调用，不保证一定被调用，当程序是被内核终止以便为其他应用程序释放资源，那么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程；</p><p>③onLowMemory() 低内存时执行。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况；</p><p>④onConfigurationChanged(Configuration newConfig) 配置改变时触发这个方法。</p><p>⑤onTrimMemory(int level) 程序在进行内存清理时执行。</p><h4 id="38-如何避免因引入的开源库导致的安全性和稳定性？"><a href="#38-如何避免因引入的开源库导致的安全性和稳定性？" class="headerlink" title="38.如何避免因引入的开源库导致的安全性和稳定性？"></a>38.如何避免因引入的开源库导致的安全性和稳定性？</h4><p>由于项目引入了太多第三方开源库，Android APP有65536方法数的问题，可使用multidex解决。<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fplugins.jetbrains.com%2Fplugin%2F8076%3Fpr%3Dandroidstudio" target="_blank" rel="noopener">Android Methods Count</a>插件可以高效统计Android开源库的方法数。</p><h4 id="39-简单的音频-视频格式"><a href="#39-简单的音频-视频格式" class="headerlink" title="39.简单的音频/视频格式"></a><strong>39.简单的音频/视频格式</strong></h4><p><strong>PCM</strong>：<strong>脉冲编码调制</strong>，由二进制数字信号对光源进行通断调制产生，没有压缩的编码方式。</p><p><strong>WAV</strong>：<strong>无损音频文件格式</strong>，PCM是无损WAV文件中音频数据的一种编码方式，但是WAV还可以用其它编码。</p><p><strong>AVI</strong>：音视频交错，调用方便，图像质量好，压缩标准可选。</p><p><strong>WMV</strong>：可扩充的媒体类型，本地或网络回放，流优先级化。</p><p><strong>3GP</strong>：3G流媒体，配合3G网络高速传输而开发。</p><p><strong>FLV</strong>：文件小，加载速度快，用于网络观看视频。</p><p><strong>MP4</strong>：音视频压缩编码标准。</p><h4 id="40-线程同步的方法"><a href="#40-线程同步的方法" class="headerlink" title="40.线程同步的方法"></a>40.线程同步的方法</h4><p>转载文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fxiaoxi%2Fp%2F7679470.html" target="_blank" rel="noopener">多线程同步的五种方法 - 平凡希 - 博客园</a></p><p><strong>①synchronized</strong>  即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态；</p><p><strong>②同步代码块</strong>  即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步；</p><p><strong>③使用特殊变量Volatile</strong> </p><p>（1）volatile关键字为域变量的访问提供了一种免锁机制；</p><p>（2）使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；</p><p>（3）因此每次使用该域就要重新计算，而不是使用寄存器中的值；</p><p>（4）volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p><p>④<strong>使用重入锁</strong></p><p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力；</p><p><strong>⑤使用局部变量；</strong></p><p><strong>⑥使用阻塞队列。</strong></p><p><strong>线程sleep()和wait()的区别</strong></p><p><strong>sleep()不释放同步锁，自动唤醒，需要try-catch，线程方法。</strong></p><p><strong>wait()释放同步锁，需要notify唤醒，是object方法。</strong></p><p><strong><em>线程的生命周期？如何中断？</em></strong></p><p>生命周期：文章转载：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fwzy330782%2Fp%2F5456923.html" target="_blank" rel="noopener">多线程——线程的生命周期 - 积_跬步 - 博客园</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161023.png" alt=""></p><p><strong>① 新建状态(New Thread)</strong>：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。</p><p>线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。</p><p><strong>② 就绪状态(Runnable)</strong>：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。</p><p><strong>③ 运行状态(Running)</strong>：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。</p><p>a) 可以通过Thread类的isAlive方法来判断线程是否处于就绪/运行状态：当线程处于就绪/运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。</p><p><strong>④ 阻塞和唤醒线程</strong></p><p>阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括：</p><p>​              a)当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。</p><p>​              b)当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。</p><p>​              c)当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()/notify()方法的执行要求线程首先获得该对象的锁。</p><p><strong>⑤ 死亡状态(Dead)</strong>：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。</p><p><strong>终止线程的三种方法</strong></p><p>① 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。</p><p>② 使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。</p><p>③ 使用interrupt方法中断线程。</p><h4 id="41-线程安全的单例"><a href="#41-线程安全的单例" class="headerlink" title="41.线程安全的单例"></a>41.线程安全的单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">(SingleInstance instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="42-Serializable-序列化接口，开销大，建议使用，java方法；"><a href="#42-Serializable-序列化接口，开销大，建议使用，java方法；" class="headerlink" title="42.Serializable 序列化接口，开销大，建议使用，java方法；"></a>42.Serializable 序列化接口，开销大，建议使用，java方法；</h4><p> Parcelelable 使用麻烦，效率高，多用于内存，Android方法。</p><h4 id="43-Service启动方式和生命周期"><a href="#43-Service启动方式和生命周期" class="headerlink" title="43.Service启动方式和生命周期"></a>43.Service启动方式和生命周期</h4><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161217.png" alt=""></p><p>①startService()：开启，调用者退出后Service仍在；<br> 生命周期：onCreate()–onStartCommand()–onDestory()<br> 通过startService启动后，service会一直无限期运行下去，只有外部调用了stopService()或stopSelf()方法时，该Service才会停止运行并销毁。<br> ②bindService()：开启，调用者退出后Service随即退出。<br> 生命周期：onCreate()–onBind()–onUnBind()–onDestory()<br> ①+② 的生命周期：onCreate()–onStartCommand()–onBind()–onUnBind()–onDestory()</p><h4 id="44-Android-常见布局"><a href="#44-Android-常见布局" class="headerlink" title="44.Android 常见布局"></a>44.Android 常见布局</h4><p> FrameLayout （框架布局）、LinearLayout（线性布局）、AbsoluteLayout（绝对布局）、RelativeLayout（相对布局）、TableLayout（表格布局）</p><h4 id="45-Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。"><a href="#45-Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。" class="headerlink" title="45.Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。"></a>45.Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。</h4><p> ①HttpClient：开源框架，无封装，原始，使用方便，开发快，实现比较稳定，Android废弃，Android 6.0删除；<br> ②HttpUrlConnection：对网络请求没有HttpClient封装彻底，Android2.2之前存在bug，所以2.2之前用HttpClient，之后用容易优化的HttpUrlConnection，开源框架，封装了请求头、参数、内容体、响应在I/O流，接口中统一封成了HttpGet/HttpPost，减少了操作的繁琐性，访问速度快。</p><p>Https是以安全为目标的Http通道，简单讲就是Http的安全版，即Http下加入SSL层，安全基础是SSL，加密的详细内容是SSL，作用：建立一个信息安全通道，来保证数据传输的安全、确认网站的安全性。</p><p>Volley：适合处理数据量小，通信频繁的网络操作，内部封装了异步操作，可直接在线程执行并处理结果，同时可以取消，容易扩展，但是不适合大数据请求，比如下载表现糟糕，不支持https，android2.2及以下用HttpClient，android2.3及以上用HttpUrlConnection。</p><p>OkHttp：专注于提升网络连接效率的Http客户端，能够实现IP和端口的请求重用一个socket，大大降低了连接时间，也降低了服务器的压力，对Http和https都有良好的支持，不用担心app版本更换的困扰，但是okHttp请求是在线程里执行，不能直接刷新UI，需要手动处理。</p><p>总结：在项目实际运用中，视情况选择网络请求方式，也可以Volley+OkHttp搭配使用。异步回调用Volley，网络请求底层用OkHttp</p><p>RxJava + Retrofit3 + OkHttp3<br> ①RxJava 主要用来实现线程切换，我们制定订阅在哪一个线程，观察在哪个线程，通过操作符进行数据变换，整个过程是键式的，简化逻辑。<br> ②Retrofit 是网络请求的一个架子，用它设置一些参数和请求Url。<br> ③OkHttp是网络请求的内核，实际的网络请求是它发出来的。</p><p>TCP 是网络层，滑动窗口协议，拥塞控制，可靠连接借助socket长连接，需要3次握手，第四次取消连接，画面优先。<br> UDP：不关心数据是否到达，是否阻塞，不可靠连接，流畅优先。</p><h4 id="46-如何节省内存使用，主动回收内存？"><a href="#46-如何节省内存使用，主动回收内存？" class="headerlink" title="46.如何节省内存使用，主动回收内存？"></a>46.如何节省内存使用，主动回收内存？</h4><p> 答：尽量多使用内部类，提高程序效率，回收已使用的资源，合理使用缓存，合理设置变量的作用范围。</p><h4 id="47-Activity如何生成View？"><a href="#47-Activity如何生成View？" class="headerlink" title="47.Activity如何生成View？"></a>47.Activity如何生成View？</h4><p> 答：Activity执行在attch()方法的时候，会创建一个PhoneWindow（Window的子类），在onCreate()方法的setContentView()方法中，创建DecorView，DecorView的addView()方法，把layout布局加载出来。通过onDraw()画出来，画View之前调用onMeasure()方法计算显示的大小。</p><h4 id="48-为什么要使用多线程？"><a href="#48-为什么要使用多线程？" class="headerlink" title="48.为什么要使用多线程？"></a>48.为什么要使用多线程？</h4><p> ①更好地利用CPU资源；②进程间数据不能数据共享，线程可以；③系统创建进程需要为该进程重新分配系统资源，创建线程代价较小；④Java语言内置了多线程功能支持，简化了java多线程编程。</p><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，在创建线程后自动启动这些任务，线程池线程是后台线程，每个线程都使用默认的堆栈大小，以优先级执行。</p><h4 id="49-现场保护"><a href="#49-现场保护" class="headerlink" title="49.现场保护"></a>49.现场保护</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：①进程被异常杀死；②系统配置发生变化（比如横竖屏切花换）。<br> 当Activity处于onPause() ，onStop() ，onDestroy() 三种状态时程序可能会被Android系统回收掉，这时可能会造成用户在程序当中的数据或者修改丢失。于是我们需要”现场保护”，当下次重启程序或activity时恢复上一次的数据。<br> 因此Android提供了onSaveInstanceState(Bundlout State)方法会在程序被回收前进行调用，但需要注意的是onSaveInstanceState()方法只适合保存瞬态数据, 比如UI控件的状态, 成员变量的值等，而不应该用来保存持久化数据。onRestoreInstanceState方法，需要注意的是onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p><h4 id="50-内存溢出，内存泄漏"><a href="#50-内存溢出，内存泄漏" class="headerlink" title="50.内存溢出，内存泄漏"></a>50.内存溢出，内存泄漏</h4><p> 内存溢出（OOM）：程序在申请内存时，没有足够的内存空间使用。<br> 原因：加载对象过大，相对资源较多，来不及加载。<br> 解决办法：内存引用上做处理，比如用软引用；图片加载时处理（压缩等）；动态回收内存；优化内存分配，自定义堆内存大小，避免使用Enum，减少BitMap的内存占用，内存对象重复使用，避免对象的内存泄漏。<br> 内存泄漏（memory leak）： 程序在申请内存后，无法释放已申请的内存空间，一次泄漏危害可忽略，但推积严重最终会导致OOM；</p><p>handler泄露：消息引用了handler对象，该对象又隐性地持有了Activity对象，当发生GC时以为message-handler-activity的引用链导致Activity无法被回收，即发生泄漏，简单来说就是handler对activity强引用导致的GC，无法及时回收Activity。（PS：GC垃圾回收，当堆内存里的对象没有引用指向时，GC回收。）</p><p>解决办法：方法一：通过程序逻辑来进行保护。</p><p>1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。</p><p>2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。</p><p>方法二：将Handler声明为静态类。</p><p>PS:在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。</p><p>静态类不持有外部类的对象，所以你的Activity可以随意被回收。由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）。<br> WebView泄漏：创建的对象没有在合适的时间销毁，则一直存在内存里耗费内存空间，WebView不建议在xml文件中指明，因为一直存在不能对其销毁，应该在代码中创建WebView，通过addView()的方式加入layout，在Activity 的onDestory()方法中需要销毁，先将加载的内容置为null，webView.destroy();</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebView mWebView = <span class="keyword">new</span> WebView(getApplicationContext());</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( mWebView!=<span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           ViewParent parent = mWebView.getParent();</span><br><span class="line">           <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ((ViewGroup) parent).removeView(mWebView);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mWebView.stopLoading();</span><br><span class="line">           <span class="comment">// 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错</span></span><br><span class="line">           mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">false</span>);</span><br><span class="line">           mWebView.clearHistory();</span><br><span class="line">           mWebView.clearView();</span><br><span class="line">           mWebView.removeAllViews();</span><br><span class="line">           mWebView.destroy();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="51-JNI和NDK"><a href="#51-JNI和NDK" class="headerlink" title="51.JNI和NDK"></a>51.JNI和NDK</h4><p>​     <strong>JNI是Java调用Native 语言的一种特性，属于Java，Java本地接口，使Java与本地其他类型语言交互（C++）</strong></p><p>​       实现步骤：<strong>在Java中声明Native方法，编译该文件得到.class文件，通过javah命令导出JNI头文件（.h文件），使用Java需要交互的本地代码实现子啊Java中声明的Native方法，编译so文件，通过Java执行Java程序，最终实现Java调用本地代码</strong></p><hr><p>​     <strong>NDK（Native Develop Kit）：Android开发工具包，属于Android。</strong></p><p>​     作用：快速开发C、C++动态库，并自动将so文件和应用打包成APK，即可通过NDK在Android中使用JNI与本地代码（C、C++）交互（Android开发需要本地代码C、C++实现）</p><p>​      特点：运行效率高，代码安全性高，功能拓展性好，易于代码复用和移植。</p><p>​      使用步骤：<strong>①配置NDK环境；②创建Android项目，并于NDK进行关联；③在Android项目中声明所需调用的Native方法；④使用该Native方法；⑤通过NDK build命令编译产生so文件；⑥编译AS工程，实现调用本地代码。</strong></p><p>​    <strong>JNI和NDK的关系：JNI实现目的，NDK是Android实现JNI的手段，即在AS开发环境中通过NDK从而实现JNI功能。</strong></p><h4 id="52-常用的设计模式及其实现思想和作用"><a href="#52-常用的设计模式及其实现思想和作用" class="headerlink" title="52.常用的设计模式及其实现思想和作用"></a><strong>52.常用的设计模式及其实现思想和作用</strong></h4><p><strong>转载文章：23种设计模式全解析 - codeTao - 博客园</strong></p><p><strong>①单例模式：</strong>单例对象能保证在一个JVM中，该对象只有一个实例存在。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161310.png" alt=""></p><p><strong>②工厂模式</strong></p><p>一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。</p><p>抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 </p><p><strong>③适配器模式</strong></p><p>将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p><p><strong>④装饰模式（Decorator）</strong></p><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161327.png" alt=""></p><p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能。</p><p>装饰器模式的应用场景：</p><p>1、需要扩展一个类的功能。</p><p>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</p><p>缺点：产生过多相似的对象，不易排错！</p><p><strong>⑤代理模式（Proxy）</strong>：多一个代理类出来，替原对象进行一些操作。</p><p><strong>⑥桥接模式（Bridge）</strong>：桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：<strong>将抽象化与实现化解耦，使得二者可以独立变化。</strong></p><p><strong>⑦观察者模式</strong>：一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p><p><strong>⑧访问者模式</strong>：一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。</p><h4 id="53-HashMap、-HashTable、HashSet的异同"><a href="#53-HashMap、-HashTable、HashSet的异同" class="headerlink" title="53.HashMap、 HashTable、HashSet的异同"></a>53.HashMap、 HashTable、HashSet的异同</h4><p>转载文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fywl925%2Fp%2F3865269.html" target="_blank" rel="noopener">HashSet HashTable HashMap的区别 及其Java集合介绍 - ywl925 - 博客园</a></p><p>①HashSet是Set的一个实现类，HashMap是Map的一个实现类，同时HashMap是HashTable的替代品</p><p>②HashSet以对象作为元素，而HashMap以(key-value)的一组对象作为元素，且HashSet拒绝接受重复的对象。HashMap可以看作三个视图：key的Set，value的Collection，Entry的Set。 这里HashSet就是其实就是HashMap的一个视图。</p><p>HashSet内部就是使用HashMap实现的，和HashMap不同的是它不需要Key和Value两个值。</p><p>HashMap是一个数组和链表的结合体，新加入的放在链头，重复的key不同的alue被新value替代</p><p>③继承不同</p><p>public class Hashtable extends Dictionary&lt;&gt; implements Map&lt;&gt;</p><p>public class HashMap  extends AbstractMap&lt;&gt; implements Map&lt;&gt;</p><p>④HashTable 方法同步，而HashMap需要自己增加同步处理。</p><p>⑤HashTable中，key和value都不允许出现null值。</p><p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。用containsKey()方法来判断是否存在某个键。</p><p>⑥两个遍历方式的内部实现上不同。</p><p>HashTable、HashMap都使用了 Iterator。而由于历史原因，HashTable还使用了Enumeration的方式 。</p><p>⑦哈希值的使用不同</p><p>HashTable直接使用对象的hashCode，HashTable中hash数组默认大小是11，增加的方式是 old*2+1。</p><p>而HashMap重新计算hash值，HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><p>如何实现HashMap线程同步？</p><p>①使用 java.util.Hashtable 类，此类是线程安全的。</p><p>②使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。</p><p>③使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。</p><h4 id="54-Android-中内存泄漏原因及优化方案？"><a href="#54-Android-中内存泄漏原因及优化方案？" class="headerlink" title="54.Android 中内存泄漏原因及优化方案？"></a>54.Android 中内存泄漏原因及优化方案？</h4><p>文章转载：<a href="https://www.jianshu.com/p/abee7c186bfa" target="_blank" rel="noopener">Android 中内存泄漏的原因和解决方案 - 简书</a></p><p>①<strong>非静态内部类造成的内存泄漏</strong>  非静态类会持有外部类的引用，如果这个内部类比外部类的生命周期长，在外部类被销毁时，内部类无法回收，即造成内存泄漏；</p><p><strong>②外部类中持有非静态内部类的静态对象</strong>  保持一致的生命周期，将内部类对象改成非静态；</p><p>③<strong>Handler 或 Runnable 作为非静态内部类</strong>  Handler 和 Runnable 作为匿名内部类，都会持有 Activity 的引用，由于 Handler 和 Runnable 的生命周期比 Activity 长，导致Activity 无法被回收，从而造成内存泄漏。  解决办法：将Handler 和 Runnable 定义为静态内部类，在Activity 的onDestory()方法中调用Handler 的 removeCallbacks 方法来移除 Message。</p><p>还有一种特殊情况，如果 Handler 或者 Runnable 中持有 Context 对象，那么即使使用静态内部类，还是会发生内存泄漏。解决办法：使用弱引用</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161341.png" alt=""></p><p>④其他内存泄漏情况：比如BraodcastReceiver 未注销，InputStream 未关闭，再代码中多注意注销或关闭。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161424.png" alt=""></p><h4 id="55-LeakCanary内存优化"><a href="#55-LeakCanary内存优化" class="headerlink" title="55.LeakCanary内存优化"></a>55.LeakCanary内存优化</h4><p>参考文章：<a href="https://www.jianshu.com/p/261e70f3083f" target="_blank" rel="noopener">LeakCanary原理解析 - 简书</a></p><p>①项目如何使用LeakCanary</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161409.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161434.png" alt=""></p><p>LeakCanary.enableDisplayLeakActivity(context);内存溢出图标，图标以通知的形式显示内存溢出</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161447.png" alt=""></p><p>②工作机制</p><p>LeakCanary.install() 会返回一个预定义的 <strong>RefWatcher</strong>，同时也会启用一个 <strong>ActivityRefWatcher</strong>，用于自动监控调用Activity.onDestroy() 之后泄露的 activity。</p><p>1.RefWatcher.watch() 创建一个 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsquare%2Fleakcanary%2Fblob%2Fmaster%2Flibrary%2Fleakcanary-watcher%2Fsrc%2Fmain%2Fjava%2Fcom%2Fsquareup%2Fleakcanary%2FKeyedWeakReference.java" target="_blank" rel="noopener">KeyedWeakReference</a> 到要被监控的对象。</p><p>2.然后在后台线程检查引用是否被清除，如果没有，调用GC。</p><p>3.如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。</p><p>4.在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsquare%2Fhaha" target="_blank" rel="noopener">HAHA</a> 解析这个文件。</p><p>5.得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。</p><p>6.HeapAnalyzer 计算 <em>到 GC roots 的最短强引用路径</em>，并确定是否是泄露。如果是的话，建立导致泄露的引用链。</p><p>7.引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。</p><h4 id="56-多线程、线程池"><a href="#56-多线程、线程池" class="headerlink" title="56.多线程、线程池"></a>56.多线程、线程池</h4><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fwxd0108%2Fp%2F5479442.html" target="_blank" rel="noopener">Java中的多线程你只要看这一篇就够了 - Givefine - 博客园</a></p><p>线程的并行和并发</p><p>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</p><p>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p><p>线程安全：多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。</p><hr><p>Java通过Executors提供四种线程池（from 百度）</p><p><strong>newCachedThreadPool</strong>——创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p><strong>newFixedThreadPool</strong>——创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p><strong>newScheduledThreadPool</strong>——创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>newSingleThreadExecutor</strong>——创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fdolphin0520%2Fp%2F3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用 - Matrix海子 - 博客园</a></p><p><strong>①线程池中的线程初始化</strong></p><p>创建线程池后，线程池中没有线程，需要提交任务才会创建线程。</p><p>prestartCoreThread()：初始化一个核心线程；</p><p>prestartAllCoreThreads()：初始化所有核心线程</p><p><strong>②workQueue，任务缓存队列，用来存放等待执行的任务</strong></p><p>workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>　　3）SynchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p><p><strong>③任务拒绝策略</strong></p><p>当线程池的任务缓存队列已满或线程数目达到maximumPoolSize，还有任务来时会采用任务拒绝策略</p><p>1）ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</p><p>2）ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p><p>3）ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p><p>4）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p><p><strong>④线程池的关闭</strong></p><p>1）shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p><p>2）shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p><p><strong>⑤线程池容量的动态调整</strong></p><p>1）setCorePoolSize：设置核心池大小</p><p>2）setMaximumPoolSize：设置线程池最大能创建的线程数目大小</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161503.png" alt=""></p><p>参考文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fsuperfj%2Fp%2F7544971.html" target="_blank" rel="noopener">由浅入深理解Java线程池及线程池的如何使用 - Janti - 博客园</a></p><p>corePoolSize :线程池的核心池大小，在创建线程池之后，线程池默认没有任何线程。</p><p>当有任务过来的时候才会去创建创建线程执行任务。换个说法，线程池创建之后，线程池中的线程数为0，当任务过来就会创建一个线程去执行，直到线程数达到corePoolSize之后，就会被到达的任务放在队列中。（注意是到达的任务）。换句更精炼的话：corePoolSize表示允许线程池中允许同时运行的最大线程数。</p><p>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p><p>maximumPoolSize :线程池允许的最大线程数，他表示最大能创建多少个线程。maximumPoolSize肯定是大于等于corePoolSize。</p><p>keepAliveTime :表示线程没有任务时最多保持多久然后停止。默认情况下，只有线程池中线程数大于corePoolSize时，keepAliveTime才会起作用。换句话说，当线程池中的线程数大于corePoolSize，并且一个线程空闲时间达到了keepAliveTime，那么就是shutdown。</p><p>Unit:keepAliveTime的单位。</p><p>workQueue：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能</p><p>threadFactory：线程工厂，用来创建线程。</p><p>handler :表示当拒绝处理任务时的策略。</p><p>在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的<strong>几个静态方法来创建线程池</strong>：</p><p>Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</p><p>Executors.newSingleThreadExecutor(); //创建容量为1的缓冲池</p><p>Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池</p><h4 id="57-腾讯-Bugly"><a href="#57-腾讯-Bugly" class="headerlink" title="57.腾讯 Bugly"></a>57.腾讯 Bugly</h4><p>腾讯公司为移动开发者开放的服务之一，面向移动开发者提供专业的 <strong>Crash 监控、崩溃分析</strong>等质量跟踪服务。Bugly 能帮助移动互联网开发者更及时地发现掌控异常，更全面的了解定位异常，更高效的修复解决异常。</p><p>针对移动应用，腾讯 Bugly 提供了专业的 Crash、Android ANR ( application not response)、iOS 卡顿监控和解决方案。移动开发者 ( Android / iOS ) 可以通过监控，快速发现用户在使用过程中出现的 Crash (崩溃)、Android ANR 和 iOS 卡顿，并根据上报的信息快速定位和解决问题。</p><h4 id="58-Glide"><a href="#58-Glide" class="headerlink" title="58.Glide"></a>58.Glide</h4><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbumptech%2Fglide" target="_blank" rel="noopener">github 地址</a></p><p>项目依赖Glide，在app build.gradle 中配置 compile’com.github.bumptech.glide:glide:3.7.0’</p><p>使用glide3.7版本，更高版本或出现异常：Error:Failed to resolve: com.android.support:support-annotations:27.0.2</p><p><strong>Glide缓存机制</strong></p><p>内存存缓存的 读存都在Engine类中完成。内存缓存使用弱引用和LruCache结合完成的,弱引用来缓存的是正在使用中的图片。图片封装类Resources内部有个计数器判断是该图片否正在使用。</p><p><strong>Glide内存缓存的流程</strong></p><p>读：是先从lruCache取，取不到再从弱引用中取；</p><p>存：内存缓存取不到，从网络拉取回来先放在弱引用里，渲染图片，图片对象Resources使用计数加一；</p><p>渲染完图片，图片对象Resources使用计数减一，如果计数为0，图片缓存从弱引用中删除，放入lruCache缓存。</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/7ce7b02988a4" target="_blank" rel="noopener">Google推荐——Glide使用详解 - 简书</a></p><p><a href="https://www.jianshu.com/p/17644406396b" target="_blank" rel="noopener">Glide 系列(四) Glide缓存机制 - 野生的安卓兽 - 简书</a></p><h4 id="59-Fresco"><a href="#59-Fresco" class="headerlink" title="59.Fresco"></a>59.Fresco</h4><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ffacebook%2Ffresco" target="_blank" rel="noopener">github 地址</a></p><p>项目依赖Glide，在app build.gradle 中配置：implementation’com.facebook.fresco:fresco:1.9.0’</p><p><a href="https://github.com/desmond1121/Fresco-Source-Analysis" target="_blank" rel="noopener">https://github.com/desmond1121/Fresco-Source-Analysis</a></p><p>参考文章：<a href="https://www.jianshu.com/p/3b143cf39013" target="_blank" rel="noopener">Fresco的使用小结 - 简书</a></p><p><a href="https://blog.csdn.net/yw59792649/article/details/78921025" target="_blank" rel="noopener">https://blog.csdn.net/yw59792649/article/details/78921025</a></p><h4 id="60-React-Native"><a href="#60-React-Native" class="headerlink" title="60.React Native"></a>60.React Native</h4><p><strong>混合开发技术移动开发-混合App介绍 - Primise7的博客 - CSDN博客</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722161536.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面试大纲&quot;&gt;&lt;a href=&quot;#面试大纲&quot; class=&quot;headerlink&quot; title=&quot;面试大纲&quot;&gt;&lt;/a&gt;面试大纲&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;java基础、面向对象、集合、线程使用；&lt;/li&gt;
&lt;li&gt;Android 机型适配、SDK适配、内存优化、内存溢出、内存泄漏；&lt;/li&gt;
&lt;li&gt;MVC/MVP/MVVM的使用场景；&lt;/li&gt;
&lt;li&gt;了解并能使用最新流行开源库RXjava+Retrofit+OKHttp、Glide、EventBus等；&lt;/li&gt;
&lt;li&gt;JNI及NDK的使用、熟悉Framework。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/categories/Android/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题集</title>
    <link href="https://zhangmiao.cc/posts/4a3cde30.html"/>
    <id>https://zhangmiao.cc/posts/4a3cde30.html</id>
    <published>2019-07-02T06:36:57.000Z</published>
    <updated>2019-07-22T09:18:42.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java部分</strong><br><strong>Android部分</strong><br><strong>数据结构与算法部分</strong><br><strong>常用的开源库部分</strong><br><strong>计算机网络认识</strong></p><a id="more"></a><h2 id="1-Java部分"><a href="#1-Java部分" class="headerlink" title="1.Java部分"></a><strong>1.Java部分</strong></h2><h3 id="1-1-操作系统相关"><a href="#1-1-操作系统相关" class="headerlink" title="1.1 操作系统相关"></a>1.1 操作系统相关</h3><ul><li>1.什么是操作系统？</li><li>2.什么是线程，什么是进程？</li></ul><h3 id="1-2-JDK-amp-JVM-amp-JRE"><a href="#1-2-JDK-amp-JVM-amp-JRE" class="headerlink" title="1.2 JDK&amp;JVM&amp;JRE"></a>1.2 JDK&amp;JVM&amp;JRE</h3><ul><li>1.JDK &amp; JVM &amp; JRE分别是什么以及它们的区别？</li><li>2.解释一下为什么Java可以跨平台？</li></ul><h3 id="1-3-面向过程-amp-面向对象"><a href="#1-3-面向过程-amp-面向对象" class="headerlink" title="1.3 面向过程 &amp; 面向对象"></a>1.3 面向过程 &amp; 面向对象</h3><ul><li>1.什么是面向过程 &amp; 什么是面向对象 &amp; 区别？</li><li>2.给我说说Java面向对象的特征以及讲讲你代码中凸显这些特征的经验。</li><li>3.什么是重载 &amp; 什么是重写 &amp; 区别。</li><li>4.谈谈你对this和super的认识。</li><li>5.接口和抽象类的区别。</li><li>6.静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？</li><li>7.给我说说权限修饰符特性。</li><li>8.给我谈谈Java中的内部类。</li><li>9.闭包和内部类的区别？</li><li>10.Java多态的实现机制是什么？</li><li>11.谈谈你对对象生命周期的认识？</li><li>12.static关键字的作用？</li><li>13.final关键字的作用。</li></ul><h3 id="1-4-八大基本数据类型-amp-引用类型"><a href="#1-4-八大基本数据类型-amp-引用类型" class="headerlink" title="1.4 八大基本数据类型&amp;引用类型"></a>1.4 八大基本数据类型&amp;引用类型</h3><ul><li>1.说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 什么是引用类型？</li><li>2.什么是拆箱 &amp; 装箱，能给我举栗子吗？</li></ul><h3 id="1-5-数组"><a href="#1-5-数组" class="headerlink" title="1.5 数组"></a>1.5 数组</h3><ul><li>1.能说说多维数组在内存上是怎么存储的吗？</li><li>2.你对数组二次封装过吗？说说封装了什么</li></ul><h3 id="1-6-Java异常"><a href="#1-6-Java异常" class="headerlink" title="1.6 Java异常"></a>1.6 Java异常</h3><ul><li>1.说说Java异常体系主要用来干什么的 &amp; 异常体系？</li><li>2.Error和Exception的区别？</li><li>3.说说运行时异常和非运行时异常的区别？</li><li>4.如何自定义一个异常？</li><li>5.throw和throws 的区别？</li><li>6.try{}catch{}finally{}可以没有finally吗？</li><li>7.finally语块有什么特点？</li><li>8.return在try{}catch{}finally{}中执行具有哪些规则？</li><li>9.给我例举至少5个常见的运行时异常。</li></ul><h3 id="1-7-NIO-BIO-AIO"><a href="#1-7-NIO-BIO-AIO" class="headerlink" title="1.7 NIO/BIO/AIO"></a>1.7 NIO/BIO/AIO</h3><ul><li>1.NIO是什么 &amp; BIO是什么 &amp; AIO是什么 &amp; 它们之间的区别？</li><li>2.IO按照方向和数据类型划分能划分为哪些数据流？</li><li>3.能给我说说NIO有什么特点？平常开发中使用过吗？</li></ul><h3 id="1-8-集合-容器"><a href="#1-8-集合-容器" class="headerlink" title="1.8 集合(容器)"></a>1.8 集合(容器)</h3><ul><li>1.说说Java中集合的框架？</li><li>2.Collection &amp; Map区别</li><li>3.谈谈你常用的集合 &amp; 它们底层的实现方式 &amp; 优缺点 &amp; 使用场景。</li><li>4.Map的遍历方式有哪些？</li><li>5.给我说说ArrayList的扩容机制.</li><li>6.什么是深拷贝 &amp; 浅拷贝 &amp; 如何深拷贝一个List集合.</li><li>7.Set是如何确保它的唯一性的。</li><li>8.你觉得HashMap的元素顺序和什么有关？</li><li>9.Java中HashMap如何解决哈希碰撞的？</li><li>10.ConcurrentHashMap如何实现并发访问的？</li><li>11.谈谈Java集合中那些线程安全的集合 &amp; 实现原理。</li><li>12.说说有哪些集合能加入null,哪些不能加入null,为什么？</li><li>13.说说LinkedHashMap原理。</li><li>14.Collection 和 Collections的区别？</li><li>15.比较一下ArrayMap和HashMap。</li><li>16.说说HashMap的原理。</li></ul><h3 id="1-9-线程"><a href="#1-9-线程" class="headerlink" title="1.9 线程"></a>1.9 线程</h3><ul><li>1.什么是线程？能解决什么问题。</li><li>2.Java中创建线程的2种方式 &amp; 区别？</li><li>3.给我说说线程的生命周期。</li><li>4.线程死锁的原因 &amp; 举个栗子 &amp; 如何避免死锁。</li><li>5.Synchronized放在静态方法和非静态方法上的锁对象分别是什么？</li><li>6.如何停止掉一个线程？</li><li>7.给我说说线程池的种类 &amp; 特点 &amp; 内部原理 &amp; 平时当中使用案例。</li><li>8.给我谈谈你是如何保证线程数据安全问题的？</li><li>9.wait()和sleep()的区别？</li><li>10.什么是公平锁&amp;非公平锁&amp;区别？</li><li>11.给我讲讲线程间通信</li><li>12.volatile关键字是如何使用的？原理是什么</li><li>13.说说使用5个线程去计算一个数组之和的思路。</li><li>14.谈谈线程阻塞的原因有哪些？</li><li>15.谈谈你对notify的理解？</li><li>16.你觉得Lock和Synchronized的区别是什么？</li><li>17.谈谈你对ReentrantLock的认识。</li><li>18.调用run()和start()的区别？</li><li>19.transient关键字的用法 &amp; 作用 &amp; 原理。</li><li>20.线程池的种类  &amp; 工作原理 &amp; ThreadPoolExecutor的工作策略有哪些？</li><li>21.ThreadLocal了解吗？说说原理。</li><li>22.权衡多线程的性能。</li><li>23.如何理解同步和异步，阻塞和非阻塞。</li></ul><h3 id="1-10-泛型"><a href="#1-10-泛型" class="headerlink" title="1.10 泛型"></a>1.10 泛型</h3><ul><li>1.什么是泛型？能解决什么问题？</li><li>2.说说Java中泛型的工作机制？</li><li>3.在泛型种extends和super关键字的区别是什么？</li></ul><h3 id="1-11-反射"><a href="#1-11-反射" class="headerlink" title="1.11 反射"></a>1.11 反射</h3><ul><li>1.什么是反射？</li><li>2.如何获取一个类的成员变量 &amp; 成员方法 &amp; 注解信息 &amp; …。</li><li>3.通常在项目当中用到反射多吗？都是用来干嘛？</li></ul><h3 id="1-12-注解"><a href="#1-12-注解" class="headerlink" title="1.12 注解"></a>1.12 注解</h3><ul><li>1.什么是注解 &amp; 它和注释的区别？</li><li>2.注解的工作机制是什么？</li></ul><h3 id="1-13-Socket编程"><a href="#1-13-Socket编程" class="headerlink" title="1.13 Socket编程"></a>1.13 Socket编程</h3><ul><li>1.什么是Socket编程？</li><li>2.什么是TCP,什么是UDP,二者之间区别如何？</li></ul><h3 id="1-14-设计模式"><a href="#1-14-设计模式" class="headerlink" title="1.14 设计模式"></a>1.14 设计模式</h3><ul><li>1.说说设计模式的六大原则。</li><li>2.请讲讲你会使用的一些设计模式？</li><li>3.请说说单例模式 &amp; 你项目中常用的单例模式。</li><li>4.懒汉单例模式为什么要加volaitle？</li><li>5.能否给我说说Android中至少3个用到设计模式的栗子？</li></ul><h3 id="1-15-JVM相关"><a href="#1-15-JVM相关" class="headerlink" title="1.15 JVM相关"></a>1.15 JVM相关</h3><ul><li>1.什么是class文件？</li><li>2.Java代码执行流程？</li><li>3.Java内存结构 &amp; 内存模型。</li><li>4.GC回收机制。</li><li>5.Java虚拟机是如何加载一个类的？</li><li>6.给我谈谈类加载器。</li><li>7.谈谈static编译运行时的流程，在虚拟机中如何保存的？</li><li>8.说说Java种的4种引用以及用法？</li><li>9.如何判断一个对象是死亡的？</li><li>10.代码中直接调用System.gc()会发生什么？</li><li>11.一个强引用直接被null赋值，那么这个对象会被立刻回收吗？</li><li>12.String a = “a”+”b”+”c”;在内存中创建了几个对象？</li><li>13.谈谈你对字符集的理解。</li><li>14.常见的编码格式有哪些？</li><li>15.utf-8中的中文占几个字节？int型占几个字节？</li><li>16.谈谈你对逻辑地址和物理地址的理解？</li><li>17.你知道对象什么时候会回调finalize方法吗？</li></ul><h3 id="1-16-其它Java部分有关面试题"><a href="#1-16-其它Java部分有关面试题" class="headerlink" title="1.16 其它Java部分有关面试题"></a>1.16 其它Java部分有关面试题</h3><ul><li>1.为什么局部内部类访问局部变量需要final?</li><li>2.String、StringBuffer、StringBuilder、CharSequence的区别。</li><li>3.equals和==的区别？</li><li>4.关于字符串的拼接你在项目中常常怎么操作的？为什么不能用“+”的方式进行拼接呢？</li><li>5.什么是Callback,讲讲你项目中使用的一些有关Callback的栗子。</li><li>6.retrun &amp; break &amp; continue 区别？</li><li>7.如何判断一个字符串是回文字符串？</li><li>8.final,finally,finalize的区别？</li><li>9.什么是动态代理 &amp; 什么是静态代理？</li><li>10.String为什么会加final？</li><li>11.OOM可以try{}catch{}吗？</li><li>12.给我谈谈正则表达式。</li><li>13.如何将String转成int?</li><li>14.谈谈你对String的理解。</li><li>15.你如何理解序列化？有哪些方式序列化？</li><li>16.谈谈你对依赖注入的理解。</li><li>17.给我谈谈你对分派的理解。</li></ul><h2 id="2-Android-部分"><a href="#2-Android-部分" class="headerlink" title="2.Android 部分"></a><strong>2.Android 部分</strong></h2><ul><li>四大组件是哪四个？ABCS(Activity,Braodcast,ContentProvider,Service)</li></ul><h3 id="2-1-Activity"><a href="#2-1-Activity" class="headerlink" title="2.1 Activity"></a>2.1 Activity</h3><ul><li>1.Activity是什么？</li><li>2.典型情况下的Activity生命周期？</li><li>3.异常情况下的Activity的生命周期 &amp; 数据如何保存和恢复？</li><li>4.从Activity A跳转到Activity B之后，然后再点击back建之后，它们的生命周期调用流程是什么？</li><li>5.如何统计Activity的工作时间？</li><li>6.给我说说Activity的启动模式 &amp; 使用场景。</li><li>7.如何在任意位置关掉应用所有Activity &amp; 如何在任意位置关掉指定的Activity？</li><li>8.Activity的启动流程(从源码角度解析)？</li><li>9.启动一个其它应用的Activity的生命周期分析。</li><li>10.Activity任务栈是什么？在项目中有用到它吗？说给我听听</li><li>11.什么情况下Activity不走onDestory?</li><li>12.什么情况下Activity会单独执行onPause?</li><li>13.a-&gt;b-&gt;c界面，其中b是SingleInstance的，那么c界面点back返回a界面，为什么？</li><li>14.如果一个Activity弹出一个Dialog,那么这个Acitvity会回调哪些生命周期函数呢？</li><li>15.Activity之间如何通信 &amp; Activity和Fragment之间通信 &amp; Activity和Service之间通信？</li><li>16.说说Activity横竖屏切换的生命周期。</li><li>17.前台切换到后台，然后在回到前台时Activity的生命周期。</li><li>18.下拉状态栏时Activity的生命周期？</li><li>19.Activity与Fragment的生命周期比较？</li><li>20.了解哪些Activity常用的标记位Flags？</li><li>21.谈谈隐式启动和显示启动Activity的方式？</li><li>22.Activity用Intent传递数据和Bundle传递数据的区别？为什么不用HashMap呢？</li><li>23.在隐式启动中Intent可以设置多个action,多个category吗 &amp; 顺便讲讲它们的匹配规则？</li><li>24.Activity可以设置为对话框的形式吗？</li><li>25.如何给Activity设置进入和退出的动画？</li><li>26.Activity使用Intent传递数据是否有限制 &amp; 如果传递一个复杂的对象，例如一个复杂的控件对象应该怎么做？</li></ul><h3 id="2-2-BroadcastReceiver"><a href="#2-2-BroadcastReceiver" class="headerlink" title="2.2 BroadcastReceiver"></a>2.2 BroadcastReceiver</h3><ul><li>1.广播是什么？</li><li>2.广播的注册方式有哪些？</li><li>3.广播的分类 &amp; 特性 &amp; 使用场景？</li><li>4.说说系统广播和本地广播的原理 &amp; 区别 &amp; 使用场景。</li><li>5.有两个应用注册了一样的广播，一个是静态，一个是动态，连优先级也一样，那么当广播从系统发出来后，哪个应用先接收到广播？</li></ul><h3 id="2-3-ContentProvider"><a href="#2-3-ContentProvider" class="headerlink" title="2.3 ContentProvider"></a>2.3 ContentProvider</h3><ul><li>1.什么是内容提供者？</li><li>2.说说如何创建自己应用的内容提供者 &amp; 使用场景。</li><li>3.说说ContentProvider的原理。</li><li>4.ContentProvider,ContentResolver,ContentObserver之间的关系？</li><li>5.说说ContentProvider的权限管理。</li></ul><h3 id="2-4-Service"><a href="#2-4-Service" class="headerlink" title="2.4 Service"></a>2.4 Service</h3><ul><li>1.什么是Service?</li><li>2.说说Service的生命周期。</li><li>3.Service和Thread的区别？</li><li>4.Android 5.0以上的隐式启动问题及其解决方案。</li><li>5.给我说说Service保活方案</li><li>6.IntentService是什么 &amp; 原理 &amp; 使用场景 &amp; 和Service的区别。</li><li>7.创建一个独立进程的Service应该怎样做？</li><li>8.Service和Activity之间如何通信？</li><li>9.说说你了解的系统Service。</li><li>10.谈谈你对ActivityManagerService的理解。</li><li>11.在Activtiy中创建一个Thread和在一个Service中创建一个Thread的区别？</li></ul><h3 id="2-5-Handler"><a href="#2-5-Handler" class="headerlink" title="2.5 Handler"></a>2.5 Handler</h3><ul><li>1.子线程一定不能更新UI吗？</li><li>2.给我说说Handler的原理</li><li>3.Handler导致的内存泄露你是如何解决的？</li><li>4.如何使用Handler让子线程和子线程通信？</li><li>5.你能给我说说Handler的设计原理？</li><li>6.HandlerThread是什么 &amp; 原理 &amp; 使用场景？</li><li>7.IdleHandler是什么？</li><li>8.一个线程能否创建多个Handler,Handler和Looper之间的对应关系？</li><li>9.为什么Android系统不建议子线程访问UI？</li><li>10.Looper死循环为什么不会导致应用卡死？</li><li>11.使用Handler的postDealy后消息队列有什么变化？</li><li>12.可以在子线程直接new一个Handler出来吗？</li><li>13.Message对象创建的方式有哪些 &amp; 区别？</li></ul><h3 id="2-6-AsyncTask"><a href="#2-6-AsyncTask" class="headerlink" title="2.6 AsyncTask"></a>2.6 AsyncTask</h3><ul><li>1.AsyncTask是什么？能解决什么问题</li><li>2.给我谈谈AsyncTask的三个泛型参数作用 &amp; 它的一些方法作用。</li><li>3.给我说说AsyncTask的原理。</li><li>4.你觉得AsyncTask有不足之处吗？</li></ul><h3 id="2-7-Fragment"><a href="#2-7-Fragment" class="headerlink" title="2.7 Fragment"></a>2.7 Fragment</h3><ul><li>1.Android中v4包下Fragment和app包下Fragment的区别是什么？</li><li>2.Fragment的生命周期 &amp; 请结合Activity的生命周期再一起说说。</li><li>3.说说Fragment如何进行懒加载。</li><li>4.ViewPager + Fragment结合使用会出现内存泄漏吗 &amp; 如何解决？</li><li>5.Fragment如何和Activity进行通信 &amp; Fragment之间如何进行通信？</li><li>6.给我谈谈Fragment3种切换的方式以及区别 &amp; 使用场景。</li><li>7.getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？</li><li>8.FragmentPagerAdapter和FragmentStatePagerAdapter区别？</li><li>9.Fragment如何实现类似Activity栈的压栈和出栈效果的？</li></ul><h3 id="2-8-序列化"><a href="#2-8-序列化" class="headerlink" title="2.8 序列化"></a>2.8 序列化</h3><ul><li>1.什么是序列化 &amp; 能用来干什么？</li><li>2.Android中序列化方式有几种？说说它们的区别。</li><li>3.如果想要序列化的类中某些字段不序列化，那么应该怎么做？</li></ul><h3 id="2-9-IPC"><a href="#2-9-IPC" class="headerlink" title="2.9 IPC"></a>2.9 IPC</h3><ul><li>1.说说你对Android多进程开发的认识？</li><li>2.Android中进程间通信的方式有哪些？</li><li>3.什么是AIDL?如何创建一个AIDL。</li></ul><h3 id="2-10-文件存储"><a href="#2-10-文件存储" class="headerlink" title="2.10 文件存储"></a>2.10 文件存储</h3><ul><li>1.说说Android中数据持久化的方式 &amp; 使用场景。</li><li>2.接触过MMKV吗？说说SharedPreference和它的区别。</li><li>3.第三方数据库框架用过哪些？有没有自己封装过一个SQLite的库？</li><li>4.SQLite是线程安全的吗 &amp; SharedPreference是线程安全的吗？</li><li>5.请简单的给我说说什么是三级缓存？</li><li>6.SharedPreference的apply和commit的区别。</li><li>7.谈谈你对SQLite事务的认识。</li><li>8.千奇百怪的SQL语句考察。</li><li>9.SharePreference跨进程使用会怎么样？如何保证跨进程使用安全？</li><li>10.谈谈SQLite升级要注意哪些地方？</li></ul><h3 id="2-11-ListView-amp-RecyclerView"><a href="#2-11-ListView-amp-RecyclerView" class="headerlink" title="2.11 ListView &amp; RecyclerView"></a>2.11 ListView &amp; RecyclerView</h3><ul><li>1.ListView是什么？如何使用？</li><li>2.RecyclerView是什么？如何使用？如何返回不一样的Item。</li><li>3.ListView和RecycyclerView的区别是什么？</li><li>4.分别讲讲你对ListView &amp; RecyclerView的优化经验。</li><li>5.给我说说RecyclerView的回收复用机制</li><li>6.说说你是如何给ListView &amp; RecyclerView加上拉刷新 &amp; 下拉加载更多机制。</li><li>7.谈谈你是如何对ListView &amp; RecycleView进行局部刷新的？</li><li>8.谈谈如何进行分页加载？</li><li>9.ScrollView下嵌套一个ListView通常会出现什么问题？</li><li>10.一个ListView或者一个RecyclerView在显示新闻数据的时候，出现图片错位，可能的原因有哪些 &amp; 如何解决？</li></ul><h3 id="2-12-图片编程"><a href="#2-12-图片编程" class="headerlink" title="2.12 图片编程"></a>2.12 图片编程</h3><ul><li>1.你对Bitmap了解吗？它在内存中如何存在？</li><li>2.有关Bitmap导致OOM的原因知道吗？如何优化？</li><li>3.给我谈谈图片压缩。</li><li>4.LruCache &amp; DiskLruCache原理。</li><li>5.说说你平常会使用的一些第三方图片加载库,最好给我谈谈它的原理。</li><li>6.如果让你设计一个图片加载库，你会如何设计？</li><li>7.有一张非常大的图片,你如何去加载这张大图片？</li><li>8.你知道Android中处理图片的一些库吗(OpenCv &amp; GPUImage …)？</li><li>9.如何计算一张图片在内存中占用的大小？</li></ul><h3 id="2-13-WebView"><a href="#2-13-WebView" class="headerlink" title="2.13 WebView"></a>2.13 WebView</h3><ul><li>1.WebView是什么？</li><li>2.WebView会导致内存泄露吗？原因是什么？解决方式有哪些？</li><li>3.你知道Hybrid开发吗？说说你的相关经验。</li><li>4.说说WebSettings &amp; WebViewClient &amp; WebChromeClient这三个类的作用 &amp; 用法。</li><li>5.说说你了解的Hybrid框架。</li></ul><h3 id="2-14-ViewPager"><a href="#2-14-ViewPager" class="headerlink" title="2.14 ViewPager"></a>2.14 ViewPager</h3><ul><li>1.什么是ViewPager?说说它的那些适配器。</li><li>2.你了解ViewPager2吗？和ViewPager 1有哪些区别？</li><li>3.ViewPager + Fragment结合使用存在的内存泄漏的原因是什么？如何解决？</li></ul><h3 id="2-15-View事件分发机制"><a href="#2-15-View事件分发机制" class="headerlink" title="2.15 View事件分发机制"></a>2.15 View事件分发机制</h3><ul><li>1.什么是事件分发机制？主要用来解决什么问题？</li><li>2.给我说说事件分发的流程 &amp; 你项目解决事件冲突的一些案例。</li><li>3.多点触摸事件平时接触过吗？如何监听用户第二个手指，第三个…？</li><li>4.OnTouchListener &amp; OnTouchEvent &amp; onClickListener三者之间的关系？</li><li>5.谈谈你对MotionEvent的认识？Cancel事件是什么情况下触发的？</li><li>6.能给我谈谈Android中坐标体系吗？</li></ul><h3 id="2-16-View绘制机制"><a href="#2-16-View绘制机制" class="headerlink" title="2.16 View绘制机制"></a>2.16 View绘制机制</h3><ul><li>1.说说View绘制流程。</li><li>2.说说Activity View树结构。</li><li>3.自定义View的方式有哪些?给我说说你之前项目中的案例。</li><li>4.invalidate和postvalidate的区别？</li><li>5.说说你在自定义View时常常重写的一些方法？</li><li>6.说说自定义View中如何自定义属性？</li><li>7.requestLayout(),onLayout(),onDraw(),drawChild()区别和联系？</li><li>8.如何计算出一个View的嵌套层级？</li><li>9.自定义View如何考虑机型适配？</li></ul><h3 id="2-17-布局"><a href="#2-17-布局" class="headerlink" title="2.17 布局"></a>2.17 布局</h3><ul><li>1.说说Android中有哪些布局 &amp; 特点。</li><li>2.你知道布局文件到控件对象的过程吗？</li><li>3.有这么一个布局需求，一个文本控件放在屏幕一半的一半的中间位置，你如何进行布局？</li><li>4.LinearLayout,FrameLayout,RelativeLayout性能对比，为什么？</li></ul><h3 id="2-18-Binder"><a href="#2-18-Binder" class="headerlink" title="2.18 Binder"></a>2.18 Binder</h3><ul><li>1.什么是Binder？用来干什么？</li><li>2.给我具体讲讲Binder机制。</li></ul><h3 id="2-19-动画机制"><a href="#2-19-动画机制" class="headerlink" title="2.19 动画机制"></a>2.19 动画机制</h3><ul><li>1.Android中的动画分为哪些种类 &amp; 特点 &amp; 缺点。</li><li>2.知道SVG &amp; 矢量动画吗？</li><li>3.给我说说转场动画。</li><li>4.给我谈谈插值器 &amp; 估值器 的作用。</li><li>5.说说Android动画框架实现的原理。</li></ul><h3 id="2-20-JNI"><a href="#2-20-JNI" class="headerlink" title="2.20 JNI"></a>2.20 JNI</h3><ul><li>1.什么是JNI?它主要用来干什么。</li><li>2.Java Native方法如何和Native函数进行绑定的？</li><li>3.JNI如何实现数据传递？</li><li>4.如何全局捕获Native发生的异常？</li><li>5.只有C/C++能编写Native库吗？</li></ul><h3 id="2-21-Window-amp-Appliction-amp-Context"><a href="#2-21-Window-amp-Appliction-amp-Context" class="headerlink" title="2.21 Window &amp; Appliction &amp; Context"></a>2.21 Window &amp; Appliction &amp; Context</h3><ul><li>1.说说你对Android中Window的理解。</li><li>2.说说你对Application的理解 &amp; 生命周期。</li><li>3.Android中有哪些上下文 &amp; 区别 &amp; 作用。</li><li>4.谈谈你对Android中Context的理解。</li></ul><h3 id="2-22-通知"><a href="#2-22-通知" class="headerlink" title="2.22 通知"></a>2.22 通知</h3><ul><li>1.Android 8.0如何适配通知？</li><li>2.自定义通知流程？</li></ul><h3 id="2-23-对话框-Dialog-amp-DialogFragment-amp-PopWindow"><a href="#2-23-对话框-Dialog-amp-DialogFragment-amp-PopWindow" class="headerlink" title="2.23 对话框(Dialog &amp; DialogFragment &amp; PopWindow)"></a>2.23 对话框(Dialog &amp; DialogFragment &amp; PopWindow)</h3><ul><li>1.说说Android中对话框可以用哪些方式完成？</li></ul><h3 id="2-24-蓝牙"><a href="#2-24-蓝牙" class="headerlink" title="2.24 蓝牙"></a>2.24 蓝牙</h3><ul><li>1.说说最新的蓝牙版本？新版本的特性是什么？</li></ul><h3 id="2-25-冷启动-amp-热启动"><a href="#2-25-冷启动-amp-热启动" class="headerlink" title="2.25 冷启动&amp;热启动"></a>2.25 冷启动&amp;热启动</h3><ul><li>1.什么是冷启动 &amp; 什么是热启动 &amp; 它们的流程？</li><li>2.如何优化冷启动？</li><li>3.启动页白屏，黑屏，太慢如何解决？</li></ul><h3 id="2-26-悬浮窗"><a href="#2-26-悬浮窗" class="headerlink" title="2.26 悬浮窗"></a>2.26 悬浮窗</h3><ul><li>1.在做悬浮窗的时候你遇到了什么困难(主要指悬浮窗权限适配)？</li><li>2.如何制作一个悬浮窗？</li></ul><h3 id="2-27-Android版本"><a href="#2-27-Android版本" class="headerlink" title="2.27 Android版本"></a>2.27 Android版本</h3><ul><li>1.最新的Android版本多少知道吗？有哪些特性</li><li>2.说说更新较大的Android版本。</li></ul><h3 id="2-28-Android-Studio"><a href="#2-28-Android-Studio" class="headerlink" title="2.28 Android Studio"></a>2.28 Android Studio</h3><ul><li>1.你现在比较常用Android Studio那个版本 &amp; 用的Gradle版本是多少？</li><li>2.如何理解gradle?</li><li>3.说说Android Studio中大致项目结构？</li><li>4.混淆是什么 &amp; 为什么需要进行混淆 &amp; 混淆的原理 &amp; 为什么Java反射常常会和混淆冲突？</li></ul><h3 id="2-29-UI卡顿优化"><a href="#2-29-UI卡顿优化" class="headerlink" title="2.29 UI卡顿优化"></a>2.29 UI卡顿优化</h3><ul><li>1.ANR是什么？导致原因有哪些？</li><li>2.谈谈你项目中避免ANR的一些经验。</li><li>3.分别说说Activity &amp; BroadcastReceiver &amp; Serice最长可耗时时间为多少？</li></ul><h3 id="2-30-内存优化"><a href="#2-30-内存优化" class="headerlink" title="2.30 内存优化"></a>2.30 内存优化</h3><ul><li>1.什么是OOM &amp; 什么是内存泄漏 &amp; 什么是内存抖动？</li><li>2.谈谈你项目中内存优化的一些经验。</li></ul><h3 id="2-31-屏幕适配"><a href="#2-31-屏幕适配" class="headerlink" title="2.31 屏幕适配"></a>2.31 屏幕适配</h3><ul><li>1.说说Android中一些屏幕单位。</li><li>2.谈谈你项目中的一些屏幕适配的经验。</li><li>3.今日头条的轻量级适配方案了解吗 &amp; 给我说说原理。</li></ul><h3 id="2-32-多渠道打包-amp-apk签名"><a href="#2-32-多渠道打包-amp-apk签名" class="headerlink" title="2.32 多渠道打包 &amp; apk签名"></a>2.32 多渠道打包 &amp; apk签名</h3><ul><li>1.apk为什么需要签名？</li><li>2.多渠道打包是什么 &amp; 有类似经验吗？</li><li>3.简述多渠道打包及原理和常用操作？</li></ul><h3 id="2-33-项目架构"><a href="#2-33-项目架构" class="headerlink" title="2.33 项目架构"></a>2.33 项目架构</h3><ul><li>1.说说你用过的项目架构？</li><li>2.分别给我说说MVC,MVP,MVVM特点和区别。</li><li>3.以登陆界面为例子,设计MVP架构。</li><li>4.谈谈AndroidManifest.xml文件的理解。</li></ul><h3 id="2-34-Android前沿知识"><a href="#2-34-Android前沿知识" class="headerlink" title="2.34 Android前沿知识"></a>2.34 Android前沿知识</h3><ul><li>1.谷歌新出的Flutter知道吗？</li><li>2.谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。</li><li>3.谈谈Kotlin中协程的认识？</li></ul><h3 id="2-35-音视频开发-高薪"><a href="#2-35-音视频开发-高薪" class="headerlink" title="2.35 音视频开发(高薪)"></a>2.35 音视频开发(高薪)</h3><ul><li>1.之前有过音视频开发经验吗 &amp; 说说用哪些开源架子开发的。</li><li>2.FFmpeng了解过吗？</li><li>3.Android中播放视频音频的方式有哪些？</li><li>4.Android中播放网络地址视频有哪些出色的开源库？</li><li>5.流媒体服务器了解吗？</li><li>6.谈谈你对编码格式的理解。</li><li>7.MediaPlayer和SoundPool的区别？</li><li>8.视频硬解码和软解码的区别？</li></ul><h3 id="2-36-其它Android部分有关面试题"><a href="#2-36-其它Android部分有关面试题" class="headerlink" title="2.36 其它Android部分有关面试题"></a>2.36 其它Android部分有关面试题</h3><ul><li>1.说说一个app的启动流程(从源码角度讲解)。</li><li>2.你知道无论是Kotlin或者是Java,程序运行的主要入口都是main()方法，那么Android的main方法在哪里？</li><li>3.Android Hock技术了解吗？</li><li>4.简述Android中的加固和使用平台？</li><li>5.谈谈你对Apk瘦身的经验？</li><li>6.为什么子线程不能更新UI？</li><li>7.你知道如何定位内存泄漏吗？</li><li>8.说说System.exit(0),onDestory(),Activity.finish()的区别？</li><li>9.在OnResume或者之前获取View的宽高为多少 &amp; 为什么？</li><li>10.Art &amp; Dvm 区别，特别是谈谈GC的区别。</li><li>11.说说你用的二维码框架 &amp; 有过优化经验吗？</li><li>12.谈谈App多进程的好处 &amp; 缺点。</li><li>13.说说AMS是怎么找到启动指定的Activity？</li><li>14.View的getWidth和getMeasureWidth有啥区别？</li><li>15.有插件化或者热修复经验吗？说说它的原理。</li><li>16.断点续传了解吗？谈谈你是如何通过多线程实现断点续传的。</li><li>17.给我谈谈你对SurfaceView的认识。</li><li>18.什么情况下你会使用到ScrollView。</li><li>19.低版本SDK如何使用高版本API？</li><li>20.AlertDialog,PopWindow,Activity之间的区别？</li><li>21.Application和Activity,Context的区别？</li><li>22.谈谈Android中多线程通信方式？</li><li>23.说说Android大体的架构图，试着画出来。</li><li>24.知道SpareArray吗？</li><li>25.Activity除了setContentView可以设置布局，还有其它方式吗？</li><li>26.Android为每个应用程序分配的内存大小为多少？</li><li>27.Android进程保活方案？</li><li>28.谈谈Android系统安装apk的过程？</li><li>29.Activity,Window,View三者的关系？</li><li>30.ActivityThread,ActivityManagerService,WindowManagerService的工作原理？</li><li>31.PackageManagerService的工作原理？</li><li>32.PowerManagerService的工作原理？</li><li>33.在桌面点击一个未启动的App的流程 &amp; 点击一个已启动的App的流程？</li><li>34.Android中进程分为哪些种类？</li><li>35.什么是埋点，懂点它的原理吗？</li><li>36.进程和Application生命周期之间的关系？</li><li>37.App相互唤醒的有哪些方式？</li><li>38.Android中如何开启多进程？应用是否可以开启N个进程？</li><li>39.谈谈消息推送的方式有哪些？</li><li>40.谈谈你对Root权限的理解。</li><li>41.谈谈项目如何进行国际化？</li><li>42.谈谈你对Intent和IntentFilter的理解。</li><li>43.一条最长的短信息约占多少byte？</li></ul><h2 id="3-算法与数据结构部分"><a href="#3-算法与数据结构部分" class="headerlink" title="3.算法与数据结构部分"></a><strong>3.算法与数据结构部分</strong></h2><h3 id="3-1-复杂度分析"><a href="#3-1-复杂度分析" class="headerlink" title="3.1 复杂度分析"></a>3.1 复杂度分析</h3><ul><li>1.什么是时间复杂度 &amp; 什么是空间复杂度？</li><li>2.时间复杂度和空间复杂度之间存在什么联系？</li></ul><h3 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h3><ul><li>1.谈谈你对数组的理解。</li></ul><h3 id="3-3-链表"><a href="#3-3-链表" class="headerlink" title="3.3 链表"></a>3.3 链表</h3><ul><li>1.什么是单链表 &amp; 双向链表 &amp; 循环链表 &amp; 双向循环链表 &amp; 静态链表。</li><li>2.反转一个链表有哪些方式？</li><li>3.如何判断链表有环？</li><li>4.用Java语言设计一个LinkedList。</li></ul><h3 id="3-4-堆"><a href="#3-4-堆" class="headerlink" title="3.4 堆"></a>3.4 堆</h3><ul><li>1.如何理解堆？</li></ul><h3 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5 栈"></a>3.5 栈</h3><ul><li>1.什么是栈 &amp; 栈的特点是什么？</li><li>2.什么是顺序栈 &amp; 链式栈？</li><li>3.你有没有基于栈封装的业务类？</li><li>4.你能用栈实现队列吗？</li><li>5.如何实现浏览器前进和后退功能？</li></ul><h3 id="3-6-队列"><a href="#3-6-队列" class="headerlink" title="3.6 队列"></a>3.6 队列</h3><ul><li>1.什么是队列 &amp; 队列的特点是什么？</li><li>2.什么是优先队列？</li><li>3.什么是双端队列 &amp; 阻塞队列?</li><li>4.你能用队列实现栈吗？</li></ul><h3 id="3-7-散列表"><a href="#3-7-散列表" class="headerlink" title="3.7 散列表"></a>3.7 散列表</h3><ul><li>1.什么是散列函数？</li><li>2.什么是散列冲突？解决的方式有哪些？Java中的HashMap解决方式采用的哪一种？</li><li>3.什么是散列表的动态扩容？</li><li>4.什么是位图？</li></ul><h3 id="3-8-树"><a href="#3-8-树" class="headerlink" title="3.8 树"></a>3.8 树</h3><ul><li>1.什么是二叉树？</li><li>2.什么是先序遍历 &amp; 中序遍历 &amp; 后序遍历。</li><li>3.什么是多路查找树？</li><li>4.什么是红黑树？</li></ul><h3 id="3-9-排序"><a href="#3-9-排序" class="headerlink" title="3.9 排序"></a>3.9 排序</h3><ul><li>1.给我说说你会的排序 &amp; 复杂度如何？</li><li>2.现在有10万条数据需要进行排序，你会选择什么排序？</li></ul><h3 id="3-10-查找"><a href="#3-10-查找" class="headerlink" title="3.10 查找"></a>3.10 查找</h3><ul><li>1.说说你知道的查找算法 &amp; 复杂度如何？</li></ul><h3 id="3-11-递归-amp-回溯算法"><a href="#3-11-递归-amp-回溯算法" class="headerlink" title="3.11 递归&amp;回溯算法"></a>3.11 递归&amp;回溯算法</h3><ul><li>1.什么是递归 &amp; 什么是回溯？</li></ul><h3 id="3-12-贪心算法"><a href="#3-12-贪心算法" class="headerlink" title="3.12 贪心算法"></a>3.12 贪心算法</h3><ul><li>1.什么是贪心算法？</li></ul><h3 id="3-13-其它有关算法与数据结构的面试题"><a href="#3-13-其它有关算法与数据结构的面试题" class="headerlink" title="3.13 其它有关算法与数据结构的面试题"></a>3.13 其它有关算法与数据结构的面试题</h3><ul><li>1.什么是图？可以解决一些什么问题？</li><li>2.时针走一圈，时针分针重合几次？</li><li>3.有一个不均匀的绳子烧完要1个小时，如何算出1小时15分钟？</li><li>4.求1000以内的水仙花数以及40亿以内的水仙花数？</li><li>5.数据怎么压缩，数据的安全。</li><li>6.谈谈你对对称加密 &amp; 非对称加密的理解。</li></ul><h2 id="4-常用的开源库部分"><a href="#4-常用的开源库部分" class="headerlink" title="4.常用的开源库部分"></a><strong>4.常用的开源库部分</strong></h2><h3 id="4-1-异步通信"><a href="#4-1-异步通信" class="headerlink" title="4.1 异步通信"></a>4.1 异步通信</h3><ul><li>1.RxJava用法 &amp; RxJava2用法 &amp; 原理 &amp;用到的设计模式？</li><li>2.EventBus用法 &amp; 原理。</li></ul><h3 id="4-2-网络"><a href="#4-2-网络" class="headerlink" title="4.2 网络"></a>4.2 网络</h3><ul><li>1.OkHttp用法 &amp; 源码分析。</li><li>2.Retrofit用法 &amp; 源码分析。</li><li>3.Volley用法 &amp; 缺点。</li></ul><h3 id="4-3-依赖注入"><a href="#4-3-依赖注入" class="headerlink" title="4.3 依赖注入"></a>4.3 依赖注入</h3><ul><li>1.ButterKnife用法 &amp; 原理。</li><li>2.Dagger2用法 &amp; 原理。</li></ul><h3 id="4-4-图片加载"><a href="#4-4-图片加载" class="headerlink" title="4.4 图片加载"></a>4.4 图片加载</h3><ul><li>1.Glide用法 &amp; 原理。</li><li>2.Picasso用法 &amp; 原理。</li><li>3.Fresco用法 &amp; 原理。</li></ul><h3 id="4-5-数据库"><a href="#4-5-数据库" class="headerlink" title="4.5 数据库"></a>4.5 数据库</h3><ul><li>1.GreenDao。</li><li>2.LitePal。</li><li>3.OrmLite。</li><li>4.DBFlow。</li><li>5.Realm。</li></ul><h3 id="4-6-其它"><a href="#4-6-其它" class="headerlink" title="4.6 其它"></a>4.6 其它</h3><ul><li>1.分享你觉得比较好用的开源库。</li><li>2.自己有封装库吗？给我说说你是如何设计的？</li><li>3.你是如何设计一个网络请求框架的？</li></ul><h2 id="5-计算机网络部分"><a href="#5-计算机网络部分" class="headerlink" title="5.计算机网络部分"></a><strong>5.计算机网络部分</strong></h2><ul><li>1.给我介绍5层网络模型。</li><li>2.Http/Https协议工作在哪一层？</li><li>3.TCP/UDP协议工作在哪一层？</li><li>4.给我说说三次握手和四次挥手。</li><li>5.什么是请求头 &amp; 响应头 ? 说说请求头中一些重要的字段。</li><li>6.什么是Cookie &amp; Session。</li><li>7.知道什么是心跳检测吗？</li><li>8.Http和Https的区别？</li><li>9.加密协议TLS/SSL加密过程是怎样的？</li><li>10.什么是DNS &amp; 作用是什么 &amp;工作机制？</li><li>11.浏览器访问一个url网址所经历的过程是什么？</li><li>12.Socket是协议吗？WebSocket是协议吗？它们的区别是什么？</li><li>13.Json解析方式有哪些？比较它们的优劣势。</li><li>14.XML解析方式有哪些？比较它们的优劣势。</li><li>15.http1.x &amp; http 2.0区别是什么？</li><li>16.说说HTTP缓存的原理。</li><li>17.如果有个100M大的文件，需要上传至服务器中，而服务器form表单最大只能上传2M,可以使用什么方法？</li><li>18.说说你项目中即时通讯的方案有哪些？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Android部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;数据结构与算法部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;常用的开源库部分&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;计算机网络认识&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/categories/Android/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android知识间记，快速回顾各种知识</title>
    <link href="https://zhangmiao.cc/posts/97843d21.html"/>
    <id>https://zhangmiao.cc/posts/97843d21.html</id>
    <published>2019-07-01T06:45:30.000Z</published>
    <updated>2019-07-22T06:56:59.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a><strong>目录：</strong></h3><ul><li><p>网络</p></li><li><p>Java 基础&amp;容器&amp;同步&amp;设计模式</p></li><li><p>Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理</p></li><li><p>Android 基础&amp;性能优化&amp;Framwork</p></li><li><p>Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩</p></li><li><p>音视频&amp;FFmpeg&amp;播放器</p></li></ul><a id="more"></a><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络协议模型"><a href="#网络协议模型" class="headerlink" title="网络协议模型"></a><strong>网络协议模型</strong></h4><p>应用层：负责处理特定的应用程序细节</p><p>HTTP、FTP、DNS</p><p>传输层：为两台主机提供端到端的基础通信<br>TCP、UDP</p><p>网络层：控制分组传输、路由选择等<br>IP</p><p>链路层：操作系统设备驱动程序、网卡相关接口</p><p>#### </p><h4 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a><strong>TCP 和 UDP 区别</strong></h4><p>TCP 连接；可靠；有序；面向字节流；速度慢；较重量；全双工；适用于文件传输、浏览器等</p><ul><li>全双工：A 给 B 发消息的同时，B 也能给 A 发</li><li>半双工：A 给 B 发消息的同时，B 不能给 A 发</li></ul><p>UDP 无连接；不可靠；无序；面向报文；速度快；轻量；适用于即时通讯、视频通话等</p><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a><strong>TCP 三次握手</strong></h4><ol><li>A：你能听到吗？</li><li>B：我能听到，你能听到吗？</li><li>A：我能听到，开始吧</li></ol><p>A 和 B 两方都要能确保：我说的话，你能听到；你说的话，我能听到。所以需要三次握手</p><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a><strong>TCP 四次挥手</strong></h4><ol><li>A：我说完了</li><li>B：我知道了，等一下，我可能还没说完</li><li>B：我也说完了</li><li>A：我知道了，结束吧</li></ol><p>B 收到 A 结束的消息后 B 可能还没说完，没法立即回复结束标示，只能等说完后再告诉 A ：我说完了。</p><h4 id="POST-和-GET-区别"><a href="#POST-和-GET-区别" class="headerlink" title="POST 和 GET 区别"></a><strong>POST 和 GET 区别</strong></h4><p>Get 参数放在 url 中；Post 参数放在 request Body 中</p><p>Get 可能不安全，因为参数放在 url 中</p><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a><strong>HTTPS</strong></h4><ol><li>HTTP 是超文本传输协议，明文传输；HTTPS 使用 SSL 协议对 HTTP 传输数据进行了加密</li><li>HTTP 默认 80 端口；HTTPS 默认 443 端口</li><li>优点：安全</li><li>缺点：费时、SSL 证书收费，加密能力还是有限的，但是比 HTTP 强多了</li></ol><h3 id="Java-基础-amp-容器-amp-同步-amp-设计模式"><a href="#Java-基础-amp-容器-amp-同步-amp-设计模式" class="headerlink" title="Java 基础&amp;容器&amp;同步&amp;设计模式"></a>Java 基础&amp;容器&amp;同步&amp;设计模式</h3><h4 id="StringBuilder、StringBuffer、-、String-concat-链接字符串："><a href="#StringBuilder、StringBuffer、-、String-concat-链接字符串：" class="headerlink" title="StringBuilder、StringBuffer、+、String.concat 链接字符串："></a><strong>StringBuilder、StringBuffer、+、String.concat 链接字符串：</strong></h4><ul><li>StringBuffer 线程安全，StringBuilder 线程不安全</li><li>+实际上是用 StringBuilder 来实现的，所以非循环体可以直接用 +，循环体不行，因为会频繁创建 StringBuilder</li><li>String.concat 实质是 new String ，效率也低，耗时排序：StringBuilder &lt; StringBuffer &lt; concat &lt; +</li></ul><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="Java-泛型擦除"><a href="#Java-泛型擦除" class="headerlink" title="Java 泛型擦除"></a><strong>Java 泛型擦除</strong></h4><ul><li>修饰成员变量等类结构相关的泛型不会被擦除</li><li>容器类泛型会被擦除</li></ul><h4 id="ArrayList、LinkedList"><a href="#ArrayList、LinkedList" class="headerlink" title="ArrayList、LinkedList"></a><strong>ArrayList、LinkedList</strong></h4><p>ArrayList</p><ul><li>基于数组实现，查找快：o(1)，增删慢：o(n)</li><li>初始容量为10，扩容通过 System.arrayCopy 方法</li></ul><p>LinkedList</p><ul><li>基于双向链表实现，查找慢：o(n)，增删快：o(1)</li><li>封装了队列和栈的调用</li></ul><h4 id="HashMap-、HashTable"><a href="#HashMap-、HashTable" class="headerlink" title="HashMap 、HashTable"></a><strong>HashMap 、HashTable</strong></h4><p>HashMap</p><ul><li>基于数组和链表实现，数组是 HashMap 的主体；链表是为解决哈希冲突而存在的</li><li>当发生哈希冲突且链表 size 大于阈值时会扩容，JAVA 8 会将链表转为红黑树提高性能<br>允许 key/value 为 null</li></ul><p>HashTable</p><ul><li>数据结构和 HashMap 一样</li><li>不允许 value 为 null</li><li>线程安全</li></ul><h4 id="ArrayMap、SparseArray"><a href="#ArrayMap、SparseArray" class="headerlink" title="ArrayMap、SparseArray"></a><strong>ArrayMap、SparseArray</strong></h4><p>ArrayMap</p><ul><li>基于两个数组实现，一个存放 hash；一个存放键值对。扩容的时候只需要数组拷贝，不需要重建哈希表</li><li>内存利用率高</li><li>不适合存大量数据，因为会对 key 进行二分法查找（1000以下）</li></ul><p>SparseArray</p><ul><li>基于两个数组实现，int 做 key</li><li>内存利用率高</li><li>不适合存大量数据，因为会对 key 进行二分法查找（1000以下）</li></ul><h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><strong>volatile 关键字</strong></h4><ul><li><p>只能用来修饰变量，适用修饰可能被多线程同时访问的变量</p></li><li><p>相当于轻量级的 synchronized，volatitle 能保证有序性（禁用指令重排序）、可见性；后者还能保证原子性</p></li><li><p>变量位于主内存中，每个线程还有自己的工作内存，变量在自己线程的工作内存中有份拷贝，线程直接操作的是这个拷贝</p></li><li><p>被 volatile 修饰的变量改变后会立即同步到主内存，保持变量的可见性.</p></li></ul><p>双重检查单例，为什么要加 volatile？</p><ul><li>volatile想要解决的问题是，在另一个线程中想要使用instance，发现instance!=null，但是实际上instance还未初始化完毕这个问题</li><li>将instance =newInstance();拆分为3句话是。1.分配内存2.初始化3.将instance指向分配的内存空</li><li>volatile可以禁止指令重排序，确保先执行2，后执行3</li></ul><p><strong>wait 和 sleep</strong></p><ul><li>sleep 是 Thread 的静态方法，可以在任何地方调用</li><li>wait 是 Object 的成员方法，只能在 synchronized 代码块中调用，否则会报 IllegalMonitorStateException 非法监控状态异常</li><li>sleep 不会释放共享资源锁，wait 会释放共享资源锁</li></ul><p><strong>lock 和 synchronized</strong></p><ul><li>synchronized 是 Java 关键字，内置特性；Lock 是一个接口</li><li>synchronized 会自动释放锁；lock 需要手动释放，所以需要写到 try catch 块中并在 finally 中释放锁</li><li>synchronized 无法中断等待锁；lock 可以中断</li><li>Lock 可以提高多个线程进行读/写操作的效率</li><li>竞争资源激烈时，lock 的性能会明显的优于 synchronized</li></ul><p><strong>可重入锁</strong></p><ul><li>定义：已经获取到锁后，再次调用同步代码块/尝试获取锁时不必重新去申请锁，可以直接执行相关代码</li><li>ReentrantLock 和 synchronized 都是可重入锁</li></ul><p><strong>公平锁</strong></p><ul><li>定义：等待时间最久的线程会优先获得锁</li><li>非公平锁无法保证哪个线程获取到锁，synchronized 就是非公平锁</li><li>ReentrantLock 默认时非公平锁，可以设置为公平锁</li></ul><p><strong>乐观锁和悲观锁</strong></p><ul><li>悲观锁：线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁</li><li>乐观锁：假设没有冲突，不加锁，更新数据时判断该数据是否过期，过期的话则不进行数据更新，适用于读取操作频繁的场景</li><li>乐观锁 CAS：Compare And Swap，更新数据时先比较原值是否相等，不相等则表示数据过去，不进行数据更新</li><li>乐观锁实现：AtomicInteger、AtomicLong、AtomicBoolean</li></ul><p><strong>死锁 4 个必要条件</strong></p><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ul><p><strong>synchronized 原理</strong></p><ul><li>每个对象都有一个监视器锁：monitor，同步代码块会执行  monitorenter 开始，motnitorexit 结束</li><li>wait/notify 就依赖 monitor 监视器，所以在非同步代码块中执行会报 IllegalMonitorStateException 异常</li></ul><h3 id="Java-虚拟机-amp-内存结构-amp-GC-amp-类加载-amp-四种引用-amp-动态代理"><a href="#Java-虚拟机-amp-内存结构-amp-GC-amp-类加载-amp-四种引用-amp-动态代理" class="headerlink" title="Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理"></a>Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h4><ul><li>定义：可以理解成一个虚构的计算机，解释自己的字节码指令集映射到本地 CPU 或 OS 的指令集，上层只需关注 Class 文件，与操作系统无关，实现跨平台</li><li>Kotlin 就是能解释成 Class 文件，所以可以跑在 JVM 上</li></ul><h4 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a><strong>JVM 内存模型</strong></h4><ul><li>Java 多线程之间是通过共享内存来通信的，每个线程都有自己的本地内存</li><li>共享变量存放于主内存中，线程会拷贝一份共享变量到本地内存</li><li>volatile 关键字就是给内存模型服务的，用来保证内存可见性和顺序性</li></ul><h4 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a><strong>JVM 内存结构</strong></h4><p>线程私有：</p><ul><li>程序计数器：记录正在执行的字节码指令地址，若正在执行 Native 方法则为空</li><li>虚拟机栈：执行方法时把方法所需数据存为一个栈帧入栈，执行完后出栈</li><li>本地方法栈：同虚拟机栈，但是针对的是 Native 方法</li></ul><p>线程共享：</p><ul><li>堆：存储 Java 实例，GC 主要区域，分代收集 GC 方法会吧堆划分为新生代、老年代</li><li>方法区：存储类信息，常量池，静态变量等数据</li></ul><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a><strong>GC</strong></h4><h4 id="回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收"><a href="#回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收" class="headerlink" title="回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收"></a>回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收</h4><h4 id="回收类型："><a href="#回收类型：" class="headerlink" title="回收类型："></a><strong>回收类型：</strong></h4><p>1.堆中的对象</p><ul><li><p>分代收集 GC 方法会吧堆划分为新生代、老年代</p></li><li><p>新生代：新建小对象会进入新生代；通过复制算法回收对象</p></li><li><p>老年代：新建大对象及老对象会进入老年代；通过标记-清除算法回收对象</p></li></ul><p>2.方法区中的类信息、常量池</p><p><strong>判断一个对象是否可被回收：</strong></p><p>1.引用计数法<br>缺点：循环引用</p><p>2.可达性分析法<br>定义：从 GC ROOT 开始搜索，不可达的对象都是可以被回收的</p><p><strong>GC ROOT</strong> </p><p>1.虚拟机栈/本地方法栈中引用的对象<br>2.方法区中常量/静态变量引用的对象</p><h4 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a><strong>四种引用</strong></h4><ul><li>强引用：不会被回收</li><li>软引用：内存不足时会被回收</li><li>弱引用：gc 时会被回收</li><li>虚引用：无法通过虚引用得到对象，可以监听对象的回收</li></ul><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><strong>ClassLoader</strong></h4><p>类的生命周期：<br>1.加载；2.验证；3.准备；4.解析；5.初始化；6.使用；7.卸载</p><p>类加载过程：</p><p>1.加载：获取类的二进制字节流；生成方法区的运行时存储结构；在内存中生成 Class 对象<br>2.验证：确保该 Class 字节流符合虚拟机要求<br>3.准备：初始化静态变量<br>4.解析：将常量池的符号引用替换为直接引用<br>5.初始化：执行静态块代码、类变量赋值</p><p>类加载时机：</p><p>1.实例化对象<br>2.调用类的静态方法<br>3.调用类的静态变量（放入常量池的常量除外）</p><p>类加载器：负责加载 class 文件</p><p>分类：</p><p>1.引导类加载器 - 没有父类加载器<br>2.拓展类加载器 - 继承自引导类加载器<br>3.系统类加载器 - 继承自拓展类加载器</p><p><strong>双亲委托模型：</strong></p><p>当要加载一个 class 时，会先逐层向上让父加载器先加载，加载失败才会自己加载</p><p>为什么叫双亲？不考虑自定义加载器，系统类加载器需要网上询问两层，所以叫双亲</p><p>判断是否是同一个类时，除了类信息，还必须时同一个类加载器</p><p>优点：</p><ul><li>防止重复加载，父加载器加载过了就没必要加载了</li><li>安全，防止篡改核心库类</li></ul><h4 id="动态代理原理及实现"><a href="#动态代理原理及实现" class="headerlink" title="动态代理原理及实现"></a><strong>动态代理原理及实现</strong></h4><ul><li>InvocationHandler 接口，动态代理类需要实现这个接口</li><li>Proxy.newProxyInstance，用于动态创建代理对象</li><li>Retrofit 应用： Retrofit 通过动态代理，为我们定义的请求接口都生成一个动态代理对象，实现请求</li></ul><h3 id="Android-基础-amp-性能优化-amp-Framwork"><a href="#Android-基础-amp-性能优化-amp-Framwork" class="headerlink" title="Android 基础&amp;性能优化&amp;Framwork"></a>Android 基础&amp;性能优化&amp;Framwork</h3><h4 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a><strong>Activity 启动模式</strong></h4><ul><li>standard 标准模式</li><li>singleTop 栈顶复用模式，<br>* 推送点击消息界面</li><li>singleTask 栈内复用模式，<br>* 首页</li><li>singleInstance 单例模式，单独位于一个任务栈中<br>* 拨打电话界面<br>细节：<br>* taskAffinity：任务相关性，用于指定任务栈名称，默认为应用包名<br>* allowTaskReparenting：允许转移任务栈</li></ul><h4 id="View-工作原理"><a href="#View-工作原理" class="headerlink" title="View 工作原理"></a><strong>View 工作原理</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* DecorView (FrameLayout)</span><br><span class="line">   * LinearLayout</span><br><span class="line">       * titlebar</span><br><span class="line">       * Content</span><br><span class="line">       * 调用 setContentView 设置的 View</span><br></pre></td></tr></table></figure><p>ViewRoot 的 performTraversals 方法调用触发开始 View 的绘制，然后会依次调用:</p><ul><li>performMeasure：遍历 View 的 measure 测量尺寸</li><li>performLayout：遍历 View 的 layout 确定位置</li><li>performDraw：遍历 View 的 draw 绘制</li></ul><p>#### </p><h4 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a><strong>事件分发机制</strong></h4><ul><li>一个 MotionEvent 产生后，按 Activity -&gt; Window -&gt; decorView -&gt; View 顺序传递，View 传递过程就是事件分发，主要依赖三个方法:</li><li>dispatchTouchEvent：用于分发事件，只要接受到点击事件就会被调用，返回结果表示是否消耗了当前事件</li><li>onInterceptTouchEvent：用于判断是否拦截事件，当 ViewGroup 确定要拦截事件后，该事件序列都不会再触发调用此 ViewGroup 的 onIntercept</li><li>onTouchEvent：用于处理事件，返回结果表示是否处理了当前事件，未处理则传递给父容器处理</li><li>细节：<ul><li>一个事件序列只能被一个 View 拦截且消耗</li><li>View 没有 onIntercept 方法，直接调用 onTouchEvent 处理</li><li>OnTouchListener 优先级比 OnTouchEvent 高，onClickListener 优先级最低</li><li>requestDisallowInterceptTouchEvent 可以屏蔽父容器 onIntercet 方法的调用</li></ul></li></ul><h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><h4 id="Window-、-WindowManager、WMS、SurfaceFlinger"><a href="#Window-、-WindowManager、WMS、SurfaceFlinger" class="headerlink" title="Window 、 WindowManager、WMS、SurfaceFlinger"></a><strong>Window 、 WindowManager、WMS、SurfaceFlinger</strong></h4><ul><li>Window：抽象概念不是实际存在的，而是以 View 的形式存在，通过 PhoneWindow 实现</li><li>WindowManager：外界访问 Window 的入口，内部与 WMS 交互是个 IPC 过程</li><li>WMS：管理窗口 Surface 的布局和次序，作为系统级服务单独运行在一个进程</li><li>SurfaceFlinger：将 WMS 维护的窗口按一定次序混合后显示到屏幕上</li></ul><h4 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h4><h4 id="View-动画、帧动画及属性动画"><a href="#View-动画、帧动画及属性动画" class="headerlink" title="View 动画、帧动画及属性动画"></a><strong>View 动画、帧动画及属性动画</strong></h4><p>View 动画：</p><p>* 作用对象是 View，可用 xml 定义，建议 xml 实现比较易读<br>* 支持四种效果：平移、缩放、旋转、透明度</p><p>帧动画：</p><p>* 通过 AnimationDrawable 实现，容易 OOM</p><p>属性动画：</p><ul><li>可作用于任何对象，可用 xml 定义，Android 3 引入，建议代码实现比较灵活</li><li>包括 ObjectAnimator、ValuetAnimator、AnimatorSet</li><li>时间插值器：根据时间流逝的百分比计算当前属性改变的百分比</li><li>系统预置匀速、加速、减速等插值器</li><li>类型估值器：根据当前属性改变的百分比计算改变后的属性值</li><li>系统预置整型、浮点、色值等类型估值器</li><li>使用注意事项：</li><li>避免使用帧动画，容易OOM</li><li>界面销毁时停止动画，避免内存泄漏</li><li>开启硬件加速，提高动画流畅性 ，硬件加速：</li><li>将 cpu 一部分工作分担给 gpu ，使用 gpu 完成绘制工作</li><li>从工作分摊和绘制机制两个方面优化了绘制速度</li></ul><h4 id="Handler、MessageQueue、Looper"><a href="#Handler、MessageQueue、Looper" class="headerlink" title="Handler、MessageQueue、Looper"></a><strong>Handler、MessageQueue、Looper</strong></h4><ul><li>Handler：开发直接接触的类，内部持有 MessageQueue 和 Looper</li><li>MessageQueue：消息队列，内部通过单链表存储消息</li><li>Looper：内部持有 MessageQueue，循环查看是否有新消息，有就处理，没就阻塞</li><li>如何实现阻塞：通过 nativePollOnce 方法，基于 Linux epoll 事件管理机制</li><li>为什么主线程不会因为 Looper 阻塞：系统每 16ms 会发送一个刷新 UI 消息唤醒</li></ul><h4 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h4><h4 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a><strong>MVC、MVP、MVVM</strong></h4><ul><li>MVP：Model：处理数据；View：控制视图；Presenter：分离 Activity 和 Model</li><li>MVVM：Model：处理获取保存数据；View：控制视图；ViewModel：数据容器<br>* 使用 Jetpack 组件架构的 LiveData、ViewModel 便捷实现 MVVM</li></ul><h4 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h4><h4 id="Serializable、Parcelable"><a href="#Serializable、Parcelable" class="headerlink" title="Serializable、Parcelable"></a><strong>Serializable、Parcelable</strong></h4><ul><li>Serializable ：Java 序列化方式，适用于存储和网络传输，serialVersionUID 用于确定反序列化和类版本是否一致，不一致时反序列化回失败</li><li>Parcelable ：Android 序列化方式，适用于组件通信数据传递，性能高，因为不像 Serializable 一样有大量反射操作，频繁 GC</li></ul><h4 id="-5"><a href="#-5" class="headerlink" title=" "></a> </h4><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a><strong>Binder</strong></h4><ul><li>Android 进程间通信的中流砥柱，基于客户端-服务端通信方式</li><li>使用 mmap 一次数据拷贝实现 IPC，传统 IPC：用户A空间-&gt;内核-&gt;用户B空间；mmap 将内核与用户B空间映射，实现直接从用户A空间-&gt;用户B空间</li><li>BinderPool 可避免创建多 Service</li></ul><h4 id="-6"><a href="#-6" class="headerlink" title=" "></a> </h4><h4 id="IPC-方式"><a href="#IPC-方式" class="headerlink" title="IPC 方式"></a><strong>IPC 方式</strong></h4><ul><li>Intent extras、Bundle：要求传递数据能被序列化，实现 Parcelable、Serializable ，适用于四大组件通信</li><li>文件共享：适用于交换简单的数据实时性不高的场景</li><li>AIDL：AIDL 接口实质上是系统提供给我们可以方便实现 BInder 的工具<ul><li>Android Interface Definition Language，可实现跨进程调用方法</li><li>服务端：将暴漏给客户端的接口声明在 AIDL 文件中，创建 Service 实现 AIDL 接口并监听客户端连接请求</li><li>客户端：绑定服务端 Service ，绑定成功后拿到服务端 Binder 对象转为 AIDL 接口调用</li><li>RemoteCallbackList 实现跨进程接口监听，同个 Binder 对象做 key 存储客户端注册的 listener</li><li>监听 Binder 断开：1.Binder.linkToDeath 设置死亡代理；2. onServiceDisconnected 回调</li></ul></li><li>Messenger：基于 AIDL 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信</li><li>ContentProvider：基于 Binder 实现，适用于一对多进程间数据共享</li><li>Socket：TCP、UDP，适用于网络数据交换</li></ul><h4 id="-7"><a href="#-7" class="headerlink" title=" "></a> </h4><h4 id="Android-系统启动流程"><a href="#Android-系统启动流程" class="headerlink" title="Android 系统启动流程"></a><strong>Android 系统启动流程</strong></h4><ul><li>按电源键 -&gt; 加载引导程序 BootLoader 到 RAM -&gt; 执行 BootLoader 程序启动内核 -&gt; 启动 init 进程 -&gt; 启动 Zygote 和各种守护进程 -&gt;</li><li>启动  System Server 服务进程开启 AMS、WMS 等 -&gt; 启动 Launcher 应用进程</li></ul><p>#### </p><h4 id="App-启动流程"><a href="#App-启动流程" class="headerlink" title="App 启动流程"></a><strong>App 启动流程</strong></h4><ul><li>Launcher 中点击一个应用图标 -&gt; 通过 AMS 查找应用进程，若不存在就通过 Zygote 进程 fork</li></ul><h4 id="-8"><a href="#-8" class="headerlink" title=" "></a> </h4><h4 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a><strong>进程保活</strong></h4><ul><li>进程优先级：1.前台进程 ；2.可见进程；3.服务进程；4.后台进程；5.空进程</li><li>进程被 kill 场景：1.切到后台内存不足时被杀；2.切到后台厂商省电机制杀死；3.用户主动清理</li><li>保活方式：<ul><li>1.Activity 提权：挂一个 1像素 Activity 将进程优先级提高到前台进程</li><li>2.Service 提权：启动一个前台服务（API&gt;18会有正在运行通知栏）</li><li>3.广播拉活</li><li>4.Service 拉活</li><li>5.JobScheduler 定时任务拉活</li><li>6.双进程拉活</li></ul></li></ul><h4 id="-9"><a href="#-9" class="headerlink" title=" "></a> </h4><h4 id="网络优化及检测"><a href="#网络优化及检测" class="headerlink" title="网络优化及检测"></a><strong>网络优化及检测</strong></h4><ul><li>速度：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；4.IP 直连省去 DNS 解析时间</li><li>成功率：1.失败重试策略；</li><li>流量：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；5.文件下载断点续传 ；6.缓存</li><li>协议层的优化，比如更优的 http 版本等</li><li>监控：Charles 抓包、Network Monitor 监控流量</li></ul><h4 id="-10"><a href="#-10" class="headerlink" title=" "></a> </h4><h4 id="UI卡顿优化"><a href="#UI卡顿优化" class="headerlink" title="UI卡顿优化"></a><strong>UI卡顿优化</strong></h4><ul><li>减少布局层级及控件复杂度，避免过度绘制</li><li>使用 include、merge、viewstub</li><li>优化绘制过程，避免在 Draw 中频繁创建对象、做耗时操作</li></ul><h4 id="-11"><a href="#-11" class="headerlink" title=" "></a> </h4><h4 id="内存泄漏场景及规避"><a href="#内存泄漏场景及规避" class="headerlink" title="内存泄漏场景及规避"></a><strong>内存泄漏场景及规避</strong></h4><ul><li>1.静态变量、单例强引跟生命周期相关的数据或资源，包括 EventBus</li><li>2.游标、IO 流等资源忘记主动释放</li><li>3.界面相关动画在界面销毁时及时暂停</li><li>4.内部类持有外部类引用导致的内存泄漏<br>* handler 内部类内存泄漏规避：1.使用静态内部类+弱引用 2.界面销毁时清空消息队列<br>* 检测：Android Studio Profiler</li></ul><h4 id="-12"><a href="#-12" class="headerlink" title=" "></a> </h4><h4 id="LeakCanary-原理"><a href="#LeakCanary-原理" class="headerlink" title="LeakCanary 原理"></a><strong>LeakCanary 原理</strong></h4><ul><li>通过弱引用和引用队列监控对象是否被回收</li><li>比如 Activity 销毁时开始监控此对象，检测到未被回收则主动 gc ，然后继续监控</li></ul><h4 id="-13"><a href="#-13" class="headerlink" title=" "></a> </h4><h4 id="OOM-场景及规避"><a href="#OOM-场景及规避" class="headerlink" title="OOM 场景及规避"></a><strong>OOM 场景及规避</strong></h4><ul><li>加载大图：减小图片</li><li>内存泄漏：规避内存泄漏</li></ul><h3 id="Android-模块化-amp-热修复-amp-热更新-amp-打包-amp-混淆-amp-压缩"><a href="#Android-模块化-amp-热修复-amp-热更新-amp-打包-amp-混淆-amp-压缩" class="headerlink" title="Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩"></a>Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩</h3><h4 id="Dalvik-和-ART"><a href="#Dalvik-和-ART" class="headerlink" title="Dalvik 和 ART"></a><strong>Dalvik 和 ART</strong></h4><ul><li>Dalvik<br>* 谷歌设计专用于 Android 平台的 Java 虚拟机，可直接运行 .dex 文件，适合内存和处理速度有限的系统<br>* JVM 指令集是基于栈的；Dalvik 指令集是基于寄存器的，代码执行效率更优</li><li>ART<br>* Dalvik 每次运行都要将字节码转换成机器码；ART 在应用安装时就会转换成机器码，执行速度更快<br>* ART 存储机器码占用空间更大，空间换时间</li></ul><h4 id="-14"><a href="#-14" class="headerlink" title=" "></a> </h4><h4 id="APK-打包流程"><a href="#APK-打包流程" class="headerlink" title="APK 打包流程"></a><strong>APK 打包流程</strong></h4><ul><li>1.aapt 打包资源文件生成 R.java 文件；aidl 生成 java 文件</li><li>2.将 java 文件编译为 class 文件</li><li>3.将工程及第三方的 class 文件转换成 dex 文件</li><li>4.将 dex 文件、so、编译过的资源、原始资源等打包成 apk 文件</li><li>5.签名</li><li>6.资源文件对齐，减少运行时内存</li></ul><h4 id="-15"><a href="#-15" class="headerlink" title=" "></a> </h4><h4 id="App-安装过程"><a href="#App-安装过程" class="headerlink" title="App 安装过程"></a><strong>App 安装过程</strong></h4><ul><li>首先要解压 APK，资源、so等放到应用目录</li><li>Dalvik 会将 dex 处理成 ODEX ；ART 会将 dex 处理成 OAT；</li><li>OAT 包含 dex 和安装时编译的机器码</li></ul><p>#### </p><h4 id="组件化路由实现"><a href="#组件化路由实现" class="headerlink" title="组件化路由实现"></a><strong>组件化路由实现</strong></h4><ul><li>ARoute：通过 APT 解析 @Route 等注解，结合 JavaPoet 生成路由表，即路由与 Activity 的映射关系</li></ul><h3 id="音视频-amp-FFmpeg-amp-播放器"><a href="#音视频-amp-FFmpeg-amp-播放器" class="headerlink" title="音视频&amp;FFmpeg&amp;播放器"></a>音视频&amp;FFmpeg&amp;播放器</h3><h4 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a><strong>FFmpeg</strong></h4><p>基于命令方式实现了一个音视频编辑 App：</p><p><em><a href="https://github.com/yhaolpz/FFmpegCmd" target="_blank" rel="noopener">https://github.com/yhaolpz/FFmpegCmd</a></em></p><p>集成编译了 AAC、MP3、H264 编码器</p><h4 id="-16"><a href="#-16" class="headerlink" title=" "></a> </h4><h4 id="播放器原理"><a href="#播放器原理" class="headerlink" title="播放器原理"></a><strong>播放器原理</strong></h4><ul><li>视频播放原理：（mp4、flv）-&gt; 解封装 -&gt; （mp3/aac、h264/h265）-&gt; 解码 -&gt; （pcm、yuv）-&gt; 音视频同步 -&gt; 渲染播放</li><li>音视频同步：<br>* 选择参考时钟源：音频时间戳、视频时间戳和外部时间三者选择一个作为参考时钟源（一般选择音频，因为人对音频更敏感，ijk 默认也是音频）<br>* 通过等待或丢帧将视频流与参考时钟源对齐，实现同步</li></ul><h4 id="-17"><a href="#-17" class="headerlink" title=" "></a> </h4><h4 id="IjkPlayer-原理"><a href="#IjkPlayer-原理" class="headerlink" title="IjkPlayer 原理"></a><strong>IjkPlayer 原理</strong></h4><ul><li>集成了 MediaPlayer、ExoPlayer 和 IjkPlayer 三种实现，其中 IjkPlayer 基于 FFmpeg 的 ffplay</li><li>音频输出方式：AudioTrack、OpenSL ES；视频输出方式：NativeWindow、OpenGL ES</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录：&quot;&gt;&lt;a href=&quot;#目录：&quot; class=&quot;headerlink&quot; title=&quot;目录：&quot;&gt;&lt;/a&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java 基础&amp;amp;容器&amp;amp;同步&amp;amp;设计模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java 虚拟机&amp;amp;内存结构&amp;amp;GC&amp;amp;类加载&amp;amp;四种引用&amp;amp;动态代理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android 基础&amp;amp;性能优化&amp;amp;Framwork&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android 模块化&amp;amp;热修复&amp;amp;热更新&amp;amp;打包&amp;amp;混淆&amp;amp;压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;音视频&amp;amp;FFmpeg&amp;amp;播放器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/categories/Android/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="面试" scheme="https://zhangmiao.cc/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Flutter “保姆”级项目 Demo合集</title>
    <link href="https://zhangmiao.cc/posts/60004316.html"/>
    <id>https://zhangmiao.cc/posts/60004316.html</id>
    <published>2019-05-12T05:40:05.000Z</published>
    <updated>2019-07-22T06:03:30.700Z</updated>
    
    <content type="html"><![CDATA[<p>为啥叫“保姆”级项目，因为是真的贴心…</p><h3 id="flutter-go"><a href="#flutter-go" class="headerlink" title="flutter go"></a>flutter go</h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135152.png" alt=""></td><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135724.png" alt=""></td><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135809.png" alt=""></td></tr></tbody></table><p><em><a href="https://github.com/alibaba/flutter-go" target="_blank" rel="noopener">https://github.com/alibaba/flutter-go</a></em></p><a id="more"></a><h3 id="GSY的-flutter-合集"><a href="#GSY的-flutter-合集" class="headerlink" title="GSY的 flutter 合集"></a>GSY的 flutter 合集</h3><p>GSYFlutterDemo 作为简单示例和解决方案 Demo ，它可以给你学习和工作中提供一些便捷的帮助，比如 如何自定义布局，如何滚动控件到指定 child position ，如何调整 Text 控件的 Line Space ，如何监听键盘的弹出和收起 等等，所以例子方案都独立实现，方便阅读 CV 。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135241.png" alt=""></p><p>已有例子</p><ul><li>Controller 例子</li><li>圆角 例子</li><li>滑动监听 例子</li><li>滑动到指定位置 例子</li><li>滑动到指定位置2 例子</li><li>Transform 例子</li><li>文本行间距 例子</li><li>多种下拉刷新 例子</li><li>绝对定位 例子</li><li>气泡提示框 例子</li><li>标签Wrap 例子</li><li>共享元素动画 例子</li><li>修改状态栏颜色 例子</li><li>系统键盘相关 例子</li><li>动画相关 例子</li><li>悬浮触摸控件 例子</li><li>全局字体大小 例子</li><li>富文本 例子</li><li>ViewPager 例子</li><li>滑动停靠 例子</li><li>验证码输入框 例子</li><li>自定义布局 例子</li><li>自定义布局云词图 例子</li></ul><p><em><a href="https://github.com/CarGuo/GSYFlutterDemo" target="_blank" rel="noopener">https://github.com/CarGuo/GSYFlutterDemo</a></em></p><p>除此之外，GSY 也对外输出了，实战系列博客：</p><p><em><a href="https://juejin.im/user/582aca2ba22b9d006b59ae68/posts" target="_blank" rel="noopener">https://juejin.im/user/582aca2ba22b9d006b59ae68/posts</a></em></p><p>实战项目：</p><p><em><a href="https://github.com/CarGuo/GSYGithubAppFlutter" target="_blank" rel="noopener">https://github.com/CarGuo/GSYGithubAppFlutter</a></em></p><h3 id="Flutter-NoteBook"><a href="#Flutter-NoteBook" class="headerlink" title="Flutter NoteBook"></a>Flutter NoteBook</h3><p>flutetr_note_book有许多flutter相关功能demo的集合，它能够帮助您快速学习一些零碎的知识，本项目将会不定期更新。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135024.png" alt=""></p><p><em><a href="https://github.com/OpenFlutter/Flutter-Notebook" target="_blank" rel="noopener">https://github.com/OpenFlutter/Flutter-Notebook</a></em></p><p>看介绍上写，原本作者计划是日更的，但是日更的压力太大了。</p><p>我曾经尝试过做这样的事情，后来还是觉得不需要给自己太大压力才好，比如：wanandroid 上面的每日一问，现在变成了每周 3 问。</p><p>想要坚持做一件事情，而且是没有明显收益的事情，还是保持一个合理的周期，不要影响到自己才行。</p><p>就像谈恋爱，天天觉得有压力，烦那就不长久了~</p><p>好在作者并没有断更，希望作者能坚持更久，感谢。</p><h3 id="flutter-app"><a href="#flutter-app" class="headerlink" title="flutter_app"></a>flutter_app</h3><p>本项目包括各种基本控件使用（Text、TextField、Icon、Image、Listview、Gridview、Picker、Stepper、Dialog、Slider、Row、Appbar、Sizebox、BottomSheet、Chip、Dismissible、FlutterLogo、Check、Switch、TabBar、BottomNavigationBar、Sliver等）、豆瓣电影、每日一文、和天气、百姓生活、随机诗词、联系人、句子迷、好奇心日报等板块</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722134953.png" alt=""></p><p>这个项目比较大的特色，就是汇集了非常多的实战 app，那么你看到哪个页面效果就能去看看它的实现。</p><p>当然了，现在做具体 app 类似开源项目，最麻烦的就是开放 api 了，很多抓取的一方面不确定是否违规，另一方面极度不稳定，我以前经常推荐完整项目，但是经常过了一段时间就不能访问了。</p><p>所以，你们真要练手，不妨使用 wanandroid.com 的开放 API，网站多数接口和开放 API 是使用的相同的接口，除非这个网站挂了，否则 API 一直很稳定，数据也同步更新，也算我对外的一些付出啦。</p><p><em><a href="https://github.com/shichunlei/flutter_app" target="_blank" rel="noopener">https://github.com/shichunlei/flutter_app</a></em></p><h3 id="awesome-flutter"><a href="#awesome-flutter" class="headerlink" title="awesome-flutter"></a>awesome-flutter</h3><p>类似于收集不错的 Flutter 库，工具，文章，实例等。</p><p>因为是国外开发者做的，所以关注的更多是国外的内容，所以和以上项目做互补还是非常不错的。</p><p>这个资源合集，分类非常细致，有入门，进阶；视频教程等等。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722134928.png" alt=""></p><p><em><a href="https://github.com/Solido/awesome-flutter" target="_blank" rel="noopener">https://github.com/Solido/awesome-flutter</a></em></p><p>另外有一个小技巧，就是你想看什么方向技术的时候，果断用 awesome + 关键词 搜索。</p><h3 id="awesome-kotlin"><a href="#awesome-kotlin" class="headerlink" title="awesome kotlin"></a>awesome kotlin</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722134848.png" alt=""></p><h3 id="awesome-android"><a href="#awesome-android" class="headerlink" title="awesome android"></a>awesome android</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722134825.png" alt=""></p><p>学到了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为啥叫“保姆”级项目，因为是真的贴心…&lt;/p&gt;
&lt;h3 id=&quot;flutter-go&quot;&gt;&lt;a href=&quot;#flutter-go&quot; class=&quot;headerlink&quot; title=&quot;flutter go&quot;&gt;&lt;/a&gt;flutter go&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135152.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135724.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190722135809.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/alibaba/flutter-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alibaba/flutter-go&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>FlutterPlugin开发流程</title>
    <link href="https://zhangmiao.cc/posts/b7213cdb.html"/>
    <id>https://zhangmiao.cc/posts/b7213cdb.html</id>
    <published>2019-04-29T08:00:03.000Z</published>
    <updated>2019-05-27T08:02:01.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章主要介绍了Flutter Plugin开发流程，包括如何利用Android Studio开发以及发布等。</p></blockquote><p>今天这篇文章，给大家介绍如何开发Flutter Plugin中Android的部分。有关Flutter以及Flutter Plugin的概念，感兴趣的可以从官网查看相关资料。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>笔者的环境是Mac下Android Studio进行的开发，AS也是谷歌官推的，安装flutter插件后，开发起来相对于其他IDE来说，方便很多，自带了三种模板：</p><ul><li>Flutter Application： Flutter应用</li><li>Flutter Plugin：Flutter插件</li><li>Flutter Package：纯Dart组件</li></ul><p><code>Plugin其实就是一个特殊的Package</code>。Flutter Plugin提供Android或者iOS的底层封装，在Flutter层提供组件功能，使Flutter可以较方便的调取Native的模块。很多平台相关性或者对于Flutter实现起来比较复杂的部分，都可以封装成Plugin。其原理如下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527160122.png" alt=""></p><p>消息在client和host之间通过平台通道（platform channels）来进行的，之间的通讯都是<code>异步</code>的。</p><a id="more"></a><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><p>直接在Android Studio中新建一个Flutter Plugin的工程，当然也可以使用命令行来进行，例如创建一个flutter_text_plugin。</p><blockquote><p>flutter create –org com.example –plugin flutter_text_plugin</p></blockquote><p>如果想支持swift或者kotlin，可以用如下命令进行创建:</p><blockquote><p>flutter create –org com.example –plugin -i swift -a kotlin flutter_text_plugin</p></blockquote><p>更多的参数选项，大家可以 查看帮助文档，当然还是比较推荐直接用AS进行创建，简单直观。用AS打开项目，可以看到项目的组织结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">    android</span><br><span class="line">    example</span><br><span class="line">    ios</span><br><span class="line">    lib</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>android以及ios文件夹是我们将要编写插件的native层的地方，lib文件夹是编写与native层映射的地方，native与flutter之间不能直接通信，必须通过MethodChannel来间接调用。example文件夹则是例子工程，编写的插件可以直接在这个项目中进行验证。在本文中，我们主要在android目录下进行，也就是android部分。</p><h2 id="编写Android部分"><a href="#编写Android部分" class="headerlink" title="编写Android部分"></a>编写Android部分</h2><p>用AS打开flutter_text_plugin/android项目，这样子开发起来比较方便。但是打开过后，会发现出现了很多错误，提示找不到flutter相关的东西，我们仔细看这个项目，会发现跟我们平时用AS建的Android项目有所不同，少了很多部分，目录也有所不同。这是因为这个android项目不需要能够直接去运行，因此减少了很多东西。但是对于初次接触的人来说，可能是一头懵逼，例如该如何添加第三方库，如何添加proguard rule等等。</p><h3 id="引入flutter库"><a href="#引入flutter库" class="headerlink" title="引入flutter库"></a>引入flutter库</h3><p>android插件工程是没有引入flutter库的，所以才会出现错误提示，我们在项目根目录建立一个libs文件夹，用来存放flutter库。</p><p>flutter库就在我们的flutter sdk中，路径如下</p><blockquote><p><sdk project="">/bin/cache/artifacts/engine</sdk></p></blockquote><p>engine下面包含了各种平台的flutter库，我们随便拷贝一个Android平台的库到libs文件夹下，右键flutter.jar，弹出菜单选择<code>Add As Library...</code>。</p><p>经过这一步，项目中不会再报错了，但是，由于整个flutter plugin包含了flutter库，因此不能只是简单的添加就了事了，点击菜单<code>Project Structure...</code>，找到flutter_text_plugin的Dependencies中，将flutter库的Scope从Implementation改成<code>Compile Only</code>。至此，引入flutter库的工作完成了，可以进行插件的编写操作了。</p><h3 id="添加第三方库"><a href="#添加第三方库" class="headerlink" title="添加第三方库"></a>添加第三方库</h3><p>添加第三方库有两种，一种是jar包引入，另一种通过gradle的方式进行。由于进行了第一步flutter库的引入，这一步就简单多了。查看build.gradle文件，可以看到最下面出现了如下的信息。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compileOnly files(<span class="string">'libs/flutter.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个，是不是就明朗多了，添加静态库以及添加在线库都可以在这个地方进行。例如我添加一个bugly静态库以及okhttp3库：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compileOnly files(<span class="string">'libs/flutter.jar'</span>)</span><br><span class="line">  implementation <span class="string">'com.squareup.okhttp3:okhttp:3.10.0'</span></span><br><span class="line">  implementation files(<span class="string">'libs/bugly_crash_release.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加proguard-rule"><a href="#添加proguard-rule" class="headerlink" title="添加proguard rule"></a>添加proguard rule</h3><p>由于了bugly以及okhttp3库，因此需要添加progurad rule。我们发现项目中没有proguard-rules.pro文件，因此这一步也需要我们自己去创建，在根目录下，建立proguard-rules.pro文件，将混淆规则添加进去，然后修改build.gradle文件，添加如下信息，跟普通Android项目差不多：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">      minifyEnabled <span class="keyword">true</span></span><br><span class="line">      proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">    debug &#123;</span><br><span class="line">      minifyEnabled <span class="keyword">false</span></span><br><span class="line">      proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Android权限"><a href="#Android权限" class="headerlink" title="Android权限"></a>Android权限</h3><p>添加了bugly以及okhttp3库，需要对应的权限申明，才能正常运行。直接在manifest文件下，添加对应的权限</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_LOGS"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h3><p>至此，准备工作都已就绪，你可以把这个项目当做一个独立的Android项目，在上面进行各种封装操作，然后在FlutterTestPlugin文件下，将接口暴露出来。通过platform channels与flutter层关联起来。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>当插件开发完毕，可以将插件发布让其他人使用，在发布之前，确保pubspec.yaml,、README.md以及CHANGELOG.md文件的内容都正确填写完毕。可以通过dry-run命令来看准备是否就绪。</p><blockquote><p>flutter packages pub publish –dry-run</p></blockquote><p>检查无误后，可以执行下面的命令，发布到<a href="https://pub.dartlang.org/" target="_blank" rel="noopener">Pub</a>上。</p><blockquote><p>flutter packages pub publish</p></blockquote><h2 id="如何引用"><a href="#如何引用" class="headerlink" title="如何引用"></a>如何引用</h2><p>对插件的引用有两种，已经发布的和未发布的。</p><h3 id="引用发布的库"><a href="#引用发布的库" class="headerlink" title="引用发布的库"></a>引用发布的库</h3><p>flutter项目的很多资源管理都在根目录的pubspec.yaml下面，类似于js中的一些包管理一样，在<code>dependencies</code>加上我们需要引入的库，例如引入url_launcher库：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  url_launcher: ^<span class="number">0.4</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>如果这个库包含了一些平台相关的东西，例如需要在native层进行使用的话，则需要在对应的native项目单独做引用。</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>修改android/build.gradle的dependencies处做引用：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        provided rootProject.findProject(<span class="string">":url_launcher"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>修改ios/hello.podspec文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  # lines skipped</span><br><span class="line">  s.dependency &apos;url_launcher&apos;</span><br></pre></td></tr></table></figure><h4 id="引用冲突"><a href="#引用冲突" class="headerlink" title="引用冲突"></a>引用冲突</h4><p>引用不同的库可能会导致一些冲突，例如A和B两个插件，都包含了C插件，但是所需的版本不同。因此我们可以采取以下措施避免这种问题：</p><ul><li>尽量使用范围版本而不是指定一个特定的版本。</li><li>强制统一冲突的插件版本</li><li>对于native层，android可以通过force命令强制指定版本，而iOS这边，Cocoapods则不支持引用的override功能。</li></ul><h3 id="引用未发布的库"><a href="#引用未发布的库" class="headerlink" title="引用未发布的库"></a>引用未发布的库</h3><p>引用未发布的库有两种方式，通过本地路径和git地址的方式：</p><h4 id="基于Path的引用方式："><a href="#基于Path的引用方式：" class="headerlink" title="基于Path的引用方式："></a>基于Path的引用方式：</h4><p>这种方式主要针对本地的未发布的库，引用的路径可以是相对或者绝对路径。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  plugin1:</span><br><span class="line">    path: ../plugin1/</span><br></pre></td></tr></table></figure><h4 id="基于Git的引用方式："><a href="#基于Git的引用方式：" class="headerlink" title="基于Git的引用方式："></a>基于Git的引用方式：</h4><p>这种方式针对存放在git上的库，其中path是可选的，可以定位到某个子目录</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  package1:</span><br><span class="line">    git:</span><br><span class="line">      url: git:<span class="comment">//github.com/flutter/packages.git</span></span><br><span class="line">      path: packages/package1</span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>笔者新建了一个flutter学习相关的项目，<a href="https://github.com/yang7229693/flutter-study" target="_blank" rel="noopener">github地址</a>，里面包含了笔者写的关于flutter学习相关的一些文章，后期也会定期更新，也会上传一些学习demo，欢迎大家关注。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/hekaiyou/article/details/72862653" target="_blank" rel="noopener">Flutter进阶—平台插件</a></li><li><a href="https://www.youtube.com/watch?v=tErY3QWTZSA&amp;t=883s" target="_blank" rel="noopener">Flutter - Creating a Plugin</a></li><li><a href="https://flutter.io/flutter-for-android/" target="_blank" rel="noopener">Flutter for Android Developers</a></li><li><a href="https://flutter.io/platform-channels/" target="_blank" rel="noopener">Writing custom platform-specific code with platform channels</a></li><li><a href="https://flutter.io/developing-packages/#step-2b-add-android-platform-code-javakt" target="_blank" rel="noopener">Developing Packages &amp; Plugins</a></li><li><a href="https://flutter.io/using-packages/" target="_blank" rel="noopener">Using Packages</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章主要介绍了Flutter Plugin开发流程，包括如何利用Android Studio开发以及发布等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天这篇文章，给大家介绍如何开发Flutter Plugin中Android的部分。有关Flutter以及Flutter Plugin的概念，感兴趣的可以从官网查看相关资料。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;笔者的环境是Mac下Android Studio进行的开发，AS也是谷歌官推的，安装flutter插件后，开发起来相对于其他IDE来说，方便很多，自带了三种模板：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flutter Application： Flutter应用&lt;/li&gt;
&lt;li&gt;Flutter Plugin：Flutter插件&lt;/li&gt;
&lt;li&gt;Flutter Package：纯Dart组件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Plugin其实就是一个特殊的Package&lt;/code&gt;。Flutter Plugin提供Android或者iOS的底层封装，在Flutter层提供组件功能，使Flutter可以较方便的调取Native的模块。很多平台相关性或者对于Flutter实现起来比较复杂的部分，都可以封装成Plugin。其原理如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527160122.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;消息在client和host之间通过平台通道（platform channels）来进行的，之间的通讯都是&lt;code&gt;异步&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter与Android的交互</title>
    <link href="https://zhangmiao.cc/posts/5ae94dfd.html"/>
    <id>https://zhangmiao.cc/posts/5ae94dfd.html</id>
    <published>2019-04-29T07:46:33.000Z</published>
    <updated>2019-05-27T08:01:52.234Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 说到底只是一个 UI 框架，很多功能都需要通过原生的 Api 来实现，那么就会涉及到 Flutter 和 Native 的交互，因为本人不懂 iOS 开发，所以只能讲下 Flutter 同 Android 的交互。</p><h4 id="Android-项目配置-Flutter-依赖"><a href="#Android-项目配置-Flutter-依赖" class="headerlink" title="Android 项目配置 Flutter 依赖"></a>Android 项目配置 Flutter 依赖</h4><p>既然是互相交互，那么需要准备一个 Android 项目。接着就需要创建 flutter module，让 Android 项目依赖，创建的方法可以参考官网 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fwiki%2FAdd-Flutter-to-existing-apps" target="_blank" rel="noopener">Flutter Wiki</a>，虽然是官网提供的方法，但是完全按照这个步骤来，还是会有坑的，这边就慢慢一步步解决坑。</p><p>如果你用的是 Android Studio 进行开发的话，直接打开底部的 Terminal，直接创建 flutter module 依赖</p><p><code>flutter create -t module flutter_native_contact</code> 至于 module 名可以随意填写，module 创建完后结构大概是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154756.png" alt=""></p><a id="more"></a><p>接着切换到 module 下的 .android 文件夹，接着有坑来了，官网提供的方法是 <code>./gradlew flutter:assembleDebug</code> 可能会提示命令不存在，那么直接通过 <code>gradlew flutter:assembleDebug</code> 来运行，等它自动跑完后，打开根目录下的 <code>settings.gradle</code> 文件，加入官网提供的 gradle 代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setBinding(<span class="keyword">new</span> Binding([gradle: <span class="keyword">this</span>]))                                 <span class="comment">// new</span></span><br><span class="line">evaluate(<span class="keyword">new</span> File(                                                      <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                               <span class="comment">// new</span></span><br><span class="line">  <span class="string">'flutter_native_contact/.android/include_flutter.groovy'</span>              <span class="comment">// new</span></span><br><span class="line">))                                                                      <span class="comment">// new</span></span><br></pre></td></tr></table></figure><p>你以为这里没坑，真是图样图森破，没坑是不可能的，编译器大爷可能会给你甩这么个错误</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154815.png" alt=""></p><p>很明显可以看出是找不到我们的文件，所以把文件名路径给补全</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">evaluate(<span class="keyword">new</span> File(                                                      <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                               <span class="comment">// new</span></span><br><span class="line">  <span class="string">'FlutterNativeContactDemo/flutter_native_contact/.android/include_flutter.groovy'</span> <span class="comment">// 这里补全路径</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>接着打开原有项目下，原有项目下，原有项目下的 app 中的 <code>build.gradle</code> 文件，在 android 下加上如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">  sourceCompatibility <span class="number">1.8</span></span><br><span class="line">  targetCompatibility <span class="number">1.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个必须要加，不要问为什么，我也不知道为什么，最后在项目下添加 flutter module 的依赖就完成了。这个过程告诉我们一个什么道理呢？*不要以为官网的都对，官网讲的也不是完全可信的，时不时给你来个坑就能卡你老半天。</p><h4 id="原生界面加载-Flutter-页面"><a href="#原生界面加载-Flutter-页面" class="headerlink" title="原生界面加载 Flutter 页面"></a>原生界面加载 Flutter 页面</h4><p>那么如何在原生界面显示 Flutter 界面呢，这个就需要通过 FlutterView 来实现了，Flutter 这个类提供了 <code>createView</code> 和 <code>createFragment</code> 两个方法，分别用于返回 FlutterView 和 FlutterFragment 实例，FlutterFragment 的实现原理也是通过 FlutterView 来实现的，可以简单看下 FlutterFragment 的源码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;@link Fragment&#125; managing a &#123;@link FlutterView&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This file is auto-generated by Flutter tooling.</span></span><br><span class="line"><span class="comment"> * DO NOT EDIT.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlutterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> ARG_ROUTE = <span class="string">"route"</span>;</span><br><span class="line">  private <span class="built_in">String</span> mRoute = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public <span class="keyword">void</span> onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// 获取传入的路由值，默认为 '/'</span></span><br><span class="line">    <span class="keyword">if</span> (getArguments() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mRoute = getArguments().getString(ARG_ROUTE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public FlutterView onCreateView(<span class="meta">@NonNull</span> LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="comment">// 最后还是挺过 createView 方法来生成页面，只不过直接放在 fragment，</span></span><br><span class="line">    <span class="comment">// 放在 fragment 会比直接 使用 FlutterView 更方便管理，例如实现 ViewPager 等</span></span><br><span class="line">    <span class="keyword">return</span> Flutter.createView(getActivity(), getLifecycle(), mRoute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="createFragment-方式加载"><a href="#createFragment-方式加载" class="headerlink" title="createFragment 方式加载"></a>createFragment 方式加载</h5><p>在原生页面显示 Flutter 界面的第一种方式就是加载 FlutterFragment，看个比较简单的例子吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    tools:context=<span class="string">".MainActivity"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个布局用于加载 fragment --&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=<span class="string">"@+id/fragment_container"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">        android:id=<span class="string">"@+id/flutter_fragment"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_marginEnd=<span class="string">"20dp"</span></span><br><span class="line">        android:layout_marginBottom=<span class="string">"50dp"</span></span><br><span class="line">        android:src=<span class="string">"@drawable/ic_add_white_36dp"</span></span><br><span class="line">        app:fabSize=<span class="string">"auto"</span></span><br><span class="line">        app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintEnd_toEndOf=<span class="string">"parent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>在 Activity 可以直接通过返回 FlutterFragment 加载到 FrameLayout 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="title">AppCompatActivity</span>() </span>&#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        supportFragmentManager.beginTransaction()</span><br><span class="line">            .add(R.id.fragment_container, Flutter.createFragment(<span class="string">"route_flutter"</span>))</span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把 Flutter 页面加载到原生界面了，会通过传递的路由值在 dart 层进行查找，所以接着就需要编写 Flutter 界面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// runApp 内部值也可以直接传入 _buildWidgetForNativeRoute 方法</span></span><br><span class="line"><span class="comment">/// 这边在外层嵌套一层 MaterialApp 主要是防止一些不必要的麻烦，</span></span><br><span class="line"><span class="comment">/// 例如 MediaQuery 这方面的使用等</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(FlutterApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: _buildWidgetForNativeRoute(<span class="built_in">window</span>.defaultRouteName),</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Color(<span class="number">0XFF008577</span>),</span><br><span class="line">        accentColor: Color(<span class="number">0xFFD81B60</span>),</span><br><span class="line">        primaryColorDark: Color(<span class="number">0xFF00574B</span>),</span><br><span class="line">        iconTheme: IconThemeData(color: Color(<span class="number">0xFFD81B60</span>)),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 该方法用于判断原生界面传递过来的路由值，加载不同的页面</span></span><br><span class="line">Widget _buildWidgetForNativeRoute(<span class="built_in">String</span> route) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'route_flutter'</span>:</span><br><span class="line">      <span class="keyword">return</span> GreetFlutterPage();</span><br><span class="line">    <span class="comment">// 默认的路由值为 '/'，所以在 default 情况也需要返回页面，否则 dart 会报错，这里默认返回空页面</span></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> Scaffold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetFlutterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'NativeMessageContactPage'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(</span><br><span class="line">          <span class="string">'This is a flutter fragment page'</span>,</span><br><span class="line">          style: TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.black),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到页面加载出来了，不过会有一段时间的空白，这个在正式打包后就不会出现，所以不必担心。最后的页面应该是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154907.png" alt=""></p><h5 id="createView-方式加载"><a href="#createView-方式加载" class="headerlink" title="createView 方式加载"></a>createView 方式加载</h5><p>接着看下 createView 方法，说白了，第一种方法最后还是会通过该方式实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">public <span class="keyword">static</span> FlutterView createView(<span class="meta">@NonNull</span> <span class="keyword">final</span> Activity activity, <span class="meta">@NonNull</span> <span class="keyword">final</span> Lifecycle lifecycle, <span class="keyword">final</span> <span class="built_in">String</span> initialRoute) &#123;</span><br><span class="line">  <span class="comment">// 交互前的一些初始化工作，需要完成才可以继续下一步，同时需要保证当前线程为主线程</span></span><br><span class="line">  <span class="comment">// Looper.myLooper() == Looper.getMainLooper()，否则会甩你一脸的 IllegalStateException </span></span><br><span class="line">  FlutterMain.startInitialization(activity.getApplicationContext());</span><br><span class="line">  FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> FlutterNativeView nativeView = <span class="keyword">new</span> FlutterNativeView(activity);</span><br><span class="line">  <span class="comment">// 将 flutter 页面绑定到相应的 activity</span></span><br><span class="line">  <span class="keyword">final</span> FlutterView flutterView = <span class="keyword">new</span> FlutterView(activity, <span class="keyword">null</span>, nativeView) &#123;</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 将路由值传到 flutter 层，并加载相应的页面，</span></span><br><span class="line">  <span class="keyword">if</span> (initialRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">    flutterView.setInitialRoute(initialRoute);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 绑定 lifecycle，方便生命周期管理，同 activity 绑定</span></span><br><span class="line">  <span class="comment">// 不熟悉 LifeCycle 的同学可以自行网上查找资料</span></span><br><span class="line">  lifecycle.addObserver(<span class="keyword">new</span> LifecycleObserver() &#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    public <span class="keyword">void</span> onCreate() &#123;</span><br><span class="line">      <span class="comment">// 配置一些参数，传递到 flutter 层</span></span><br><span class="line">      <span class="keyword">final</span> FlutterRunArguments arguments = <span class="keyword">new</span> FlutterRunArguments();</span><br><span class="line">      arguments.bundlePath = FlutterMain.findAppBundlePath(activity.getApplicationContext());</span><br><span class="line">      arguments.entrypoint = <span class="string">"main"</span>;</span><br><span class="line">      <span class="comment">// 最终会调用方法 nativeRunBundleAndSnapshotFromLibrary，这是一个 native 方法，进行交互</span></span><br><span class="line">      flutterView.runFromBundle(arguments);</span><br><span class="line">      <span class="comment">// 进行注册</span></span><br><span class="line">      GeneratedPluginRegistrant.registerWith(flutterView.getPluginRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flutterView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 createView 方法返回的 FlutterView，通过设置 Layoutparams 参数就可以添加到相应的布局上，还有一种直接通过 addContentView 方式进行加载，这里直接修改原有代码，</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// setContentView(R.layout.activity_main) 不需要这一步了</span></span><br><span class="line">        val flutterView = Flutter.createView(<span class="keyword">this</span><span class="meta">@ContactActivity</span>, lifecycle, <span class="string">"route_flutter"</span>)</span><br><span class="line">        val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</span><br><span class="line">        addContentView(flutterView, lp) <span class="comment">// 直接加载到 activity 页面</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是通过这样加载的话，那么整个页面都是 flutter 的页面。那么之前的效果的 FAB 则不会被加载出来了，即使没有省略 <code>setContentView(R.layout.activity_main)</code> 方法，这个页面的 xml 布局也会被覆盖。</p><h4 id="PlantformChannel"><a href="#PlantformChannel" class="headerlink" title="PlantformChannel"></a>PlantformChannel</h4><p>那么能够在原生界面显示 flutter 页面了，如何互相交互呢，这就需要通过 PlantformChannel 来执行了，PlantformChannel 主要有三种类型，BasicMessageChannel，MethodChannel，EventChannel。通过查看源码可以发现，三个 Channel 的实现机制类似，都是通过 BinaryMessenger 进行信息交流，每个 Channel 通过传入的 channel name 进行区分，所以在注册 Channel 的时候必须要保证 channel name 是唯一的，同时需要传入一个 BinaryMessageHandler 实例，用于传递信息的处理，当 Handler 处理完信息后，会返回一个 result，然后通过 BinaryMessenger 将 result 返回到 Flutter 层。如果需要深入理解这边推荐一篇文章<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5b84ff6a6fb9a019f47d1cc9" target="_blank" rel="noopener">深入理解Flutter PlatformChannel</a></p><p>接下来直接看例子吧，在创建 PlatformChannel 的时候需要传入一个 BinaryMessenger 实例，通过查看 FlutterView 的源码可以发现，FlutterView 就是一个 BinaryMessenger 在 Android 端的实现，所以呢，可以直接通过前面介绍的 <code>Flutter.createView</code> 方法获取注册 Channel 时的 BinaryMessenger 实例了，真是得来全部费工夫~因为通信的方法可能在多个界面会使用，所以还是封装一个通用类来处理会比较合理</p><h5 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a>BasicMessageChannel</h5><blockquote><p>BasicMessageChannel 用于传递字符串和半结构化的信息。</p></blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span>(<span class="title">private</span> <span class="title">val</span> <span class="title">flutterView</span>: <span class="title">FlutterView</span>) :<span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">Any</span>&gt;</span>&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private <span class="keyword">const</span> val TAG = <span class="string">"FlutterPlugin"</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123;</span><br><span class="line">            <span class="comment">// channel name 需要保持两侧一致</span></span><br><span class="line">            val messageChannel =</span><br><span class="line">               BasicMessageChannel(flutterView, Constant.MESSAGE_CHANNEL_NAME, StandardMessageCodec.INSTANCE) <span class="comment">// MessageCodec 有多种实现方式，可以参考推荐的文章</span></span><br><span class="line"></span><br><span class="line">            val instance = FlutterPlugin(flutterView)</span><br><span class="line">            messageChannel.setMessageHandler(instance) <span class="comment">// 注册处理的 Hnadler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onMessage(`object`: Any?, reply: BasicMessageChannel.Reply&lt;Any&gt;?) &#123;</span><br><span class="line">        <span class="comment">// 简单的将从 Flutter 传过来的消息进行吐司，同时返回自己的交互信息</span></span><br><span class="line">        <span class="comment">// `object` 中包含的就是 Flutter 层传递过来的信息，reply 实例用于传递信息到 Flutter 层</span></span><br><span class="line">        Toast.makeText(flutterView.context, `object`.toString(), Toast.LENGTH_LONG).show()</span><br><span class="line">        reply?.reply(<span class="string">"\"Hello Flutter\"--- an message from Android"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就需要有个 FlutterView 用来注册，新建一个 Activity，用于加载 Flutter 页面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactActivity</span> : <span class="title">AppCompatActivity</span>() </span>&#123;</span><br><span class="line">    private lateinit <span class="keyword">var</span> plugin: FlutterPlugin</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入路由值，需要在 flutter 层生成相应的界面</span></span><br><span class="line">        val flutterView = Flutter.createView(<span class="keyword">this</span><span class="meta">@ContactActivity</span>, lifecycle, <span class="string">"route_contact"</span>)</span><br><span class="line">        val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</span><br><span class="line">        addContentView(flutterView, lp)</span><br><span class="line"></span><br><span class="line">        plugin = FlutterPlugin.registerPlugin(flutterView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就要在 Flutter 界面的 <code>_buildWidgetForNativeRoute</code> 方法加入新路由值对应的界面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _buildWidgetForNativeRoute(<span class="built_in">String</span> route) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'route_contact'</span>:</span><br><span class="line">      <span class="keyword">return</span> FlutterContactPage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> Scaffold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterContactPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注册对应的 channel，要保证 channel name 和原生层是一致的</span></span><br><span class="line">  <span class="keyword">final</span> BasicMessageChannel _messageChannel =</span><br><span class="line">      BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Flutter Page'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 简单放一个按钮，通过 channel 传输消息过去，同时将原生层返回的消息打印出来</span></span><br><span class="line">      body: RaisedButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          _messageChannel</span><br><span class="line">              .send(<span class="string">'"Hello Native" --- an message from flutter'</span>)</span><br><span class="line">              .then((str) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Receive message: $str'</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Text(<span class="string">'Send Message to Native'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果小伙伴可以自行执行，点击按钮后会弹出吐司，吐司内容就是 Flutter 传递的信息，同时在控制台可以看到从原生层返回的信息。</p><h5 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h5><blockquote><p>MethodChannel 用于传递方法调用（method invocation）</p></blockquote><p>直接在上述例子中进行修改，例如在 Flutter 页面中实现 Activity 的 finish 方法，并传递参数到前一个界面，先做 Flutter 页面的修改，在 AppBar 上增加一个返回按钮，用于返回上层页面</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterContactPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注册对应的 channel，要保证 channel name 和原生层是一致的</span></span><br><span class="line">  <span class="keyword">final</span> BasicMessageChannel _messageChannel =</span><br><span class="line">      BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec());</span><br><span class="line">  <span class="keyword">final</span> MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        leading: InkWell(</span><br><span class="line">          child: Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">20.0</span>),</span><br><span class="line">            child: Icon(Icons.arrow_back),</span><br><span class="line">          ),</span><br><span class="line">          onTap: () &#123;</span><br><span class="line">            _methodChannel</span><br><span class="line">                <span class="comment">// invokeMethod 第一个值用于传递方法名，第二个值用于传递参数，</span></span><br><span class="line">                <span class="comment">// 这边简单的传递一个字符串，当然也可以传递别的类型，map，list 等等</span></span><br><span class="line">                .invokeMethod&lt;<span class="built_in">bool</span>&gt;(<span class="string">'finishActivity'</span>, <span class="string">'Finish Activity'</span>)</span><br><span class="line">                .then((result) &#123; <span class="comment">// 这边会返回一个结果值，通过判断是否成功来打印不同的信息</span></span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;result ? <span class="string">'has finish'</span> : <span class="string">'not finish'</span>&#125;</span>'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        title: Text(<span class="string">'Flutter Page'</span>),</span><br><span class="line">      ),</span><br><span class="line">        </span><br><span class="line">      body: <span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们需要在 FlutterPlugin 这个类中，做些必要的修改，首先需要实现 <code>MethodCallHandler</code> 接口，该接口中需要实现 <code>onMethodCall</code> 方法，通过获取调用的方法名和参数值，进行相应的处理</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span>(<span class="title">private</span> <span class="title">val</span> <span class="title">flutterView</span>: <span class="title">FlutterView</span>) :</span></span><br><span class="line"><span class="class">    <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span>, <span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">Any</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private <span class="keyword">const</span> val TAG = <span class="string">"FlutterPlugin"</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123;</span><br><span class="line">            val instance = FlutterPlugin(flutterView)</span><br><span class="line">            val methodChannel = MethodChannel(flutterView, Constant.METHOD_CHANNEL_NAME)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            messageChannel.setMessageHandler(instance)</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// call 中携带了 Flutter 层传递过来的方法名和参数信息</span></span><br><span class="line">    <span class="comment">// 可以分别通过 call.method 和 call.arguments 来获取</span></span><br><span class="line">    override fun onMethodCall(call: MethodCall?, result: MethodChannel.Result?) &#123;</span><br><span class="line">        when (call?.method) &#123;</span><br><span class="line">            <span class="string">"finishActivity"</span> -&gt; &#123;</span><br><span class="line">                val activity = flutterView.context <span class="keyword">as</span> Activity</span><br><span class="line">                val info = call.arguments.toString()</span><br><span class="line">                </span><br><span class="line">                val intent = Intent().apply &#123;</span><br><span class="line">                    putExtra(<span class="string">"info"</span>, info)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.setResult(Activity.RESULT_OK, intent)</span><br><span class="line">                activity.finish()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 成功时候通过 result.success 返回值，</span></span><br><span class="line">                <span class="comment">// 如果发生异常，通过 result.error 返回异常信息</span></span><br><span class="line">                <span class="comment">// Flutter 通过 invokeMethod().then() 来处理正常结束的逻辑</span></span><br><span class="line">                <span class="comment">// 通过 catchError 来处理发生异常的逻辑</span></span><br><span class="line">                result?.success(<span class="keyword">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果未找到对应的方法名，则通过 result.notImplemented 来返回异常</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; result?.notImplemented()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终的效果，当点击返回按钮的时候，会将 Flutter 层通过 invokeMethod 传递的 arguments 属性吐司出来，同时，控制台会打印出 “has finish” 的信息</p><h5 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h5><blockquote><p>EventChannel 用于数据流（event streams）的通信</p></blockquote><p>EventChannel 的实现方式也类似，EventChannel 可以持续返回多个信息到 Flutter 层，在 Flutter 层的表现就是一个 stream，原生层通过 sink 不断的添加数据，Flutter 层接收到数据的变化就会作出新相应的处理。在 Android 端实现状态的监听可以通过广播来实现。直接看例子，还是修改上述代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span>(<span class="title">private</span> <span class="title">val</span> <span class="title">flutterView</span>: <span class="title">FlutterView</span>) :</span></span><br><span class="line"><span class="class">    <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span>, <span class="title">EventChannel</span>.<span class="title">StreamHandler</span>, <span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">Any</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">var</span> mStateChangeReceiver: BroadcastReceiver? = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private <span class="keyword">const</span> val TAG = <span class="string">"FlutterPlugin"</span></span><br><span class="line">        <span class="keyword">const</span> val STATE_CHANGE_ACTION = <span class="string">"com.demo.plugins.action.StateChangeAction"</span></span><br><span class="line">        <span class="keyword">const</span> val STATE_VALUE = <span class="string">"com.demo.plugins.value.StateValue"</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123;</span><br><span class="line">            <span class="comment">// ... </span></span><br><span class="line">            val streamChannel = EventChannel(flutterView, Constant.STREAM_CHANNEL_NAME)</span><br><span class="line"></span><br><span class="line">            val instance = FlutterPlugin(flutterView)</span><br><span class="line">            methodChannel.setMethodCallHandler(instance)</span><br><span class="line">            streamChannel.setStreamHandler(instance)</span><br><span class="line">            messageChannel.setMessageHandler(instance)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 StreamHandler 需要重写 onListen 和 onCancel 方法</span></span><br><span class="line">    <span class="comment">// onListen 不会每次数据改变就会调用，只在 Flutter 层，eventChannel 订阅广播</span></span><br><span class="line">    <span class="comment">// 的时候调用，当取消订阅的时候则会调用 onCancel，</span></span><br><span class="line">    <span class="comment">// 所以当开始订阅数据的时候，注册接收数据变化的关闭，</span></span><br><span class="line">    <span class="comment">// 在取消订阅的时候，将注册的广播注销，防止内存泄漏</span></span><br><span class="line">    override fun onListen(argument: Any?, sink: EventChannel.EventSink?) &#123;</span><br><span class="line">        mStateChangeReceiver = createEventListener(sink)</span><br><span class="line">        flutterView.context.registerReceiver(mStateChangeReceiver, IntentFilter(STATE_CHANGE_ACTION))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCancel(argument: Any?) &#123;</span><br><span class="line">        unregisterListener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 activity 被销毁的时候，FlutterView 不一定会调用销毁生命周期，或者会延时调用</span></span><br><span class="line">    <span class="comment">// 这就需要手动去注销一开始注册的广播了</span></span><br><span class="line">    fun unregisterListener() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStateChangeReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            flutterView.context.unregisterReceiver(mStateChangeReceiver)</span><br><span class="line">            mStateChangeReceiver = <span class="keyword">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun createEventListener(sink: EventChannel.EventSink?):</span><br><span class="line">            BroadcastReceiver = object : BroadcastReceiver() &#123;</span><br><span class="line"></span><br><span class="line">        override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.equals(intent?.action, STATE_CHANGE_ACTION)) &#123;</span><br><span class="line">                <span class="comment">// 这边广播只做简单的接收一个整数，然后通过 sink 传递到 Flutter 层</span></span><br><span class="line">                <span class="comment">// 当然，sink 还有 error 方法，用于传递发生的错误信息，</span></span><br><span class="line">                <span class="comment">// 以及 endOfStream 方法，用于结束接收</span></span><br><span class="line">                <span class="comment">// 在 Flutter 层分别有 onData 对应 success 方法，onError 对应 error 方法</span></span><br><span class="line">                <span class="comment">// onDone 对应 endOfStream 方法，根据不同的回调处理不同的逻辑</span></span><br><span class="line">                sink?.success(intent?.getIntExtra(STATE_VALUE, <span class="number">-1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Flutter 层，通过对 stream 的监听，对返回的数据进行处理，为了体现出变化，这边修改成 SatefulWidget 来存储状态</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterContactPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FlutterContactPageState createState() =&gt; _FlutterContactPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FlutterContactPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FlutterContactPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME);</span><br><span class="line">  <span class="keyword">final</span> EventChannel _eventChannel = EventChannel(STREAM_CHANNEL_NAME);</span><br><span class="line">  <span class="keyword">final</span> BasicMessageChannel _messageChannel =</span><br><span class="line">      BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec());</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line">  <span class="keyword">var</span> _receiverMessage = <span class="string">'Start receive state'</span>; <span class="comment">// 初始的状态值</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 当页面生成的时候就开始监听数据的变化</span></span><br><span class="line">    _subscription = _eventChannel.receiveBroadcastStream().listen((data) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _receiverMessage = <span class="string">'receive state value: $data'</span>; <span class="comment">// 数据变化了，则修改数据</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, onError: (e) &#123;</span><br><span class="line">      _receiverMessage = <span class="string">'process error: $e'</span>; <span class="comment">// 发生错误则显示错误信息</span></span><br><span class="line">    &#125;, onDone: () &#123;</span><br><span class="line">      _receiverMessage = <span class="string">'receive data done'</span>; <span class="comment">// 发送完毕则直接显示完毕</span></span><br><span class="line">    &#125;, cancelOnError: <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    _subscription.cancel(); <span class="comment">// 当页面销毁的时候需要将订阅取消，防止内存泄漏</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        leading: InkWell(</span><br><span class="line">          child: Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">20.0</span>),</span><br><span class="line">            child: Icon(Icons.arrow_back),</span><br><span class="line">          ),</span><br><span class="line">          onTap: () &#123;</span><br><span class="line">            <span class="comment">// MethodChannel demo</span></span><br><span class="line">            _methodChannel</span><br><span class="line">                .invokeMethod&lt;<span class="built_in">bool</span>&gt;(<span class="string">'finishActivity'</span>, _receiverMessage)</span><br><span class="line">                .then((result) &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;result ? <span class="string">'has finish'</span> : <span class="string">'not finish'</span>&#125;</span>'</span>);</span><br><span class="line">            &#125;).catchError((e) &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'error happend: $e'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        title: Text(<span class="string">'Flutter Page'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">              <span class="comment">// EventChannel demo，页面直接显示信息的变化</span></span><br><span class="line">              child: Text(</span><br><span class="line">                _receiverMessage,</span><br><span class="line">                style: TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.black),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            <span class="comment">// BasicMessageChannel demo</span></span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                _messageChannel</span><br><span class="line">                    .send(<span class="string">'"Hello Native" --- an message from flutter'</span>)</span><br><span class="line">                    .then((str) &#123;</span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'Receive message: $str'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">'Send Message to Native'</span>),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，需要在 Activity 层调用一个定时任务不断的发送广播</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactActivity</span> : <span class="title">AppCompatActivity</span>() </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">var</span> timer: Timer? = <span class="keyword">null</span></span><br><span class="line">    private <span class="keyword">var</span> task: TimerTask? = <span class="keyword">null</span></span><br><span class="line">    private lateinit <span class="keyword">var</span> random: Random</span><br><span class="line">    private lateinit <span class="keyword">var</span> plugin: FlutterPlugin</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        random = Random() <span class="comment">// 生成随机整数</span></span><br><span class="line">        val flutterView = Flutter.createView(<span class="keyword">this</span><span class="meta">@ContactActivity</span>, lifecycle, <span class="string">"route_contact"</span>)</span><br><span class="line">        val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</span><br><span class="line">        addContentView(flutterView, lp)</span><br><span class="line"></span><br><span class="line">        plugin = FlutterPlugin.registerPlugin(flutterView)</span><br><span class="line"></span><br><span class="line">        timer = Timer() <span class="comment">// 定时器</span></span><br><span class="line">        task = timerTask &#123; <span class="comment">// 定时任务</span></span><br><span class="line">            sendBroadcast(Intent(FlutterPlugin.STATE_CHANGE_ACTION).apply &#123;</span><br><span class="line">                putExtra(FlutterPlugin.STATE_VALUE, random.nextInt(<span class="number">1000</span>))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        timer?.schedule(task, <span class="number">3000</span>, <span class="number">2000</span>) <span class="comment">// 延时 3s 开启定时器，并 2s 发送一次广播</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 页面销毁的时候需要将定时器，定时任务销毁</span></span><br><span class="line">        <span class="comment">// 同时注销 Plugin 中注册的广播，防止内存泄漏</span></span><br><span class="line">        timer?.cancel()</span><br><span class="line">        timer = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        task?.cancel()</span><br><span class="line">        task = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        plugin.unregisterListener()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的实现效果大概是这样的</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-c604f0a652d1c172.gif" alt=""></p><p>Flutter 同 Android 端的交互到这讲的差不多了，和 iOS 的交互其实也类似，只不过在 Android 端通过 FlutterNativeView 来作为 Binarymessenger 的实现，在 iOS 端通过 FlutterBinaryMessenger 协议实现，原理是一致的。至于 Flutter 插件，其实现也是通过以上三种交互方式来实现的，可能我们目前通过 FlutterView 来作为 BinaryMessenger 实例，插件会通过 PluginRegistry.Registrar 实例的 messenger() 方法来获取 BinaryMessenger 实例。</p><p>最后贴上 demo 的地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2FFlutterNativeContactDemo" target="_blank" rel="noopener">ContactDemo</a></p><p>需要了解插件的写法也可以直接查看官方提供的检测电量插件：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fbattery" target="_blank" rel="noopener">Flutter Battery Plugin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 说到底只是一个 UI 框架，很多功能都需要通过原生的 Api 来实现，那么就会涉及到 Flutter 和 Native 的交互，因为本人不懂 iOS 开发，所以只能讲下 Flutter 同 Android 的交互。&lt;/p&gt;
&lt;h4 id=&quot;Android-项目配置-Flutter-依赖&quot;&gt;&lt;a href=&quot;#Android-项目配置-Flutter-依赖&quot; class=&quot;headerlink&quot; title=&quot;Android 项目配置 Flutter 依赖&quot;&gt;&lt;/a&gt;Android 项目配置 Flutter 依赖&lt;/h4&gt;&lt;p&gt;既然是互相交互，那么需要准备一个 Android 项目。接着就需要创建 flutter module，让 Android 项目依赖，创建的方法可以参考官网 &lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fwiki%2FAdd-Flutter-to-existing-apps&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Wiki&lt;/a&gt;，虽然是官网提供的方法，但是完全按照这个步骤来，还是会有坑的，这边就慢慢一步步解决坑。&lt;/p&gt;
&lt;p&gt;如果你用的是 Android Studio 进行开发的话，直接打开底部的 Terminal，直接创建 flutter module 依赖&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flutter create -t module flutter_native_contact&lt;/code&gt; 至于 module 名可以随意填写，module 创建完后结构大概是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527154756.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十四)之实战</title>
    <link href="https://zhangmiao.cc/posts/b447830c.html"/>
    <id>https://zhangmiao.cc/posts/b447830c.html</id>
    <published>2019-04-28T07:33:17.000Z</published>
    <updated>2019-05-31T08:17:27.004Z</updated>
    
    <content type="html"><![CDATA[<p>讲完了常用的部件和网络请求后，差不多该进入整体实战了，这里我们将写一个比较熟悉的项目，郭神的 cool weather。项目将使用 fluro 实现路由管理，dio 实现网络请求，rxdart 实现 BLoC 进行状态管理和逻辑分离，使用文件，shared_preferences，sqflite 实现本地的数据持久化。这边先给出项目的地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather" target="_blank" rel="noopener">flutter_weather</a>，以及最后实现的效果图：</p><table><thead><tr><th>One</th><th>Two</th><th>Three</th></tr></thead><tbody><tr><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527153406.png" alt=""></td><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-50e81d7c4da87e57.gif" alt=""></td><td><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-eb02699bb66b1535.gif" alt=""></td></tr></tbody></table><a id="more"></a><p>除了 fluro 别的基本上前面都讲了，所以在开始正式的实战前，先讲下 fluro</p><h4 id="Fluro"><a href="#Fluro" class="headerlink" title="Fluro"></a>Fluro</h4><p>fluro 是对 Navigator 的一个封装，方便更好的管理路由跳转，当然还存在一些缺陷，例如目前只支持传递字符串，不能传递中文等，但是这些问题都算不上是大问题。</p><p>fluro 的使用很简单，大概分如下的步骤：</p><ol><li><p>在全局定义一个 <code>Router</code> 实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> router = Router();</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Router</code> 实例定义路径和其对应的 <code>Handler</code> 对象</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如定义一个 CityPage 的路径和 Handler</span></span><br><span class="line">Handler cityHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="comment">// 传递的参数都在 params 中，params 是一个 Map&lt;String, List&lt;String&gt;&gt; 类型参数</span></span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first; </span><br><span class="line">  <span class="keyword">return</span> BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由的路径和参数</span></span><br><span class="line"><span class="comment">// 需要注意的是，第一个页面的路径必须为 "/"，别的可为 "/" + 任意拼接</span></span><br><span class="line">router.define(<span class="string">'/city'</span>, handler: cityHandler);</span><br><span class="line"><span class="comment">// 或者官方提供的另一种方式</span></span><br><span class="line">router.define(<span class="string">'/city/:city_id'</span>, handler: cityHandler);</span><br></pre></td></tr></table></figure></li><li><p>将 <code>router</code> 注册到 <code>MaterialApp</code> 的 <code>onGenerateRoute</code> 中</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(onGenerateRoute: router);</span><br></pre></td></tr></table></figure></li><li><p>最后通过 <code>Router</code> 实例进行跳转，如果有参数传递则会在新的页面收到</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">router.navigateTo(context, <span class="string">'/city?city_id=CN13579'</span>);</span><br><span class="line"><span class="comment">// 或者官方的方式</span></span><br><span class="line">router.navigateTo(context, <span class="string">'/city/CN13579'</span>);</span><br></pre></td></tr></table></figure></li></ol><p>在 fluro 中提供了多种路由动画，包括 <code>fadeIn</code>，<code>inFromRight</code> 等。讲完了使用，就进入实战了。</p><h4 id="flutter-weather-实战"><a href="#flutter-weather-实战" class="headerlink" title="flutter_weather 实战"></a>flutter_weather 实战</h4><h5 id="导入插件"><a href="#导入插件" class="headerlink" title="导入插件"></a>导入插件</h5><p>在开始的时候，已经提到了整体功能的实现需求，所以这边需要导入的插件以及存放图片的文件夹如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">    </span><br><span class="line">  cupertino_icons: ^<span class="number">0.1</span><span class="number">.2</span></span><br><span class="line">  fluro: ^<span class="number">1.4</span><span class="number">.0</span></span><br><span class="line">  dio: ^<span class="number">2.1</span><span class="number">.0</span></span><br><span class="line">  shared_preferences: ^<span class="number">0.5</span><span class="number">.1</span>+<span class="number">2</span></span><br><span class="line">  sqflite: ^<span class="number">1.1</span><span class="number">.3</span></span><br><span class="line">  fluttertoast: ^<span class="number">3.0</span><span class="number">.3</span></span><br><span class="line">  rxdart: ^<span class="number">0.21</span><span class="number">.0</span></span><br><span class="line">  path_provider: <span class="number">0.5</span><span class="number">.0</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  flutter_test:</span><br><span class="line">    sdk: flutter</span><br><span class="line">    </span><br><span class="line">flutter:</span><br><span class="line">  uses-material-design: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">  assets:</span><br><span class="line">    - images/</span><br></pre></td></tr></table></figure><h5 id="顶层静态实例的实现"><a href="#顶层静态实例的实现" class="headerlink" title="顶层静态实例的实现"></a>顶层静态实例的实现</h5><p>有许多实例需要在顶层注册，然后在全局使用，包括但不限于 fluro 的 router，http，database 等等。在这个项目中，需要用到的就是这三个实例，会在全局调用，所以在开始前进行初始化，当然 http 和 database 在使用的时候创建也可以，完全看个人习惯，但是 fluro 的管理类必须在一开始就注册完成。首先需要定义一个 <code>Application</code> 类用来存放这些静态实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> HttpUtils http; <span class="comment">// 全局网络</span></span><br><span class="line">  <span class="keyword">static</span> Router router; <span class="comment">// 全局路由</span></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils db; <span class="comment">// 全局数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是对相应方法类的编写，其中 <code>HttpUtil</code> 和 <code>DatabaseUtils</code> 在前面有讲过，这边不重复讲，会讲下数据库如何建立。</p><h6 id="Fluro-路由管理类"><a href="#Fluro-路由管理类" class="headerlink" title="Fluro 路由管理类"></a>Fluro 路由管理类</h6><p>首先，需要知道，该项目的界面大概分如下的界面(当然可先只定义首页，剩下用到了再定义，该项目相对简单，所以先列出来)：省选择页，市选择页，区选择页，天气展示页，设置页。所以 fluro 的管理类可按如下定义：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看 `routers/routers.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 各个页面对应的路径</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> root = <span class="string">'/'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> weather = <span class="string">'/weather'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> provinces = <span class="string">'/provinces'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> cities = <span class="string">'/cities'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> districts = <span class="string">'/districts'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> settings = <span class="string">'/settings'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 该方法用于放到 `main` 方法中定义所有的路由，</span></span><br><span class="line">  <span class="comment">/// 对应的 handler 可放同一个文件，也可放另一个文件，看个人喜好</span></span><br><span class="line">  <span class="keyword">static</span> configureRouters(Router router) &#123;</span><br><span class="line">    router.notFoundHandler = notFoundHandler;</span><br><span class="line"></span><br><span class="line">    router.define(root, handler: rootHandler); <span class="comment">// 首页</span></span><br><span class="line"></span><br><span class="line">    router.define(weather, handler: weatherHandler); <span class="comment">// 天气展示页</span></span><br><span class="line"></span><br><span class="line">    router.define(provinces, handler: provincesHandler); <span class="comment">// 省列表页</span></span><br><span class="line"></span><br><span class="line">    router.define(cities, handler: citiesHandler); <span class="comment">// 省下市列表页</span></span><br><span class="line"></span><br><span class="line">    router.define(districts, handler: districtsHandler); <span class="comment">// 市下区列表页</span></span><br><span class="line"></span><br><span class="line">    router.define(settings, handler: settingsHandler); <span class="comment">// 设置页</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 生成天气显示页面路径，需要用到城市 id</span></span><br><span class="line">  <span class="keyword">static</span> generateWeatherRouterPath(<span class="built_in">String</span> cityId) =&gt; <span class="string">'$weather?city_id=$cityId'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 生成省下的市列表页相应路径 需要用到省 id 及省名</span></span><br><span class="line">  <span class="keyword">static</span> generateProvinceRouterPath(<span class="built_in">int</span> provinceId, <span class="built_in">String</span> name)</span><br><span class="line">                    =&gt; <span class="string">'$cities?province_id=$provinceId&amp;name=$name'</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/// 生成市下的区列表页相应路径，需用到市 id 及市名</span></span><br><span class="line">  <span class="keyword">static</span> generateCityRouterPath(<span class="built_in">int</span> provinceId, <span class="built_in">int</span> cityId, <span class="built_in">String</span> name) </span><br><span class="line">                    =&gt; <span class="string">'$districts?province_id=$provinceId&amp;city_id=$cityId&amp;name=$name'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 查看 `routers/handler.dart` 文件</span></span><br><span class="line">Handler notFoundHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  Logger(<span class="string">'RouterHandler:'</span>).log(<span class="string">'Not Found Router'</span>); <span class="comment">// 当找不到相应的路由时，打印信息处理</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler rootHandler = Handler(handlerFunc: (_, params) =&gt; SplashPage());</span><br><span class="line"></span><br><span class="line">Handler weatherHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first; <span class="comment">// 获取相应的参数</span></span><br><span class="line">  <span class="keyword">return</span> WeatherPage(city: cityId);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler provincesHandler = Handler(handlerFunc: (_, params) =&gt; ProvinceListPage());</span><br><span class="line"></span><br><span class="line">Handler citiesHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> provinceId = params[<span class="string">'province_id'</span>]?.first;</span><br><span class="line">  <span class="built_in">String</span> name = params[<span class="string">'name'</span>]?.first;</span><br><span class="line">  <span class="keyword">return</span> CityListPage(provinceId: provinceId, </span><br><span class="line">                      name: FluroConvertUtils.fluroCnParamsDecode(name));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler districtsHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> provinceId = params[<span class="string">'province_id'</span>]?.first;</span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first;</span><br><span class="line">  <span class="built_in">String</span> name = params[<span class="string">'name'</span>]?.first;</span><br><span class="line">  <span class="keyword">return</span> DistrictListPage(provinceId: provinceId, cityId: cityId, </span><br><span class="line">                          name: FluroConvertUtils.fluroCnParamsDecode(name));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Handler settingsHandler = Handler(handlerFunc: (_, params) =&gt; SettingsPage());</span><br></pre></td></tr></table></figure><p>那么界面的路由到这就编写好了，但是前面提到了 fluro 目前不支持中文的传递，所以在传递中文时候，需要先进行转码，这边提供一个自己写的方法，小伙伴有更好的方法也可以直接在项目提 issue</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `utils/fluro_convert_util.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FluroConvertUtils</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// fluro 传递中文参数前，先转换，fluro 不支持中文传递</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> fluroCnParamsEncode(<span class="built_in">String</span> originalCn) &#123;</span><br><span class="line">    <span class="built_in">StringBuffer</span> sb = <span class="built_in">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">var</span> encoded = Utf8Encoder().convert(originalCn); <span class="comment">// utf8 编码，会生成一个 int 列表</span></span><br><span class="line">    encoded.forEach((val) =&gt; sb.write(<span class="string">'$val,'</span>)); <span class="comment">// 将 int 列表重新转换成字符串</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString().substring(<span class="number">0</span>, sb.length - <span class="number">1</span>).toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// fluro 传递后取出参数，解析</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> fluroCnParamsDecode(<span class="built_in">String</span> encodedCn) &#123;</span><br><span class="line">    <span class="keyword">var</span> decoded = encodedCn.split(<span class="string">'['</span>).last.split(<span class="string">']'</span>).first.split(<span class="string">','</span>); <span class="comment">// 对参数字符串分割</span></span><br><span class="line">    <span class="keyword">var</span> list = &lt;<span class="built_in">int</span>&gt;[];</span><br><span class="line">    decoded.forEach((s) =&gt; list.add(<span class="built_in">int</span>.parse(s.trim()))); <span class="comment">// 转回 int 列表</span></span><br><span class="line">    <span class="keyword">return</span> Utf8Decoder().convert(list); <span class="comment">// 解码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Database-管理类编写"><a href="#Database-管理类编写" class="headerlink" title="Database 管理类编写"></a>Database 管理类编写</h6><p>因为数据库的开启是一个很耗资源的过程，所以这边通过单例并提取到顶层。在该项目中，数据库主要用于存储城市信息，因为城市之间的关联比较复杂，如果通过 <code>shared_preferences</code> 或者文件存储会很复杂。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `utils/db_utils.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _dbName = <span class="string">'weather.db'</span>; <span class="comment">// 数据表名</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableProvinces = <span class="string">'provinces'</span>; <span class="comment">// 省表</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableCities = <span class="string">'cities'</span>; <span class="comment">// 市表</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableDistricts = <span class="string">'districts'</span>; <span class="comment">// 区表</span></span><br><span class="line">  <span class="keyword">static</span> Database _db;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils <span class="keyword">get</span> instance =&gt; DatabaseUtils();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将数据库的初始化放到私有构造中，值允许通过单例访问</span></span><br><span class="line">  DatabaseUtils._internal() &#123;</span><br><span class="line">    getDatabasesPath().then((path) <span class="keyword">async</span> &#123;</span><br><span class="line">      _db = <span class="keyword">await</span> openDatabase(join(path, _dbName), version: <span class="number">1</span>, onCreate: (db, version) &#123;</span><br><span class="line">        db.execute(<span class="string">'create table $_tableProvinces('</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'province_id integer not null unique,'</span> <span class="comment">// 省 id，id 唯一</span></span><br><span class="line">            <span class="string">'province_name text not null'</span> <span class="comment">// 省名</span></span><br><span class="line">            <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">        db.execute(<span class="string">'create table $_tableCities('</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'city_id integer not null unique,'</span> <span class="comment">// 市 id，id 唯一</span></span><br><span class="line">            <span class="string">'city_name text not null,'</span> <span class="comment">// 市名</span></span><br><span class="line">            <span class="string">'province_id integer not null,'</span> <span class="comment">// 对应的省的 id，作为外键同省表关联</span></span><br><span class="line">            <span class="string">'foreign key(province_id) references $_tableProvinces(province_id)'</span></span><br><span class="line">            <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">        db.execute(<span class="string">'create table $_tableDistricts('</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'district_id integer not null unique,'</span> <span class="comment">// 区 id</span></span><br><span class="line">            <span class="string">'district_name text not null,'</span> <span class="comment">// 区名</span></span><br><span class="line">            <span class="string">'weather_id text not null unique,'</span> <span class="comment">// 查询天气用的 id，例如 CN13579826，id 唯一</span></span><br><span class="line">            <span class="string">'city_id integer not null,'</span> <span class="comment">// 对应市的 id，作为外键同市表关联</span></span><br><span class="line">            <span class="string">'foreign key(city_id) references $_tableCities(city_id)'</span></span><br><span class="line">            <span class="string">')'</span>);</span><br><span class="line">      &#125;, onUpgrade: (db, oldVersion, newVersion) &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 构建单例</span></span><br><span class="line">  <span class="keyword">factory</span> DatabaseUtils() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _instance = DatabaseUtils._internal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 查询所有的省，`ProvinceModel` 为省市接口返回数据生成的 model 类</span></span><br><span class="line">  <span class="comment">/// 查看 `model/province_model.dart` 文件</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; queryAllProvinces() <span class="keyword">async</span> =&gt;</span><br><span class="line">      ProvinceModel.fromProvinceTableList(<span class="keyword">await</span> _db.rawQuery(<span class="string">'select province_id, province_name from $_tableProvinces'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 查询某个省内的所有市</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; queryAllCitiesInProvince(<span class="built_in">String</span> proid) <span class="keyword">async</span> =&gt; ProvinceModel.fromCityTableList(<span class="keyword">await</span> _db.rawQuery(</span><br><span class="line">        <span class="string">'select city_id, city_name from $_tableCities where province_id = ?'</span>,</span><br><span class="line">        [proid],</span><br><span class="line">      ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 查询某个市内的所有区，`DistrictModel` 为区接口返回数据生成的 model 类</span></span><br><span class="line">  <span class="comment">/// 查看 `model/district_model.dart` 文件</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; queryAllDistrictsInCity(<span class="built_in">String</span> cityid) <span class="keyword">async</span> =&gt; DistrictModel.fromDistrictTableList(<span class="keyword">await</span> _db.rawQuery(</span><br><span class="line">        <span class="string">'select district_id, district_name, weather_id from $_tableDistricts where city_id = ?'</span>,</span><br><span class="line">        [cityid],</span><br><span class="line">      ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将所有的省插入数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; insertProvinces(<span class="built_in">List</span>&lt;ProvinceModel&gt; provinces) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch = _db.batch();</span><br><span class="line">    provinces.forEach((p) =&gt; batch.rawInsert(</span><br><span class="line">          <span class="string">'insert or ignore into $_tableProvinces (province_id, province_name) values (?, ?)'</span>,</span><br><span class="line">          [p.id, p.name],</span><br><span class="line">        ));</span><br><span class="line">    batch.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将省对应下的所有市插入数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; insertCitiesInProvince(<span class="built_in">List</span>&lt;ProvinceModel&gt; cities, <span class="built_in">String</span> proid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch = _db.batch();</span><br><span class="line">    cities.forEach((c) =&gt; batch.rawInsert(</span><br><span class="line">          <span class="string">'insert or ignore into $_tableCities (city_id, city_name, province_id) values (?, ?, ?)'</span>,</span><br><span class="line">          [c.id, c.name, proid],</span><br><span class="line">        ));</span><br><span class="line">    batch.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将市下的所有区插入数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; insertDistrictsInCity(<span class="built_in">List</span>&lt;DistrictModel&gt; districts, <span class="built_in">String</span> cityid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> batch = _db.batch();</span><br><span class="line">    districts.forEach((d) =&gt; batch.rawInsert(</span><br><span class="line">          <span class="string">'insert or ignore into $_tableDistricts (district_id, district_name, weather_id, city_id) values (?, ?, ?, ?)'</span>,</span><br><span class="line">          [d.id, d.name, d.weatherId, cityid],</span><br><span class="line">        ));</span><br><span class="line">    batch.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义完全局使用的方法，就可以在 <code>main</code> 函数中进行相关的初始化了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `main.dart` 文件</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 初始化 fluro router</span></span><br><span class="line">  Router router = Router();</span><br><span class="line">  Routers.configureRouters(router);</span><br><span class="line">  Application.router = router;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 http</span></span><br><span class="line">  Application.http = HttpUtils(baseUrl: WeatherApi.WEATHER_HOST);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 db</span></span><br><span class="line">  Application.db = DatabaseUtils.instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 强制竖屏，因为设置竖屏为 `Future` 方法，防止设置无效可等返回值后再启动 App</span></span><br><span class="line">  SystemChrome.setPreferredOrientations([DeviceOrientation.portraitDown, DeviceOrientation.portraitUp]).then((_) &#123;</span><br><span class="line">    runApp(WeatherApp()); <span class="comment">// App 类可放在同个文件，个人习惯单独一个文件存放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">      SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">            title: <span class="string">'Weather App'</span>,</span><br><span class="line">            onGenerateRoute: Application.router.generator, <span class="comment">// 将 fluro 的路由进行注册</span></span><br><span class="line">            debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">          );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完毕，接着就可以进行页面的编写了。</p><h5 id="首页编写"><a href="#首页编写" class="headerlink" title="首页编写"></a>首页编写</h5><p>首页主要是为了对 App 的一个大概展示，或者是一些广告的展示，同时也给一些数据初始化提供时间，当用户进入后有更好的体验效果。我们在这里就做一个图标的展示(图标可自行到项目中 <code>images</code> 文件夹查找)，延时 5s 后跳转下个页面。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `splash_page.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplashPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">/// 因为已经引入了 rxdart，这里通过 rxdart.timer 进行倒计时</span></span><br><span class="line">    <span class="comment">/// 当然也可以使用 Futuer.delayed 进行倒计时</span></span><br><span class="line">    <span class="comment">/// 5s 计时，如果已经选择城市，跳转天气界面，否则进入城市选择</span></span><br><span class="line">    Observable.timer(<span class="number">0</span>, <span class="built_in">Duration</span>(milliseconds: <span class="number">5000</span>)).listen((_) &#123;</span><br><span class="line">      PreferenceUtils.instance.getString(PreferencesKey.WEATHER_CITY_ID)</span><br><span class="line">          .then((city) &#123;</span><br><span class="line">        <span class="comment">// 如果当前还未选择城市，则进入城市选择页，否则跳转天气详情页</span></span><br><span class="line">        <span class="comment">// replace: true 即为 Navigator.pushReplacement 方法</span></span><br><span class="line">        Application.router.navigateTo(context, city.isEmpty </span><br><span class="line">                                      ? Routers.provinces </span><br><span class="line">                                      : Routers.generateWeatherRouterPath(city), </span><br><span class="line">                                                                        replace: <span class="keyword">true</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        color: Colors.white,</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">// 展示图标</span></span><br><span class="line">            Image.asset(Resource.pngSplash, width: <span class="number">200.0</span>, height: <span class="number">200.0</span>),</span><br><span class="line">            <span class="comment">// 展示文字提醒，用 SizedBox 设置区域大小</span></span><br><span class="line">            SizedBox(</span><br><span class="line">                width: MediaQuery.of(context).size.width * <span class="number">0.7</span>,</span><br><span class="line">                child: Text(</span><br><span class="line">                  <span class="string">'所有天气数据均为模拟数据，仅用作学习目的使用，请勿当作真实的天气预报软件来使用'</span>,</span><br><span class="line">                  textAlign: TextAlign.center,</span><br><span class="line">                  softWrap: <span class="keyword">true</span>,</span><br><span class="line">                  style: TextStyle(color: Colors.red[<span class="number">700</span>], fontSize: <span class="number">16.0</span>),</span><br><span class="line">                ))</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="城市选择页面"><a href="#城市选择页面" class="headerlink" title="城市选择页面"></a>城市选择页面</h5><p>当首次进入的时候，用户肯定没有选择城市，所以先编写城市选择列表页面，因为整体的项目使用 BLoC 分离业务逻辑和页面，所以先编写数据管理类吧，把数据请求和改变的业务逻辑放到这块，BLoC 的实现在前面讲过了，这边就不重复提了。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `provinces_bloc.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProvincesBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _logger = Logger(<span class="string">'ProvincesBloc'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; _provinces = []; <span class="comment">// 全国省</span></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; _cities = []; <span class="comment">// 省内市</span></span><br><span class="line">  <span class="built_in">List</span>&lt;DistrictModel&gt; _districts = []; <span class="comment">// 市内区</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; <span class="keyword">get</span> provinces =&gt; _provinces;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;ProvinceModel&gt; <span class="keyword">get</span> cities =&gt; _cities;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;DistrictModel&gt; <span class="keyword">get</span> districts =&gt; _districts;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; _provinceController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; _citiesController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; _districtController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// stream，用于 StreamBuilder 的 stream 参数</span></span><br><span class="line">  Observable&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; <span class="keyword">get</span> provinceStream </span><br><span class="line">                                             =&gt; Observable(_provinceController.stream);</span><br><span class="line"></span><br><span class="line">  Observable&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; <span class="keyword">get</span> cityStream =&gt; Observable(_citiesController.stream);</span><br><span class="line"></span><br><span class="line">  Observable&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; <span class="keyword">get</span> districtStream</span><br><span class="line">                                            =&gt; Observable(_districtController.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 通知刷新省份列表</span></span><br><span class="line">  changeProvinces(<span class="built_in">List</span>&lt;ProvinceModel&gt; provinces) &#123;</span><br><span class="line">    _provinces.clear();</span><br><span class="line">    _provinces.addAll(provinces);</span><br><span class="line">    _provinceController.add(_provinces);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 通知刷新城市列表</span></span><br><span class="line">  changeCities(<span class="built_in">List</span>&lt;ProvinceModel&gt; cities) &#123;</span><br><span class="line">    _cities.clear();</span><br><span class="line">    _cities.addAll(cities);</span><br><span class="line">    _citiesController.add(_cities);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 通知刷新区列表</span></span><br><span class="line">  changeDistricts(<span class="built_in">List</span>&lt;DistrictModel&gt; districts) &#123;</span><br><span class="line">    _districts.clear();</span><br><span class="line">    _districts.addAll(districts);</span><br><span class="line">    _districtController.add(_districts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求全国省</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; requestAllProvinces() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http.getRequest(WeatherApi.WEATHER_PROVINCE, </span><br><span class="line">                                           error: (msg) =&gt; _logger.log(msg, <span class="string">'province'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? [] : ProvinceModel.fromMapList(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求省内城市</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; requestAllCitiesInProvince(<span class="built_in">String</span> proid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest(<span class="string">'<span class="subst">$&#123;WeatherApi.WEATHER_PROVINCE&#125;</span>/$proid'</span>, </span><br><span class="line">                                           error: (msg) =&gt; _logger.log(msg, <span class="string">'city'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? [] : ProvinceModel.fromMapList(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求市内的区</span></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;DistrictModel&gt;&gt; requestAllDistricts(<span class="built_in">String</span> proid, <span class="built_in">String</span> cityid) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest(<span class="string">'<span class="subst">$&#123;WeatherApi.WEATHER_PROVINCE&#125;</span>/$proid/$cityid'</span>, </span><br><span class="line">                                           error: (msg) =&gt; _logger.log(msg, <span class="string">'district'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? [] : DistrictModel.fromMapList(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123; <span class="comment">// 及时销毁</span></span><br><span class="line">    _provinceController?.close();</span><br><span class="line">    _citiesController?.close();</span><br><span class="line">    _districtController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完 BLoC 需要对其进行注册，因为城市选择相对还是比较频繁的，所以可以放最顶层进行注册</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>  BlocProvider(</span><br><span class="line">      bloc: ProvincesBloc(), <span class="comment">// 城市切换 BLoC</span></span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'Weather App'</span>,</span><br><span class="line">        onGenerateRoute: Application.router.generator,</span><br><span class="line">        debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>城市选择就是一个列表，直接通过 <code>ListView</code> 生成即可，前面讲 <code>ListView</code> 的时候提到，尽可能固定 item 的高度，会提高绘制效率</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `provinces_page.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProvinceListPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _bloc = BlocProvider.of&lt;ProvincesBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入的时候先使用数据库的数据填充界面</span></span><br><span class="line">    Application.db.queryAllProvinces().then((ps) =&gt; _bloc.changeProvinces(ps));</span><br><span class="line">    <span class="comment">// 网络数据更新列表并刷新数据库数据</span></span><br><span class="line">    _bloc.requestAllProvinces().then((provinces) &#123;</span><br><span class="line">      _bloc.changeProvinces(provinces);</span><br><span class="line">      Application.db.insertProvinces(provinces);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'请选择省份'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        color: Colors.black12,</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        <span class="comment">// 省列表选择</span></span><br><span class="line">        child: StreamBuilder(</span><br><span class="line">          stream: _bloc.provinceStream,</span><br><span class="line">          initialData: _bloc.provinces,</span><br><span class="line">          builder: (_, AsyncSnapshot&lt;<span class="built_in">List</span>&lt;ProvinceModel&gt;&gt; snapshot) </span><br><span class="line">            =&gt; !snapshot.hasData || snapshot.data.isEmpty</span><br><span class="line">            <span class="comment">// 如果当前的数据未加载则给一个加载，否则显示列表加载</span></span><br><span class="line">              ? CupertinoActivityIndicator(radius: <span class="number">12.0</span>) </span><br><span class="line">              : ListView.builder(</span><br><span class="line">              physics: BouncingScrollPhysics(),</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">              itemBuilder: (_, index) =&gt; InkWell(</span><br><span class="line">                child: Container(</span><br><span class="line">                  alignment: Alignment.centerLeft,</span><br><span class="line">                  child: Text(snapshot.data[index].name, style: TextStyle(fontSize: <span class="number">18.0</span>, color: Colors.black)),</span><br><span class="line">                ),</span><br><span class="line">                onTap: () =&gt; Application.router.navigateTo(</span><br><span class="line">                    context,</span><br><span class="line">                    <span class="comment">// 跳转下层省内城市选择，需要将当前的省 id 以及省名传入</span></span><br><span class="line">                    Routers.</span><br><span class="line">                    generateProvinceRouterPath(snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)),</span><br><span class="line">                    transition: TransitionType.fadeIn),</span><br><span class="line">              ),</span><br><span class="line">              itemExtent: <span class="number">50.0</span>,</span><br><span class="line">              itemCount: snapshot.data.length),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于市和区的列表选择也类似，除了最后的点击会有些区别页面的布局几乎一致，这边只提下点击事件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `cities_page.dart` 文件</span></span><br><span class="line">Application.router.navigateTo(</span><br><span class="line">                                    context,</span><br><span class="line">                                    <span class="comment">// 跳转下层省内城市选择</span></span><br><span class="line">                                    Routers.generateProvinceRouterPath(</span><br><span class="line">                                        snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)),</span><br><span class="line">                                    transition: TransitionType.fadeIn),</span><br><span class="line">                              )</span><br><span class="line"><span class="comment">// 设置为当前区，并清理路由 stack，并将天气界面设置到最上层</span></span><br><span class="line">onTap: () &#123;</span><br><span class="line"> PreferenceUtils.instance</span><br><span class="line">     .saveString(PreferencesKey.WEATHER_CITY_ID, snapshot.data[index].weatherId);</span><br><span class="line">    </span><br><span class="line">                                  Application.router.navigateTo(context, Routers.generateWeatherRouterPath(snapshot.data[index].weatherId),</span><br><span class="line">                                      transition: TransitionType.inFromRight, clearStack: <span class="keyword">true</span>);</span><br><span class="line">                                &#125;)</span><br></pre></td></tr></table></figure><h5 id="天气详情页面"><a href="#天气详情页面" class="headerlink" title="天气详情页面"></a>天气详情页面</h5><p>天气详情页面相对部件会多点，为了看着舒服一点，这里拆成多个部分来编写，在这之前还是先编写数据的管理类，因为天气详情接口返回的数据嵌套层次比较多，关系比较复杂，不适合用 <code>database</code> 来做持久化，所以这里采用文件持久化方式。当然有些小伙伴会问干嘛不使用 <code>shared_preferences</code> 来存储，理论上应该没有太大的问题，但是个人建议相对复杂的数据使用文件存储会相对比较好点，一定要说个为什么，我也说不出来。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `weather_bloc.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _logger = Logger(<span class="string">'WeatherBloc'</span>);</span><br><span class="line"></span><br><span class="line">  WeatherModel _weather; <span class="comment">// 天气情况</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> _background = WeatherApi.DEFAULT_BACKGROUND; <span class="comment">// 背景</span></span><br><span class="line"></span><br><span class="line">  WeatherModel <span class="keyword">get</span> weather =&gt; _weather;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> background =&gt; _background;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;WeatherModel&gt; _weatherController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">String</span>&gt; _backgroundController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  Observable&lt;WeatherModel&gt; <span class="keyword">get</span> weatherStream =&gt; Observable(_weatherController.stream);</span><br><span class="line"></span><br><span class="line">  Observable&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> backgroundStream =&gt; Observable(_backgroundController.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 更新天气情况</span></span><br><span class="line">  updateWeather(WeatherModel weather) &#123;</span><br><span class="line">    _weather = weather;</span><br><span class="line">    _weatherController.add(_weather);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 更新天气背景</span></span><br><span class="line">  updateBackground(<span class="built_in">String</span> background) &#123;</span><br><span class="line">    _background = background;</span><br><span class="line">    _backgroundController.add(_background);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求天气情况</span></span><br><span class="line">  Future&lt;WeatherModel&gt; requestWeather(<span class="built_in">String</span> id) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest(WeatherApi.WEATHER_STATUS, </span><br><span class="line">                    params: &#123;<span class="string">'cityid'</span>: id, <span class="string">'key'</span>: WeatherApi.WEATHER_KEY&#125;, </span><br><span class="line">                    error: (msg) =&gt; _logger.log(msg, <span class="string">'weather'</span>));</span><br><span class="line">    <span class="comment">// 请求数据成功则写入到文件中</span></span><br><span class="line">    <span class="keyword">if</span> (resp != <span class="keyword">null</span> &amp;&amp; resp.data != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _writeIntoFile(json.encode(resp.data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WeatherModel.fromMap(resp.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; requestBackground() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="keyword">await</span> Application.http</span><br><span class="line">        .getRequest&lt;<span class="built_in">String</span>&gt;(WeatherApi.WEATHER_BACKGROUND, </span><br><span class="line">                            error: (msg) =&gt; _logger.log(msg, <span class="string">'background'</span>));</span><br><span class="line">    <span class="keyword">return</span> resp == <span class="keyword">null</span> || resp.data == <span class="keyword">null</span> ? WeatherApi.DEFAULT_BACKGROUND : resp.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取存储文件路径</span></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; _getPath() <span class="keyword">async</span> =&gt; </span><br><span class="line">      <span class="string">'<span class="subst">$&#123;(await getApplicationDocumentsDirectory()).path&#125;</span>/weather.txt'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入到文件</span></span><br><span class="line">  _writeIntoFile(<span class="built_in">String</span> contents) <span class="keyword">async</span> &#123;</span><br><span class="line">    File file = File(<span class="keyword">await</span> _getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> file.exists()) file.deleteSync();</span><br><span class="line">    file.createSync();</span><br><span class="line">    file.writeAsString(contents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件读取存储信息，如果不存在文件则返回空字符串 ''，不推荐返回 null</span></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; readWeatherFromFile() <span class="keyword">async</span> &#123;</span><br><span class="line">    File file = File(<span class="keyword">await</span> _getPath());</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">await</span> file.exists()) ? file.readAsString() : <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _weatherController?.close();</span><br><span class="line">    _backgroundController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天气详情的刷新只有当个页面，所以 BLoC 的注册值需要在路由上注册即可，在 fluro 对应 handler 中加入注册</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Handler weatherHandler = Handler(handlerFunc: (_, params) &#123;</span><br><span class="line">  <span class="built_in">String</span> cityId = params[<span class="string">'city_id'</span>]?.first; <span class="comment">// 这个 id 可以通过 BLoC 获取也可以</span></span><br><span class="line">  <span class="keyword">return</span> BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么接下来就可以编写界面了，先实现最外层的背景图变化</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `weather_page.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> city;</span><br><span class="line"></span><br><span class="line">  WeatherPage(&#123;Key key, <span class="keyword">this</span>.city&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _bloc = BlocProvider.of&lt;WeatherBloc&gt;(context);</span><br><span class="line">    <span class="comment">// 请求背景并更新</span></span><br><span class="line">    _bloc.requestBackground().then((b) =&gt; _bloc.updateBackground(b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先读取本地文件缓存进行页面填充</span></span><br><span class="line">    _bloc.readWeatherFromFile().then((s) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.isNotEmpty) &#123;</span><br><span class="line">        _bloc.updateWeather(WeatherModel.fromMap(json.decode(s)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再请求网络更新数据</span></span><br><span class="line">    _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">          stream: _bloc.backgroundStream,</span><br><span class="line">          initialData: _bloc.background,</span><br><span class="line">          builder: (_, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; themeSnapshot) =&gt; Container(</span><br><span class="line">                padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">20.0</span>),</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                decoration: BoxDecoration(</span><br><span class="line">                  color: Colors.black12,</span><br><span class="line">                  image: DecorationImage(</span><br><span class="line">                      image: NetworkImage(themeSnapshot.data), fit: BoxFit.cover),</span><br><span class="line">                ),</span><br><span class="line">                child: <span class="comment">// 具体内部布局通过拆分小部件实现</span></span><br><span class="line">              )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面最顶部是显示两个按钮，一个跳转城市选择，一个跳转设置页面，显示当前的城市</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FollowedHeader</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot; <span class="comment">// snapshot 通过上层传入</span></span><br><span class="line"></span><br><span class="line">  FollowedHeader(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// 城市选择页面跳转按钮</span></span><br><span class="line">        IconButton(</span><br><span class="line">            icon: Icon(Icons.home, color: Colors.white, size: <span class="number">32.0</span>),</span><br><span class="line">            onPressed: () =&gt; Application.router.</span><br><span class="line">            navigateTo(context, Routers.provinces, </span><br><span class="line">                       transition: TransitionType.inFromLeft)),</span><br><span class="line">        <span class="comment">// 当前城市</span></span><br><span class="line">        Text(<span class="string">'<span class="subst">$&#123;snapshot.data.heWeather[<span class="number">0</span>].basic.location&#125;</span>'</span>, </span><br><span class="line">             style: TextStyle(fontSize: <span class="number">28.0</span>, color: Colors.white)),</span><br><span class="line">        <span class="comment">// 设置页面跳转按钮</span></span><br><span class="line">        IconButton(</span><br><span class="line">            icon: Icon(Icons.settings, color: Colors.white, size: <span class="number">32.0</span>),</span><br><span class="line">            onPressed: () =&gt; Application.router</span><br><span class="line">            .navigateTo(context, Routers.settings, </span><br><span class="line">                        transition: TransitionType.inFromRight))</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是当前的天气详情部分</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrentWeatherState</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  CurrentWeatherState(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _now = snapshot.data.heWeather[<span class="number">0</span>].now;</span><br><span class="line">    <span class="keyword">var</span> _update = snapshot.data.heWeather[<span class="number">0</span>].update.loc.split(<span class="string">' '</span>).last;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// 当前的温度</span></span><br><span class="line">        Text(<span class="string">'<span class="subst">$&#123;_now.tmp&#125;</span>℃'</span>, style: TextStyle(fontSize: <span class="number">50.0</span>, color: Colors.white)),</span><br><span class="line">        <span class="comment">// 当前的天气状况</span></span><br><span class="line">        Text(<span class="string">'<span class="subst">$&#123;_now.condTxt&#125;</span>'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, color: Colors.white)),</span><br><span class="line">        Row( <span class="comment">// 刷新的时间</span></span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Icon(Icons.refresh, size: <span class="number">16.0</span>, color: Colors.white),</span><br><span class="line">            Padding(padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">4.0</span>)),</span><br><span class="line">            Text(_update, style: TextStyle(fontSize: <span class="number">12.0</span>, color: Colors.white))</span><br><span class="line">          ],</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一个天气预报的列表块，以为是一个列表，当然可以通过 <code>Cloumn</code> 来实现，但是前面有提到过一个列表「粘合剂」—- <code>CustomScrollView</code>，所以这里的整体连接最后会通过 <code>CustomScrollView</code> 来实现，那么你可以放心在最上层容器的 <code>child</code> 属性加上 <code>CustomScrollView</code> 了。接着来实现这块预报模块</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherForecast</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  WeatherForecast(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _forecastList = snapshot.data.heWeather[<span class="number">0</span>].dailyForecasts; <span class="comment">// 获取天气预报</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SliverFixedExtentList(</span><br><span class="line">        delegate: SliverChildBuilderDelegate(</span><br><span class="line">          (_, index) =&gt; Container(</span><br><span class="line">              color: Colors.black54, <span class="comment">// 外层设置背景色，防止被最外层图片背景遮挡文字</span></span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">              alignment: Alignment.centerLeft,</span><br><span class="line">              child: index == <span class="number">0</span> <span class="comment">// 当第一个 item 情况，显示 ‘预报’</span></span><br><span class="line">                  ? Text(<span class="string">'预报'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, color: Colors.white))</span><br><span class="line">                  : Row(</span><br><span class="line">                      mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">                      crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">                      children: &lt;Widget&gt;[</span><br><span class="line">                        Text(_forecastList[index - <span class="number">1</span>].date,  <span class="comment">// 预报的日期</span></span><br><span class="line">                             style: TextStyle(fontSize: <span class="number">16.0</span>, color: Colors.white)),</span><br><span class="line">                        Expanded( <span class="comment">// 天气情况，这边通过 expanded 进行占位，并居中显示</span></span><br><span class="line">                            child: Center(child: Text(_forecastList[index - <span class="number">1</span>].cond.txtD, </span><br><span class="line">                                                      style: TextStyle(fontSize: <span class="number">16.0</span>,                                                                  color: Colors.white))),</span><br><span class="line">                            flex: <span class="number">2</span>),</span><br><span class="line">                        Expanded(</span><br><span class="line">                            child: Row( <span class="comment">// 最高温度，最低温度</span></span><br><span class="line">                              mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">                              children: &lt;Widget&gt;[</span><br><span class="line">                                Text(_forecastList[index - <span class="number">1</span>].tmp.max, </span><br><span class="line">                                     style: TextStyle(fontSize: <span class="number">16.0</span>, </span><br><span class="line">                                                      color: Colors.white)),</span><br><span class="line">                                Text(_forecastList[index - <span class="number">1</span>].tmp.min, </span><br><span class="line">                                     style: TextStyle(fontSize: <span class="number">16.0</span>, </span><br><span class="line">                                                      color: Colors.white)),</span><br><span class="line">                              ],</span><br><span class="line">                            ),</span><br><span class="line">                            flex: <span class="number">1</span>)</span><br><span class="line">                      ],</span><br><span class="line">                    )),</span><br><span class="line">          childCount: _forecastList.length + <span class="number">1</span>, <span class="comment">// 这个数量需要 +1，因为有个标题需要一个数量</span></span><br><span class="line">        ),</span><br><span class="line">        itemExtent: <span class="number">50.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是空气质量报告，一个标题，下面由两个布局进行平分</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirQuality</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  AirQuality(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> quality = snapshot.data.heWeather[<span class="number">0</span>].aqi.city;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">        color: Colors.black54,</span><br><span class="line">        alignment: Alignment.centerLeft,</span><br><span class="line">        child: Column(</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">// 标题</span></span><br><span class="line">            Padding(padding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">20.0</span>), child: </span><br><span class="line">                    Text(<span class="string">'空气质量'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, </span><br><span class="line">                                                  color: Colors.white))),</span><br><span class="line">            Row(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 通过 expanded 进行平分横向距离</span></span><br><span class="line">                Expanded(</span><br><span class="line">                    child: Center(</span><br><span class="line">                  <span class="comment">// 内部居中显示</span></span><br><span class="line">                  child: Column(</span><br><span class="line">                    children: &lt;Widget&gt;[</span><br><span class="line">                      Text(<span class="string">'<span class="subst">$&#123;quality.aqi&#125;</span>'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">40.0</span>, color: Colors.white)),</span><br><span class="line">                      Text(<span class="string">'AQI 指数'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.white)),</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                )),</span><br><span class="line">                Expanded(</span><br><span class="line">                    child: Center(</span><br><span class="line">                  child: Column(</span><br><span class="line">                    children: &lt;Widget&gt;[</span><br><span class="line">                      Text(<span class="string">'<span class="subst">$&#123;quality.pm25&#125;</span>'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">40.0</span>, color: Colors.white)),</span><br><span class="line">                      Text(<span class="string">'PM2.5 指数'</span>, style: </span><br><span class="line">                           TextStyle(fontSize: <span class="number">20.0</span>, color: Colors.white)),</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                )),</span><br><span class="line">              ],</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是生活质量模块，看着也是个列表，但是后台返回的不是列表，而是根据不同字段获取不同质量指数，因为布局类似，所以可以对其进行封装再整体调用</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeSuggestions</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AsyncSnapshot&lt;WeatherModel&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  LifeSuggestions(&#123;Key key, <span class="keyword">this</span>.snapshot&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生活指数封装</span></span><br><span class="line">  Widget _suggestionWidget(<span class="built_in">String</span> content) =&gt;</span><br><span class="line">      Padding(padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>), child: </span><br><span class="line">              Text(content, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _suggestion = snapshot.data.heWeather[<span class="number">0</span>].suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">      color: Colors.black54,</span><br><span class="line">      alignment: Alignment.centerLeft,</span><br><span class="line">      child: Column(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">'生活建议'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>, color: Colors.white)),</span><br><span class="line">          _suggestionWidget(<span class="string">'舒适度：<span class="subst">$&#123;_suggestion.comf.brf&#125;</span>\n<span class="subst">$&#123;_suggestion.comf.txt&#125;</span>'</span>),</span><br><span class="line">          _suggestionWidget(<span class="string">'洗车指数：<span class="subst">$&#123;_suggestion.cw.brf&#125;</span>\n<span class="subst">$&#123;_suggestion.cw.txt&#125;</span>'</span>),</span><br><span class="line">          _suggestionWidget(<span class="string">'运动指数：</span></span><br><span class="line"><span class="string">                                <span class="subst">$&#123;_suggestion.sport.brf&#125;</span>\n<span class="subst">$&#123;_suggestion.sport.txt&#125;</span>'</span>),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的分模块都已经编写完成，剩下就是通过粘合剂进行组装了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: StreamBuilder(</span><br><span class="line">                    initialData: _bloc.weather,</span><br><span class="line">                    stream: _bloc.weatherStream,</span><br><span class="line">                    builder: (_, AsyncSnapshot&lt;WeatherModel&gt; snapshot) =&gt; !snapshot.hasData</span><br><span class="line">                        ? CupertinoActivityIndicator(radius: <span class="number">12.0</span>)</span><br><span class="line">                        : SafeArea(</span><br><span class="line">                            child: RefreshIndicator(</span><br><span class="line">                                child: CustomScrollView(</span><br><span class="line">                                  physics: BouncingScrollPhysics(),</span><br><span class="line">                                  slivers: &lt;Widget&gt;[</span><br><span class="line">                                    SliverToBoxAdapter(child: FollowedHeader(snapshot: snapshot)),</span><br><span class="line">                                    <span class="comment">// 实时天气</span></span><br><span class="line">                                    SliverPadding(</span><br><span class="line">                                      padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">30.0</span>),</span><br><span class="line">                                      sliver: SliverToBoxAdapter(</span><br><span class="line">                                        child: CurrentWeatherState(snapshot: snapshot, city: city),</span><br><span class="line">                                      ),</span><br><span class="line">                                    ),</span><br><span class="line">                                    <span class="comment">// 天气预报</span></span><br><span class="line">                                    WeatherForecast(snapshot: snapshot),</span><br><span class="line">                                    <span class="comment">// 空气质量</span></span><br><span class="line">                                    SliverPadding(</span><br><span class="line">                                      padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">30.0</span>),</span><br><span class="line">                                      sliver: SliverToBoxAdapter(child: AirQuality(snapshot: snapshot)),</span><br><span class="line">                                    ),</span><br><span class="line">                                    <span class="comment">// 生活建议</span></span><br><span class="line">                                    SliverToBoxAdapter(child: LifeSuggestions(snapshot: snapshot))</span><br><span class="line">                                  ],</span><br><span class="line">                                ),</span><br><span class="line">                                onRefresh: () <span class="keyword">async</span> &#123;</span><br><span class="line">                                  _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w));</span><br><span class="line">                                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                &#125;),</span><br><span class="line">                          )),</span><br></pre></td></tr></table></figure><p>最后就剩下设置页的全局主题切换了</p><h5 id="设置页全局主题切换"><a href="#设置页全局主题切换" class="headerlink" title="设置页全局主题切换"></a>设置页全局主题切换</h5><p>既然提到了数据的切换，那肯定就涉及 BLoC 毫无疑问了，还是照常编写管理类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查看 `setting_bloc.dart` 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 所有主题色列表</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> themeColors = [Colors.blue, Colors.red, Colors.green, </span><br><span class="line">                              Colors.deepOrange, Colors.pink, Colors.purple];</span><br><span class="line"></span><br><span class="line">  Color _color = themeColors[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  Color <span class="keyword">get</span> color =&gt; _color;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;Color&gt; _colorController = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  Observable&lt;Color&gt; <span class="keyword">get</span> colorStream =&gt; Observable(_colorController.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 切换主题通知刷新</span></span><br><span class="line">  switchTheme(<span class="built_in">int</span> themeIndex) &#123;</span><br><span class="line">    _color = themeColors[themeIndex];</span><br><span class="line">    _colorController.add(_color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _colorController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是全局的切换，那么这个 BLoC 肯定需要在最顶层进行注册，这边就不贴代码了，同 <code>ProvinceBloc</code> 一致。接着编写界面，设置界面因为有 <code>GridView</code> 和其他部件，所以也需要用 <code>CustomScrollView</code> 作为粘合剂，当然，你也可以用 <code>Wrap</code> 代替 <code>GridView</code> 来实现网格，就不需要用 <code>CustomScrollView</code>，使用 <code>Column</code> 即可。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingsPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _bloc = BlocProvider.of&lt;SettingBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StreamBuilder(</span><br><span class="line">        stream: _bloc.colorStream,</span><br><span class="line">        initialData: _bloc.color,</span><br><span class="line">        <span class="comment">// Theme 是 Flutter 自带的一个设置主题的部件，里面可以设置多种颜色，</span></span><br><span class="line">        <span class="comment">// 通过接收到 color 的变化，改变主题色，其他页面也如此设置，小伙伴可以自己添加</span></span><br><span class="line">        builder: (_, AsyncSnapshot&lt;Color&gt; snapshot) =&gt; Theme(</span><br><span class="line">            <span class="comment">// IconThemeData 用于设置按钮的主题色</span></span><br><span class="line">              data: ThemeData(primarySwatch: snapshot.data, iconTheme: IconThemeData(color: snapshot.data)),</span><br><span class="line">              child: Scaffold(</span><br><span class="line">                appBar: AppBar(</span><br><span class="line">                  title: Text(<span class="string">'设置'</span>),</span><br><span class="line">                ),</span><br><span class="line">                body: Container(</span><br><span class="line">                  color: Colors.black12,</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">20.0</span>),</span><br><span class="line">                  child: CustomScrollView(</span><br><span class="line">                    slivers: &lt;Widget&gt;[</span><br><span class="line">                      SliverPadding(</span><br><span class="line">                        padding: <span class="keyword">const</span> EdgeInsets.only(right: <span class="number">12.0</span>),</span><br><span class="line">                        sliver: SliverToBoxAdapter(</span><br><span class="line">                            child: Row(</span><br><span class="line">                          mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">                          crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">                          children: &lt;Widget&gt;[</span><br><span class="line">                            Text(<span class="string">'当前主题色：'</span>, style: TextStyle(fontSize: <span class="number">16.0</span>, </span><br><span class="line">                                                            color: snapshot.data)),</span><br><span class="line">                            Container(width: <span class="number">20.0</span>, height: <span class="number">20.0</span>, color: snapshot.data)</span><br><span class="line">                          ],</span><br><span class="line">                        )),</span><br><span class="line">                      ),</span><br><span class="line">                      SliverPadding(padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">15.0</span>)),</span><br><span class="line">                      SliverGrid(</span><br><span class="line">                          delegate: SliverChildBuilderDelegate(</span><br><span class="line">                              (_, index) =&gt; InkWell(</span><br><span class="line">                                    child: Container(color: SettingBloc.themeColors[index]),</span><br><span class="line">                                    onTap: () &#123;</span><br><span class="line">                                        <span class="comment">// 选择后进行保存，当下次进入的时候直接使用该主题色</span></span><br><span class="line">                                        <span class="comment">// 同时切换主题色</span></span><br><span class="line">                                      _bloc.switchTheme(index);</span><br><span class="line">                                      PreferenceUtils.instance.saveInteger(PreferencesKey.THEME_COLOR_INDEX, index);</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                  ),</span><br><span class="line">                              childCount: SettingBloc.themeColors.length),</span><br><span class="line">                          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: <span class="number">3</span>, mainAxisSpacing: <span class="number">20.0</span>, crossAxisSpacing: <span class="number">20.0</span>)),</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终全局的主题切换也实现了。</p><p>编写完代码，需要打包啊，Android 下的打包大家肯定没问题，这里讲下 flutter 下如何打包 apk，ipa 因为没有 mac 所以你们懂的。</p><h5 id="apk-文件打包"><a href="#apk-文件打包" class="headerlink" title="apk 文件打包"></a>apk 文件打包</h5><ol><li><p>创建 jks 文件，如果已经存在可忽略这步从第二步开始。打开终端并输入</p><p><code>keytool -genkey -v -keystore [你的签名文件路径].jks -keyalg RSA -keysize 2048 -validity 10000 -alias key</code></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527153900.png" alt=""></p><p>然后输入密码以及一些基本信息就可以创建成功了</p></li><li><p>在项目的 <code>android</code> 目录下创建一个 <code>key.properties</code> 文件，里面进行如下配置</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">storePassword=&lt;password from previous step&gt;</span><br><span class="line">keyPassword=&lt;password from previous step&gt;</span><br><span class="line">keyAlias=key</span><br><span class="line">storeFile=&lt;[你的签名文件路径].jks&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>android/app</code> 下的 <code>build.gradle</code> 中进行如下修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">apply from: <span class="string">"$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 增加如下部分代码</span></span><br><span class="line">def keystorePropertiesFile = rootProject.file(<span class="string">"key.properties"</span>)</span><br><span class="line">def keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    defaultConfigs&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加如下代码</span></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">            keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">            storeFile file(keystoreProperties[<span class="string">'storeFile'</span>])</span><br><span class="line">            storePassword keystoreProperties[<span class="string">'storePassword'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buildTypes&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次打开终端运行 <code>flutter build apk</code> 会自动生成一个 apk 文件，文件路径为</p><p><code>[你的项目地址]\build\app\outputs\apk\release</code></p></li><li><p>通过 <code>flutter install</code> 就可以将正式包运行到手机上</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲完了常用的部件和网络请求后，差不多该进入整体实战了，这里我们将写一个比较熟悉的项目，郭神的 cool weather。项目将使用 fluro 实现路由管理，dio 实现网络请求，rxdart 实现 BLoC 进行状态管理和逻辑分离，使用文件，shared_preferences，sqflite 实现本地的数据持久化。这边先给出项目的地址：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;flutter_weather&lt;/a&gt;，以及最后实现的效果图：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;One&lt;/th&gt;
&lt;th&gt;Two&lt;/th&gt;
&lt;th&gt;Three&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527153406.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-50e81d7c4da87e57.gif&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-eb02699bb66b1535.gif&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十三)之网络</title>
    <link href="https://zhangmiao.cc/posts/d9e32c9b.html"/>
    <id>https://zhangmiao.cc/posts/d9e32c9b.html</id>
    <published>2019-04-28T07:24:59.000Z</published>
    <updated>2019-05-27T07:42:31.723Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲完了常用的部件，<code>BLoC</code> 模式，数据持久化等常用的，今天再介绍个重头戏 —— 网络请求</p><h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><p><code>HttpClient</code> 是 <code>dart</code> 自带的网络请求方式，在 <code>dart:io</code> 包下。使用 <code>HttpClient</code> 作为请求分以下几个步骤</p><ol><li><p>创建 HttpClient 实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpClient client = HttpClient();</span><br></pre></td></tr></table></figure></li><li><p>打开连接，并设置一些头参数，请求参数等</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 url 中没有查询参数可直接创建</span></span><br><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">'https://www.xxx.com'</span>);</span><br><span class="line"><span class="comment">// 如果存在查询参数则在 Uri 中添加</span></span><br><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>(scheme: <span class="string">'https'</span>, host: <span class="string">'www.xxx.com'</span>, queryParameters: &#123;<span class="string">'a'</span>: <span class="string">'AAA'</span>&#125;);</span><br><span class="line"><span class="comment">// 打开连接</span></span><br><span class="line">HttpClientRequest request = <span class="keyword">await</span> client.getUrl(uri);</span><br><span class="line">request.headers.add(<span class="string">'token'</span>, <span class="string">'Bear <span class="subst">$&#123;<span class="string">'x'</span> * <span class="number">20</span>&#125;</span>'</span>); <span class="comment">// 添加头部 token 信息</span></span><br><span class="line"><span class="comment">// 如果是 post 或者 put 请求，通过 `add` 添加请求体</span></span><br><span class="line"><span class="comment">// 因为 `add` 方法需要传入 `List&lt;int&gt;` 参数，可以通过 utf8.encode 进行编码</span></span><br><span class="line">request.add(utf8.encode(<span class="string">'&#123;"a": "aaa"&#125;'</span>));</span><br><span class="line"><span class="comment">// 也可以通过添加流的方式进行添加</span></span><br><span class="line">request.addStream(input);</span><br></pre></td></tr></table></figure></li><li><p>连接服务器</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 request 后通过 request.close() 获取一个响应对象 HttpClientResponse，</span></span><br><span class="line"><span class="comment">// 包括响应头，响应内容等</span></span><br><span class="line">HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br></pre></td></tr></table></figure></li><li><p>读取服务器响应内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> responseBody = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br></pre></td></tr></table></figure></li><li><p>关闭实例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><p>例如我们要去请求 <code>Bird.so</code> 的首页并显示，我们可以这么实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_httpClientRequest() <span class="keyword">async</span> &#123;</span><br><span class="line">    HttpClient client;</span><br><span class="line">    <span class="comment">// try catch finally 用于捕获请求过程中发生的异常，在 finally 中设置保证 client 能够关闭</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client = HttpClient();</span><br><span class="line">      HttpClientRequest request = <span class="keyword">await</span> client.getUrl(<span class="built_in">Uri</span>.parse(_BIRD_SO_URL));</span><br><span class="line">      HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br><span class="line">      <span class="built_in">String</span> strResponse = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">      setState(() =&gt; _netBack = strResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;e.toString()&#125;</span>'</span>);</span><br><span class="line">      setState(() =&gt; _netBack = <span class="string">'Fail'</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后实现的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-1042230799d843a8.gif" alt=""></p><p>很显然，用 <code>HttpClient</code> 请求相对来说是个非常麻烦的过程，如果要涉及到文本上传之类的，那么就会更麻烦了，所以这边引入一个网络请求的插件 <code>dio</code>，写本文的时候版本为 <code>2.1.0</code></p><h4 id="Dio"><a href="#Dio" class="headerlink" title="Dio"></a>Dio</h4><p>dio 是个非常强大的网络请求库，他的方式类似 <code>OkHttp</code>，我们可以直接查看<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflutterchina%2Fdio%2Fblob%2Fmaster%2FREADME-ZH.md" target="_blank" rel="noopener">官方文档</a>，使用方式非常简单，创建一个 <code>Dio</code> 实例，然后就可以通过 <code>get</code>，<code>post</code> 等方式发起请求，返回 <code>Future&lt;Response&gt;</code>，而且支持多个并发请求，可以设置返回响应的类型，监听上传下载进度等等，看着就很给力。对于简单的方式，这边就不做太多介绍，主要讲下拦截器，也是非常给力的一部分。比如我们需要请求这么个接口 <code>https://randomuser.me/api/</code></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527152811.png" alt=""></p><p>这个接口通过 <code>get</code> 请求，可以加入任意的查询参数。比如我们需要实现一个请求加解密的过程，如果每次都在上传参数或者返回请求的时候去加密，解密的话，就做了非常多无用功了，那么这时候拦截器就派上用场了。先定义下加解密的规则，上传的参数统一转为小写，不存在大写，请求回的数据，不能含有 <code>info</code> 字段。看下如何实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_dioRequest() <span class="keyword">async</span> &#123;</span><br><span class="line">    BaseOptions options = BaseOptions(connectTimeout: <span class="number">5000</span>, receiveTimeout: <span class="number">60000</span>);</span><br><span class="line">    Dio dio = Dio(options);</span><br><span class="line">    </span><br><span class="line">    dio.interceptors.add(InterceptorsWrapper(onRequest: (opt) &#123;</span><br><span class="line">      <span class="comment">// 获取查询的参数</span></span><br><span class="line">      <span class="built_in">Map</span> params = opt.queryParameters;</span><br><span class="line">      <span class="comment">// 将所有的参数转为小写，因为查询参数通过 map 形式上传</span></span><br><span class="line">      params.forEach((key, value) =&gt; </span><br><span class="line">                       opt.queryParameters[key] = <span class="string">'$value'</span>.toLowerCase());</span><br><span class="line">      <span class="comment">// 这边还可以做些别的操作，例如需要 token 进行用户身份验证，则通过头部进行添加</span></span><br><span class="line">      <span class="comment">// opt.headers['authorization'] = 'token';</span></span><br><span class="line">      <span class="comment">// 在官网中，提供了 lock 和 unlock 的写法，被 lock 后，接下来的请求会进入队列等待，</span></span><br><span class="line">      <span class="comment">// 直到 unlock 后才能继续，可以用于几个请求，后续的需要用到前面的返回值的情况使用</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 返回修改后的 RequestOptions</span></span><br><span class="line">      <span class="keyword">return</span> opt;</span><br><span class="line">    &#125;, onResponse: (resp) &#123;</span><br><span class="line">      <span class="comment">// 返回响应体后，将 info 字段的内容切除，并将 json 拼接完成</span></span><br><span class="line">      resp.data = <span class="string">'<span class="subst">$&#123;<span class="string">'<span class="subst">$&#123;resp.data&#125;</span>'</span>.split(<span class="string">', info'</span>).first&#125;</span>&#125;'</span>;</span><br><span class="line">      <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;, onError: (error) &#123;</span><br><span class="line">      <span class="comment">// 发生错误时的回调</span></span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送一个请求，可以查看下打印的结果</span></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(_USER_ME_URL, queryParameters: &#123;<span class="string">'a'</span>: <span class="string">'AAA'</span>, <span class="string">'b'</span>: <span class="string">'BbBbBb'</span>&#125;);</span><br><span class="line">    <span class="built_in">print</span>(response.data);</span><br><span class="line">    <span class="built_in">print</span>(response.request.headers);</span><br><span class="line">    <span class="built_in">print</span>(response.request.queryParameters);</span><br><span class="line">    setState(() =&gt; _netBack = response.data.toString()); <span class="comment">// 界面显示 response.data</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看下最后的显示信息</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527152843.png" alt=""></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527152854.png" alt=""></p><p>请求体的头部成功加上了 <code>authorization</code> 参数，请求的参数全部变为小写，返回的信息也把 info 字段值去除。在很多时候，请求接口后，需要将 json 转换成 pojo 类来处理，可以通过 <code>json_serializable</code> 这个三方插件实现，这边提供文章 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5b5f00e7e51d45190571172f" target="_blank" rel="noopener">Flutter Json自动反序列化</a>，当然这种方式比较麻烦，这里推荐个 <code>Android Studio</code> 下的插件 <code>dart_json_format</code> 直接搜索就可以，如果用的是 <code>Vitual Code</code> 或者别的不是 <code>JetBrains</code> 系列的，这里有个转换的网址 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjaviercbk.github.io%2Fjson_to_dart" target="_blank" rel="noopener">JsonToDart</a>。</p><p><em>以上代码查看 http_main.dart 文件</em></p><h4 id="实践一下下"><a href="#实践一下下" class="headerlink" title="实践一下下"></a>实践一下下</h4><p>不知道小伙还记得前面讲的 <code>BLoC</code> 没有，忘了可以查看 <a href="https://zhangmiao.cc/posts/d121323a.html">Flutter 状态管理及 BLoC</a>，这里结合 <code>BLoC</code> 和 <code>Dio</code> 实现界面和逻辑分离的小例子，接口使用前面提到的 <code>https://randomuser.me/api/</code> 接口。网络应该是比较常用的，所以对其进行一些封装还是很有必要的，这边提供下我自己封装的方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于错误信息回调</span></span><br><span class="line"><span class="keyword">typedef</span> ErrorCallback = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">String</span> msg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> GET = <span class="string">'get'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> POST = <span class="string">'post'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Dio _dio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> HttpUtils _instance;</span><br><span class="line"></span><br><span class="line">  Dio <span class="keyword">get</span> hp =&gt; _dio;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dio 可以在 BaseOptions 中指定域名 baseUrl，</span></span><br><span class="line">  <span class="comment">// 后续接口就不需要再添加域名了</span></span><br><span class="line">  <span class="comment">// 如果请求的接口域名发生了变化，只要把全部 url 写全，就会自动使用新的域名</span></span><br><span class="line">  HttpUtils._internal(<span class="built_in">String</span> base) &#123;</span><br><span class="line">    <span class="comment">// 生成一个单例，防止多次打开关闭造成开销</span></span><br><span class="line">    _dio = Dio(BaseOptions(baseUrl: base, connectTimeout: <span class="number">10000</span>, receiveTimeout: <span class="number">10000</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> HttpUtils(<span class="built_in">String</span> base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) _instance = HttpUtils._internal(base);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加拦截器</span></span><br><span class="line">  addInterceptor(<span class="built_in">List</span>&lt;InterceptorsWrapper&gt; interceptors) &#123;</span><br><span class="line">    _dio.interceptors.clear();</span><br><span class="line">    _dio.interceptors.addAll(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Response&lt;T&gt;&gt; getRequest&lt;T&gt;(url, &#123;<span class="built_in">Map</span> params, ErrorCallback callback&#125;) =&gt;</span><br><span class="line">      _request(url, GET, params: params, callback: callback);</span><br><span class="line"></span><br><span class="line">  Future&lt;Response&lt;T&gt;&gt; postRequest&lt;T&gt;(url, &#123;<span class="built_in">Map</span> params, ErrorCallback callback&#125;) =&gt;</span><br><span class="line">      _request(url, POST, params: params, callback: callback);</span><br><span class="line"></span><br><span class="line">  Future&lt;Response&gt; download(url, path, &#123;ProgressCallback receive, CancelToken token&#125;) =&gt;</span><br><span class="line">      _dio.download(url, path, onReceiveProgress: receive, cancelToken: token);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// T 可以指定返回的类型，String 或者 Map&lt;String, dynamic&gt;</span></span><br><span class="line">  Future&lt;Response&lt;T&gt;&gt; _request&lt;T&gt;(</span><br><span class="line">    url,</span><br><span class="line">    <span class="built_in">String</span> method, &#123;</span><br><span class="line">    <span class="built_in">Map</span> params, <span class="comment">// 上传的参数</span></span><br><span class="line">    Options opt,</span><br><span class="line">    ErrorCallback callback, <span class="comment">// 错误回调</span></span><br><span class="line">    ProgressCallback send, <span class="comment">// 上传进度监听</span></span><br><span class="line">    ProgressCallback receive, <span class="comment">// 下载监听</span></span><br><span class="line">    CancelToken token, <span class="comment">// 用于取消的 token，可以多个请求绑定一个 token</span></span><br><span class="line">  &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response&lt;T&gt; rep;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (method == GET) &#123;</span><br><span class="line">        <span class="comment">// 如果不是重新创建 Dio 实例，get 方法使用 queryParams 会出错，不懂原因，使用拼接没有问题</span></span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.isNotEmpty) &#123;</span><br><span class="line">          <span class="keyword">var</span> sb = <span class="built_in">StringBuffer</span>(<span class="string">'?'</span>);</span><br><span class="line">          params.forEach((key, value) &#123;</span><br><span class="line">            sb.write(<span class="string">'$key=$value&amp;'</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="comment">// get 请求下拼接路径</span></span><br><span class="line">          url += sb.toString().substring(<span class="number">0</span>, sb.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rep = <span class="keyword">await</span> _dio.<span class="keyword">get</span>(url, options: opt, onReceiveProgress: receive, cancelToken: token);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == POST) &#123;</span><br><span class="line">        <span class="comment">// post 参数放请求体</span></span><br><span class="line">        rep = params == <span class="keyword">null</span></span><br><span class="line">            ? <span class="keyword">await</span> _dio.post(url, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive)</span><br><span class="line">            : <span class="keyword">await</span> _dio.post(url,</span><br><span class="line">                data: params, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 statusCode 不是 200 则错误回调，返回空的 Response</span></span><br><span class="line">      <span class="keyword">if</span> (rep.statusCode != <span class="number">200</span> &amp;&amp; callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback(<span class="string">'network error, and code is <span class="subst">$&#123;rep.statusCode&#125;</span>'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> rep;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback(<span class="string">'network error, catch error: <span class="subst">$&#123;e.toString()&#125;</span>'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装后就可以愉快的调用了，如果有别的请求方式后期可以继续扩展。继续看代码，创建一个 <code>application.dart</code> 文件，用于存放全局参数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> HttpUtils http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在 <code>main()</code> 方法中进行初始化，接下来就可以直接使用</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Application.http = HttpUtils(<span class="string">'https://randomuser.me'</span>);</span><br><span class="line">  </span><br><span class="line">  runApp(DemoApp());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 透明状态栏</span></span><br><span class="line">  <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">      SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下最后的实现效果吧，刚进入没有数据则通过转圈圈提示，加载完数据后，点击头像更换下个</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-cbe4a21cc6b3b828.gif" alt=""></p><p>实现 <code>BLoC</code> 需要有一个管理类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  RandomUserModel _user;</span><br><span class="line"></span><br><span class="line">  RandomUserModel <span class="keyword">get</span> user =&gt; _user;</span><br><span class="line"></span><br><span class="line">  BehaviorSubject&lt;RandomUserModel&gt; _controller = BehaviorSubject();</span><br><span class="line"></span><br><span class="line">  Observable&lt;RandomUserModel&gt; <span class="keyword">get</span> stream =&gt; Observable(_controller.stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 网络请求获取新的数据，并更新</span></span><br><span class="line">  updateUserInfo() &#123;</span><br><span class="line">    Application.http.getRequest(<span class="string">'/api'</span>).then((response) &#123;</span><br><span class="line">      <span class="comment">// RandomUserModel 就是接口返回的 json 转成的 model 类</span></span><br><span class="line">      RandomUserModel model = RandomUserModel.fromMap(response.data);</span><br><span class="line">      _user = model;</span><br><span class="line">      <span class="comment">// add 到 controller 通知修改</span></span><br><span class="line">      _controller.add(model);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _controller?.close(); <span class="comment">// 及时销毁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好管理类后，就可以来编写界面了，界面也比较简单</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPageDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将首字母大写</span></span><br><span class="line">  <span class="built_in">String</span> _upperFirst(<span class="built_in">String</span> content) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(content != <span class="keyword">null</span> &amp;&amp; content.isNotEmpty);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'<span class="subst">$&#123;content.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase()&#125;</span><span class="subst">$&#123;content.substring(<span class="number">1</span>)&#125;</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 地址信息通用部件</span></span><br><span class="line">  Widget _userLocation(<span class="built_in">String</span> info) =&gt; Padding(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">4.0</span>),</span><br><span class="line">      child: Text(info, style: TextStyle(color: Colors.white, fontSize: <span class="number">16.0</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    UserBloc _bloc = BlocProvider.of&lt;UserBloc&gt;(context);</span><br><span class="line">    _bloc.updateUserInfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// StreamBuilder 接受更新数据的 stream</span></span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">          builder: (_, AsyncSnapshot&lt;RandomUserModel&gt; snapshot) =&gt; Container(</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                decoration: BoxDecoration(</span><br><span class="line">                    gradient: LinearGradient(</span><br><span class="line">                        begin: Alignment.topCenter,</span><br><span class="line">                        end: Alignment.bottomCenter,</span><br><span class="line">                        colors: [Colors.blue[<span class="number">600</span>], Colors.blue[<span class="number">400</span>]])),</span><br><span class="line">                child: !snapshot.hasData</span><br><span class="line">                    ? CupertinoActivityIndicator(radius: <span class="number">12.0</span>)</span><br><span class="line">                    : Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[</span><br><span class="line">                        InkWell( <span class="comment">// 用于切换数据</span></span><br><span class="line">                            child: ClipOval( <span class="comment">// 圆形头像</span></span><br><span class="line">                              child: FadeInImage.assetNetwork(</span><br><span class="line">                                  placeholder: <span class="string">'images/ava_default.png'</span>, image: snapshot.data.results[<span class="number">0</span>].picture.large),</span><br><span class="line">                            ),</span><br><span class="line">                            onTap: () =&gt; _bloc.updateUserInfo()), <span class="comment">// 更新数据</span></span><br><span class="line">                        Padding(</span><br><span class="line">                          padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">                          child: Text(</span><br><span class="line">                              <span class="string">'<span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].name.first)&#125;</span> <span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].name.last)&#125;</span>'</span>,</span><br><span class="line">                              style: TextStyle(color: Colors.white, fontSize: <span class="number">24.0</span>)),</span><br><span class="line">                        ),</span><br><span class="line">                        Text(<span class="string">'<span class="subst">$&#123;snapshot.data.results[<span class="number">0</span>].email&#125;</span>'</span>,</span><br><span class="line">                            style: TextStyle(color: Colors.white, fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                        _userLocation(<span class="string">'<span class="subst">$&#123;snapshot.data.results[<span class="number">0</span>].location.street&#125;</span>'</span>),</span><br><span class="line">                        _userLocation(<span class="string">'<span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].location.city)&#125;</span>'</span>),</span><br><span class="line">                        _userLocation(<span class="string">'<span class="subst">$&#123;_upperFirst(snapshot.data.results[<span class="number">0</span>].location.state)&#125;</span>'</span>),</span><br><span class="line">                      ]),</span><br><span class="line">              ),</span><br><span class="line">          initialData: _bloc.user, <span class="comment">// 注入初始值</span></span><br><span class="line">          stream: _bloc.stream), <span class="comment">// 注入更新 stream</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>以上代码查看 bloc_network 包下的所有文件</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面讲完了常用的部件，&lt;code&gt;BLoC&lt;/code&gt; 模式，数据持久化等常用的，今天再介绍个重头戏 —— 网络请求&lt;/p&gt;
&lt;h4 id=&quot;HttpClient&quot;&gt;&lt;a href=&quot;#HttpClient&quot; class=&quot;headerlink&quot; title=&quot;HttpClient&quot;&gt;&lt;/a&gt;HttpClient&lt;/h4&gt;&lt;p&gt;&lt;code&gt;HttpClient&lt;/code&gt; 是 &lt;code&gt;dart&lt;/code&gt; 自带的网络请求方式，在 &lt;code&gt;dart:io&lt;/code&gt; 包下。使用 &lt;code&gt;HttpClient&lt;/code&gt; 作为请求分以下几个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建 HttpClient 实例&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HttpClient client = HttpClient();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开连接，并设置一些头参数，请求参数等&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果 url 中没有查询参数可直接创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt; uri = &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt;.parse(&lt;span class=&quot;string&quot;&gt;&#39;https://www.xxx.com&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果存在查询参数则在 Uri 中添加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt; uri = &lt;span class=&quot;built_in&quot;&gt;Uri&lt;/span&gt;(scheme: &lt;span class=&quot;string&quot;&gt;&#39;https&#39;&lt;/span&gt;, host: &lt;span class=&quot;string&quot;&gt;&#39;www.xxx.com&#39;&lt;/span&gt;, queryParameters: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;AAA&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 打开连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HttpClientRequest request = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; client.getUrl(uri);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.headers.add(&lt;span class=&quot;string&quot;&gt;&#39;token&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Bear &lt;span class=&quot;subst&quot;&gt;$&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&amp;#125;&lt;/span&gt;&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 添加头部 token 信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果是 post 或者 put 请求，通过 `add` 添加请求体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为 `add` 方法需要传入 `List&amp;lt;int&amp;gt;` 参数，可以通过 utf8.encode 进行编码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.add(utf8.encode(&lt;span class=&quot;string&quot;&gt;&#39;&amp;#123;&quot;a&quot;: &quot;aaa&quot;&amp;#125;&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 也可以通过添加流的方式进行添加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.addStream(input);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接服务器&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置 request 后通过 request.close() 获取一个响应对象 HttpClientResponse，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 包括响应头，响应内容等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HttpClientResponse response = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; request.close();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读取服务器响应内容&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; responseBody = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; response.transform(utf8.decoder).join();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关闭实例&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;client.close();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十二)之数据持久化</title>
    <link href="https://zhangmiao.cc/posts/6358b348.html"/>
    <id>https://zhangmiao.cc/posts/6358b348.html</id>
    <published>2019-04-28T07:18:47.000Z</published>
    <updated>2019-05-27T07:25:16.938Z</updated>
    
    <content type="html"><![CDATA[<p>上节讲了状态管理，但是当 <code>App</code> 重启后，数据就都丢失了，这样就比较尴尬了，什么都要重来，所以这节我们来讲下数据持久化。数据持久化主要有如下方式</p><ul><li>文件读写</li><li><code>shared_preferences</code> 存储</li><li>数据库存储</li></ul><p>持久化的实现都需要通过三方插件来实现，接着会慢慢介绍三种实现方式</p><a id="more"></a><h4 id="文件读写-IO-操作"><a href="#文件读写-IO-操作" class="headerlink" title="文件读写/ IO 操作"></a>文件读写/ IO 操作</h4><p>文件读写需要 <code>path_provider</code> 插件，写这篇文章的时候，最新版本是 <code>0.5.0+1</code>，小伙伴们可以根据官网最新的版本进行替换，导入后我们就可以来看下如何实现文件的读写了。<code>path_provider</code> 的源码比较简单，这边就不单独拎出来说了，可以自行查看。<code>path_provider</code> 用于获取手机的存储文件位置，一共有三个方法</p><ul><li><code>getTemporaryDirectory</code> 临时目录，在 Android 中对应的方法为 <code>getCacheDir</code>，而在 iOS 中对应为 <code>NSCachesDirectory</code>，可以通过系统检测并清除</li><li><code>getApplicationDocumentsDirectory</code> 缓存目录，在 Android 中对应为 <code>AppData</code> 文件夹，在 iOS 中对应为  <code>NSDocumentsDirectory</code>，只有当 App 被删除才能被删除</li><li><code>getExternalStorageDirectory</code> 外部存储目录，只有在 Android 中有效，在 iOS 调用会抛出 <code>UnsupportedError</code> 异常，不过 Android 在写入前记得先申请权限哟，否则也是不行滴。</li></ul><p>读写文件操作需要通过 <code>Dart</code> 的 <code>IO</code> 操作完成，这边小伙伴们可以自己看文档 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fapi.dartlang.org%2Fstable%2F2.2.0%2Fdart-io%2FFile-class.html" target="_blank" rel="noopener">File class</a>，接着我们就直接通过例子来看文件实现数据持久化。先看下效果吧，最终重启 App 后，数据也能正常读取显示，说明数据被保存下来了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-7a9977c10ad33aff.gif" alt=""></p><p>看下实现的代码，因为会涉及到多种方式，所以这边我把视图抽取出来实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _fileIoPart() &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">      margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(<span class="number">8.0</span>))),</span><br><span class="line">      child: Column(children: &lt;Widget&gt;[</span><br><span class="line">        Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">          child: Text(<span class="string">'File IO'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>, color: Theme.of(context).primaryColor)),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// RadioList 是单选按钮部件，通过选择不同的情况，创建不同目录的文件</span></span><br><span class="line">        RadioListTile(</span><br><span class="line">            value: _radioText[<span class="number">0</span>],</span><br><span class="line">            title: Text(_radioText[<span class="number">0</span>]),</span><br><span class="line">            subtitle: Text(_radioDescriptions[<span class="number">0</span>]),</span><br><span class="line">            groupValue: _currentValue,</span><br><span class="line">            onChanged: ((value) &#123;</span><br><span class="line">              setState(() =&gt; _currentValue = value);</span><br><span class="line">            &#125;)),</span><br><span class="line">        RadioListTile(</span><br><span class="line">            value: _radioText[<span class="number">1</span>],</span><br><span class="line">            title: Text(_radioText[<span class="number">1</span>]),</span><br><span class="line">            subtitle: Text(_radioDescriptions[<span class="number">1</span>]),</span><br><span class="line">            groupValue: _currentValue,</span><br><span class="line">            onChanged: ((value) &#123;</span><br><span class="line">              setState(() =&gt; _currentValue = value);</span><br><span class="line">            &#125;)),</span><br><span class="line">        RadioListTile(</span><br><span class="line">            value: _radioText[<span class="number">2</span>],</span><br><span class="line">            title: Text(_radioText[<span class="number">2</span>]),</span><br><span class="line">            subtitle: Text(_radioDescriptions[<span class="number">2</span>]),</span><br><span class="line">            groupValue: _currentValue,</span><br><span class="line">            onChanged: ((value) &#123;</span><br><span class="line">              setState(() =&gt; _currentValue = value);</span><br><span class="line">            &#125;)),</span><br><span class="line">        Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">          <span class="comment">// 用于写入文本信息</span></span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: _editController,</span><br><span class="line">            decoration: InputDecoration(labelText: <span class="string">'输入存储的文本内容'</span>, icon: Icon(Icons.text_fields)),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">          width: MediaQuery.of(context).size.width,</span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            onPressed: _writeTextIntoFile,</span><br><span class="line">            child: Text(<span class="string">'写入文件信息'</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">          child: Row(</span><br><span class="line">            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[Text(<span class="string">'文件内容：'</span>), Expanded(child: Text(_fileContent, softWrap: <span class="keyword">true</span>))],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">          width: MediaQuery.of(context).size.width,</span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            onPressed: _readTextFromFile,</span><br><span class="line">            child: Text(<span class="string">'读取文件信息'</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ]),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关键的部分在于 <code>_writeTextIntoFile</code> 和 <code>_readTextFromFile</code> 两个方法的实现。看下实现的代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果写入外部内存需要读写权限，这边使用了第三方插件 `permission_handler`</span></span><br><span class="line"> <span class="keyword">void</span> _writeTextIntoFile() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (_currentValue == _radioText[<span class="number">2</span>]) &#123;</span><br><span class="line">     PermissionStatus status = <span class="keyword">await</span> PermissionHandler().checkPermissionStatus(PermissionGroup.storage);</span><br><span class="line">     <span class="keyword">if</span> (status == PermissionStatus.granted) <span class="comment">// 如果是写入外部存储，则检测权限状态，同意则写入</span></span><br><span class="line">       _writeContent();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (status == PermissionStatus.disabled) <span class="comment">// 拒绝了提示手动打开</span></span><br><span class="line">       Fluttertoast.showToast(msg: <span class="string">'未打开相关权限'</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">// 未同意则主动申请权限</span></span><br><span class="line">       PermissionHandler().requestPermissions([PermissionGroup.storage]);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="comment">// 不是写入外部存储直接写入文件</span></span><br><span class="line">     _writeContent();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本写入文件 </span></span><br><span class="line"> <span class="keyword">void</span> _writeContent() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="comment">// 写入文本操作</span></span><br><span class="line">   <span class="keyword">var</span> text = _editController.value.text; <span class="comment">// 获取文本框的内容</span></span><br><span class="line">   File file = File(<span class="keyword">await</span> _getFilePath()); <span class="comment">// 获取相应的文件</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (text == <span class="keyword">null</span> || text.isEmpty) &#123;</span><br><span class="line">     Fluttertoast.showToast(msg: <span class="string">'请输入内容'</span>); <span class="comment">// 内容为空，则不写入并提醒</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 内容不空，则判断是否已经存在，存在先删除，重新创建后写入信息</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">await</span> file.exists()) file.deleteSync();</span><br><span class="line">     file.createSync(); <span class="comment">// createSync 是一个同步的创建过程</span></span><br><span class="line">     file.writeAsStringSync(text); <span class="comment">// writeAsStringSync 是同步写入的过程</span></span><br><span class="line">     _editController.clear(); <span class="comment">// 写入文件后清空输入框信息</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 读取文本操作</span></span><br><span class="line"> <span class="keyword">void</span> _readTextFromFile() <span class="keyword">async</span> &#123;</span><br><span class="line">   File file = File(<span class="keyword">await</span> _getFilePath());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">await</span> file.exists()) &#123;</span><br><span class="line">     setState(() =&gt; _fileContent = file.readAsStringSync()); <span class="comment">// 文件存在则直接显示文本信息</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     setState(() =&gt; _fileContent = <span class="string">''</span>); <span class="comment">// 文件不存在则清空显示文本信息，并提示</span></span><br><span class="line">     Fluttertoast.showToast(msg: <span class="string">'文件还未创建，请先通过写入信息来创建文件'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为外部存储的文件需要涉及到权限问题，而且 iOS 也不支持，所以如果需要使用文件来持久化数据的话，尽量使用另外两种。因为在例子中，我们保存的数据相对比较简单，所以这边就不得不说另外一种更方便的持久化方式了 <code>shared_preferences</code></p><h4 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h4><p>写 Android 的小伙伴对这个应该不陌生了，但是 <code>Flutter</code> 并没有自带的 <code>shared_preferences</code> 功能，需要第三方插件来实现，引入 <code>shared_preferences</code> 插件，写文章的时候最新版本是 <code>^0.5.1+2</code>，还是先看下最后的效果</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-6cbe9d19584b96b4.gif" alt=""></p><p>代码的实现相对比较简单</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _sharedPart() &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">        shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(<span class="number">8.0</span>))),</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">              child:</span><br><span class="line">                  Text(<span class="string">'Shared Preferences'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>, color: Theme.of(context).primaryColor)),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">12.0</span>, <span class="number">0</span>, <span class="number">12.0</span>, <span class="number">12.0</span>),</span><br><span class="line">              <span class="comment">// 用于设置 key 信息</span></span><br><span class="line">              child: TextField(</span><br><span class="line">                controller: _shareKeyController,</span><br><span class="line">                decoration: InputDecoration(labelText: <span class="string">'输入 share 存储的 key'</span>, icon: Icon(Icons.lock_outline)),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">12.0</span>, <span class="number">0</span>, <span class="number">12.0</span>, <span class="number">12.0</span>),</span><br><span class="line">              <span class="comment">// 用于写入文本信息</span></span><br><span class="line">              child: TextField(</span><br><span class="line">                controller: _shareValueController,</span><br><span class="line">                decoration: InputDecoration(labelText: <span class="string">'输入 share 存储的 value'</span>, icon: Icon(Icons.text_fields)),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">              width: MediaQuery.of(context).size.width,</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: _writeIntoShare,</span><br><span class="line">                child: Text(<span class="string">'写入 share'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">12.0</span>),</span><br><span class="line">              child: Row(</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: &lt;Widget&gt;[Text(<span class="string">'share 存储内容：'</span>), Expanded(child: Text(_shareContent, softWrap: <span class="keyword">true</span>))],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>),</span><br><span class="line">              width: MediaQuery.of(context).size.width,</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: _readFromShare,</span><br><span class="line">                child: Text(<span class="string">'读取 share'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实现的关键部分就是方法 <code>_writeIntoShare</code> 和 <code>_readFromShare</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _writeIntoShare() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> shareKey = _shareKeyController.value.text;</span><br><span class="line">    <span class="keyword">var</span> shareContent = _shareValueController.value.text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shareKey == <span class="keyword">null</span> || shareKey.isEmpty) &#123;</span><br><span class="line">      Fluttertoast.showToast(msg: <span class="string">'请输入 key'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shareContent == <span class="keyword">null</span> || shareContent.isEmpty) &#123;</span><br><span class="line">      Fluttertoast.showToast(msg: <span class="string">'请输入保存的内容'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 `getInstance` 获取 `shared_preferences` 单例</span></span><br><span class="line">      <span class="keyword">var</span> sp = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">      <span class="comment">// sp 能保存的数据类型包括 `int`, `String`, `bool`, `double`, `StringList`</span></span><br><span class="line">      sp.setString(shareKey, shareContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _readFromShare() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> shareKey = _shareKeyController.value.text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shareKey == <span class="keyword">null</span> || shareKey.isEmpty) &#123;</span><br><span class="line">      Fluttertoast.showToast(msg: <span class="string">'请输入 key'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> sp = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">      <span class="comment">// 数据读取的类型同写入类型，如果传入的 key 不存在则返回 null</span></span><br><span class="line">      <span class="keyword">var</span> value = sp.getString(shareKey);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Fluttertoast.showToast(msg: <span class="string">'未找到该 key'</span>);</span><br><span class="line">        setState(() =&gt; _shareContent = <span class="string">''</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setState(() =&gt; _shareContent = value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这两种数据持久化的方式主要用于存储相对简单，关系不复杂的数据，如果涉及到大量的，且字段之间有关系的情况就需要通过数据库来实现了，Android 和 iOS 都自带 sqlite 数据库。</p><p><em>以上代码查看 data_persistence_main.dart 文件</em></p><h4 id="Sqflite"><a href="#Sqflite" class="headerlink" title="Sqflite"></a>Sqflite</h4><p><code>Flutter</code> 实现数据库存储需要通过插件 <code>sqflite</code> 来实现，写文章的时候最新的版本是 <code>sqflite 1.1.3</code>，但是该版本需要 <code>flutter 1.2</code> 以上才行，所以我选择的是 <code>sqflite 1.1.0</code>，小伙伴可以根据自己的 <code>flutter</code> 版本选择相应的 <code>sqflite</code> 版本</p><p>sqflite 的基本操作语句，在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftekartik%2Fsqflite%2Fblob%2Fmaster%2Fsqflite%2FREADME.md" target="_blank" rel="noopener">文档中</a>已经写得非常明白了，所以就不搬运了，这边直接讲下对于数据库的一些封装处理吧，因为打开数据库是一个很消耗资源的一个过程，所以呢，推荐实现单例会比较好。例如我们要实现一个 <code>student</code> 存储表</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _tableStudent = <span class="string">'student'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Database _database; <span class="comment">// 创建单例，防止重复打开消耗内存</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DatabaseUtils <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line"></span><br><span class="line">  DatabaseUtils._internal() &#123;</span><br><span class="line">    getDatabasesPath().then((path) <span class="keyword">async</span> &#123;</span><br><span class="line">      _database = <span class="keyword">await</span> openDatabase(join(path, <span class="string">'demo.db'</span>), version: <span class="number">2</span>, onCreate: (db, version) &#123;</span><br><span class="line">        <span class="comment">// 创建数据库的时候在这边调用</span></span><br><span class="line">        db.execute(<span class="string">'create table $_tableStudent '</span></span><br><span class="line">            <span class="string">'id integer primary key autoincrement,'</span></span><br><span class="line">            <span class="string">'name text not null,'</span></span><br><span class="line">            <span class="string">'age integer not null default 0,'</span></span><br><span class="line">            <span class="string">'gender integer not null default 0'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新升级增加的字段</span></span><br><span class="line">        db.execute(<span class="string">'alter table $_tableStudent add column birthday text'</span>);</span><br><span class="line">      &#125;, onUpgrade: (db, oldVersion, newVersion) &#123;</span><br><span class="line">        <span class="comment">// 更新升级数据库的时候在这操作</span></span><br><span class="line">        <span class="keyword">if</span> (oldVersion == <span class="number">1</span>) db.execute(<span class="string">'alter table $_tableStudent add column birthday text'</span>);</span><br><span class="line">      &#125;, onOpen: (db) &#123;</span><br><span class="line">        <span class="comment">// 打开数据库时候的回调</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;db.path&#125;</span>'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> DatabaseUtils() &#123;</span><br><span class="line">    <span class="comment">// 如果当前的单例已经存在，则不再创建，否则重新创建，factory 关键词看第一章</span></span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) _instance = DatabaseUtils._internal();</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对数据库的操作就完全考验你的 <code>SQL</code> 的掌握程度了，但是千万记住，sqlite 中的类型只有，整型 <code>integer</code> ，字符类型 <code>text</code>，浮点类型 <code>real</code>，二进制 <code>blob</code>。数据库的具体例子会等到最后的实际项目中展示，原谅我不懂如何展示一个界面给你操作，实现数据库的各种功能。</p><p><em>该部分代码查看 db_util.dart 文件</em>，里面有一些基本的操作写法，小伙伴可自行查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节讲了状态管理，但是当 &lt;code&gt;App&lt;/code&gt; 重启后，数据就都丢失了，这样就比较尴尬了，什么都要重来，所以这节我们来讲下数据持久化。数据持久化主要有如下方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件读写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared_preferences&lt;/code&gt; 存储&lt;/li&gt;
&lt;li&gt;数据库存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;持久化的实现都需要通过三方插件来实现，接着会慢慢介绍三种实现方式&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十一)之状态管理，BLoC</title>
    <link href="https://zhangmiao.cc/posts/d121323a.html"/>
    <id>https://zhangmiao.cc/posts/d121323a.html</id>
    <published>2019-04-27T07:07:53.000Z</published>
    <updated>2019-05-27T07:12:22.212Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>在 <code>dart</code> 部分记得分享过 <code>Stream</code> 的文章链接，但是我知道你们肯定没几个愿意看的，所以这里再提下。还是得从源码开始…因为源码的注释比较长，就不贴注释了，可以自己看，我这边就提取一些关键信息。</p><p><code>Stream</code> 是 <code>Dart</code> 提供的一种数据流订阅管理的”工具”，感觉有点像 <code>Android</code> 中的 <code>EventBus</code> 或者 <code>RxBus</code>，<code>Stream</code> 可以接收任何对象，包括是另外一个 <code>Stream</code>，接收的对象通过 <code>StreamController</code> 的 <code>sink</code> 进行添加，然后通过 <code>StreamController</code> 发送给 <code>Stream</code>，通过 <code>listen</code> 进行监听，<code>listen</code> 会返回一个 <code>StreamSubscription</code> 对象，<code>StreamSubscription</code> 可以操作对数据流的监听，例如 <code>pause</code>，<code>resume</code>，<code>cancel</code> 等。</p><p><code>Stream</code> 分两种类型：</p><ol><li><code>Single-subscription Stream</code>：单订阅 stream，整个生命周期只允许有一个监听，如果该监听 cancel 了，也不能再添加另一个监听，而且只有当有监听了，才会发送数据，主要用于文件 <code>IO</code> 流的读取等。</li><li><code>Broadcast Stream</code>：广播订阅 stream，允许有多个监听，当添加了监听后，如果流中有数据存在就可以监听到数据，这种类型，不管是否有监听，只要有数据就会发送，用于需要多个监听的情况。</li></ol><a id="more"></a><p>还是看下例子会比较直观</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StreamHomeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StreamHome</span>&gt; </span>&#123;</span><br><span class="line">  StreamController _controller = StreamController();  <span class="comment">// 创建单订阅类型 `StreamController`</span></span><br><span class="line">  Sink _sink;</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    _sink = _controller.sink; <span class="comment">// _sink 用于添加数据</span></span><br><span class="line">    <span class="comment">// _controller.stream 会返回一个单订阅 stream，</span></span><br><span class="line">    <span class="comment">// 通过 listen 返回 StreamSubscription，用于操作流的监听操作</span></span><br><span class="line">    _subscription = _controller.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listener: $data'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据，stream 会通过 `listen` 方法打印</span></span><br><span class="line">    _sink.add(<span class="string">'A'</span>);</span><br><span class="line">    _sink.add(<span class="number">11</span>);</span><br><span class="line">    _sink.add(<span class="number">11.16</span>);</span><br><span class="line">    _sink.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    _sink.add(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 最后要释放资源...</span></span><br><span class="line">    _sink.close();</span><br><span class="line">    _controller.close();</span><br><span class="line">    _subscription.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Container(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下控制台的输出：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527150910.png" alt=""></p><p>果然把所有的数据都打印出来了，前面有说过，单订阅的 stream 只有当 <code>listen</code> 后才会发送数据，不试试我还是不相信的，我们把 <code>_sink.add</code> 放到 <code>listen</code> 前面去执行，再看控制台的打印结果。居然真的是一样的，Google 粑粑果然诚不欺我。接着试下 <code>pause</code>，<code>resume</code> 方法，看下数据如何监听，修改代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_sink = _controller.sink;</span><br><span class="line">_subscription = _controller.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listener: $data'</span>));</span><br><span class="line">_sink.add(<span class="string">'A'</span>);</span><br><span class="line">_subscription.pause(); <span class="comment">// 暂停监听</span></span><br><span class="line">_sink.add(<span class="number">11</span>);</span><br><span class="line">_sink.add(<span class="number">11.16</span>);</span><br><span class="line">_subscription.resume(); <span class="comment">// 恢复监听</span></span><br><span class="line">_sink.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">_sink.add(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>再看控制台的打印，你们可以先猜下是什么结果，我猜大部分人都会觉得应该是不会有 11 和 11.16 打印出来了。然鹅事实并非这样，打印的结果并未发生变化，也就是说，调用 <code>pause</code> 方法后，stream 被堵住了，数据不继续发送了。</p><p>接下来看下广播订阅 stream，对代码做下修改</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamController _controller = StreamController.broadcast();</span><br><span class="line">  Sink _sink;</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    _sink = _controller.sink;</span><br><span class="line"></span><br><span class="line">    _sink.add(<span class="string">'A'</span>);</span><br><span class="line">    _subscription = _controller.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listener: $data'</span>));</span><br><span class="line"></span><br><span class="line">    _sink.add(<span class="number">11</span>);</span><br><span class="line">    _subscription.pause();</span><br><span class="line">    _sink.add(<span class="number">11.16</span>);</span><br><span class="line">    _subscription.resume();</span><br><span class="line"></span><br><span class="line">    _sink.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    _sink.add(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看下控制台的打印：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527150935.png" alt=""></p><p>你猜对答案了吗，这边做下小总结：</p><p><strong>单订阅 Stream 只有当存在监听的时候，才发送数据，广播订阅 Stream 则不考虑这点，有数据就发送；当监听调用 pause 以后，不管哪种类型的 stream 都会停止发送数据，当 resume 之后，把前面存着的数据都发送出去。</strong></p><p>sink 可以接受任何类型的数据，也可以通过泛型对传入的数据进行限制，比如我们对 <code>StreamController</code> 进行类型指定 <code>StreamController&lt;int&gt; _controller = StreamController.broadcast();</code> 因为没有对 <code>Sink</code> 的类型进行限制，还是可以添加除了 <code>int</code> 外的类型参数，但是运行的时候就会报错，<code>_controller</code> 对你传入的参数做了类型判定，拒绝进入。</p><p><code>Stream</code> 中还提供了很多 <code>StremTransformer</code>，用于对监听到的数据进行处理，比如我们发送 0~19 的 20 个数据，只接受大于 10 的前 5 个数据，那么可以对 stream 如下操作</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_subscription = _controller.stream</span><br><span class="line">    .where((value) =&gt; value &gt; <span class="number">10</span>)</span><br><span class="line">    .take(<span class="number">5</span>)</span><br><span class="line">    .listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'Listen: $data'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>.generate(<span class="number">20</span>, (index) =&gt; _sink.add(index));</span><br></pre></td></tr></table></figure><p>那么打印出来的数据如下图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190527150951.png" alt=""></p><p>除了 <code>where</code>，<code>take</code> 还有很多 <code>Transformer</code>， 例如 <code>map</code>，<code>skip</code> 等等，小伙伴们可以自行研究。了解了 <code>Stream</code> 的基本属性后，就可以继续往下了~</p><h4 id="StreamBuilder"><a href="#StreamBuilder" class="headerlink" title="StreamBuilder"></a>StreamBuilder</h4><p>前面提到了 stream 通过 <code>listen</code> 进行监听数据的变化，<code>Flutter</code> 就为我们提供了这么个部件 <code>StreamBuilder</code> 专门用于监听 stream 的变化，然后自动刷新重建。接着来看下源码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> StreamBuilder(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.initialData, <span class="comment">// 初始数据，不传入则为 null</span></span><br><span class="line">    Stream&lt;T&gt; stream,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key, stream: stream);</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">AsyncSnapshot&lt;T&gt; initial() =&gt; AsyncSnapshot&lt;T&gt;.withData(ConnectionState.none, initialData);</span><br></pre></td></tr></table></figure><p><code>StreamBuilder</code> 必须传入一个 <code>AsyncWidgetBuilder</code> 参数，初始值 <code>initialData</code> 可为空， <code>stream</code> 用于监听数据变化，<code>initial</code> 方法的调用在其父类 <code>StremBuilderBase</code> 中，接着看下 <code>StreamBuilderBaseState</code> 的源码，这里我删除一些不必要的源码，方便查看，完整的源码可自行查看</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StreamBuilderBaseState</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StreamBuilderBase</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _summary = widget.initial(); <span class="comment">// 通过传入的初始值生成默认值，如果没有传入则会是 null</span></span><br><span class="line">    _subscribe(); <span class="comment">// 注册传入的 stream，用于监听变化</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// _summary 为监听到的数据</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; widget.build(context, _summary);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">void</span> _subscribe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.stream != <span class="keyword">null</span>) &#123; </span><br><span class="line">      <span class="comment">// stream 通过外部传入，对数据的变化进行监听，</span></span><br><span class="line">      <span class="comment">// 在不同回调中，通过 setState 进行更新 _summary</span></span><br><span class="line">      <span class="comment">// 当 _summary 更新后，由于调用了 setState，重新调用 build 方法，将最新的 _summary 传递出去</span></span><br><span class="line">      _subscription = widget.stream.listen((T data) &#123;</span><br><span class="line">        setState(() &#123; </span><br><span class="line">          _summary = widget.afterData(_summary, data); </span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, onError: (<span class="built_in">Object</span> error) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _summary = widget.afterError(_summary, error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, onDone: () &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _summary = widget.afterDone(_summary);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      _summary = widget.afterConnected(_summary); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前更新数据都需要通过 <code>setState</code> 进行更新，这里了解完了 <code>stream</code>，我们就不使用 <code>setState</code> 更新，使用 <code>Stream</code> 来更新</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StreamHomeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StreamHome</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一个全局的 `StreamController`</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _controller = StreamController.broadcast();</span><br><span class="line">  <span class="comment">// `sink` 用于传入新的数据</span></span><br><span class="line">  Sink&lt;<span class="built_in">int</span>&gt; _sink;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _sink = _controller.sink;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 需要销毁资源</span></span><br><span class="line">    _sink.close();</span><br><span class="line">    _controller.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: StreamBuilder(</span><br><span class="line">          builder: (_, snapshot) =&gt; Text(<span class="string">'<span class="subst">$&#123;snapshot.data&#125;</span>'</span>, style: TextStyle(fontSize: <span class="number">24.0</span>)),</span><br><span class="line">          stream: _controller.stream, <span class="comment">// stream 在 StreamBuilder 销毁的时候会自动销毁</span></span><br><span class="line">          initialData: _counter,</span><br><span class="line">        ),</span><br><span class="line">      )),</span><br><span class="line">      <span class="comment">// 通过 `sink` 传入新的数据，去通知 `stream` 更新到 builder 中</span></span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; _sink.add(_counter++),</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当点击按钮的时候，就会刷新界面上的值，通过上面的源码分析，<code>StreamBuilder</code> 也是通过 <code>setState</code> 方法进行刷新，那么两种方法孰优孰劣呢，当然是通过 <code>Stream</code> 啦，这不是废话吗。<strong>因为通过调用 setState 刷新的话，会把整个界面都进行重构，但是通过 StreamBuilder 的话，只刷新其 builder，这样效率就更高了</strong>，最后看小效果吧，所谓有图有真相嘛</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-31cb9b8c3a99abaf.gif" alt=""></p><p>这一步，我们摒弃了 <code>setState</code> 方法，那么下一步，我们试试把 <code>StatefulWidget</code> 替换成 <code>StatelessWidget</code> 吧，而且<strong>官方也推荐使用 StatelessWidget 替换 StatefulWidget</strong>，这里就需要提下 <code>BLoC</code> 模式了。</p><h4 id="BLoC"><a href="#BLoC" class="headerlink" title="BLoC"></a>BLoC</h4><p>说实话，现在 Google 下 「flutter bloc」能搜到很多文章，基本上都是通过 <code>InheritedWidget</code> 来实现的，例如这篇<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5bb6f344f265da0aa664d68a" target="_blank" rel="noopener">Flutter | 状态管理探索篇——BLoC(三)</a>，但是 <code>InheritedWidget</code> 没有提供 <code>dispose</code> 方法，那么就会存在 <code>StreamController</code> 不能及时销毁等问题，所以，参考了一篇国外的文章，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.didierboelens.com%2F2018%2F08%2Freactive-programming---streams---bloc%2F" target="_blank" rel="noopener">Reactive Programming - Streams - BLoC</a> 这里通过使用 <code>StatefulWidget</code> 来实现，当该部件销毁的时候，可以在其 <code>dispose</code> 方法中及时销毁 <code>StreamController</code>，这里我还是先当个搬运工，搬下大佬为我们实现好的基类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose(); <span class="comment">// 该方法用于及时销毁资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child; <span class="comment">// 这个 `widget` 在 stream 接收到通知的时候刷新</span></span><br><span class="line">  <span class="keyword">final</span> T bloc; </span><br><span class="line">  </span><br><span class="line">  BlocProvider(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.child, <span class="meta">@required</span> <span class="keyword">this</span>.bloc&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该方法用于返回 Bloc 实例</span></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BaseBloc&gt;(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;(); <span class="comment">// 获取当前 Bloc 的类型</span></span><br><span class="line">    <span class="comment">// 通过类型获取相应的 Provider，再通过 Provider 获取 bloc 实例</span></span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type); </span><br><span class="line">    <span class="keyword">return</span> provider.bloc; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BaseBloc</span>&gt;&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    widget.bloc.dispose(); <span class="comment">// 及时销毁资源</span></span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们对前面的例子使用 <code>BLoC</code> 进行修改。</p><p>首先，我们需要创建一个 <code>Bloc</code> 类，用于修改 count 的值</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">BaseBloc</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; _count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stream</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _countController = StreamController.broadcast();</span><br><span class="line"></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> countStream =&gt; _countController.stream; <span class="comment">// 用于 StreamBuilder 的 stream</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispatch(<span class="built_in">int</span> value) &#123;</span><br><span class="line">    _count = value;</span><br><span class="line">    _countController.sink.add(_count); <span class="comment">// 用于通知修改值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _countController.close(); <span class="comment">// 注销资源</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 <code>Bloc</code> 前，需要在最上层的容器中进行注册，也就是 <code>MaterialApp</code> 中</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(StreamApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 这里对创建的 bloc 类进行注册，如果说有多个 bloc 类的话，可以通过 child 进行嵌套注册即可</span></span><br><span class="line">    <span class="comment">// 放在最顶层，可以全局调用，当 App 关闭后，销毁所有的 Bloc 资源，</span></span><br><span class="line">    <span class="comment">// 也可以在路由跳转的时候进行注册，至于在哪里注册，完全看需求</span></span><br><span class="line">    <span class="comment">// 例如实现主题色的切换，则需要在全局定义，当切换主题色的时候全局切换</span></span><br><span class="line">    <span class="comment">// 又比如只有某个或者某几个特殊界面调用，那么完全可以通过在路由跳转的时候注册</span></span><br><span class="line">    <span class="keyword">return</span> BlocProvider(  </span><br><span class="line">        child: MaterialApp(</span><br><span class="line">          debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">          home: StreamHome(),</span><br><span class="line">        ),</span><br><span class="line">        bloc: CounterBloc());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHome</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 获取注册的 bloc，必须先注册，再去查找</span></span><br><span class="line">    <span class="keyword">final</span> CounterBloc _bloc = BlocProvider.of&lt;CounterBloc&gt;(context); </span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: StreamBuilder(</span><br><span class="line">          initialData: _bloc.count,</span><br><span class="line">          stream: _bloc.countStream,</span><br><span class="line">          builder: (_, snapshot) =&gt; Text(<span class="string">'<span class="subst">$&#123;snapshot.data&#125;</span>'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>)),</span><br><span class="line">        ),</span><br><span class="line">      )),</span><br><span class="line">      floatingActionButton:</span><br><span class="line">          <span class="comment">// 通过 bloc 中的 dispatch 方法进行值的修改，通知 stream 刷新界面</span></span><br><span class="line">          FloatingActionButton(onPressed: () =&gt; </span><br><span class="line">                               _bloc.dispatch(_bloc.count + <span class="number">1</span>), child: Icon(Icons.add)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行后，查看效果还是一样的。所以我们成功的对 <code>StatefulWidget</code> 进行了替换</p><p>再继续讲之前，先总结下 <code>Bloc</code></p><p>​    <strong>1. 成功的把页面和逻辑分离开了，页面只展示数据，逻辑通过 BLoC 进行处理</strong></p><p>​    <strong>2. 减少了 setState 方法的使用，提高了性能</strong></p><p>​    <strong>3. 实现了状态管理</strong></p><h4 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h4><p>因为上面的参考文章中提到了 <code>RxDart</code>，个人觉得有必要了解下，当然目前也有很多文章介绍 <code>RxDart</code>，所以我就讲下和 <code>BLoC</code> 有点关系的部分吧。<code>RxDart</code> 需要通过引入插件的方式引入(<code>rxdart: ^0.21.0</code>)</p><p>如果需要查看详细的内容，我这里提供几篇文章链接</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FReactiveX%2Frxdart" target="_blank" rel="noopener">RxDart 文档</a></p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.burkharts.net%2Fapps%2Fblog%2Frxdart-magical-transformations-of-streams%2F" target="_blank" rel="noopener">RxDart: Magical transformations of Streams</a></p><p>其实 RxDart 就是对 Stream 的进一步分装，RxDart 提供了三种 Subject，其功能类似 Stream 中的单订阅 stream 和 广播 stream。</p><ol><li><p><code>PublishSubject</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// PublishSubject is, by default, a broadcast (aka hot) controller, in order</span></span><br><span class="line"><span class="comment">/// to fulfill the Rx Subject contract. This means the Subject's `stream` can</span></span><br><span class="line"><span class="comment">/// be listened to multiple times.</span></span><br></pre></td></tr></table></figure><p>通过注释可以发现 <code>PuslishSubject</code> 不可被多次订阅，尽管实现是通过 <code>StreamController&lt;T&gt;.broadcast</code> 方式实现，其实三种都是通过 <code>broadcast</code> 方式实现的，所以实现的功能就是类似 <code>Single-subscription Stream</code> 的功能。</p></li><li><p><code>BehaviorSubject</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// BehaviorSubject is, by default, a broadcast (aka hot) controller, in order</span></span><br><span class="line"><span class="comment">/// to fulfill the Rx Subject contract. This means the Subject's `stream` can</span></span><br><span class="line"><span class="comment">/// be listened to multiple times.</span></span><br></pre></td></tr></table></figure><p><code>BehaviorSubject</code> 可以被多次订阅，那么这个就是实现了 <code>Broadcast Stream</code> 功能。</p></li><li><p><code>ReplaySubject</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ReplaySubject is, by default, a broadcast (aka hot) controller, in order</span></span><br><span class="line"><span class="comment">/// to fulfill the Rx Subject contract. This means the Subject's `stream` can</span></span><br><span class="line"><span class="comment">/// be listened to multiple times.</span></span><br></pre></td></tr></table></figure><p><code>ReplaySubject</code> 其实也是实现 <code>Broadcast Stream</code> 功能，那么它和 <code>BehaviorSubject</code> 的区别在哪呢，别急，等我慢慢讲。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// As items are added to the subject, the ReplaySubject will store them.</span></span><br><span class="line"><span class="comment">/// When the stream is listened to, those recorded items will be emitted to</span></span><br><span class="line"><span class="comment">/// the listener.</span></span><br></pre></td></tr></table></figure><p>当有数据添加了，但是还没有监听的时候，它会将数据存储下来，等到有监听了，再发送出去，也就是说，<code>ReplaySubject</code> 实现了 <code>Brodacast Stream</code> 的多订阅功能，同时也实现了 <code>Single-subscription Stream</code> 的存储数据的功能，每次添加了新的监听，都能够获取到全部的数据。当然，这还不是它的全部功能，它还可以设置最大的监听数量，会只监听最新的几个数据，在注释中，提供了这么两个例子，可以看下</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ### Example </span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     final subject = new ReplaySubject&lt;int&gt;();</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.add(1);</span></span><br><span class="line"><span class="comment">///     subject.add(2);</span></span><br><span class="line"><span class="comment">///     subject.add(3);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 1, 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 1, 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 1, 2, 3</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ### Example with maxSize</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     final subject = new ReplaySubject&lt;int&gt;(maxSize: 2); // 实现监听数量限制</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.add(1);</span></span><br><span class="line"><span class="comment">///     subject.add(2);</span></span><br><span class="line"><span class="comment">///     subject.add(3);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 2, 3</span></span><br><span class="line"><span class="comment">///     subject.stream.listen(print); // prints 2, 3</span></span><br></pre></td></tr></table></figure></li></ol><p>那么我们可以使用 <code>RxDart</code> 对前面使用 <code>Stream</code> 实现的例子进行替换，最简单的其实只需要使用 <code>BehaviorSubject</code> 替换 <code>StreamController.broadcast()</code> 就可以了，别的都不需要变化。但是 <code>RxDart</code> 有自己的变量，还是按照 <code>RxDart</code> 的方式来</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 StreamController，所以 StreamController 拥有的属性都有</span></span><br><span class="line">BehaviorSubject&lt;<span class="built_in">int</span>&gt; _countController = BehaviorSubject();</span><br><span class="line"><span class="comment">//  StreamController&lt;int&gt; _countController = StreamController.broadcast();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 Stream，所以这里直接用之前 stream 的写法也没问题，但是这样就有点不 RxDart 了</span></span><br><span class="line">Observable&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> countStream =&gt; Observable(_countController.stream);</span><br><span class="line"><span class="comment">//  Stream&lt;int&gt; get countStream =&gt; _countController.stream;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dispatch(<span class="built_in">int</span> value) &#123;</span><br><span class="line">  _count = value;</span><br><span class="line">  <span class="comment">// 直接提供了 add 方法，不需要通过 sink 来添加</span></span><br><span class="line">  _countController.add(_count);</span><br><span class="line"><span class="comment">//    _countController.sink.add(_count);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行还是能过实现相同的效果。如果说要在 <code>RxDart</code> 和 <code>Stream</code> 两种实现方式中选择一种，个人更偏向于 <code>RxDart</code>，因为它对 <code>Stream</code> 进行了进一步的封装，提供了更多更方便的数据转换方法，而且链式的写法真的很舒服，用过了就停不下来，具体的方法介绍可以参考上面提供的链接。</p><h4 id="Provide"><a href="#Provide" class="headerlink" title="Provide"></a>Provide</h4><p>说实话自己封装 <code>BLoC</code> 来实现分离逻辑和界面，相对还是有点难度的，这边可以通过第三方来实现，这边推荐 Google 粑粑的库，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgoogle%2Fflutter-provide" target="_blank" rel="noopener">flutter_provide</a>，看下官方对关键部件和静态方法的介绍</p><blockquote><ul><li><code>Provide&lt;T&gt;</code> - Widget used to obtain values from a <code>ProviderNode</code> higher up in the widget tree and rebuild on change. The <code>Provide&lt;T&gt;</code>widget should only be used with <code>Stream</code>s or <code>Listenable</code>s. Equivalent to <code>ScopedModelDescendant</code> in <code>ScopedModel</code> </li><li><code>Provide.value&lt;T&gt;</code> - Static method used to get a value from a <code>ProviderNode</code> using the <code>BuildContext</code>. This will not rebuild on change. Similar to manually writing a static <code>.of()</code> method for an <code>InheritedWidget</code>.</li><li><code>Provide.stream&lt;T&gt;</code> - Static method used to get a <code>Stream</code> from a <code>ProviderNode</code>. Only works if either <code>T</code> is listenable, or if the <code>Provider</code>comes from a <code>Stream</code>.</li><li><code>Provider&lt;T&gt;</code> - A class that returns a typed value on demand. Stored in a <code>ProviderNode</code> to allow retrieval using <code>Provide</code>.</li><li><code>ProviderNode</code> - The equivalent of the <code>ScopedModel</code> widget. Contains <code>Providers</code> which can be found as an <code>InheritedWidget</code>.</li></ul></blockquote><p><code>Provide</code> 这个部件主要用于从上层的 <code>ProvideNode</code> 中获取值，当变化的时候刷新重建，只能同 <code>Stream</code> 和 <code>Listenable</code>  一同使用，类似于 <code>ScopeMode</code> 中的 <code>ScopedModelDescendant</code>。<em>(这个部件放在需要状态管理的部件的上层，例如有个 Text 需要修改状态，那么就需要在外层提供一个 Provide 部件，通过内部 builder 参数返回 Text 部件)</em></p><p><code>Provide.value</code> 是个静态方法，用于从 <code>ProvideNode</code> 获取值，但是当接收的值改变的时候不会重建。类似于 <code>InheritedWidget</code> 的静态方法 <code>of</code>。<em>(这个方法用于获取指定类型的 provide，每个 provide 都需要提供一个数据类，该类 with ChangeNotifier，当数据变化的时候通过 notifyListeners 通知 provide 变化，进行刷新重建)</em></p><p><code>Provide.stream</code> 是个静态方法，用于从 <code>ProvideNode</code> 获取一个 <code>stream</code>，仅在 T 可被监听，或者 Provide 来自 stream 的情况下有效。<em>(这个通常结合 StreamBuilder 使用，StreamBuilder 在上面已经提到，就不多说了)</em></p><p><code>Provider</code> 按需要的类型返回相关值的类，存储在 <code>ProviderNode</code> 中方便 <code>Provide</code> 进行检索。<em>(这个类主要是将我们自己创建的数据类通过 function 等方法转换成 Provider，并在 Providers 中进行注册)</em></p><p><code>ProvideNode</code> 类似于 <code>ScopedModel</code> 的一个部件，包含所有能被查找的 <code>Providers</code>。<em>(这个需要放在顶层，方便下面的容器进行查找 provider，刷新相应的部件，一般放在 MaterialApp 上层)</em></p><p><em>这边再补充一个个人觉得关键的类 Providers，这个类主要用于存储定义的 Provider，主要是在建立 MaterialApp 的时候将需要用到的 Provider 通过 provide 方法添加进去存储起来，然后在 ProvideNode 中注册所有的 provider 方便下层容器获取值，并调用。</em></p><p>说那么多，还不如直接看个例子直接，代码来了~，首先需要建立一个类似 <code>BLoC</code> 中监听数据变化的 <code>counter_bloc</code> 类的数据管理类，我们这边定义为 <code>count_provider</code> 需要混入 <code>ChangeNotifier</code> 类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountProvider</span> <span class="title">with</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _value = <span class="number">0</span>; <span class="comment">// 存储的数据，也是我们需要管理的状态值</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> value =&gt; _value; <span class="comment">// 获取状态值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> changeValue(<span class="built_in">int</span> value) &#123;</span><br><span class="line">    _value = value;</span><br><span class="line">    notifyListeners(); <span class="comment">// 当状态值发生变化的时候，通过该方法刷新重建部件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要将定义的类注册到全局的 <code>Providers</code> 中</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> providers = Providers()</span><br><span class="line">    <span class="comment">// 将我们创建的数据管理类，通过 Provider.function 方法转换成 Provider，</span></span><br><span class="line">    <span class="comment">// 然后添加到 Providers 中</span></span><br><span class="line">    ..provide(Provider.function((_) =&gt; CountProvider()));</span><br><span class="line">  <span class="comment">// 在 App 上层，通过包裹一层 ProvideNode，并将我们生成的 Providers 实例</span></span><br><span class="line">  <span class="comment">// 注册到 ProvideNode 中去，这样整个 App 都可以通过 Provide.value 查找相关的 Provider</span></span><br><span class="line">  <span class="comment">// 找到 Provider 后就可以找到我们的数据管理类</span></span><br><span class="line">  runApp(ProviderNode(child: StreamApp(), providers: providers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是替换我们的界面实现了，前面通过 <code>BLoC</code> 实现，这里替换成 <code>Provide</code> 来实现</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHome</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">          child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        <span class="comment">// 通过指定类型，获取特定的 Provide，这个 Provide 会返回我们的数据管理类 provider</span></span><br><span class="line">        <span class="comment">// 通过内部定义的方法，获取到需要展示的值</span></span><br><span class="line">        child: Provide&lt;CountProvider&gt;(builder: (_, widget, provider) =&gt; Text(<span class="string">'<span class="subst">$&#123;provider.value&#125;</span>'</span>)),</span><br><span class="line">      )),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">          onPressed: () =&gt;</span><br><span class="line">              <span class="comment">// 通过 value 方法获取到我们的数据管理类 provider，</span></span><br><span class="line">              <span class="comment">// 通过调用改变值的方法，修改内部的值，并通知界面刷新重建</span></span><br><span class="line">              Provide.value&lt;CountProvider&gt;(context).changeValue(</span><br><span class="line">                  Provide.value&lt;CountProvider&gt;(context).value + <span class="number">1</span>),</span><br><span class="line">          child: Icon(Icons.add))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>本文代码查看 bloc 包名下的所有文件，需要单独运行 stream_main.dart 文件</em></p><p>最后运行后还是一样的效果，也摒弃了 <code>StatefulWidget</code> 部件和 <code>SetState</code> 方法，实现了逻辑和界面分离。但是 <code>Provide</code> 最终还是通过 <code>InheritedWidget</code> 来实现，当然在资源方面 Google 的大佬们做了一些相关的处理，至于如何处理，这边就不多说了。目前 <code>provide</code> 的这个库还存在一点争议的地方，具体查看 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgoogle%2Fflutter-provide%2Fissues%2F3" target="_blank" rel="noopener">issue#3</a>，但是目前来看并没有太大的影响。当然你不放心的话，可以使用 <code>Scoped_model</code> 或者上面的 <code>Bloc</code> 模式，Google 在文档也有相关的注明</p><blockquote><p>If you must choose a package today, it’s safer to go with <code>package:scoped_model</code> than with this package.</p></blockquote><p>这篇概念性的比较多，但是等理解了以后，对于以后的开发还是非常有利的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;dart&lt;/code&gt; 部分记得分享过 &lt;code&gt;Stream&lt;/code&gt; 的文章链接，但是我知道你们肯定没几个愿意看的，所以这里再提下。还是得从源码开始…因为源码的注释比较长，就不贴注释了，可以自己看，我这边就提取一些关键信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 是 &lt;code&gt;Dart&lt;/code&gt; 提供的一种数据流订阅管理的”工具”，感觉有点像 &lt;code&gt;Android&lt;/code&gt; 中的 &lt;code&gt;EventBus&lt;/code&gt; 或者 &lt;code&gt;RxBus&lt;/code&gt;，&lt;code&gt;Stream&lt;/code&gt; 可以接收任何对象，包括是另外一个 &lt;code&gt;Stream&lt;/code&gt;，接收的对象通过 &lt;code&gt;StreamController&lt;/code&gt; 的 &lt;code&gt;sink&lt;/code&gt; 进行添加，然后通过 &lt;code&gt;StreamController&lt;/code&gt; 发送给 &lt;code&gt;Stream&lt;/code&gt;，通过 &lt;code&gt;listen&lt;/code&gt; 进行监听，&lt;code&gt;listen&lt;/code&gt; 会返回一个 &lt;code&gt;StreamSubscription&lt;/code&gt; 对象，&lt;code&gt;StreamSubscription&lt;/code&gt; 可以操作对数据流的监听，例如 &lt;code&gt;pause&lt;/code&gt;，&lt;code&gt;resume&lt;/code&gt;，&lt;code&gt;cancel&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 分两种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Single-subscription Stream&lt;/code&gt;：单订阅 stream，整个生命周期只允许有一个监听，如果该监听 cancel 了，也不能再添加另一个监听，而且只有当有监听了，才会发送数据，主要用于文件 &lt;code&gt;IO&lt;/code&gt; 流的读取等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Broadcast Stream&lt;/code&gt;：广播订阅 stream，允许有多个监听，当添加了监听后，如果流中有数据存在就可以监听到数据，这种类型，不管是否有监听，只要有数据就会发送，用于需要多个监听的情况。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(十)之手势处理和动画</title>
    <link href="https://zhangmiao.cc/posts/d4756fd3.html"/>
    <id>https://zhangmiao.cc/posts/d4756fd3.html</id>
    <published>2019-04-27T06:55:04.000Z</published>
    <updated>2019-05-27T07:06:50.600Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Flutter</code> 中，自带手势监听的目前为止好像只有按钮部件和一些 <code>chip</code> 部件，例如 <code>Text</code> 等部件需要实现手势监听，就需要借助带有监听事件的部件来实现了，这节我们会讲下 <code>InkWell</code> 和 <code>GestureDetector</code> 来实现手势的监听。</p><h4 id="InkWell"><a href="#InkWell" class="headerlink" title="InkWell"></a>InkWell</h4><p>在前面的一些例子中，小伙伴应该看到了好几次 <code>InkWell</code> 这个部件，通过它我们可以实现对一些手势的监听，并实现 <code>MD</code> 的水波纹效果，举个简单的一个例子</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">InkWell(</span><br><span class="line">  child: Text(<span class="string">'点我...点我...我能响应点击手势'</span>),</span><br><span class="line">  onTap: () =&gt; <span class="built_in">print</span>(<span class="string">'啊...我被点击了...'</span>)</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>那么当点击 <code>Text</code> 的时候就会响应点击事件，控制台输出日志</p><a id="more"></a><p>我们还是老套路，分析下源码。<code>Ctrl</code> 点击 <code>InkWell</code> 来查看源码(<code>Android Studio</code> 的操作，别的我不懂喔…)，然后，「嗯…除了构造函数怎么什么都没有？？？」那只能看它的父类 <code>InkResponse</code> 了，在那之前，我们看下 <code>InkWell</code> 的说明</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; /// A rectangular area of a [Material] that responds to touch.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>InkWell</code> 是在 <strong>MaterialDesign</strong> 风格下的一个用来响应触摸的<strong>矩形区域</strong>（注意加粗的文字，1.如果不是 <code>MD</code> 风格的部件下，你是不能用这个来做点击响应的；2.<code>InkWell</code> 是一块矩形区域，如果你要的是圆形区域，8 好意思，不行！）</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; /// The [InkWell] widget must have a [Material] widget as an ancestor. The</span><br><span class="line">&gt; /// [Material] widget is where the ink reactions are actually painted. This</span><br><span class="line">&gt; /// matches the material design premise wherein the [Material] is what is</span><br><span class="line">&gt; /// actually reacting to touches by spreading ink.</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`InkWell` 必须要有一个 `Material` 风格的部件作为锚点，巴拉巴拉巴拉....再次强调必须要在 `MD` 风格下使用。</span><br><span class="line"></span><br><span class="line">接下来看下 `InkResponse` 吧</span><br><span class="line"></span><br><span class="line">#### InkResponse</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line">const InkResponse(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.child, // 需要监听的子部件</span><br><span class="line">    // 一个 `GestureTapCallback` 类型参数，看下 `GestureTapCallback` 的定义,</span><br><span class="line">    // `typedef GestureTapCallback = void Function();` 就是简单的无参无返回类型参数</span><br><span class="line">    // 监听手指点击事件</span><br><span class="line">    this.onTap,</span><br><span class="line">    // 一个 `GestureTapDownCallback` 类型参数，需要 `TapDownDetails` 类型参数，</span><br><span class="line">    // `TapDownDetails` 里面有个 `Offset` 参数用于记录点击的位置，监听手指点击屏幕的事件</span><br><span class="line">    this.onTapDown,</span><br><span class="line">    // 同 `onTap` 表示点击事件取消监听</span><br><span class="line">    this.onTapCancel,</span><br><span class="line">    // 同 `onTap` 表示双击事件监听</span><br><span class="line">    this.onDoubleTap,</span><br><span class="line">    // 一个 `GestureLongPressCallback` 类型参数，也是无参无返回值，表示长按的监听</span><br><span class="line">    this.onLongPress,</span><br><span class="line">    // 监听高亮的变化，返回 `true` 表示往高亮变化，`false` 相反</span><br><span class="line">    this.onHighlightChanged,</span><br><span class="line">    // 是否需要裁剪区域，`InkWell` 该值为 `true`，会根据 `highlightShape` 裁剪</span><br><span class="line">    this.containedInkWell = false,</span><br><span class="line">    // 高亮的外形，`InkWell` 该值设置成 `BoxShape.rectangle`，所以是个矩形区域</span><br><span class="line">    this.highlightShape = BoxShape.circle,</span><br><span class="line">    this.radius, // 手指点下去的时候，出现水波纹的半径</span><br><span class="line">    this.borderRadius, // 点击时候外圈阴影的圆角半径</span><br><span class="line">    this.customBorder,</span><br><span class="line">    this.highlightColor, // 高亮颜色</span><br><span class="line">    this.splashColor, // 手指点下生成的水波颜色</span><br><span class="line">    this.splashFactory, // 两个值 `InkRipple.splashFactory` 和 `InkSplash.splashFactory`</span><br><span class="line">    this.enableFeedback = true, // 检测到手势是否有反馈</span><br><span class="line">    this.excludeFromSemantics = false,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></blockquote><p>所以一些简单的触摸事件直接通过 <code>InkWell</code> 或者 <code>InkResponse</code> 就能够实现，但是面临一些比较复杂的手势，就有点不太够用了，我们需要通过 <code>GestureDector</code> 来进行处理</p><h4 id="GestureDector"><a href="#GestureDector" class="headerlink" title="GestureDector"></a>GestureDector</h4><p><code>GestureDetector</code> 也是一个部件，主要实现对各种手势动作的监听，其监听事件查看下面的表格</p><table><thead><tr><th style="text-align:left">回调方法</th><th>回调描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>onTapDown</code></td><td>点击屏幕的手势触碰到屏幕时候触发</td></tr><tr><td style="text-align:left"><code>onTapUp</code></td><td>点击屏幕抬手后触发，点击结束</td></tr><tr><td style="text-align:left"><code>onTap</code></td><td>点击事件已经完成的时候触发，和 <code>onTapUp</code> 几乎同时</td></tr><tr><td style="text-align:left"><code>onTapCancel</code></td><td>点击未完成，被其它手势取代的时候触发</td></tr><tr><td style="text-align:left"><code>onDoubleTap</code></td><td>双击屏幕的时候触发</td></tr><tr><td style="text-align:left"><code>onLongPress</code></td><td>长按屏幕的时候触发</td></tr><tr><td style="text-align:left"><code>onLongPressUp</code></td><td>长按屏幕后抬手触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragDown</code></td><td>触碰到屏幕，可能发生垂直方向移动触发，<code>onVerticalDrag</code> 系列事件不会同 <code>onHorizontalDrag</code> 系列事件同时发生 ，如果发生了 <code>onVerticalDrag</code> 则接下来如何变化移动，都不会触发 <code>onHorizontalDrag</code> 事件，除非取消后重新触发。判断两者的关键是准备滑动的意图，先发生横向滑动则触发 <code>onHorizontalDrag</code> 事件，否则 <code>onVerticalDrag</code> 事件。</td></tr><tr><td style="text-align:left"><code>onVerticalDragStart</code></td><td>触碰到屏幕，并开始发生垂直方向的移动触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragUpdate</code></td><td>垂直方向移动的距离变化触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragEnd</code></td><td>抬手取消垂直方向移动的时候触发</td></tr><tr><td style="text-align:left"><code>onVerticalDragCancel</code></td><td>触发 <code>onVerticalDragDown</code> 但是没有完成整个 <code>onVerticalDrag</code> 事件触发</td></tr><tr><td style="text-align:left"></td><td><code>onHorizontalDrag</code> 系列介绍省略同上…</td></tr><tr><td style="text-align:left"><code>onPanDown</code></td><td>触碰到屏幕，准备滑动的时候触发，<code>onPan</code> 系列回调不可和 <code>onVerticalDrag</code> 或者 <code>onHorizontalDrag</code> 系列回调同时设置</td></tr><tr><td style="text-align:left"><code>onPanStart</code></td><td>触碰到屏幕，并开始滑动时候触发</td></tr><tr><td style="text-align:left"><code>onPanUpdate</code></td><td>滑动位置发生改变的时候触发</td></tr><tr><td style="text-align:left"><code>onPanEnd</code></td><td>滑动完成并抬手的时候触发</td></tr><tr><td style="text-align:left"><code>onPanCancel</code></td><td>触发 <code>onPanDown</code> 但是没有完成整个 <code>onPan</code> 事件触发</td></tr><tr><td style="text-align:left"><code>onScaleStart</code></td><td>两个手指之间建立联络点触发，初始缩放比例为 1.0</td></tr><tr><td style="text-align:left"><code>onScaleUpdate</code></td><td>手指距离发生变化，缩放比例也跟随变化触发</td></tr><tr><td style="text-align:left"><code>onScaleEnd</code></td><td>手指抬起，至间的联络断开时候触发</td></tr></tbody></table><p>还有 <code>onForcePress</code> 系列事件，这个是根据对屏幕的挤压力度进行触发，需要达到某些定值才能触发。<code>GestureDetector</code> 有个 <code>behavior</code> 属性用于设置手势监听过程中的表现形式</p><ol><li><code>deferToChild</code> 默认值，触摸到 <code>child</code> 的范围才会触发手势，空白处不会触发</li><li><code>opaque</code> 不透明模式，防止 <code>background widget</code> 接收到手势</li><li><code>translucent</code> 半透明模式，刚好同 <code>opaque</code> 相反，允许 <code>background widget</code> 接收到手势</li></ol><p>介绍完了手势，那就可以实际操练起来了，比如，实现一个跟随手指运动的小方块，先看下效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-fad16bdf993f54d8.gif" alt=""></p><p>简单的分析下，通过 <code>Positioned</code> 来设置小方块的位置，根据 <code>GestureDetector</code> 的 <code>onPanUpdate</code> 修改 <code>Positioned</code> 的 <code>left</code> 和 <code>top</code> 值，当 <code>onPanEnd</code> 或者 <code>onPanCancel</code> 的时候设置为原点，那么就可以有如图的效果了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GestureDemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _GestureDemoPageState createState() =&gt; _GestureDemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GestureDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GestureDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> left = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">double</span> top = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Gesture Demo'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Stack(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Positioned(child: Container(width: <span class="number">50.0</span>, height: <span class="number">50.0</span>, color: Colors.red), left: left, top: top),</span><br><span class="line">            GestureDetector(</span><br><span class="line">              behavior: HitTestBehavior.translucent,</span><br><span class="line">              child: Container(</span><br><span class="line">                  color: Colors.transparent,</span><br><span class="line">                  width: MediaQuery.of(context).size.width - <span class="number">10</span>,</span><br><span class="line">                  height: MediaQuery.of(context).size.height),</span><br><span class="line">              onPanDown: (details) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = details.globalPosition.dx;</span><br><span class="line">                  top = details.globalPosition.dy;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onPanUpdate: (details) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = details.globalPosition.dx;</span><br><span class="line">                  top = details.globalPosition.dy;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onPanCancel: () &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = <span class="number">0.0</span>;</span><br><span class="line">                  top = <span class="number">0.0</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onPanEnd: (details) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  left = <span class="number">0.0</span>;</span><br><span class="line">                  top = <span class="number">0.0</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说要实现一个放大缩小的方块，就可以通过 <code>onScaleUpdate</code> 中获取到的 <code>details.scale</code> 来设置方块的宽高即可。这个比较简单就留给小伙伴们自己实现效果了。</p><p><em>该部分代码查看 gesture_main.dart 文件</em></p><h4 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h4><p><code>Flutter</code> 的 <code>Animation</code> 是个抽象类，具体的实现需要看其子类 <code>AnimationController</code>，在这之前，先了解下 <code>Animation</code> 的一些方法和介绍。</p><ol><li><p><code>addListener</code> / <code>removeListener</code> 添加的监听用于监听值的变化，<code>remove</code> 用于停止监听</p></li><li><p><code>addStatusListener</code> / <code>removeStatusListener</code> 添加动画状态变化的监听，<code>remove</code> 停止监听，<code>Animation</code> 的状态有 4 种：<code>dismissed</code> 动画初始状态，反向运动结束状态，<code>forward</code> 动画正向运动状态，<code>reverse</code> 动画反向运动状态，<code>completed</code> 动画正向运动结束状态。</p></li><li><p><code>drive</code> 方法用于连接动画，例如官方举的例子，因为 <code>AnimationController</code> 是其子类，所以也拥有该方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Animation&lt;Alignment&gt; _alignment1 = _controller.drive(</span><br><span class="line">     AlignmentTween(</span><br><span class="line">       begin: Alignment.topLeft,</span><br><span class="line">       end: Alignment.topRight,</span><br><span class="line">     ),</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>上面的例子将 <code>AnimationController</code> 和 <code>AlignmentTween</code> 结合成一个 <code>Animation&lt;Alignment&gt;</code> 动画，当然 <code>drive</code> 可以结合多个动画，例如</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Animation&lt;Alignment&gt; _alignment3 = _controller</span><br><span class="line">       .drive(CurveTween(curve: Curves.easeIn))</span><br><span class="line">       .drive(AlignmentTween(</span><br><span class="line">         begin: Alignment.topLeft,</span><br><span class="line">         end: Alignment.topRight,</span><br><span class="line">       ));</span><br></pre></td></tr></table></figure></li></ol><p>因为 <code>Animation</code> 是抽象类，所以具体的还是需要通过 <code>AnimationController</code> 来实现。</p><h4 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController(&#123;</span><br><span class="line">    <span class="built_in">double</span> value, <span class="comment">// 设置初始的值</span></span><br><span class="line">    <span class="keyword">this</span>.duration, <span class="comment">// 动画的时长</span></span><br><span class="line">    <span class="keyword">this</span>.debugLabel, <span class="comment">// 主要是用于 `toString` 方法中输出信息</span></span><br><span class="line">    <span class="keyword">this</span>.lowerBound = <span class="number">0.0</span>, <span class="comment">// 最小范围</span></span><br><span class="line">    <span class="keyword">this</span>.upperBound = <span class="number">1.0</span>, <span class="comment">// 最大范围</span></span><br><span class="line">    <span class="comment">// AnimationController 结束时候的行为，有 `normal` 和 `preserve` 两个值可选</span></span><br><span class="line">    <span class="keyword">this</span>.animationBehavior = AnimationBehavior.normal, </span><br><span class="line">    <span class="comment">// 这个属性可以通过 with `SingleTickerProviderStateMixin` </span></span><br><span class="line">    <span class="comment">// 或者 `TickerProviderStateMixin` 引入到 `State`，通过 `this` 指定</span></span><br><span class="line">    <span class="meta">@required</span> TickerProvider vsync,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><code>AnimationController</code> 控制动画的方法有这么几个</p><ol><li><code>forward</code> 启动动画，和上面提到的 <code>forward</code> 状态不一样</li><li><code>reverse</code> 方向启动动画</li><li><code>repeat</code> 重复使动画运行</li><li><code>stop</code> 停止动画</li><li><code>reset</code> 重置动画</li></ol><p>大概了解了 <code>AnimationController</code> ，接下来通过一个实际的小例子来加深下印象，例如实现如下效果，点击开始动画，结束后再点击反向动画</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-0f55a9d8215eb84c.gif" alt=""></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoPage</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _animationController = AnimationController(</span><br><span class="line">        vsync: <span class="keyword">this</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>), lowerBound: <span class="number">28.0</span>, upperBound: <span class="number">50.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当动画值发生变化的时候，重绘下 icon</span></span><br><span class="line">    _animationController.addListener(() &#123;</span><br><span class="line">      setState(() &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 一定要释放资源</span></span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Animation Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: IconButton(</span><br><span class="line">            icon: Icon(Icons.android, color: Colors.green[<span class="number">500</span>], size: _animationController.value),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 根据状态执行不同动画运动方式</span></span><br><span class="line">              <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">                _animationController.reverse();</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed)</span><br><span class="line">                _animationController.forward();</span><br><span class="line">            &#125;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果要实现无限动画呢，那就可以通过 <code>addStatusListener</code> 监听动画的状态来执行，修改代码，在 <code>initState</code> 增加如下代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_animationController.addStatusListener((status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">        _animationController.reverse();  <span class="comment">// 正向结束后开始反向</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed) </span><br><span class="line">        _animationController.forward(); <span class="comment">// 反向结束后开始正向</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _animationController.forward(); <span class="comment">// 启动动画</span></span><br></pre></td></tr></table></figure><p>把 <code>Center</code> 的 <code>child</code> 替换成一个 <code>Icon</code>，因为上面已经启动了动画，所以不需要再用点击去启动了，运行后就会无限放大缩小循环跑了。</p><p>在这个例子中，通过设置 <code>AnimationController</code> 的 <code>lowerBound</code> 和 <code>upperBound</code> 实现了动画的变化范围，接下来，将通过 <code>Tween</code> 来实现动画的变化范围。先看下 <code>Tween</code> 的一些介绍。</p><h4 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h4><blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">/// A linear interpolation between a beginning and ending value.</span></span><br><span class="line">&gt; <span class="comment">///</span></span><br><span class="line">&gt; <span class="comment">/// [Tween] is useful if you want to interpolate across a range.</span></span><br><span class="line">&gt; <span class="comment">///</span></span><br><span class="line">&gt; <span class="comment">/// To use a [Tween] object with an animation, call the [Tween] object's</span></span><br><span class="line">&gt; <span class="comment">/// [animate] method and pass it the [Animation] object that you want to</span></span><br><span class="line">&gt; <span class="comment">/// modify.</span></span><br><span class="line">&gt; <span class="comment">///</span></span><br><span class="line">&gt; <span class="comment">/// You can chain [Tween] objects together using the [chain] method, so that a</span></span><br><span class="line">&gt; <span class="comment">/// single [Animation] object is configured by multiple [Tween] objects called</span></span><br><span class="line">&gt; <span class="comment">/// in succession. This is different than calling the [animate] method twice,</span></span><br><span class="line">&gt; <span class="comment">/// which results in two separate [Animation] objects, each configured with a</span></span><br><span class="line">&gt; <span class="comment">/// single [Tween].</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>Tween</code> 是一个线性插值(如果要修改运动的插值，可以通过 <code>CurveTween</code> 来修改)，所以在线性变化的时候很有用</p><p>通过调用 <code>Tween</code> 的 <code>animate</code> 方法生成一个 <code>Animation</code>(<code>animate</code> 一般传入 <code>AnimationController</code>)</p><p>还可以通过 <code>chain</code> 方法将多个 <code>Tween</code> 结合到一起，这样就不需要多次去调用 <code>Tween</code> 的 <code>animate</code> 方法来生成动画了，多次调用 <code>animate</code> 相当于使用了两个分开的动画来完成效果，但是 <code>chain</code> 结合到一起就是一个动画过程</p><p>那么对前面的动画进行一些修改，通过 <code>Tween</code> 来控制值的变化</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoPage</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  Animation _scaleAnimation; <span class="comment">// 动画实例，用于修改值的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _animationController = AnimationController(vsync: <span class="keyword">this</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>)); <span class="comment">// 不通过 `lowerBound` 和 `upperBound` 设置范围，改用 `Tween`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当动画值发生变化的时候，重绘下 icon</span></span><br><span class="line">    _animationController.addListener(() &#123;</span><br><span class="line">      setState(() &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _animationController.addStatusListener((status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">        _animationController.reverse();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed)</span><br><span class="line">        _animationController.forward();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 `Tween` 的 `animate` 生成一个 Animation</span></span><br><span class="line">    <span class="comment">// 再通过  Animation.value 进行值的修改</span></span><br><span class="line">    _scaleAnimation = Tween(begin: <span class="number">28.0</span>, end: <span class="number">50.0</span>).animate(_animationController);</span><br><span class="line">    _animationController.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 一定要释放资源</span></span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Animation Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        <span class="comment">// 通过动画返回的值，修改图标的大小</span></span><br><span class="line">        child: Icon(Icons.favorite, color: Colors.red, size: _scaleAnimation.value),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，还是能过达到之前的效果，那么很多小伙伴肯定会问了，「**，加了那么多代码，效果还是和以前的一样，还不如不加…」好吧，我无法反驳，但是如果要实现多个动画呢，那么使用 <code>Tween</code> 就有优势了，比如我们让图标大小变化的同时，颜色和位置也发生变化，只通过 <code>AnimationController</code> 要怎么实现? 又比如说，运动的方式要先加速后减速，那只通过 <code>AnimationController</code> 要如何实现？这些问题通过 <code>Tween</code> 就会非常方便解决，直接上代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoPage</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  Animation _scaleAnimation; <span class="comment">// 用于控制图标大小</span></span><br><span class="line">  Animation&lt;Color&gt; _colorAnimation; <span class="comment">// 控制图标颜色</span></span><br><span class="line">  Animation&lt;Offset&gt; _positionAnimation; <span class="comment">// 控制图标位置</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _animationController = AnimationController(vsync: <span class="keyword">this</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当动画值发生变化的时候，重绘下 icon</span></span><br><span class="line">    _animationController.addListener(() &#123;</span><br><span class="line">      setState(() &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _animationController.addStatusListener((status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_animationController.status == AnimationStatus.completed)</span><br><span class="line">        _animationController.reverse();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_animationController.status == AnimationStatus.dismissed) _animationController.forward();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 通过 `chain` 结合 `CurveTween` 修改动画的运动方式，曲线类型可自行替换</span></span><br><span class="line">    _scaleAnimation =</span><br><span class="line">        Tween(begin: <span class="number">28.0</span>, end: <span class="number">50.0</span>).chain(CurveTween(curve: Curves.decelerate)).animate(_animationController);</span><br><span class="line"></span><br><span class="line">    _colorAnimation = ColorTween(begin: Colors.red[<span class="number">200</span>], end: Colors.red[<span class="number">900</span>])</span><br><span class="line">        .chain(CurveTween(curve: Curves.easeIn))</span><br><span class="line">        .animate(_animationController);</span><br><span class="line"></span><br><span class="line">    _positionAnimation = Tween(begin: Offset(<span class="number">100</span>, <span class="number">100</span>), end: Offset(<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line">        .chain(CurveTween(curve: Curves.bounceInOut))</span><br><span class="line">        .animate(_animationController);</span><br><span class="line"></span><br><span class="line">    _animationController.forward(); <span class="comment">// 启动动画</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Animation Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Stack(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Positioned(</span><br><span class="line">            child: Icon(Icons.favorite, color: _colorAnimation.value, size: _scaleAnimation.value),</span><br><span class="line">            left: _positionAnimation.value.dx,</span><br><span class="line">            top: _positionAnimation.value.dy,</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么最后的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-977e7de1b224aa58.gif" alt=""></p><p>当然，<code>Flutter</code> 中已经实现的 <code>Tween</code> 还有很多，包括 <code>BorderTween</code>、<code>TextStyleTween</code>、<code>ThemeDataTween</code> ..等等，实现的方式都是类似的，小伙伴们可以自己慢慢看。</p><h4 id="AnimationWidget"><a href="#AnimationWidget" class="headerlink" title="AnimationWidget"></a>AnimationWidget</h4><p>在上面的例子中，都是通过 <code>addListener</code> 监听动画值变化，然后通过 <code>setState</code> 方法来实现刷新效果。那么 <code>Flutter</code> 也提供了一个部件 <code>AnimationWidget</code> 来实现动画部件，就不需要一直监听了，还是实现上面的例子</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunningHeart</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Animation&gt; animations; <span class="comment">// 传入动画列表</span></span><br><span class="line">  <span class="keyword">final</span> AnimationController animationController; <span class="comment">// 控制动画</span></span><br><span class="line"></span><br><span class="line">  RunningHeart(&#123;<span class="keyword">this</span>.animations, <span class="keyword">this</span>.animationController&#125;)</span><br><span class="line">      <span class="comment">// 对传入的参数进行限制(当然你也可以不做限制)</span></span><br><span class="line">      : <span class="keyword">assert</span>(animations.length == <span class="number">3</span>),</span><br><span class="line">        <span class="keyword">assert</span>(animations[<span class="number">0</span>] <span class="keyword">is</span> Animation&lt;Color&gt;),</span><br><span class="line">        <span class="keyword">assert</span>(animations[<span class="number">1</span>] <span class="keyword">is</span> Animation&lt;<span class="built_in">double</span>&gt;),</span><br><span class="line">        <span class="keyword">assert</span>(animations[<span class="number">2</span>] <span class="keyword">is</span> Animation&lt;Offset&gt;),</span><br><span class="line">        <span class="keyword">super</span>(listenable: animationController);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Positioned(</span><br><span class="line">          <span class="comment">// 之前的 animation 都通过 animations 参数传入到 `AnimationWidget`</span></span><br><span class="line">          child: Icon(Icons.favorite, color: animations[<span class="number">0</span>].value, size: animations[<span class="number">1</span>].value),</span><br><span class="line">          left: animations[<span class="number">2</span>].value.dx,</span><br><span class="line">          top: animations[<span class="number">2</span>].value.dy,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实内部返回的部件和前面的是一样的</p><p>接着对 <code>_AnimationDemoPageState</code> 类进行修改，注释 <code>initState</code> 中的 <code>_animationController.addListener</code> 所有内容，然后将 <code>body</code> 属性替换成新建的 <code>RunningHeart</code> 部件，记得传入的动画列表的顺序</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: RunningHeart(</span><br><span class="line">        animations: [_colorAnimation, _scaleAnimation, _positionAnimation],</span><br><span class="line">        animationController: _animationController,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>这样就实现了刚才一样的效果，并且没有一直调用 <code>setState</code> 来刷新。</p><p><em>该部分代码查看 animation_main.dart 文件</em></p><h4 id="StaggeredAnimations"><a href="#StaggeredAnimations" class="headerlink" title="StaggeredAnimations"></a>StaggeredAnimations</h4><p><code>Flutter</code> 还提供了交错动画，听名字就可以知道，是按照时间轴，进行不同的动画，并且由同个<code>AnimationController</code> 进行控制。因为没有找到好的例子，原谅我直接搬官方的例子来讲，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fflutterchina.club%2Fanimations%2Fstaggered-animations%2F%23complete-staggered-animation" target="_blank" rel="noopener">官方交错动画 demo</a></p><p>在继续看之前，先了解下 <code>Interval</code></p><blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">/// An [Interval] can be used to delay an animation. For example, a six second</span></span><br><span class="line">&gt; <span class="comment">/// animation that uses an [Interval] with its [begin] set to 0.5 and its [end]</span></span><br><span class="line">&gt; <span class="comment">/// set to 1.0 will essentially become a three-second animation that starts</span></span><br><span class="line">&gt; <span class="comment">/// three seconds later.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>Interval</code> 用来延迟动画，例如一个时长 6s 的动画，通过 <code>Interval</code> 设置其 <code>begin</code> 参数为 0.5，<code>end</code> 参数设置为 1.0，那么这个动画就会变成 3s 的动画，并且开始的时间延迟了 3s。</p><p>了解 <code>Interval</code> 功能后，就可以看下实例了，当然我们不和官方的 demo 一样，中间加个旋转动画</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaggeredAnim</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AnimationController controller;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; opacity;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; width;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; height;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;EdgeInsets&gt; padding;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;BorderRadius&gt; border;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;Color&gt; color;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; rotate;</span><br><span class="line"></span><br><span class="line">  StaggeredAnim(&#123;Key key, <span class="keyword">this</span>.controller&#125;):</span><br><span class="line">        <span class="comment">// widget 透明度</span></span><br><span class="line">        opacity = Tween(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.0</span>, <span class="number">0.1</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 宽</span></span><br><span class="line">        width = Tween(begin: <span class="number">50.0</span>, end: <span class="number">150.0</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.1</span>, <span class="number">0.250</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 高</span></span><br><span class="line">        height = Tween(begin: <span class="number">50.0</span>, end: <span class="number">150.0</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.25</span>, <span class="number">0.375</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 底部距离</span></span><br><span class="line">        padding = EdgeInsetsTween(begin: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">150.0</span>), end: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">.0</span>))</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.25</span>, <span class="number">0.375</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 旋转</span></span><br><span class="line">        rotate = Tween(begin: <span class="number">0.0</span>, end: <span class="number">0.25</span>)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.375</span>, <span class="number">0.5</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 外形</span></span><br><span class="line">        border = BorderRadiusTween(begin: BorderRadius.circular(<span class="number">5.0</span>), end: BorderRadius.circular(<span class="number">75.0</span>))</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.5</span>, <span class="number">0.75</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="comment">// widget 颜色</span></span><br><span class="line">        color = ColorTween(begin: Colors.blue, end: Colors.orange)</span><br><span class="line">            .animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.75</span>, <span class="number">1.0</span>, curve: Curves.ease))),</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  Widget _buildAnimWidget(BuildContext context, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      padding: padding.value,</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      <span class="comment">// 旋转变化</span></span><br><span class="line">      child: RotationTransition(</span><br><span class="line">        turns: rotate, <span class="comment">// turns 表示当前动画的值 * 360° 角度</span></span><br><span class="line">        child: Opacity(</span><br><span class="line">          opacity: opacity.value, <span class="comment">// 透明度变化</span></span><br><span class="line">          child: Container(</span><br><span class="line">            width: width.value, <span class="comment">// 宽度变化</span></span><br><span class="line">            height: height.value, <span class="comment">// 高度变化</span></span><br><span class="line">            decoration: BoxDecoration(</span><br><span class="line">                color: color.value, <span class="comment">// 颜色变化</span></span><br><span class="line">                border: Border.all(color: Colors.indigo[<span class="number">300</span>], width: <span class="number">3.0</span>),</span><br><span class="line">                borderRadius: border.value), <span class="comment">// 外形变化</span></span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// AnimatedBuilder 继承 AnimationWidget，用来快速构建动画部件</span></span><br><span class="line">    <span class="keyword">return</span> AnimatedBuilder(animation: controller, builder: _buildAnimWidget);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>body</code> 的参数，设置成我们的动画，当点击的时候就会启动动画</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">    behavior: HitTestBehavior.opaque,</span><br><span class="line">    onTap: _playAnim,</span><br><span class="line">    child: Center(</span><br><span class="line">      <span class="comment">// 定义一个外层圈，能够使动画显眼点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        width: <span class="number">300</span>,</span><br><span class="line">        height: <span class="number">300</span>,</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: Colors.black.withOpacity(<span class="number">0.1</span>), border: Border.all(color: Colors.black.withOpacity(<span class="number">0.5</span>))),</span><br><span class="line">        child: StaggeredAnim(controller: _controller),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>看下最后的效果吧</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-329d48585eee04b4.gif" alt=""></p><p><em>该部分代码查看 staggered_animation_main.dart 文件</em></p><p>结束前，我们再讲一种比较简单的 <code>Hreo</code> 动画，用来过渡用。</p><h4 id="Hero"><a href="#Hero" class="headerlink" title="Hero"></a>Hero</h4><p>通过指定 <code>Hero</code> 中的 <code>tag</code>，在切换的时候 <code>Hero</code> 会寻找相同的 <code>tag</code>，并实现动画，具体的实现逻辑，这里可以推荐一篇文章 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fyumi0629%2Farticle%2Fdetails%2F83176911" target="_blank" rel="noopener">谈一谈Flutter中的共享元素动画Hero</a>，里面写的很详细，就不造车轮了。当然这边还是得提供个简单的 demo 的，替换前面的 <code>body</code> 参数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: InkWell(</span><br><span class="line">          child: Hero(</span><br><span class="line">            tag: <span class="string">'hero_tag'</span>, <span class="comment">// 这里指定 tag</span></span><br><span class="line">            child: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">100.0</span>, height: <span class="number">100.0</span>),</span><br><span class="line">          ),</span><br><span class="line">          onTap: () =&gt; Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; HeroPage())),</span><br><span class="line">        ),</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>然后创建 <code>HeroPage</code> 界面，当然也可以是个 <code>Dialog</code>，只要通过路由实现即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: InkWell(</span><br><span class="line">          child: Hero(tag: <span class="string">'hero_tag'</span>, child: Image.asset(<span class="string">'images/ali.jpg'</span>, width: <span class="number">200.0</span>, height: <span class="number">200.0</span>)),</span><br><span class="line">          onTap: () =&gt; Navigator.pop(context),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下最后的效果图：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-b20a401615f8acde.gif" alt=""></p><p><em>该部分代码查看 animation_main.dart 文件</em></p><p>这一部分讲的比较多，小伙伴可以慢慢消化，下节我会尽量填下之前留下的状态管理的坑。</p><p>最后代码的地址还是要的：</p><ol><li>文章中涉及的代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_arts_demos_app" target="_blank" rel="noopener">demos</a></li><li>基于郭神 <code>cool weather</code> 接口的一个项目，实现 <code>BLoC</code> 模式，实现状态管理：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_weather" target="_blank" rel="noopener">flutter_weather</a></li><li>一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkukyxs%2Fflutter_shop" target="_blank" rel="noopener">flutter_shop</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;Flutter&lt;/code&gt; 中，自带手势监听的目前为止好像只有按钮部件和一些 &lt;code&gt;chip&lt;/code&gt; 部件，例如 &lt;code&gt;Text&lt;/code&gt; 等部件需要实现手势监听，就需要借助带有监听事件的部件来实现了，这节我们会讲下 &lt;code&gt;InkWell&lt;/code&gt; 和 &lt;code&gt;GestureDetector&lt;/code&gt; 来实现手势的监听。&lt;/p&gt;
&lt;h4 id=&quot;InkWell&quot;&gt;&lt;a href=&quot;#InkWell&quot; class=&quot;headerlink&quot; title=&quot;InkWell&quot;&gt;&lt;/a&gt;InkWell&lt;/h4&gt;&lt;p&gt;在前面的一些例子中，小伙伴应该看到了好几次 &lt;code&gt;InkWell&lt;/code&gt; 这个部件，通过它我们可以实现对一些手势的监听，并实现 &lt;code&gt;MD&lt;/code&gt; 的水波纹效果，举个简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;InkWell(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  child: Text(&lt;span class=&quot;string&quot;&gt;&#39;点我...点我...我能响应点击手势&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  onTap: () =&amp;gt; &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;啊...我被点击了...&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;),&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么当点击 &lt;code&gt;Text&lt;/code&gt; 的时候就会响应点击事件，控制台输出日志&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(九)之弹窗和提示(SnackBar、BottomSheet、Dialog)</title>
    <link href="https://zhangmiao.cc/posts/5da6faeb.html"/>
    <id>https://zhangmiao.cc/posts/5da6faeb.html</id>
    <published>2019-04-27T03:30:42.000Z</published>
    <updated>2019-05-27T07:03:53.115Z</updated>
    
    <content type="html"><![CDATA[<p>前面的小节把常用的一些部件都介绍了，这节介绍下 <code>Flutter</code> 中的一些操作提示。<code>Flutter</code> 中的操作提示主要有这么几种 <code>SnackBar</code>、<code>BottomSheet</code>、<code>Dialog</code>，因为 <code>Dialog</code> 样式比较多，放最后讲好了</p><h4 id="SnackBar"><a href="#SnackBar" class="headerlink" title="SnackBar"></a>SnackBar</h4><p><code>SnackBar</code> 的源码相对简单</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SnackBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.content, <span class="comment">// 提示信息</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor, <span class="comment">// 背景色</span></span><br><span class="line">    <span class="keyword">this</span>.action, <span class="comment">// SnackBar 尾部的按钮，用于一些回退操作等</span></span><br><span class="line">    <span class="keyword">this</span>.duration = _kSnackBarDisplayDuration, <span class="comment">// 停留的时长，默认 4000ms</span></span><br><span class="line">    <span class="keyword">this</span>.animation, <span class="comment">// 进出动画</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>例如我们需要实现一个功能，修改某个值，修改后给用户一个提示，同时给用户一个撤销该操作的按钮，那么就可以通过 <code>SnackBar</code> 来简单实现。还有就是 <code>SnackBar</code> 可以和 <code>floatingActionButton</code> 完美的配合，弹出的时候不会遮挡住 <code>fab</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PromptDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">PromptDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自增操作</span></span><br><span class="line">  increase() &#123;</span><br><span class="line">    setState(() =&gt; count++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自减操作</span></span><br><span class="line">  decrease() &#123;</span><br><span class="line">    setState(() =&gt; count--);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _changeValue(BuildContext context) &#123;</span><br><span class="line">    increase();</span><br><span class="line">    Scaffold.of(context).showSnackBar(SnackBar(</span><br><span class="line">        content: Text(<span class="string">'当前值已修改'</span>),</span><br><span class="line">        action: SnackBarAction(label: <span class="string">'撤销'</span>, onPressed: decrease),</span><br><span class="line">        duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Prompt Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'当前值：$count'</span>, style: TextStyle(fontSize: <span class="number">20.0</span>)),</span><br><span class="line">        Expanded(</span><br><span class="line">            <span class="comment">// 为了方便拓展，我这边提取了 `snackBar` 的方法，并把按钮放在列表</span></span><br><span class="line">            child: ListView(padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">8.0</span>), children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// SnackBar 需要提供一个包含 context，但是 context 不能是 Scaffold 节点下的 context，所以需要通过 Builder 包裹一层</span></span><br><span class="line">          Builder(builder: (context) =&gt; RaisedButton(onPressed: () =&gt; _changeValue(context), child: Text(<span class="string">'修改当前值'</span>))),</span><br><span class="line">        ]))</span><br><span class="line">      ]),</span><br><span class="line">      <span class="comment">// 当 SnackBar 弹出时，fab 会上移一段距离</span></span><br><span class="line">      floatingActionButton: Builder(</span><br><span class="line">          builder: (context) =&gt; FloatingActionButton(onPressed: () =&gt; _changeValue(context), child: Icon(Icons.send))),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看下最后的效果图，请注意看 <code>fab</code> 和值的变化：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-da29f7ede96f2215.gif" alt=""></p><h4 id="BottomSheet"><a href="#BottomSheet" class="headerlink" title="BottomSheet"></a>BottomSheet</h4><p><code>BottomSheet</code> 看命名就知道是从底部弹出的菜单，展示 <code>BottomSheet</code> 有两种方式，分别是 <code>showBottomSheet</code> 和 <code>showModalBottomSheet</code>，两种方式只有在展示类型上的差别，方法调用无差，而且 <code>showBottomSheet</code> 和 <code>fab</code> 有组合动画，<code>showModalBottomSheet</code> 则没有，看下实际的例子吧。在 <code>ListView</code> 中增加一个 <code>BottomSheet</code> 的按钮，因为 <code>BottomSheet</code> 需要的 <code>context</code> 也不能是 <code>Scaffold</code> 下的 <code>context</code>，所以需要通过 <code>Builder</code> 进行包裹一层，然后增加 <code>_showBottomSheet</code> 的方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showBottomSheet(BuildContext context) &#123;</span><br><span class="line">   showBottomSheet(</span><br><span class="line">     context: context,</span><br><span class="line">     builder: (context) =&gt; ListView(</span><br><span class="line">             <span class="comment">// 生成一个列表选择器</span></span><br><span class="line">             children: <span class="built_in">List</span>.generate(</span><br><span class="line">           <span class="number">20</span>,</span><br><span class="line">           (index) =&gt; InkWell(</span><br><span class="line">               child: Container(alignment: Alignment.center, height: <span class="number">60.0</span>, child: Text(<span class="string">'Item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>)),</span><br><span class="line">               onTap: () &#123;</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">'tapped item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>);</span><br><span class="line">                 Navigator.pop(context);</span><br><span class="line">               &#125;),</span><br><span class="line">         )),</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>把 <code>showBottomSheet</code> 替换成 <code>showModalBottomSheet</code> 就是另外一种展示方式了，内部不需要做任何改变，我们看下两种的运行效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-70e344e56f98f683.gif" alt=""></p><p>可以看到 <code>showBottomSheet</code> 会充满整个屏幕，然后 <code>fab</code> 会跟随一起到 <code>AppBar</code> 的底部位置，而 <code>showModalBottomSheet</code> 展示的高度不会超过半个屏幕的高度，但是 <code>fab</code> 被其遮挡了。假如我们只需要展示 2-3 个 <code>item</code>，但是按照刚才的方式 <code>showModalBottomSheet</code> 的高度太高了，那我们可以在 <code>ListView</code> 外层包裹一层 <code>Container</code>，然后指定 <code>height</code> 即可</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showModalBottomSheet(BuildContext context) &#123;</span><br><span class="line">    showModalBottomSheet(</span><br><span class="line">      context: context,</span><br><span class="line">      builder: (context) =&gt; Container(</span><br><span class="line">            child: ListView(</span><br><span class="line">                children: <span class="built_in">List</span>.generate(</span><br><span class="line">              <span class="number">2</span>,</span><br><span class="line">              (index) =&gt; InkWell(</span><br><span class="line">                  child: Container(alignment: Alignment.center, height: <span class="number">60.0</span>, child: Text(<span class="string">'Item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>)),</span><br><span class="line">                  onTap: () &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">'tapped item <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>);</span><br><span class="line">                    Navigator.pop(context);</span><br><span class="line">                  &#125;),</span><br><span class="line">            )),</span><br><span class="line">            height: <span class="number">120</span>,</span><br><span class="line">          ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>修改高度后的效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-51e8092d6a0e879b.gif" alt=""></p><h4 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h4><p>相对于 <code>SnackBar</code> 和 <code>BottomSheet</code>，<code>Dialog</code> 的使用场景相对会更多，在 <code>MaterialDesign</code> 下，<code>Dialog</code> 主要有 3 种：<code>AlertDialog</code>，<code>SimpleDialog</code> 和 <code>AboutDialog</code>，当然在 <code>Cupertino</code> 风格下也有相应的 <code>Dialog</code>，因为这个系列以 <code>MaterialDesign</code> 风格为主，所以 <code>Cupertiono</code> 等下次有时间再写吧。</p><h5 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h5><p>在 <code>ListView</code> 中增加一个 <code>AlertDialog</code> 的按钮，用于点击显示 <code>AlertDialog</code> 用，然后加入显示 <code>AlertDilaog</code> 的方法，并将按钮的 <code>onPressed</code> 指向该方法，<code>Dialog</code> 的 <code>context</code> 可以是 <code>Scaffold</code> 下的 <code>context</code>，所以不需要用 <code>Builder</code> 来包裹一层。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showAlertDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 设置点击 dialog 外部不取消 dialog，默认能够取消</span></span><br><span class="line">        barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt; AlertDialog(</span><br><span class="line">              title: Text(<span class="string">'我是个标题...嗯，标题..'</span>),</span><br><span class="line">              titleTextStyle: TextStyle(color: Colors.purple), <span class="comment">// 标题文字样式</span></span><br><span class="line">              content: Text(<span class="string">r'我是内容\(^o^)/~, 我是内容\(^o^)/~, 我是内容\(^o^)/~'</span>),</span><br><span class="line">              contentTextStyle: TextStyle(color: Colors.green), <span class="comment">// 内容文字样式</span></span><br><span class="line">              backgroundColor: CupertinoColors.white,</span><br><span class="line">              elevation: <span class="number">8.0</span>, <span class="comment">// 投影的阴影高度</span></span><br><span class="line">              semanticLabel: <span class="string">'Label'</span>, <span class="comment">// 这个用于无障碍下弹出 dialog 的提示</span></span><br><span class="line">              shape: Border.all(),</span><br><span class="line">              <span class="comment">// dialog 的操作按钮，actions 的个数尽量控制不要过多，否则会溢出 `Overflow`</span></span><br><span class="line">              actions: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 点击增加显示的值</span></span><br><span class="line">                FlatButton(onPressed: increase, child: Text(<span class="string">'点我增加'</span>)),</span><br><span class="line">                <span class="comment">// 点击减少显示的值</span></span><br><span class="line">                FlatButton(onPressed: decrease, child: Text(<span class="string">'点我减少'</span>)),</span><br><span class="line">                <span class="comment">// 点击关闭 dialog，需要通过 Navigator 进行操作</span></span><br><span class="line">                FlatButton(onPressed: () =&gt; Navigator.pop(context), </span><br><span class="line">                           child: Text(<span class="string">'你点我试试.'</span>)),</span><br><span class="line">              ],</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后看下效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-dd8dc81b43e02e44.gif" alt=""></p><h5 id="SimpleDialog"><a href="#SimpleDialog" class="headerlink" title="SimpleDialog"></a>SimpleDialog</h5><p><code>SimpleDialog</code> 相比于 <code>AlertDialog</code> 少了 <code>content</code> 和 <code>action</code> 参数，多了 <code>children</code> 属性，需要传入 <code>Widget</code> 列表，那就可以自定义全部内容了。那我们这里就实现一个性别选择的 <code>Dialog</code>，选择后通过 <code>Taost</code> 提示选择的内容，<code>Taost</code> 就是之前导入的第三方插件，先看下效果图吧</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-a9dd6de23478249e.gif" alt=""></p><p>只要实现 <code>children</code> 是个列表选择器就可以了，比较简单，直接上代码</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showSimpleDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt; SimpleDialog(</span><br><span class="line">              title: Text(<span class="string">'我是个比较正经的标题...\n选择你的性别'</span>),</span><br><span class="line">              <span class="comment">// 这里传入一个选择器列表即可</span></span><br><span class="line">              children: _genders</span><br><span class="line">                  .map((gender) =&gt; InkWell(</span><br><span class="line">                        child: Container(height: <span class="number">40.0</span>, child: Text(gender), alignment: Alignment.center),</span><br><span class="line">                        onTap: () &#123;</span><br><span class="line">                          Navigator.pop(context);</span><br><span class="line">                          Fluttertoast.showToast(msg: <span class="string">'你选择的性别是 $gender'</span>);</span><br><span class="line">                        &#125;,</span><br><span class="line">                      ))</span><br><span class="line">                  .toList(),</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="AboutDialog"><a href="#AboutDialog" class="headerlink" title="AboutDialog"></a>AboutDialog</h5><p><code>AboutDialog</code> 主要是用于展示你的 <code>App</code> 或者别的相关东西的内容信息的，平时用的比较少，显示 <code>AboutDialog</code> 有两种方式可以展示，一种是前面一样的 <code>showDialog</code> 方法，传入一个 <code>AboutDialog</code> 实例，还有中方法是直接调用 <code>showAboutDialog</code> 方法。我们还是一样在列表加个按钮，并指向显示 <code>AboutDialog</code> 的事件。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showAboutDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt; AboutDialog(</span><br><span class="line">              <span class="comment">// App 的名字</span></span><br><span class="line">              applicationName: <span class="string">'Flutter 入门指北'</span>,</span><br><span class="line">              <span class="comment">// App 的版本号</span></span><br><span class="line">              applicationVersion: <span class="string">'0.1.1'</span>,</span><br><span class="line">              <span class="comment">// App 基本信息下面会显示一行小字，主要用来显示版权信息</span></span><br><span class="line">              applicationLegalese: <span class="string">'Copyright: this is a copyright notice topically'</span>,</span><br><span class="line">              <span class="comment">// App 的图标</span></span><br><span class="line">              applicationIcon: Icon(Icons.android, size: <span class="number">28.0</span>, color: CupertinoColors.activeBlue),</span><br><span class="line">              <span class="comment">// 任何你想展示的</span></span><br><span class="line">              children: &lt;Widget&gt;[Text(<span class="string">'我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)'</span>)],</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也可以通过 <code>showAboutDialog</code> 实现同样的效果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showAboutDialog() &#123;</span><br><span class="line">  showAboutDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    applicationName: <span class="string">'Flutter 入门指北'</span>,</span><br><span class="line">    applicationVersion: <span class="string">'0.1.1'</span>,</span><br><span class="line">    applicationLegalese: <span class="string">'Copyright: this is a copyright notice topically'</span>,</span><br><span class="line">    applicationIcon: Image.asset(<span class="string">'images/app_icon.png'</span>, width: <span class="number">40.0</span>, height: <span class="number">40.0</span>),</span><br><span class="line">    children: &lt;Widget&gt;[Text(<span class="string">'我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)'</span>)],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-692a6d8b1b1b2ad1.gif" alt=""></p><p><code>AboutDialog</code> 会自带两个按钮 <code>VIEW LICENSES</code> 和 <code>CLOSE</code>，<code>VIEW LICENSES</code> 会跳转一个 <code>Flutter Licenses</code> 的网页，<code>CLOSE</code> 会关闭，至于为什么是英文的，是因为我们没有设置语言的原因，这个涉及到多语言，这边推荐几篇之前看过的文章，如果下次有时间的话会单独拿出来讲下</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.didierboelens.com%2F2018%2F04%2Finternationalization---make-an-flutter-application-multi-lingual%2F" target="_blank" rel="noopener">英文原版多语言设置，介绍两种方式实现</a></p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fyumi0629%2Farticle%2Fdetails%2F81873141" target="_blank" rel="noopener">国人翻译版，未持续更新第二种方式</a></p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5c701379f265da2d9b5e196a" target="_blank" rel="noopener">使用插件 in18 版</a></p><p>这边为了支持中文，我们做下如下的修改，首先打开 <code>pubspec.ymal</code> 文件加入如下支持</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522113832.png" alt=""></p><p><code>get package</code> 后给 <code>MaterialApp</code> 加入如下属性，这样就会支持中文了，这里需要导入包 <code>package:flutter_localizations/flutter_localizations.dart</code>，再次运行，就会发现之前的英文变成中文了，当然你也可以设置成别的语言。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522113849.png" alt=""></p><h4 id="Dialog-状态保持"><a href="#Dialog-状态保持" class="headerlink" title="Dialog 状态保持"></a>Dialog 状态保持</h4><p>假如有个需求，需要在弹出的 <code>Dialog</code> 显示当前被改变的值，然后通过按钮可以修改这个值 ，该如何实现。相信很多小伙伴都会这么认为，通过 <code>setState</code> 来修改不就行了吗，没错，我一开始的确这么去实现的，我们先看下代码好了，增加一个 <code>DialogState</code> 按钮，然后指向对应的点击事件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_showStateDialog() &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        context: context,</span><br><span class="line">        barrierDismissible: false,</span><br><span class="line">        builder: (context) =&gt; SimpleDialog(</span><br><span class="line">              title: Text(&apos;我这边能实时修改状态值&apos;),</span><br><span class="line">              contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Text(&apos;当前的值是： $_count&apos;, style: TextStyle(fontSize: 18.0)),</span><br><span class="line">                Padding(</span><br><span class="line">                  padding: const EdgeInsets.symmetric(vertical: 12.0),</span><br><span class="line">                  child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                      onPressed: increase,</span><br><span class="line">                      child: Text(&apos;点我自增&apos;),</span><br><span class="line">                    ),</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                      onPressed: decrease,</span><br><span class="line">                      child: Text(&apos;点我自减&apos;),</span><br><span class="line">                    ),</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                      onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                      child: Text(&apos;点我关闭&apos;),</span><br><span class="line">                    )</span><br><span class="line">                  ]),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后我们运行看下</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-b90b21ff3cca2241.gif" alt=""></p><p>诶诶诶，怎么 <code>Dialog</code> 的值不改变呢，明明界面上的已经修改了啊。所以说图样图森破咯，看下官方对 <code>showDialog</code> 方法的解释吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This function takes a `builder` which typically builds a [Dialog] widget.</span></span><br><span class="line"><span class="comment">// Content below the dialog is dimmed with a [ModalBarrier]. The widget</span></span><br><span class="line"><span class="comment">// returned by the `builder` does not share a context with the location that</span></span><br><span class="line"><span class="comment">// `showDialog` is originally called from. Use a [StatefulBuilder] or a</span></span><br><span class="line"><span class="comment">// custom [StatefulWidget] if the dialog needs to update dynamically.</span></span><br></pre></td></tr></table></figure><p>糟糕透的翻译又来了：该方法通过 <code>builder</code> 参数来传入一个 <code>Dialog</code> 部件，<code>dialog</code> 下的内容被一个「模态障碍」阻隔，<code>builder</code> 的 <code>context</code> 和调用 <code>showDialog</code> 时候的 <code>context</code> 不是共享的，如果需要动态修改 <code>dialog</code> 的状态值，需要通过 <code>StatefulBuilder</code> 或者自定义 <code>dialog</code> 继承于 <code>StatefulWidget</code> 来实现</p><p>所以解决的方法很明确，对上面的代码进行修改，在外层嵌套一个 <code>StatefulBuilder</code> 部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_showStateDialog() &#123;</span><br><span class="line">   showDialog(</span><br><span class="line">       context: context,</span><br><span class="line">       barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">       <span class="comment">// 通过 StatefulBuilder 来保存 dialog 状态</span></span><br><span class="line">       <span class="comment">// builder 需要传入一个 BuildContext 和 StateSetter 类型参数</span></span><br><span class="line">       <span class="comment">// StateSetter 有一个 VoidCallback，修改状态的方法在这写</span></span><br><span class="line">       builder: (context) =&gt; StatefulBuilder(</span><br><span class="line">           builder: (context, dialogStateState) =&gt; SimpleDialog(</span><br><span class="line">                 title: Text(<span class="string">'我这边能实时修改状态值'</span>),</span><br><span class="line">                 contentPadding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">12.0</span>, vertical: <span class="number">8.0</span>),</span><br><span class="line">                 children: &lt;Widget&gt;[</span><br><span class="line">                   Text(<span class="string">'当前的值是： $_count'</span>, style: TextStyle(fontSize: <span class="number">18.0</span>)),</span><br><span class="line">                   Padding(</span><br><span class="line">                     padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">12.0</span>),</span><br><span class="line">                     child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[</span><br><span class="line">                       RaisedButton(</span><br><span class="line">                         <span class="comment">// 通过 StatefulBuilder 的 StateSetter 来修改值</span></span><br><span class="line">                         onPressed: () =&gt; dialogStateState(() =&gt; increase()),</span><br><span class="line">                         child: Text(<span class="string">'点我自增'</span>),</span><br><span class="line">                       ),</span><br><span class="line">                       RaisedButton(</span><br><span class="line">                         onPressed: () =&gt; dialogStateState(() =&gt; decrease()),</span><br><span class="line">                         child: Text(<span class="string">'点我自减'</span>),</span><br><span class="line">                       ),</span><br><span class="line">                       RaisedButton(</span><br><span class="line">                         onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                         child: Text(<span class="string">'点我关闭'</span>),</span><br><span class="line">                       )</span><br><span class="line">                     ]),</span><br><span class="line">                   )</span><br><span class="line">                 ],</span><br><span class="line">               )));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后再运行下，可以看到 <code>dialog</code> 和界面的值保持一致了</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/2888797-fe488a85d5276b4c.gif" alt=""></p><p><em>以上部分代码查看 prompt_main.dart 文件</em></p><p>差不多常用弹窗和操作提示就在这了，好好消化吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的小节把常用的一些部件都介绍了，这节介绍下 &lt;code&gt;Flutter&lt;/code&gt; 中的一些操作提示。&lt;code&gt;Flutter&lt;/code&gt; 中的操作提示主要有这么几种 &lt;code&gt;SnackBar&lt;/code&gt;、&lt;code&gt;BottomSheet&lt;/code&gt;、&lt;code&gt;Dialog&lt;/code&gt;，因为 &lt;code&gt;Dialog&lt;/code&gt; 样式比较多，放最后讲好了&lt;/p&gt;
&lt;h4 id=&quot;SnackBar&quot;&gt;&lt;a href=&quot;#SnackBar&quot; class=&quot;headerlink&quot; title=&quot;SnackBar&quot;&gt;&lt;/a&gt;SnackBar&lt;/h4&gt;&lt;p&gt;&lt;code&gt;SnackBar&lt;/code&gt; 的源码相对简单&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SnackBar(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@required&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.content, &lt;span class=&quot;comment&quot;&gt;// 提示信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.backgroundColor, &lt;span class=&quot;comment&quot;&gt;// 背景色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.action, &lt;span class=&quot;comment&quot;&gt;// SnackBar 尾部的按钮，用于一些回退操作等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.duration = _kSnackBarDisplayDuration, &lt;span class=&quot;comment&quot;&gt;// 停留的时长，默认 4000ms&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.animation, &lt;span class=&quot;comment&quot;&gt;// 进出动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门指南(八)之Sliver组件及NestedScrollView</title>
    <link href="https://zhangmiao.cc/posts/f600e8a7.html"/>
    <id>https://zhangmiao.cc/posts/f600e8a7.html</id>
    <published>2019-04-26T02:57:48.000Z</published>
    <updated>2019-05-27T07:03:44.066Z</updated>
    
    <content type="html"><![CDATA[<p>上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去</p><p>在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。</p><h3 id="SliverAppBar"><a href="#SliverAppBar" class="headerlink" title="SliverAppBar"></a>SliverAppBar</h3><p>相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverAppBar(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.leading,</span><br><span class="line"><span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">this</span>.title,</span><br><span class="line"><span class="keyword">this</span>.actions,</span><br><span class="line"><span class="keyword">this</span>.flexibleSpace, <span class="comment">// 通过这个来设置背景</span></span><br><span class="line"><span class="keyword">this</span>.bottom,</span><br><span class="line"><span class="keyword">this</span>.elevation,</span><br><span class="line"><span class="keyword">this</span>.forceElevated = <span class="keyword">false</span>, <span class="comment">// 是否显示层次感</span></span><br><span class="line"><span class="keyword">this</span>.backgroundColor,</span><br><span class="line"><span class="keyword">this</span>.brightness,</span><br><span class="line"><span class="keyword">this</span>.iconTheme,</span><br><span class="line"><span class="keyword">this</span>.textTheme,</span><br><span class="line"><span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">this</span>.centerTitle,</span><br><span class="line"><span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line"><span class="keyword">this</span>.expandedHeight, <span class="comment">// 展开的高度</span></span><br><span class="line"><span class="comment">// 以下三个等例子再讲</span></span><br><span class="line"><span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span><br><span class="line"><span class="keyword">this</span>.pinned = <span class="keyword">false</span>,</span><br><span class="line"><span class="keyword">this</span>.snap = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件</p><a id="more"></a><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: CustomScrollView(slivers: &lt;Widget&gt;[</span><br><span class="line">SliverAppBar(</span><br><span class="line">title: Text(<span class="string">'Sliver Demo'</span>),</span><br><span class="line">centerTitle: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 展开的高度</span></span><br><span class="line">expandedHeight: <span class="number">300.0</span>,</span><br><span class="line"><span class="comment">// 强制显示阴影</span></span><br><span class="line">forceElevated: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 设置该属性，当有下滑手势的时候，就会显示 AppBar</span></span><br><span class="line"><span class="comment">// floating: true,</span></span><br><span class="line"><span class="comment">// 该属性只有在 floating 为 true 的情况下使用，不然会报错</span></span><br><span class="line"><span class="comment">// 当上滑到一定的比例，会自动把 AppBar 收缩（不知道是不是 bug，当 AppBar 下面的部件没有被 AppBar 覆盖的时候，不会自动收缩）</span></span><br><span class="line"><span class="comment">// 当下滑到一定比例，会自动把 AppBar 展开</span></span><br><span class="line"><span class="comment">// snap: true,</span></span><br><span class="line"><span class="comment">// 设置该属性使 Appbar 折叠后不消失</span></span><br><span class="line"><span class="comment">// pinned: true,</span></span><br><span class="line"><span class="comment">// 通过这个属性设置 AppBar 的背景</span></span><br><span class="line">flexibleSpace: FlexibleSpaceBar(</span><br><span class="line"><span class="comment">// title: Text('Expanded Title'),</span></span><br><span class="line"><span class="comment">// 背景折叠动画</span></span><br><span class="line">collapseMode: CollapseMode.parallax,</span><br><span class="line">background: Image.asset(<span class="string">'images/timg.jpg'</span>, fit: BoxFit.cover),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，</span></span><br><span class="line"><span class="comment">// 可以在 child 属性加入需要展示的部件</span></span><br><span class="line">SliverFillRemaining(</span><br><span class="line">child: Center(child: Text(<span class="string">'FillRemaining'</span>, style: TextStyle(fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br><span class="line">]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分别给出不同的动图来查看三个属性的影响</p><p>如果设置了 floating 属性，当有下拉动作时，会显示 AppBar</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/a2.gif" alt=""></p><p>如果设置了 snap 属性，滑动距离达到一定值后，会根据滑动方向收缩或者展开</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111020.gif" alt=""></p><p>如果设置了 pinned 属性，那么 AppBar 就会在界面上不会消失</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111101.gif" alt=""></p><p>以上的效果图把 SliverFillRemaining 换成列表 SliverFixedExtentList 效果可能会更加明显，这边给小伙伴自己替换测试吧。</p><h3 id="SliverFillViewport"><a href="#SliverFillViewport" class="headerlink" title="SliverFillViewport"></a>SliverFillViewport</h3><p>这边提到了 SliverFillRemaining 用来填充视图，那么顺带提下 SliverFillViewport 这个部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverFillViewport(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="meta">@required</span> SliverChildDelegate delegate, <span class="comment">// 这个 delegate 同 SliverGrid</span></span><br><span class="line"><span class="keyword">this</span>.viewportFraction = <span class="number">1.0</span>, <span class="comment">// 同屏幕的比例值，1.0 为一个屏幕大小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果一个滑动列表，每个 item 需要占满一个屏幕或者更大，可以使用该部件生成列表，但是如果 item 的高度小于一个屏幕高度，那就不太推荐了，在首尾会用空白 item 来把未填满的补上，就是首尾都会留空白。我们使用 SliverFillViewport 对 SliverFillRemaning 进行替换</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverFillViewport(</span><br><span class="line">viewportFraction: <span class="number">1.0</span>,</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Container(child: Text(<span class="string">'Item $index'</span>), alignment: Alignment.center, color: colors[index % <span class="number">4</span>]),</span><br><span class="line">childCount: <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>效果就不展示了，可自行运行查看。</p><h3 id="SliverToBoxAdapter"><a href="#SliverToBoxAdapter" class="headerlink" title="SliverToBoxAdapter"></a>SliverToBoxAdapter</h3><p>还记得上节最后的代码中，有使用 SliverToBoxAdapter 这个部件吗，这个部件只需要传入一个 child 属性。因为在 CustomScrollView 中只允许传入 Sliver 部件，那么类似 Container 等普通部件就不可以使用了，那么这样就需要更多的 Sliver 组件才能完成视图，所以为了方便，直接通过 SliverToBoxAdapter 对普通部件进行包裹，这样就成为一个 Sliver 部件了。总结下 SliverToBoxAdapter 的功能就是 把一个普通部件包裹成为 Sliver 部件，例子就不举了，上节已经有了。</p><h3 id="SliverPadding"><a href="#SliverPadding" class="headerlink" title="SliverPadding"></a>SliverPadding</h3><p>那么在 CustomScrollView 中部件之间如何设置间距呢，可能你会想到用 SliverToBoxAdapter 包裹一个 Padding 来处理，当然没问题。不过 Flutter 也提供了专门的部件 SliverPadding 使用方式同 Padding，但是需要传入一个 sliver 作为子类。</p><h3 id="SliverPersistentHeader"><a href="#SliverPersistentHeader" class="headerlink" title="SliverPersistentHeader"></a>SliverPersistentHeader</h3><p>Flutter 中，为我们提供了这么一个作为头部的部件 SliverPersistentHeader，这个部件可以根据滚动的距离缩小高度，有点类似 SliverAppBar 的背景效果。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverPersistentHeader(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="meta">@required</span> <span class="keyword">this</span>.delegate, <span class="comment">// SliverPersistentHeaderDelegate，用来创建展示内容</span></span><br><span class="line"><span class="keyword">this</span>.pinned = <span class="keyword">false</span>, <span class="comment">// 同 SliverAppBar 属性</span></span><br><span class="line"><span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="SliverPersistentHeaderDelegate"><a href="#SliverPersistentHeaderDelegate" class="headerlink" title="SliverPersistentHeaderDelegate"></a>SliverPersistentHeaderDelegate</h3><p>这个代理比较特殊，是个抽象类，也就是需要我们自己进行继承后再实现方法。SliverPersistentHeaderDelegate 需要提供一个最大值，最小值，展示内容，以及更新部件条件</p><p>比如我们需要展示一个最大高度 300，最小高度 100，居中的文字，那么我们可以这么写这个代理类</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoHeader</span> <span class="keyword">extends</span> <span class="title">SliverPersistentHeaderDelegate</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context, <span class="built_in">double</span> shrinkOffset, <span class="built_in">bool</span> overlapsContent) &#123;</span><br><span class="line"><span class="keyword">return</span> Container(</span><br><span class="line">color: Colors.pink,</span><br><span class="line">alignment: Alignment.center,</span><br><span class="line">child: Text(<span class="string">'我是一个头部部件'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>)));</span><br><span class="line">&#125; <span class="comment">// 头部展示内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> maxExtent =&gt; <span class="number">300.0</span>; <span class="comment">// 最大高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> minExtent =&gt; <span class="number">100.0</span>; <span class="comment">// 最小高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) =&gt; <span class="keyword">false</span>; <span class="comment">// 因为所有的内容都是固定的，所以不需要更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 SliverPersistentHeader 代替 SliverAppBar，看下效果</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: CustomScrollView(slivers: &lt;Widget&gt;[</span><br><span class="line">SliverPersistentHeader(delegate: DemoHeader(), pinned: <span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，</span></span><br><span class="line"><span class="comment">// 可以在 child 属性加入需要展示的部件</span></span><br><span class="line">SliverFillRemaining(</span><br><span class="line">child: Center(child: Text(<span class="string">'FillRemaining'</span>, style: TextStyle(fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br><span class="line">]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果图</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/201905221400.gif" alt=""></p><p>当然，为了方便扩展，需要重新封装下 Delegate ，通过外部传入范围和展示内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 SliverPersistentHeaderDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSliverPersistentHeaderDelegate</span> <span class="keyword">extends</span> <span class="title">SliverPersistentHeaderDelegate</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> max; <span class="comment">// 最大高度</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> min; <span class="comment">// 最小高度</span></span><br><span class="line"><span class="keyword">final</span> Widget child; <span class="comment">// 需要展示的内容</span></span><br><span class="line"></span><br><span class="line">CustomSliverPersistentHeaderDelegate(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.max, <span class="meta">@required</span> <span class="keyword">this</span>.min, <span class="meta">@required</span> <span class="keyword">this</span>.child&#125;)</span><br><span class="line"><span class="comment">// 如果 assert 内部条件不成立，会报错</span></span><br><span class="line">: <span class="keyword">assert</span>(max != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(min != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line"><span class="keyword">assert</span>(min &lt;= max),</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回展示的内容，如果内容固定可以直接在这定义，如果需要可扩展，这边通过传入值来定义</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context, <span class="built_in">double</span> shrinkOffset, <span class="built_in">bool</span> overlapsContent) =&gt; child;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> maxExtent =&gt; max; <span class="comment">// 返回最大高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> minExtent =&gt; min; <span class="comment">// 返回最小高度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> shouldRebuild(CustomSliverPersistentHeaderDelegate oldDelegate) &#123;</span><br><span class="line"><span class="comment">// 是否需要更新，这里我们定义当高度范围和展示内容被替换的时候进行刷新界面</span></span><br><span class="line"><span class="keyword">return</span> max != oldDelegate.max || min != oldDelegate.min || child != oldDelegate.child;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以愉快的使用了，不需要每个 Delegate 都重新写一遍，例如替换下刚才写死的 DemoHeader</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverPersistentHeader(</span><br><span class="line"><span class="comment">// 属性同 SliverAppBar</span></span><br><span class="line">pinned: <span class="keyword">true</span>,</span><br><span class="line">floating: <span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 因为 SliverPersistentHeaderDelegate 是一个抽象类，所以需要自定义</span></span><br><span class="line">delegate: CustomSliverPersistentHeaderDelegate(</span><br><span class="line">max: <span class="number">300.0</span>, min: <span class="number">100.0</span>, child: Text(<span class="string">'我是一个头部部件'</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">30.0</span>))),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>例如需要替换成一张图片，直接将 Text 修改成 Image 即可。</p><p>以上部分代码查看 sliver_main.dart 文件</p><h3 id="NestedScrollView"><a href="#NestedScrollView" class="headerlink" title="NestedScrollView"></a>NestedScrollView</h3><p>讲到这了，不得不提下 Scrollable 中比较重要的一员 NestedScrollView，先看下官方的解释</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A scrolling view inside of which can be nested other scrolling views, with</span></span><br><span class="line"><span class="comment">/// their scroll positions being intrinsically linked.</span></span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 1：一个内部能够嵌套其他滚动部件，并使其滚动位置联结到一起的滚动部件</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The most common use case for this widget is a scrollable view with a</span></span><br><span class="line"><span class="comment">/// flexible [SliverAppBar] containing a [TabBar] in the header (build by</span></span><br><span class="line"><span class="comment">/// [headerSliverBuilder], and with a [TabBarView] in the [body], such that the</span></span><br><span class="line"><span class="comment">/// scrollable view's contents vary based on which tab is visible.</span></span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 2：最常用的情况，就是在其 headerSliverBuilder 中使用携带 TabBar 的 SliverAppBar（就是使用 SliverAppBar 的 bottom 属性添加 tab 切换也），其 body 属性使用 TabBarView 来展示 Tab 页的内容，这样通过切换 Tab 页就能展示该页下的展示内容。</p><p>看下 headerSliverBuilder 的定义</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Signature used by [NestedScrollView] for building its header.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The `innerBoxIsScrolled` argument is typically used to control the</span></span><br><span class="line"><span class="comment">/// [SliverAppBar.forceElevated] property to ensure that the app bar shows a</span></span><br><span class="line"><span class="comment">/// shadow, since it would otherwise not necessarily be aware that it had</span></span><br><span class="line"><span class="comment">/// content ostensibly below it.</span></span><br><span class="line"><span class="keyword">typedef</span> NestedScrollViewHeaderSliversBuilder = <span class="built_in">List</span>&lt;Widget&gt; <span class="built_in">Function</span>(BuildContext context, <span class="built_in">bool</span> innerBoxIsScrolled);</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 3：用于构建 NestScrollView 的头部部件，innerBoxIsScrolled 主要用来控制 SliverAppBar 的 forceElevated 属性，当内部内容滚动时，显示 SliverAppbar 的阴影，主要用来提醒内部的内容低于 SliverAppBar （相当于给人一种物理层次感，否则很容易被认为，头部和内容是连接在一起的）</p><p>接下来看下 NestedScrollView 内部个人觉得有点重要的一个方法 sliverOverlapAbsorberHandleFor</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Returns the [SliverOverlapAbsorberHandle] of the nearest ancestor</span></span><br><span class="line"><span class="comment">/// [NestedScrollView].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is necessary to configure the [SliverOverlapAbsorber] and</span></span><br><span class="line"><span class="comment">/// [SliverOverlapInjector] widgets.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// For sample code showing how to use this method, see the [NestedScrollView]</span></span><br><span class="line"><span class="comment">/// documentation.</span></span><br><span class="line"><span class="keyword">static</span> SliverOverlapAbsorberHandle sliverOverlapAbsorberHandleFor(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> _InheritedNestedScrollView target = context.inheritFromWidgetOfExactType(_InheritedNestedScrollView);</span><br><span class="line">  <span class="keyword">assert</span>(target != <span class="keyword">null</span>, <span class="string">'NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.'</span>);</span><br><span class="line">  <span class="keyword">return</span> target.state._absorberHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意到中间的注释</p><p>糟透了的翻译 X 4：这个方法返回的值对于 SliverOverlapAbsorber 和 SliverOverlapInjector 部件是非常重要的参数</p><p>接着请注意代码中的那段 assert 中的文字</p><p>糟透了的翻译 X 5：sliverOverlapAbsorberHandleFor 传入的参数 context 中必须包含 NestedScrollView</p><h3 id="SliverOverlapAbsorber"><a href="#SliverOverlapAbsorber" class="headerlink" title="SliverOverlapAbsorber"></a>SliverOverlapAbsorber</h3><p>这边又引入了两个部件 SliverOverlapAbsorber + SliverOverlapInjector 还是看源码的解释吧</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Creates a sliver that absorbs overlap and reports it to a</span></span><br><span class="line"><span class="comment">/// [SliverOverlapAbsorberHandle].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [handle] must not be null.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [child] must be a sliver.</span></span><br><span class="line"><span class="keyword">const</span> SliverOverlapAbsorber(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.handle,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 6：一个 sliver 部件，用于把部件重叠的高度反馈给 SliverOverlapAbsorberHandle，而且指明了 handle 不能空，可以通过 NestedScrollView 的 sliverOverlapAbsorberHandleFor 方法来赋值，并且 child 必须是个 sliver 部件，也就是说我们的 SliverAppBar 需要放到 SliverOverlapAbsorber 里面。</p><h3 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Creates a sliver that is as tall as the value of the given [handle]'s</span></span><br><span class="line"><span class="comment">/// layout extent.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The [handle] must not be null.</span></span><br><span class="line"><span class="keyword">const</span> SliverOverlapInjector(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.handle,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>糟透了的翻译 X 7：创建一个和指定的 handle 一样高度的 sliver 部件，这个 handle 同 SliverOverlapAbsorber 的 handle 保持一致即可。</p><p>分析完源码后，例子的目标很明确，使用 SliverAppBar + TabBar + TabBarView，先看下最后的效果图吧</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190522111721.gif" alt=""></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollDemoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> _tabs = &lt;<span class="built_in">String</span>&gt;[<span class="string">'TabA'</span>, <span class="string">'TabB'</span>];</span><br><span class="line"><span class="keyword">final</span> colors = &lt;Color&gt;[Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">body: DefaultTabController(</span><br><span class="line">length: _tabs.length,</span><br><span class="line">child: NestedScrollView(</span><br><span class="line">headerSliverBuilder: (context, innerScrolled) =&gt; &lt;Widget&gt;[</span><br><span class="line">SliverOverlapAbsorber(</span><br><span class="line"><span class="comment">// 传入 handle 值，直接通过 `sliverOverlapAbsorberHandleFor` 获取即可</span></span><br><span class="line">handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),</span><br><span class="line">child: SliverAppBar(</span><br><span class="line">pinned: <span class="keyword">true</span>,</span><br><span class="line">title: Text(<span class="string">'NestedScroll Demo'</span>),</span><br><span class="line">expandedHeight: <span class="number">200.0</span>,</span><br><span class="line">flexibleSpace: FlexibleSpaceBar(background: Image.asset(<span class="string">'images/timg.jpg'</span>, fit: BoxFit.cover)),</span><br><span class="line">bottom: TabBar(tabs: _tabs.map((tab) =&gt; Text(tab, style: TextStyle(fontSize: <span class="number">18.0</span>))).toList()),</span><br><span class="line">forceElevated: innerScrolled,</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">],</span><br><span class="line">body: TabBarView(</span><br><span class="line">children: _tabs</span><br><span class="line"><span class="comment">// 这边需要通过 Builder 来创建 TabBarView 的内容，否则会报错</span></span><br><span class="line"><span class="comment">// NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.</span></span><br><span class="line">.map((tab) =&gt; Builder(</span><br><span class="line">builder: (context) =&gt; CustomScrollView(</span><br><span class="line"><span class="comment">// key 保证唯一性</span></span><br><span class="line">key: PageStorageKey&lt;<span class="built_in">String</span>&gt;(tab),</span><br><span class="line">slivers: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">// 将子部件同 `SliverAppBar` 重叠部分顶出来，否则会被遮挡</span></span><br><span class="line">SliverOverlapInjector(</span><br><span class="line">handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),</span><br><span class="line">SliverGrid(</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Image.asset(<span class="string">'images/ali.jpg'</span>),</span><br><span class="line">childCount: <span class="number">8</span>),</span><br><span class="line">gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">crossAxisCount: <span class="number">4</span>, mainAxisSpacing: <span class="number">10.0</span>, crossAxisSpacing: <span class="number">10.0</span>)),</span><br><span class="line">SliverFixedExtentList(</span><br><span class="line">delegate: SliverChildBuilderDelegate(</span><br><span class="line">(_, index) =&gt; Container(</span><br><span class="line">child: Text(<span class="string">'$tab - item<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>'</span>,</span><br><span class="line">style: TextStyle(fontSize: <span class="number">20.0</span>, color: colors[index % <span class="number">6</span>])),</span><br><span class="line">alignment: Alignment.center),</span><br><span class="line">childCount: <span class="number">15</span>),</span><br><span class="line">itemExtent: <span class="number">50.0</span>)</span><br><span class="line">],</span><br><span class="line">),</span><br><span class="line">))</span><br><span class="line">.toList()))),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的部件和之前讲的没啥大区别，就是多了 SliverOverlapAbsorber 和 SliverOverlapInjector 没啥难度</p><p>以上部分代码查看 nested_scroll_main.dart 文件</p><p>sliver 部件常用的也就那么多了，望小伙伴好好吸收，跟着例子撸撸代码，撸顺下思路</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去&lt;/p&gt;
&lt;p&gt;在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。&lt;/p&gt;
&lt;h3 id=&quot;SliverAppBar&quot;&gt;&lt;a href=&quot;#SliverAppBar&quot; class=&quot;headerlink&quot; title=&quot;SliverAppBar&quot;&gt;&lt;/a&gt;SliverAppBar&lt;/h3&gt;&lt;p&gt;相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SliverAppBar(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Key key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.leading,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.automaticallyImplyLeading = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.title,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.actions,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.flexibleSpace, &lt;span class=&quot;comment&quot;&gt;// 通过这个来设置背景&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bottom,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.elevation,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.forceElevated = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 是否显示层次感&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.backgroundColor,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.brightness,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.iconTheme,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.textTheme,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.primary = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.centerTitle,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.titleSpacing = NavigationToolbar.kMiddleSpacing,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.expandedHeight, &lt;span class=&quot;comment&quot;&gt;// 展开的高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下三个等例子再讲&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.floating = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.pinned = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.snap = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
</feed>
