<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android适配-6.0的动态权限管理]]></title>
    <url>%2Fposts%2Feea8a783.html</url>
    <content type="text"><![CDATA[前言大家都知道Android 6.0的新特性之一就是应用权限的管理。也就是说凡是涉及用户隐私的权限，用户可以自己去设置管理了。然而在6.0以前，我们安装一款APP是默认同意此APP所需的所有权限（比如定位、访问通讯录），不同意就不能安装。当然，国内的一些手机厂商基于Android定制的系统中，可以实现在6.0以前关闭指定的权限。如下图： LTR RTL 危险权限列表(Dangerous Permission)Dangerous Permission一般都是涉及用户隐私的权限。 从上面的图片中可以看到，摄像头、电话、定位等等都是我们平常开发中常用的权限。 可以在6.0不适配权限管理吗？答案是可以，但是不推荐。 首先说怎么不适配，那就是设置targetSdkVersion小于23（Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果您APP设置的targetSdkVersion低于23，在运行时也不会崩溃。） 有人一看这不是挺好的嘛，解决问题。那么我想告诉你，首先这不是长久之计，早晚都要面对的。你不可能永远targetSdkVersion低于23。其次，它是有一个前提，那就是用户自己不去操作权限。要知道如果用户是6.0以上的手机或是国内部分6.0以前的手机，他可以自己在设置中关闭权限，那么到时APP因为没有权限获取数据异常，导致空指针的异常时，APP就会崩溃。 怎么适配首先Android Studio：在build.gradle中声明targetSdkVersion为23及以上。 Eclipse：在AndroidManifest.xml中声明targetSdkVersion为23及以上。 这里引用高德定位Demo的CheckPermissionsActivity类，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/** * 继承了Activity，实现Android6.0的运行时权限检测 * 需要进行运行时权限检测的Activity可以继承这个类 * * @创建时间：2016年5月27日 下午3:01:31 * @项目名称： AMapLocationDemo * @author hongming.wang * @文件名称：PermissionsChecker.java * @类型名称：PermissionsChecker * @since 2.5.0 */public class CheckPermissionsActivity extends Activity &#123; /** * 需要进行检测的权限数组 */ protected String[] needPermissions = &#123; Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE &#125;; private static final int PERMISSON_REQUESTCODE = 0; /** * 判断是否需要检测，防止不停的弹框 */ private boolean isNeedCheck = true; @Override protected void onResume() &#123; super.onResume(); if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= 23) &#123; if (isNeedCheck) &#123; checkPermissions(needPermissions); &#125; &#125; &#125; /** * * @param permissions * @since 2.5.0 * requestPermissions方法是请求某一权限， */ private void checkPermissions(String... permissions) &#123; try &#123; if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= 23) &#123; List&lt;String&gt; needRequestPermissonList = findDeniedPermissions(permissions); if (null != needRequestPermissonList &amp;&amp; needRequestPermissonList.size() &gt; 0) &#123; String[] array = needRequestPermissonList.toArray(new String[needRequestPermissonList.size()]); Method method = getClass().getMethod("requestPermissions", new Class[]&#123;String[].class, int.class&#125;); method.invoke(this, array, PERMISSON_REQUESTCODE); &#125; &#125; &#125; catch (Throwable e) &#123; &#125; &#125; /** * 获取权限集中需要申请权限的列表 * * @param permissions * @return * @since 2.5.0 * checkSelfPermission方法是在用来判断是否app已经获取到某一个权限 * shouldShowRequestPermissionRationale方法用来判断是否 * 显示申请权限对话框，如果同意了或者不在询问则返回false */ private List&lt;String&gt; findDeniedPermissions(String[] permissions) &#123; List&lt;String&gt; needRequestPermissonList = new ArrayList&lt;String&gt;(); if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= 23)&#123; try &#123; for (String perm : permissions) &#123; Method checkSelfMethod = getClass().getMethod("checkSelfPermission", String.class); Method shouldShowRequestPermissionRationaleMethod = getClass().getMethod("shouldShowRequestPermissionRationale", String.class); if ((Integer)checkSelfMethod.invoke(this, perm) != PackageManager.PERMISSION_GRANTED || (Boolean)shouldShowRequestPermissionRationaleMethod.invoke(this, perm)) &#123; needRequestPermissonList.add(perm); &#125; &#125; &#125; catch (Throwable e) &#123; &#125; &#125; return needRequestPermissonList; &#125; /** * 检测是否所有的权限都已经授权 * @param grantResults * @return * @since 2.5.0 * */ private boolean verifyPermissions(int[] grantResults) &#123; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; return false; &#125; &#125; return true; &#125; /** * 申请权限结果的回调方法 */ @TargetApi(23) public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] paramArrayOfInt) &#123; if (requestCode == PERMISSON_REQUESTCODE) &#123; if (!verifyPermissions(paramArrayOfInt)) &#123; showMissingPermissionDialog(); isNeedCheck = false; &#125; &#125; &#125; /** * 显示提示信息 * * @since 2.5.0 * */ private void showMissingPermissionDialog() &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(R.string.notifyTitle); builder.setMessage(R.string.notifyMsg); // 拒绝, 退出应用 builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;); builder.setPositiveButton(R.string.setting, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; startAppSettings(); &#125; &#125;); builder.setCancelable(false); builder.show(); &#125; /** * 启动应用的设置 * * @since 2.5.0 * */ private void startAppSettings() &#123; Intent intent = new Intent( Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.parse("package:" + getPackageName())); startActivity(intent); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if(keyCode == KeyEvent.KEYCODE_BACK)&#123; this.finish(); return true; &#125; return super.onKeyDown(keyCode, event); &#125; &#125; 我在上面的类中，自己加入了一些注释，大家仔细看就可以明白了。 补充：小米手机在动态权限这里还需要一些兼容，我们需要注意一下。当然对于国内部分6.0以前手机，只能在需要权限去去捕获异常来处理了。 当然不止上面一种实现方法，github上有许多大神开源的封装库，可以很方便的实现权限适配。我推荐两个库，大家根据需求选择： PermissionsDispatcher 鸿洋大神的MPermissions 参考 Android M 新的运行时权限开发者需要知道的一切 高德地图定位API]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动态权限</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android适配-7.0的踩坑之路]]></title>
    <url>%2Fposts%2Fa6a9da5d.html</url>
    <content type="text"><![CDATA[安装时解析错误我们的App通常会有检查更新的功能。用户在收到提示更新并且下载完后，会自动打开安装页面让用户来去安装。这时就会出现安装错误的问题，这类的问题的可能性比较多。比如较低版本的App想要覆盖已有的较高版本App会提示安装未完成，或是签名不一致导致的。不过7.0上常见的有以下两种情况。 应用间共享文件在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 Android 7.0 行为变更 通过FileProvider在应用间共享文件 这篇文章。 APK signature scheme v2 Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。详细看安卓官方说明。 简单地说就是任何方式的篡改APK 文件，在利用了V2签名的apk上会失效。 可以看到默认是V1 和V2选中的。 1）只勾选v1签名就是传统方案签署，但是在7.0上不会使用V2安全的验证方式。2）只勾选V2签名7.0以下会显示未安装，7.0上则会使用了V2安全的验证方式。3）同时勾选V1和V2则所有版本都没问题。 PopupWindow位置不正确7.0系统的手机上，PopupWindow弹出位置不正确。有两种可能： 第一种： 我们使用了update方法，同时设置了Gravity（Gravity.NO_GRAVITY没事）。因为在update方法中有调用computeGravity方法去获取Gravity。（7.0以下没有获取Gravity进行更新判断） 12345678910111213public void update() &#123; // 省略部分代码 final int newGravity = computeGravity(); if (newGravity != p.gravity) &#123; p.gravity = newGravity; update = true; &#125; if (update) &#123; setLayoutDirectionFromAnchor(); mWindowManager.updateViewLayout(mDecorView, p); &#125; &#125; Android 7.1computeGravity方法 1234567private int computeGravity() &#123; int gravity = mGravity == Gravity.NO_GRAVITY ? Gravity.START | Gravity.TOP : mGravity; if (mIsDropdown &amp;&amp; (mClipToScreen || mClippingEnabled)) &#123; gravity |= Gravity.DISPLAY_CLIP_VERTICAL; &#125; return gravity;&#125; 很显然在7.0上我们设置的Gravity被覆盖了。解决就很简单了，不使用update方法。如果你真的要使用可以参考这篇文章的方法。 第二种： PopupWindow高度为MATCH_PARENT，在显示的时候调用showAsLocation方法时，PopupWindow并没有在指定控件的下方显示。如果使用showAsDropDown，会全屏显示。 解决方法： 1.最简单的解决方法就是指定 PopupWindow 的高度为 WRAP_CONTENT, 调用 showAsDropDown方法。 2.或者弹出时做一下判断处理（代码来自PopupWindowCompat） 12345678910111213if (Build.VERSION.SDK_INT &gt;= 24) &#123; // Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性 int[] location = new int[2]; // 记录anchor在屏幕中的位置 anchor.getLocationOnScreen(location); int offsetY = location[1] + anchor.getHeight(); if (Build.VERSION.SDK_INT &gt;= 25) &#123; // Android 7.1 ,8.0中，PopupWindow高度为 match_parent 时，会占据整个屏幕 // 故而需要在 Android 7.1上再做特殊处理 int screenHeight = ScreenUtils.getScreenHeight(context); // 获取屏幕高度 popupWindow.setHeight(screenHeight - offsetY); // 重新设置 PopupWindow 的高度 &#125; popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, 0, offsetY);&#125; else &#123; popupWindow.showAsDropDown(anchor);&#125; 后台优化小伙伴们都知道在Android中有一些隐式广播，使用这些隐式广播可以做一些特定的功能，如，当手机网络变成WiFi时自动下载更新包等。 但，这些隐式广播会在后台频繁启动已注册侦听这些广播的应用，从而带来很大的电量消耗，为缓解这一问题来提升设备性能和用户体验，在Android 7.0中删除了三项隐式广播，以帮助优化内存使用和电量消耗。 Android 7.0 应用了以下优化措施： 在 Android 7.0上 应用不会收到 CONNECTIVITY_ACTION 广播，即使你在manifest清单文件中设置了请求接受这些事件的通知。 但，在前台运行的应用如果使用BroadcastReceiver 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。 在 Android 7.0上应用无法发送或接收 ACTION_NEW_PICTURE 或ACTION_NEW_VIDEO 类型的广播。 应对策略：Android 框架提供多个解决方案来缓解对这些隐式广播的需求。 例如，JobScheduler API提供了一个稳健可靠的机制来安排满足指定条件（例如连入无线流量网络）时所执行的网络操作。 您甚至可以使用 JobScheduler API 来适应内容提供程序变化。 另外，大家如果想了解更多关于后台的优化可查阅后台优化 移动设备会经历频繁的连接变更，例如在 Wi-Fi 和移动数据之间切换时。 目前，可以通过在应用清单中注册一个接收器来侦听隐式 CONNECTIVITY_ACTION 广播，让应用能够监控这些变更。 由于很多应用会注册接收此广播，因此单次网络切换即会导致所有应用被唤醒并同时处理此广播。以上内容来自这里 多语言特性首先是官方的API指南：语言和语言区域 变化对比： Android 7.0多语言支持开发浅析 实现功能： Android 实现应用内置语言切换 通知栏适配这里有一篇非常详细的通知栏介绍与适配，分享给大家：Android通知栏介绍与适配总结 WebView问题 Android 7.0 WebView 部分机型打不开 Android 7.0 WebView 二级跳转后界面空白 Toast导致的BadTokenException 同学，你的系统Toast可能需要修复一下]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动态权限</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开箱即用的自定义Banner]]></title>
    <url>%2Fposts%2F108df6b8.html</url>
    <content type="text"><![CDATA[自定义Banner用法明细支持XML自定义属性： bv_viewHeight：Banner视图区域的高度，小于等于0时为该布局的高度 bv_viewCornerRadius：视图区域圆角的半径 bv_itemViewWidthRatio：根据该布局宽度的百分比设置ItemView的宽度 bv_itemViewMargin：设置ItemView之间的间距 bv_intervalInMillis：Banner轮换时间（在SMOOTH模式下为Banner从右匀速到左的时间） bv_pageHoldInMillis：手指滑动后，页面停留的时长（只在SMOOTH模式下生效） bv_scrollMode：设置Banner滚动模式 INTERVAL：间隔切换模式 SMOOTH：匀速滚动模式 bv_itemViewAlign：ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置） CENTER_HORIZONTAL：水平居中 ALIGN_PARENT_LEFT：居左对齐 ALIGN_PARENT_RIGHT：居右对齐 暴露的API有： setBannerViewImpl(impl: IBannerView)：设置Banner必须的实现类 startAutoScroll()：开始自动滚动（页面数量小于1时不会滚动） stopAutoScroll()：停止自动滚动 123456789101112131415161718192021222324252627282930313233343536/** * 定义页面切换回调 */interface OnPageChangeListener &#123; fun onPageSelected(position: Int)&#125;interface IBannerViewBase &#123; fun getCount(): Int fun getItemView(context: Context): View fun onBindView(itemView: View, position: Int)&#125;/** * BannerView依赖的外部实现 */interface IBannerView : OnPageChangeListener, IBannerViewBase &#123; /** * 当count为0时的默认view */ fun getDefaultView(context: Context): View? &#123; return null &#125; /** * 默认关闭自动滚动 */ fun isDefaultAutoScroll(): Boolean &#123; return false &#125; override fun onPageSelected(position: Int) &#123;&#125;&#125; 源码地址： https://github.com/drawf/SourceSet/tree/master/app/src/main/java/me/erwa/sourceset/view/banner 思考分析NOTE：这篇文章我们专注于BannerView的封装与实现，关于更底层的PagerSnapHelper的原理部分不在范围内，但在文末我拜读的文章中贴出了一份链接，大家可自行食用。 前路漫漫，我们先梳理下需求： 要支持两种滚动模式，间隔切换、平滑滚动 要支持设置视图区域圆角 要支持设置条目视图圆角（ItemView）（该需求本次未做实现，下文会自动忽略该需求） 要支持无限循环滚动 要支持根据BannerView的宽的比值设置ItemView的宽 要支持设置ItemView之间的间距 要支持设置滚动间隔，匀速模式要支持设置滚动一页的时间 要支持设置匀速模式下，手指滑动后，页面停留的时长 要支持设置ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置） 要支持设置默认是否开启滚动 要支持设置数据源为空时的默认View 要支持数据源只有1张banner时，禁止滚动 要暴露API控制Banner的自动滚动与暂停 要支持设置指示器（Indicator），且能灵活控制指示器位置，且与BannerView解耦 🤩这么多需求，不要怕，我们根据需求来理一遍核心技术点： 平滑滚动模式可以使用RecyclerView+PagerSnapHelper实现，间隔滚动模式可以继续使用ViewPager实现，也可以使用前者方式实现。（本文统一使用RecyclerView+PagerSnapHelper方式，不过代码中也留出了接口，可用ViewPager做实现） 设置圆角还是采用Xfermode做裁剪合成即可。（该方式在之前的文章ShadowLayout中使用过，故本文不再赘述） 需求[4]将adpter中getItemCount()返回Int.MAX_VALUE，再在绑定View时候，用当前的position与真实count求余数，作为真实的position去绑定数据，即可实现。 需求[4]到[13]，都没有技术复杂度，但有业务复杂度，做常规实现即可。 需求[14]可定义Indicator涉及的接口做代码解耦，并将BannerView继承RelativeLayout，这样Indicator作为子View在xml中可灵活控制位置。 这样一来，实现我们想要的BannerView只是耐心+时间的问题了。以下，我会挑本次实现中重要的几点来做说明，如下： RecyclerView+PagerSnapHelper实现的PagerRecyclerView 生成PagerView实例的工厂PagerViewFactory Indicator的解耦实现 PagerRecyclerView看名字便知这是一个用RecyclerView实现ViewPager功能的类，所以继承自RecyclerView。 它作为BannerView的核心功能实现类，为了与上层解耦（也就是方便切换为其它实现，比如用ViewPager做实现）所以定义接口IPagerViewInstance。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * PagerView功能实例需实现的接口 */interface IPagerViewInstance &#123; /** * 设置自动滚动 * @param intervalInMillis: Int 在INTERVAL模式下为页面切换间隔 在SMOOTH模式下为滚动一页所需时间 */ fun startAutoScroll(intervalInMillis: Int) /** * 停止自动滚动 */ fun stopAutoScroll() /** * 获取当前Item的位置（List的索引） */ fun getCurrentPosition(): Int /** * 获取当前真实的Item的位置（List的索引） */ fun getRealCurrentPosition(realCount: Int): Int /** * 设置平滑模式是否开启，否则为间隔切换模式 */ fun setSmoothMode(enabled: Boolean) /** * 设置页面停留时长 */ fun setPageHoldInMillis(pageHoldInMillis: Int) /** * 设置页面切换回调 */ fun setOnPageChangeListener(listener: OnPageChangeListener) /** * 通知数据刷新 */ fun notifyDataSetChanged()&#125; 关于PagerSnapHelper的使用极其简单，只需创建出实例，attachToRecyclerView一下，即可让RecyclerView摇身一变成为ViewPager一样。（这里实在让人惊叹！！我们都应该追求这种API的极致设计） 123456789/** * 滑动到具体位置帮助器 */private var mSnapHelper: PagerSnapHelper = PagerSnapHelper()... 省略代码init &#123; mSnapHelper.attachToRecyclerView(this) ... 省略代码&#125; 关于间隔切换模式 匀速滚动模式的实现主要是在startTimer()方法中，两者的区别在于Timer的间隔时间不同、回调中执行的方法不同。其中匀速模式的Timer间隔时间需要使用外部设置的滚动一屏的时间、一屏的宽度、每次scrollBy的距离计算而来。 123456789101112131415161718192021222324252627282930313233343536/** * 开始定时器 */private fun startTimer() &#123; mTimer?.cancel() if (mWidth &gt; 0 &amp;&amp; mFlagStartTimer &amp;&amp; context != null &amp;&amp; context is Activity) &#123; mTimer = timer(initialDelay = mDelayedTime, period = mPeriodTime) &#123; if (mScrollState == SCROLL_STATE_IDLE) &#123; (context as Activity).runOnUiThread &#123; if (mSmoothMode) &#123; scrollBy(DEFAULT_PERIOD_SCROLL_PIXEL, 0) triggerOnPageSelected() &#125; else &#123; smoothScrollToPosition(++mOldPosition) mPageChangeListener?.onPageSelected(mOldPosition) &#125; &#125; &#125; &#125; &#125;&#125;override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) mWidth = (w - paddingLeft - paddingRight).toFloat() mHeight = (h - paddingTop - paddingBottom).toFloat() //计算匀速滚动的时间间隔 if (mSmoothMode) &#123; mPeriodTime = (mSmoothSpeed / (mWidth / DEFAULT_PERIOD_SCROLL_PIXEL)).toLong() &#125; if (mTimer == null) &#123; startTimer() &#125;&#125; 页面选中是根据PagerSnapHelper中提供的findSnapView方法，先找到Snap（就是当前的目标View），再找它的位置，当然还需用一个变量记录一下，防止多次触发回调。 123456789101112131415/** * 触发OnPageSelected回调 */private fun triggerOnPageSelected() &#123; val layoutManager = getLinearLayoutManager() val view = mSnapHelper.findSnapView(layoutManager) if (view != null) &#123; val position = layoutManager.getPosition(view) //防止同一位置多次触发 if (position != mOldPosition) &#123; mOldPosition = position mPageChangeListener?.onPageSelected(position) &#125; &#125;&#125; 还有一个值得说道的点是初始化时需要矫正Snap的位置，因为PagerSnapHelper手指滑动的时候才工作让RecyclerView滑动出ViewPager的感觉，所以初始化时不矫正会发现选中的页面不居中显示，还是一个RecyclerView的样子。那如何矫正呢？这里去看了PagerSnapHelper实现，搬过来，稍加修改即可。 123456789101112131415161718192021222324252627282930313233343536/** * 矫正首次初始化时SnapView的位置 */private fun correctSnapViewPosition() &#123; val layoutManager = getLinearLayoutManager() val snapView = mSnapHelper.findSnapView(layoutManager) if (snapView != null) &#123; val snapDistance = mSnapHelper.calculateDistanceToFinalSnap(layoutManager, snapView) if (snapDistance != null) &#123; if (snapDistance[0] != 0 || snapDistance[1] != 0) &#123; //我们把源码的smoothScrollBy改为scrollBy，这样视觉上觉察不出矫正过程 scrollBy(snapDistance[0], snapDistance[1]) &#125; //首次触发回调 triggerOnPageSelected() &#125; &#125;&#125;/** * 这是源码 */void snapToTargetExistingView() &#123; if (this.mRecyclerView != null) &#123; LayoutManager layoutManager = this.mRecyclerView.getLayoutManager(); if (layoutManager != null) &#123; View snapView = this.findSnapView(layoutManager); if (snapView != null) &#123; int[] snapDistance = this.calculateDistanceToFinalSnap(layoutManager, snapView); if (snapDistance[0] != 0 || snapDistance[1] != 0) &#123; this.mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]); &#125; &#125; &#125; &#125;&#125; 以上是我认为PagerRecyclerView较为关键的点，其它部分均为业务逻辑的处理与实现，大家可打开源码自行食用。 PagerViewFactory这里采用了工厂方法模式来创建Banner底层的核心实现。 首先定义了BannerView实例接口，它将作为工厂实例的构造方法参数，用于区分创建底层实现。 1234567891011121314151617181920212223interface IBannerViewBase &#123; fun getCount(): Int fun getItemView(context: Context): View fun onBindView(itemView: View, position: Int)&#125;/** * 定义BannerView实例接口 */interface IBannerViewInstance : IBannerViewBase &#123; fun getContext(): Context fun isSmoothMode(): Boolean fun getItemViewWidth(): Int fun getItemViewMargin(): Int fun getItemViewAlign(): Int&#125; 工厂有个getPagerView()的方法，来创建Banner核心实现 123456789101112131415/** * 工厂根据参数创建对应PagerView实例 */override fun getPagerView(): IPagerViewInstance &#123; return if (bannerView.isSmoothMode()) &#123; casePagerRecycler(true) &#125; else &#123; if (intervalUseViewPager) &#123; //这里可以根据需要用ViewPager做底层实现 throw IllegalStateException("这里未使用ViewPager做底层实现") &#125; else &#123; casePagerRecycler(false) &#125; &#125;&#125; 这里就是创建了之前写好的PagerRecyclerView，其实就是创建配置使用一个RecyclerView的过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 处理PagerRecyclerView */private fun casePagerRecycler(isSmoothMode: Boolean): IPagerViewInstance &#123; val recyclerView = PagerRecyclerView(bannerView.getContext()) recyclerView.layoutManager = LinearLayoutManager(bannerView.getContext(), LinearLayoutManager.HORIZONTAL, false) recyclerView.adapter = object : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123; override fun getItemCount(): Int &#123; return Int.MAX_VALUE &#125; override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) &#123; if (!isActivityDestroyed(holder.itemView.context)) &#123; val realPos = position % bannerView.getCount() bannerView.onBindView(holder.itemView.findViewById(R.id.id_real_item_view), realPos) &#125; &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder &#123; val itemWrapper = LayoutInflater.from(parent.context).inflate( R.layout.layout_banner_item_wrapper, parent, false ) as RelativeLayout //处理ItemViewWrapper的宽 itemWrapper.layoutParams.width = bannerView.getItemViewWidth() + bannerView.getItemViewMargin() //外部实际的ItemView val itemView = bannerView.getItemView(parent.context) itemView.id = R.id.id_real_item_view val ivParams = RelativeLayout.LayoutParams( bannerView.getItemViewWidth(), ViewGroup.LayoutParams.MATCH_PARENT ) ivParams.addRule(bannerView.getItemViewAlign()) //添加ItemView到Wrapper itemWrapper.addView(itemView, ivParams) return object : RecyclerView.ViewHolder(itemWrapper) &#123;&#125; &#125; &#125; //初始化位置 recyclerView.scrollToPosition(bannerView.getCount() * 100) recyclerView.setSmoothMode(isSmoothMode) return recyclerView&#125; Indicator的解耦实现解耦的惯用套路就是抽象方法定义接口。所以我们定义了两个接口，一个是指示器实例需实现的接口，一个是指示器依赖的外部实现。所以使用这两个接口，可以自定义实现想要的样式。 1234567891011121314151617181920212223242526272829303132333435363738/** * 指示器实例需实现的接口 */interface IIndicatorInstance &#123; /** * 设置外部实现 */ fun setIndicator(impl: IIndicator) /** * 重新布局 */ fun doRequestLayout() /** * 重新绘制 */ fun doInvalidate()&#125;/** * 指示器依赖的外部实现 */interface IIndicator &#123; /** * 获取adapter总数目 */ fun getCount(): Int /** * 获取当前选中页面的索引 */ fun getCurrentIndex(): Int&#125; 对于我们这次实现的CrossBarIndicator，它就是一个常规的自定义View，这里已没有什么好说的啦。重点要说的是需求中有一条且能灵活控制指示器位置，如何实现呢？需求分析时说了，我们的BannerView是一个RelativeLayout，Indicator作为其子View可以很方便的控制其位置。 然后，看下BannerView中的关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647override fun onFinishInflate() &#123; super.onFinishInflate() findIndicator()&#125;/** * 在子View中找到指示器 */private fun findIndicator() &#123; for (i in 0 until childCount) &#123; val child = getChildAt(i) if (child is IIndicatorInstance) &#123; //布局填充完毕时，找到子View中的Indicator，并保存下来 mIndicator = child return &#125; &#125;&#125;/** * 初始化view */private fun initView() &#123; if (mBannerViewImpl != null &amp;&amp; mWidth &gt; 0) &#123; val bvImpl = mBannerViewImpl!! removeAllViews() ... 省略代码 //初始化指示器 if (mIndicator != null) &#123; mIndicator?.setIndicator(object : IIndicator &#123; override fun getCount(): Int &#123; return bvImpl.getCount() &#125; override fun getCurrentIndex(): Int &#123; return mPagerViewInstance.getRealCurrentPosition(bvImpl.getCount()) &#125; &#125;) //把指示器再添加回去 addView(mIndicator as View) &#125; &#125;&#125; 文末到这里整体要说的就完结了，整个BannerView的实现细节、逻辑还是很多的，不过复杂度倒没那么高，建议食用源码~ O(∩_∩)O哈哈~ 个人能力有限，如有不正之处欢迎大家批评指出，我会虚心接受并第一时间修改，以不误导大家。 拜读的文章SnapHelper硬核讲解： https://juejin.im/post/5cbe78ae5188250a6b183872]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>Banner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Context细节解析]]></title>
    <url>%2Fposts%2Fb902250c.html</url>
    <content type="text"><![CDATA[Context到底是啥？Context 本身是一个抽象类，它的实现类为 ContextImpl。 另外有子类 ContextWrapper 和 ContextThemeWrapper，这两个子类都是 Context 的代理类，主要区别是 ContextThemeWrapper 有自己的主题资源。 一个 Context 意味着一个场景，一个场景就是我们和软件进行交互的一个过程。 从安卓程序的角度来看，其实一个 Activity 就是一个 Context ，一个 Service 也是一个 Context。 Context有啥作用？有啥用？要看它能做啥，看看主要提供了哪些接口了。 还挺多的，看起来管得挺多，四大组件都管着，像个 Application 大管家。 一个app里有多少个Context？前面说啦，一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。 ContextImpl和ContextWrapper有啥区别？看下ContextWrapper： 再看下ContextImpl： 比较下： 不同组件创建ContextImpl的方式： 总结 Context相当于Application的大管家； ContextWrapper、ContextThemWrapper都是Context的代理类，ContextImpl是Context的主要实现类，是个实力派！ 参考: https://juejin.im/post/5c1fab7d5188254eb05fbe48 https://juejin.im/post/5865bfa1128fe10057e57c63]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中东阿拉伯语适配]]></title>
    <url>%2Fposts%2Fc080be13.html</url>
    <content type="text"><![CDATA[RTL 语言由来RTL 是 Right-to-left(从右向左) 的缩写。其意为人们书写阅读习惯是从右向左，朝左继续的，常见的 RTL 语言有阿拉伯语，希伯来语等。 看一下对比： LTR RTL 那么对于这种从右到左的习惯，在 Android 布局中有没有支持呢？ 答案是有的：从 Android 4.2 即 SDK 17 开始，提供了全面的本地布局支持，允许镜像布局，可以同时支持 RTL 和 LTR。 接下来我将介绍如何一步一步适配阿拉伯语。 属性 name desc chinese android:layoutDirection attribute for setting the direction of a component’s layout 设置组件的布局排列方向 android:textDirection attribute for setting the direction of a component’s text 设置组件的文字排列方向 android:textAlignment attribute for setting the alignment of a component’s text 设置文字的对齐方式 getLayoutDirectionFromLocale() method for getting the Locale-specified direction 获取指定地区的惯用布局方式 前提条件在 AndroidManifest.xml 文件中 application 节点添加支持从右到左布局方式代码 12345 &lt;application ... android:supportsRtl="true" &gt; ...&lt;/application&gt; 切换语言相关链接：change-language-programmatically-in-android 对应国家语言代码: what-is-the-list-of-supported-languages-locales-on-android 下面切换语言方式 updateConfiguration 方法在 Api 25 已经过时, 新的切换方式实例 地址 12345678String languageToLoad = "ar"; // your languageResources res = getResources(); DisplayMetrics dm = res.getDisplayMetrics();Locale locale = new Locale(languageToLoad); Locale.setDefault(locale);Configuration config = new Configuration();config.locale = locale;res.updateConfiguration(conf, dm); AS 一键适配AS 支持一键适配 RTL，主要是在原来 Layout 中设置 Left 和 Right 属性的补充添加 Start 和 End 属性（你们在写布局的时候是不是很少用到 paddingStart、marginStart？接下来你们写布局的时候可不能再偷懒了，该加的还是得加上) Start 属性在 LTR 中对应 Left，在 RTL 中对应 Right，在API 17开始支持，为了兼容低版本，需要同时有 Left 和 Start。从市场来看，Android 4.2 系统以下的手机用户已经不多了，我的建议是可以不兼容，具体还得你们看自家产品在 4.2 系统以下用户数。 Refactor &gt; Add RTL Support Where Possible… 利用第三方插件 名称 描述 gradle-android-rtl 自动修复布局文件中未添加RTL支持的标签 与 AS 插件的比较： 性能更好。在处理大批量文件修改时，用AS工具会出现卡顿 支持padding标签的补齐 使用全局样式EditText发现 EditText 控件基本都需要设置下面两个属性 相关链接：set-a-consistent-style-to-all-edittext-for-e-g 12android:textAlignment="viewStart"android:gravity="start" 那我们就可以在 style.xml 样式中全部 EditText 都设置 1234567891011&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="editTextStyle"&gt;@style/EditTextStyle.Alignment&lt;/item&gt; ...&lt;/style&gt;&lt;style name="EditTextStyle.Alignment" parent="@android:style/Widget.EditText"&gt; &lt;item name="android:textAlignment"&gt;viewStart&lt;/item&gt; &lt;item name="android:gravity"&gt;start&lt;/item&gt; &lt;item name="android:textDirection"&gt;locale&lt;/item&gt;&lt;/style&gt; TextView全局给所有 TextView 添加一个 RTL 属性 相关链接:setting-global-styles-for-views-in-android 123456789&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="android:textViewStyle"&gt;@style/TextViewStyle.TextDirection&lt;/item&gt; ...&lt;/style&gt;&lt;style name="TextViewStyle.TextDirection" parent="android:Widget.TextView"&gt; &lt;item name="android:textDirection"&gt;locale&lt;/item&gt;&lt;/style&gt; 判断是否是 RTL 布局1TextUtilsCompat.getLayoutDirectionFromLocale(Locale.getDefault()) == LayoutDirection.RTL 对集合进行倒序处理在某些场合下, 这个方法很有用 1Collections.reverse(List&lt;?&gt; list); 代码动态设置控件 setMargins1234FrameLayout.LayoutParams params = new FrameLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);params.setMargins(10, 0, 10, 0);params.setMarginEnd(10); ViewPager相关链接: tabs-swipe-direction-in-right-to-left-android-app Android 官方控件大多支持 RTL，ViewPager 除外，GitHub 上面有人对 ViewPager 进行修改支持 RTL, 地址 适配总结 横向布局 LinearLayout ，可以使用 FrameLayout，控件需要靠左或靠右可以使用 layout_gravity 设置对应属性 切换阿拉伯语时，网格布局 item 之间的距离会出现增大问题，处理方法是：网格分割线 ItemDecoration 需要加入语言来判断，调换原来设置左右的边距即可 禁止掉之前的侧滑返回，以免出现冲突 一些方向图标，重新做一个相对方向的放到 mipmap-ldrtl-xxxhdpi 包下 动画翻转, 放在 anim-ldrtl 将对应的动画进行反向处理 布局里如果设置了 paddingLeft、drawableLeft 等等这些属性更改为一个支持 RTL 的属性 paddingStart、drawableStart；但是有些地方可以不加的，例如：购物车上的数量徽章，加了之后感觉怪怪的，所以还是不加了 利用在 AS 右边的预览布局工具中的语言切换工具，切换成阿拉伯语，能实时看到布局的效果图 EditText 添加 android:layoutDirection=”locale” ，如果外面有 TextInputLayout 的需给它设置 android:textDirection=”locale” ，如果输入类型时密码时还需添加一个属性 android:textAlignment=”viewStart” TextView 需要加上 android:textAlignment=”viewStart 或 viewEnd” 以及 android:textDirection=”locale” RecyclerView 网络布局的可以考虑使用 StaggeredGridLayoutManager ，如果数量太多的网格布局，不太建议使用，可能会出现滑动混乱 阿拉伯语目录下的 String.xml 文件, 出现占位符 d% 需要注意改为 %d, 但又并不是所有都改成这样, 目前我发现当代码中使用了 Toast 和 SpannableString 属性的就需要更改为 %d 建议计划 从基础类开始入手，判断是否是阿拉伯语，如果是需要将界面设置为从右到左的显示方式 分模块进行适配 复杂的模块，可以放到 layout-ldrtl 包下，单独做一个布局来适配阿拉伯语，例如详情页 参考资料 https://android-developers.googleblog.com/2013/03/native-rtl-support-in-android-42.html https://medium.com/@zhangqichuan/rtl-support-in-android-898e11f31561 https://mobikul.com/just-few-steps-to-make-your-app-rtl-supportable/ https://blog.robustastudio.com/featured/android-rtl-support/ http://blog.csdn.net/figo0423/article/details/50241363 http://blog.csdn.net/wxx614817/article/details/50586388 http://jiajixin.cn/2016/10/08/android_adapt_rtl/ http://www.apkbus.com/blog-327085-57866.html http://droidyue.com/blog/2014/07/07/support-rtl-in-android/index.html http://chuansong.me/n/920084451521]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>阿拉伯语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻量级存储框架MMKV]]></title>
    <url>%2Fposts%2F4770b281.html</url>
    <content type="text"><![CDATA[一、前言APP 的性能优化之路是永无止境的, 这里学习一个腾讯开源用于提升本地存储效率的轻量级存储框架 MMKV 目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR 网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了 因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架 二、集成与测试以下介绍简单的使用方式, 更多详情请查看 Wiki 2.1 依赖注入在 App 模块的 build.gradle 文件里添加: 1234dependencies &#123; implementation &apos;com.tencent:mmkv:1.0.22&apos; // replace &quot;1.0.22&quot; with any available version&#125; 2.2 初始化1234// 设置初始化的根目录String dir = getFilesDir().getAbsolutePath() + "/mmkv_2";String rootDir = MMKV.initialize(dir);Log.i("MMKV", "mmkv root: " + rootDir); 2.3 获取实例12345678// 获取默认的全局实例MMKV kv = MMKV.defaultMMKV();// 根据业务区别存储, 附带一个自己的 IDMMKV kv = MMKV.mmkvWithID("MyID");// 多进程同步支持MMKV kv = MMKV.mmkvWithID("MyID", MMKV.MULTI_PROCESS_MODE); 2.4 CURD12345678// 添加/更新数据kv.encode(key, value);// 获取数据int tmp = kv.decodeInt(key);// 删除数据kv.removeValueForKey(key); 2.5 SP 的迁移123456789private void testImportSharedPreferences() &#123; MMKV mmkv = MMKV.mmkvWithID("myData"); SharedPreferences old_man = getSharedPreferences("myData", MODE_PRIVATE); // 迁移旧数据 mmkv.importFromSharedPreferences(old_man); // 清空旧数据 old_man.edit().clear().commit(); ......&#125; 2.6 数据测试以下是 MMKV、SharedPreferences 和 SQLite 同步写入 1000 条数据的测试结果 1234567891011121314151617181920// MMKVMMKV: MMKV write int: loop[1000]: 12 msMMKV: MMKV read int: loop[1000]: 3 msMMKV: MMKV write String: loop[1000]: 7 msMMKV: MMKV read String: loop[1000]: 4 ms// SharedPreferencesMMKV: SharedPreferences write int: loop[1000]: 119 msMMKV: SharedPreferences read int: loop[1000]: 3 msMMKV: SharedPreferences write String: loop[1000]: 187MMKV: SharedPreferences read String: loop[1000]: 2 ms// SQLiteMMKV: sqlite write int: loop[1000]: 101 msMMKV: sqlite read int: loop[1000]: 136 msMMKV: sqlite write String: loop[1000]: 29 msMMKV: sqlite read String: loop[1000]: 93 ms 可以看到 MMKV 无论是对比 SP 还是 SQLite, 在性能上都有非常大的优势, 官方提供的数据测试结果如下 更详细的性能测试见 wiki 了解 MMKV 的使用方式和测试结果, 让我对其实现原理产生了很大的好奇心, 接下来便看看它是如何将性能做到这个地步的, 这里对主要对 MMKV 的基本操作进行剖析 初始化 实例化 encode decode 进程读写的同步 我们从初始化的流程开始分析 三、初始化12345678910111213141516171819202122public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123; // call on program start public static String initialize(Context context) &#123; String root = context.getFilesDir().getAbsolutePath() + "/mmkv"; return initialize(root, null); &#125; static private String rootDir = null; public static String initialize(String rootDir, LibLoader loader) &#123; ...... // 省略库文件加载器相关代码 // 保存根目录 MMKV.rootDir = rootDir; // Native 层初始化 jniInitialize(MMKV.rootDir); return rootDir; &#125; private static native void jniInitialize(String rootDir); &#125; MMKV 的初始化, 主要是将根目录通过 jniInitialize 传入了 Native 层, 接下来看看 Native 的初始化操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// native-bridge.cppnamespace mmkv &#123; MMKV_JNI void jniInitialize(JNIEnv *env, jobject obj, jstring rootDir) &#123; if (!rootDir) &#123; return; &#125; const char *kstr = env-&gt;GetStringUTFChars(rootDir, nullptr); if (kstr) &#123; MMKV::initializeMMKV(kstr); env-&gt;ReleaseStringUTFChars(rootDir, kstr); &#125;&#125; &#125;// MMKV.cppstatic unordered_map&lt;std::string, MMKV *&gt; *g_instanceDic;static ThreadLock g_instanceLock;static std::string g_rootDir;void initialize() &#123; // 1.1 获取一个 unordered_map, 类似于 Java 中的 HashMap g_instanceDic = new unordered_map&lt;std::string, MMKV *&gt;; // 1.2 初始化线程锁 g_instanceLock = ThreadLock(); ......&#125;void MMKV::initializeMMKV(const std::string &amp;rootDir) &#123; // 由 Linux Thread 互斥锁和条件变量保证 initialize 函数在一个进程内只会执行一次 // https://blog.csdn.net/zhangxiao93/article/details/51910043 static pthread_once_t once_control = PTHREAD_ONCE_INIT; // 1. 进行初始化操作 pthread_once(&amp;once_control, initialize); // 2. 将根目录保存到全局变量 g_rootDir = rootDir; // 拷贝字符串 char *path = strdup(g_rootDir.c_str()); if (path) &#123; // 3. 根据路径, 生成目标地址的目录 mkPath(path); // 释放内存 free(path); &#125;&#125; 可以看到 initializeMMKV 中主要任务是初始化数据, 以及创建根目录 pthread_once_t: 类似于 Java 的单例, 其 initialize 方法在进程内只会执行一次 创建 MMKV 对象的缓存散列表 g_instanceDic 创建一个线程锁 g_instanceLock mkPath: 根据字符串创建文件目录 接下来我们看看这个目录创建的过程 3.1 目录的创建123456789101112131415161718192021222324252627282930313233// MmapedFile.cppbool mkPath(char *path) &#123; // 定义 stat 结构体用于描述文件的属性 struct stat sb = &#123;&#125;; bool done = false; // 指向字符串起始地址 char *slash = path; while (!done) &#123; // 移动到第一个非 "/" 的下标处 slash += strspn(slash, "/"); // 移动到第一个 "/" 下标出处 slash += strcspn(slash, "/"); done = (*slash == '\0'); *slash = '\0'; if (stat(path, &amp;sb) != 0) &#123; // 执行创建文件夹的操作, C 中无 mkdirs 的操作, 需要一个一个文件夹的创建 if (errno != ENOENT || mkdir(path, 0777) != 0) &#123; MMKVWarning("%s : %s", path, strerror(errno)); return false; &#125; &#125; // 若非文件夹, 则说明为非法路径 else if (!S_ISDIR(sb.st_mode)) &#123; MMKVWarning("%s: %s", path, strerror(ENOTDIR)); return false; &#125; *slash = '/'; &#125; return true;&#125; 以上是 Native 层创建文件路径的通用代码, 逻辑很清晰 好的, 文件目录创建好了之后, Native 层的初始化操作便结束了, 接下来看看 MMKV 实例构建的过程 四、实例化123456789101112131415161718192021222324public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123; @Nullable public static MMKV mmkvWithID(String mmapID, int mode, String cryptKey, String relativePath) &#123; ...... // 执行 Native 初始化, 获取句柄值 long handle = getMMKVWithID(mmapID, mode, cryptKey, relativePath); if (handle == 0) &#123; return null; &#125; // 构建一个 Java 的壳对象 return new MMKV(handle); &#125; private native static long getMMKVWithID(String mmapID, int mode, String cryptKey, String relativePath); // jni private long nativeHandle; private MMKV(long handle) &#123; nativeHandle = handle; &#125;&#125; 可以看到 MMKV 实例构建的主要逻辑通过 getMMKVWithID 方法实现, 看它内部做了什么 12345678910111213141516171819202122232425262728293031323334// native-bridge.cppnamespace mmkv &#123;MMKV_JNI jlong getMMKVWithID( JNIEnv *env, jobject, jstring mmapID, jint mode, jstring cryptKey, jstring relativePath) &#123; MMKV *kv = nullptr; if (!mmapID) &#123; return (jlong) kv; &#125; // 获取独立存储 id string str = jstring2string(env, mmapID); bool done = false; if (cryptKey) &#123; // 获取秘钥 string crypt = jstring2string(env, cryptKey); if (crypt.length() &gt; 0) &#123; if (relativePath) &#123; // 获取相对路径 string path = jstring2string(env, relativePath); // 通过 mmkvWithID 函数获取一个 MMKV 的对象 kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, &amp;path); &#125; else &#123; kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, nullptr); &#125; done = true; &#125; &#125; ...... // 强转成句柄, 返回到 Java return (jlong) kv;&#125;&#125; 可以看到最终通过 MMKV::mmkvWithID 函数获取到 MMKV 的对象 1234567891011121314151617181920212223242526272829303132333435// MMKV.cppMMKV *MMKV::mmkvWithID( const std::string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath) &#123; if (mmapID.empty()) &#123; return nullptr; &#125; SCOPEDLOCK(g_instanceLock); // 1. 通过 mmapID 和 relativePath, 组成最终的 mmap 文件路径的 key auto mmapKey = mmapedKVKey(mmapID, relativePath); // 2. 从全局缓存中查找 auto itr = g_instanceDic-&gt;find(mmapKey); if (itr != g_instanceDic-&gt;end()) &#123; MMKV *kv = itr-&gt;second; return kv; &#125; // 3. 创建缓存文件 if (relativePath) &#123; // 根据 mappedKVPathWithID 获取 mmap 的最终文件路径 // mmapID 使用 md5 加密 auto filePath = mappedKVPathWithID(mmapID, mode, relativePath); // 不存在则创建一个文件 if (!isFileExist(filePath)) &#123; if (!createFile(filePath)) &#123; return nullptr; &#125; &#125; ...... &#125; // 4. 创建实例对象 auto kv = new MMKV(mmapID, size, mode, cryptKey, relativePath); // 5. 缓存这个 mmapKey (*g_instanceDic)[mmapKey] = kv; return kv;&#125; mmkvWithID 函数的实现流程非常的清晰, 这里我们主要关注一下实例对象的创建流程 1234567891011121314151617181920212223242526272829303132333435// MMKV.cppMMKV::MMKV( const std::string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath) : m_mmapID(mmapedKVKey(mmapID, relativePath)) // 拼装文件的路径 , m_path(mappedKVPathWithID(m_mmapID, mode, relativePath)) // 拼装 .crc 文件路径 , m_crcPath(crcPathWithID(m_mmapID, mode, relativePath)) // 1. 将文件映射到内存 , m_metaFile(m_crcPath, DEFAULT_MMAP_SIZE, (mode &amp; MMKV_ASHMEM) ? MMAP_ASHMEM : MMAP_FILE) ...... , m_sharedProcessLock(&amp;m_fileLock, SharedLockType) ...... , m_isAshmem((mode &amp; MMKV_ASHMEM) != 0) &#123; ...... // 判断是否为 Ashmem 跨进程匿名共享内存 if (m_isAshmem) &#123; // 创共享内存的文件 m_ashmemFile = new MmapedFile(m_mmapID, static_cast&lt;size_t&gt;(size), MMAP_ASHMEM); m_fd = m_ashmemFile-&gt;getFd(); &#125; else &#123; m_ashmemFile = nullptr; &#125; // 根据 cryptKey 创建 AES 加解密的引擎 if (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; 0) &#123; m_crypter = new AESCrypt((const unsigned char *) cryptKey-&gt;data(), cryptKey-&gt;length()); &#125; ...... // sensitive zone &#123; SCOPEDLOCK(m_sharedProcessLock); // 2. 根据 m_mmapID 来加载文件中的数据 loadFromFile(); &#125;&#125; 可以从 MMKV 的构造函数中看到很多有趣的信息, MMKV 是支持 Ashmem 共享内存的, 这意味着即使是跨进程大数据的传输, 它也能够提供很好的性能支持 不过这里我们主要关注两个关键点 m_metaFile 文件的映射 loadFromFile 数据的载入 接下来我们先看看, 文件的映射 4.1 文件映射到内存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// MmapedFile.cppMmapedFile::MmapedFile(const std::string &amp;path, size_t size, bool fileType) : m_name(path), m_fd(-1), m_segmentPtr(nullptr), m_segmentSize(0), m_fileType(fileType) &#123; // 用于内存映射的文件 if (m_fileType == MMAP_FILE) &#123; // 1. 打开文件 m_fd = open(m_name.c_str(), O_RDWR | O_CREAT, S_IRWXU); if (m_fd &lt; 0) &#123; MMKVError("fail to open:%s, %s", m_name.c_str(), strerror(errno)); &#125; else &#123; // 2. 创建文件锁 FileLock fileLock(m_fd); InterProcessLock lock(&amp;fileLock, ExclusiveLockType); SCOPEDLOCK(lock); // 获取文件的信息 struct stat st = &#123;&#125;; if (fstat(m_fd, &amp;st) != -1) &#123; // 获取文件大小 m_segmentSize = static_cast&lt;size_t&gt;(st.st_size); &#125; // 3. 验证文件的大小是否小于一个内存页, 一般为 4kb if (m_segmentSize &lt; DEFAULT_MMAP_SIZE) &#123; m_segmentSize = static_cast&lt;size_t&gt;(DEFAULT_MMAP_SIZE); // 3.1 通过 ftruncate 将文件大小对其到内存页 // 3.2 通过 zeroFillFile 将文件对其后的空白部分用 0 填充 if (ftruncate(m_fd, m_segmentSize) != 0 || !zeroFillFile(m_fd, 0, m_segmentSize)) &#123; // 说明文件拓展失败了, 移除这个文件 close(m_fd); m_fd = -1; removeFile(m_name); return; &#125; &#125; // 4. 通过 mmap 将文件映射到内存, 获取内存首地址 m_segmentPtr = (char *) mmap(nullptr, m_segmentSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0); if (m_segmentPtr == MAP_FAILED) &#123; MMKVError("fail to mmap [%s], %s", m_name.c_str(), strerror(errno)); close(m_fd); m_fd = -1; m_segmentPtr = nullptr; &#125; &#125; &#125; // 用于共享内存的文件 else &#123; ...... &#125;&#125; MmapedFile 的构造函数处理的事务如下 打开指定的文件 创建这个文件锁 修正文件大小, 最小为 4kb 前 4kb 用于统计数据总大小 通过 mmap 将文件映射到内存 好的, 通过 MmapedFile 的构造函数, 我们便能够获取到映射后的内存首地址了, 操作这块内存时 Linux 内核会负责将内存中的数据同步到文件中 比起 SP 的数据同步, mmap 显然是要优雅的多, 即使进程意外死亡, 也能够通过 Linux 内核的保护机制, 将进行了文件映射的内存数据刷入到文件中, 提升了数据写入的可靠性 结下来看看数据的载入 4.2 数据的载入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// MMKV.cppvoid MMKV::loadFromFile() &#123; ......// 忽略匿名共享内存相关代码 // 若已经进行了文件映射 if (m_metaFile.isFileValid()) &#123; // 则获取相关数据 m_metaInfo.read(m_metaFile.getMemory()); &#125; // 获取文件描述符 m_fd = open(m_path.c_str(), O_RDWR | O_CREAT, S_IRWXU); if (m_fd &lt; 0) &#123; MMKVError(&quot;fail to open:%s, %s&quot;, m_path.c_str(), strerror(errno)); &#125; else &#123; // 1. 获取文件大小 m_size = 0; struct stat st = &#123;0&#125;; if (fstat(m_fd, &amp;st) != -1) &#123; m_size = static_cast&lt;size_t&gt;(st.st_size); &#125; // 1.1 将文件大小对其到内存页的整数倍 if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123; ...... &#125; // 2. 获取文件映射后的内存地址 m_ptr = (char *) mmap(nullptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0); if (m_ptr == MAP_FAILED) &#123; ...... &#125; else &#123; // 3. 读取内存文件的前 32 位, 获取存储数据的真实大小 memcpy(&amp;m_actualSize, m_ptr, Fixed32Size); ...... bool loadFromFile = false, needFullWriteback = false; if (m_actualSize &gt; 0) &#123; // 4. 验证文件的长度 if (m_actualSize &lt; m_size &amp;&amp; m_actualSize + Fixed32Size &lt;= m_size) &#123; // 5. 验证文件 CRC 的正确性 if (checkFileCRCValid()) &#123; loadFromFile = true; &#125; else &#123; // 若不正确, 则回调异常 CRC 异常 auto strategic = mmkv::onMMKVCRCCheckFail(m_mmapID); if (strategic == OnErrorRecover) &#123; loadFromFile = true; needFullWriteback = true; &#125; &#125; &#125; else &#123; // 回调文件长度异常 auto strategic = mmkv::onMMKVFileLengthError(m_mmapID); if (strategic == OnErrorRecover) &#123; writeAcutalSize(m_size - Fixed32Size); loadFromFile = true; needFullWriteback = true; &#125; &#125; &#125; // 6. 需要从文件获取数据 if (loadFromFile) &#123; ...... // 构建输入缓存 MMBuffer inputBuffer(m_ptr + Fixed32Size, m_actualSize, MMBufferNoCopy); if (m_crypter) &#123; // 解密输入缓冲中的数据 decryptBuffer(*m_crypter, inputBuffer); &#125; // 从输入缓冲中将数据读入 m_dic m_dic.clear(); MiniPBCoder::decodeMap(m_dic, inputBuffer); // 构建输出数据 m_output = new CodedOutputData(m_ptr + Fixed32Size + m_actualSize, m_size - Fixed32Size - m_actualSize); // 进行重整回写, 剔除重复的数据 if (needFullWriteback) &#123; fullWriteback(); &#125; &#125; // 7. 说明文件中没有数据, 或者校验失败了 else &#123; SCOPEDLOCK(m_exclusiveProcessLock); // 清空文件中的数据 if (m_actualSize &gt; 0) &#123; writeAcutalSize(0); &#125; m_output = new CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size); // 重新计算 CRC recaculateCRCDigest(); &#125; ...... &#125; &#125; ...... m_needLoadFromFile = false;&#125; 好的, 可以看到 loadFromFile 中对于 CRC 验证通过的文件, 会将文件中的数据读入到 m_dic 中缓存, 否则则会清空文件 因此用户恶意修改文件之后, 会破坏 CRC 的值, 这个存储数据便会被作废, 这一点要尤为注意 从文件中读取数据到 m_dic 之后, 会将 mdic 回写到文件中 , 其重写的目的是为了剔除重复的数据 关于为什么会出现重复的数据, 在后面 encode 操作中再分析 4.3 回顾到这里 MMKV 实例的构建就完成了, 有了 m_dic 这个内存缓存, 我们进行数据查询的效率就大大提升了 从最终的结果来看它与 SP 是一致的, 都是初次加载时会将文件中所有的数据加载到散列表中, 不过 MMKV 多了一步数据回写的操作, 因此当数据量比较大时, 对实例构建的速度有一定的影响 123// 写入 1000 条数据之后, MMVK 和 SharedPreferences 实例化的时间对比E/TAG: create MMKV instance time is 4 msE/TAG: create SharedPreferences instance time is 1 ms 从结果上来看, MMVK 的确在实例构造速度上有一定的劣势, 不过得益于是将 m_dic 中的数据写入到 mmap 的内存, 其真正进行文件写入的时机由 Linux 内核决定, 再加上文件的页缓存机制, 所以速度上虽有劣势, 但不至于无法接受 五、encode关于 encode 即数据的添加与更新的流程, 这里以 encodeString 为例 123456789public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123; public boolean encode(String key, String value) &#123; return encodeString(nativeHandle, key, value); &#125; private native boolean encodeString(long handle, String key, String value);&#125; 看看 native 层的实现 1234567891011121314151617181920212223// native-bridge.cppnamespace mmkv &#123;MMKV_JNI jboolean encodeString(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue) &#123; MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle); if (kv &amp;&amp; oKey) &#123; string key = jstring2string(env, oKey); // 若是 value 非 NULL if (oValue) &#123; // 通过 setStringForKey 函数, 将数据存入 string value = jstring2string(env, oValue); return (jboolean) kv-&gt;setStringForKey(value, key); &#125; // 若是 value 为 NULL, 则移除 key 对应的 value 值 else &#123; kv-&gt;removeValueForKey(key); return (jboolean) true; &#125; &#125; return (jboolean) false;&#125;&#125; 这里我们主要分析一下 setStringForKey 这个函数 12345678910// MMKV.cppbool MMKV::setStringForKey(const std::string &amp;value, const std::string &amp;key) &#123; if (key.empty()) &#123; return false; &#125; // 1. 将数据编码成 ProtocolBuffer auto data = MiniPBCoder::encodeDataWithObject(value); // 2. 更新键值对 return setDataForKey(std::move(data), key);&#125; 这里主要分为两步操作 数据编码 更新键值对 5.1 数据的编码MMKV 采用的是 ProtocolBuffer 编码方式, 这里就不做过多介绍了, 具体请查看 Google 官方文档 1234567891011121314151617181920212223242526272829303132333435363738// MiniPBCoder.cppMMBuffer MiniPBCoder::getEncodeData(const string &amp;str) &#123; // 1. 创建编码条目的集合 m_encodeItems = new vector&lt;PBEncodeItem&gt;(); // 2. 为集合填充数据 size_t index = prepareObjectForEncode(str); PBEncodeItem *oItem = (index &lt; m_encodeItems-&gt;size()) ? &amp;(*m_encodeItems)[index] : nullptr; if (oItem &amp;&amp; oItem-&gt;compiledSize &gt; 0) &#123; // 3. 开辟一个内存缓冲区, 用于存放编码后的数据 m_outputBuffer = new MMBuffer(oItem-&gt;compiledSize); // 4. 创建一个编码操作对象 m_outputData = new CodedOutputData(m_outputBuffer-&gt;getPtr(), m_outputBuffer-&gt;length()); // 执行 protocolbuffer 编码, 并输出到缓冲区 writeRootObject(); &#125; // 调用移动构造函数, 重新创建实例返回 return move(*m_outputBuffer);&#125;size_t MiniPBCoder::prepareObjectForEncode(const string &amp;str) &#123; // 2.1 创建 PBEncodeItem 对象用来描述待编码的条目, 并添加到 vector 集合 m_encodeItems-&gt;push_back(PBEncodeItem()); // 2.2 获取 PBEncodeItem 对象 PBEncodeItem *encodeItem = &amp;(m_encodeItems-&gt;back()); // 2.3 记录索引位置 size_t index = m_encodeItems-&gt;size() - 1; &#123; // 2.4 填充编码类型 encodeItem-&gt;type = PBEncodeItemType_String; // 2.5 填充要编码的数据 encodeItem-&gt;value.strValue = &amp;str; // 2.6 填充数据大小 encodeItem-&gt;valueSize = static_cast&lt;int32_t&gt;(str.size()); &#125; // 2.7 计算编码后的大小 encodeItem-&gt;compiledSize = pbRawVarint32Size(encodeItem-&gt;valueSize) + encodeItem-&gt;valueSize; return index;&#125; 可以看到, 再未进行编码操作之前, 编码后的数据大小就已经确定好了, 并且将它保存在了 encodeItem-&gt;compiledSize 中, 接下来我们看看执行数据编码并输出到缓冲区的操作流程 1234567891011121314151617181920212223242526// MiniPBCoder.cppvoid MiniPBCoder::writeRootObject() &#123; for (size_t index = 0, total = m_encodeItems-&gt;size(); index &lt; total; index++) &#123; PBEncodeItem *encodeItem = &amp;(*m_encodeItems)[index]; switch (encodeItem-&gt;type) &#123; // 主要关心编码 String case PBEncodeItemType_String: &#123; m_outputData-&gt;writeString(*(encodeItem-&gt;value.strValue)); break; &#125; ...... &#125; &#125;&#125;// CodedOutputData.cppvoid CodedOutputData::writeString(const string &amp;value) &#123; size_t numberOfBytes = value.size(); ...... // 1. 按照 varint 方式编码字符串长度, 会改变 m_position 的值 this-&gt;writeRawVarint32((int32_t) numberOfBytes); // 2. 将字符串的数据拷贝到编码好的长度后面 memcpy(m_ptr + m_position, ((uint8_t *) value.data()), numberOfBytes); // 更新 position 的值 m_position += numberOfBytes;&#125; 可以看到 CodedOutputData 的 writeString 中按照 protocol buffer 进行了字符串的编码操作 其中 m_ptr 是上面开辟的内存缓冲区的地址, 也就是说 writeString 执行结束之后, 数据就已经被写入缓冲区了 有了编码好的数据缓冲区, 接下来看看更新键值对的操作 5.2键值对的更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// MMKV.cppbool MMKV::setStringForKey(const std::string &amp;value, const std::string &amp;key) &#123; // 编码数据获取存放数据的缓冲区 auto data = MiniPBCoder::encodeDataWithObject(value); // 更新键值对 return setDataForKey(std::move(data), key);&#125;bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, const std::string &amp;key) &#123; ...... // 将键值对写入 mmap 文件映射的内存中 auto ret = appendDataWithKey(data, key); // 写入成功, 更新散列数据 if (ret) &#123; m_dic[key] = std::move(data); m_hasFullWriteback = false; &#125; return ret;&#125;bool MMKV::appendDataWithKey(const MMBuffer &amp;data, const std::string &amp;key) &#123; // 1. 计算 key + value 的 ProtocolBuffer 编码后的长度 size_t keyLength = key.length(); size_t size = keyLength + pbRawVarint32Size((int32_t) keyLength); size += data.length() + pbRawVarint32Size((int32_t) data.length()); SCOPEDLOCK(m_exclusiveProcessLock); // 2. 验证是否有足够的空间, 不足则进行数据重整与扩容操作 bool hasEnoughSize = ensureMemorySize(size); if (!hasEnoughSize || !isFileValid()) &#123; return false; &#125; // 3. 更新文件头的数据总大小 writeAcutalSize(m_actualSize + size); // 4. 将 key 和编码后的 value 写入到文件映射的内存 m_output-&gt;writeString(key); m_output-&gt;writeData(data); // 5. 获取文件映射内存当前 &lt;key, value&gt; 的起始位置 auto ptr = (uint8_t *) m_ptr + Fixed32Size + m_actualSize - size; if (m_crypter) &#123; // 加密这块区域 m_crypter-&gt;encrypt(ptr, ptr, size); &#125; // 6. 更新 CRC updateCRCDigest(ptr, size, KeepSequence); return true;&#125; 好的, 可以看到更新键值对的操作还是比较复杂的, 首先将键值对数据写入到文件映射的内存中, 写入成功之后更新散列数据 关于写入到文件映射的过程, 上面代码中的注释也非常的清晰, 接下来我们 ensureMemorySize 是如何进行数据的重整与扩容的 5.2.1 数据的重整与扩容123456789101112131415161718192021222324252627282930313233343536373839404142// MMKV.cppbool MMKV::ensureMemorySize(size_t newSize) &#123; ...... // 计算新键值对的大小 constexpr size_t ItemSizeHolderSize = 4; if (m_dic.empty()) &#123; newSize += ItemSizeHolderSize; &#125; // 数据重写: // 1. 文件剩余空闲空间少于新的键值对 // 2. 散列为空 if (newSize &gt;= m_output-&gt;spaceLeft() || m_dic.empty()) &#123; // 计算所需的数据空间 static const int offset = pbFixed32Size(0); MMBuffer data = MiniPBCoder::encodeDataWithObject(m_dic); size_t lenNeeded = data.length() + offset + newSize; if (m_isAshmem) &#123; ...... &#125; else &#123; // // 计算每个键值对的平均大小 size_t avgItemSize = lenNeeded / std::max&lt;size_t&gt;(1, m_dic.size()); // 计算未来可能会使用的大小(类似于 1.5 倍) size_t futureUsage = avgItemSize * std::max&lt;size_t&gt;(8, (m_dic.size() + 1) / 2); // 1. 所需空间 &gt;= 当前文件总大小 // 2. 所需空间的 1.5 倍 &gt;= 当前文件总大小 if (lenNeeded &gt;= m_size || (lenNeeded + futureUsage) &gt;= m_size) &#123; // 扩容为 2 倍 size_t oldSize = m_size; do &#123; m_size *= 2; &#125; while (lenNeeded + futureUsage &gt;= m_size); ....... &#125; &#125; ...... // 进行数据的重写 writeAcutalSize(data.length()); ...... &#125; return true;&#125; 从上面的代码我们可以了解到 数据的重写时机 文件剩余空间少于新的键值对大小 散列为空 文件扩容时机 所需空间的 1.5 倍超过了当前文件的总大小时, 扩容为之前的两倍 5.3回顾至此 encode 的流程我们就走完了, 回顾一下整个 encode 的流程 使用 ProtocolBuffer 编码 value 将 key 和 编码后的 value 使用 ProtocolBuffer 的格式 append 到文件映射区内存的尾部 文件空间不足 判断是否需要扩容 进行数据的回写 即在文件后进行追加 对这个键值对区域进行统一的加密 更新 CRC 的值 将 key 和 value 对应的 ProtocolBuffer 编码内存区域, 更新到散列表 m_dic 中 通过 encode 的分析, 我们得知 MMKV 文件的存储方式如下 接下来看看 decode 的流程 六、decodedecode 的过程同样以 decodeString 为例 1234567891011121314151617181920212223242526272829303132333435363738394041// native-bridge.cppMMKV_JNI jstringdecodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) &#123; MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle); if (kv &amp;&amp; oKey) &#123; string key = jstring2string(env, oKey); // 通过 getStringForKey, 将数据输出到传出参数中 value 中 string value; bool hasValue = kv-&gt;getStringForKey(key, value); if (hasValue) &#123; return string2jstring(env, value); &#125; &#125; return oDefaultValue;&#125;// MMKV.cppbool MMKV::getStringForKey(const std::string &amp;key, std::string &amp;result) &#123; if (key.empty()) &#123; return false; &#125; SCOPEDLOCK(m_lock); // 1. 从内存缓存中获取数据 auto &amp;data = getDataForKey(key); if (data.length() &gt; 0) &#123; // 2. 解析 data 对应的 ProtocolBuffer 数据 result = MiniPBCoder::decodeString(data); return true; &#125; return false;&#125;const MMBuffer &amp;MMKV::getDataForKey(const std::string &amp;key) &#123; // 从散列表中获取 key 对应的 value auto itr = m_dic.find(key); if (itr != m_dic.end()) &#123; return itr-&gt;second; &#125; static MMBuffer nan(0); return nan;&#125; 好的可以看到 decode 的流程比较简单, 先从内存缓存中获取 key 对应的 value 的 ProtocolBuffer 内存区域, 再解析这块内存区域, 从中获取真正的 value 值 6.1 思考看到这里可能会有一个疑问, 为什么 m_dic 不直接存储 key 和 value 原始数据呢, 这样查询效率不是更快吗? 如此一来查询效率的确会更快, 因为少了 ProtocolBuffer 解码的过程 从图上的结果可以看出, MMKV 的读取性能时略低于 SharedPreferences 的, 这里笔者给出自己的思考 m_dic 在数据重整中也起到了非常重要的作用, 需要依靠 m_dic 将数据写入到 mmap 的文件映射区, 这个过程是非常耗时的, 若是原始的 value, 则需要对所有的 value 再进行一次 ProtocolBuffer 编码操作, 尤其是当数据量比较庞大时, 其带来的性能损耗更是无法忽略的 既然 m_dic 还承担着方便数据复写的功能, 那能否再添加一个内存缓存专门用于存储原始的 value 呢? 当然可以, 这样 MMKV 的读取定是能够达到 SharedPreferences 的水平, 不过 value 的内存消耗则会加倍, MMKV 作为一个轻量级缓存的框架, 查询时时间的提升幅度还不足以用内存加倍的代价去换取, 我想这是 Tencent 在进行多方面权衡之后, 得到的一个比较合理的解决方案 七、进程读写的同步说起进程间读写同步, 我们很自然的想到 Linux 的共享内存配合信号量使用的案例, 但是这种方式有一个弊端, 那就是当持有锁的进程意外死亡的时候, 并不会释放其拥有的信号量, 若多进程之间存在竞争, 那么阻塞的进程将不会被唤醒, 这是非常危险的 MMKV 是采用 文件锁 的方式来进行进程间的同步操作 LOCK_SH(共享锁): 多个进程可以使用同一把锁, 常被用作读共享锁 LOCK_EX(排他锁): 同时只允许一个进程使用, 常被用作写锁 LOCK_UN: 释放锁 接下来我看看 MMKV 加解锁的操作 7.1 文件共享锁123456789101112131415161718192021222324MMKV::MMKV( const std::string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath) : m_mmapID(mmapedKVKey(mmapID, relativePath)) // 创建文件锁的描述 , m_fileLock(m_metaFile.getFd()) // 描述共享锁 , m_sharedProcessLock(&amp;m_fileLock, SharedLockType) // 描述排它锁 , m_exclusiveProcessLock(&amp;m_fileLock, ExclusiveLockType) // 判读是否为进程间通信 , m_isInterProcess((mode &amp; MMKV_MULTI_PROCESS) != 0 || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != 0) , m_isAshmem((mode &amp; MMKV_ASHMEM) != 0) &#123; ...... // 根据是否跨进程操作判断共享锁和排它锁的开关 m_sharedProcessLock.m_enable = m_isInterProcess; m_exclusiveProcessLock.m_enable = m_isInterProcess; // sensitive zone &#123; // 文件读操作, 启用了文件共享锁 SCOPEDLOCK(m_sharedProcessLock); loadFromFile(); &#125;&#125; 可以看到在我们前面分析过的构造函数中, MMKV 对文件锁进行了初始化, 并且创建了共享锁和排它锁, 并在跨进程操作时开启, 当进行读操作时, 启动了共享锁 7.2 文件排它锁1234567891011121314151617181920212223242526bool MMKV::fullWriteback() &#123; ...... auto allData = MiniPBCoder::encodeDataWithObject(m_dic); // 启动了排它锁 SCOPEDLOCK(m_exclusiveProcessLock); if (allData.length() &gt; 0) &#123; if (allData.length() + Fixed32Size &lt;= m_size) &#123; if (m_crypter) &#123; m_crypter-&gt;reset(); auto ptr = (unsigned char *) allData.getPtr(); m_crypter-&gt;encrypt(ptr, ptr, allData.length()); &#125; writeAcutalSize(allData.length()); delete m_output; m_output = new CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size); m_output-&gt;writeRawData(allData); // note: don't write size of data recaculateCRCDigest(); m_hasFullWriteback = true; return true; &#125; else &#123; // ensureMemorySize will extend file &amp; full rewrite, no need to write back again return ensureMemorySize(allData.length() + Fixed32Size - m_size); &#125; &#125; return false;&#125; 在进行数据回写的函数中, 启动了排它锁 7.3 读写效率表现其进程同步读写的性能表现如下 可以看到进程同步读写的效率也是非常 nice 的 关于跨进程同步就介绍到这里, 当然 MMKV 的文件锁并没有表面上那么简单, 因为文件锁为状态锁, 无论加了多少次锁, 一个解锁操作就全解除, 显然无法应对子函数嵌套调用的问题, MMKV 内部通过了自行实现计数器来实现锁的可重入性, 更多的细节可以查看 wiki 总结通过上面的分析, 我们对 MMKV 有了一个整体上的把控, 其具体的表现如下所示 项目 评价 描述 正确性 优 支持多进程安全, 使用 mmap, 由操作系统保证数据回写的正确性 时间开销 优 使用 mmap 实现, 减少了用户空间数据到内核空间的拷贝 空间开销 中 使用 protocl buffer 存储数据, 同样的数据会比 xml 和 json 消耗空间小 使用的是数据追加到末尾的方式, 只有到达一定阈值之后才会触发键值合并, 不合并之前会导致同一个 key 存在多份 安全 中 使用 crc 校验, 甄别文件系统和操作系统不稳定导致的异常数据 开发成本 优 使用方式较为简单 兼容性 优 各个安卓版本都前后兼容 虽然 MMKV 一些场景下比 SP 稍慢(如: 首次实例化会进行数据的复写剔除重复数据, 比 SP 稍慢, 查询数据时存在 ProtocolBuffer 解码, 比 SP 稍慢), 但其逆天的数据写入速度、mmap Linux 内核保证数据的同步, 以及 ProtocolBuffer 编码带来的更小的本地存储空间占用等都是非常棒的闪光点 在分析 MMKV 的代码的过程中, 从中学习到了很多知识, 非常感谢 Tencent 为开源社区做出的贡献 八、参考文献 github.com/Tencent/MMK… developers.google.com/protocol-bu… time.geekbang.org/column/arti… www.cnblogs.com/kex1n/p/710…]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BannerViewPage]]></title>
    <url>%2Fposts%2F6831bdd1.html</url>
    <content type="text"><![CDATA[BannerViewPageBanner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于OKR的解读]]></title>
    <url>%2Fposts%2F5b77eb6.html</url>
    <content type="text"><![CDATA[OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。 具体拆解如下： 1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。 2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。 以季度（或者其他预先规定的周期）为单位刷新OKR； 仔细确认结果达成情况； 如有必要，持续修正现行战略和商业模式； 结果导向。 3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。 4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。 5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。 6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是灰度发布，灰度测试]]></title>
    <url>%2Fposts%2F5b196854.html</url>
    <content type="text"><![CDATA[什么是灰度发布？灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。 灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。 灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。 灰度发布的意义灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。 灰度发布步骤 定义目标 选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等 筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等 部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调 发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表 产品完善 新一轮灰度发布或完整发布]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.lang.ClassNotFoundException:"org.apache.http.ProtocolVersion"]]></title>
    <url>%2Fposts%2Fc7a54c5f.html</url>
    <content type="text"><![CDATA[运行项目遇到以下问题： Caused by: java.lang.ClassNotFoundException: Didn’t find class “org.apache.http.ProtocolVersion” on path: DexPathList[[zip file “/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk”],nativeLibraryDirectories=[/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk!/lib/arm64-v8a, /system/lib64, /product/lib64]] 解决方案：1.在清单文件增加代码: 12&lt;application android:usesCleartextTraffic="true"&gt; 2.在清单文件清单再加一句代码： 123456 &lt;application android:usesCleartextTraffic="true"&gt; &lt;uses-library android:name="org.apache.http.legacy" android:required="false" /&gt;&lt;/application&gt; 好了，重新运行解决了.最根本的做法是使用https进行接口访问，毕竟涉及数据的安全性。当然了，这需要服务器的支持。还有第三方sdk，也需要使用https。]]></content>
      <categories>
        <category>Android</category>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoogleMap使用介绍]]></title>
    <url>%2Fposts%2F50fe3b5b.html</url>
    <content type="text"><![CDATA[概述通过本文，你可以知道如何使用 GoogleMap 相关 API、定位当前位置、获取当前所在城市、获取当前位置附近的地点、导航、地点搜索等内容。大致内容，可以查看如下思维导图。 特别注意：demo 使用的 GoogleMap key 对应我自己电脑的 keystore，如果重新编译项目，生成的apk使用的是你的电脑的 keystore，和我的 keystore 是不一样的，所以要正常运行， 直接下载我编译好的 apk； 用我的项目包名，和你自己的 keystore 的 SHA-1 去申请新的 GoogleMap key。（方法在下面，往下看哈） 前期准备网络因为国内众所周知的网络问题，谷歌地图的页面加载和 API 的使用会出现无效的情况，如果你要使用或调试，首先要确保是可以科学上网的。 设备Android 设备，必须安装了 Google 服务。 谷歌账号作为用户，不需要拥有或者登录你的 Google 账号。网络和 Google 服务正常即可。 作为开发者，必须拥有一个 Google 账号。要知道，谷歌地图是不开源的，要使用他的 API ，必须用你的包名，和编译 Android app 的 keystore 的 SHA-1，去申请App 对应的 Google Map Key。获取 Key 的教程官网讲得很详细，请看这里 Google API Console 设置完成后，如下图所示： 设置好后，还要确保已经 Enable了对应的API，不然会出现数据访问不到的情况。 把这个 API key 填入 AndroidManifest.xml ： 123&lt;meta-data android:name="com.google.android.geo.API_KEY" android:value="your key" /&gt; Map 相关前提初始化 Google Map布局在你的布局文件里面，只需要如下方式声明一个 Fragment，这个 Fragment 是可以放在 LinearLayout 或 RelativeLayout 下面的。 12345678&lt;fragment android:id="@+id/map" android:layout_width="match_parent" android:layout_height="match_parent" map:uiZoomControls="true" map:uiCompass = "true" class="com.google.android.gms.maps.SupportMapFragment" android:layout_below="@id/layout_btn"/&gt; Activity在 onCreate 的时候，进行初始化操作。 12345678910private GoogleMap mMap;SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager() .findFragmentById(map);mapFragment.getMapAsync(new OnMapReadyCallback() &#123; @Override public void onMapReady(GoogleMap googleMap) &#123; //初始化完 GoogleMap mMap = googleMap; &#125;&#125;); 确保 GoogleMap 实例化在使用 GoogleMap 相关接口前，必须确保 GoogleMap 已经实例化，即已经在 onMapReady回调中获取了 GoogleMap实例。 开关类定位按钮定位功能必须获取用户的位置权限，判断是非获取了用户权限，没有获取则手动请求权限。 12345678910111213141516171819202122232425262728/** * * 检查定位权限，如果未授权则请求该权限 * @return true：已经授权； false：未授权 */private boolean checkLocationPermission() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; // Permission to access the location is missing. PermissionUtils.requestPermission(this, LOCATION_PERMISSION_REQUEST_CODE, Manifest.permission.ACCESS_FINE_LOCATION, true); return false; &#125; return true;&#125;public static void requestPermission(FragmentActivity activity, int requestId, String permission, boolean finishActivity) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) &#123; // Display a dialog with rationale. PermissionUtils.RationaleDialog.newInstance(requestId, finishActivity) .show(activity.getSupportFragmentManager(), "dialog"); &#125; else &#123; // Location permission has not been granted yet, request it. ActivityCompat.requestPermissions(activity, new String[]&#123;permission&#125;, requestId); &#125;&#125; 要让地图上显示开关按钮，只需要设置mMap.setMyLocationEnabled(true); 点击此按钮，地图的摄像头就会开始移动，定位到当前设备所在位置，如果要获取点击此按钮的回调，可以设置监听器 mMap.setOnMyLocationButtonClickListener 放大／缩小按钮地图的放大缩小，就以摄像头焦点（地图中心）进行缩放。要出现这个开关，只需要 12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setZoomControlsEnabled(true); 指南针按钮12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setCompassEnabled(true); 手势 旋转 12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setRotateGesturesEnabled(mRotateGesturesEnabled); 平移 12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setScrollGesturesEnabled(mScrollGesturesEnabled); 自定义标注清除标注1mMap.clear(); 新增标注增加一个标注，只需要把当前的经纬度，图标，标题等信息传入 MarkerOptions ，之后在 addMarker 到 map对象即可。 1234567LatLng latLng = new LatLng(latitude, longitude);//标记当前坐标mMap.addMarker(new MarkerOptions() .position(latLng) .icon(BitmapDescriptorFactory.fromResource(R.drawable.icon_position_small)) .title(getString(R.string.map_camera_center_location))); 摄像头当前位置123//获取当前摄像头中心点的坐标double latitude = mMap.getCameraPosition().target.latitude;double longitude = mMap.getCameraPosition().target.longitude; 移动相关监听 开始监听 1234567891011121314151617//摄像头开始滑动监听mMap.setOnCameraMoveStartedListener(new GoogleMap.OnCameraMoveStartedListener() &#123; @Override public void onCameraMoveStarted(int reason) &#123; if (reason == GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE) &#123; //表示摄像头移动是为了响应用户在地图上做出的手势，如平移、倾斜、通过捏合手指进行缩放或旋转地图 &#125; else if (reason == GoogleMap.OnCameraMoveStartedListener .REASON_API_ANIMATION) &#123; //表示 API 移动摄像头是为了响应非手势用户操作，如点按 zoom 按钮、点按 My Location 按钮或点击标记 &#125; else if (reason == GoogleMap.OnCameraMoveStartedListener .REASON_DEVELOPER_ANIMATION) &#123; //表示您的应用已发起摄像头移动 &#125; &#125;&#125; ; 取消 1234567//摄像头移动停止状态的监听mMap.setOnCameraIdleListener(new GoogleMap.OnCameraIdleListener() &#123; @Override public void onCameraIdle() &#123; &#125;&#125;); 停止 1234567//摄像头移动中被取消时的监听mMap.setOnCameraMoveCanceledListener(new GoogleMap.OnCameraMoveCanceledListener() &#123; @Override public void onCameraMoveCanceled() &#123; &#125;&#125;); 点击监听点击123456789//点击地图上某个坐标mMap.setOnMapClickListener(new GoogleMap.OnMapClickListener() &#123; @Override public void onMapClick(LatLng latLng) &#123; Toast.makeText(MapActivity.this, getString(R.string.map_click_tip, latLng.latitude, latLng.longitude), Toast.LENGTH_SHORT).show(); &#125;&#125;); 长按123456789//长按地图上某个坐标mMap.setOnMapLongClickListener(new GoogleMap.OnMapLongClickListener() &#123; @Override public void onMapLongClick(LatLng latLng) &#123; Toast.makeText(MapActivity.this, getString(R.string.map_long_click_tip, latLng.latitude, latLng.longitude), Toast.LENGTH_SHORT).show(); &#125;&#125;); 点击景点123456789//点击地图上某个景点mMap.setOnPoiClickListener(new GoogleMap.OnPoiClickListener() &#123; @Override public void onPoiClick(PointOfInterest pointOfInterest) &#123; Toast.makeText(MapActivity.this, getString(R.string.map_place_click_tip, pointOfInterest.name, pointOfInterest.placeId, pointOfInterest.latLng.latitude, pointOfInterest.latLng.longitude), Toast.LENGTH_SHORT).show(); &#125;&#125;); 快照快照分两种，一种是直接不管地图有没有加载完，就把当前的地图截屏，如果此时地图未加载完，截取的图片会出现模糊的情况；另外一种是判断地图是否在加载中，如果是，则等加载完毕再截图，如果不是，就直接截图。 123456789101112131415161718192021222324252627//是否等待地图加载完毕if (mWaitForMapLoaded) &#123; //获取加载完的高清图片 mMap.setOnMapLoadedCallback(new GoogleMap.OnMapLoadedCallback() &#123; @Override public void onMapLoaded() &#123; if (null != mMap) &#123; mMap.snapshot(new GoogleMap.SnapshotReadyCallback() &#123; @Override public void onSnapshotReady(Bitmap bitmap) &#123; //获取bitmap &#125; &#125;); &#125; &#125; &#125;);&#125; else &#123; //未加载完，就执行快照功能，会导致截取模糊图片 mMap.snapshot(new GoogleMap.SnapshotReadyCallback() &#123; @Override public void onSnapshotReady(Bitmap bitmap) &#123; //获取bitmap &#125; &#125;);&#125; GoogleApiClient前提 初始化 GoogleApiClient 在 onCreate 的时候进行初始化操作 123456789101112131415161718192021222324252627282930313233343536373839/** * 初始化 google client 用于获取地点信息 */private void createGoogleApiClient() &#123; if (mGoogleApiClient == null) &#123; mGoogleApiClient = new GoogleApiClient .Builder(this) .addApi(Places.GEO_DATA_API) .addApi(Places.PLACE_DETECTION_API) .addApi(LocationServices.API) .addConnectionCallbacks(new GoogleApiClient.ConnectionCallbacks() &#123; @Override public void onConnected(@Nullable Bundle bundle) &#123; //连接成功 mConnected = true; &#125; @Override public void onConnectionSuspended(int i) &#123; //连接暂停 &#125; &#125;) .addOnConnectionFailedListener(new GoogleApiClient.OnConnectionFailedListener() &#123; @Override public void onConnectionFailed(@NonNull ConnectionResult connectionResult) &#123; //连接失败 mConnected = false; &#125; &#125;) .enableAutoManage(this, new GoogleApiClient.OnConnectionFailedListener() &#123; @Override public void onConnectionFailed(@NonNull ConnectionResult connectionResult) &#123; //连接失败 mConnected = false; &#125; &#125;) .build(); &#125;&#125; 在 onStart() 的时候连接，在 onStop() 的时候，断开连接。 123456789101112131415@Overrideprotected void onStart() &#123; super.onStart(); if (null != mGoogleApiClient) &#123; mGoogleApiClient.connect(); &#125;&#125;@Overrideprotected void onStop() &#123; super.onStop(); if (null != mGoogleApiClient) &#123; mGoogleApiClient.disconnect(); &#125;&#125; 使用位置相关 API 的前提，必须确保用户授予位置权限。方法同上的 checkLocationPermission() 获取当前定位的经纬度坐标科普 WGS-84 国际标准的坐标系，国际标准的 GPS 设备定位获取的就是这种坐标。简称 地球坐标系。 GCJ-02 在我们国家，据说是为了保密，我们不使用 WGS-84 坐标，而是使用经过加密的 GCJ-02，高德地图，谷歌地图（国内板块）都是使用这个坐标系。这个就是俗称的 火星坐标系。 其他坐标系 比如百度地图，他用的是他们家的 BD-09 坐标，这个只适用于百度相关产品。搜狗地图也有自己的坐标。 格式注意到谷歌地图的坐标是 latitude, longitude 格式，即 纬度，经度 格式。和国内的百度，高德坐标写法是反过来的。国内的一般是 经度，纬度 的方式。 API1234567Location lastLocation = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);if (null != lastLocation) &#123; double latitude = lastLocation.getLatitude(); double longitude = lastLocation.getLongitude();&#125; else &#123; &#125; 刚开始我也以为这么简单就可以了，在测试设备上确实可以获取到坐标，但是实际上，大多数情况，在第一次运行定位的时候，获取的 Location 对象是为null。所以还需要注册位置变化的监听。等监听到位置信息后，移除此监听，防止不断监听引起高耗电现象。这部分百度地图用得很方便，他封装好了，但是谷歌地图就要自己实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private long UPDATE_INTERVAL = 10 * 1000; /* 10 secs */private long FASTEST_INTERVAL = 1500; /* 1.5 sec */private final int MAX_TIME = 2; //最多定位次数private int time;if (null != lastLocation) &#123; //.....&#125; else &#123; //如果获取不到位置信息，注册位置变化监听 regLocationUpdates();&#125;private void regLocationUpdates() &#123; if (!checkLocationPermission()) &#123; showContentText(getString(R.string.cilent_permission_failed)); return; &#125; LocationRequest locationRequest = LocationRequest.create() .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY) .setInterval(UPDATE_INTERVAL) .setFastestInterval(FASTEST_INTERVAL); LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, locationRequest, new LocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; time++; //如果获取到位置信息，则移除位置变化监听 if (null != location) &#123; LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this); //获取定位的经纬度 double latitude = location.getLatitude(); double longitude = location.getLongitude(); return; &#125; //如果超过最大的定位次数则停止位置变化监听 if (time == MAX_TIME) &#123; //移除位置变化监听 LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this); //获取当前位置失败 &#125; &#125; &#125;);&#125; 现在终于获取到定位坐标了，等等，好像不太对，这个坐标和我实际位置好像有不少的偏差…..我打开了 GoogleMap 这个官方的 APP，点击了他的定位。这下就懵逼了，怎么官方的这个是没问题了，误差很小…. 我明明用的是 GoogleMap 的 API，为什么定位会不一样？ 原因在刚才的坐标系里面，谷歌地图的国内板块是用 GCJ-02，但是定位 API 获取的坐标是国际标准坐标 WGS-84，所以需要把 WGS-84 转化 GCJ-02。 那谷歌地图 APP 上为什么可以呢？ 我猜测，谷歌地图在访问网络的时候，会进行位置判断，如果是国内坐标，就进行转换，国外坐标就不转换。 WGS-84 转化 GCJ-02 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static double a = 6378245.0;static double ee = 0.00669342162296594323;/** * 把 WGS-84 转换成 GCJ-02 * @param wgLoc * @return */public static LatLng transformFromWGSToGCJ(LatLng wgLoc) &#123; //如果在国外，则默认不进行转换 if (outOfChina(wgLoc.latitude, wgLoc.longitude)) &#123; //return new LatLng(wgLoc.latitude, wgLoc.longitude); return wgLoc; &#125; double dLat = transformLat(wgLoc.longitude - 105.0, wgLoc.latitude - 35.0); double dLon = transformLon(wgLoc.longitude - 105.0, wgLoc.latitude - 35.0); double radLat = wgLoc.latitude / 180.0 * Math.PI; double magic = Math.sin(radLat); magic = 1 - ee * magic * magic; double sqrtMagic = Math.sqrt(magic); dLat = (dLat * 180.0)/ ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI); dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI); return new LatLng(wgLoc.latitude + dLat, wgLoc.longitude + dLon);&#125;private static double transformLat(double x, double y) &#123; double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(x &gt; 0 ? x : -x); ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0; ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0; return ret;&#125;private static double transformLon(double x, double y) &#123; double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(x &gt; 0 ? x : -x); ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0; ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0; return ret;&#125;/** * 判断是否在中国以外 * @param lat * @param lon * @return */public static boolean outOfChina(double lat, double lon) &#123; if (lon &lt; 72.004 || lon &gt; 137.8347) return true; if (lat &lt; 0.8293 || lat &gt; 55.8271) return true; return false;&#125; 根据经纬度获取附近地点通过经纬度获取对应的地理位置信息，这个叫做反地理编码请求，以前百度地图有个 API mGeoCoder.reverseGeoCode(mReverseGeoCodeOption);可以直接使用，Google地图也有类似的，只不过在我使用过程中存在 bug。 心急想马上能用的，可以自己调到 Web API 中的 【根据经纬度获取附近地点】章节。 此处存在的问题：如果坐标切换为国外，就会造成获取数据为null。即使修改地区 mGeocoder = new Geocoder(this, Locale.JAPAN) 也无效。 初始化 Geocoder 123mGeocoder = new Geocoder(this, Locale.getDefault());//设置区域//mGeocoder = new Geocoder(this, Locale.JAPAN); 在子线程获取数据 1234567891011121314List&lt;Address&gt; addressList = mGeocoder.getFromLocation(latitude, longitude, maxResult);if (null != addressList &amp;&amp; addressList.size() &gt; 0) &#123; //遍历获取附近地点信息 for (Address address : addressList) &#123; //省 String adminArea = address.getAdminArea(); //市 String city = address.getLocality(); //地址 String feature = address.getFeatureName(); &#125; &#125; else &#123; //获取附近地点失败&#125; startActivity方式地点搜索 打开 Activity private static final int REQUEST_CODE_AUTOCOMPLETE = 2; 123456789101112131415161718/** * 打开搜索的 Activity */private void openAutocompleteActivity() &#123; try &#123; // MODE_FULLSCREEN 全屏方式启动一个 Activity // MODE_OVERLAY 启动浮在界面上的控件 Intent intent = new PlaceAutocomplete.IntentBuilder(PlaceAutocomplete.MODE_OVERLAY) .build(this); startActivityForResult(intent, REQUEST_CODE_AUTOCOMPLETE); &#125; catch (GooglePlayServicesRepairableException e) &#123; GoogleApiAvailability.getInstance().getErrorDialog(this, e.getConnectionStatusCode(), 0).show(); &#125; catch (GooglePlayServicesNotAvailableException e) &#123; String message = "Google Play Services is not available: " + GoogleApiAvailability.getInstance().getErrorString(e.errorCode); Toast.makeText(this, message, Toast.LENGTH_SHORT).show(); &#125;&#125; 在 onActivityResult 回调中获取搜索的地点信息 123456789101112131415161718192021222324252627@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_CODE_AUTOCOMPLETE) &#123; if (resultCode == RESULT_OK) &#123; Place place = PlaceAutocomplete.getPlace(this, data); String placeText = null; if (null != place) &#123; placeText = "place.getId() = " + place.getId() + "\nplace.getName() = " + place.getName() + "\nplace.getLatLng().latitude = " + place.getLatLng().latitude + "\nplace.getLatLng().longitude = " + place.getLatLng().longitude + "\nplace.getAddress() = " +place.getAddress() + "\nplace.getPhoneNumber() = " + place.getPhoneNumber() + "\nplace.getLocale() = " + place.getLocale() + "\n......."; &#125; Toast.makeText(this, getString(R.string.start_by_activity_btn_search_place_result, placeText), Toast.LENGTH_LONG).show(); &#125; else if (resultCode == PlaceAutocomplete.RESULT_ERROR) &#123; //错误码 Status status = PlaceAutocomplete.getStatus(this, data); &#125; else if (resultCode == RESULT_CANCELED) &#123; //取消 &#125; &#125; &#125; 导航123456789101112131415161718192021222324252627/** * 开启导航 * @param latitude * @param longitude */private void startNavigation(double latitude, double longitude) &#123; try &#123; Uri gmmIntentUri = Uri.parse("google.navigation:q="+latitude+","+longitude+"&amp;mode=d"); Intent mapIntent = new Intent(Intent.ACTION_VIEW, gmmIntentUri); mapIntent.setPackage("com.google.android.apps.maps"); startActivity(mapIntent); &#125; catch (Exception e) &#123; //提示未安装google map //开启google map下载界面 showGoogleMapDownloadView(); &#125;&#125;/** * 开启google map下载界面 */private void showGoogleMapDownloadView() &#123; Uri uri = Uri.parse("market://details?id=com.google.android.apps.maps"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); this.startActivity(intent);&#125; 附近地点 获取定位权限 获取方法和前面一样，使用 checkLocationPermission() 打开 Activity，开启附近地点选择 private static final int PLACE_PICKER_REQUEST = 3; 12345678PlacePicker.IntentBuilder builder = new PlacePicker.IntentBuilder();try &#123; startActivityForResult(builder.build(this), PLACE_PICKER_REQUEST);&#125; catch (GooglePlayServicesRepairableException e) &#123; e.printStackTrace();&#125; catch (GooglePlayServicesNotAvailableException e) &#123; e.printStackTrace();&#125; 在 onActivityResult 获取选择的地点信息 123456789@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == PLACE_PICKER_REQUEST) &#123; if (resultCode == RESULT_OK) &#123; Place place = PlacePicker.getPlace(this, data); //place.getName() .... &#125; &#125;&#125; Places当前位置及附近地点API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private final int mMaxEntries = 5;/** * 获取当前位置及附近地点 */private void getCurrentPlaces()&#123; if (!mConnected) &#123; return; &#125; if (!checkLocationPermission()) &#123; //未授权定位 return; &#125; PendingResult&lt;PlaceLikelihoodBuffer&gt; result = Places.PlaceDetectionApi .getCurrentPlace(mGoogleApiClient, null); result.setResultCallback(new ResultCallback&lt;PlaceLikelihoodBuffer&gt;() &#123; @Override public void onResult(@NonNull PlaceLikelihoodBuffer likelyPlaces) &#123; int i = 0; String[] likelyPlaceNames = new String[mMaxEntries]; String[] likelyPlaceAddresses = new String[mMaxEntries]; String[] likelyPlaceAttributions = new String[mMaxEntries]; LatLng[] likelyPlaceLatLngs = new LatLng[mMaxEntries]; for (PlaceLikelihood placeLikelihood : likelyPlaces) &#123; // Build a list of likely places to show the user. Max 5. likelyPlaceNames[i] = (String) placeLikelihood.getPlace().getName(); likelyPlaceAddresses[i] = (String) placeLikelihood.getPlace().getAddress(); likelyPlaceAttributions[i] = (String) placeLikelihood.getPlace() .getAttributions(); likelyPlaceLatLngs[i] = placeLikelihood.getPlace().getLatLng(); i++; //String placeId = (String) placeLikelihood.getPlace().getId(); if (i &gt; (mMaxEntries - 1)) &#123; break; &#125; &#125; likelyPlaces.release(); StringBuilder builder = new StringBuilder(); for (String placeName : likelyPlaceNames) &#123; builder.append(placeName + "\n"); &#125; //显示地点列表 //builder.toString() &#125; &#125;);&#125; 根据 PlaceID 获取对应地点在 onResult 返回的 places 一般只有一个，所以取第一个元素，就是 id 对应的地点信息。 1234567891011121314151617181920212223/** * 通过placeId获取对应的位置信息 * @param placeId */private void getPlaceById(String placeId)&#123; if (TextUtils.isEmpty(placeId)) &#123; return; &#125; Places.GeoDataApi.getPlaceById(mGoogleApiClient, placeId) .setResultCallback(new ResultCallback&lt;PlaceBuffer&gt;() &#123; @Override public void onResult(PlaceBuffer places) &#123; if (places.getStatus().isSuccess() &amp;&amp; places.getCount() &gt; 0) &#123; Place myPlace = places.get(0); //获取id对应的Place &#125; else &#123; //没有获取到数据 &#125; places.release(); &#125; &#125;);&#125; Web API这里说的 Web API 是指：通过拼接 url 的方式，向 Google 服务器请求数据，服务器会返回一段 JSON，我们本地再用 fastjson 解析，获取对应的数据。 根据坐标获取所在城市这里的 URL 可以这样拼接 1private static final String GOOGLE_MAP_URL = "https://maps.google.com/maps/api/geocode/json?language=%1$s&amp;sensor=true&amp;latlng=%2$s,%3$s"; 其中 %1$s 对应的是语言，比如我要返回的是中文，那么对于的就是 zh-CN*，%2$s %3$s* 对应的就是纬度和经度。 12345678910private static final String DEFAULT_LANGUAGE = "zh-CN";/** * 拼接url(默认设置语言为中文) * * @param latitude * @param longitude */public static String getGoogleMapUrl(double latitude, double longitude) &#123; return String.format(GOOGLE_MAP_URL, DEFAULT_LANGUAGE, Double.valueOf(latitude), Double.valueOf(longitude));&#125; 这样，外面只需要直接调这个方法，参数传入纬度、经度，就会返回拼接好的 URL。 获取了 URL，我们就可以异步访问网络，去获取数据了。这里主要讲下思路，详细代码，可以自己查看 Demo。 以Demo为例，拼接的URL为： 1https://maps.google.com/maps/api/geocode/json?language=zh-CN&amp;sensor=true&amp;latlng=22.536817569098282,113.97451490163802 获取的 JSON 如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; "results": [ &#123; "address_components": [ &#123; "long_name": "9028", "short_name": "9028", "types": [ "street_number" ] &#125;, &#123; "long_name": "深南大道", "short_name": "深南大道", "types": [ "route" ] &#125;, &#123; "long_name": "华侨城", "short_name": "华侨城", "types": [ "neighborhood", "political" ] &#125;, &#123; "long_name": "南山区", "short_name": "南山区", "types": [ "political", "sublocality", "sublocality_level_1" ] &#125;, &#123; "long_name": "深圳市", "short_name": "深圳市", "types": [ "locality", "political" ] &#125;, &#123; "long_name": "广东省", "short_name": "广东省", "types": [ "administrative_area_level_1", "political" ] &#125;, /** * 篇幅原因，省略其余数据 */ "status": "OK"&#125; 其中 type 对应的值是 locality 的就是城市名字，political 代表政治实体。 关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 根据经纬度获取对应的城市 * @param latitude * @param longitude */private void getCityByLatlngWeb(double latitude, double longitude) &#123; String urlString = GoogleMapUrlUtil.getGoogleMapUrl(latitude, longitude); if (URLUtil.isNetworkUrl(urlString)) &#123; new GeocodeTask().execute(urlString); &#125;&#125;class GeocodeTask extends AsyncTask&lt;String, Void, JSONObject&gt; &#123; @Override protected void onPreExecute() &#123; &#125; @Override protected com.alibaba.fastjson.JSONObject doInBackground(String... params) &#123; //请求网络，并且转化为 JSONObject 对象 return GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[0])); &#125; @Override protected void onPostExecute(com.alibaba.fastjson.JSONObject result) &#123; if (null != result) &#123; JSONArray jsonArray = result.getJSONArray("results"); if (null != jsonArray) &#123; Object firstObj = jsonArray.get(0); if (null != firstObj) &#123; GeocodeBean bean = JSON.parseObject(firstObj.toString(), GeocodeBean.class); //获取所在城市 String city = getLocality(bean); &#125; &#125; &#125; &#125;&#125;public class GeocodeBean &#123; private List&lt;AddressComponent&gt; address_components; private String formatted_address; //geometry private String place_id; private List&lt;String&gt; types; //set, get 方法自己补充哈&#125;/** * 从数据集里面获取所在城市 * @param bean * @return */private String getLocality(GeocodeBean bean) &#123; boolean isFound = false; if (null != bean) &#123; List&lt;AddressComponent&gt; list = bean.getAddress_components(); if (null != list) &#123; for (AddressComponent address : list) &#123; List&lt;String&gt; types = address.getTypes(); for (String type : types) &#123; if ("locality".equals(type)) &#123; isFound = true; break; &#125; &#125; if (isFound) &#123; return address.getShort_name(); &#125; &#125; &#125; &#125; return null;&#125; 根据经纬度获取附近地点前面获取对应城市中用的 URL 很方便，基本上没有限制。但是获取附近地点的就没这么好了，在拼接 URL 的时候，需要加上谷歌授权给你的 Web API key。这个是官方推荐的做法，详情可以查看官网的介绍 特别注意这里有一点要特别注意的，这里说的 Web API key 必须要重新申请的。之前我们使用 GoogleMap 的时候已经申请了 KEY，但是选项选择的是【Android apps】，只是作用于 Android Map 相关 API，这个时候访问 Web API 必须重新申请多一个 KEY。申请方法和前面一样，只是选项为【None】即可。 设置完之后如果一般间隔几分钟就可以调用，如果不行，就要手动开启服务。点击此处开启,选择对应的项目，【启用】 Google Places API Web Service 服务。 1private static final String GOOGLE_MAP_PLACES_URL = "https://maps.googleapis.com/maps/api/place/nearbysearch/json?language=%1$s&amp;location=%2$s,%3$s&amp;radius=%4$s&amp;type=%5$s&amp;key=%6$s"; 这下参数有点多了哈，前面3个和之前一样，分别对应语言、纬度、经度。第四个参数是查询地点的半径多大，第五个是类型，这里我使用的是 point_of_interest 意思是已经命名的景点，其他类型可以查看官网，最后一个参数是你的 APP 申请的 Key值。 关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 获取经纬度对应的附近地点 * @param latitude * @param longitude */private void getPlacesByLatLngWeb(double latitude, double longitude) &#123; String url = GoogleMapUrlUtil.getGoogleMapPlacesUrl(latitude, longitude); if (URLUtil.isNetworkUrl(url)) &#123; new NearbyPlacesTask().execute(url); &#125;&#125;class NearbyPlacesTask extends AsyncTask&lt;String, Void, JSONObject&gt; &#123; @Override protected JSONObject doInBackground(String... params) &#123; return GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[0])); &#125; @Override protected void onPostExecute(JSONObject result) &#123; if (null != result) &#123; JSONArray jsonArray = result.getJSONArray("results"); if (null != jsonArray) &#123; List&lt;NearbyPlaceBean&gt; list = JSON.parseArray(jsonArray.toString(), NearbyPlaceBean.class); //遍历 list 可以获取对应的附近地点信息 //list的size能比较大，可以根据项目需求，指截取前面10个。 &#125; &#125; &#125;&#125;public class NearbyPlaceBean &#123; //geometry //icon private String id; //1f7541b5f729cdc8bc8bb546f205848c50315af7 private String name; //澎柏白金假日公寓 //photos private String place_id; //ChIJX9_kRAXsAzQRKmc97njB67c //reference //scope //types private String vicinity; //深圳市宝安区 private GeometryBean geometry; //set，get 自己补充哈&#125; 实战：附近地点推荐可以像上面那样使用 Activity 的方式，弹出 Google 自带的地点推荐／选取界面，但是这样的UI定制性低，不能按照项目需求显示界面。所以根据上面学习到的东西，我重新写了个类似的界面，实现地点推荐、搜索、选择和截图功能的功能。考虑到频繁调接口会损耗请求次数，所以我设置了个半径，超过半径的才重新请求数据。 限制／收费前面我把类型分为 Map，Places主要原因就是，他们的收费标准是不同的。详情可见 Android 标准方案 高级 Google Maps Android API 不受限制地免费使用。1 定价基于所需数量。如需了解详细信息，请参阅Premium Plan使用率和限制。 Google Places API for Android 默认每天 1,000 次免费请求，信用卡验证后可增至每天 150,000 次免费请求。符合要求的应用可免费提升。详情 —- Web 服务 标准 高级 Google Places API Web Service 每天 150,000 次免费请求（信用卡验证后）。 定价基于所需数量。如需了解详细信息，请参阅Premium Plan使用率和限制。 学习资料官方 Demo官方 Demo 要跑起来，必须像前面的方式一样，去申请对应的 Key。 android-samples-apiDemos介绍 Map 相关 API。 android-play-places介绍 Places 相关 API 。包括地点搜索，附近地点选择，地点补全等。 android-maps-utils点聚合 Clustering 可以通过这个 demo 学习，GoogleMap的点聚合和百度是一样的用法，外层代码基本上是一样的。 工具类网页 API Console （Key 管理控制台） Google Map API 查询 坐标反查 (通过经纬度查对应地点)GoogleMap(谷歌地图直接把经纬度输入输入框即可查询，例如输入：22.536817569098282,113.97451490163802 )高德地图百度地图 相关参考[1]官方 Map 教程 https://developers.google.com/maps/documentation/android-api/[2]官方 Places 教程 https://developers.google.com/places/android-api/[3]启动 GoogleMap https://developers.google.com/maps/documentation/android-api/intents[4]Android使用intent调取导航或者地图 https://blog.csdn.net/qwer4755552/article/details/51659833[5]关于地图和偏移的那些事 https://blog.csdn.net/sanjay_f/article/details/48493699[6]地图坐标转换大全 http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=332419[7]Show Popup when Location access is disable by user (Andorid Google Maps) https://stackoverflow.com/questions/24160472/show-popup-when-location-access-is-disable-by-user-andorid-google-maps[8]How to show enable location dialog like Google maps? https://stackoverflow.com/questions/29801368/how-to-show-enable-location-dialog-like-google-maps]]></content>
      <categories>
        <category>Android</category>
        <category>Map</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最新Android框架排行榜，上百项资源汇总不容错过]]></title>
    <url>%2Fposts%2Fb0de6447.html</url>
    <content type="text"><![CDATA[Android框架排行榜1.Retrofit 一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言 上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。 官网地址：http://square.github.io/retrofit/ github：https://github.com/square/retrofit 作者：square团队 使用：1compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos; 2.okhttp 一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端 上榜理由，okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。 官网地址：http://square.github.io/okhttp/ github：https://github.com/square/okhttp 作者：square团队 使用：1compile &apos;com.squareup.okhttp3:okhttp:3.9.1&apos; 3.Butter Knife 一句话介绍：Butter Knife所提供了一种能力——使用注解生成模板代码，将view与方法和参数绑定。 上榜理由：github上16.5K个star，配合Androidstudio提供的Butter Knife插件，帮助开发者省却了频繁findviewbyid的烦恼，最新的Butter Knife还提供了onclick绑定以及字符串的初始化，初学者可以查阅Butter Knife以及Butter Knife插件进一步学习！ 官网地址：http://jakewharton.github.io/butterknife/ github：https://github.com/JakeWharton/butterknife 作者：JakeWharton ，也是square团队成员之一 使用：1234dependencies &#123; compile &apos;com.jakewharton:butterknife:8.8.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos;&#125; 4.MPAndroidChart 一句话介绍：MPAndroidChart是一款图表框架 上榜理由：github上16.1K个star，以快速、简洁。强大著称的图表框架 官网地址：https://github.com/PhilJay/MPAndroidChart github：https://github.com/PhilJay/MPAndroidChart 作者：PhilJay 使用：在AS中加入Gradle依赖 在根目录的 build.gradle上加入: 12345allprojects &#123; repositories &#123; maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 在app的build.gradle上加入： 123dependencies &#123; compile &apos;com.github.PhilJay:MPAndroidChart:v3.0.3&apos;&#125; 5.glide 一句话介绍：glide是一款专注于提供流畅划动能力的“图片加载和缓存框架” 上榜理由：15.9k个star，图片加载类框架排名第一的框架，google 在2014开发者大会上演示的camera app就是基于gilde框架开发的 github：https://github.com/bumptech/glide 作者：Bump Technologies团队 使用：12345678repositories &#123; mavenCentral()&#125;dependencies &#123; implementation &apos;com.github.bumptech.glide:glide:4.5.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.5.0&apos;&#125; 6.leakcanary 一句话介绍：一款内存检测框架，服务于java和android客户端 上榜理由：方便，简洁是leakcanary最大的特点，只需在应用的apllication中集成，就可以直接使用它；15.5k个star说明了它有多么受欢迎 github：https://github.com/square/leakcanary 作者：square团队 使用：12345dependencies &#123; debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos; releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos; testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos; &#125; 在 Application 中写入: 12345678910111213public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); // Normal app init code... &#125;&#125; 7.Android-Universal-Image-Loader 一句话介绍：曾经的图片加载框架王者，android开发老手都用过它 上榜理由:android端图片加载框架的老大哥了，15.3k个star足以证明它的热门，UIL与gilde最大区别是可定制，UIL提供了大量配置方式，图片加载状态的回调（成功，失败，进行中），加载动画等；以及提供了移动端图片加载框架的缓存思路：三级缓存策略 sd卡-内存-网络；值得注意的是，UIL以及两年未更新了，但笔者仍推荐各位使用！ github：https://github.com/nostra13/Android-Universal-Image-Loader 作者：nostra13 使用： 下载地址 universal-image-loader-1.9.5.jar 8.EventBus 一句话介绍：EventBus是一款本地组件间通信框架 上榜理由：组件间通信框架star量第一：14.8k，在大型项目的Activities，fragments，Threads，Services都可以看到它的使用场景，尽管EventBus在向未创建的组件传递事件时有些局限，仅适合在“活着的”组件间传递消息，但仍不妨碍它活跃在各个大型项目各个场景里。 官网地址：http://greenrobot.org/eventbus/documentation/how-to-get-started/ github：https://github.com/greenrobot/EventBus 作者：greenrobot 使用：1compile &apos;org.greenrobot:eventbus:3.1.1&apos; 9.zxing 一句话介绍：条码图像处理库 上榜理由：如果你用过二维码，你肯定已经间接使用过大名鼎鼎的zxing了。13.9K的star量，让它排在本榜单第九，实至名归，如果你有了解二维码的需求，不妨从了解、修改它源码入手。 github：https://github.com/zxing/zxing 作者：Sean Owen 10.picasso 一句话介绍：强力的图片下载、缓存框架 上榜理由：本榜单出现的第三款图片类框架，不同的是picasso更强调图片下载，你可以将picasso集成进你的项目中，你也可以结合gilde和UIL与picasso，三者一齐封装至你的项目中，按需所用。 官网地址：http://square.github.io/picasso/ github：https://github.com/square/picasso 作者：square团队 使用：1compile &apos;com.squareup.picasso:picasso:2.5.2&apos; 或者下载jar包 11.lottie-android 一句话介绍：一款可以在Android端快速展示Adobe Afeter Effect（AE）工具所作动画的框架 上榜理由：动画类框架第一名，github上13.3k个star证明了他的优越性，利用json文件快速实现动画效果是它最大的便利，而这个json文件也是由Adobe提供的After Effects（AE）工具制作的，在AE中装一个Bodymovin的插件，使用这个插件最终将动画效果生成json文件，这个json文件即可由LottieAnimationView解析并生成绚丽的动画效果。而且它还支持跨平台哟。 github：https://github.com/airbnb/lottie-android 作者：Airbnb 团队 12.fresco 一句话介绍：一款可以管理图片内存的框架 上榜理由:github上12.8k个star，图片类排行榜第四名，facebook的出身证明了它并非是重复造的轮子，在管理图片内存领域上有着它的一片天地，渐进式加载、加载gif都是它与前三位相比独有的特性 官网地址：https://www.fresco-cn.org/ github：https://github.com/facebook/fresco 作者：facebook 使用：1234dependencies &#123; // 其他依赖 compile &apos;com.facebook.fresco:fresco:0.12.0&apos;&#125; 下面的依赖需要根据需求添加： 1234567891011121314dependencies &#123; // 在 API &lt; 14 上的机器支持 WebP 时，需要添加 compile &apos;com.facebook.fresco:animated-base-support:0.12.0&apos; // 支持 GIF 动图，需要添加 compile &apos;com.facebook.fresco:animated-gif:0.12.0&apos; // 支持 WebP （静态图+动图），需要添加 compile &apos;com.facebook.fresco:animated-webp:0.12.0&apos; compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos; // 仅支持 WebP 静态图，需要添加 compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos;&#125; 13.RxAndroid 一句话介绍：一款Android客户端组件间异步通信的框架 上榜理由：github上12.7k个star，位居组件通信框架的第二名，仅在EventBus之后，如果要问两者的区别，Eventbus是用来取代组件间繁琐的interface，RxAndroid是用来取代AnsyTask的，并不冲突；当然RxAndroid的优点并不仅限于此，更多优雅的实现，可以去官网查阅！ github：https://github.com/ReactiveX/RxAndroid 作者：JakeWharton 使用：12compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxjava:2.1.0&apos; 14.SlidingMenu 一句话介绍：侧滑菜单栏框架 上榜理由：与Userval-Image-loader 齐名的上古神器框架——为你的app提供侧滑菜单栏的功能；github闪更有10.5k个star，证明了它的经久不衰，即使在Google推出了NavigationDrawer，仍然没有减少开发者对SildingMenu的拥簇，经典总是经得起考验的，这个上古神兽已经四年没有更新了；有太多太多的app使用过它，这些都可以在软件的开源许可上看到！ github：https://github.com/jfeinstein10/SlidingMenu 作者：Jeremy Feinstein 使用：在gihub上fork源码，集成进项目中 15.PhotoView 一句话介绍：一款ImageView展示框架，支持缩放，响应手势 上榜理由：10.3k的star数量，位于图片类框架排行榜第五位，PhotoView与前四位不同的是这次带来的是图片的展示能力，你一定好奇微信的头像点击放大是如何实现的，很多App的图片显示响应手势按压是如何实现的，了解PhotoView，你一定会开心的！（笔者也不会告诉你ImageView的点击放大效果在Android的sample也有） github：https://github.com/chrisbanes/PhotoView 作者：chrisbanes 使用：在app根目录的build.gradle中加入： 12345allprojects &#123; repositories &#123; maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 在app的module目录的build.gralde中加入： 123dependencies &#123; compile &apos;com.github.chrisbanes:PhotoView:latest.release.here&apos;&#125; 使用12345678&lt;com.github.chrisbanes.photoview.PhotoView android:id=&quot;@+id/photo_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;PhotoView photoView = (PhotoView) findViewById(R.id.photo_view);photoView.setImageResource(R.drawable.image); 16.material-dialogs 一句话介绍：一款自定义dialog框架 上榜理由：9.9k个star，也是继PhotoView，SlidingMenu之后第三款自定义View框架，也许你还是自定义View的新人，对Dialog使用的还有点生疏，你可以通过它提升你的Dilaog使用能力 github：https://github.com/afollestad/material-dialogs 作者：Aidan Follestad 使用：1234dependencies &#123; // ... other dependencies here compile &apos;com.afollestad.material-dialogs:core:0.9.4.5&apos;&#125; 17.droid-async-http 一句话介绍：一款基于Http协议的异步请求的网络框架， 上榜理由：虽然你有无数个使用retrofit+okhttp的理由，但9.8k个star，证明它仍然值得你深入学习。值得注意的是，它也已经有两年没更新了，你尽管拿去当你懒惰的理由！ github：https://github.com/loopj/android-async-http 作者：James Smith 使用：12345678repositories &#123; maven &#123; url &apos;https://oss.sonatype.org/content/repositories/snapshots/&apos; &#125;&#125;dependencies &#123; compile &apos;com.loopj.android:android-async-http:1.5.0-SNAPSHOT&apos;&#125; 18.androidannotations 一句话介绍：一款基于注解的快速开发框架 上榜理由：与Butterknife一样基于注解，利用注解快速完成view的初始化，不同的是androidannotations提供了更多的能力：简单的线程模型等；笔者只接触过Butterknife，无法更进一步叙述androidannotations的优势，如果你志在深入了解注解的妙用，可以尝试探索一下！ 官网地址：http://androidannotations.org/ github：https://github.com/androidannotations/androidannotations 作者：WonderCsabo 19.fastjson 一句话介绍:一款基于json解析、生成的框架 上榜理由：从它的名字不难看出，快速是它最大的特性，阿里巴巴的出身保证了代码的质量和优越，9.4k的star数量，也是榜单里第一个出现的中国开源框架，涉及网络的app都会用到json，fastjson值得作为你的首选！ github：https://github.com/alibaba/fastjson 作者：alibaba 使用：1compile &apos;com.alibaba:fastjson:1.1.58.android&apos; 20.Material-Animations 一句话介绍：一款提供场景转换过渡能力的动画框架 上榜理由：Android动画框架排行榜第二名，9.3k个star数量，与动画框架榜单第一名lottie-android不同的是，Material-Animations提供的是场景切换的动画效果。Android 官网sample中已经提供了部分Transition （转场动画）的展示，作为初学者很难快速拓展到自己项目中，Material-Animations的示例出现为开发者省去了此类麻烦，直接照搬应用到自己的App中吧。 github：https://github.com/lgvalle/Material-Animations 作者：Luis G. Valle 使用：down源码，修改学习 21.tinker 一句话介绍：它是微信官网的Android热补丁解决方案 上榜理由：9.1k个star，微信在用的热补丁方案，心动不如行动 官网地址：http://www.tinkerpatch.com/Docs/intro github：https://github.com/Tencent/tinker 作者：Tencent 22.ViewPagerIndicator 一句话介绍：一款基于ViewPager的页面指示器开源框架 上榜理由：上古神器，尽管已经五年未更新了，但你仍然可以在淘宝等app中看到它的使用场景，8.9K的star量让它不愠不火的在矗立在榜单里 官网地址：http://viewpagerindicator.com/ github：https://github.com/JakeWharton/ViewPagerIndicator 作者：JakeWharton 使用：下载地址：https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master 23.Android-CleanArchitecture 一句话介绍：一个讲解设计框架的demo 上榜理由：它不是框架，你可以把它当作一本书，它将教会你如何设计简洁的架构，工程里有一个sample app，配合图文讲解，你将对Android客户端的架构有更深一层的认识。8.8k的star数量，证明了它是一本“好书”哟。 github：https://github.com/android10/Android-CleanArchitecture 作者：Fernando Cejas 24.Android-PullToRefresh 一句话介绍：一款为普通视图提供刷新UI的视图框架 上榜理由：8.2K的star数量使它位居刷新类UI框架榜首，强大的兼容能力，该框架支持ListView，GrdiView，WebViewScrollView，ViewPager等众多View增加刷新的能力，如果你有增加上拉加载，下拉加载的需求，你应该考虑它了！ github：https://github.com/chrisbanes/Android-PullToRefresh 作者：Chris Banes 使用：github fork源码，集成到项目中 25.flexbox-layout 一句话介绍：一款弹性伸缩布局 上榜理由：8.1k个star，前端H5开发者转Android开发的福音，FlexboxLayout作为LinearLayout和RelativeLayout的替代者，值得各位一试，与其一同推出的还有ConstraintLayout。 github：https://github.com/google/flexbox-layout 作者：Google 使用：123dependencies &#123; compile &apos;com.google.android:flexbox:0.3.0-alpha3&apos;&#125; 26.AndroidSwipeLayout 一句话介绍：非常强大滑动式布局 上榜理由:滑动删除是国产app常见需求，商品详情的上下滑动需求作为开发者的我们也经常遇到，AndroidSwipeLayout在github上拥有8K个star，证明它经受住了检验，各位值得一试 github：https://github.com/daimajia/AndroidSwipeLayout 作者：daimajia 使用：12345dependencies &#123; compile &apos;com.android.support:recyclerview-v7:21.0.0&apos; compile &apos;com.android.support:support-v4:20.+&apos; compile &quot;com.daimajia.swipelayout:library:1.2.0@aar&quot;&#125; 或下载AndroidSwipeLayout-v1.1.8.jar 27.realm-java 一句话介绍：Realm是一款移动端数据库框架 上榜理由：核心数据引擎C++打造，比普通的Sqlite型数据库快的多。笔者猜测正是如此，realm以7892个star数让它位于大名鼎鼎的数据库框架GreenDao（7877）之前 官网地址：https://realm.io/cn/ github：https://github.com/realm/realm-java 作者：Realm团队 使用：https://realm.io/docs/java/latest/ 28.greenDAO 一句话介绍：greenDAO是一款高效、快速的SQLite型数据库 上榜理由：greenDAO的star数量与Realm不相上下，且与EventBus师出同门，也是由greenrobot团队开发维护的，质量有所保证，但若拷问笔者Realm与greenDao两者的优劣性，只能具体到实际使用当中，模拟线上的使用情形，进行高强度测试后才能下判断，故在此不能一言两语说完，深表遗憾 官网地址：http://greenrobot.org/greendao/ github：https://github.com/greenrobot/greenDAO 使用：12345678910111213141516171819buildscript &#123; repositories &#123; jcenter() mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.1&apos; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; -----apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; 29.stetho 一句话介绍：一款提供在Chrome开发者工具上调试Android app能力的开源框架 上榜理由：上古时期Android程序员要调试本地数据库，需要进入Android Device Monitor找到/data/data/com.xxx.xxx/databases里面的db文件，导出到PC端，用PC的数据工具查看，现在使用stetho省却了如此的麻烦；如今的Android程序员如果想调试网络请求响应过程中的报文段，需要在请求中加入Log语句，一个信息一个信息打印出来，相当繁琐，现在请使用stetho，省却诸如此类的麻烦把！7.8K个star数，广大Android开发者调试的福音，你值得拥有！ 官网地址：http://facebook.github.io/stetho/ github：https://github.com/facebook/stetho 作者：FaceBook 使用：1compile ‘com.facebook.stetho:stetho:1.5.0’ 30.BaseRecyclerViewAdapterHelper 一句话介绍：强大、流畅的Recyvlerview通用适配器 上榜理由：如果你是RecyclerView的拥簇者，你一定要体验这款专门服务该view的适配器，7.7K个star，让这个家伙位于github上Android 适配器排行榜第一，还有很多惊喜等你去探寻！ 官网地址：http://www.recyclerview.org/ 使用： 1234567891011allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot;&#125; &#125;&#125;dependencies &#123; compile &apos;com.github.CymChad:BaseRecyclerViewAdapterHelper:VERSION_CODE&apos;&#125; 31.AndroidViewAnimations 一句话介绍：一款提供可爱动画集合的框架 上榜理由：正如作者所说，它囊括了开发需求过程中所有的动画效果，集成进了这个简洁可爱的动画框架。7.6K的star数，证明了它在动画框架领域的战斗力，让它仅仅位列lottie-android和Material-Animations两个动画框架霸主之后，屈居第三名 github：https://github.com/daimajia/AndroidViewAnimations 作者：daimajia 使用：1234567891011dependencies &#123; compile &apos;com.android.support:support-compat:25.1.1&apos; compile &apos;com.daimajia.easing:library:2.0@aar&apos; compile &apos;com.daimajia.androidanimations:library:2.2@aar&apos;&#125;sample：YoYo.with(Techniques.Tada) .duration(700) .repeat(5) .playOn(findViewById(R.id.edit_area)); 32.MaterialDrawer 一句话介绍：强大的塑料风格的抽屉框架 上榜理由：7.6K的star数量，作者的持续更新状态，如果你还在犹豫上手SlidingMenu遇到bug没人管的困境，那么你可以入手它作为你的抽屉布局 github：https://github.com/mikepenz/MaterialDrawer 作者：Mike Penz 使用:12345compile(&apos;com.mikepenz:materialdrawer:5.9.2@aar&apos;) &#123; transitive = true&#125;new DrawerBuilder().withActivity(this).build(); 33.Android-ObservableScrollView 一句话介绍：一款让视图滑动更具有视觉效果的滑动式框架 上榜理由：7.5K的star数量，证明了它曾经的价值，github上提供了12种滑动效果，你可以用它弥补其他框架的不足，提升你的App体验！ github：https://github.com/ksoichiro/Android-ObservableScrollView 作者：Soichiro Kashima 使用：1compile com.github.ksoichiro:android-observablescrollview 34.CircleImageView 一句话介绍：圆角ImageView 上榜理由：也许你已经听说过无数种展示圆角图片的方法，但如果你不尝试尝试CircleImageView，那么你的知识库会因为少了它黯然失色，有的时候完成需求是开发者优先考虑的，不同实现方法牵扯到的性能差异更值得让人深思，如果你有心在图片性能上有所涉猎，那么CircleImageView绝对不会让你败兴而归。最后别忘了记得去看Romain Guy的建议哟。 github：https://github.com/hdodenhof/CircleImageView 作者：Henning Dodenhof 使用：12345678910111213dependencies &#123; ... compile &apos;de.hdodenhof:circleimageview:2.1.0&apos;&#125;&lt;de.hdodenhof.circleimageview.CircleImageView xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/profile_image&quot; android:layout_width=&quot;96dp&quot; android:layout_height=&quot;96dp&quot; android:src=&quot;@drawable/profile&quot; app:civ_border_width=&quot;2dp&quot; app:civ_border_color=&quot;#FF000000&quot;/&gt; 35.logger 一句话介绍：一款让log日志优雅显示的框架 上榜理由：logger作为调试框架，并未给出很强大的能力，它最大的亮点是优雅的输出log信息，并且支持多种格式：线程、Json、Xml、List、Map等，如果你整日沉迷于汪洋大海般的log信息不能自拔，logger就是你的指路明灯！6.6k个star让他位列调试框架第二名，屈居facebook的stetho之后 github：https://github.com/orhanobut/logger 作者：Orhan Obut 使用： 12345678compile &apos;com.orhanobut:logger:2.1.1&apos;Logger.d(MAP);Logger.d(SET);Logger.d(LIST);Logger.d(ARRAY);Logger.json(JSON_CONTENT);Logger.xml(XML_CONTENT); 36.agera 一句话介绍:一款服务于Android平台的响应式编程框架 上榜理由：google专门推出一套响应式编程框架服务于Android开发者，相比于之响应式编程框架榜首的 RxJava RxAndroid，它更轻量，两者最大的不同点在于agera基于push event、pull data （VS Rx系列 push data）。 github：https://github.com/google/agera 作者：Google 使用：1compile &apos;com.google.android.agera:agera:1.3.0&apos; 扩展能力12345compile &apos;com.google.android.agera:content:1.3.0&apos; compile &apos;com.google.android.agera:database:1.3.0&apos; compile &apos;com.google.android.agera:net:1.3.0&apos; compile &apos;com.google.android.agera:rvadapter:1.3.0&apos; compile &apos;com.google.android.agera:rvdatabinding:1.3.0&apos; 37.BottmBar 一句话介绍：一款底部导航栏视图框架 上榜理由：底部栏里的王者框架，6.3K的star数量，证明了它的优秀，完全遵循材料设计规范，上手非常方便。如果说缺点，无法设置icon与titile的间距，无法自定义视图的大小等，但这些都可以通过修改源代码解决，笔者献丑也修改了一套符合国内开发者的底部导航框架，即将开源。 github：https://github.com/roughike/BottomBar 作者：Iiro Krankka 使用：1compile &apos;com.roughike:bottom-bar:2.3.1&apos; 38.Calligraphy 一句话介绍：一款自定义字体框架 上榜理由：如果你还在为一键修改App内所有字体样式而烦恼，6.3K个star的Calligraphy就值得你拥有，它可以同时修改整个整个项目的Textview字体，也可以单独 设置某个Textview的字体，还在等什么，快来试试吧！ github：https://github.com/chrisjenx/Calligraphy 作者：Christopher Jenkins 使用：123dependencies &#123; compile &apos;uk.co.chrisjenx:calligraphy:2.3.0&apos;&#125; 39.AndroidSlidingUpPanel 一句话介绍：可拖动的滑动面板视图框架 上榜理由：如果你的项目需要一个可拖拽的滑动式面板（展示某些详情信息，播放音乐，地图信息等），那么推荐你使用它，6.3k个star，来自创业公司umano的作品，证明它是用心推出的杰作 github：https://github.com/umano/AndroidSlidingUpPanel 作者：umano 使用：12345678dependencies &#123; repositories &#123; mavenCentral() &#125; compile &apos;com.sothree.slidinguppanel:library:3.3.1&apos;&#125; 40.AppIntro 一句话介绍：一款提供快速制作欢迎页的框架 上榜理由：笔者从未把打算把欢迎页框架纳入排行榜当中，作为国内开发者，ViewPager开发App的欢迎页已经是手到擒来的需求，为何一个开源的欢迎页框架会在github上拥有6.3k个star？也许你会不屑一顾，是的，往往就在不屑一顾的瞬间，机遇就悄悄溜走了。 github：https://github.com/apl-devs/AppIntro 作者：Paolo Rotolo 12345678910allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos;&#125; &#125; &#125; dependencies &#123; compile &apos;com.github.apl-devs:appintro:v4.2.0&apos; &#125; 41.recyclerview-animators 一句话介绍：一款为Recyclerview提供扩展动画能力的框架 上榜理由：有一句老话：如果有天你失去对新事物的兴趣，那就说明你老了。recyclerview已经推出快三年了，还在用listview的人们，是否已经发掘自己渐渐变老；不要灰心，快为你的项目加入recyclerview-animators框架吧，为“自己”加入新鲜的血液和能量！（笔者备注：6.2K个star） github：https://github.com/wasabeef/recyclerview-animators 作者：https://github.com/wasabeef 使用：1234dependencies &#123; // jCenter compile &apos;jp.wasabeef:recyclerview-animators:2.2.6&apos;&#125; 42.dagger 一句话介绍：一款通过依赖注入降低程序间耦合的开发框架 上榜理由：github 上dagger1版本 有6.2k个star ， dagger2版本有7.3k个；由square完成的dagger1版本，到如今google团队接手的dagger2版本，强力开发团队保证了代码在设计上的优越性；如果你想探究Android 领域的设计模式，这也是不错的选择。 官网地址：https://google.github.io/dagger/ github：https://github.com/google/dagger 作者：google 使用：123456789dependencies &#123; compile &apos;com.google.dagger:dagger:2.x&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.x&apos;&#125;If you&apos;re using classes in dagger.android you&apos;ll also want to include:compile &apos;com.google.dagger:dagger-android:2.x&apos;compile &apos;com.google.dagger:dagger-android-support:2.x&apos; annotationProcessor &apos;com.google.dagger:dagger-android-processor:2.x&apos; 43.Android-Bootstarp 一句话介绍：一款提供在Android应用上实现Bootstrap（web框架）所作出效果的框架 上榜理由：榜单上第二款响应web技术的Android 端框架，还记得第一名是谁吗——flexbox-layout，作为Android开发者，你有必要去了解Web技术了。5.9k个star，证明它不容小觑 github：https://github.com/Bearded-Hen/Android-Bootstrap 作者：Bearded-Hen团队 使用：123dependencies &#123; compile &apos;com.beardedhen:androidbootstrap:&#123;X.X.X&#125;&apos;&#125; 44.RxBinding一句话介绍：一款提供UI组件事件响应能力的框架 上榜理由：如果你还未开始RxAndroid 之旅，RxBinding可以作为你的第一站，通过RXBinding，你将理解响应式编程的快乐，让项目里的事件流程更清晰。5.6K个star，RxAndroid作者亲自操刀，快来试用吧！ github：https://github.com/JakeWharton/RxBinding 作者：JakeWharton Platform bindings:12345678910111213141516compile &apos;com.jakewharton.rxbinding2:rxbinding:2.0.0&apos;&apos;support-v4&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-support-v4:2.0.0&apos;&apos;appcompat-v7&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-appcompat-v7:2.0.0&apos;&apos;design&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-design:2.0.0&apos;&apos;recyclerview-v7&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:2.0.0&apos;&apos;leanback-v17&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-leanback-v17:2.0.0&apos; 45.ListViewAnimations 一句话介绍：一款为ListView提供动展示画效果能力的框架 上榜理由：如果有一天我承认自己老了，我还会排排我的兄弟——ListView，证明我和它一起战斗过。ListViewAnimations的存在就是证明我们这些“老年人”仍有用武之地，也许你有说不出口的难处，无法体会到RecyclerView里动画的快乐，拥有ListViewAnimations，你一样可以骄傲的说，我的孩子（每个item）也有自己的动效啦。（笔者备注 5.6K个star） github：https://github.com/nhaarman/ListViewAnimations 作者：nhaarman 使用：123456789repositories &#123; mavenCentral()&#125;dependencies &#123; compile &apos;com.nhaarman.listviewanimations:lib-core:3.1.0@aar&apos; compile &apos;com.nhaarman.listviewanimations:lib-manipulation:3.1.0@aar&apos; compile &apos;com.nhaarman.listviewanimations:lib-core-slh:3.1.0@aar&apos;&#125; 46.UItimateRecyclerView 一句话介绍：一款提供刷新、加载更多、动画特效等额外能力的RecyclerView框架 上榜理由：榜单上第三次出现RecyclerView的身影，足以证明RecyclerView的优异性，5.5K个star，框架里所提供众多的能力，如果你是个功利开发者，那么此框架会为你节省很多学习时间，它可以完成多item式布局的大多数需求，值得注意的是，这个项目也是在其他项目的思路上二次开发的。 github：https://github.com/cymcsg/UltimateRecyclerView 作者：MarshalChen 使用：1234567repositories &#123; jcenter() &#125;dependencies &#123; ... compile &apos;com.marshalchen.ultimaterecyclerview:library:0.7.2&apos;&#125; 47.uCrop 一句话介绍：一款优雅的图片裁剪框架 上榜理由：5.3K个star，图片编辑模块单独拎出来也是一款优雅的App。 github：https://github.com/Yalantis/uCrop 作者：Yalantis 使用：12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125;compile &apos;com.github.yalantis:ucrop:2.2.1&apos; 48.RxJava-Android-Samples 一句话介绍：一款介绍RxJava使用场景的app 上榜理由：榜单出现的第一个“仅仅为告诉你如何使用另一个项目”的开源项目，它可以说是RxJava的用例，你想得到的想不到的RxJava用法这里都有，这就是为什么它以5.2k个star矗立在这份榜单里的原因。遗憾自己没有创作这么一个受人追捧的demo？赶快动手写个其他的“XX项目用例吧” github：https://github.com/kaushikgopal/RxJava-Android-Samples 作者：kaushikgopal 使用：clone到本地慢慢探索吧 49.AndroidAutoLayout 一句话介绍：一个提供适配能力的框架 上榜理由：5.2K个star，鸿洋老弟的作品，适合小项目的开发团队，拿到设计MM的px像素设计稿是不是很头疼捏？这个框架一键式搞定你的问题，它有很多的不足，但在追求完美适配的路上，你值得探索和了解它！笔者并不推荐把它应用到已经成熟运行的项目中，毕竟市面上已经有太多的适配解决方案了，适配问题就像是个大杂烩，想炒一盘好菜，就得备好各种佐料（适配小方案），当你把各种小佐料用的炉火纯青的时候，你离美食大厨就不远了。 github：https://github.com/hongyangAndroid/AndroidAutoLayout 作者：张鸿洋 使用：123dependencies &#123; compile &apos;com.zhy:autolayout:1.4.5&apos;&#125; 50.EffectiveAndroidUI 一句话介绍：一款讲解高效展示UI的教学型App 上榜理由：编程新手很难对MVC MVP,MVVM等模式有深刻的理解，如果有一个示例型app，那对初学者会有很大裨益，笔者在遇到它时也是相见恨晚。4.8K个star，证明了它经受了广大开发者的考验与审视，其中Effective UI的编程思想更是与Android官方课程里的Effective UI课程不谋而合，并且，此项目还包含了fragment、dagger、主题样式、Butterknife等众多小知识点，作为编程初学者的学习用例再适合不过了 github：https://github.com/pedrovgs/EffectiveAndroidUI 作者：Pedro Vicente 使用：clone项目到本地 51.Luban 一句话介绍：最接近微信的图片压缩框架 上榜理由：好的思路总是可以让你大放异彩，Luban仅以图片压缩单一功能，俘获了4.8K个star，证明了它在图片压缩上的造诣，它可能不是最优秀的，但它是让你我最接近伟大的项目 github：https://github.com/Curzibn/Luban 作者：Curzibn 使用：1compile &apos;top.zibin:Luban:1.1.1&apos; 52.DroidPlugin 一句话介绍：一款热门的插件化开发框架 上榜理由：4.8K个star，插件化框架榜单第一名，，360团队出品，框架质量有保证，有成功案例——360手机助手，并且持续维护着 github：https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md 作者：Andy Zhang 使用:clone项目到本地 53.otto 一句话介绍:一款老旧且强大的事件总线框架 上榜理由：4.8K个star，是square团队早先推出的事件响应型框架，淘宝app的事件驱动也是基于此框架封装的，如今square已经建议开发者采用RxJava RxAndroid来代替otto了。但otto仍有与EventBus横向对比的价值，纵向来说，otto与square自家开发的Rx系列框架的差异同样值得开发者们去探究。 github https://github.com/square/otto 作者：square 使用：123456repositories &#123; mavenCentral() maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;&#125;compile &apos;com.michaelpardo:activeandroid:3.1.0-SNAPSHOT&apos; 54.u2020 一句话介绍：一款提供Dagger的高级教学示例的app（额，名字是有点绕） 上榜理由：4.7K个star，JakeWharton牵头开发的教学类app，教你使用Dagger在其他高级框架的用法，它展示了Dagger与ButterKnife、Retrofit、Moshi、Picasso、Okhttp、RxJava、Timber、Madge、LeakCanar等众多优秀框架结合起来的高级用法，你也可以借鉴到自己的项目当中 github：https://github.com/JakeWharton/u2020 作者：JakeWharton 55.buck 一句话介绍：buck是一个快速构建系统 上榜理由：facebook+google出身的作者，对构建代码的出色理解，加上大型团队的维护，以及增量更新时的快速高效，让buck成为了微信Android团队构建项目的首选，构建大型项目时，它比gradle更快，然而中小公司并不适合此框架，但作为立志在框架设计领域有一番作为的人们，欢迎来一探究竟 官网地址：https://buckbuild.com/ github：https://github.com/facebook/buck 作者：facebook 使用：linux or mac system +docs 56.PermissionsDispatcher 一句话介绍：一款基于注解的提供解决运行时危险权限方案的框架 上榜理由：自Android6.0 Google提出危险权限一词起，用户安全性被提到一定的高度，一些运行时对用户较为危险的权限将不再自动被开发者获取，需要经过用户批准，开发者才可以继续使用该权限，如果你曾经被权限问题搞的抓耳挠腮，建议你试试这个框架，它足够解决你的问题 官网地址：https://hotchemi.github.io/PermissionsDispatcher/ github：https://github.com/hotchemi/PermissionsDispatcher 作者：Shintaro Katafuchi 使用：123456789101112dependencies &#123; compile(&apos;com.github.hotchemi:permissionsdispatcher:$&#123;latest.version&#125;&apos;) &#123; exclude module: &quot;support-v13&quot; &#125; annotationProcessor &apos;com.github.hotchemi:permissionsdispatcher-processor:$&#123;latest.version&#125;&apos;&#125;repositories &#123; jcenter() maven &#123; url &apos;http://oss.jfrog.org/artifactory/oss-snapshot-local/&apos; &#125;&#125; 57.android-gif-drawable 一句话介绍:一款提供展示GIF动画能力的视图框架 上榜理由：据我所查国内著名App——知乎使用了android-gif-drawable，因此证明了它的存在价值，尽管在榜单第十一位介绍了lottie-android直接应用AE动画的示例，但AE设计师不是每个公司都配备的，GIF的存在，就必然存在了展示GIF的需要，它值得你拥有！ github：https://github.com/koral--/android-gif-drawable 作者：Karol Wrótniak 使用：1234567repositories &#123; mavenCentral() maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;&#125;dependencies &#123; compile &apos;pl.droidsonroids.gif:android-gif-drawable:1.2.+&apos;&#125; 58.Apktool 一句话介绍：一款反编译apk的工具 上榜理由：开源的反编译工具，对于志在了解apk逆向破解的诸位，值得拥有，4.5k个star，逆向破解apk神器！ github：https://github.com/iBotPeaches/Apktool 官网地址：https://ibotpeaches.github.io/Apktool/ 作者：Connor Tumbleson 59.dynamic-load-apk 一句话介绍：插件化开发框架 上榜理由：4.5k个star，位于插件化开发框架第二名（第一名来自360团队），全面的文档介绍让你很快就能上手插件化开发，如果你喜欢大段文字讲解，那么这个项目一定适合你 github：https://github.com/singwhatiwanna/dynamic-load-apk 作者：singwhatiwanna 使用：github上的文档配合作者博客更配哟 60.atlas 一句话介绍：淘宝推出的组件化开发框架 上榜理由：淘宝团队所出的精品，atlas框架提供了解耦、组件、动态的开发能力，4.5k个star让他位列组件化开发框架第一名 github：https://github.com/alibaba/atlas 作者：alibaba 61.volley 一句话介绍：google推荐使用的Android端网络请求框架 上榜理由：4.4k个star，并不是他不够优秀，而是使用volley已经渐渐成为广大开发者的习惯 github：https://github.com/google/volley（新版volley地址） 作者：google 使用：clone源码到本地 62.androidmvp 一句话介绍：一款展示Android端Mvp设计的demo 上榜理由：榜单里为数不多、仅凭展示某种设计模式就获得4.2K个star的项目，如果你有尝试mvp的打算，androidmvp可以作为你的前哨站 github：https://github.com/antoniolg/androidmvp 作者：Antonio Leiva 使用：clone到本地 63.SwipeBackLayout 一句话介绍:一款可以让你通过滑动手势关闭页面的的框架 上榜理由：仿微信滑动退出当前聊天界面的效果，提供了activity的滑动关闭能力，通过这种思路，实现fragment的滑动关闭轻而易举;笔者坚持建议诸位clone源码到本地探索一番；4.2k个star证明很多人都喜爱它 github：https://github.com/ikew0ng/SwipeBackLayout 作者：ike_w0ng 使用:1compile &apos;me.imid.swipebacklayout.lib:library:1.0.0&apos; 64.FlycoTabLayout 一句话介绍：一款可以让作出多种多样指示器效果的框架 上榜理由：尽管我们没有理由为了给app加入页面指示器功能就集成2.5M的依赖库，但是作为了解viewpager或swip views的指示器设计原理的优秀框架，你值得打开它试试，笔者建议单独拆分所需源码，加入到自己的项目中去。4.1K个star，二次开发的作品，仍然推荐！ github：https://github.com/H07000223/FlycoTabLayout 作者：Flyco 65.android-testing 一句话介绍：一款展示四大自动化测试框架用例的demo（Espresso，UiAutomator，AndroidJunitRunner，JUnit4） 上榜理由：学习者经常会陷入似懂非懂的境地，如果你有幸学习过Android Testing Support Library site的课程，那么你一定对android的四大测试框架迫不及待，这款demo非常适合你，快来学习这个4.1k个star的明星项目吧 github：https://github.com/googlesamples/android-testing 作者：googlesampes团队 66.FileDownloader 一句话介绍：一款高效、稳定、灵活、易用的文件下载引擎 上榜理由：4.1k证明了它有多受人喜爱，文件下载看似简单的背后暗藏了多少的坑坑点点，我知道你有能力自己实现文件下载功能，但优秀的框架可以提升你的设计编码能力，这款框架可以提升你的实力！ github：https://github.com/lingochamp/FileDownloader 作者：LingoChamp团队 使用：123dependencies &#123; compile &apos;com.liulishuo.filedownloader:library:1.5.5&apos;&#125; 67.JieCaoVideoPlayer 一句话介绍：基于MediaPlayer api——VideoView 的多媒体播放框架 上榜理由：榜单里第三款多媒体播放框架，它以灵巧的身姿挤入本榜单，精巧是它最大的优点，不到100k，拥有它，你就可以快速开发类似今日头条那样的视频播放效果，4k个star，证明它值得一试 github：https://github.com/lipangit/JieCaoVideoPlayer 作者：Nathen 使用：1compile &apos;fm.jiecao:jiecaovideoplayer:5.5.4&apos; 68.glide-transformations 一句话介绍：为众多著名图片加载框架提供图片形状变幻能力的框架 上榜理由：在榜单靠前的部分已经介绍过glide，Picasso，Fresco等图片加载框架，glide-transformations就是一款为他们提供图片变形能力的框架，使用起来非常简单，因此受到了大家的喜爱，github上有3.8K个star github：https://github.com/wasabeef/glide-transformations 作者：Daichi Furiya 使用：123456789repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;jp.wasabeef:glide-transformations:2.0.2&apos; // If you want to use the GPU Filters compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;&#125; 在Glide里设置变幻效果 12345Set Glide Transform.Glide.with(this).load(R.drawable.demo) .bitmapTransform(new BlurTransformation(context)) .into((ImageView) findViewById(R.id.image)); 69.android-gpuimage 一句话介绍：一款基于OpenGL的图片渲染引擎 上榜理由：放下GpuImage在IOS平台的荣誉不谈，Android版的android-gpuimage就提供多达70多种图片渲染效果，你还在好奇美图秀秀是如何实现图片变幻的？有了它，一切都不是问题。如果你是美图工具类的工程师，此框架的建设思路也会对你大有裨益。笔者也是通过android-gpuimage仿造了美图App并俘获女友芳心的，再次为它的实力点赞。ios版+android版一共19k个star，已经证明了它的实力，还在等什么呢？ github：https://github.com/CyberAgent/android-gpuimage 作者：CyberAgent 团队 使用：1234567repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;&#125; 更多的改造方法，还需要阅读Ios的编程文档，对于有毅力的小伙伴强力推荐！ 70.RxPermissions 一句话介绍：一款基于RxJava完成权限申请的框架 上榜理由：榜单里第二款提供权服务的框架，基于RxJava的设计，让你可以专心写业务，3.7K个star已经证明了它的实用价值 github：https://github.com/tbruyelle/RxPermissions 作者：Thomas Bruyelle 使用：1234567repositories &#123; jcenter() // If not already there&#125;dependencies &#123; compile &apos;com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar&apos;&#125; 优雅的使用： 12345678910RxPermissions rxPermissions = new RxPermissions(this); rxPermissions .request(Manifest.permission.CAMERA) .subscribe(granted -&gt; &#123; if (granted) &#123; // I can control the camera now &#125; else &#123; // Oups permission denied &#125; &#125;); 71.freeline 一句话介绍：一款动态替换的编译构建框架 上榜理由：继Facebook的Buck，Androdi官方的InstRun之后，蚂蚁金服推出了Freeline编译框架，官网宣称Freeline与业内主流构建方式相比仍然有数倍的速度领先;排行有先后，编译速度并不在本榜单排序的考据因素中，因此freeline以3.7个star，暂列编译框架第二名 官网地址：https://www.freelinebuild.com/ github：https://github.com/alibaba/freeline 作者：alibaba 使用：1234567891011121314buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.antfortune.freeline:gradle:0.8.7&apos; &#125;&#125;apply plugin: &apos;com.antfortune.freeline&apos;android &#123; ...&#125; File → Settings… → Plugins → Browse repositories →freeline. 72.RxLifecycle 一句话介绍：一款提供在使用RxJava过程中管理Activity和Fragment生命周期能力的框架 上榜理由：在榜单靠前的部分，你已经了解RxJava和RxAndroid的强大之处，但部分粗心的开发者因为没有及时取消订阅而产生严重的内存泄漏，不要担心，RxLifecycle可以为你解决难题，在gtihub上拥有3.7K个star，国内知名软件——知乎和淘宝也都在使用它 github：https://github.com/trello/RxLifecycle 作者：trello团队 使用：clone源码到本地 73.classyshark 一句话介绍：一款可执行文件浏览器 上榜理由：榜单里继Apktool之后第二款apk逆向工具，如果你喜欢优雅的图形数据展示，那么你一定不能错过他，classyshark可以将破解的结果以图形化展示用户，方便分析，3.7K个star，让它暂列apk逆向工具第二位！ github：https://github.com/google/android-classyshark 作者：google 使用：下载 JAR 74.acra 一句话介绍：一款提供记录APP崩溃日志能力的框架 上榜理由：如果你面临着收集APP崩溃日志的需求，那么acra是个不错的选择。3.7K个star，让acra位列崩溃日志框架排行榜第一名，acra有足够的能力记录线上APP，并且发回服务端，acra也提供了相当棒的崩溃日志统计服务端框架Acralyzer，cralyzer工作在Apache CouchDB之上，所以除了CouchDB之外，没有必要安装任何额外的软件，移动端开发者也可以借此学习服务端的建设，一举两得！ github：https://github.com/ACRA/acra 服务端github：https://github.com/ACRA/acralyzer 作者：acra团队 使用：没有什么方法比clone源码到本地更方便了 75.DiskLruCache 一句话介绍：一款提供磁盘文件缓存管理能力的框架 上榜理由：3.7k个star并不足以说明DiskLruCache的优秀，仅仅以管理磁盘文件能力单独拎出来成为一个框架，作者需要很大的勇气，很幸运，作者做到了，并且也成为Google官网提倡的缓存 ；如还记得上次做“一键清除缓存”、“查看缓存文件大小”功能是什么时候吗？DiskLruCache一句话就可以搞定！ github：https://github.com/JakeWharton/DiskLruCache 作者：JakeWharton 使用：1compile &apos;com.jakewharton:disklrucache:2.0.2&apos; 或者下载 latest .jar 76.dexposed 一句话介绍：一款支撑阿里大部分App客户端热修复、线上调试能力的框架 上榜理由：榜单上再次出现热修复框架的身影，证明App热修复技术的火热，dexposed提供图形化的性能监控、在线热修复bug漏洞、支持AOP编程思想等，不论你是企业热修复技术的设计者还是打算在热修复领域一探究竟的新人，这款框架很适合你。3.5k个star，证明它作为一门技术框架的存在，是多么令人喜爱！ github：https://github.com/alibaba/dexposed 作者：alibaba 使用：123dependencies &#123; compile &apos;com.taobao.android:dexposed:0.1.1@aar&apos; &#125; 77.Litho 一句话介绍：一款提供高效构建UI能力的框架 上榜理由：作为一款专门构建UI的框架，Litho高效的地方在于：单独开辟了用于渲染和布局的线程，然后将创建好的组件传递给UI线程去完成最终的渲染，使用更少的视图层级，来提升界面的滚动速度，值得注意的是，它仅支持开发者作出不可改变的UI组件 ,3.5K个star，证明了它在构建UI领域的价值，更多的妙处，期待你亲自去发掘！ github：https://github.com/facebook/litho 作者：facebook 使用：123456789101112131415161718192021dependencies &#123; // ... // Litho compile &apos;com.facebook.litho:litho-core:0.3.1&apos; compile &apos;com.facebook.litho:litho-widget:0.3.1&apos; provided &apos;com.facebook.litho:litho-annotations:0.3.1&apos; annotationProcessor &apos;com.facebook.litho:litho-processor:0.3.1&apos; // SoLoader compile &apos;com.facebook.soloader:soloader:0.2.0&apos; // Optional // For debugging debugCompile &apos;com.facebook.litho:litho-stetho:0.3.1&apos; // For integration with Fresco compile &apos;com.facebook.litho:litho-fresco:0.3.1&apos; // For testing testCompile &apos;com.facebook.litho:litho-testing:0.3.1&apos;&#125; 78.mosby 一句话介绍：一款提供构建MVP项目能力的框架 上榜理由：榜单靠前的部分已经介绍了MVC,MVVM,MVP的框架项目，想必此时你在构建企业项目架构上，选择或者开发一款合适的MVP框架迫在眉睫，mosby可以作为你的第一步参考，你可以封装它，也可以照抄它，无论如何，3.4K个star，证明了它在框架设计上有多受开发者的喜爱 github：https://github.com/sockeqwe/mosby 作者：Hannes Dorfmann 使用：1234567891011121314dependencies &#123; compile &apos;com.hannesdorfmann.mosby3:mvi:3.0.4&apos; // Model-View-Intent // or compile &apos;com.hannesdorfmann.mosby3:mvp:3.0.4&apos; // Plain MVP // or compile &apos;com.hannesdorfmann.mosby3:viewstate:3.0.4&apos; // MVP + ViewState support&#125;allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;&#125; 79.AndResGuard 一句话介绍：一款提供资源文件路径混淆 的工具 上榜理由：如果你是个对APK大小很敏感的人，那么AndResGuard一定适合你，它的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a，3.4K个star，证明了在优化APK道路上，你不是一个人在战斗！ github：https://github.com/shwenzhang/AndResGuard 作者：wechat team 使用：clone项目到本地，其实也就是个三两句话的文档 80.StatusBarUtil 一句话介绍：一款提供设置沉浸式状态栏样式能力的框架 上榜理由：设计师MM总是抱怨系统状态栏不优雅？那就给她一个完美的沉浸式状态栏。StatusBarUtil可以随心所欲的设置状态栏样式，3.3K个star，足以说明它有多受设计MM的喜爱 github：https://github.com/laobie/StatusBarUtil 作者：Jaeger 使用：1compile &apos;com.jaeger.statusbarutil:library:1.4.0&apos; 81.robolectric 一句话介绍：一款不依赖于Android设备的单元测试框架， 上榜理由：sample中列举了如何对Android四大组件和常见功能测试的用例，3.2K个star，值得充满好奇心的人尝试 官网地址：http://robolectric.org/ github：https://github.com/robolectric/robolectric 作者：robolectric 使用：1testCompile &quot;org.robolectric:robolectric:3.3.2&quot; 82.Fragmentation 一句话介绍:一款提供管理Fragmen嵌套t能力的框架 上榜理由：对于Activity和Fragment使用，你一定得心应手，但如果要做一套通用的Activity&amp;Fragment嵌套设计，想必你有点手足无措了，Fragmentation可以作为你设计Fragment管理上的第一步，3.2K个star，笔者认为有点名副其实了，项目介绍里说的是Fragment的管理能力，但并未提供Fragment&amp;Activity生命周期、任务栈的管理能力，因此很难直接应用到企业项目当中，但源码当中的设计思路，值得笔者与诸位借鉴，拾人牙慧留有余香！ github：https://github.com/YoKeyword/Fragmentation 作者：YoKey 使用：1// appcompat v7包是必须的compile ‘me.yokeyword:fragmentation:0.10.7’// 如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，请再添加下面的库// compile ‘me.yokeyword:fragmentation-swipeback:0.10.4’ 83.Small 一句话介绍：轻巧的插件化框架 上榜理由：作为插件框架榜单的新成员，Small的优点是轻巧，适合作为小团队的插件开发方案，3.1K个star，让它获得了酷狗音乐等著名开发团队的青睐，如果你们的团队想逐步实施插件化开发，Small是个不错的选择！ 官网地址：http://code.wequick.net/Small/cn/cases github：https://github.com/wequick/Small 作者：wequick 团队 使用：123456789buildscript &#123; dependencies &#123; classpath &apos;net.wequick.tools.build:gradle-small:1.2.0-alpha6&apos; &#125;&#125;apply plugin: &apos;net.wequick.small&apos;small &#123; aarVersion = &apos;1.2.0-alpha6&apos;&#125; 84.JsBridge 一句话介绍：一款提供WebView和Javascript通信能力的框架 上榜理由：该框架提供给了允许H5页面调用通过JS调用App方法的能力；3.1K个star，简洁的通讯方式，值得每一个WebHybrid App开发者尝试 gtihub：https://github.com/lzyzsd/JsBridge 作者：hi大头鬼hi 使用：12345678repositories &#123; // ... maven &#123; url &quot;https://jitpack.io&quot; &#125;&#125;dependencies &#123; compile &apos;com.github.lzyzsd:jsbridge:1.0.4&apos;&#125; 85.richeditor-android 一句话介绍：一款强大的富文本编辑框架 上榜理由：2.8k个star，榜单里第一个为TextView提供扩展能力的框架，你暂时不需要它，但不能不知道它 github：https://github.com/wasabeef/richeditor-android 作者：Daichi Furiya 使用：1234567repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;jp.wasabeef:richeditor-android:1.2.2&apos;&#125; 86.Transitions-Everywhere 一句话介绍：一款教你正确使用Transitions API（Android 转场动画API）的教学型项目 上榜理由：你可能还未尝试过Android API的Transitions 框架，可能听过，但却无法做出优雅奇妙的动效——别担心，Transitions-Everywhere正如它的名字一样，它将带你全面体验Transitions 的强大之处 github：https://github.com/andkulikov/Transitions-Everywhere 作者：Andrey Kulikov 使用：123dependencies &#123; compile &quot;com.andkulikov:transitionseverywhere:1.7.4&quot;&#125; 87.android-viewbadger 一句话介绍：能够快速的为Android 视图加入“勋章”能力的框架 上榜理由：如果说勋章一词听起来陌生，那么显示已读未读个数、小红点标记信息这一类词语你一定不太陌生，笔者相信在诸位实际开发中经常遇到为某些item加入小红点标记的需求，聪明的各位一定有着各种实现方案，为什么不能快速优雅的完成呢？android-viewbadger可以帮你实现，当然，在某些情况下，你需要具备修改源码的能力，以符合设计MM的需求！值得注意的是，这宽项目已经五年没有更新了！ github：https://github.com/jgilfelt/android-viewbadger 作者：Jeff Gilfelt 使用：clone源码到本地 1234View target = findViewById(R.id.target_view);BadgeView badge = new BadgeView(this, target);badge.setText(&quot;1&quot;);badge.show(); 88.AndroidWiFiADB 一句话介绍：一款不用数据线也可以让你调试手机设备APP的插件项目 上榜理由：你是否还在担心测试过程中高强度的拔插数据线对手机电池和USB端口造成终生难以弥补的损害？别担心，有wifi有AndroidWiFiADB，无须数据线也可以调试应用了，更有趣的是，在测试工程师一边拿着手机一边找你聊bug的时候，你已经偷偷在它的手机上修复了bug，深藏功与名！ github：https://github.com/pedrovgs/AndroidWiFiADB 作者：Pedro Vicente Gómez Sánchez 使用： Preferences/Settings-&gt;Plugins-&gt;Browse Repositories-&gt;serch AndroidWiFiADB 89.emojicon 一句话介绍：一款提供在TextView、EdiText展示表情包能力的框架 上榜理由：2.7k个star，,榜单第二款增强TextView显示能力的框架，这款专为表情包设计，如果你曾经好奇微信、QQ的表情显示是如何做到的？这款框架一定能满足你的求知欲。 90.packer-ng-plugin 一句话介绍：一款打爆工具插件 上榜利用：笔者尽力维护榜单涉及范围的全面性，因此引入此插件项目——项目号称完成100个渠道包只需要10秒钟，在市面上各种各样多渠道打包方案的今天，选择一款适合自己团队的，才是上上选择 github：https://github.com/mcxiaoke/packer-ng-plugin 作者：Xiaoke Zhang 使用：1234567891011121314151617181920buildscript &#123; ...... dependencies&#123; // add packer-ng classpath &apos;com.mcxiaoke.gradle:packer-ng:1.0.9&apos; &#125;&#125; apply plugin: &apos;packer&apos; dependencies &#123; compile &apos;com.mcxiaoke.gradle:packer-helper:1.0.9&apos;&#125; android &#123; //... signingConfigs &#123; release &#123; // 满足下面两个条件时需要此配置 // 1. Gradle版本 &gt;= 2.14.1 // 2. Android Gradle Plugin 版本 &gt;= 2.2.0 // 作用是只使用旧版签名，禁用V2版签名模式 v2SigningEnabled false &#125; &#125; &#125; 91.android-priority-jobqueue 一句话介绍：一款提供后台任务管理能力的框架 上榜理由：如果你是个志在深入研究多线程操作的开发者，这个项目一定不要错过，不论是Activity重新加载、Service使用线程池时的任务优先级和并发问题，都不要担心，Job Manage会照顾优先级，持久性，负载平衡，延迟，网络控制，分组，2.4K个star，优秀的多线程管理能力，况且它依赖的第三方框架很少，值得你一试 github：https://github.com/yigit/android-priority-jobqueue 作者：Yigit Boyar]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试总结]]></title>
    <url>%2Fposts%2F27a6e4df.html</url>
    <content type="text"><![CDATA[面试大纲 java基础、面向对象、集合、线程使用； Android 机型适配、SDK适配、内存优化、内存溢出、内存泄漏； MVC/MVP/MVVM的使用场景； 了解并能使用最新流行开源库RXjava+Retrofit+OKHttp、Glide、EventBus等； JNI及NDK的使用、熟悉Framework。 频繁面试题 1.面向对象（OOP） 2.数据类型 3.equal和==的区别 4.字符串运行速度：StringBuilder、StringBuffer、 String 5.Queue 队列、Stack 栈 6.ListView机制 7.Fragment生命周期 8.四大引用类型 9.线程、进程及其通信方式 10.PackageManagerService 11.binder机制 12.launcher的实现 13.Android 版本特性 14.BroadcastReceiver广播 15.RecycleView 16.各种集合比较SparseArray、HashMap、ArrayMap、LinkedList、ArrayList 17.SQLite升级 18.Bitmap 19.Handler机制 20.性能优化技巧 21.ANR 22.自定义View 23.MVC、MVP、MVVM三种架构设计 24.APP 启动流程 25.插件化 26.Kotlin 多平台应用的静态编程语言 27.Framework 工作原理 28.Android 屏幕适配 29.事件分发机制 30.Android 动画分类：视图，属性，帧，gif 31.Android 进程 32.Android 五大存储方式 33.屏幕旋转Activity生命周期 34.Activity 四大启动模式 35.CPU、GPU工作原理 36.UI卡顿原因 37.Application的生命周期 38.如何避免因引入的开源库导致的安全性和稳定性？ 39.简单的音频/视频格式 40.线程同步的方法 41.线程安全的单例 42.Serializable、Parcelelable 43.Service启动方式和生命周期 44.Android 常见布局 45.Http、Https、Volley、OkHttp、RxJava + Retrofit + OkHttp、TCP、UDP 46.如何节省内存使用，主动回收内存？ 47.Activity如何生成View？ 48.为什么要使用多线程？ 49.现场保护 50.内存溢出、内存泄漏 51.JNI和NDK 52.常用的设计模式及其实现思想和作用 53.HashMap、 HashTable、HashSet的异同 54.Android 中内存泄漏原因及优化方案 55.LeakCanary 内存泄漏检查的开源工具 56.多线程、线程池 57.腾讯 Bugly 58.Glide 59.Fresco 60.React 面试题解析1.面向对象（OOP）针对业务处理过程的实体及其属性和行为进行抽象封装以获得高效清晰的逻辑单元划分。 三大特性：①封装（隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变量隔离便于使用，提高代码的服用小和安全性）；②继承（提高代码的复用性，继承是多态的前提）；③多态（父类或接口定义的引用变量可以指向子类或具体实现类的形象，提高了程序的拓展性）。 五大原则：单一职责、开放封闭、里氏替换、依赖倒置、接口分离。 2.数据类型byte 1个字符，short 、char2 个字符，int 、float 4个字符，long 、double 8个字符。** volatile是一个类型修饰符（type specifier）volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。（from百度） volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。 在JDK1.7之前，switch语句仅支持byte、short、char、int，在JDK1.7之后，枚举、字符串类型都可以，通过String.hashcode转成int进行判断。 String不可变原因：字符串常量池的需要；运行String对象缓存HashCode，提高效率；多线程安全。 String 转integer的方法和原理 ①Integer.parseInt（String str）调用Integer内部的； ②Integer.parseInt（String s, int radix）parseInt内部首先判断字符串是否包含符号（-或者+），则对相应的negative和limit进行赋值，然后再循环字符串，对单个char进行数值计算 ③Character.digit(char ch, int radix) 返回指定基数中字符表示的数值。函数肯定进入到0-9字符的判断（相对于string转换到int），否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。 限定参数类型的上界：参数类型必须是T或T的子类型 &lt;? super T&gt; 限定参数类型的下界：参数类型必须是T或T的超类型 3.equal和==的区别：equal 比较对象，==比较原生类型equal：存储空间的值是否相同，字符串内容比较，值是否相同 ==：是否为同一内存空间，内存空间是否相同，引用是否相同 如果一个类重写了equals()方法，则一定也要重写hashCode()方法，原因是：虽然equals()方法重写可以保证正确判断两个对象在逻辑是否相同，但是hashCode()方法映射的物理地址是不相同的，依然会将逻辑上相同的两个元素存入集合，但是第二个对象的内容会是Null. 参考文章：关于java中Object类中的equals()和hashCode()方法的使用个人总结 - 张森（ZhangSen） - 博客园 4.字符串运行速度：StringBuilder &gt; StringBuffer （线程安全）&gt; String ，String为常量，其它为变量，所以运行慢。5.Queue 队列：先进先出，Stack 栈：后进先出。Collect –&gt;List/Set/Map6.ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapterBaseAdapter 重写的方法getCount()、getItem()、getItemId()、getView()，每绘制一次就调用一次getView()，在getView()中将事先定好的layout布局确定显示的效果并返回一个view对象作为一个item 显示出来，getItem()、getItemId()在调用LIstView响应方法时调用。 7.Fragment生命周期参考文章：Fragment各种情况的生命周期 - 猫吻鱼的博客 - CSDN博客 onAttach()： 完成Fragment和Activity的绑定，参数中的Activity即为要绑定的Activity，可以进行赋值等操作。 onCreate() : 完成Fragment的初始化 onCreateView() : 加载Fragment布局，绑定布局文件 onActivityCreated() : 表名与Fragment绑定的Activity已经执行完成了onCreate，可以与Activity进行交互操作。 onStart() : Fragment变为可见状态 onResume() : Fragment变为可交互状态 onPause()： Fragment变为不可交互状态(不代表不可见) onSaveInstanceState()：保存当前Fragment的状态。记录一些数据，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本。 onStop(): Fragment变为不可见状态 onDestroyView() : 销毁Fragment的有关视图，但并未和Activity解绑，可以通过onCreateView()重新创建视图。Fragment销毁时或者ViewPager+Fragment情况下会调用 onDestroy() : 销毁Fragment时调用 onDetach() : 解除和Activity的绑定。Fragmen销毁最后一步。 8.四大引用类型强引用： 是指创建一个对象并把这个对象赋给一个引用变量。 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。 软引用（SoftReference）：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。 弱引用（WeakReference）：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。 虚引用（PhantomReference）：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。 9.线程是进程的子集，一个进程可有多个线程。线程间通讯方式：①共享变量；②管道；③handler；④runOnUiThread(Runnable)；⑤view.post(Runnable)。 进程间通讯方式：①管道；②FIFO；③消息队列；④信号量；⑤共享内存区；⑥套接字socket信号。 Activity间的通信方式：①Intent；②借助类的静态变量；③借助全局变量/Application；④借助外部工具（SharedPreference、SQLite、File、剪贴板）；⑤借助Service。 10.PackageManagerService APP安装有关的service，WindowManagerService APP调用窗口相关的service，ActivityManagerService 系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。自定义系统服务：在ServiceManager注册，在Framework/base增加JNI，C++ 文件，在build 配置mk文件，全部编译，才可调用。 11.binder机制Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 12.launcher的实现Manifest 配置launcher，PackageManager、ActivityManager对应包的管理和应用进程的管理。 13.Android 版本特性6.0需要代码请求权限checkPermissions，7.0应用间文件共享限制，系统广播删除，8.0通知渠道、悬浮窗、透明窗口不允许屏幕旋转，9.0明文流量的网络请求（Https加密） Android SDK兼容：minSdkVersion必须，targetSdkVersion针对某版本，maxSdkVersion非必需。 详细特性可见转载文档：Android 各版本新特性介绍 - 落叶Ex的博客 - CSDN博客 14.BroadcastReceiver广播 BroadcastReceiver比较 特别注意：动态广播最好在Activity 的 onResume()注册、onPause()注销。 原因：对于动态广播，有注册就必然得有注销，否则会导致内存泄露，重复注册、重复注销也不允许 广播的类型主要分为5类： 普通广播（Normal Broadcast）：开发者自身定义 intent的广播（最常用），sendBroadcast(intent); 系统广播（System Broadcast）：涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播，每个广播都有特定的Intent - Filter（包括具体的action） 有序广播（Ordered Broadcast）：发送出去的广播被广播接收者按照先后顺序接收，按照Priority属性值从大-小排序；Priority属性相同者，动态注册的广播优先； sendOrderedBroadcast(intent); 特点 接收广播按顺序接收 先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播； 先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播 App应用内广播（Local Broadcast）：Android高效安全的本地广播LocalBroadcast完全解析 - 简书 粘性广播（Sticky Broadcast）：由于在Android5.0 &amp; API 21中已经失效，所以不建议使用 15.RecycleView方法：onCreateViewHolder() 、onBinderViewHolder()、getItemCount() 三种布局：垂直or水平、网格、瀑布流 需要自定义分割线、易于回收、View复用、便于实现添加和删除item动画。 16.各种集合比较SparseArray稀疏数组与HashMap相比，正序插入快，逆序插入慢，查找慢占用内存少于HashMap； HashMap和ArrayMap的区别 ①查找效率 HashMap依据HashCode查找，效率增加；ArrayMap使用二分法查找，效率下降。数量大时用HashMap ②扩展数量 HashMap初始值16个长度，每次扩容申请双倍的数组空间；A扩容申请空间更少 ③扩容效率 ArrayMap更好 ④内存消耗 数据量小时，ArrayMap更节省内存 总结：数据量小时，并需要频繁使用map存储时，用ArrayMap，数据量大时，用HashMap。 HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 HashMap 的实例有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。在Java编程语言中，加载因子默认值为0.75，默认哈希表元为101 hashMap的默认加载因子为0.75，加载因子表示Hsah表中元素的填满的程度。加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。冲突的机会越大,则查找的成本越高。反之,查找的成本越小。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。 参考文章：为什么java Hashmap 中的加载因子是默认为0.75 - 简书 LinkedList 链表结构，查找慢，插入快； ArrayList 数组结构，查找快，插入慢。 17.SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade()方法中判断oldVersion对数据库进行增删改查以实现数据库升级。18.Bitmap参考文章：Android Bitmap详解 - 小爷宋 - 博客园 位图包括图片的像素、长宽、颜色等描述，可通过这些信息计算出图像占用内存的大小。作为花架，可对图片做一些处理，位图文件显示效果好，但是非压缩格式，需要占用较大存储空间。 ①Config：表示图片像素类型 ②三种压缩格式：Bitmap.CompressFormat.JPEG、Bitmap.CompressFormat.PNG、Bitmap.CompressFormat.WEBP ③BitmapFactory提供了四类加载方法：decodeFile、decodeResource、decodeStream、decodeByteArray。巨图加载：BitmapRegionDecoder，可以按照区域进行加载。高效加载：核心其实也很简单，主要是采样压缩、缓存策略、异步加载等 ④内存优化：缓存LRU、缩放、Config、Compress选择、内存管理、缓存方式等等方面入手。、内存管理、内存优化、缩放、config、compress 开源框架：ImageLoader、Glide（google）、Fresco（FaceBook）、Picasso（Square） 图片优化：异步加载，压缩处理bitmapFactory.options，设置内存大小，缓存于内存、SD卡，没有内存再从网络取。 Picasso包体积小、清晰，但功能有局限不能加载gif、只能缓存全尺寸； Glide功能全面，擅长大型图片流，体积较大； Fresco内存优化，减少oom，体积更大。 如何处理大图：BitmapFactory.Options，把inJustDecodeBounds这个属性设为true，计算inSampleSize。参考文章：官方推荐方法，如何有效率的加载大图Bitmap - 月毛毛的专栏 - CSDN博客 19.Handler机制主线程不能进行耗时操作，子线程不能更新UI，Handler实现线程间通信，将要发送的消息保存到Message中，Handler调用sendMessage()方法将message发送到MessageQueue，Looper对象不断调用loop()方法，不断从MessageQueue中取出message交给handler处理，从而实现线程间的通信。 主线程handler不需要调用Looper.prepare()，Looper.loop()，通过sendMessage将message添加到messagequeue。 子线程可以new Handler。 总结：当创建Handler时将通过ThreadLocal在当前线程绑定一个Looper对象，而Looper持有MessageQueue对象。执行Handler.sendMessage(Message)方法将一个待处理的Message插入到MessageQueue中，这时候通过Looper.loop()方法获取到队列中Message，然后再交由Handler.handleMessage(Message)来处理。 20.性能优化技巧启动速度优化，布局优化，内存、电量、APP大小优化、列表滑动优化等等。 性能优化工具：TraceView、Hierarchy Viewer。 21.ANR（Application Not Responding）扩展文链接：深入理解ANR - 简书 Android应用程序有一段时间响应不够灵敏，系统会向用户显示应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现ANR，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。 原因：主线程做耗时操作；主线程被其他线程锁；CPU被其他进程占用，该进程没有分配CPU资源；OnReceiver过多操作，IO操作，如数据库、文件、网络。 22.自定义View扩展文链接：Android自定义View全解 - 简书 自定义组合控件 多个控件组合成为一个新的控件，方便多处复用 继承系统View控件 继承自TextView等系统控件，在系统控件的基础功能上进行扩展 继承View 不复用系统控件逻辑，继承View进行功能定义 继承系统ViewGroup 继承自LinearLayout等系统控件，在系统控件的基础功能上进行扩展 继承ViewViewGroup 不复用系统控件逻辑，继承ViewGroup进行功能定义 View绘制流程基本由measure()、layout()、draw()这个三个函数完成 函数作用相关方法 measure()测量View的宽高measure(),setMeasuredDimension(),onMeasure() layout()计算当前View以及子View的位置layout(),onLayout(),setFrame() draw()视图的绘制工作draw(),onDraw() 自定义View的注意事项 参考文章：Android自定义View注意事项 - 简书 ①需要在onMeasure方法中处理wrap_content的方法，让View支持wrap_content； ②避免padding和子元素的margin失效，让View支持padding； ③尽量不要在View中使用Handler，View中已提供了post系列方法，可替代Handler作用； ④避免造成内存泄漏，View中如果有线程或者动画，需要及时停止。 23.MVC、MVP、MVVM三种架构设计扩展文链接：Android高精战争（MVC、MVP、MVVM） - lihaoxiang123的博客 - CSDN博客 MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。 MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。 MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）： View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity) Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合) Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。 View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试 MVC 与MVP的区别 （最主要区别）View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。 在MVP中，Activity的代码不臃肿； 在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会； 在MVP中，IUserView这个接口可以实现方便地对Presenter的测试； 在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。 MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。 24.APP 启动流程点击桌面图标，launcher进程启动主Activity以Binder方式发送给AMS服务，交付给ActivityManagerService处理Intent和flag信息，通过prepareMainLooper()方法loop处理消息 25.插件化解除代码耦合，插件支持热插拔，静默升级，从根本上解决65k属性和方法的bug，进行自定义classLoader。 插件化和热修复都是动态加载技术，使用场景不同，热修复为解决线上问题或者小功能更新，插件化解决应用上的大问题。 组件化：为了解耦，把复杂系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。 26.Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。 React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 flutter。 27.Framework 工作原理Android 系统对Linux、kernel、lib库等封装，提供WMS、AMS、binder机制，handler-message机制等方式，供APP使用。Framework 就是提供APP生存环境。 28.Android 屏幕适配各种dp文件，使用各种尺寸屏幕 布局文件中view设置高宽时不限定大小，尽量使用wrap_content，match_parent；代码中设置高宽前可获取屏幕大小，如果是线性布局可设置view在LinearLayout的weight；单位dp适配屏幕，单位sp适用字体，多图片，多布局。 29.事件分发机制dispatchTouchEvent() 负责事件分发。当点击事件产生后，事件首先传递给当前Activity，调用Activity的dispatchTouchEvent()方法，返回值为true则表示View或子View消费了此事件，如果返回true，则表示没有消费事件，并调用父View的onTouchEvent方法。 onTouchEvent()用于处理事件，返回值决定当前控件是否消费了这个事件，也就是说在当前控件在调用父View的onTouchEvent方法完Touch事件后，是否还允许Touch事件继续向上（父控件）传递，一但返回True，则父控件不用操心自己来处理Touch事件。返回true，则向上传递给父控件。 onInterceptTouchEvent() ViewGroup的一个方法，用于处理事件（类似于预处理，当然也可以不处理）并改变事件的传递方向，也就是决定是否允许Touch事件继续向下（子控件）传递，一但返回True（代表事件在当前的viewGroup中会被处理），则向下传递之路被截断（所有子控件将没有机会参与Touch事件），同时把事件传递给当前的控件的onTouchEvent()处理；返回false，则把事件交给子控件的onInterceptTouchEvent()。 事件分发机制原理图 当一个Touch事件(触摸事件为例)到达根节点，即Acitivty的ViewGroup时，它会依次下发，下发的过程是调用子View(ViewGroup)的dispatchTouchEvent方法实现的。简单来说，就是ViewGroup遍历它包含着的子View，调用每个View的dispatchTouchEvent方法，而当子View为ViewGroup时，又会通过调用ViwGroup的dispatchTouchEvent方法继续调用其内部的View的dispatchTouchEvent方法。上述例子中的消息下发顺序是这样的：①-②-⑤-⑥-⑦-③-④。dispatchTouchEvent方法只负责事件的分发，它拥有boolean类型的返回值，当返回为true时，顺序下发会中断。 小结：onInterceptTouchEvent()默认返回false，不做截获。返回true之后，事件流的后端控件就没有机会处理touch事件。view的onTouchEvent()返回了false，那么该事件将被传递至其上一层次的view的onTouchEvent()处理，如果onTouchEvent()返回了true，那么后续事件将可以继续传递给该view的onTouchEvent()处理。 30.Android 动画分类：视图，属性，帧，gif。31.Android 进程一般大体分为前台进程，后台进程，可见进程，服务进程，空进程这五大进程。其中空进程优先级最低，调用startService()让service所在进程成为前台进程，service的onDestory()里重新启动自己可避免后台进程被杀死。 一个应用允许多个进程，在清单文件配置的service为一个进程，Android:process就可以配置； 多进程会引起的异常：静态成员和单例模式会失效，线程同步机制完全失效，SharedPreferences可靠性下降，Application会多次创建。 32.Android 五大存储方式使用SharedPreferences存储数据； 文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据。 当APP没有获取文件存储权限时，当需要存储大文件时，可以保存在APP-data-cache目录里。 ContentProvider：抽象类，为不同应用数据提供数据共享，提供统一接口，通过uri标识要访问的数据。 33.屏幕旋转Activity生命周期参考文章链接：Activity横竖屏切换生命周期变化 - 简书 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行1次，切竖屏时会执行1次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 4、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏切记要加上screenSize,否则4.0版本以上生命周期不生效 34.Activity 四大启动模式standard 启动模式 Activity 默认的启动模式，每次 startActivity 都会在栈顶创建一个新的实例，在同一个任务中可以存在多个Activity 的实例。 singleTop 启动模式 栈顶复用，也就是说，要启动 singleTop 模式的 Activity，如果它恰好在当前栈顶，那么直接复用，执行其 onNewIntent 方法。否则，就重新创建一个实例入栈。 singleTask 启动模式 在系统中只有一个实例，当再次启动该 Activity 时，会重用已存在的任务和实例，并且会调用这个实例的 onNewIntent()方法，将 Intent 实例传递到该实例中。 singleInstance 启动模式 总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他 Activity 会自动运行于另一个任务中。当再次启动该 Activity 的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将 Intent 实例传递到该实例中。 总结：①standard每一次都会创建新的实例；②singleTop栈顶复用。和standard相似，但是如果栈顶已有实例，复用该实例，回调onNewIntent()方法；③singleTask栈内复用。查找栈内有没有该实例，有则复用回调onNewIntent()方法，如果没有，新建Activity，并入栈；④singleInstance单例模式，全局唯一。具备singleTask所有特性，独占一个任务栈。 35.CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。36.UI卡顿原因每16ms绘制一次Activity，如果由于一些原因导致了我们的逻辑、CPU耗时、GPU耗时大于16ms(应用卡顿的根源就在于16ms内不能完成绘制渲染合成过程,16ms需要完成视图树的所有测量、布局、绘制渲染及合成)，UI就无法完成一次绘制，那么就会造成卡顿。①内存抖动问题，②方法耗时，③view本身卡顿。 解决办法：修改方法，使其不耗时，放到子线程中，如网络访问，大文件操作等，防止ANR，避免GPU过度绘制。 37.Application的生命周期参考文章：Android中Application的用途及生命周期_YY小爬虫_新浪博客 ①onCreate0 在创建应用程序时创建； ②onTerminate() 在模拟环境下执行。当终止应用程序对象时调用，不保证一定被调用，当程序是被内核终止以便为其他应用程序释放资源，那么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程； ③onLowMemory() 低内存时执行。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况； ④onConfigurationChanged(Configuration newConfig) 配置改变时触发这个方法。 ⑤onTrimMemory(int level) 程序在进行内存清理时执行。 38.如何避免因引入的开源库导致的安全性和稳定性？由于项目引入了太多第三方开源库，Android APP有65536方法数的问题，可使用multidex解决。Android Methods Count插件可以高效统计Android开源库的方法数。 39.简单的音频/视频格式PCM：脉冲编码调制，由二进制数字信号对光源进行通断调制产生，没有压缩的编码方式。 WAV：无损音频文件格式，PCM是无损WAV文件中音频数据的一种编码方式，但是WAV还可以用其它编码。 AVI：音视频交错，调用方便，图像质量好，压缩标准可选。 WMV：可扩充的媒体类型，本地或网络回放，流优先级化。 3GP：3G流媒体，配合3G网络高速传输而开发。 FLV：文件小，加载速度快，用于网络观看视频。 MP4：音视频压缩编码标准。 40.线程同步的方法转载文章：多线程同步的五种方法 - 平凡希 - 博客园 ①synchronized 即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态； ②同步代码块 即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步； ③使用特殊变量Volatile （1）volatile关键字为域变量的访问提供了一种免锁机制； （2）使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新； （3）因此每次使用该域就要重新计算，而不是使用寄存器中的值； （4）volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。 ④使用重入锁 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力； ⑤使用局部变量； ⑥使用阻塞队列。 线程sleep()和wait()的区别 sleep()不释放同步锁，自动唤醒，需要try-catch，线程方法。 wait()释放同步锁，需要notify唤醒，是object方法。 线程的生命周期？如何中断？ 生命周期：文章转载：多线程——线程的生命周期 - 积_跬步 - 博客园 ① 新建状态(New Thread)：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。 线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。 ② 就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。 ③ 运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。 a) 可以通过Thread类的isAlive方法来判断线程是否处于就绪/运行状态：当线程处于就绪/运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。 ④ 阻塞和唤醒线程 阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括： ​ a)当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。 ​ b)当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。 ​ c)当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()/notify()方法的执行要求线程首先获得该对象的锁。 ⑤ 死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。 终止线程的三种方法 ① 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。 ② 使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。 ③ 使用interrupt方法中断线程。 41.线程安全的单例1234567891011121314 private static SingleInstance instance; public static SingleInstance getInstance(SingleInstance instance)&#123; if (instance == null) &#123; synchronized (SingleInstance.class) &#123; if (instance == null) &#123; instance = new SingleInstance(); &#125; &#125; &#125; return instance; &#125;&#125; 42.Serializable 序列化接口，开销大，建议使用，java方法； Parcelelable 使用麻烦，效率高，多用于内存，Android方法。 43.Service启动方式和生命周期 ①startService()：开启，调用者退出后Service仍在； 生命周期：onCreate()–onStartCommand()–onDestory() 通过startService启动后，service会一直无限期运行下去，只有外部调用了stopService()或stopSelf()方法时，该Service才会停止运行并销毁。 ②bindService()：开启，调用者退出后Service随即退出。 生命周期：onCreate()–onBind()–onUnBind()–onDestory() ①+② 的生命周期：onCreate()–onStartCommand()–onBind()–onUnBind()–onDestory() 44.Android 常见布局 FrameLayout （框架布局）、LinearLayout（线性布局）、AbsoluteLayout（绝对布局）、RelativeLayout（相对布局）、TableLayout（表格布局） 45.Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。 ①HttpClient：开源框架，无封装，原始，使用方便，开发快，实现比较稳定，Android废弃，Android 6.0删除； ②HttpUrlConnection：对网络请求没有HttpClient封装彻底，Android2.2之前存在bug，所以2.2之前用HttpClient，之后用容易优化的HttpUrlConnection，开源框架，封装了请求头、参数、内容体、响应在I/O流，接口中统一封成了HttpGet/HttpPost，减少了操作的繁琐性，访问速度快。 Https是以安全为目标的Http通道，简单讲就是Http的安全版，即Http下加入SSL层，安全基础是SSL，加密的详细内容是SSL，作用：建立一个信息安全通道，来保证数据传输的安全、确认网站的安全性。 Volley：适合处理数据量小，通信频繁的网络操作，内部封装了异步操作，可直接在线程执行并处理结果，同时可以取消，容易扩展，但是不适合大数据请求，比如下载表现糟糕，不支持https，android2.2及以下用HttpClient，android2.3及以上用HttpUrlConnection。 OkHttp：专注于提升网络连接效率的Http客户端，能够实现IP和端口的请求重用一个socket，大大降低了连接时间，也降低了服务器的压力，对Http和https都有良好的支持，不用担心app版本更换的困扰，但是okHttp请求是在线程里执行，不能直接刷新UI，需要手动处理。 总结：在项目实际运用中，视情况选择网络请求方式，也可以Volley+OkHttp搭配使用。异步回调用Volley，网络请求底层用OkHttp RxJava + Retrofit3 + OkHttp3 ①RxJava 主要用来实现线程切换，我们制定订阅在哪一个线程，观察在哪个线程，通过操作符进行数据变换，整个过程是键式的，简化逻辑。 ②Retrofit 是网络请求的一个架子，用它设置一些参数和请求Url。 ③OkHttp是网络请求的内核，实际的网络请求是它发出来的。 TCP 是网络层，滑动窗口协议，拥塞控制，可靠连接借助socket长连接，需要3次握手，第四次取消连接，画面优先。 UDP：不关心数据是否到达，是否阻塞，不可靠连接，流畅优先。 46.如何节省内存使用，主动回收内存？ 答：尽量多使用内部类，提高程序效率，回收已使用的资源，合理使用缓存，合理设置变量的作用范围。 47.Activity如何生成View？ 答：Activity执行在attch()方法的时候，会创建一个PhoneWindow（Window的子类），在onCreate()方法的setContentView()方法中，创建DecorView，DecorView的addView()方法，把layout布局加载出来。通过onDraw()画出来，画View之前调用onMeasure()方法计算显示的大小。 48.为什么要使用多线程？ ①更好地利用CPU资源；②进程间数据不能数据共享，线程可以；③系统创建进程需要为该进程重新分配系统资源，创建线程代价较小；④Java语言内置了多线程功能支持，简化了java多线程编程。 线程池是一种多线程处理形式，处理过程中将任务添加到队列，在创建线程后自动启动这些任务，线程池线程是后台线程，每个线程都使用默认的堆栈大小，以优先级执行。 49.现场保护123456789@Overrideprotected void onSaveInstanceState(Bundle savedInstanceState) &#123; super.onSaveInstanceState(savedInstanceState);&#125;@Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState);&#125; 使用场景：①进程被异常杀死；②系统配置发生变化（比如横竖屏切花换）。 当Activity处于onPause() ，onStop() ，onDestroy() 三种状态时程序可能会被Android系统回收掉，这时可能会造成用户在程序当中的数据或者修改丢失。于是我们需要”现场保护”，当下次重启程序或activity时恢复上一次的数据。 因此Android提供了onSaveInstanceState(Bundlout State)方法会在程序被回收前进行调用，但需要注意的是onSaveInstanceState()方法只适合保存瞬态数据, 比如UI控件的状态, 成员变量的值等，而不应该用来保存持久化数据。onRestoreInstanceState方法，需要注意的是onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。 50.内存溢出，内存泄漏 内存溢出（OOM）：程序在申请内存时，没有足够的内存空间使用。 原因：加载对象过大，相对资源较多，来不及加载。 解决办法：内存引用上做处理，比如用软引用；图片加载时处理（压缩等）；动态回收内存；优化内存分配，自定义堆内存大小，避免使用Enum，减少BitMap的内存占用，内存对象重复使用，避免对象的内存泄漏。 内存泄漏（memory leak）： 程序在申请内存后，无法释放已申请的内存空间，一次泄漏危害可忽略，但推积严重最终会导致OOM； handler泄露：消息引用了handler对象，该对象又隐性地持有了Activity对象，当发生GC时以为message-handler-activity的引用链导致Activity无法被回收，即发生泄漏，简单来说就是handler对activity强引用导致的GC，无法及时回收Activity。（PS：GC垃圾回收，当堆内存里的对象没有引用指向时，GC回收。） 解决办法：方法一：通过程序逻辑来进行保护。 1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。 方法二：将Handler声明为静态类。 PS:在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。 静态类不持有外部类的对象，所以你的Activity可以随意被回收。由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）。 WebView泄漏：创建的对象没有在合适的时间销毁，则一直存在内存里耗费内存空间，WebView不建议在xml文件中指明，因为一直存在不能对其销毁，应该在代码中创建WebView，通过addView()的方式加入layout，在Activity 的onDestory()方法中需要销毁，先将加载的内容置为null，webView.destroy(); 12345678910111213141516171819202122WebView mWebView = new WebView(getApplicationContext()); @Override protected void onDestroy() &#123; if( mWebView!=null) &#123; ViewParent parent = mWebView.getParent(); if (parent != null) &#123; ((ViewGroup) parent).removeView(mWebView); &#125; mWebView.stopLoading(); // 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错 mWebView.getSettings().setJavaScriptEnabled(false); mWebView.clearHistory(); mWebView.clearView(); mWebView.removeAllViews(); mWebView.destroy(); &#125; super.onDestroy(); &#125; 51.JNI和NDK​ JNI是Java调用Native 语言的一种特性，属于Java，Java本地接口，使Java与本地其他类型语言交互（C++） ​ 实现步骤：在Java中声明Native方法，编译该文件得到.class文件，通过javah命令导出JNI头文件（.h文件），使用Java需要交互的本地代码实现子啊Java中声明的Native方法，编译so文件，通过Java执行Java程序，最终实现Java调用本地代码 ​ NDK（Native Develop Kit）：Android开发工具包，属于Android。 ​ 作用：快速开发C、C++动态库，并自动将so文件和应用打包成APK，即可通过NDK在Android中使用JNI与本地代码（C、C++）交互（Android开发需要本地代码C、C++实现） ​ 特点：运行效率高，代码安全性高，功能拓展性好，易于代码复用和移植。 ​ 使用步骤：①配置NDK环境；②创建Android项目，并于NDK进行关联；③在Android项目中声明所需调用的Native方法；④使用该Native方法；⑤通过NDK build命令编译产生so文件；⑥编译AS工程，实现调用本地代码。 ​ JNI和NDK的关系：JNI实现目的，NDK是Android实现JNI的手段，即在AS开发环境中通过NDK从而实现JNI功能。 52.常用的设计模式及其实现思想和作用转载文章：23种设计模式全解析 - codeTao - 博客园 ①单例模式：单例对象能保证在一个JVM中，该对象只有一个实例存在。 ②工厂模式 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 ③适配器模式 将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 ④装饰模式（Decorator） 顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能。 装饰器模式的应用场景： 1、需要扩展一个类的功能。 2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ ⑤代理模式（Proxy）：多一个代理类出来，替原对象进行一些操作。 ⑥桥接模式（Bridge）：桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化。 ⑦观察者模式：一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。 ⑧访问者模式：一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。 53.HashMap、 HashTable、HashSet的异同转载文章：HashSet HashTable HashMap的区别 及其Java集合介绍 - ywl925 - 博客园 ①HashSet是Set的一个实现类，HashMap是Map的一个实现类，同时HashMap是HashTable的替代品 ②HashSet以对象作为元素，而HashMap以(key-value)的一组对象作为元素，且HashSet拒绝接受重复的对象。HashMap可以看作三个视图：key的Set，value的Collection，Entry的Set。 这里HashSet就是其实就是HashMap的一个视图。 HashSet内部就是使用HashMap实现的，和HashMap不同的是它不需要Key和Value两个值。 HashMap是一个数组和链表的结合体，新加入的放在链头，重复的key不同的alue被新value替代 ③继承不同 public class Hashtable extends Dictionary&lt;&gt; implements Map&lt;&gt; public class HashMap extends AbstractMap&lt;&gt; implements Map&lt;&gt; ④HashTable 方法同步，而HashMap需要自己增加同步处理。 ⑤HashTable中，key和value都不允许出现null值。 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。用containsKey()方法来判断是否存在某个键。 ⑥两个遍历方式的内部实现上不同。 HashTable、HashMap都使用了 Iterator。而由于历史原因，HashTable还使用了Enumeration的方式 。 ⑦哈希值的使用不同 HashTable直接使用对象的hashCode，HashTable中hash数组默认大小是11，增加的方式是 old*2+1。 而HashMap重新计算hash值，HashMap中hash数组的默认大小是16，而且一定是2的指数。 如何实现HashMap线程同步？ ①使用 java.util.Hashtable 类，此类是线程安全的。 ②使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。 ③使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。 54.Android 中内存泄漏原因及优化方案？文章转载：Android 中内存泄漏的原因和解决方案 - 简书 ①非静态内部类造成的内存泄漏 非静态类会持有外部类的引用，如果这个内部类比外部类的生命周期长，在外部类被销毁时，内部类无法回收，即造成内存泄漏； ②外部类中持有非静态内部类的静态对象 保持一致的生命周期，将内部类对象改成非静态； ③Handler 或 Runnable 作为非静态内部类 Handler 和 Runnable 作为匿名内部类，都会持有 Activity 的引用，由于 Handler 和 Runnable 的生命周期比 Activity 长，导致Activity 无法被回收，从而造成内存泄漏。 解决办法：将Handler 和 Runnable 定义为静态内部类，在Activity 的onDestory()方法中调用Handler 的 removeCallbacks 方法来移除 Message。 还有一种特殊情况，如果 Handler 或者 Runnable 中持有 Context 对象，那么即使使用静态内部类，还是会发生内存泄漏。解决办法：使用弱引用 ④其他内存泄漏情况：比如BraodcastReceiver 未注销，InputStream 未关闭，再代码中多注意注销或关闭。 55.LeakCanary内存优化参考文章：LeakCanary原理解析 - 简书 ①项目如何使用LeakCanary LeakCanary.enableDisplayLeakActivity(context);内存溢出图标，图标以通知的形式显示内存溢出 ②工作机制 LeakCanary.install() 会返回一个预定义的 RefWatcher，同时也会启用一个 ActivityRefWatcher，用于自动监控调用Activity.onDestroy() 之后泄露的 activity。 1.RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。 2.然后在后台线程检查引用是否被清除，如果没有，调用GC。 3.如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。 4.在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。 5.得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。 6.HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。 7.引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 56.多线程、线程池参考文章：Java中的多线程你只要看这一篇就够了 - Givefine - 博客园 线程的并行和并发 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全：多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。 Java通过Executors提供四种线程池（from 百度） newCachedThreadPool——创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool——创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool——创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor——创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 参考文章：Java并发编程：线程池的使用 - Matrix海子 - 博客园 ①线程池中的线程初始化 创建线程池后，线程池中没有线程，需要提交任务才会创建线程。 prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 ②workQueue，任务缓存队列，用来存放等待执行的任务 workQueue的类型为BlockingQueue，通常可以取下面三种类型： 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小； 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE； 3）SynchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 ③任务拒绝策略 当线程池的任务缓存队列已满或线程数目达到maximumPoolSize，还有任务来时会采用任务拒绝策略 1）ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 2）ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 3）ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） 4）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 ④线程池的关闭 1）shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 2）shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 ⑤线程池容量的动态调整 1）setCorePoolSize：设置核心池大小 2）setMaximumPoolSize：设置线程池最大能创建的线程数目大小 参考文章：由浅入深理解Java线程池及线程池的如何使用 - Janti - 博客园 corePoolSize :线程池的核心池大小，在创建线程池之后，线程池默认没有任何线程。 当有任务过来的时候才会去创建创建线程执行任务。换个说法，线程池创建之后，线程池中的线程数为0，当任务过来就会创建一个线程去执行，直到线程数达到corePoolSize之后，就会被到达的任务放在队列中。（注意是到达的任务）。换句更精炼的话：corePoolSize表示允许线程池中允许同时运行的最大线程数。 如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize :线程池允许的最大线程数，他表示最大能创建多少个线程。maximumPoolSize肯定是大于等于corePoolSize。 keepAliveTime :表示线程没有任务时最多保持多久然后停止。默认情况下，只有线程池中线程数大于corePoolSize时，keepAliveTime才会起作用。换句话说，当线程池中的线程数大于corePoolSize，并且一个线程空闲时间达到了keepAliveTime，那么就是shutdown。 Unit:keepAliveTime的单位。 workQueue：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能 threadFactory：线程工厂，用来创建线程。 handler :表示当拒绝处理任务时的策略。 在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池： Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE Executors.newSingleThreadExecutor(); //创建容量为1的缓冲池 Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池 57.腾讯 Bugly腾讯公司为移动开发者开放的服务之一，面向移动开发者提供专业的 Crash 监控、崩溃分析等质量跟踪服务。Bugly 能帮助移动互联网开发者更及时地发现掌控异常，更全面的了解定位异常，更高效的修复解决异常。 针对移动应用，腾讯 Bugly 提供了专业的 Crash、Android ANR ( application not response)、iOS 卡顿监控和解决方案。移动开发者 ( Android / iOS ) 可以通过监控，快速发现用户在使用过程中出现的 Crash (崩溃)、Android ANR 和 iOS 卡顿，并根据上报的信息快速定位和解决问题。 58.Glidegithub 地址 项目依赖Glide，在app build.gradle 中配置 compile’com.github.bumptech.glide:glide:3.7.0’ 使用glide3.7版本，更高版本或出现异常：Error:Failed to resolve: com.android.support:support-annotations:27.0.2 Glide缓存机制 内存存缓存的 读存都在Engine类中完成。内存缓存使用弱引用和LruCache结合完成的,弱引用来缓存的是正在使用中的图片。图片封装类Resources内部有个计数器判断是该图片否正在使用。 Glide内存缓存的流程 读：是先从lruCache取，取不到再从弱引用中取； 存：内存缓存取不到，从网络拉取回来先放在弱引用里，渲染图片，图片对象Resources使用计数加一； 渲染完图片，图片对象Resources使用计数减一，如果计数为0，图片缓存从弱引用中删除，放入lruCache缓存。 参考文章： Google推荐——Glide使用详解 - 简书 Glide 系列(四) Glide缓存机制 - 野生的安卓兽 - 简书 59.Frescogithub 地址 项目依赖Glide，在app build.gradle 中配置：implementation’com.facebook.fresco:fresco:1.9.0’ https://github.com/desmond1121/Fresco-Source-Analysis 参考文章：Fresco的使用小结 - 简书 https://blog.csdn.net/yw59792649/article/details/78921025 60.React Native混合开发技术移动开发-混合App介绍 - Primise7的博客 - CSDN博客]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试题集]]></title>
    <url>%2Fposts%2F4a3cde30.html</url>
    <content type="text"><![CDATA[Java部分Android部分数据结构与算法部分常用的开源库部分计算机网络认识 1.Java部分1.1 操作系统相关 1.什么是操作系统？ 2.什么是线程，什么是进程？ 1.2 JDK&amp;JVM&amp;JRE 1.JDK &amp; JVM &amp; JRE分别是什么以及它们的区别？ 2.解释一下为什么Java可以跨平台？ 1.3 面向过程 &amp; 面向对象 1.什么是面向过程 &amp; 什么是面向对象 &amp; 区别？ 2.给我说说Java面向对象的特征以及讲讲你代码中凸显这些特征的经验。 3.什么是重载 &amp; 什么是重写 &amp; 区别。 4.谈谈你对this和super的认识。 5.接口和抽象类的区别。 6.静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？ 7.给我说说权限修饰符特性。 8.给我谈谈Java中的内部类。 9.闭包和内部类的区别？ 10.Java多态的实现机制是什么？ 11.谈谈你对对象生命周期的认识？ 12.static关键字的作用？ 13.final关键字的作用。 1.4 八大基本数据类型&amp;引用类型 1.说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 什么是引用类型？ 2.什么是拆箱 &amp; 装箱，能给我举栗子吗？ 1.5 数组 1.能说说多维数组在内存上是怎么存储的吗？ 2.你对数组二次封装过吗？说说封装了什么 1.6 Java异常 1.说说Java异常体系主要用来干什么的 &amp; 异常体系？ 2.Error和Exception的区别？ 3.说说运行时异常和非运行时异常的区别？ 4.如何自定义一个异常？ 5.throw和throws 的区别？ 6.try{}catch{}finally{}可以没有finally吗？ 7.finally语块有什么特点？ 8.return在try{}catch{}finally{}中执行具有哪些规则？ 9.给我例举至少5个常见的运行时异常。 1.7 NIO/BIO/AIO 1.NIO是什么 &amp; BIO是什么 &amp; AIO是什么 &amp; 它们之间的区别？ 2.IO按照方向和数据类型划分能划分为哪些数据流？ 3.能给我说说NIO有什么特点？平常开发中使用过吗？ 1.8 集合(容器) 1.说说Java中集合的框架？ 2.Collection &amp; Map区别 3.谈谈你常用的集合 &amp; 它们底层的实现方式 &amp; 优缺点 &amp; 使用场景。 4.Map的遍历方式有哪些？ 5.给我说说ArrayList的扩容机制. 6.什么是深拷贝 &amp; 浅拷贝 &amp; 如何深拷贝一个List集合. 7.Set是如何确保它的唯一性的。 8.你觉得HashMap的元素顺序和什么有关？ 9.Java中HashMap如何解决哈希碰撞的？ 10.ConcurrentHashMap如何实现并发访问的？ 11.谈谈Java集合中那些线程安全的集合 &amp; 实现原理。 12.说说有哪些集合能加入null,哪些不能加入null,为什么？ 13.说说LinkedHashMap原理。 14.Collection 和 Collections的区别？ 15.比较一下ArrayMap和HashMap。 16.说说HashMap的原理。 1.9 线程 1.什么是线程？能解决什么问题。 2.Java中创建线程的2种方式 &amp; 区别？ 3.给我说说线程的生命周期。 4.线程死锁的原因 &amp; 举个栗子 &amp; 如何避免死锁。 5.Synchronized放在静态方法和非静态方法上的锁对象分别是什么？ 6.如何停止掉一个线程？ 7.给我说说线程池的种类 &amp; 特点 &amp; 内部原理 &amp; 平时当中使用案例。 8.给我谈谈你是如何保证线程数据安全问题的？ 9.wait()和sleep()的区别？ 10.什么是公平锁&amp;非公平锁&amp;区别？ 11.给我讲讲线程间通信 12.volatile关键字是如何使用的？原理是什么 13.说说使用5个线程去计算一个数组之和的思路。 14.谈谈线程阻塞的原因有哪些？ 15.谈谈你对notify的理解？ 16.你觉得Lock和Synchronized的区别是什么？ 17.谈谈你对ReentrantLock的认识。 18.调用run()和start()的区别？ 19.transient关键字的用法 &amp; 作用 &amp; 原理。 20.线程池的种类 &amp; 工作原理 &amp; ThreadPoolExecutor的工作策略有哪些？ 21.ThreadLocal了解吗？说说原理。 22.权衡多线程的性能。 23.如何理解同步和异步，阻塞和非阻塞。 1.10 泛型 1.什么是泛型？能解决什么问题？ 2.说说Java中泛型的工作机制？ 3.在泛型种extends和super关键字的区别是什么？ 1.11 反射 1.什么是反射？ 2.如何获取一个类的成员变量 &amp; 成员方法 &amp; 注解信息 &amp; …。 3.通常在项目当中用到反射多吗？都是用来干嘛？ 1.12 注解 1.什么是注解 &amp; 它和注释的区别？ 2.注解的工作机制是什么？ 1.13 Socket编程 1.什么是Socket编程？ 2.什么是TCP,什么是UDP,二者之间区别如何？ 1.14 设计模式 1.说说设计模式的六大原则。 2.请讲讲你会使用的一些设计模式？ 3.请说说单例模式 &amp; 你项目中常用的单例模式。 4.懒汉单例模式为什么要加volaitle？ 5.能否给我说说Android中至少3个用到设计模式的栗子？ 1.15 JVM相关 1.什么是class文件？ 2.Java代码执行流程？ 3.Java内存结构 &amp; 内存模型。 4.GC回收机制。 5.Java虚拟机是如何加载一个类的？ 6.给我谈谈类加载器。 7.谈谈static编译运行时的流程，在虚拟机中如何保存的？ 8.说说Java种的4种引用以及用法？ 9.如何判断一个对象是死亡的？ 10.代码中直接调用System.gc()会发生什么？ 11.一个强引用直接被null赋值，那么这个对象会被立刻回收吗？ 12.String a = “a”+”b”+”c”;在内存中创建了几个对象？ 13.谈谈你对字符集的理解。 14.常见的编码格式有哪些？ 15.utf-8中的中文占几个字节？int型占几个字节？ 16.谈谈你对逻辑地址和物理地址的理解？ 17.你知道对象什么时候会回调finalize方法吗？ 1.16 其它Java部分有关面试题 1.为什么局部内部类访问局部变量需要final? 2.String、StringBuffer、StringBuilder、CharSequence的区别。 3.equals和==的区别？ 4.关于字符串的拼接你在项目中常常怎么操作的？为什么不能用“+”的方式进行拼接呢？ 5.什么是Callback,讲讲你项目中使用的一些有关Callback的栗子。 6.retrun &amp; break &amp; continue 区别？ 7.如何判断一个字符串是回文字符串？ 8.final,finally,finalize的区别？ 9.什么是动态代理 &amp; 什么是静态代理？ 10.String为什么会加final？ 11.OOM可以try{}catch{}吗？ 12.给我谈谈正则表达式。 13.如何将String转成int? 14.谈谈你对String的理解。 15.你如何理解序列化？有哪些方式序列化？ 16.谈谈你对依赖注入的理解。 17.给我谈谈你对分派的理解。 2.Android 部分 四大组件是哪四个？ABCS(Activity,Braodcast,ContentProvider,Service) 2.1 Activity 1.Activity是什么？ 2.典型情况下的Activity生命周期？ 3.异常情况下的Activity的生命周期 &amp; 数据如何保存和恢复？ 4.从Activity A跳转到Activity B之后，然后再点击back建之后，它们的生命周期调用流程是什么？ 5.如何统计Activity的工作时间？ 6.给我说说Activity的启动模式 &amp; 使用场景。 7.如何在任意位置关掉应用所有Activity &amp; 如何在任意位置关掉指定的Activity？ 8.Activity的启动流程(从源码角度解析)？ 9.启动一个其它应用的Activity的生命周期分析。 10.Activity任务栈是什么？在项目中有用到它吗？说给我听听 11.什么情况下Activity不走onDestory? 12.什么情况下Activity会单独执行onPause? 13.a-&gt;b-&gt;c界面，其中b是SingleInstance的，那么c界面点back返回a界面，为什么？ 14.如果一个Activity弹出一个Dialog,那么这个Acitvity会回调哪些生命周期函数呢？ 15.Activity之间如何通信 &amp; Activity和Fragment之间通信 &amp; Activity和Service之间通信？ 16.说说Activity横竖屏切换的生命周期。 17.前台切换到后台，然后在回到前台时Activity的生命周期。 18.下拉状态栏时Activity的生命周期？ 19.Activity与Fragment的生命周期比较？ 20.了解哪些Activity常用的标记位Flags？ 21.谈谈隐式启动和显示启动Activity的方式？ 22.Activity用Intent传递数据和Bundle传递数据的区别？为什么不用HashMap呢？ 23.在隐式启动中Intent可以设置多个action,多个category吗 &amp; 顺便讲讲它们的匹配规则？ 24.Activity可以设置为对话框的形式吗？ 25.如何给Activity设置进入和退出的动画？ 26.Activity使用Intent传递数据是否有限制 &amp; 如果传递一个复杂的对象，例如一个复杂的控件对象应该怎么做？ 2.2 BroadcastReceiver 1.广播是什么？ 2.广播的注册方式有哪些？ 3.广播的分类 &amp; 特性 &amp; 使用场景？ 4.说说系统广播和本地广播的原理 &amp; 区别 &amp; 使用场景。 5.有两个应用注册了一样的广播，一个是静态，一个是动态，连优先级也一样，那么当广播从系统发出来后，哪个应用先接收到广播？ 2.3 ContentProvider 1.什么是内容提供者？ 2.说说如何创建自己应用的内容提供者 &amp; 使用场景。 3.说说ContentProvider的原理。 4.ContentProvider,ContentResolver,ContentObserver之间的关系？ 5.说说ContentProvider的权限管理。 2.4 Service 1.什么是Service? 2.说说Service的生命周期。 3.Service和Thread的区别？ 4.Android 5.0以上的隐式启动问题及其解决方案。 5.给我说说Service保活方案 6.IntentService是什么 &amp; 原理 &amp; 使用场景 &amp; 和Service的区别。 7.创建一个独立进程的Service应该怎样做？ 8.Service和Activity之间如何通信？ 9.说说你了解的系统Service。 10.谈谈你对ActivityManagerService的理解。 11.在Activtiy中创建一个Thread和在一个Service中创建一个Thread的区别？ 2.5 Handler 1.子线程一定不能更新UI吗？ 2.给我说说Handler的原理 3.Handler导致的内存泄露你是如何解决的？ 4.如何使用Handler让子线程和子线程通信？ 5.你能给我说说Handler的设计原理？ 6.HandlerThread是什么 &amp; 原理 &amp; 使用场景？ 7.IdleHandler是什么？ 8.一个线程能否创建多个Handler,Handler和Looper之间的对应关系？ 9.为什么Android系统不建议子线程访问UI？ 10.Looper死循环为什么不会导致应用卡死？ 11.使用Handler的postDealy后消息队列有什么变化？ 12.可以在子线程直接new一个Handler出来吗？ 13.Message对象创建的方式有哪些 &amp; 区别？ 2.6 AsyncTask 1.AsyncTask是什么？能解决什么问题 2.给我谈谈AsyncTask的三个泛型参数作用 &amp; 它的一些方法作用。 3.给我说说AsyncTask的原理。 4.你觉得AsyncTask有不足之处吗？ 2.7 Fragment 1.Android中v4包下Fragment和app包下Fragment的区别是什么？ 2.Fragment的生命周期 &amp; 请结合Activity的生命周期再一起说说。 3.说说Fragment如何进行懒加载。 4.ViewPager + Fragment结合使用会出现内存泄漏吗 &amp; 如何解决？ 5.Fragment如何和Activity进行通信 &amp; Fragment之间如何进行通信？ 6.给我谈谈Fragment3种切换的方式以及区别 &amp; 使用场景。 7.getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？ 8.FragmentPagerAdapter和FragmentStatePagerAdapter区别？ 9.Fragment如何实现类似Activity栈的压栈和出栈效果的？ 2.8 序列化 1.什么是序列化 &amp; 能用来干什么？ 2.Android中序列化方式有几种？说说它们的区别。 3.如果想要序列化的类中某些字段不序列化，那么应该怎么做？ 2.9 IPC 1.说说你对Android多进程开发的认识？ 2.Android中进程间通信的方式有哪些？ 3.什么是AIDL?如何创建一个AIDL。 2.10 文件存储 1.说说Android中数据持久化的方式 &amp; 使用场景。 2.接触过MMKV吗？说说SharedPreference和它的区别。 3.第三方数据库框架用过哪些？有没有自己封装过一个SQLite的库？ 4.SQLite是线程安全的吗 &amp; SharedPreference是线程安全的吗？ 5.请简单的给我说说什么是三级缓存？ 6.SharedPreference的apply和commit的区别。 7.谈谈你对SQLite事务的认识。 8.千奇百怪的SQL语句考察。 9.SharePreference跨进程使用会怎么样？如何保证跨进程使用安全？ 10.谈谈SQLite升级要注意哪些地方？ 2.11 ListView &amp; RecyclerView 1.ListView是什么？如何使用？ 2.RecyclerView是什么？如何使用？如何返回不一样的Item。 3.ListView和RecycyclerView的区别是什么？ 4.分别讲讲你对ListView &amp; RecyclerView的优化经验。 5.给我说说RecyclerView的回收复用机制 6.说说你是如何给ListView &amp; RecyclerView加上拉刷新 &amp; 下拉加载更多机制。 7.谈谈你是如何对ListView &amp; RecycleView进行局部刷新的？ 8.谈谈如何进行分页加载？ 9.ScrollView下嵌套一个ListView通常会出现什么问题？ 10.一个ListView或者一个RecyclerView在显示新闻数据的时候，出现图片错位，可能的原因有哪些 &amp; 如何解决？ 2.12 图片编程 1.你对Bitmap了解吗？它在内存中如何存在？ 2.有关Bitmap导致OOM的原因知道吗？如何优化？ 3.给我谈谈图片压缩。 4.LruCache &amp; DiskLruCache原理。 5.说说你平常会使用的一些第三方图片加载库,最好给我谈谈它的原理。 6.如果让你设计一个图片加载库，你会如何设计？ 7.有一张非常大的图片,你如何去加载这张大图片？ 8.你知道Android中处理图片的一些库吗(OpenCv &amp; GPUImage …)？ 9.如何计算一张图片在内存中占用的大小？ 2.13 WebView 1.WebView是什么？ 2.WebView会导致内存泄露吗？原因是什么？解决方式有哪些？ 3.你知道Hybrid开发吗？说说你的相关经验。 4.说说WebSettings &amp; WebViewClient &amp; WebChromeClient这三个类的作用 &amp; 用法。 5.说说你了解的Hybrid框架。 2.14 ViewPager 1.什么是ViewPager?说说它的那些适配器。 2.你了解ViewPager2吗？和ViewPager 1有哪些区别？ 3.ViewPager + Fragment结合使用存在的内存泄漏的原因是什么？如何解决？ 2.15 View事件分发机制 1.什么是事件分发机制？主要用来解决什么问题？ 2.给我说说事件分发的流程 &amp; 你项目解决事件冲突的一些案例。 3.多点触摸事件平时接触过吗？如何监听用户第二个手指，第三个…？ 4.OnTouchListener &amp; OnTouchEvent &amp; onClickListener三者之间的关系？ 5.谈谈你对MotionEvent的认识？Cancel事件是什么情况下触发的？ 6.能给我谈谈Android中坐标体系吗？ 2.16 View绘制机制 1.说说View绘制流程。 2.说说Activity View树结构。 3.自定义View的方式有哪些?给我说说你之前项目中的案例。 4.invalidate和postvalidate的区别？ 5.说说你在自定义View时常常重写的一些方法？ 6.说说自定义View中如何自定义属性？ 7.requestLayout(),onLayout(),onDraw(),drawChild()区别和联系？ 8.如何计算出一个View的嵌套层级？ 9.自定义View如何考虑机型适配？ 2.17 布局 1.说说Android中有哪些布局 &amp; 特点。 2.你知道布局文件到控件对象的过程吗？ 3.有这么一个布局需求，一个文本控件放在屏幕一半的一半的中间位置，你如何进行布局？ 4.LinearLayout,FrameLayout,RelativeLayout性能对比，为什么？ 2.18 Binder 1.什么是Binder？用来干什么？ 2.给我具体讲讲Binder机制。 2.19 动画机制 1.Android中的动画分为哪些种类 &amp; 特点 &amp; 缺点。 2.知道SVG &amp; 矢量动画吗？ 3.给我说说转场动画。 4.给我谈谈插值器 &amp; 估值器 的作用。 5.说说Android动画框架实现的原理。 2.20 JNI 1.什么是JNI?它主要用来干什么。 2.Java Native方法如何和Native函数进行绑定的？ 3.JNI如何实现数据传递？ 4.如何全局捕获Native发生的异常？ 5.只有C/C++能编写Native库吗？ 2.21 Window &amp; Appliction &amp; Context 1.说说你对Android中Window的理解。 2.说说你对Application的理解 &amp; 生命周期。 3.Android中有哪些上下文 &amp; 区别 &amp; 作用。 4.谈谈你对Android中Context的理解。 2.22 通知 1.Android 8.0如何适配通知？ 2.自定义通知流程？ 2.23 对话框(Dialog &amp; DialogFragment &amp; PopWindow) 1.说说Android中对话框可以用哪些方式完成？ 2.24 蓝牙 1.说说最新的蓝牙版本？新版本的特性是什么？ 2.25 冷启动&amp;热启动 1.什么是冷启动 &amp; 什么是热启动 &amp; 它们的流程？ 2.如何优化冷启动？ 3.启动页白屏，黑屏，太慢如何解决？ 2.26 悬浮窗 1.在做悬浮窗的时候你遇到了什么困难(主要指悬浮窗权限适配)？ 2.如何制作一个悬浮窗？ 2.27 Android版本 1.最新的Android版本多少知道吗？有哪些特性 2.说说更新较大的Android版本。 2.28 Android Studio 1.你现在比较常用Android Studio那个版本 &amp; 用的Gradle版本是多少？ 2.如何理解gradle? 3.说说Android Studio中大致项目结构？ 4.混淆是什么 &amp; 为什么需要进行混淆 &amp; 混淆的原理 &amp; 为什么Java反射常常会和混淆冲突？ 2.29 UI卡顿优化 1.ANR是什么？导致原因有哪些？ 2.谈谈你项目中避免ANR的一些经验。 3.分别说说Activity &amp; BroadcastReceiver &amp; Serice最长可耗时时间为多少？ 2.30 内存优化 1.什么是OOM &amp; 什么是内存泄漏 &amp; 什么是内存抖动？ 2.谈谈你项目中内存优化的一些经验。 2.31 屏幕适配 1.说说Android中一些屏幕单位。 2.谈谈你项目中的一些屏幕适配的经验。 3.今日头条的轻量级适配方案了解吗 &amp; 给我说说原理。 2.32 多渠道打包 &amp; apk签名 1.apk为什么需要签名？ 2.多渠道打包是什么 &amp; 有类似经验吗？ 3.简述多渠道打包及原理和常用操作？ 2.33 项目架构 1.说说你用过的项目架构？ 2.分别给我说说MVC,MVP,MVVM特点和区别。 3.以登陆界面为例子,设计MVP架构。 4.谈谈AndroidManifest.xml文件的理解。 2.34 Android前沿知识 1.谷歌新出的Flutter知道吗？ 2.谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。 3.谈谈Kotlin中协程的认识？ 2.35 音视频开发(高薪) 1.之前有过音视频开发经验吗 &amp; 说说用哪些开源架子开发的。 2.FFmpeng了解过吗？ 3.Android中播放视频音频的方式有哪些？ 4.Android中播放网络地址视频有哪些出色的开源库？ 5.流媒体服务器了解吗？ 6.谈谈你对编码格式的理解。 7.MediaPlayer和SoundPool的区别？ 8.视频硬解码和软解码的区别？ 2.36 其它Android部分有关面试题 1.说说一个app的启动流程(从源码角度讲解)。 2.你知道无论是Kotlin或者是Java,程序运行的主要入口都是main()方法，那么Android的main方法在哪里？ 3.Android Hock技术了解吗？ 4.简述Android中的加固和使用平台？ 5.谈谈你对Apk瘦身的经验？ 6.为什么子线程不能更新UI？ 7.你知道如何定位内存泄漏吗？ 8.说说System.exit(0),onDestory(),Activity.finish()的区别？ 9.在OnResume或者之前获取View的宽高为多少 &amp; 为什么？ 10.Art &amp; Dvm 区别，特别是谈谈GC的区别。 11.说说你用的二维码框架 &amp; 有过优化经验吗？ 12.谈谈App多进程的好处 &amp; 缺点。 13.说说AMS是怎么找到启动指定的Activity？ 14.View的getWidth和getMeasureWidth有啥区别？ 15.有插件化或者热修复经验吗？说说它的原理。 16.断点续传了解吗？谈谈你是如何通过多线程实现断点续传的。 17.给我谈谈你对SurfaceView的认识。 18.什么情况下你会使用到ScrollView。 19.低版本SDK如何使用高版本API？ 20.AlertDialog,PopWindow,Activity之间的区别？ 21.Application和Activity,Context的区别？ 22.谈谈Android中多线程通信方式？ 23.说说Android大体的架构图，试着画出来。 24.知道SpareArray吗？ 25.Activity除了setContentView可以设置布局，还有其它方式吗？ 26.Android为每个应用程序分配的内存大小为多少？ 27.Android进程保活方案？ 28.谈谈Android系统安装apk的过程？ 29.Activity,Window,View三者的关系？ 30.ActivityThread,ActivityManagerService,WindowManagerService的工作原理？ 31.PackageManagerService的工作原理？ 32.PowerManagerService的工作原理？ 33.在桌面点击一个未启动的App的流程 &amp; 点击一个已启动的App的流程？ 34.Android中进程分为哪些种类？ 35.什么是埋点，懂点它的原理吗？ 36.进程和Application生命周期之间的关系？ 37.App相互唤醒的有哪些方式？ 38.Android中如何开启多进程？应用是否可以开启N个进程？ 39.谈谈消息推送的方式有哪些？ 40.谈谈你对Root权限的理解。 41.谈谈项目如何进行国际化？ 42.谈谈你对Intent和IntentFilter的理解。 43.一条最长的短信息约占多少byte？ 3.算法与数据结构部分3.1 复杂度分析 1.什么是时间复杂度 &amp; 什么是空间复杂度？ 2.时间复杂度和空间复杂度之间存在什么联系？ 3.2 数组 1.谈谈你对数组的理解。 3.3 链表 1.什么是单链表 &amp; 双向链表 &amp; 循环链表 &amp; 双向循环链表 &amp; 静态链表。 2.反转一个链表有哪些方式？ 3.如何判断链表有环？ 4.用Java语言设计一个LinkedList。 3.4 堆 1.如何理解堆？ 3.5 栈 1.什么是栈 &amp; 栈的特点是什么？ 2.什么是顺序栈 &amp; 链式栈？ 3.你有没有基于栈封装的业务类？ 4.你能用栈实现队列吗？ 5.如何实现浏览器前进和后退功能？ 3.6 队列 1.什么是队列 &amp; 队列的特点是什么？ 2.什么是优先队列？ 3.什么是双端队列 &amp; 阻塞队列? 4.你能用队列实现栈吗？ 3.7 散列表 1.什么是散列函数？ 2.什么是散列冲突？解决的方式有哪些？Java中的HashMap解决方式采用的哪一种？ 3.什么是散列表的动态扩容？ 4.什么是位图？ 3.8 树 1.什么是二叉树？ 2.什么是先序遍历 &amp; 中序遍历 &amp; 后序遍历。 3.什么是多路查找树？ 4.什么是红黑树？ 3.9 排序 1.给我说说你会的排序 &amp; 复杂度如何？ 2.现在有10万条数据需要进行排序，你会选择什么排序？ 3.10 查找 1.说说你知道的查找算法 &amp; 复杂度如何？ 3.11 递归&amp;回溯算法 1.什么是递归 &amp; 什么是回溯？ 3.12 贪心算法 1.什么是贪心算法？ 3.13 其它有关算法与数据结构的面试题 1.什么是图？可以解决一些什么问题？ 2.时针走一圈，时针分针重合几次？ 3.有一个不均匀的绳子烧完要1个小时，如何算出1小时15分钟？ 4.求1000以内的水仙花数以及40亿以内的水仙花数？ 5.数据怎么压缩，数据的安全。 6.谈谈你对对称加密 &amp; 非对称加密的理解。 4.常用的开源库部分4.1 异步通信 1.RxJava用法 &amp; RxJava2用法 &amp; 原理 &amp;用到的设计模式？ 2.EventBus用法 &amp; 原理。 4.2 网络 1.OkHttp用法 &amp; 源码分析。 2.Retrofit用法 &amp; 源码分析。 3.Volley用法 &amp; 缺点。 4.3 依赖注入 1.ButterKnife用法 &amp; 原理。 2.Dagger2用法 &amp; 原理。 4.4 图片加载 1.Glide用法 &amp; 原理。 2.Picasso用法 &amp; 原理。 3.Fresco用法 &amp; 原理。 4.5 数据库 1.GreenDao。 2.LitePal。 3.OrmLite。 4.DBFlow。 5.Realm。 4.6 其它 1.分享你觉得比较好用的开源库。 2.自己有封装库吗？给我说说你是如何设计的？ 3.你是如何设计一个网络请求框架的？ 5.计算机网络部分 1.给我介绍5层网络模型。 2.Http/Https协议工作在哪一层？ 3.TCP/UDP协议工作在哪一层？ 4.给我说说三次握手和四次挥手。 5.什么是请求头 &amp; 响应头 ? 说说请求头中一些重要的字段。 6.什么是Cookie &amp; Session。 7.知道什么是心跳检测吗？ 8.Http和Https的区别？ 9.加密协议TLS/SSL加密过程是怎样的？ 10.什么是DNS &amp; 作用是什么 &amp;工作机制？ 11.浏览器访问一个url网址所经历的过程是什么？ 12.Socket是协议吗？WebSocket是协议吗？它们的区别是什么？ 13.Json解析方式有哪些？比较它们的优劣势。 14.XML解析方式有哪些？比较它们的优劣势。 15.http1.x &amp; http 2.0区别是什么？ 16.说说HTTP缓存的原理。 17.如果有个100M大的文件，需要上传至服务器中，而服务器form表单最大只能上传2M,可以使用什么方法？ 18.说说你项目中即时通讯的方案有哪些？]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识间记，快速回顾各种知识]]></title>
    <url>%2Fposts%2F97843d21.html</url>
    <content type="text"><![CDATA[目录： 网络 Java 基础&amp;容器&amp;同步&amp;设计模式 Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理 Android 基础&amp;性能优化&amp;Framwork Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩 音视频&amp;FFmpeg&amp;播放器 网络网络协议模型应用层：负责处理特定的应用程序细节 HTTP、FTP、DNS 传输层：为两台主机提供端到端的基础通信TCP、UDP 网络层：控制分组传输、路由选择等IP 链路层：操作系统设备驱动程序、网卡相关接口 #### TCP 和 UDP 区别TCP 连接；可靠；有序；面向字节流；速度慢；较重量；全双工；适用于文件传输、浏览器等 全双工：A 给 B 发消息的同时，B 也能给 A 发 半双工：A 给 B 发消息的同时，B 不能给 A 发 UDP 无连接；不可靠；无序；面向报文；速度快；轻量；适用于即时通讯、视频通话等 TCP 三次握手 A：你能听到吗？ B：我能听到，你能听到吗？ A：我能听到，开始吧 A 和 B 两方都要能确保：我说的话，你能听到；你说的话，我能听到。所以需要三次握手 TCP 四次挥手 A：我说完了 B：我知道了，等一下，我可能还没说完 B：我也说完了 A：我知道了，结束吧 B 收到 A 结束的消息后 B 可能还没说完，没法立即回复结束标示，只能等说完后再告诉 A ：我说完了。 POST 和 GET 区别Get 参数放在 url 中；Post 参数放在 request Body 中 Get 可能不安全，因为参数放在 url 中 HTTPS HTTP 是超文本传输协议，明文传输；HTTPS 使用 SSL 协议对 HTTP 传输数据进行了加密 HTTP 默认 80 端口；HTTPS 默认 443 端口 优点：安全 缺点：费时、SSL 证书收费，加密能力还是有限的，但是比 HTTP 强多了 Java 基础&amp;容器&amp;同步&amp;设计模式StringBuilder、StringBuffer、+、String.concat 链接字符串： StringBuffer 线程安全，StringBuilder 线程不安全 +实际上是用 StringBuilder 来实现的，所以非循环体可以直接用 +，循环体不行，因为会频繁创建 StringBuilder String.concat 实质是 new String ，效率也低，耗时排序：StringBuilder &lt; StringBuffer &lt; concat &lt; + Java 泛型擦除 修饰成员变量等类结构相关的泛型不会被擦除 容器类泛型会被擦除 ArrayList、LinkedListArrayList 基于数组实现，查找快：o(1)，增删慢：o(n) 初始容量为10，扩容通过 System.arrayCopy 方法 LinkedList 基于双向链表实现，查找慢：o(n)，增删快：o(1) 封装了队列和栈的调用 HashMap 、HashTableHashMap 基于数组和链表实现，数组是 HashMap 的主体；链表是为解决哈希冲突而存在的 当发生哈希冲突且链表 size 大于阈值时会扩容，JAVA 8 会将链表转为红黑树提高性能允许 key/value 为 null HashTable 数据结构和 HashMap 一样 不允许 value 为 null 线程安全 ArrayMap、SparseArrayArrayMap 基于两个数组实现，一个存放 hash；一个存放键值对。扩容的时候只需要数组拷贝，不需要重建哈希表 内存利用率高 不适合存大量数据，因为会对 key 进行二分法查找（1000以下） SparseArray 基于两个数组实现，int 做 key 内存利用率高 不适合存大量数据，因为会对 key 进行二分法查找（1000以下） volatile 关键字 只能用来修饰变量，适用修饰可能被多线程同时访问的变量 相当于轻量级的 synchronized，volatitle 能保证有序性（禁用指令重排序）、可见性；后者还能保证原子性 变量位于主内存中，每个线程还有自己的工作内存，变量在自己线程的工作内存中有份拷贝，线程直接操作的是这个拷贝 被 volatile 修饰的变量改变后会立即同步到主内存，保持变量的可见性. 双重检查单例，为什么要加 volatile？ volatile想要解决的问题是，在另一个线程中想要使用instance，发现instance!=null，但是实际上instance还未初始化完毕这个问题 将instance =newInstance();拆分为3句话是。1.分配内存2.初始化3.将instance指向分配的内存空 volatile可以禁止指令重排序，确保先执行2，后执行3 wait 和 sleep sleep 是 Thread 的静态方法，可以在任何地方调用 wait 是 Object 的成员方法，只能在 synchronized 代码块中调用，否则会报 IllegalMonitorStateException 非法监控状态异常 sleep 不会释放共享资源锁，wait 会释放共享资源锁 lock 和 synchronized synchronized 是 Java 关键字，内置特性；Lock 是一个接口 synchronized 会自动释放锁；lock 需要手动释放，所以需要写到 try catch 块中并在 finally 中释放锁 synchronized 无法中断等待锁；lock 可以中断 Lock 可以提高多个线程进行读/写操作的效率 竞争资源激烈时，lock 的性能会明显的优于 synchronized 可重入锁 定义：已经获取到锁后，再次调用同步代码块/尝试获取锁时不必重新去申请锁，可以直接执行相关代码 ReentrantLock 和 synchronized 都是可重入锁 公平锁 定义：等待时间最久的线程会优先获得锁 非公平锁无法保证哪个线程获取到锁，synchronized 就是非公平锁 ReentrantLock 默认时非公平锁，可以设置为公平锁 乐观锁和悲观锁 悲观锁：线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁 乐观锁：假设没有冲突，不加锁，更新数据时判断该数据是否过期，过期的话则不进行数据更新，适用于读取操作频繁的场景 乐观锁 CAS：Compare And Swap，更新数据时先比较原值是否相等，不相等则表示数据过去，不进行数据更新 乐观锁实现：AtomicInteger、AtomicLong、AtomicBoolean 死锁 4 个必要条件 互斥 占有且等待 不可抢占 循环等待 synchronized 原理 每个对象都有一个监视器锁：monitor，同步代码块会执行 monitorenter 开始，motnitorexit 结束 wait/notify 就依赖 monitor 监视器，所以在非同步代码块中执行会报 IllegalMonitorStateException 异常 Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理JVM 定义：可以理解成一个虚构的计算机，解释自己的字节码指令集映射到本地 CPU 或 OS 的指令集，上层只需关注 Class 文件，与操作系统无关，实现跨平台 Kotlin 就是能解释成 Class 文件，所以可以跑在 JVM 上 JVM 内存模型 Java 多线程之间是通过共享内存来通信的，每个线程都有自己的本地内存 共享变量存放于主内存中，线程会拷贝一份共享变量到本地内存 volatile 关键字就是给内存模型服务的，用来保证内存可见性和顺序性 JVM 内存结构线程私有： 程序计数器：记录正在执行的字节码指令地址，若正在执行 Native 方法则为空 虚拟机栈：执行方法时把方法所需数据存为一个栈帧入栈，执行完后出栈 本地方法栈：同虚拟机栈，但是针对的是 Native 方法 线程共享： 堆：存储 Java 实例，GC 主要区域，分代收集 GC 方法会吧堆划分为新生代、老年代 方法区：存储类信息，常量池，静态变量等数据 GC回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收回收类型：1.堆中的对象 分代收集 GC 方法会吧堆划分为新生代、老年代 新生代：新建小对象会进入新生代；通过复制算法回收对象 老年代：新建大对象及老对象会进入老年代；通过标记-清除算法回收对象 2.方法区中的类信息、常量池 判断一个对象是否可被回收： 1.引用计数法缺点：循环引用 2.可达性分析法定义：从 GC ROOT 开始搜索，不可达的对象都是可以被回收的 GC ROOT 1.虚拟机栈/本地方法栈中引用的对象2.方法区中常量/静态变量引用的对象 四种引用 强引用：不会被回收 软引用：内存不足时会被回收 弱引用：gc 时会被回收 虚引用：无法通过虚引用得到对象，可以监听对象的回收 ClassLoader类的生命周期：1.加载；2.验证；3.准备；4.解析；5.初始化；6.使用；7.卸载 类加载过程： 1.加载：获取类的二进制字节流；生成方法区的运行时存储结构；在内存中生成 Class 对象2.验证：确保该 Class 字节流符合虚拟机要求3.准备：初始化静态变量4.解析：将常量池的符号引用替换为直接引用5.初始化：执行静态块代码、类变量赋值 类加载时机： 1.实例化对象2.调用类的静态方法3.调用类的静态变量（放入常量池的常量除外） 类加载器：负责加载 class 文件 分类： 1.引导类加载器 - 没有父类加载器2.拓展类加载器 - 继承自引导类加载器3.系统类加载器 - 继承自拓展类加载器 双亲委托模型： 当要加载一个 class 时，会先逐层向上让父加载器先加载，加载失败才会自己加载 为什么叫双亲？不考虑自定义加载器，系统类加载器需要网上询问两层，所以叫双亲 判断是否是同一个类时，除了类信息，还必须时同一个类加载器 优点： 防止重复加载，父加载器加载过了就没必要加载了 安全，防止篡改核心库类 动态代理原理及实现 InvocationHandler 接口，动态代理类需要实现这个接口 Proxy.newProxyInstance，用于动态创建代理对象 Retrofit 应用： Retrofit 通过动态代理，为我们定义的请求接口都生成一个动态代理对象，实现请求 Android 基础&amp;性能优化&amp;FramworkActivity 启动模式 standard 标准模式 singleTop 栈顶复用模式，* 推送点击消息界面 singleTask 栈内复用模式，* 首页 singleInstance 单例模式，单独位于一个任务栈中* 拨打电话界面细节：* taskAffinity：任务相关性，用于指定任务栈名称，默认为应用包名* allowTaskReparenting：允许转移任务栈 View 工作原理12345* DecorView (FrameLayout) * LinearLayout * titlebar * Content * 调用 setContentView 设置的 View ViewRoot 的 performTraversals 方法调用触发开始 View 的绘制，然后会依次调用: performMeasure：遍历 View 的 measure 测量尺寸 performLayout：遍历 View 的 layout 确定位置 performDraw：遍历 View 的 draw 绘制 #### 事件分发机制 一个 MotionEvent 产生后，按 Activity -&gt; Window -&gt; decorView -&gt; View 顺序传递，View 传递过程就是事件分发，主要依赖三个方法: dispatchTouchEvent：用于分发事件，只要接受到点击事件就会被调用，返回结果表示是否消耗了当前事件 onInterceptTouchEvent：用于判断是否拦截事件，当 ViewGroup 确定要拦截事件后，该事件序列都不会再触发调用此 ViewGroup 的 onIntercept onTouchEvent：用于处理事件，返回结果表示是否处理了当前事件，未处理则传递给父容器处理 细节： 一个事件序列只能被一个 View 拦截且消耗 View 没有 onIntercept 方法，直接调用 onTouchEvent 处理 OnTouchListener 优先级比 OnTouchEvent 高，onClickListener 优先级最低 requestDisallowInterceptTouchEvent 可以屏蔽父容器 onIntercet 方法的调用 Window 、 WindowManager、WMS、SurfaceFlinger Window：抽象概念不是实际存在的，而是以 View 的形式存在，通过 PhoneWindow 实现 WindowManager：外界访问 Window 的入口，内部与 WMS 交互是个 IPC 过程 WMS：管理窗口 Surface 的布局和次序，作为系统级服务单独运行在一个进程 SurfaceFlinger：将 WMS 维护的窗口按一定次序混合后显示到屏幕上 View 动画、帧动画及属性动画View 动画： * 作用对象是 View，可用 xml 定义，建议 xml 实现比较易读* 支持四种效果：平移、缩放、旋转、透明度 帧动画： * 通过 AnimationDrawable 实现，容易 OOM 属性动画： 可作用于任何对象，可用 xml 定义，Android 3 引入，建议代码实现比较灵活 包括 ObjectAnimator、ValuetAnimator、AnimatorSet 时间插值器：根据时间流逝的百分比计算当前属性改变的百分比 系统预置匀速、加速、减速等插值器 类型估值器：根据当前属性改变的百分比计算改变后的属性值 系统预置整型、浮点、色值等类型估值器 使用注意事项： 避免使用帧动画，容易OOM 界面销毁时停止动画，避免内存泄漏 开启硬件加速，提高动画流畅性 ，硬件加速： 将 cpu 一部分工作分担给 gpu ，使用 gpu 完成绘制工作 从工作分摊和绘制机制两个方面优化了绘制速度 Handler、MessageQueue、Looper Handler：开发直接接触的类，内部持有 MessageQueue 和 Looper MessageQueue：消息队列，内部通过单链表存储消息 Looper：内部持有 MessageQueue，循环查看是否有新消息，有就处理，没就阻塞 如何实现阻塞：通过 nativePollOnce 方法，基于 Linux epoll 事件管理机制 为什么主线程不会因为 Looper 阻塞：系统每 16ms 会发送一个刷新 UI 消息唤醒 MVC、MVP、MVVM MVP：Model：处理数据；View：控制视图；Presenter：分离 Activity 和 Model MVVM：Model：处理获取保存数据；View：控制视图；ViewModel：数据容器* 使用 Jetpack 组件架构的 LiveData、ViewModel 便捷实现 MVVM Serializable、Parcelable Serializable ：Java 序列化方式，适用于存储和网络传输，serialVersionUID 用于确定反序列化和类版本是否一致，不一致时反序列化回失败 Parcelable ：Android 序列化方式，适用于组件通信数据传递，性能高，因为不像 Serializable 一样有大量反射操作，频繁 GC Binder Android 进程间通信的中流砥柱，基于客户端-服务端通信方式 使用 mmap 一次数据拷贝实现 IPC，传统 IPC：用户A空间-&gt;内核-&gt;用户B空间；mmap 将内核与用户B空间映射，实现直接从用户A空间-&gt;用户B空间 BinderPool 可避免创建多 Service IPC 方式 Intent extras、Bundle：要求传递数据能被序列化，实现 Parcelable、Serializable ，适用于四大组件通信 文件共享：适用于交换简单的数据实时性不高的场景 AIDL：AIDL 接口实质上是系统提供给我们可以方便实现 BInder 的工具 Android Interface Definition Language，可实现跨进程调用方法 服务端：将暴漏给客户端的接口声明在 AIDL 文件中，创建 Service 实现 AIDL 接口并监听客户端连接请求 客户端：绑定服务端 Service ，绑定成功后拿到服务端 Binder 对象转为 AIDL 接口调用 RemoteCallbackList 实现跨进程接口监听，同个 Binder 对象做 key 存储客户端注册的 listener 监听 Binder 断开：1.Binder.linkToDeath 设置死亡代理；2. onServiceDisconnected 回调 Messenger：基于 AIDL 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信 ContentProvider：基于 Binder 实现，适用于一对多进程间数据共享 Socket：TCP、UDP，适用于网络数据交换 Android 系统启动流程 按电源键 -&gt; 加载引导程序 BootLoader 到 RAM -&gt; 执行 BootLoader 程序启动内核 -&gt; 启动 init 进程 -&gt; 启动 Zygote 和各种守护进程 -&gt; 启动 System Server 服务进程开启 AMS、WMS 等 -&gt; 启动 Launcher 应用进程 #### App 启动流程 Launcher 中点击一个应用图标 -&gt; 通过 AMS 查找应用进程，若不存在就通过 Zygote 进程 fork 进程保活 进程优先级：1.前台进程 ；2.可见进程；3.服务进程；4.后台进程；5.空进程 进程被 kill 场景：1.切到后台内存不足时被杀；2.切到后台厂商省电机制杀死；3.用户主动清理 保活方式： 1.Activity 提权：挂一个 1像素 Activity 将进程优先级提高到前台进程 2.Service 提权：启动一个前台服务（API&gt;18会有正在运行通知栏） 3.广播拉活 4.Service 拉活 5.JobScheduler 定时任务拉活 6.双进程拉活 网络优化及检测 速度：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；4.IP 直连省去 DNS 解析时间 成功率：1.失败重试策略； 流量：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；5.文件下载断点续传 ；6.缓存 协议层的优化，比如更优的 http 版本等 监控：Charles 抓包、Network Monitor 监控流量 UI卡顿优化 减少布局层级及控件复杂度，避免过度绘制 使用 include、merge、viewstub 优化绘制过程，避免在 Draw 中频繁创建对象、做耗时操作 内存泄漏场景及规避 1.静态变量、单例强引跟生命周期相关的数据或资源，包括 EventBus 2.游标、IO 流等资源忘记主动释放 3.界面相关动画在界面销毁时及时暂停 4.内部类持有外部类引用导致的内存泄漏* handler 内部类内存泄漏规避：1.使用静态内部类+弱引用 2.界面销毁时清空消息队列* 检测：Android Studio Profiler LeakCanary 原理 通过弱引用和引用队列监控对象是否被回收 比如 Activity 销毁时开始监控此对象，检测到未被回收则主动 gc ，然后继续监控 OOM 场景及规避 加载大图：减小图片 内存泄漏：规避内存泄漏 Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩Dalvik 和 ART Dalvik* 谷歌设计专用于 Android 平台的 Java 虚拟机，可直接运行 .dex 文件，适合内存和处理速度有限的系统* JVM 指令集是基于栈的；Dalvik 指令集是基于寄存器的，代码执行效率更优 ART* Dalvik 每次运行都要将字节码转换成机器码；ART 在应用安装时就会转换成机器码，执行速度更快* ART 存储机器码占用空间更大，空间换时间 APK 打包流程 1.aapt 打包资源文件生成 R.java 文件；aidl 生成 java 文件 2.将 java 文件编译为 class 文件 3.将工程及第三方的 class 文件转换成 dex 文件 4.将 dex 文件、so、编译过的资源、原始资源等打包成 apk 文件 5.签名 6.资源文件对齐，减少运行时内存 App 安装过程 首先要解压 APK，资源、so等放到应用目录 Dalvik 会将 dex 处理成 ODEX ；ART 会将 dex 处理成 OAT； OAT 包含 dex 和安装时编译的机器码 #### 组件化路由实现 ARoute：通过 APT 解析 @Route 等注解，结合 JavaPoet 生成路由表，即路由与 Activity 的映射关系 音视频&amp;FFmpeg&amp;播放器FFmpeg基于命令方式实现了一个音视频编辑 App： https://github.com/yhaolpz/FFmpegCmd 集成编译了 AAC、MP3、H264 编码器 播放器原理 视频播放原理：（mp4、flv）-&gt; 解封装 -&gt; （mp3/aac、h264/h265）-&gt; 解码 -&gt; （pcm、yuv）-&gt; 音视频同步 -&gt; 渲染播放 音视频同步：* 选择参考时钟源：音频时间戳、视频时间戳和外部时间三者选择一个作为参考时钟源（一般选择音频，因为人对音频更敏感，ijk 默认也是音频）* 通过等待或丢帧将视频流与参考时钟源对齐，实现同步 IjkPlayer 原理 集成了 MediaPlayer、ExoPlayer 和 IjkPlayer 三种实现，其中 IjkPlayer 基于 FFmpeg 的 ffplay 音频输出方式：AudioTrack、OpenSL ES；视频输出方式：NativeWindow、OpenGL ES]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter “保姆”级项目 Demo合集]]></title>
    <url>%2Fposts%2F60004316.html</url>
    <content type="text"><![CDATA[为啥叫“保姆”级项目，因为是真的贴心… flutter go https://github.com/alibaba/flutter-go GSY的 flutter 合集GSYFlutterDemo 作为简单示例和解决方案 Demo ，它可以给你学习和工作中提供一些便捷的帮助，比如 如何自定义布局，如何滚动控件到指定 child position ，如何调整 Text 控件的 Line Space ，如何监听键盘的弹出和收起 等等，所以例子方案都独立实现，方便阅读 CV 。 已有例子 Controller 例子 圆角 例子 滑动监听 例子 滑动到指定位置 例子 滑动到指定位置2 例子 Transform 例子 文本行间距 例子 多种下拉刷新 例子 绝对定位 例子 气泡提示框 例子 标签Wrap 例子 共享元素动画 例子 修改状态栏颜色 例子 系统键盘相关 例子 动画相关 例子 悬浮触摸控件 例子 全局字体大小 例子 富文本 例子 ViewPager 例子 滑动停靠 例子 验证码输入框 例子 自定义布局 例子 自定义布局云词图 例子 https://github.com/CarGuo/GSYFlutterDemo 除此之外，GSY 也对外输出了，实战系列博客： https://juejin.im/user/582aca2ba22b9d006b59ae68/posts 实战项目： https://github.com/CarGuo/GSYGithubAppFlutter Flutter NoteBookflutetr_note_book有许多flutter相关功能demo的集合，它能够帮助您快速学习一些零碎的知识，本项目将会不定期更新。 https://github.com/OpenFlutter/Flutter-Notebook 看介绍上写，原本作者计划是日更的，但是日更的压力太大了。 我曾经尝试过做这样的事情，后来还是觉得不需要给自己太大压力才好，比如：wanandroid 上面的每日一问，现在变成了每周 3 问。 想要坚持做一件事情，而且是没有明显收益的事情，还是保持一个合理的周期，不要影响到自己才行。 就像谈恋爱，天天觉得有压力，烦那就不长久了~ 好在作者并没有断更，希望作者能坚持更久，感谢。 flutter_app本项目包括各种基本控件使用（Text、TextField、Icon、Image、Listview、Gridview、Picker、Stepper、Dialog、Slider、Row、Appbar、Sizebox、BottomSheet、Chip、Dismissible、FlutterLogo、Check、Switch、TabBar、BottomNavigationBar、Sliver等）、豆瓣电影、每日一文、和天气、百姓生活、随机诗词、联系人、句子迷、好奇心日报等板块 这个项目比较大的特色，就是汇集了非常多的实战 app，那么你看到哪个页面效果就能去看看它的实现。 当然了，现在做具体 app 类似开源项目，最麻烦的就是开放 api 了，很多抓取的一方面不确定是否违规，另一方面极度不稳定，我以前经常推荐完整项目，但是经常过了一段时间就不能访问了。 所以，你们真要练手，不妨使用 wanandroid.com 的开放 API，网站多数接口和开放 API 是使用的相同的接口，除非这个网站挂了，否则 API 一直很稳定，数据也同步更新，也算我对外的一些付出啦。 https://github.com/shichunlei/flutter_app awesome-flutter类似于收集不错的 Flutter 库，工具，文章，实例等。 因为是国外开发者做的，所以关注的更多是国外的内容，所以和以上项目做互补还是非常不错的。 这个资源合集，分类非常细致，有入门，进阶；视频教程等等。 https://github.com/Solido/awesome-flutter 另外有一个小技巧，就是你想看什么方向技术的时候，果断用 awesome + 关键词 搜索。 awesome kotlin awesome android 学到了吧。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlutterPlugin开发流程]]></title>
    <url>%2Fposts%2Fb7213cdb.html</url>
    <content type="text"><![CDATA[这篇文章主要介绍了Flutter Plugin开发流程，包括如何利用Android Studio开发以及发布等。 今天这篇文章，给大家介绍如何开发Flutter Plugin中Android的部分。有关Flutter以及Flutter Plugin的概念，感兴趣的可以从官网查看相关资料。 简介笔者的环境是Mac下Android Studio进行的开发，AS也是谷歌官推的，安装flutter插件后，开发起来相对于其他IDE来说，方便很多，自带了三种模板： Flutter Application： Flutter应用 Flutter Plugin：Flutter插件 Flutter Package：纯Dart组件 Plugin其实就是一个特殊的Package。Flutter Plugin提供Android或者iOS的底层封装，在Flutter层提供组件功能，使Flutter可以较方便的调取Native的模块。很多平台相关性或者对于Flutter实现起来比较复杂的部分，都可以封装成Plugin。其原理如下 消息在client和host之间通过平台通道（platform channels）来进行的，之间的通讯都是异步的。 创建组件直接在Android Studio中新建一个Flutter Plugin的工程，当然也可以使用命令行来进行，例如创建一个flutter_text_plugin。 flutter create –org com.example –plugin flutter_text_plugin 如果想支持swift或者kotlin，可以用如下命令进行创建: flutter create –org com.example –plugin -i swift -a kotlin flutter_text_plugin 更多的参数选项，大家可以 查看帮助文档，当然还是比较推荐直接用AS进行创建，简单直观。用AS打开项目，可以看到项目的组织结构 123456root android example ios lib ... android以及ios文件夹是我们将要编写插件的native层的地方，lib文件夹是编写与native层映射的地方，native与flutter之间不能直接通信，必须通过MethodChannel来间接调用。example文件夹则是例子工程，编写的插件可以直接在这个项目中进行验证。在本文中，我们主要在android目录下进行，也就是android部分。 编写Android部分用AS打开flutter_text_plugin/android项目，这样子开发起来比较方便。但是打开过后，会发现出现了很多错误，提示找不到flutter相关的东西，我们仔细看这个项目，会发现跟我们平时用AS建的Android项目有所不同，少了很多部分，目录也有所不同。这是因为这个android项目不需要能够直接去运行，因此减少了很多东西。但是对于初次接触的人来说，可能是一头懵逼，例如该如何添加第三方库，如何添加proguard rule等等。 引入flutter库android插件工程是没有引入flutter库的，所以才会出现错误提示，我们在项目根目录建立一个libs文件夹，用来存放flutter库。 flutter库就在我们的flutter sdk中，路径如下 /bin/cache/artifacts/engine engine下面包含了各种平台的flutter库，我们随便拷贝一个Android平台的库到libs文件夹下，右键flutter.jar，弹出菜单选择Add As Library...。 经过这一步，项目中不会再报错了，但是，由于整个flutter plugin包含了flutter库，因此不能只是简单的添加就了事了，点击菜单Project Structure...，找到flutter_text_plugin的Dependencies中，将flutter库的Scope从Implementation改成Compile Only。至此，引入flutter库的工作完成了，可以进行插件的编写操作了。 添加第三方库添加第三方库有两种，一种是jar包引入，另一种通过gradle的方式进行。由于进行了第一步flutter库的引入，这一步就简单多了。查看build.gradle文件，可以看到最下面出现了如下的信息。 123dependencies &#123; compileOnly files('libs/flutter.jar')&#125; 看到这个，是不是就明朗多了，添加静态库以及添加在线库都可以在这个地方进行。例如我添加一个bugly静态库以及okhttp3库： 12345dependencies &#123; compileOnly files('libs/flutter.jar') implementation 'com.squareup.okhttp3:okhttp:3.10.0' implementation files('libs/bugly_crash_release.jar')&#125; 添加proguard rule由于了bugly以及okhttp3库，因此需要添加progurad rule。我们发现项目中没有proguard-rules.pro文件，因此这一步也需要我们自己去创建，在根目录下，建立proguard-rules.pro文件，将混淆规则添加进去，然后修改build.gradle文件，添加如下信息，跟普通Android项目差不多： 12345678910buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; debug &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; Android权限添加了bugly以及okhttp3库，需要对应的权限申明，才能正常运行。直接在manifest文件下，添加对应的权限 12345&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.READ_LOGS"/&gt; 插件开发至此，准备工作都已就绪，你可以把这个项目当做一个独立的Android项目，在上面进行各种封装操作，然后在FlutterTestPlugin文件下，将接口暴露出来。通过platform channels与flutter层关联起来。 发布当插件开发完毕，可以将插件发布让其他人使用，在发布之前，确保pubspec.yaml,、README.md以及CHANGELOG.md文件的内容都正确填写完毕。可以通过dry-run命令来看准备是否就绪。 flutter packages pub publish –dry-run 检查无误后，可以执行下面的命令，发布到Pub上。 flutter packages pub publish 如何引用对插件的引用有两种，已经发布的和未发布的。 引用发布的库flutter项目的很多资源管理都在根目录的pubspec.yaml下面，类似于js中的一些包管理一样，在dependencies加上我们需要引入的库，例如引入url_launcher库： 12dependencies: url_launcher: ^0.4.2 如果这个库包含了一些平台相关的东西，例如需要在native层进行使用的话，则需要在对应的native项目单独做引用。 Android修改android/build.gradle的dependencies处做引用： 123dependencies &#123; provided rootProject.findProject(":url_launcher") &#125; iOS修改ios/hello.podspec文件 123Pod::Spec.new do |s| # lines skipped s.dependency &apos;url_launcher&apos; 引用冲突引用不同的库可能会导致一些冲突，例如A和B两个插件，都包含了C插件，但是所需的版本不同。因此我们可以采取以下措施避免这种问题： 尽量使用范围版本而不是指定一个特定的版本。 强制统一冲突的插件版本 对于native层，android可以通过force命令强制指定版本，而iOS这边，Cocoapods则不支持引用的override功能。 引用未发布的库引用未发布的库有两种方式，通过本地路径和git地址的方式： 基于Path的引用方式：这种方式主要针对本地的未发布的库，引用的路径可以是相对或者绝对路径。 123dependencies: plugin1: path: ../plugin1/ 基于Git的引用方式：这种方式针对存放在git上的库，其中path是可选的，可以定位到某个子目录 12345dependencies: package1: git: url: git://github.com/flutter/packages.git path: packages/package1 后话笔者新建了一个flutter学习相关的项目，github地址，里面包含了笔者写的关于flutter学习相关的一些文章，后期也会定期更新，也会上传一些学习demo，欢迎大家关注。 参考 Flutter进阶—平台插件 Flutter - Creating a Plugin Flutter for Android Developers Writing custom platform-specific code with platform channels Developing Packages &amp; Plugins Using Packages]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter与Android的交互]]></title>
    <url>%2Fposts%2F5ae94dfd.html</url>
    <content type="text"><![CDATA[Flutter 说到底只是一个 UI 框架，很多功能都需要通过原生的 Api 来实现，那么就会涉及到 Flutter 和 Native 的交互，因为本人不懂 iOS 开发，所以只能讲下 Flutter 同 Android 的交互。 Android 项目配置 Flutter 依赖既然是互相交互，那么需要准备一个 Android 项目。接着就需要创建 flutter module，让 Android 项目依赖，创建的方法可以参考官网 Flutter Wiki，虽然是官网提供的方法，但是完全按照这个步骤来，还是会有坑的，这边就慢慢一步步解决坑。 如果你用的是 Android Studio 进行开发的话，直接打开底部的 Terminal，直接创建 flutter module 依赖 flutter create -t module flutter_native_contact 至于 module 名可以随意填写，module 创建完后结构大概是这样的 接着切换到 module 下的 .android 文件夹，接着有坑来了，官网提供的方法是 ./gradlew flutter:assembleDebug 可能会提示命令不存在，那么直接通过 gradlew flutter:assembleDebug 来运行，等它自动跑完后，打开根目录下的 settings.gradle 文件，加入官网提供的 gradle 代码 12345setBinding(new Binding([gradle: this])) // newevaluate(new File( // new settingsDir.parentFile, // new 'flutter_native_contact/.android/include_flutter.groovy' // new)) // new 你以为这里没坑，真是图样图森破，没坑是不可能的，编译器大爷可能会给你甩这么个错误 很明显可以看出是找不到我们的文件，所以把文件名路径给补全 1234evaluate(new File( // new settingsDir.parentFile, // new 'FlutterNativeContactDemo/flutter_native_contact/.android/include_flutter.groovy' // 这里补全路径)) 接着打开原有项目下，原有项目下，原有项目下的 app 中的 build.gradle 文件，在 android 下加上如下代码 1234compileOptions &#123; sourceCompatibility 1.8 targetCompatibility 1.8&#125; 这个必须要加，不要问为什么，我也不知道为什么，最后在项目下添加 flutter module 的依赖就完成了。这个过程告诉我们一个什么道理呢？*不要以为官网的都对，官网讲的也不是完全可信的，时不时给你来个坑就能卡你老半天。 原生界面加载 Flutter 页面那么如何在原生界面显示 Flutter 界面呢，这个就需要通过 FlutterView 来实现了，Flutter 这个类提供了 createView 和 createFragment 两个方法，分别用于返回 FlutterView 和 FlutterFragment 实例，FlutterFragment 的实现原理也是通过 FlutterView 来实现的，可以简单看下 FlutterFragment 的源码 1234567891011121314151617181920212223242526/** * A &#123;@link Fragment&#125; managing a &#123;@link FlutterView&#125;. * * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This file is auto-generated by Flutter tooling. * DO NOT EDIT.&lt;/p&gt; */public class FlutterFragment extends Fragment &#123; public static final String ARG_ROUTE = "route"; private String mRoute = "/"; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 获取传入的路由值，默认为 '/' if (getArguments() != null) &#123; mRoute = getArguments().getString(ARG_ROUTE); &#125; &#125; @Override public FlutterView onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // 最后还是挺过 createView 方法来生成页面，只不过直接放在 fragment， // 放在 fragment 会比直接 使用 FlutterView 更方便管理，例如实现 ViewPager 等 return Flutter.createView(getActivity(), getLifecycle(), mRoute); &#125;&#125; createFragment 方式加载在原生页面显示 Flutter 界面的第一种方式就是加载 FlutterFragment，看个比较简单的例子吧 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;!-- 这个布局用于加载 fragment --&gt; &lt;FrameLayout android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/flutter_fragment" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginEnd="20dp" android:layout_marginBottom="50dp" android:src="@drawable/ic_add_white_36dp" app:fabSize="auto" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 在 Activity 可以直接通过返回 FlutterFragment 加载到 FrameLayout 即可 1234567891011class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) supportFragmentManager.beginTransaction() .add(R.id.fragment_container, Flutter.createFragment("route_flutter")) .commit() &#125;&#125; 这样就把 Flutter 页面加载到原生界面了，会通过传递的路由值在 dart 层进行查找，所以接着就需要编写 Flutter 界面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/// runApp 内部值也可以直接传入 _buildWidgetForNativeRoute 方法/// 这边在外层嵌套一层 MaterialApp 主要是防止一些不必要的麻烦，/// 例如 MediaQuery 这方面的使用等void main() =&gt; runApp(FlutterApp());class FlutterApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: _buildWidgetForNativeRoute(window.defaultRouteName), debugShowCheckedModeBanner: false, theme: ThemeData( primaryColor: Color(0XFF008577), accentColor: Color(0xFFD81B60), primaryColorDark: Color(0xFF00574B), iconTheme: IconThemeData(color: Color(0xFFD81B60)), ), ); &#125;&#125;/// 该方法用于判断原生界面传递过来的路由值，加载不同的页面Widget _buildWidgetForNativeRoute(String route) &#123; switch (route) &#123; case 'route_flutter': return GreetFlutterPage(); // 默认的路由值为 '/'，所以在 default 情况也需要返回页面，否则 dart 会报错，这里默认返回空页面 default: return Scaffold(); &#125;&#125;class GreetFlutterPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('NativeMessageContactPage'), ), body: Center( child: Text( 'This is a flutter fragment page', style: TextStyle(fontSize: 20.0, color: Colors.black), ), ), ); &#125;&#125; 运行后可以看到页面加载出来了，不过会有一段时间的空白，这个在正式打包后就不会出现，所以不必担心。最后的页面应该是这样的 createView 方式加载接着看下 createView 方法，说白了，第一种方法最后还是会通过该方式实现 1234567891011121314151617181920212223242526272829303132333435@NonNullpublic static FlutterView createView(@NonNull final Activity activity, @NonNull final Lifecycle lifecycle, final String initialRoute) &#123; // 交互前的一些初始化工作，需要完成才可以继续下一步，同时需要保证当前线程为主线程 // Looper.myLooper() == Looper.getMainLooper()，否则会甩你一脸的 IllegalStateException FlutterMain.startInitialization(activity.getApplicationContext()); FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), null); final FlutterNativeView nativeView = new FlutterNativeView(activity); // 将 flutter 页面绑定到相应的 activity final FlutterView flutterView = new FlutterView(activity, null, nativeView) &#123; // ...... &#125;; // 将路由值传到 flutter 层，并加载相应的页面， if (initialRoute != null) &#123; flutterView.setInitialRoute(initialRoute); &#125; // 绑定 lifecycle，方便生命周期管理，同 activity 绑定 // 不熟悉 LifeCycle 的同学可以自行网上查找资料 lifecycle.addObserver(new LifecycleObserver() &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) public void onCreate() &#123; // 配置一些参数，传递到 flutter 层 final FlutterRunArguments arguments = new FlutterRunArguments(); arguments.bundlePath = FlutterMain.findAppBundlePath(activity.getApplicationContext()); arguments.entrypoint = "main"; // 最终会调用方法 nativeRunBundleAndSnapshotFromLibrary，这是一个 native 方法，进行交互 flutterView.runFromBundle(arguments); // 进行注册 GeneratedPluginRegistrant.registerWith(flutterView.getPluginRegistry()); &#125; // ...... &#125;); return flutterView;&#125; 通过 createView 方法返回的 FlutterView，通过设置 Layoutparams 参数就可以添加到相应的布局上，还有一种直接通过 addContentView 方式进行加载，这里直接修改原有代码， 1234567override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // setContentView(R.layout.activity_main) 不需要这一步了 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_flutter") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) // 直接加载到 activity 页面 &#125; 但是通过这样加载的话，那么整个页面都是 flutter 的页面。那么之前的效果的 FAB 则不会被加载出来了，即使没有省略 setContentView(R.layout.activity_main) 方法，这个页面的 xml 布局也会被覆盖。 PlantformChannel那么能够在原生界面显示 flutter 页面了，如何互相交互呢，这就需要通过 PlantformChannel 来执行了，PlantformChannel 主要有三种类型，BasicMessageChannel，MethodChannel，EventChannel。通过查看源码可以发现，三个 Channel 的实现机制类似，都是通过 BinaryMessenger 进行信息交流，每个 Channel 通过传入的 channel name 进行区分，所以在注册 Channel 的时候必须要保证 channel name 是唯一的，同时需要传入一个 BinaryMessageHandler 实例，用于传递信息的处理，当 Handler 处理完信息后，会返回一个 result，然后通过 BinaryMessenger 将 result 返回到 Flutter 层。如果需要深入理解这边推荐一篇文章深入理解Flutter PlatformChannel 接下来直接看例子吧，在创建 PlatformChannel 的时候需要传入一个 BinaryMessenger 实例，通过查看 FlutterView 的源码可以发现，FlutterView 就是一个 BinaryMessenger 在 Android 端的实现，所以呢，可以直接通过前面介绍的 Flutter.createView 方法获取注册 Channel 时的 BinaryMessenger 实例了，真是得来全部费工夫~因为通信的方法可能在多个界面会使用，所以还是封装一个通用类来处理会比较合理 BasicMessageChannel BasicMessageChannel 用于传递字符串和半结构化的信息。 123456789101112131415161718192021222324class FlutterPlugin(private val flutterView: FlutterView) :BasicMessageChannel.MessageHandler&lt;Any&gt;&#123; companion object &#123; private const val TAG = "FlutterPlugin" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; // channel name 需要保持两侧一致 val messageChannel = BasicMessageChannel(flutterView, Constant.MESSAGE_CHANNEL_NAME, StandardMessageCodec.INSTANCE) // MessageCodec 有多种实现方式，可以参考推荐的文章 val instance = FlutterPlugin(flutterView) messageChannel.setMessageHandler(instance) // 注册处理的 Hnadler return instance &#125; &#125; override fun onMessage(`object`: Any?, reply: BasicMessageChannel.Reply&lt;Any&gt;?) &#123; // 简单的将从 Flutter 传过来的消息进行吐司，同时返回自己的交互信息 // `object` 中包含的就是 Flutter 层传递过来的信息，reply 实例用于传递信息到 Flutter 层 Toast.makeText(flutterView.context, `object`.toString(), Toast.LENGTH_LONG).show() reply?.reply("\"Hello Flutter\"--- an message from Android") &#125;&#125; 接着就需要有个 FlutterView 用来注册，新建一个 Activity，用于加载 Flutter 页面 123456789101112131415161718class ContactActivity : AppCompatActivity() &#123; private lateinit var plugin: FlutterPlugin override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // 传入路由值，需要在 flutter 层生成相应的界面 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_contact") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) plugin = FlutterPlugin.registerPlugin(flutterView) &#125; override fun onDestroy() &#123; super.onDestroy() &#125;&#125; 那么我们就要在 Flutter 界面的 _buildWidgetForNativeRoute 方法加入新路由值对应的界面 12345678910111213141516171819202122232425262728293031323334353637Widget _buildWidgetForNativeRoute(String route) &#123; switch (route) &#123; // ... case 'route_contact': return FlutterContactPage(); default: return Scaffold(); &#125;&#125;class FlutterContactPage extends StatelessWidget &#123; // 注册对应的 channel，要保证 channel name 和原生层是一致的 final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Flutter Page'), ), // 简单放一个按钮，通过 channel 传输消息过去，同时将原生层返回的消息打印出来 body: RaisedButton( onPressed: () &#123; _messageChannel .send('"Hello Native" --- an message from flutter') .then((str) &#123; print('Receive message: $str'); &#125;); &#125;, child: Text('Send Message to Native'), ), ); &#125;&#125; 最后的效果小伙伴可以自行执行，点击按钮后会弹出吐司，吐司内容就是 Flutter 传递的信息，同时在控制台可以看到从原生层返回的信息。 MethodChannel MethodChannel 用于传递方法调用（method invocation） 直接在上述例子中进行修改，例如在 Flutter 页面中实现 Activity 的 finish 方法，并传递参数到前一个界面，先做 Flutter 页面的修改，在 AppBar 上增加一个返回按钮，用于返回上层页面 1234567891011121314151617181920212223242526272829303132class FlutterContactPage extends StatelessWidget &#123; // 注册对应的 channel，要保证 channel name 和原生层是一致的 final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); final MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: InkWell( child: Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Icon(Icons.arrow_back), ), onTap: () &#123; _methodChannel // invokeMethod 第一个值用于传递方法名，第二个值用于传递参数， // 这边简单的传递一个字符串，当然也可以传递别的类型，map，list 等等 .invokeMethod&lt;bool&gt;('finishActivity', 'Finish Activity') .then((result) &#123; // 这边会返回一个结果值，通过判断是否成功来打印不同的信息 print('$&#123;result ? 'has finish' : 'not finish'&#125;'); &#125;); &#125;, ), title: Text('Flutter Page'), ), body: // ... ); &#125;&#125; 同时，我们需要在 FlutterPlugin 这个类中，做些必要的修改，首先需要实现 MethodCallHandler 接口，该接口中需要实现 onMethodCall 方法，通过获取调用的方法名和参数值，进行相应的处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344class FlutterPlugin(private val flutterView: FlutterView) : MethodChannel.MethodCallHandler, BasicMessageChannel.MessageHandler&lt;Any&gt; &#123; companion object &#123; private const val TAG = "FlutterPlugin" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; val instance = FlutterPlugin(flutterView) val methodChannel = MethodChannel(flutterView, Constant.METHOD_CHANNEL_NAME) // ... messageChannel.setMessageHandler(instance) return instance &#125; &#125; // .... // call 中携带了 Flutter 层传递过来的方法名和参数信息 // 可以分别通过 call.method 和 call.arguments 来获取 override fun onMethodCall(call: MethodCall?, result: MethodChannel.Result?) &#123; when (call?.method) &#123; "finishActivity" -&gt; &#123; val activity = flutterView.context as Activity val info = call.arguments.toString() val intent = Intent().apply &#123; putExtra("info", info) &#125; activity.setResult(Activity.RESULT_OK, intent) activity.finish() // 成功时候通过 result.success 返回值， // 如果发生异常，通过 result.error 返回异常信息 // Flutter 通过 invokeMethod().then() 来处理正常结束的逻辑 // 通过 catchError 来处理发生异常的逻辑 result?.success(true) &#125; // 如果未找到对应的方法名，则通过 result.notImplemented 来返回异常 else -&gt; result?.notImplemented() &#125; &#125; 最终的效果，当点击返回按钮的时候，会将 Flutter 层通过 invokeMethod 传递的 arguments 属性吐司出来，同时，控制台会打印出 “has finish” 的信息 EventChannel EventChannel 用于数据流（event streams）的通信 EventChannel 的实现方式也类似，EventChannel 可以持续返回多个信息到 Flutter 层，在 Flutter 层的表现就是一个 stream，原生层通过 sink 不断的添加数据，Flutter 层接收到数据的变化就会作出新相应的处理。在 Android 端实现状态的监听可以通过广播来实现。直接看例子，还是修改上述代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class FlutterPlugin(private val flutterView: FlutterView) : MethodChannel.MethodCallHandler, EventChannel.StreamHandler, BasicMessageChannel.MessageHandler&lt;Any&gt; &#123; private var mStateChangeReceiver: BroadcastReceiver? = null companion object &#123; private const val TAG = "FlutterPlugin" const val STATE_CHANGE_ACTION = "com.demo.plugins.action.StateChangeAction" const val STATE_VALUE = "com.demo.plugins.value.StateValue" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; // ... val streamChannel = EventChannel(flutterView, Constant.STREAM_CHANNEL_NAME) val instance = FlutterPlugin(flutterView) methodChannel.setMethodCallHandler(instance) streamChannel.setStreamHandler(instance) messageChannel.setMessageHandler(instance) return instance &#125; &#125; // 实现 StreamHandler 需要重写 onListen 和 onCancel 方法 // onListen 不会每次数据改变就会调用，只在 Flutter 层，eventChannel 订阅广播 // 的时候调用，当取消订阅的时候则会调用 onCancel， // 所以当开始订阅数据的时候，注册接收数据变化的关闭， // 在取消订阅的时候，将注册的广播注销，防止内存泄漏 override fun onListen(argument: Any?, sink: EventChannel.EventSink?) &#123; mStateChangeReceiver = createEventListener(sink) flutterView.context.registerReceiver(mStateChangeReceiver, IntentFilter(STATE_CHANGE_ACTION)) &#125; override fun onCancel(argument: Any?) &#123; unregisterListener() &#125; // 在 activity 被销毁的时候，FlutterView 不一定会调用销毁生命周期，或者会延时调用 // 这就需要手动去注销一开始注册的广播了 fun unregisterListener() &#123; if (mStateChangeReceiver != null) &#123; flutterView.context.unregisterReceiver(mStateChangeReceiver) mStateChangeReceiver = null &#125; &#125; private fun createEventListener(sink: EventChannel.EventSink?): BroadcastReceiver = object : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; if (TextUtils.equals(intent?.action, STATE_CHANGE_ACTION)) &#123; // 这边广播只做简单的接收一个整数，然后通过 sink 传递到 Flutter 层 // 当然，sink 还有 error 方法，用于传递发生的错误信息， // 以及 endOfStream 方法，用于结束接收 // 在 Flutter 层分别有 onData 对应 success 方法，onError 对应 error 方法 // onDone 对应 endOfStream 方法，根据不同的回调处理不同的逻辑 sink?.success(intent?.getIntExtra(STATE_VALUE, -1)) &#125; &#125; &#125;&#125; 在 Flutter 层，通过对 stream 的监听，对返回的数据进行处理，为了体现出变化，这边修改成 SatefulWidget 来存储状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class FlutterContactPage extends StatefulWidget &#123; @override _FlutterContactPageState createState() =&gt; _FlutterContactPageState();&#125;class _FlutterContactPageState extends State&lt;FlutterContactPage&gt; &#123; final MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME); final EventChannel _eventChannel = EventChannel(STREAM_CHANNEL_NAME); final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); StreamSubscription _subscription; var _receiverMessage = 'Start receive state'; // 初始的状态值 @override void initState() &#123; super.initState(); // 当页面生成的时候就开始监听数据的变化 _subscription = _eventChannel.receiveBroadcastStream().listen((data) &#123; setState(() &#123; _receiverMessage = 'receive state value: $data'; // 数据变化了，则修改数据 &#125;); &#125;, onError: (e) &#123; _receiverMessage = 'process error: $e'; // 发生错误则显示错误信息 &#125;, onDone: () &#123; _receiverMessage = 'receive data done'; // 发送完毕则直接显示完毕 &#125;, cancelOnError: true); &#125; @override void dispose() &#123; super.dispose(); _subscription.cancel(); // 当页面销毁的时候需要将订阅取消，防止内存泄漏 &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: InkWell( child: Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Icon(Icons.arrow_back), ), onTap: () &#123; // MethodChannel demo _methodChannel .invokeMethod&lt;bool&gt;('finishActivity', _receiverMessage) .then((result) &#123; print('$&#123;result ? 'has finish' : 'not finish'&#125;'); &#125;).catchError((e) &#123; print('error happend: $e'); &#125;); &#125;, ), title: Text('Flutter Page'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(8.0), // EventChannel demo，页面直接显示信息的变化 child: Text( _receiverMessage, style: TextStyle(fontSize: 20.0, color: Colors.black), ), ), // BasicMessageChannel demo RaisedButton( onPressed: () &#123; _messageChannel .send('"Hello Native" --- an message from flutter') .then((str) &#123; print('Receive message: $str'); &#125;); &#125;, child: Text('Send Message to Native'), ), ], ), ), ); &#125;&#125; 同时，需要在 Activity 层调用一个定时任务不断的发送广播 12345678910111213141516171819202122232425262728293031323334353637383940class ContactActivity : AppCompatActivity() &#123; private var timer: Timer? = null private var task: TimerTask? = null private lateinit var random: Random private lateinit var plugin: FlutterPlugin override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) random = Random() // 生成随机整数 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_contact") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) plugin = FlutterPlugin.registerPlugin(flutterView) timer = Timer() // 定时器 task = timerTask &#123; // 定时任务 sendBroadcast(Intent(FlutterPlugin.STATE_CHANGE_ACTION).apply &#123; putExtra(FlutterPlugin.STATE_VALUE, random.nextInt(1000)) &#125;) &#125; timer?.schedule(task, 3000, 2000) // 延时 3s 开启定时器，并 2s 发送一次广播 &#125; override fun onDestroy() &#123; super.onDestroy() // 页面销毁的时候需要将定时器，定时任务销毁 // 同时注销 Plugin 中注册的广播，防止内存泄漏 timer?.cancel() timer = null task?.cancel() task = null plugin.unregisterListener() &#125;&#125; 最后的实现效果大概是这样的 Flutter 同 Android 端的交互到这讲的差不多了，和 iOS 的交互其实也类似，只不过在 Android 端通过 FlutterNativeView 来作为 Binarymessenger 的实现，在 iOS 端通过 FlutterBinaryMessenger 协议实现，原理是一致的。至于 Flutter 插件，其实现也是通过以上三种交互方式来实现的，可能我们目前通过 FlutterView 来作为 BinaryMessenger 实例，插件会通过 PluginRegistry.Registrar 实例的 messenger() 方法来获取 BinaryMessenger 实例。 最后贴上 demo 的地址：ContactDemo 需要了解插件的写法也可以直接查看官方提供的检测电量插件：Flutter Battery Plugin]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十四)之实战]]></title>
    <url>%2Fposts%2Fb447830c.html</url>
    <content type="text"><![CDATA[讲完了常用的部件和网络请求后，差不多该进入整体实战了，这里我们将写一个比较熟悉的项目，郭神的 cool weather。项目将使用 fluro 实现路由管理，dio 实现网络请求，rxdart 实现 BLoC 进行状态管理和逻辑分离，使用文件，shared_preferences，sqflite 实现本地的数据持久化。这边先给出项目的地址：flutter_weather，以及最后实现的效果图： One Two Three 除了 fluro 别的基本上前面都讲了，所以在开始正式的实战前，先讲下 fluro Flurofluro 是对 Navigator 的一个封装，方便更好的管理路由跳转，当然还存在一些缺陷，例如目前只支持传递字符串，不能传递中文等，但是这些问题都算不上是大问题。 fluro 的使用很简单，大概分如下的步骤： 在全局定义一个 Router 实例 1final router = Router(); 使用 Router 实例定义路径和其对应的 Handler 对象 123456789101112// 例如定义一个 CityPage 的路径和 HandlerHandler cityHandler = Handler(handlerFunc: (_, params) &#123; // 传递的参数都在 params 中，params 是一个 Map&lt;String, List&lt;String&gt;&gt; 类型参数 String cityId = params['city_id']?.first; return BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());&#125;);// 定义路由的路径和参数// 需要注意的是，第一个页面的路径必须为 "/"，别的可为 "/" + 任意拼接router.define('/city', handler: cityHandler);// 或者官方提供的另一种方式router.define('/city/:city_id', handler: cityHandler); 将 router 注册到 MaterialApp 的 onGenerateRoute 中 1MaterialApp(onGenerateRoute: router); 最后通过 Router 实例进行跳转，如果有参数传递则会在新的页面收到 123router.navigateTo(context, '/city?city_id=CN13579');// 或者官方的方式router.navigateTo(context, '/city/CN13579'); 在 fluro 中提供了多种路由动画，包括 fadeIn，inFromRight 等。讲完了使用，就进入实战了。 flutter_weather 实战导入插件在开始的时候，已经提到了整体功能的实现需求，所以这边需要导入的插件以及存放图片的文件夹如下： 12345678910111213141516171819202122dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2 fluro: ^1.4.0 dio: ^2.1.0 shared_preferences: ^0.5.1+2 sqflite: ^1.1.3 fluttertoast: ^3.0.3 rxdart: ^0.21.0 path_provider: 0.5.0+1dev_dependencies: flutter_test: sdk: flutter flutter: uses-material-design: true assets: - images/ 顶层静态实例的实现有许多实例需要在顶层注册，然后在全局使用，包括但不限于 fluro 的 router，http，database 等等。在这个项目中，需要用到的就是这三个实例，会在全局调用，所以在开始前进行初始化，当然 http 和 database 在使用的时候创建也可以，完全看个人习惯，但是 fluro 的管理类必须在一开始就注册完成。首先需要定义一个 Application 类用来存放这些静态实例 12345class Application &#123; static HttpUtils http; // 全局网络 static Router router; // 全局路由 static DatabaseUtils db; // 全局数据库&#125; 接着就是对相应方法类的编写，其中 HttpUtil 和 DatabaseUtils 在前面有讲过，这边不重复讲，会讲下数据库如何建立。 Fluro 路由管理类首先，需要知道，该项目的界面大概分如下的界面(当然可先只定义首页，剩下用到了再定义，该项目相对简单，所以先列出来)：省选择页，市选择页，区选择页，天气展示页，设置页。所以 fluro 的管理类可按如下定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 查看 `routers/routers.dart` 文件class Routers &#123; /// 各个页面对应的路径 static const root = '/'; static const weather = '/weather'; static const provinces = '/provinces'; static const cities = '/cities'; static const districts = '/districts'; static const settings = '/settings'; /// 该方法用于放到 `main` 方法中定义所有的路由， /// 对应的 handler 可放同一个文件，也可放另一个文件，看个人喜好 static configureRouters(Router router) &#123; router.notFoundHandler = notFoundHandler; router.define(root, handler: rootHandler); // 首页 router.define(weather, handler: weatherHandler); // 天气展示页 router.define(provinces, handler: provincesHandler); // 省列表页 router.define(cities, handler: citiesHandler); // 省下市列表页 router.define(districts, handler: districtsHandler); // 市下区列表页 router.define(settings, handler: settingsHandler); // 设置页 &#125; /// 生成天气显示页面路径，需要用到城市 id static generateWeatherRouterPath(String cityId) =&gt; '$weather?city_id=$cityId'; /// 生成省下的市列表页相应路径 需要用到省 id 及省名 static generateProvinceRouterPath(int provinceId, String name) =&gt; '$cities?province_id=$provinceId&amp;name=$name'; /// 生成市下的区列表页相应路径，需用到市 id 及市名 static generateCityRouterPath(int provinceId, int cityId, String name) =&gt; '$districts?province_id=$provinceId&amp;city_id=$cityId&amp;name=$name';&#125;/// 查看 `routers/handler.dart` 文件Handler notFoundHandler = Handler(handlerFunc: (_, params) &#123; Logger('RouterHandler:').log('Not Found Router'); // 当找不到相应的路由时，打印信息处理&#125;);Handler rootHandler = Handler(handlerFunc: (_, params) =&gt; SplashPage());Handler weatherHandler = Handler(handlerFunc: (_, params) &#123; String cityId = params['city_id']?.first; // 获取相应的参数 return WeatherPage(city: cityId);&#125;);Handler provincesHandler = Handler(handlerFunc: (_, params) =&gt; ProvinceListPage());Handler citiesHandler = Handler(handlerFunc: (_, params) &#123; String provinceId = params['province_id']?.first; String name = params['name']?.first; return CityListPage(provinceId: provinceId, name: FluroConvertUtils.fluroCnParamsDecode(name));&#125;);Handler districtsHandler = Handler(handlerFunc: (_, params) &#123; String provinceId = params['province_id']?.first; String cityId = params['city_id']?.first; String name = params['name']?.first; return DistrictListPage(provinceId: provinceId, cityId: cityId, name: FluroConvertUtils.fluroCnParamsDecode(name));&#125;);Handler settingsHandler = Handler(handlerFunc: (_, params) =&gt; SettingsPage()); 那么界面的路由到这就编写好了，但是前面提到了 fluro 目前不支持中文的传递，所以在传递中文时候，需要先进行转码，这边提供一个自己写的方法，小伙伴有更好的方法也可以直接在项目提 issue 123456789101112131415161718/// 查看 `utils/fluro_convert_util.dart` 文件class FluroConvertUtils &#123; /// fluro 传递中文参数前，先转换，fluro 不支持中文传递 static String fluroCnParamsEncode(String originalCn) &#123; StringBuffer sb = StringBuffer(); var encoded = Utf8Encoder().convert(originalCn); // utf8 编码，会生成一个 int 列表 encoded.forEach((val) =&gt; sb.write('$val,')); // 将 int 列表重新转换成字符串 return sb.toString().substring(0, sb.length - 1).toString(); &#125; /// fluro 传递后取出参数，解析 static String fluroCnParamsDecode(String encodedCn) &#123; var decoded = encodedCn.split('[').last.split(']').first.split(','); // 对参数字符串分割 var list = &lt;int&gt;[]; decoded.forEach((s) =&gt; list.add(int.parse(s.trim()))); // 转回 int 列表 return Utf8Decoder().convert(list); // 解码 &#125;&#125; Database 管理类编写因为数据库的开启是一个很耗资源的过程，所以这边通过单例并提取到顶层。在该项目中，数据库主要用于存储城市信息，因为城市之间的关联比较复杂，如果通过 shared_preferences 或者文件存储会很复杂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/// 查看 `utils/db_utils.dart` 文件class DatabaseUtils &#123; final String _dbName = 'weather.db'; // 数据表名 final String _tableProvinces = 'provinces'; // 省表 final String _tableCities = 'cities'; // 市表 final String _tableDistricts = 'districts'; // 区表 static Database _db; static DatabaseUtils _instance; static DatabaseUtils get instance =&gt; DatabaseUtils(); /// 将数据库的初始化放到私有构造中，值允许通过单例访问 DatabaseUtils._internal() &#123; getDatabasesPath().then((path) async &#123; _db = await openDatabase(join(path, _dbName), version: 1, onCreate: (db, version) &#123; db.execute('create table $_tableProvinces(' 'id integer primary key autoincrement,' 'province_id integer not null unique,' // 省 id，id 唯一 'province_name text not null' // 省名 ')'); db.execute('create table $_tableCities(' 'id integer primary key autoincrement,' 'city_id integer not null unique,' // 市 id，id 唯一 'city_name text not null,' // 市名 'province_id integer not null,' // 对应的省的 id，作为外键同省表关联 'foreign key(province_id) references $_tableProvinces(province_id)' ')'); db.execute('create table $_tableDistricts(' 'id integer primary key autoincrement,' 'district_id integer not null unique,' // 区 id 'district_name text not null,' // 区名 'weather_id text not null unique,' // 查询天气用的 id，例如 CN13579826，id 唯一 'city_id integer not null,' // 对应市的 id，作为外键同市表关联 'foreign key(city_id) references $_tableCities(city_id)' ')'); &#125;, onUpgrade: (db, oldVersion, newVersion) &#123;&#125;); &#125;); &#125; /// 构建单例 factory DatabaseUtils() &#123; if (_instance == null) &#123; _instance = DatabaseUtils._internal(); &#125; return _instance; &#125; /// 查询所有的省，`ProvinceModel` 为省市接口返回数据生成的 model 类 /// 查看 `model/province_model.dart` 文件 Future&lt;List&lt;ProvinceModel&gt;&gt; queryAllProvinces() async =&gt; ProvinceModel.fromProvinceTableList(await _db.rawQuery('select province_id, province_name from $_tableProvinces')); /// 查询某个省内的所有市 Future&lt;List&lt;ProvinceModel&gt;&gt; queryAllCitiesInProvince(String proid) async =&gt; ProvinceModel.fromCityTableList(await _db.rawQuery( 'select city_id, city_name from $_tableCities where province_id = ?', [proid], )); /// 查询某个市内的所有区，`DistrictModel` 为区接口返回数据生成的 model 类 /// 查看 `model/district_model.dart` 文件 Future&lt;List&lt;DistrictModel&gt;&gt; queryAllDistrictsInCity(String cityid) async =&gt; DistrictModel.fromDistrictTableList(await _db.rawQuery( 'select district_id, district_name, weather_id from $_tableDistricts where city_id = ?', [cityid], )); /// 将所有的省插入数据库 Future&lt;void&gt; insertProvinces(List&lt;ProvinceModel&gt; provinces) async &#123; var batch = _db.batch(); provinces.forEach((p) =&gt; batch.rawInsert( 'insert or ignore into $_tableProvinces (province_id, province_name) values (?, ?)', [p.id, p.name], )); batch.commit(); &#125; /// 将省对应下的所有市插入数据库 Future&lt;void&gt; insertCitiesInProvince(List&lt;ProvinceModel&gt; cities, String proid) async &#123; var batch = _db.batch(); cities.forEach((c) =&gt; batch.rawInsert( 'insert or ignore into $_tableCities (city_id, city_name, province_id) values (?, ?, ?)', [c.id, c.name, proid], )); batch.commit(); &#125; /// 将市下的所有区插入数据库 Future&lt;void&gt; insertDistrictsInCity(List&lt;DistrictModel&gt; districts, String cityid) async &#123; var batch = _db.batch(); districts.forEach((d) =&gt; batch.rawInsert( 'insert or ignore into $_tableDistricts (district_id, district_name, weather_id, city_id) values (?, ?, ?, ?)', [d.id, d.name, d.weatherId, cityid], )); batch.commit(); &#125;&#125; 定义完全局使用的方法，就可以在 main 函数中进行相关的初始化了 1234567891011121314151617181920212223242526272829303132/// 查看 `main.dart` 文件void main() &#123; // 初始化 fluro router Router router = Router(); Routers.configureRouters(router); Application.router = router; // 初始化 http Application.http = HttpUtils(baseUrl: WeatherApi.WEATHER_HOST); // 初始化 db Application.db = DatabaseUtils.instance; // 强制竖屏，因为设置竖屏为 `Future` 方法，防止设置无效可等返回值后再启动 App SystemChrome.setPreferredOrientations([DeviceOrientation.portraitDown, DeviceOrientation.portraitUp]).then((_) &#123; runApp(WeatherApp()); // App 类可放在同个文件，个人习惯单独一个文件存放 if (Platform.isAndroid) &#123; SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent)); &#125; &#125;);&#125;class WeatherApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Weather App', onGenerateRoute: Application.router.generator, // 将 fluro 的路由进行注册 debugShowCheckedModeBanner: false, ); &#125;&#125; 初始化完毕，接着就可以进行页面的编写了。 首页编写首页主要是为了对 App 的一个大概展示，或者是一些广告的展示，同时也给一些数据初始化提供时间，当用户进入后有更好的体验效果。我们在这里就做一个图标的展示(图标可自行到项目中 images 文件夹查找)，延时 5s 后跳转下个页面。 12345678910111213141516171819202122232425262728293031323334353637383940414243/// 查看 `splash_page.dart` 文件class SplashPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; /// 因为已经引入了 rxdart，这里通过 rxdart.timer 进行倒计时 /// 当然也可以使用 Futuer.delayed 进行倒计时 /// 5s 计时，如果已经选择城市，跳转天气界面，否则进入城市选择 Observable.timer(0, Duration(milliseconds: 5000)).listen((_) &#123; PreferenceUtils.instance.getString(PreferencesKey.WEATHER_CITY_ID) .then((city) &#123; // 如果当前还未选择城市，则进入城市选择页，否则跳转天气详情页 // replace: true 即为 Navigator.pushReplacement 方法 Application.router.navigateTo(context, city.isEmpty ? Routers.provinces : Routers.generateWeatherRouterPath(city), replace: true); &#125;); &#125;); return Scaffold( body: Container( alignment: Alignment.center, color: Colors.white, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 展示图标 Image.asset(Resource.pngSplash, width: 200.0, height: 200.0), // 展示文字提醒，用 SizedBox 设置区域大小 SizedBox( width: MediaQuery.of(context).size.width * 0.7, child: Text( '所有天气数据均为模拟数据，仅用作学习目的使用，请勿当作真实的天气预报软件来使用', textAlign: TextAlign.center, softWrap: true, style: TextStyle(color: Colors.red[700], fontSize: 16.0), )) ], ), ), ); &#125;&#125; 城市选择页面当首次进入的时候，用户肯定没有选择城市，所以先编写城市选择列表页面，因为整体的项目使用 BLoC 分离业务逻辑和页面，所以先编写数据管理类吧，把数据请求和改变的业务逻辑放到这块，BLoC 的实现在前面讲过了，这边就不重复提了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/// 查看 `provinces_bloc.dart` 文件class ProvincesBloc extends BaseBloc &#123; final _logger = Logger('ProvincesBloc'); List&lt;ProvinceModel&gt; _provinces = []; // 全国省 List&lt;ProvinceModel&gt; _cities = []; // 省内市 List&lt;DistrictModel&gt; _districts = []; // 市内区 List&lt;ProvinceModel&gt; get provinces =&gt; _provinces; List&lt;ProvinceModel&gt; get cities =&gt; _cities; List&lt;DistrictModel&gt; get districts =&gt; _districts; BehaviorSubject&lt;List&lt;ProvinceModel&gt;&gt; _provinceController = BehaviorSubject(); BehaviorSubject&lt;List&lt;ProvinceModel&gt;&gt; _citiesController = BehaviorSubject(); BehaviorSubject&lt;List&lt;DistrictModel&gt;&gt; _districtController = BehaviorSubject(); /// stream，用于 StreamBuilder 的 stream 参数 Observable&lt;List&lt;ProvinceModel&gt;&gt; get provinceStream =&gt; Observable(_provinceController.stream); Observable&lt;List&lt;ProvinceModel&gt;&gt; get cityStream =&gt; Observable(_citiesController.stream); Observable&lt;List&lt;DistrictModel&gt;&gt; get districtStream =&gt; Observable(_districtController.stream); /// 通知刷新省份列表 changeProvinces(List&lt;ProvinceModel&gt; provinces) &#123; _provinces.clear(); _provinces.addAll(provinces); _provinceController.add(_provinces); &#125; /// 通知刷新城市列表 changeCities(List&lt;ProvinceModel&gt; cities) &#123; _cities.clear(); _cities.addAll(cities); _citiesController.add(_cities); &#125; /// 通知刷新区列表 changeDistricts(List&lt;DistrictModel&gt; districts) &#123; _districts.clear(); _districts.addAll(districts); _districtController.add(_districts); &#125; /// 请求全国省 Future&lt;List&lt;ProvinceModel&gt;&gt; requestAllProvinces() async &#123; var resp = await Application.http.getRequest(WeatherApi.WEATHER_PROVINCE, error: (msg) =&gt; _logger.log(msg, 'province')); return resp == null || resp.data == null ? [] : ProvinceModel.fromMapList(resp.data); &#125; /// 请求省内城市 Future&lt;List&lt;ProvinceModel&gt;&gt; requestAllCitiesInProvince(String proid) async &#123; var resp = await Application.http .getRequest('$&#123;WeatherApi.WEATHER_PROVINCE&#125;/$proid', error: (msg) =&gt; _logger.log(msg, 'city')); return resp == null || resp.data == null ? [] : ProvinceModel.fromMapList(resp.data); &#125; /// 请求市内的区 Future&lt;List&lt;DistrictModel&gt;&gt; requestAllDistricts(String proid, String cityid) async &#123; var resp = await Application.http .getRequest('$&#123;WeatherApi.WEATHER_PROVINCE&#125;/$proid/$cityid', error: (msg) =&gt; _logger.log(msg, 'district')); return resp == null || resp.data == null ? [] : DistrictModel.fromMapList(resp.data); &#125; @override void dispose() &#123; // 及时销毁 _provinceController?.close(); _citiesController?.close(); _districtController?.close(); &#125;&#125; 写完 BLoC 需要对其进行注册，因为城市选择相对还是比较频繁的，所以可以放最顶层进行注册 12345678return BlocProvider( bloc: ProvincesBloc(), // 城市切换 BLoC child: MaterialApp( title: 'Weather App', onGenerateRoute: Application.router.generator, debugShowCheckedModeBanner: false, ), ); 城市选择就是一个列表，直接通过 ListView 生成即可，前面讲 ListView 的时候提到，尽可能固定 item 的高度，会提高绘制效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 查看 `provinces_page.dart` 文件class ProvinceListPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;ProvincesBloc&gt;(context); // 进入的时候先使用数据库的数据填充界面 Application.db.queryAllProvinces().then((ps) =&gt; _bloc.changeProvinces(ps)); // 网络数据更新列表并刷新数据库数据 _bloc.requestAllProvinces().then((provinces) &#123; _bloc.changeProvinces(provinces); Application.db.insertProvinces(provinces); &#125;); return Scaffold( appBar: AppBar( title: Text('请选择省份'), ), body: Container( color: Colors.black12, alignment: Alignment.center, // 省列表选择 child: StreamBuilder( stream: _bloc.provinceStream, initialData: _bloc.provinces, builder: (_, AsyncSnapshot&lt;List&lt;ProvinceModel&gt;&gt; snapshot) =&gt; !snapshot.hasData || snapshot.data.isEmpty // 如果当前的数据未加载则给一个加载，否则显示列表加载 ? CupertinoActivityIndicator(radius: 12.0) : ListView.builder( physics: BouncingScrollPhysics(), padding: const EdgeInsets.symmetric(horizontal: 12.0), itemBuilder: (_, index) =&gt; InkWell( child: Container( alignment: Alignment.centerLeft, child: Text(snapshot.data[index].name, style: TextStyle(fontSize: 18.0, color: Colors.black)), ), onTap: () =&gt; Application.router.navigateTo( context, // 跳转下层省内城市选择，需要将当前的省 id 以及省名传入 Routers. generateProvinceRouterPath(snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)), transition: TransitionType.fadeIn), ), itemExtent: 50.0, itemCount: snapshot.data.length), ), ), ); &#125;&#125; 对于市和区的列表选择也类似，除了最后的点击会有些区别页面的布局几乎一致，这边只提下点击事件 12345678910111213141516/// 查看 `cities_page.dart` 文件Application.router.navigateTo( context, // 跳转下层省内城市选择 Routers.generateProvinceRouterPath( snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)), transition: TransitionType.fadeIn), )// 设置为当前区，并清理路由 stack，并将天气界面设置到最上层onTap: () &#123; PreferenceUtils.instance .saveString(PreferencesKey.WEATHER_CITY_ID, snapshot.data[index].weatherId); Application.router.navigateTo(context, Routers.generateWeatherRouterPath(snapshot.data[index].weatherId), transition: TransitionType.inFromRight, clearStack: true); &#125;) 天气详情页面天气详情页面相对部件会多点，为了看着舒服一点，这里拆成多个部分来编写，在这之前还是先编写数据的管理类，因为天气详情接口返回的数据嵌套层次比较多，关系比较复杂，不适合用 database 来做持久化，所以这里采用文件持久化方式。当然有些小伙伴会问干嘛不使用 shared_preferences 来存储，理论上应该没有太大的问题，但是个人建议相对复杂的数据使用文件存储会相对比较好点，一定要说个为什么，我也说不出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/// 查看 `weather_bloc.dart` 文件class WeatherBloc extends BaseBloc &#123; final _logger = Logger('WeatherBloc'); WeatherModel _weather; // 天气情况 String _background = WeatherApi.DEFAULT_BACKGROUND; // 背景 WeatherModel get weather =&gt; _weather; String get background =&gt; _background; BehaviorSubject&lt;WeatherModel&gt; _weatherController = BehaviorSubject(); BehaviorSubject&lt;String&gt; _backgroundController = BehaviorSubject(); Observable&lt;WeatherModel&gt; get weatherStream =&gt; Observable(_weatherController.stream); Observable&lt;String&gt; get backgroundStream =&gt; Observable(_backgroundController.stream); /// 更新天气情况 updateWeather(WeatherModel weather) &#123; _weather = weather; _weatherController.add(_weather); &#125; /// 更新天气背景 updateBackground(String background) &#123; _background = background; _backgroundController.add(_background); &#125; // 请求天气情况 Future&lt;WeatherModel&gt; requestWeather(String id) async &#123; var resp = await Application.http .getRequest(WeatherApi.WEATHER_STATUS, params: &#123;'cityid': id, 'key': WeatherApi.WEATHER_KEY&#125;, error: (msg) =&gt; _logger.log(msg, 'weather')); // 请求数据成功则写入到文件中 if (resp != null &amp;&amp; resp.data != null) &#123; _writeIntoFile(json.encode(resp.data)); &#125; return WeatherModel.fromMap(resp.data); &#125; Future&lt;String&gt; requestBackground() async &#123; var resp = await Application.http .getRequest&lt;String&gt;(WeatherApi.WEATHER_BACKGROUND, error: (msg) =&gt; _logger.log(msg, 'background')); return resp == null || resp.data == null ? WeatherApi.DEFAULT_BACKGROUND : resp.data; &#125; // 获取存储文件路径 Future&lt;String&gt; _getPath() async =&gt; '$&#123;(await getApplicationDocumentsDirectory()).path&#125;/weather.txt'; // 写入到文件 _writeIntoFile(String contents) async &#123; File file = File(await _getPath()); if (await file.exists()) file.deleteSync(); file.createSync(); file.writeAsString(contents); &#125; // 文件读取存储信息，如果不存在文件则返回空字符串 ''，不推荐返回 null Future&lt;String&gt; readWeatherFromFile() async &#123; File file = File(await _getPath()); return (await file.exists()) ? file.readAsString() : ''; &#125; @override void dispose() &#123; _weatherController?.close(); _backgroundController?.close(); &#125;&#125; 天气详情的刷新只有当个页面，所以 BLoC 的注册值需要在路由上注册即可，在 fluro 对应 handler 中加入注册 1234Handler weatherHandler = Handler(handlerFunc: (_, params) &#123; String cityId = params['city_id']?.first; // 这个 id 可以通过 BLoC 获取也可以 return BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());&#125;); 那么接下来就可以编写界面了，先实现最外层的背景图变化 123456789101112131415161718192021222324252627282930313233343536373839/// 查看 `weather_page.dart` 文件class WeatherPage extends StatelessWidget &#123; final String city; WeatherPage(&#123;Key key, this.city&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;WeatherBloc&gt;(context); // 请求背景并更新 _bloc.requestBackground().then((b) =&gt; _bloc.updateBackground(b)); // 先读取本地文件缓存进行页面填充 _bloc.readWeatherFromFile().then((s) &#123; if (s.isNotEmpty) &#123; _bloc.updateWeather(WeatherModel.fromMap(json.decode(s))); &#125; &#125;); // 再请求网络更新数据 _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w)); return Scaffold( body: StreamBuilder( stream: _bloc.backgroundStream, initialData: _bloc.background, builder: (_, AsyncSnapshot&lt;String&gt; themeSnapshot) =&gt; Container( padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 20.0), alignment: Alignment.center, decoration: BoxDecoration( color: Colors.black12, image: DecorationImage( image: NetworkImage(themeSnapshot.data), fit: BoxFit.cover), ), child: // 具体内部布局通过拆分小部件实现 )), ); &#125;&#125; 页面最顶部是显示两个按钮，一个跳转城市选择，一个跳转设置页面，显示当前的城市 1234567891011121314151617181920212223242526272829class FollowedHeader extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; // snapshot 通过上层传入 FollowedHeader(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ // 城市选择页面跳转按钮 IconButton( icon: Icon(Icons.home, color: Colors.white, size: 32.0), onPressed: () =&gt; Application.router. navigateTo(context, Routers.provinces, transition: TransitionType.inFromLeft)), // 当前城市 Text('$&#123;snapshot.data.heWeather[0].basic.location&#125;', style: TextStyle(fontSize: 28.0, color: Colors.white)), // 设置页面跳转按钮 IconButton( icon: Icon(Icons.settings, color: Colors.white, size: 32.0), onPressed: () =&gt; Application.router .navigateTo(context, Routers.settings, transition: TransitionType.inFromRight)) ], ); &#125;&#125; 接着是当前的天气详情部分 1234567891011121314151617181920212223242526272829class CurrentWeatherState extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; CurrentWeatherState(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _now = snapshot.data.heWeather[0].now; var _update = snapshot.data.heWeather[0].update.loc.split(' ').last; return Column( crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ // 当前的温度 Text('$&#123;_now.tmp&#125;℃', style: TextStyle(fontSize: 50.0, color: Colors.white)), // 当前的天气状况 Text('$&#123;_now.condTxt&#125;', style: TextStyle(fontSize: 24.0, color: Colors.white)), Row( // 刷新的时间 mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ Icon(Icons.refresh, size: 16.0, color: Colors.white), Padding(padding: const EdgeInsets.only(left: 4.0)), Text(_update, style: TextStyle(fontSize: 12.0, color: Colors.white)) ], ) ], ); &#125;&#125; 接下来是一个天气预报的列表块，以为是一个列表，当然可以通过 Cloumn 来实现，但是前面有提到过一个列表「粘合剂」—- CustomScrollView，所以这里的整体连接最后会通过 CustomScrollView 来实现，那么你可以放心在最上层容器的 child 属性加上 CustomScrollView 了。接着来实现这块预报模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class WeatherForecast extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; WeatherForecast(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _forecastList = snapshot.data.heWeather[0].dailyForecasts; // 获取天气预报 return SliverFixedExtentList( delegate: SliverChildBuilderDelegate( (_, index) =&gt; Container( color: Colors.black54, // 外层设置背景色，防止被最外层图片背景遮挡文字 padding: const EdgeInsets.all(12.0), alignment: Alignment.centerLeft, child: index == 0 // 当第一个 item 情况，显示 ‘预报’ ? Text('预报', style: TextStyle(fontSize: 24.0, color: Colors.white)) : Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Text(_forecastList[index - 1].date, // 预报的日期 style: TextStyle(fontSize: 16.0, color: Colors.white)), Expanded( // 天气情况，这边通过 expanded 进行占位，并居中显示 child: Center(child: Text(_forecastList[index - 1].cond.txtD, style: TextStyle(fontSize: 16.0, color: Colors.white))), flex: 2), Expanded( child: Row( // 最高温度，最低温度 mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Text(_forecastList[index - 1].tmp.max, style: TextStyle(fontSize: 16.0, color: Colors.white)), Text(_forecastList[index - 1].tmp.min, style: TextStyle(fontSize: 16.0, color: Colors.white)), ], ), flex: 1) ], )), childCount: _forecastList.length + 1, // 这个数量需要 +1，因为有个标题需要一个数量 ), itemExtent: 50.0); &#125;&#125; 接着是空气质量报告，一个标题，下面由两个布局进行平分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class AirQuality extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; AirQuality(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var quality = snapshot.data.heWeather[0].aqi.city; return Container( padding: const EdgeInsets.all(12.0), color: Colors.black54, alignment: Alignment.centerLeft, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 标题 Padding(padding: const EdgeInsets.only(bottom: 20.0), child: Text('空气质量', style: TextStyle(fontSize: 24.0, color: Colors.white))), Row( children: &lt;Widget&gt;[ // 通过 expanded 进行平分横向距离 Expanded( child: Center( // 内部居中显示 child: Column( children: &lt;Widget&gt;[ Text('$&#123;quality.aqi&#125;', style: TextStyle(fontSize: 40.0, color: Colors.white)), Text('AQI 指数', style: TextStyle(fontSize: 20.0, color: Colors.white)), ], ), )), Expanded( child: Center( child: Column( children: &lt;Widget&gt;[ Text('$&#123;quality.pm25&#125;', style: TextStyle(fontSize: 40.0, color: Colors.white)), Text('PM2.5 指数', style: TextStyle(fontSize: 20.0, color: Colors.white)), ], ), )), ], ) ], )); &#125;&#125; 接下来是生活质量模块，看着也是个列表，但是后台返回的不是列表，而是根据不同字段获取不同质量指数，因为布局类似，所以可以对其进行封装再整体调用 12345678910111213141516171819202122232425262728293031class LifeSuggestions extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; LifeSuggestions(&#123;Key key, this.snapshot&#125;) : super(key: key); // 生活指数封装 Widget _suggestionWidget(String content) =&gt; Padding(padding: const EdgeInsets.only(top: 20.0), child: Text(content, style: TextStyle(color: Colors.white, fontSize: 16.0))); @override Widget build(BuildContext context) &#123; var _suggestion = snapshot.data.heWeather[0].suggestion; return Container( padding: const EdgeInsets.all(12.0), color: Colors.black54, alignment: Alignment.centerLeft, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('生活建议', style: TextStyle(fontSize: 24.0, color: Colors.white)), _suggestionWidget('舒适度：$&#123;_suggestion.comf.brf&#125;\n$&#123;_suggestion.comf.txt&#125;'), _suggestionWidget('洗车指数：$&#123;_suggestion.cw.brf&#125;\n$&#123;_suggestion.cw.txt&#125;'), _suggestionWidget('运动指数： $&#123;_suggestion.sport.brf&#125;\n$&#123;_suggestion.sport.txt&#125;'), ], ), ); &#125;&#125; 所有的分模块都已经编写完成，剩下就是通过粘合剂进行组装了 12345678910111213141516171819202122232425262728293031323334child: StreamBuilder( initialData: _bloc.weather, stream: _bloc.weatherStream, builder: (_, AsyncSnapshot&lt;WeatherModel&gt; snapshot) =&gt; !snapshot.hasData ? CupertinoActivityIndicator(radius: 12.0) : SafeArea( child: RefreshIndicator( child: CustomScrollView( physics: BouncingScrollPhysics(), slivers: &lt;Widget&gt;[ SliverToBoxAdapter(child: FollowedHeader(snapshot: snapshot)), // 实时天气 SliverPadding( padding: const EdgeInsets.symmetric(vertical: 30.0), sliver: SliverToBoxAdapter( child: CurrentWeatherState(snapshot: snapshot, city: city), ), ), // 天气预报 WeatherForecast(snapshot: snapshot), // 空气质量 SliverPadding( padding: const EdgeInsets.symmetric(vertical: 30.0), sliver: SliverToBoxAdapter(child: AirQuality(snapshot: snapshot)), ), // 生活建议 SliverToBoxAdapter(child: LifeSuggestions(snapshot: snapshot)) ], ), onRefresh: () async &#123; _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w)); return null; &#125;), )), 最后就剩下设置页的全局主题切换了 设置页全局主题切换既然提到了数据的切换，那肯定就涉及 BLoC 毫无疑问了，还是照常编写管理类 12345678910111213141516171819202122232425/// 查看 `setting_bloc.dart` 文件class SettingBloc extends BaseBloc &#123; /// 所有主题色列表 static const themeColors = [Colors.blue, Colors.red, Colors.green, Colors.deepOrange, Colors.pink, Colors.purple]; Color _color = themeColors[0]; Color get color =&gt; _color; BehaviorSubject&lt;Color&gt; _colorController = BehaviorSubject(); Observable&lt;Color&gt; get colorStream =&gt; Observable(_colorController.stream); /// 切换主题通知刷新 switchTheme(int themeIndex) &#123; _color = themeColors[themeIndex]; _colorController.add(_color); &#125; @override void dispose() &#123; _colorController?.close(); &#125;&#125; 因为是全局的切换，那么这个 BLoC 肯定需要在最顶层进行注册，这边就不贴代码了，同 ProvinceBloc 一致。接着编写界面，设置界面因为有 GridView 和其他部件，所以也需要用 CustomScrollView 作为粘合剂，当然，你也可以用 Wrap 代替 GridView 来实现网格，就不需要用 CustomScrollView，使用 Column 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class SettingsPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;SettingBloc&gt;(context); return StreamBuilder( stream: _bloc.colorStream, initialData: _bloc.color, // Theme 是 Flutter 自带的一个设置主题的部件，里面可以设置多种颜色， // 通过接收到 color 的变化，改变主题色，其他页面也如此设置，小伙伴可以自己添加 builder: (_, AsyncSnapshot&lt;Color&gt; snapshot) =&gt; Theme( // IconThemeData 用于设置按钮的主题色 data: ThemeData(primarySwatch: snapshot.data, iconTheme: IconThemeData(color: snapshot.data)), child: Scaffold( appBar: AppBar( title: Text('设置'), ), body: Container( color: Colors.black12, padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 20.0), child: CustomScrollView( slivers: &lt;Widget&gt;[ SliverPadding( padding: const EdgeInsets.only(right: 12.0), sliver: SliverToBoxAdapter( child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Text('当前主题色：', style: TextStyle(fontSize: 16.0, color: snapshot.data)), Container(width: 20.0, height: 20.0, color: snapshot.data) ], )), ), SliverPadding(padding: const EdgeInsets.symmetric(vertical: 15.0)), SliverGrid( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Container(color: SettingBloc.themeColors[index]), onTap: () &#123; // 选择后进行保存，当下次进入的时候直接使用该主题色 // 同时切换主题色 _bloc.switchTheme(index); PreferenceUtils.instance.saveInteger(PreferencesKey.THEME_COLOR_INDEX, index); &#125;, ), childCount: SettingBloc.themeColors.length), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3, mainAxisSpacing: 20.0, crossAxisSpacing: 20.0)), ], ), ), ), )); &#125;&#125; 最终全局的主题切换也实现了。 编写完代码，需要打包啊，Android 下的打包大家肯定没问题，这里讲下 flutter 下如何打包 apk，ipa 因为没有 mac 所以你们懂的。 apk 文件打包 创建 jks 文件，如果已经存在可忽略这步从第二步开始。打开终端并输入 keytool -genkey -v -keystore [你的签名文件路径].jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 然后输入密码以及一些基本信息就可以创建成功了 在项目的 android 目录下创建一个 key.properties 文件，里面进行如下配置 1234storePassword=&lt;password from previous step&gt;keyPassword=&lt;password from previous step&gt;keyAlias=keystoreFile=&lt;[你的签名文件路径].jks&gt; 在 android/app 下的 build.gradle 中进行如下修改 123456789101112131415161718192021222324252627apply from: "$flutterRoot/packages/flutter_tools/gradle/flutter.gradle" // 增加如下部分代码def keystorePropertiesFile = rootProject.file("key.properties")def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile))android &#123; // ... defaultConfigs&#123; // ... &#125; // 增加如下代码 signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125; &#125; buildTypes&#123; // ... &#125;&#125; 再次打开终端运行 flutter build apk 会自动生成一个 apk 文件，文件路径为 [你的项目地址]\build\app\outputs\apk\release 通过 flutter install 就可以将正式包运行到手机上]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十三)之网络]]></title>
    <url>%2Fposts%2Fd9e32c9b.html</url>
    <content type="text"><![CDATA[前面讲完了常用的部件，BLoC 模式，数据持久化等常用的，今天再介绍个重头戏 —— 网络请求 HttpClientHttpClient 是 dart 自带的网络请求方式，在 dart:io 包下。使用 HttpClient 作为请求分以下几个步骤 创建 HttpClient 实例 1HttpClient client = HttpClient(); 打开连接，并设置一些头参数，请求参数等 123456789101112// 如果 url 中没有查询参数可直接创建Uri uri = Uri.parse('https://www.xxx.com');// 如果存在查询参数则在 Uri 中添加Uri uri = Uri(scheme: 'https', host: 'www.xxx.com', queryParameters: &#123;'a': 'AAA'&#125;);// 打开连接HttpClientRequest request = await client.getUrl(uri);request.headers.add('token', 'Bear $&#123;'x' * 20&#125;'); // 添加头部 token 信息// 如果是 post 或者 put 请求，通过 `add` 添加请求体// 因为 `add` 方法需要传入 `List&lt;int&gt;` 参数，可以通过 utf8.encode 进行编码request.add(utf8.encode('&#123;"a": "aaa"&#125;'));// 也可以通过添加流的方式进行添加request.addStream(input); 连接服务器 123// 设置 request 后通过 request.close() 获取一个响应对象 HttpClientResponse，// 包括响应头，响应内容等HttpClientResponse response = await request.close(); 读取服务器响应内容 1String responseBody = await response.transform(utf8.decoder).join(); 关闭实例 1client.close(); 例如我们要去请求 Bird.so 的首页并显示，我们可以这么实现 12345678910111213141516_httpClientRequest() async &#123; HttpClient client; // try catch finally 用于捕获请求过程中发生的异常，在 finally 中设置保证 client 能够关闭 try &#123; client = HttpClient(); HttpClientRequest request = await client.getUrl(Uri.parse(_BIRD_SO_URL)); HttpClientResponse response = await request.close(); String strResponse = await response.transform(utf8.decoder).join(); setState(() =&gt; _netBack = strResponse); &#125; catch (e) &#123; print('$&#123;e.toString()&#125;'); setState(() =&gt; _netBack = 'Fail'); &#125; finally &#123; client.close(); &#125; &#125; 最后实现的效果 很显然，用 HttpClient 请求相对来说是个非常麻烦的过程，如果要涉及到文本上传之类的，那么就会更麻烦了，所以这边引入一个网络请求的插件 dio，写本文的时候版本为 2.1.0 Diodio 是个非常强大的网络请求库，他的方式类似 OkHttp，我们可以直接查看官方文档，使用方式非常简单，创建一个 Dio 实例，然后就可以通过 get，post 等方式发起请求，返回 Future&lt;Response&gt;，而且支持多个并发请求，可以设置返回响应的类型，监听上传下载进度等等，看着就很给力。对于简单的方式，这边就不做太多介绍，主要讲下拦截器，也是非常给力的一部分。比如我们需要请求这么个接口 https://randomuser.me/api/ 这个接口通过 get 请求，可以加入任意的查询参数。比如我们需要实现一个请求加解密的过程，如果每次都在上传参数或者返回请求的时候去加密，解密的话，就做了非常多无用功了，那么这时候拦截器就派上用场了。先定义下加解密的规则，上传的参数统一转为小写，不存在大写，请求回的数据，不能含有 info 字段。看下如何实现 123456789101112131415161718192021222324252627282930313233_dioRequest() async &#123; BaseOptions options = BaseOptions(connectTimeout: 5000, receiveTimeout: 60000); Dio dio = Dio(options); dio.interceptors.add(InterceptorsWrapper(onRequest: (opt) &#123; // 获取查询的参数 Map params = opt.queryParameters; // 将所有的参数转为小写，因为查询参数通过 map 形式上传 params.forEach((key, value) =&gt; opt.queryParameters[key] = '$value'.toLowerCase()); // 这边还可以做些别的操作，例如需要 token 进行用户身份验证，则通过头部进行添加 // opt.headers['authorization'] = 'token'; // 在官网中，提供了 lock 和 unlock 的写法，被 lock 后，接下来的请求会进入队列等待， // 直到 unlock 后才能继续，可以用于几个请求，后续的需要用到前面的返回值的情况使用 // 返回修改后的 RequestOptions return opt; &#125;, onResponse: (resp) &#123; // 返回响应体后，将 info 字段的内容切除，并将 json 拼接完成 resp.data = '$&#123;'$&#123;resp.data&#125;'.split(', info').first&#125;&#125;'; return resp; &#125;, onError: (error) &#123; // 发生错误时的回调 return error; &#125;)); // 发送一个请求，可以查看下打印的结果 Response response = await dio.get(_USER_ME_URL, queryParameters: &#123;'a': 'AAA', 'b': 'BbBbBb'&#125;); print(response.data); print(response.request.headers); print(response.request.queryParameters); setState(() =&gt; _netBack = response.data.toString()); // 界面显示 response.data &#125; 看下最后的显示信息 请求体的头部成功加上了 authorization 参数，请求的参数全部变为小写，返回的信息也把 info 字段值去除。在很多时候，请求接口后，需要将 json 转换成 pojo 类来处理，可以通过 json_serializable 这个三方插件实现，这边提供文章 Flutter Json自动反序列化，当然这种方式比较麻烦，这里推荐个 Android Studio 下的插件 dart_json_format 直接搜索就可以，如果用的是 Vitual Code 或者别的不是 JetBrains 系列的，这里有个转换的网址 JsonToDart。 以上代码查看 http_main.dart 文件 实践一下下不知道小伙还记得前面讲的 BLoC 没有，忘了可以查看 Flutter 状态管理及 BLoC，这里结合 BLoC 和 Dio 实现界面和逻辑分离的小例子，接口使用前面提到的 https://randomuser.me/api/ 接口。网络应该是比较常用的，所以对其进行一些封装还是很有必要的，这边提供下我自己封装的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import 'package:dio/dio.dart';// 用于错误信息回调typedef ErrorCallback = void Function(String msg);class HttpUtils &#123; static const GET = 'get'; static const POST = 'post'; static Dio _dio; static HttpUtils _instance; Dio get hp =&gt; _dio; // dio 可以在 BaseOptions 中指定域名 baseUrl， // 后续接口就不需要再添加域名了 // 如果请求的接口域名发生了变化，只要把全部 url 写全，就会自动使用新的域名 HttpUtils._internal(String base) &#123; // 生成一个单例，防止多次打开关闭造成开销 _dio = Dio(BaseOptions(baseUrl: base, connectTimeout: 10000, receiveTimeout: 10000)); &#125; factory HttpUtils(String base) &#123; if (_instance == null) _instance = HttpUtils._internal(base); return _instance; &#125; // 添加拦截器 addInterceptor(List&lt;InterceptorsWrapper&gt; interceptors) &#123; _dio.interceptors.clear(); _dio.interceptors.addAll(interceptors); &#125; Future&lt;Response&lt;T&gt;&gt; getRequest&lt;T&gt;(url, &#123;Map params, ErrorCallback callback&#125;) =&gt; _request(url, GET, params: params, callback: callback); Future&lt;Response&lt;T&gt;&gt; postRequest&lt;T&gt;(url, &#123;Map params, ErrorCallback callback&#125;) =&gt; _request(url, POST, params: params, callback: callback); Future&lt;Response&gt; download(url, path, &#123;ProgressCallback receive, CancelToken token&#125;) =&gt; _dio.download(url, path, onReceiveProgress: receive, cancelToken: token); // T 可以指定返回的类型，String 或者 Map&lt;String, dynamic&gt; Future&lt;Response&lt;T&gt;&gt; _request&lt;T&gt;( url, String method, &#123; Map params, // 上传的参数 Options opt, ErrorCallback callback, // 错误回调 ProgressCallback send, // 上传进度监听 ProgressCallback receive, // 下载监听 CancelToken token, // 用于取消的 token，可以多个请求绑定一个 token &#125;) async &#123; try &#123; Response&lt;T&gt; rep; if (method == GET) &#123; // 如果不是重新创建 Dio 实例，get 方法使用 queryParams 会出错，不懂原因，使用拼接没有问题 if (params != null &amp;&amp; params.isNotEmpty) &#123; var sb = StringBuffer('?'); params.forEach((key, value) &#123; sb.write('$key=$value&amp;'); &#125;); // get 请求下拼接路径 url += sb.toString().substring(0, sb.length - 1); &#125; rep = await _dio.get(url, options: opt, onReceiveProgress: receive, cancelToken: token); &#125; else if (method == POST) &#123; // post 参数放请求体 rep = params == null ? await _dio.post(url, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive) : await _dio.post(url, data: params, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive); &#125; // 如果 statusCode 不是 200 则错误回调，返回空的 Response if (rep.statusCode != 200 &amp;&amp; callback != null) &#123; callback('network error, and code is $&#123;rep.statusCode&#125;'); return null; &#125; return rep; &#125; catch (e) &#123; if (callback != null) &#123; callback('network error, catch error: $&#123;e.toString()&#125;'); &#125; return null; &#125; &#125;&#125; 封装后就可以愉快的调用了，如果有别的请求方式后期可以继续扩展。继续看代码，创建一个 application.dart 文件，用于存放全局参数 123class Application &#123; static HttpUtils http;&#125; 并在 main() 方法中进行初始化，接下来就可以直接使用 12345678910void main() &#123; Application.http = HttpUtils('https://randomuser.me'); runApp(DemoApp()); // 透明状态栏 if (Platform.isAndroid) &#123; SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent)); &#125;&#125; 看下最后的实现效果吧，刚进入没有数据则通过转圈圈提示，加载完数据后，点击头像更换下个 实现 BLoC 需要有一个管理类 12345678910111213141516171819202122232425class UserBloc extends BaseBloc &#123; RandomUserModel _user; RandomUserModel get user =&gt; _user; BehaviorSubject&lt;RandomUserModel&gt; _controller = BehaviorSubject(); Observable&lt;RandomUserModel&gt; get stream =&gt; Observable(_controller.stream); // 网络请求获取新的数据，并更新 updateUserInfo() &#123; Application.http.getRequest('/api').then((response) &#123; // RandomUserModel 就是接口返回的 json 转成的 model 类 RandomUserModel model = RandomUserModel.fromMap(response.data); _user = model; // add 到 controller 通知修改 _controller.add(model); &#125;); &#125; @override void dispose() &#123; _controller?.close(); // 及时销毁 &#125;&#125; 设置好管理类后，就可以来编写界面了，界面也比较简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class UserPageDemo extends StatelessWidget &#123; // 将首字母大写 String _upperFirst(String content) &#123; assert(content != null &amp;&amp; content.isNotEmpty); return '$&#123;content.substring(0, 1).toUpperCase()&#125;$&#123;content.substring(1)&#125;'; &#125; // 地址信息通用部件 Widget _userLocation(String info) =&gt; Padding( padding: const EdgeInsets.only(top: 4.0), child: Text(info, style: TextStyle(color: Colors.white, fontSize: 16.0))); @override Widget build(BuildContext context) &#123; UserBloc _bloc = BlocProvider.of&lt;UserBloc&gt;(context); _bloc.updateUserInfo(); return Scaffold( // StreamBuilder 接受更新数据的 stream body: StreamBuilder( builder: (_, AsyncSnapshot&lt;RandomUserModel&gt; snapshot) =&gt; Container( alignment: Alignment.center, decoration: BoxDecoration( gradient: LinearGradient( begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [Colors.blue[600], Colors.blue[400]])), child: !snapshot.hasData ? CupertinoActivityIndicator(radius: 12.0) : Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ InkWell( // 用于切换数据 child: ClipOval( // 圆形头像 child: FadeInImage.assetNetwork( placeholder: 'images/ava_default.png', image: snapshot.data.results[0].picture.large), ), onTap: () =&gt; _bloc.updateUserInfo()), // 更新数据 Padding( padding: const EdgeInsets.only(top: 20.0), child: Text( '$&#123;_upperFirst(snapshot.data.results[0].name.first)&#125; $&#123;_upperFirst(snapshot.data.results[0].name.last)&#125;', style: TextStyle(color: Colors.white, fontSize: 24.0)), ), Text('$&#123;snapshot.data.results[0].email&#125;', style: TextStyle(color: Colors.white, fontSize: 18.0)), _userLocation('$&#123;snapshot.data.results[0].location.street&#125;'), _userLocation('$&#123;_upperFirst(snapshot.data.results[0].location.city)&#125;'), _userLocation('$&#123;_upperFirst(snapshot.data.results[0].location.state)&#125;'), ]), ), initialData: _bloc.user, // 注入初始值 stream: _bloc.stream), // 注入更新 stream ); &#125;&#125; 以上代码查看 bloc_network 包下的所有文件]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十二)之数据持久化]]></title>
    <url>%2Fposts%2F6358b348.html</url>
    <content type="text"><![CDATA[上节讲了状态管理，但是当 App 重启后，数据就都丢失了，这样就比较尴尬了，什么都要重来，所以这节我们来讲下数据持久化。数据持久化主要有如下方式 文件读写 shared_preferences 存储 数据库存储 持久化的实现都需要通过三方插件来实现，接着会慢慢介绍三种实现方式 文件读写/ IO 操作文件读写需要 path_provider 插件，写这篇文章的时候，最新版本是 0.5.0+1，小伙伴们可以根据官网最新的版本进行替换，导入后我们就可以来看下如何实现文件的读写了。path_provider 的源码比较简单，这边就不单独拎出来说了，可以自行查看。path_provider 用于获取手机的存储文件位置，一共有三个方法 getTemporaryDirectory 临时目录，在 Android 中对应的方法为 getCacheDir，而在 iOS 中对应为 NSCachesDirectory，可以通过系统检测并清除 getApplicationDocumentsDirectory 缓存目录，在 Android 中对应为 AppData 文件夹，在 iOS 中对应为 NSDocumentsDirectory，只有当 App 被删除才能被删除 getExternalStorageDirectory 外部存储目录，只有在 Android 中有效，在 iOS 调用会抛出 UnsupportedError 异常，不过 Android 在写入前记得先申请权限哟，否则也是不行滴。 读写文件操作需要通过 Dart 的 IO 操作完成，这边小伙伴们可以自己看文档 File class，接着我们就直接通过例子来看文件实现数据持久化。先看下效果吧，最终重启 App 后，数据也能正常读取显示，说明数据被保存下来了 看下实现的代码，因为会涉及到多种方式，所以这边我把视图抽取出来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Widget _fileIoPart() &#123; return Card( margin: const EdgeInsets.all(8.0), shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(8.0))), child: Column(children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(12.0), child: Text('File IO', style: TextStyle(fontSize: 20.0, color: Theme.of(context).primaryColor)), ), // RadioList 是单选按钮部件，通过选择不同的情况，创建不同目录的文件 RadioListTile( value: _radioText[0], title: Text(_radioText[0]), subtitle: Text(_radioDescriptions[0]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), RadioListTile( value: _radioText[1], title: Text(_radioText[1]), subtitle: Text(_radioDescriptions[1]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), RadioListTile( value: _radioText[2], title: Text(_radioText[2]), subtitle: Text(_radioDescriptions[2]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), Padding( padding: const EdgeInsets.all(12.0), // 用于写入文本信息 child: TextField( controller: _editController, decoration: InputDecoration(labelText: '输入存储的文本内容', icon: Icon(Icons.text_fields)), ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _writeTextIntoFile, child: Text('写入文件信息'), ), ), Padding( padding: const EdgeInsets.all(12.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Text('文件内容：'), Expanded(child: Text(_fileContent, softWrap: true))], ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _readTextFromFile, child: Text('读取文件信息'), ), ), ]), ); &#125; 关键的部分在于 _writeTextIntoFile 和 _readTextFromFile 两个方法的实现。看下实现的代码 1234567891011121314151617181920212223242526272829303132333435363738394041// 如果写入外部内存需要读写权限，这边使用了第三方插件 `permission_handler` void _writeTextIntoFile() async &#123; if (_currentValue == _radioText[2]) &#123; PermissionStatus status = await PermissionHandler().checkPermissionStatus(PermissionGroup.storage); if (status == PermissionStatus.granted) // 如果是写入外部存储，则检测权限状态，同意则写入 _writeContent(); else if (status == PermissionStatus.disabled) // 拒绝了提示手动打开 Fluttertoast.showToast(msg: '未打开相关权限'); else // 未同意则主动申请权限 PermissionHandler().requestPermissions([PermissionGroup.storage]); &#125; else // 不是写入外部存储直接写入文件 _writeContent(); &#125;// 文本写入文件 void _writeContent() async &#123; // 写入文本操作 var text = _editController.value.text; // 获取文本框的内容 File file = File(await _getFilePath()); // 获取相应的文件 if (text == null || text.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入内容'); // 内容为空，则不写入并提醒 &#125; else &#123; // 内容不空，则判断是否已经存在，存在先删除，重新创建后写入信息 if (await file.exists()) file.deleteSync(); file.createSync(); // createSync 是一个同步的创建过程 file.writeAsStringSync(text); // writeAsStringSync 是同步写入的过程 _editController.clear(); // 写入文件后清空输入框信息 &#125; &#125; // 读取文本操作 void _readTextFromFile() async &#123; File file = File(await _getFilePath()); if (await file.exists()) &#123; setState(() =&gt; _fileContent = file.readAsStringSync()); // 文件存在则直接显示文本信息 &#125; else &#123; setState(() =&gt; _fileContent = ''); // 文件不存在则清空显示文本信息，并提示 Fluttertoast.showToast(msg: '文件还未创建，请先通过写入信息来创建文件'); &#125; &#125; 因为外部存储的文件需要涉及到权限问题，而且 iOS 也不支持，所以如果需要使用文件来持久化数据的话，尽量使用另外两种。因为在例子中，我们保存的数据相对比较简单，所以这边就不得不说另外一种更方便的持久化方式了 shared_preferences SharedPreferences写 Android 的小伙伴对这个应该不陌生了，但是 Flutter 并没有自带的 shared_preferences 功能，需要第三方插件来实现，引入 shared_preferences 插件，写文章的时候最新版本是 ^0.5.1+2，还是先看下最后的效果 代码的实现相对比较简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Widget _sharedPart() &#123; return Card( margin: const EdgeInsets.all(8.0), shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(8.0))), child: Column( children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(12.0), child: Text('Shared Preferences', style: TextStyle(fontSize: 20.0, color: Theme.of(context).primaryColor)), ), Padding( padding: const EdgeInsets.fromLTRB(12.0, 0, 12.0, 12.0), // 用于设置 key 信息 child: TextField( controller: _shareKeyController, decoration: InputDecoration(labelText: '输入 share 存储的 key', icon: Icon(Icons.lock_outline)), ), ), Padding( padding: const EdgeInsets.fromLTRB(12.0, 0, 12.0, 12.0), // 用于写入文本信息 child: TextField( controller: _shareValueController, decoration: InputDecoration(labelText: '输入 share 存储的 value', icon: Icon(Icons.text_fields)), ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _writeIntoShare, child: Text('写入 share'), ), ), Padding( padding: const EdgeInsets.all(12.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Text('share 存储内容：'), Expanded(child: Text(_shareContent, softWrap: true))], ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _readFromShare, child: Text('读取 share'), ), ), ], )); &#125; 实现的关键部分就是方法 _writeIntoShare 和 _readFromShare 12345678910111213141516171819202122232425262728293031323334void _writeIntoShare() async &#123; var shareKey = _shareKeyController.value.text; var shareContent = _shareValueController.value.text; if (shareKey == null || shareKey.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入 key'); &#125; else if (shareContent == null || shareContent.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入保存的内容'); &#125; else &#123; // 通过 `getInstance` 获取 `shared_preferences` 单例 var sp = await SharedPreferences.getInstance(); // sp 能保存的数据类型包括 `int`, `String`, `bool`, `double`, `StringList` sp.setString(shareKey, shareContent); &#125; &#125; void _readFromShare() async &#123; var shareKey = _shareKeyController.value.text; if (shareKey == null || shareKey.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入 key'); &#125; else &#123; var sp = await SharedPreferences.getInstance(); // 数据读取的类型同写入类型，如果传入的 key 不存在则返回 null var value = sp.getString(shareKey); if (value == null) &#123; Fluttertoast.showToast(msg: '未找到该 key'); setState(() =&gt; _shareContent = ''); &#125; else &#123; setState(() =&gt; _shareContent = value); &#125; &#125; &#125; 这两种数据持久化的方式主要用于存储相对简单，关系不复杂的数据，如果涉及到大量的，且字段之间有关系的情况就需要通过数据库来实现了，Android 和 iOS 都自带 sqlite 数据库。 以上代码查看 data_persistence_main.dart 文件 SqfliteFlutter 实现数据库存储需要通过插件 sqflite 来实现，写文章的时候最新的版本是 sqflite 1.1.3，但是该版本需要 flutter 1.2 以上才行，所以我选择的是 sqflite 1.1.0，小伙伴可以根据自己的 flutter 版本选择相应的 sqflite 版本 sqflite 的基本操作语句，在文档中已经写得非常明白了，所以就不搬运了，这边直接讲下对于数据库的一些封装处理吧，因为打开数据库是一个很消耗资源的一个过程，所以呢，推荐实现单例会比较好。例如我们要实现一个 student 存储表 12345678910111213141516171819202122232425262728293031323334353637class DatabaseUtils &#123; final String _tableStudent = 'student'; static Database _database; // 创建单例，防止重复打开消耗内存 static DatabaseUtils _instance; static DatabaseUtils get instance =&gt; _instance; DatabaseUtils._internal() &#123; getDatabasesPath().then((path) async &#123; _database = await openDatabase(join(path, 'demo.db'), version: 2, onCreate: (db, version) &#123; // 创建数据库的时候在这边调用 db.execute('create table $_tableStudent ' 'id integer primary key autoincrement,' 'name text not null,' 'age integer not null default 0,' 'gender integer not null default 0'); // 更新升级增加的字段 db.execute('alter table $_tableStudent add column birthday text'); &#125;, onUpgrade: (db, oldVersion, newVersion) &#123; // 更新升级数据库的时候在这操作 if (oldVersion == 1) db.execute('alter table $_tableStudent add column birthday text'); &#125;, onOpen: (db) &#123; // 打开数据库时候的回调 print('$&#123;db.path&#125;'); &#125;); &#125;); &#125; factory DatabaseUtils() &#123; // 如果当前的单例已经存在，则不再创建，否则重新创建，factory 关键词看第一章 if (_instance == null) _instance = DatabaseUtils._internal(); return _instance; &#125;&#125; 那么对数据库的操作就完全考验你的 SQL 的掌握程度了，但是千万记住，sqlite 中的类型只有，整型 integer ，字符类型 text，浮点类型 real，二进制 blob。数据库的具体例子会等到最后的实际项目中展示，原谅我不懂如何展示一个界面给你操作，实现数据库的各种功能。 该部分代码查看 db_util.dart 文件，里面有一些基本的操作写法，小伙伴可自行查看。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十一)之状态管理，BLoC]]></title>
    <url>%2Fposts%2Fd121323a.html</url>
    <content type="text"><![CDATA[Stream在 dart 部分记得分享过 Stream 的文章链接，但是我知道你们肯定没几个愿意看的，所以这里再提下。还是得从源码开始…因为源码的注释比较长，就不贴注释了，可以自己看，我这边就提取一些关键信息。 Stream 是 Dart 提供的一种数据流订阅管理的”工具”，感觉有点像 Android 中的 EventBus 或者 RxBus，Stream 可以接收任何对象，包括是另外一个 Stream，接收的对象通过 StreamController 的 sink 进行添加，然后通过 StreamController 发送给 Stream，通过 listen 进行监听，listen 会返回一个 StreamSubscription 对象，StreamSubscription 可以操作对数据流的监听，例如 pause，resume，cancel 等。 Stream 分两种类型： Single-subscription Stream：单订阅 stream，整个生命周期只允许有一个监听，如果该监听 cancel 了，也不能再添加另一个监听，而且只有当有监听了，才会发送数据，主要用于文件 IO 流的读取等。 Broadcast Stream：广播订阅 stream，允许有多个监听，当添加了监听后，如果流中有数据存在就可以监听到数据，这种类型，不管是否有监听，只要有数据就会发送，用于需要多个监听的情况。 还是看下例子会比较直观 1234567891011121314151617181920212223242526272829303132333435363738class _StreamHomeState extends State&lt;StreamHome&gt; &#123; StreamController _controller = StreamController(); // 创建单订阅类型 `StreamController` Sink _sink; StreamSubscription _subscription; @override void initState() &#123; super.initState(); _sink = _controller.sink; // _sink 用于添加数据 // _controller.stream 会返回一个单订阅 stream， // 通过 listen 返回 StreamSubscription，用于操作流的监听操作 _subscription = _controller.stream.listen((data) =&gt; print('Listener: $data')); // 添加数据，stream 会通过 `listen` 方法打印 _sink.add('A'); _sink.add(11); _sink.add(11.16); _sink.add([1, 2, 3]); _sink.add(&#123;'a': 1, 'b': 2&#125;); &#125; @override void dispose() &#123; super.dispose(); // 最后要释放资源... _sink.close(); _controller.close(); _subscription.cancel(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: Container(), ); &#125;&#125; 看下控制台的输出： 果然把所有的数据都打印出来了，前面有说过，单订阅的 stream 只有当 listen 后才会发送数据，不试试我还是不相信的，我们把 _sink.add 放到 listen 前面去执行，再看控制台的打印结果。居然真的是一样的，Google 粑粑果然诚不欺我。接着试下 pause，resume 方法，看下数据如何监听，修改代码 123456789_sink = _controller.sink;_subscription = _controller.stream.listen((data) =&gt; print('Listener: $data'));_sink.add('A');_subscription.pause(); // 暂停监听_sink.add(11);_sink.add(11.16);_subscription.resume(); // 恢复监听_sink.add([1, 2, 3]);_sink.add(&#123;'a': 1, 'b': 2&#125;); 再看控制台的打印，你们可以先猜下是什么结果，我猜大部分人都会觉得应该是不会有 11 和 11.16 打印出来了。然鹅事实并非这样，打印的结果并未发生变化，也就是说，调用 pause 方法后，stream 被堵住了，数据不继续发送了。 接下来看下广播订阅 stream，对代码做下修改 1234567891011121314151617181920212223StreamController _controller = StreamController.broadcast(); Sink _sink; StreamSubscription _subscription; @override void initState() &#123; super.initState(); _sink = _controller.sink; _sink.add('A'); _subscription = _controller.stream.listen((data) =&gt; print('Listener: $data')); _sink.add(11); _subscription.pause(); _sink.add(11.16); _subscription.resume(); _sink.add([1, 2, 3]); _sink.add(&#123;'a': 1, 'b': 2&#125;); &#125;// ...&#125; 我们再看下控制台的打印： 你猜对答案了吗，这边做下小总结： 单订阅 Stream 只有当存在监听的时候，才发送数据，广播订阅 Stream 则不考虑这点，有数据就发送；当监听调用 pause 以后，不管哪种类型的 stream 都会停止发送数据，当 resume 之后，把前面存着的数据都发送出去。 sink 可以接受任何类型的数据，也可以通过泛型对传入的数据进行限制，比如我们对 StreamController 进行类型指定 StreamController&lt;int&gt; _controller = StreamController.broadcast(); 因为没有对 Sink 的类型进行限制，还是可以添加除了 int 外的类型参数，但是运行的时候就会报错，_controller 对你传入的参数做了类型判定，拒绝进入。 Stream 中还提供了很多 StremTransformer，用于对监听到的数据进行处理，比如我们发送 0~19 的 20 个数据，只接受大于 10 的前 5 个数据，那么可以对 stream 如下操作 123456_subscription = _controller.stream .where((value) =&gt; value &gt; 10) .take(5) .listen((data) =&gt; print('Listen: $data'));List.generate(20, (index) =&gt; _sink.add(index)); 那么打印出来的数据如下图 除了 where，take 还有很多 Transformer， 例如 map，skip 等等，小伙伴们可以自行研究。了解了 Stream 的基本属性后，就可以继续往下了~ StreamBuilder前面提到了 stream 通过 listen 进行监听数据的变化，Flutter 就为我们提供了这么个部件 StreamBuilder 专门用于监听 stream 的变化，然后自动刷新重建。接着来看下源码 12345678910const StreamBuilder(&#123; Key key, this.initialData, // 初始数据，不传入则为 null Stream&lt;T&gt; stream, @required this.builder &#125;) : assert(builder != null), super(key: key, stream: stream);@overrideAsyncSnapshot&lt;T&gt; initial() =&gt; AsyncSnapshot&lt;T&gt;.withData(ConnectionState.none, initialData); StreamBuilder 必须传入一个 AsyncWidgetBuilder 参数，初始值 initialData 可为空， stream 用于监听数据变化，initial 方法的调用在其父类 StremBuilderBase 中，接着看下 StreamBuilderBaseState 的源码，这里我删除一些不必要的源码，方便查看，完整的源码可自行查看 123456789101112131415161718192021222324252627282930313233343536class _StreamBuilderBaseState&lt;T, S&gt; extends State&lt;StreamBuilderBase&lt;T, S&gt;&gt; &#123; // ... @override void initState() &#123; super.initState(); _summary = widget.initial(); // 通过传入的初始值生成默认值，如果没有传入则会是 null _subscribe(); // 注册传入的 stream，用于监听变化 &#125; // _summary 为监听到的数据 @override Widget build(BuildContext context) =&gt; widget.build(context, _summary); // ... void _subscribe() &#123; if (widget.stream != null) &#123; // stream 通过外部传入，对数据的变化进行监听， // 在不同回调中，通过 setState 进行更新 _summary // 当 _summary 更新后，由于调用了 setState，重新调用 build 方法，将最新的 _summary 传递出去 _subscription = widget.stream.listen((T data) &#123; setState(() &#123; _summary = widget.afterData(_summary, data); &#125;); &#125;, onError: (Object error) &#123; setState(() &#123; _summary = widget.afterError(_summary, error); &#125;); &#125;, onDone: () &#123; setState(() &#123; _summary = widget.afterDone(_summary); &#125;); &#125;); _summary = widget.afterConnected(_summary); // &#125; &#125;&#125; 在之前更新数据都需要通过 setState 进行更新，这里了解完了 stream，我们就不使用 setState 更新，使用 Stream 来更新 1234567891011121314151617181920212223242526272829303132333435363738394041class _StreamHomeState extends State&lt;StreamHome&gt; &#123; // 定义一个全局的 `StreamController` StreamController&lt;int&gt; _controller = StreamController.broadcast(); // `sink` 用于传入新的数据 Sink&lt;int&gt; _sink; int _counter = 0; @override void initState() &#123; super.initState(); _sink = _controller.sink; &#125; @override void dispose() &#123; super.dispose(); // 需要销毁资源 _sink.close(); _controller.close(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, child: StreamBuilder( builder: (_, snapshot) =&gt; Text('$&#123;snapshot.data&#125;', style: TextStyle(fontSize: 24.0)), stream: _controller.stream, // stream 在 StreamBuilder 销毁的时候会自动销毁 initialData: _counter, ), )), // 通过 `sink` 传入新的数据，去通知 `stream` 更新到 builder 中 floatingActionButton: FloatingActionButton( onPressed: () =&gt; _sink.add(_counter++), child: Icon(Icons.add), ), ); &#125;&#125; 那么当点击按钮的时候，就会刷新界面上的值，通过上面的源码分析，StreamBuilder 也是通过 setState 方法进行刷新，那么两种方法孰优孰劣呢，当然是通过 Stream 啦，这不是废话吗。因为通过调用 setState 刷新的话，会把整个界面都进行重构，但是通过 StreamBuilder 的话，只刷新其 builder，这样效率就更高了，最后看小效果吧，所谓有图有真相嘛 这一步，我们摒弃了 setState 方法，那么下一步，我们试试把 StatefulWidget 替换成 StatelessWidget 吧，而且官方也推荐使用 StatelessWidget 替换 StatefulWidget，这里就需要提下 BLoC 模式了。 BLoC说实话，现在 Google 下 「flutter bloc」能搜到很多文章，基本上都是通过 InheritedWidget 来实现的，例如这篇Flutter | 状态管理探索篇——BLoC(三)，但是 InheritedWidget 没有提供 dispose 方法，那么就会存在 StreamController 不能及时销毁等问题，所以，参考了一篇国外的文章，Reactive Programming - Streams - BLoC 这里通过使用 StatefulWidget 来实现，当该部件销毁的时候，可以在其 dispose 方法中及时销毁 StreamController，这里我还是先当个搬运工，搬下大佬为我们实现好的基类 12345678910111213141516171819202122232425262728293031323334353637abstract class BaseBloc &#123; void dispose(); // 该方法用于及时销毁资源&#125;class BlocProvider&lt;T extends BaseBloc&gt; extends StatefulWidget &#123; final Widget child; // 这个 `widget` 在 stream 接收到通知的时候刷新 final T bloc; BlocProvider(&#123;Key key, @required this.child, @required this.bloc&#125;) : super(key: key); @override _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;(); // 该方法用于返回 Bloc 实例 static T of&lt;T extends BaseBloc&gt;(BuildContext context) &#123; final type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;(); // 获取当前 Bloc 的类型 // 通过类型获取相应的 Provider，再通过 Provider 获取 bloc 实例 BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type); return provider.bloc; &#125; static Type _typeOf&lt;T&gt;() =&gt; T;&#125;class _BlocProviderState&lt;T&gt; extends State&lt;BlocProvider&lt;BaseBloc&gt;&gt; &#123; @override void dispose() &#123; widget.bloc.dispose(); // 及时销毁资源 super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return widget.child; &#125;&#125; 接着我们对前面的例子使用 BLoC 进行修改。 首先，我们需要创建一个 Bloc 类，用于修改 count 的值 12345678910111213141516171819class CounterBloc extends BaseBloc &#123; int _count = 0; int get count =&gt; _count; // stream StreamController&lt;int&gt; _countController = StreamController.broadcast(); Stream&lt;int&gt; get countStream =&gt; _countController.stream; // 用于 StreamBuilder 的 stream void dispatch(int value) &#123; _count = value; _countController.sink.add(_count); // 用于通知修改值 &#125; @override void dispose() &#123; _countController.close(); // 注销资源 &#125;&#125; 在使用 Bloc 前，需要在最上层的容器中进行注册，也就是 MaterialApp 中 1234567891011121314151617181920212223242526272829303132333435363738394041void main() =&gt; runApp(StreamApp());class StreamApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 这里对创建的 bloc 类进行注册，如果说有多个 bloc 类的话，可以通过 child 进行嵌套注册即可 // 放在最顶层，可以全局调用，当 App 关闭后，销毁所有的 Bloc 资源， // 也可以在路由跳转的时候进行注册，至于在哪里注册，完全看需求 // 例如实现主题色的切换，则需要在全局定义，当切换主题色的时候全局切换 // 又比如只有某个或者某几个特殊界面调用，那么完全可以通过在路由跳转的时候注册 return BlocProvider( child: MaterialApp( debugShowCheckedModeBanner: false, home: StreamHome(), ), bloc: CounterBloc()); &#125;&#125;class StreamHome extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 获取注册的 bloc，必须先注册，再去查找 final CounterBloc _bloc = BlocProvider.of&lt;CounterBloc&gt;(context); return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, child: StreamBuilder( initialData: _bloc.count, stream: _bloc.countStream, builder: (_, snapshot) =&gt; Text('$&#123;snapshot.data&#125;', style: TextStyle(fontSize: 20.0)), ), )), floatingActionButton: // 通过 bloc 中的 dispatch 方法进行值的修改，通知 stream 刷新界面 FloatingActionButton(onPressed: () =&gt; _bloc.dispatch(_bloc.count + 1), child: Icon(Icons.add)), ); &#125;&#125; 重新运行后，查看效果还是一样的。所以我们成功的对 StatefulWidget 进行了替换 再继续讲之前，先总结下 Bloc ​ 1. 成功的把页面和逻辑分离开了，页面只展示数据，逻辑通过 BLoC 进行处理 ​ 2. 减少了 setState 方法的使用，提高了性能 ​ 3. 实现了状态管理 RxDart因为上面的参考文章中提到了 RxDart，个人觉得有必要了解下，当然目前也有很多文章介绍 RxDart，所以我就讲下和 BLoC 有点关系的部分吧。RxDart 需要通过引入插件的方式引入(rxdart: ^0.21.0) 如果需要查看详细的内容，我这里提供几篇文章链接 RxDart 文档 RxDart: Magical transformations of Streams 其实 RxDart 就是对 Stream 的进一步分装，RxDart 提供了三种 Subject，其功能类似 Stream 中的单订阅 stream 和 广播 stream。 PublishSubject 123/// PublishSubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. 通过注释可以发现 PuslishSubject 不可被多次订阅，尽管实现是通过 StreamController&lt;T&gt;.broadcast 方式实现，其实三种都是通过 broadcast 方式实现的，所以实现的功能就是类似 Single-subscription Stream 的功能。 BehaviorSubject 123/// BehaviorSubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. BehaviorSubject 可以被多次订阅，那么这个就是实现了 Broadcast Stream 功能。 ReplaySubject 123/// ReplaySubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. ReplaySubject 其实也是实现 Broadcast Stream 功能，那么它和 BehaviorSubject 的区别在哪呢，别急，等我慢慢讲。 123/// As items are added to the subject, the ReplaySubject will store them./// When the stream is listened to, those recorded items will be emitted to/// the listener. 当有数据添加了，但是还没有监听的时候，它会将数据存储下来，等到有监听了，再发送出去，也就是说，ReplaySubject 实现了 Brodacast Stream 的多订阅功能，同时也实现了 Single-subscription Stream 的存储数据的功能，每次添加了新的监听，都能够获取到全部的数据。当然，这还不是它的全部功能，它还可以设置最大的监听数量，会只监听最新的几个数据，在注释中，提供了这么两个例子，可以看下 1234567891011121314151617181920212223/// ### Example ////// final subject = new ReplaySubject&lt;int&gt;();////// subject.add(1);/// subject.add(2);/// subject.add(3);////// subject.stream.listen(print); // prints 1, 2, 3/// subject.stream.listen(print); // prints 1, 2, 3/// subject.stream.listen(print); // prints 1, 2, 3////// ### Example with maxSize////// final subject = new ReplaySubject&lt;int&gt;(maxSize: 2); // 实现监听数量限制////// subject.add(1);/// subject.add(2);/// subject.add(3);////// subject.stream.listen(print); // prints 2, 3/// subject.stream.listen(print); // prints 2, 3/// subject.stream.listen(print); // prints 2, 3 那么我们可以使用 RxDart 对前面使用 Stream 实现的例子进行替换，最简单的其实只需要使用 BehaviorSubject 替换 StreamController.broadcast() 就可以了，别的都不需要变化。但是 RxDart 有自己的变量，还是按照 RxDart 的方式来 1234567891011121314// 继承自 StreamController，所以 StreamController 拥有的属性都有BehaviorSubject&lt;int&gt; _countController = BehaviorSubject();// StreamController&lt;int&gt; _countController = StreamController.broadcast();// 继承自 Stream，所以这里直接用之前 stream 的写法也没问题，但是这样就有点不 RxDart 了Observable&lt;int&gt; get countStream =&gt; Observable(_countController.stream);// Stream&lt;int&gt; get countStream =&gt; _countController.stream;void dispatch(int value) &#123; _count = value; // 直接提供了 add 方法，不需要通过 sink 来添加 _countController.add(_count);// _countController.sink.add(_count);&#125; 再次运行还是能过实现相同的效果。如果说要在 RxDart 和 Stream 两种实现方式中选择一种，个人更偏向于 RxDart，因为它对 Stream 进行了进一步的封装，提供了更多更方便的数据转换方法，而且链式的写法真的很舒服，用过了就停不下来，具体的方法介绍可以参考上面提供的链接。 Provide说实话自己封装 BLoC 来实现分离逻辑和界面，相对还是有点难度的，这边可以通过第三方来实现，这边推荐 Google 粑粑的库，flutter_provide，看下官方对关键部件和静态方法的介绍 Provide&lt;T&gt; - Widget used to obtain values from a ProviderNode higher up in the widget tree and rebuild on change. The Provide&lt;T&gt;widget should only be used with Streams or Listenables. Equivalent to ScopedModelDescendant in ScopedModel Provide.value&lt;T&gt; - Static method used to get a value from a ProviderNode using the BuildContext. This will not rebuild on change. Similar to manually writing a static .of() method for an InheritedWidget. Provide.stream&lt;T&gt; - Static method used to get a Stream from a ProviderNode. Only works if either T is listenable, or if the Providercomes from a Stream. Provider&lt;T&gt; - A class that returns a typed value on demand. Stored in a ProviderNode to allow retrieval using Provide. ProviderNode - The equivalent of the ScopedModel widget. Contains Providers which can be found as an InheritedWidget. Provide 这个部件主要用于从上层的 ProvideNode 中获取值，当变化的时候刷新重建，只能同 Stream 和 Listenable 一同使用，类似于 ScopeMode 中的 ScopedModelDescendant。(这个部件放在需要状态管理的部件的上层，例如有个 Text 需要修改状态，那么就需要在外层提供一个 Provide 部件，通过内部 builder 参数返回 Text 部件) Provide.value 是个静态方法，用于从 ProvideNode 获取值，但是当接收的值改变的时候不会重建。类似于 InheritedWidget 的静态方法 of。(这个方法用于获取指定类型的 provide，每个 provide 都需要提供一个数据类，该类 with ChangeNotifier，当数据变化的时候通过 notifyListeners 通知 provide 变化，进行刷新重建) Provide.stream 是个静态方法，用于从 ProvideNode 获取一个 stream，仅在 T 可被监听，或者 Provide 来自 stream 的情况下有效。(这个通常结合 StreamBuilder 使用，StreamBuilder 在上面已经提到，就不多说了) Provider 按需要的类型返回相关值的类，存储在 ProviderNode 中方便 Provide 进行检索。(这个类主要是将我们自己创建的数据类通过 function 等方法转换成 Provider，并在 Providers 中进行注册) ProvideNode 类似于 ScopedModel 的一个部件，包含所有能被查找的 Providers。(这个需要放在顶层，方便下面的容器进行查找 provider，刷新相应的部件，一般放在 MaterialApp 上层) 这边再补充一个个人觉得关键的类 Providers，这个类主要用于存储定义的 Provider，主要是在建立 MaterialApp 的时候将需要用到的 Provider 通过 provide 方法添加进去存储起来，然后在 ProvideNode 中注册所有的 provider 方便下层容器获取值，并调用。 说那么多，还不如直接看个例子直接，代码来了~，首先需要建立一个类似 BLoC 中监听数据变化的 counter_bloc 类的数据管理类，我们这边定义为 count_provider 需要混入 ChangeNotifier 类 12345678910class CountProvider with ChangeNotifier &#123; int _value = 0; // 存储的数据，也是我们需要管理的状态值 int get value =&gt; _value; // 获取状态值 void changeValue(int value) &#123; _value = value; notifyListeners(); // 当状态值发生变化的时候，通过该方法刷新重建部件 &#125;&#125; 然后需要将定义的类注册到全局的 Providers 中 12345678910void main() &#123; final providers = Providers() // 将我们创建的数据管理类，通过 Provider.function 方法转换成 Provider， // 然后添加到 Providers 中 ..provide(Provider.function((_) =&gt; CountProvider())); // 在 App 上层，通过包裹一层 ProvideNode，并将我们生成的 Providers 实例 // 注册到 ProvideNode 中去，这样整个 App 都可以通过 Provide.value 查找相关的 Provider // 找到 Provider 后就可以找到我们的数据管理类 runApp(ProviderNode(child: StreamApp(), providers: providers));&#125; 接着就是替换我们的界面实现了，前面通过 BLoC 实现，这里替换成 Provide 来实现 123456789101112131415161718192021class StreamHome extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, // 通过指定类型，获取特定的 Provide，这个 Provide 会返回我们的数据管理类 provider // 通过内部定义的方法，获取到需要展示的值 child: Provide&lt;CountProvider&gt;(builder: (_, widget, provider) =&gt; Text('$&#123;provider.value&#125;')), )), floatingActionButton: FloatingActionButton( onPressed: () =&gt; // 通过 value 方法获取到我们的数据管理类 provider， // 通过调用改变值的方法，修改内部的值，并通知界面刷新重建 Provide.value&lt;CountProvider&gt;(context).changeValue( Provide.value&lt;CountProvider&gt;(context).value + 1), child: Icon(Icons.add)) ); &#125;&#125; 本文代码查看 bloc 包名下的所有文件，需要单独运行 stream_main.dart 文件 最后运行后还是一样的效果，也摒弃了 StatefulWidget 部件和 SetState 方法，实现了逻辑和界面分离。但是 Provide 最终还是通过 InheritedWidget 来实现，当然在资源方面 Google 的大佬们做了一些相关的处理，至于如何处理，这边就不多说了。目前 provide 的这个库还存在一点争议的地方，具体查看 issue#3，但是目前来看并没有太大的影响。当然你不放心的话，可以使用 Scoped_model 或者上面的 Bloc 模式，Google 在文档也有相关的注明 If you must choose a package today, it’s safer to go with package:scoped_model than with this package. 这篇概念性的比较多，但是等理解了以后，对于以后的开发还是非常有利的。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十)之手势处理和动画]]></title>
    <url>%2Fposts%2Fd4756fd3.html</url>
    <content type="text"><![CDATA[在 Flutter 中，自带手势监听的目前为止好像只有按钮部件和一些 chip 部件，例如 Text 等部件需要实现手势监听，就需要借助带有监听事件的部件来实现了，这节我们会讲下 InkWell 和 GestureDetector 来实现手势的监听。 InkWell在前面的一些例子中，小伙伴应该看到了好几次 InkWell 这个部件，通过它我们可以实现对一些手势的监听，并实现 MD 的水波纹效果，举个简单的一个例子 1234InkWell( child: Text('点我...点我...我能响应点击手势'), onTap: () =&gt; print('啊...我被点击了...')), 那么当点击 Text 的时候就会响应点击事件，控制台输出日志 我们还是老套路，分析下源码。Ctrl 点击 InkWell 来查看源码(Android Studio 的操作，别的我不懂喔…)，然后，「嗯…除了构造函数怎么什么都没有？？？」那只能看它的父类 InkResponse 了，在那之前，我们看下 InkWell 的说明 12&gt; /// A rectangular area of a [Material] that responds to touch.&gt; InkWell 是在 MaterialDesign 风格下的一个用来响应触摸的矩形区域（注意加粗的文字，1.如果不是 MD 风格的部件下，你是不能用这个来做点击响应的；2.InkWell 是一块矩形区域，如果你要的是圆形区域，8 好意思，不行！） 1234&gt; /// The [InkWell] widget must have a [Material] widget as an ancestor. The&gt; /// [Material] widget is where the ink reactions are actually painted. This&gt; /// matches the material design premise wherein the [Material] is what is&gt; /// actually reacting to touches by spreading ink. 123456789101112131415161718192021222324252627282930313233343536373839`InkWell` 必须要有一个 `Material` 风格的部件作为锚点，巴拉巴拉巴拉....再次强调必须要在 `MD` 风格下使用。接下来看下 `InkResponse` 吧#### InkResponse```dartconst InkResponse(&#123; Key key, this.child, // 需要监听的子部件 // 一个 `GestureTapCallback` 类型参数，看下 `GestureTapCallback` 的定义, // `typedef GestureTapCallback = void Function();` 就是简单的无参无返回类型参数 // 监听手指点击事件 this.onTap, // 一个 `GestureTapDownCallback` 类型参数，需要 `TapDownDetails` 类型参数， // `TapDownDetails` 里面有个 `Offset` 参数用于记录点击的位置，监听手指点击屏幕的事件 this.onTapDown, // 同 `onTap` 表示点击事件取消监听 this.onTapCancel, // 同 `onTap` 表示双击事件监听 this.onDoubleTap, // 一个 `GestureLongPressCallback` 类型参数，也是无参无返回值，表示长按的监听 this.onLongPress, // 监听高亮的变化，返回 `true` 表示往高亮变化，`false` 相反 this.onHighlightChanged, // 是否需要裁剪区域，`InkWell` 该值为 `true`，会根据 `highlightShape` 裁剪 this.containedInkWell = false, // 高亮的外形，`InkWell` 该值设置成 `BoxShape.rectangle`，所以是个矩形区域 this.highlightShape = BoxShape.circle, this.radius, // 手指点下去的时候，出现水波纹的半径 this.borderRadius, // 点击时候外圈阴影的圆角半径 this.customBorder, this.highlightColor, // 高亮颜色 this.splashColor, // 手指点下生成的水波颜色 this.splashFactory, // 两个值 `InkRipple.splashFactory` 和 `InkSplash.splashFactory` this.enableFeedback = true, // 检测到手势是否有反馈 this.excludeFromSemantics = false, &#125;) 所以一些简单的触摸事件直接通过 InkWell 或者 InkResponse 就能够实现，但是面临一些比较复杂的手势，就有点不太够用了，我们需要通过 GestureDector 来进行处理 GestureDectorGestureDetector 也是一个部件，主要实现对各种手势动作的监听，其监听事件查看下面的表格 回调方法 回调描述 onTapDown 点击屏幕的手势触碰到屏幕时候触发 onTapUp 点击屏幕抬手后触发，点击结束 onTap 点击事件已经完成的时候触发，和 onTapUp 几乎同时 onTapCancel 点击未完成，被其它手势取代的时候触发 onDoubleTap 双击屏幕的时候触发 onLongPress 长按屏幕的时候触发 onLongPressUp 长按屏幕后抬手触发 onVerticalDragDown 触碰到屏幕，可能发生垂直方向移动触发，onVerticalDrag 系列事件不会同 onHorizontalDrag 系列事件同时发生 ，如果发生了 onVerticalDrag 则接下来如何变化移动，都不会触发 onHorizontalDrag 事件，除非取消后重新触发。判断两者的关键是准备滑动的意图，先发生横向滑动则触发 onHorizontalDrag 事件，否则 onVerticalDrag 事件。 onVerticalDragStart 触碰到屏幕，并开始发生垂直方向的移动触发 onVerticalDragUpdate 垂直方向移动的距离变化触发 onVerticalDragEnd 抬手取消垂直方向移动的时候触发 onVerticalDragCancel 触发 onVerticalDragDown 但是没有完成整个 onVerticalDrag 事件触发 onHorizontalDrag 系列介绍省略同上… onPanDown 触碰到屏幕，准备滑动的时候触发，onPan 系列回调不可和 onVerticalDrag 或者 onHorizontalDrag 系列回调同时设置 onPanStart 触碰到屏幕，并开始滑动时候触发 onPanUpdate 滑动位置发生改变的时候触发 onPanEnd 滑动完成并抬手的时候触发 onPanCancel 触发 onPanDown 但是没有完成整个 onPan 事件触发 onScaleStart 两个手指之间建立联络点触发，初始缩放比例为 1.0 onScaleUpdate 手指距离发生变化，缩放比例也跟随变化触发 onScaleEnd 手指抬起，至间的联络断开时候触发 还有 onForcePress 系列事件，这个是根据对屏幕的挤压力度进行触发，需要达到某些定值才能触发。GestureDetector 有个 behavior 属性用于设置手势监听过程中的表现形式 deferToChild 默认值，触摸到 child 的范围才会触发手势，空白处不会触发 opaque 不透明模式，防止 background widget 接收到手势 translucent 半透明模式，刚好同 opaque 相反，允许 background widget 接收到手势 介绍完了手势，那就可以实际操练起来了，比如，实现一个跟随手指运动的小方块，先看下效果图 简单的分析下，通过 Positioned 来设置小方块的位置，根据 GestureDetector 的 onPanUpdate 修改 Positioned 的 left 和 top 值，当 onPanEnd 或者 onPanCancel 的时候设置为原点，那么就可以有如图的效果了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class GestureDemoPage extends StatefulWidget &#123; @override _GestureDemoPageState createState() =&gt; _GestureDemoPageState();&#125;class _GestureDemoPageState extends State&lt;GestureDemoPage&gt; &#123; double left = 0.0; double top = 0.0; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Gesture Demo'), ), body: Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ Positioned(child: Container(width: 50.0, height: 50.0, color: Colors.red), left: left, top: top), GestureDetector( behavior: HitTestBehavior.translucent, child: Container( color: Colors.transparent, width: MediaQuery.of(context).size.width - 10, height: MediaQuery.of(context).size.height), onPanDown: (details) &#123; setState(() &#123; left = details.globalPosition.dx; top = details.globalPosition.dy; &#125;); &#125;, onPanUpdate: (details) &#123; setState(() &#123; left = details.globalPosition.dx; top = details.globalPosition.dy; &#125;); &#125;, onPanCancel: () &#123; setState(() &#123; left = 0.0; top = 0.0; &#125;); &#125;, onPanEnd: (details) &#123; setState(() &#123; left = 0.0; top = 0.0; &#125;); &#125;, ) ], )); &#125;&#125; 如果说要实现一个放大缩小的方块，就可以通过 onScaleUpdate 中获取到的 details.scale 来设置方块的宽高即可。这个比较简单就留给小伙伴们自己实现效果了。 该部分代码查看 gesture_main.dart 文件 Animation 动画Flutter 的 Animation 是个抽象类，具体的实现需要看其子类 AnimationController，在这之前，先了解下 Animation 的一些方法和介绍。 addListener / removeListener 添加的监听用于监听值的变化，remove 用于停止监听 addStatusListener / removeStatusListener 添加动画状态变化的监听，remove 停止监听，Animation 的状态有 4 种：dismissed 动画初始状态，反向运动结束状态，forward 动画正向运动状态，reverse 动画反向运动状态，completed 动画正向运动结束状态。 drive 方法用于连接动画，例如官方举的例子，因为 AnimationController 是其子类，所以也拥有该方法 123456Animation&lt;Alignment&gt; _alignment1 = _controller.drive( AlignmentTween( begin: Alignment.topLeft, end: Alignment.topRight, ), ); 上面的例子将 AnimationController 和 AlignmentTween 结合成一个 Animation&lt;Alignment&gt; 动画，当然 drive 可以结合多个动画，例如 123456Animation&lt;Alignment&gt; _alignment3 = _controller .drive(CurveTween(curve: Curves.easeIn)) .drive(AlignmentTween( begin: Alignment.topLeft, end: Alignment.topRight, )); 因为 Animation 是抽象类，所以具体的还是需要通过 AnimationController 来实现。 AnimationController123456789101112AnimationController(&#123; double value, // 设置初始的值 this.duration, // 动画的时长 this.debugLabel, // 主要是用于 `toString` 方法中输出信息 this.lowerBound = 0.0, // 最小范围 this.upperBound = 1.0, // 最大范围 // AnimationController 结束时候的行为，有 `normal` 和 `preserve` 两个值可选 this.animationBehavior = AnimationBehavior.normal, // 这个属性可以通过 with `SingleTickerProviderStateMixin` // 或者 `TickerProviderStateMixin` 引入到 `State`，通过 `this` 指定 @required TickerProvider vsync, &#125;) AnimationController 控制动画的方法有这么几个 forward 启动动画，和上面提到的 forward 状态不一样 reverse 方向启动动画 repeat 重复使动画运行 stop 停止动画 reset 重置动画 大概了解了 AnimationController ，接下来通过一个实际的小例子来加深下印象，例如实现如下效果，点击开始动画，结束后再点击反向动画 123456789101112131415161718192021222324252627282930313233343536373839404142class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; @override void initState() &#123; super.initState(); _animationController = AnimationController( vsync: this, duration: Duration(milliseconds: 1000), lowerBound: 28.0, upperBound: 50.0); // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); &#125; @override void dispose() &#123; // 一定要释放资源 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Center( child: IconButton( icon: Icon(Icons.android, color: Colors.green[500], size: _animationController.value), onPressed: () &#123; // 根据状态执行不同动画运动方式 if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;), ), ); &#125;&#125; 那么如果要实现无限动画呢，那就可以通过 addStatusListener 监听动画的状态来执行，修改代码，在 initState 增加如下代码 12345678_animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); // 正向结束后开始反向 else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); // 反向结束后开始正向 &#125;); _animationController.forward(); // 启动动画 把 Center 的 child 替换成一个 Icon，因为上面已经启动了动画，所以不需要再用点击去启动了，运行后就会无限放大缩小循环跑了。 在这个例子中，通过设置 AnimationController 的 lowerBound 和 upperBound 实现了动画的变化范围，接下来，将通过 Tween 来实现动画的变化范围。先看下 Tween 的一些介绍。 Tween 1234567891011121314&gt; /// A linear interpolation between a beginning and ending value.&gt; ///&gt; /// [Tween] is useful if you want to interpolate across a range.&gt; ///&gt; /// To use a [Tween] object with an animation, call the [Tween] object's&gt; /// [animate] method and pass it the [Animation] object that you want to&gt; /// modify.&gt; ///&gt; /// You can chain [Tween] objects together using the [chain] method, so that a&gt; /// single [Animation] object is configured by multiple [Tween] objects called&gt; /// in succession. This is different than calling the [animate] method twice,&gt; /// which results in two separate [Animation] objects, each configured with a&gt; /// single [Tween].&gt; Tween 是一个线性插值(如果要修改运动的插值，可以通过 CurveTween 来修改)，所以在线性变化的时候很有用 通过调用 Tween 的 animate 方法生成一个 Animation(animate 一般传入 AnimationController) 还可以通过 chain 方法将多个 Tween 结合到一起，这样就不需要多次去调用 Tween 的 animate 方法来生成动画了，多次调用 animate 相当于使用了两个分开的动画来完成效果，但是 chain 结合到一起就是一个动画过程 那么对前面的动画进行一些修改，通过 Tween 来控制值的变化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; Animation _scaleAnimation; // 动画实例，用于修改值的大小 @override void initState() &#123; super.initState(); _animationController = AnimationController(vsync: this, duration: Duration(milliseconds: 1000)); // 不通过 `lowerBound` 和 `upperBound` 设置范围，改用 `Tween` // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); _animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;); // 通过 `Tween` 的 `animate` 生成一个 Animation // 再通过 Animation.value 进行值的修改 _scaleAnimation = Tween(begin: 28.0, end: 50.0).animate(_animationController); _animationController.forward(); &#125; @override void dispose() &#123; // 一定要释放资源 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Center( // 通过动画返回的值，修改图标的大小 child: Icon(Icons.favorite, color: Colors.red, size: _scaleAnimation.value), ), ); &#125;&#125; 再次运行，还是能过达到之前的效果，那么很多小伙伴肯定会问了，「**，加了那么多代码，效果还是和以前的一样，还不如不加…」好吧，我无法反驳，但是如果要实现多个动画呢，那么使用 Tween 就有优势了，比如我们让图标大小变化的同时，颜色和位置也发生变化，只通过 AnimationController 要怎么实现? 又比如说，运动的方式要先加速后减速，那只通过 AnimationController 要如何实现？这些问题通过 Tween 就会非常方便解决，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; Animation _scaleAnimation; // 用于控制图标大小 Animation&lt;Color&gt; _colorAnimation; // 控制图标颜色 Animation&lt;Offset&gt; _positionAnimation; // 控制图标位置 @override void initState() &#123; super.initState(); _animationController = AnimationController(vsync: this, duration: Duration(milliseconds: 2000)); // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); _animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;); // 通过 `chain` 结合 `CurveTween` 修改动画的运动方式，曲线类型可自行替换 _scaleAnimation = Tween(begin: 28.0, end: 50.0).chain(CurveTween(curve: Curves.decelerate)).animate(_animationController); _colorAnimation = ColorTween(begin: Colors.red[200], end: Colors.red[900]) .chain(CurveTween(curve: Curves.easeIn)) .animate(_animationController); _positionAnimation = Tween(begin: Offset(100, 100), end: Offset(300, 300)) .chain(CurveTween(curve: Curves.bounceInOut)) .animate(_animationController); _animationController.forward(); // 启动动画 &#125; @override void dispose() &#123; _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Stack( children: &lt;Widget&gt;[ Positioned( child: Icon(Icons.favorite, color: _colorAnimation.value, size: _scaleAnimation.value), left: _positionAnimation.value.dx, top: _positionAnimation.value.dy, ) ], ), ); &#125;&#125; 那么最后的效果图 当然，Flutter 中已经实现的 Tween 还有很多，包括 BorderTween、TextStyleTween、ThemeDataTween ..等等，实现的方式都是类似的，小伙伴们可以自己慢慢看。 AnimationWidget在上面的例子中，都是通过 addListener 监听动画值变化，然后通过 setState 方法来实现刷新效果。那么 Flutter 也提供了一个部件 AnimationWidget 来实现动画部件，就不需要一直监听了，还是实现上面的例子 1234567891011121314151617181920212223242526class RunningHeart extends AnimatedWidget &#123; final List&lt;Animation&gt; animations; // 传入动画列表 final AnimationController animationController; // 控制动画 RunningHeart(&#123;this.animations, this.animationController&#125;) // 对传入的参数进行限制(当然你也可以不做限制) : assert(animations.length == 3), assert(animations[0] is Animation&lt;Color&gt;), assert(animations[1] is Animation&lt;double&gt;), assert(animations[2] is Animation&lt;Offset&gt;), super(listenable: animationController); @override Widget build(BuildContext context) &#123; return Stack( children: &lt;Widget&gt;[ Positioned( // 之前的 animation 都通过 animations 参数传入到 `AnimationWidget` child: Icon(Icons.favorite, color: animations[0].value, size: animations[1].value), left: animations[2].value.dx, top: animations[2].value.dy, ) ], ); &#125;&#125; 其实内部返回的部件和前面的是一样的 接着对 _AnimationDemoPageState 类进行修改，注释 initState 中的 _animationController.addListener 所有内容，然后将 body 属性替换成新建的 RunningHeart 部件，记得传入的动画列表的顺序 1234body: RunningHeart( animations: [_colorAnimation, _scaleAnimation, _positionAnimation], animationController: _animationController, ) 这样就实现了刚才一样的效果，并且没有一直调用 setState 来刷新。 该部分代码查看 animation_main.dart 文件 StaggeredAnimationsFlutter 还提供了交错动画，听名字就可以知道，是按照时间轴，进行不同的动画，并且由同个AnimationController 进行控制。因为没有找到好的例子，原谅我直接搬官方的例子来讲，官方交错动画 demo 在继续看之前，先了解下 Interval 12345&gt; /// An [Interval] can be used to delay an animation. For example, a six second&gt; /// animation that uses an [Interval] with its [begin] set to 0.5 and its [end]&gt; /// set to 1.0 will essentially become a three-second animation that starts&gt; /// three seconds later.&gt; Interval 用来延迟动画，例如一个时长 6s 的动画，通过 Interval 设置其 begin 参数为 0.5，end 参数设置为 1.0，那么这个动画就会变成 3s 的动画，并且开始的时间延迟了 3s。 了解 Interval 功能后，就可以看下实例了，当然我们不和官方的 demo 一样，中间加个旋转动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class StaggeredAnim extends StatelessWidget &#123; final AnimationController controller; final Animation&lt;double&gt; opacity; final Animation&lt;double&gt; width; final Animation&lt;double&gt; height; final Animation&lt;EdgeInsets&gt; padding; final Animation&lt;BorderRadius&gt; border; final Animation&lt;Color&gt; color; final Animation&lt;double&gt; rotate; StaggeredAnim(&#123;Key key, this.controller&#125;): // widget 透明度 opacity = Tween(begin: 0.0, end: 1.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.0, 0.1, curve: Curves.ease))), // widget 宽 width = Tween(begin: 50.0, end: 150.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.1, 0.250, curve: Curves.ease))), // widget 高 height = Tween(begin: 50.0, end: 150.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.25, 0.375, curve: Curves.ease))), // widget 底部距离 padding = EdgeInsetsTween(begin: const EdgeInsets.only(top: 150.0), end: const EdgeInsets.only(top: .0)) .animate(CurvedAnimation(parent: controller, curve: Interval(0.25, 0.375, curve: Curves.ease))), // widget 旋转 rotate = Tween(begin: 0.0, end: 0.25) .animate(CurvedAnimation(parent: controller, curve: Interval(0.375, 0.5, curve: Curves.ease))), // widget 外形 border = BorderRadiusTween(begin: BorderRadius.circular(5.0), end: BorderRadius.circular(75.0)) .animate(CurvedAnimation(parent: controller, curve: Interval(0.5, 0.75, curve: Curves.ease))), // widget 颜色 color = ColorTween(begin: Colors.blue, end: Colors.orange) .animate(CurvedAnimation(parent: controller, curve: Interval(0.75, 1.0, curve: Curves.ease))), super(key: key); Widget _buildAnimWidget(BuildContext context, Widget child) &#123; return Container( padding: padding.value, alignment: Alignment.center, // 旋转变化 child: RotationTransition( turns: rotate, // turns 表示当前动画的值 * 360° 角度 child: Opacity( opacity: opacity.value, // 透明度变化 child: Container( width: width.value, // 宽度变化 height: height.value, // 高度变化 decoration: BoxDecoration( color: color.value, // 颜色变化 border: Border.all(color: Colors.indigo[300], width: 3.0), borderRadius: border.value), // 外形变化 ), ), ), ); &#125; @override Widget build(BuildContext context) &#123; // AnimatedBuilder 继承 AnimationWidget，用来快速构建动画部件 return AnimatedBuilder(animation: controller, builder: _buildAnimWidget); &#125;&#125; 然后修改 body 的参数，设置成我们的动画，当点击的时候就会启动动画 1234567891011121314GestureDetector( behavior: HitTestBehavior.opaque, onTap: _playAnim, child: Center( // 定义一个外层圈，能够使动画显眼点 child: Container( width: 300, height: 300, decoration: BoxDecoration( color: Colors.black.withOpacity(0.1), border: Border.all(color: Colors.black.withOpacity(0.5))), child: StaggeredAnim(controller: _controller), ), ), ) 看下最后的效果吧 该部分代码查看 staggered_animation_main.dart 文件 结束前，我们再讲一种比较简单的 Hreo 动画，用来过渡用。 Hero通过指定 Hero 中的 tag，在切换的时候 Hero 会寻找相同的 tag，并实现动画，具体的实现逻辑，这里可以推荐一篇文章 谈一谈Flutter中的共享元素动画Hero，里面写的很详细，就不造车轮了。当然这边还是得提供个简单的 demo 的，替换前面的 body 参数 12345678910body: Container( alignment: Alignment.center, child: InkWell( child: Hero( tag: 'hero_tag', // 这里指定 tag child: Image.asset('images/ali.jpg', width: 100.0, height: 100.0), ), onTap: () =&gt; Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; HeroPage())), ), ) 然后创建 HeroPage 界面，当然也可以是个 Dialog，只要通过路由实现即可 1234567891011121314class HeroPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Container( alignment: Alignment.center, child: InkWell( child: Hero(tag: 'hero_tag', child: Image.asset('images/ali.jpg', width: 200.0, height: 200.0)), onTap: () =&gt; Navigator.pop(context), ), ), ); &#125;&#125; 看下最后的效果图： 该部分代码查看 animation_main.dart 文件 这一部分讲的比较多，小伙伴可以慢慢消化，下节我会尽量填下之前留下的状态管理的坑。 最后代码的地址还是要的： 文章中涉及的代码：demos 基于郭神 cool weather 接口的一个项目，实现 BLoC 模式，实现状态管理：flutter_weather 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：flutter_shop]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(九)之弹窗和提示(SnackBar、BottomSheet、Dialog)]]></title>
    <url>%2Fposts%2F5da6faeb.html</url>
    <content type="text"><![CDATA[前面的小节把常用的一些部件都介绍了，这节介绍下 Flutter 中的一些操作提示。Flutter 中的操作提示主要有这么几种 SnackBar、BottomSheet、Dialog，因为 Dialog 样式比较多，放最后讲好了 SnackBarSnackBar 的源码相对简单 12345678const SnackBar(&#123; Key key, @required this.content, // 提示信息 this.backgroundColor, // 背景色 this.action, // SnackBar 尾部的按钮，用于一些回退操作等 this.duration = _kSnackBarDisplayDuration, // 停留的时长，默认 4000ms this.animation, // 进出动画 &#125;) 例如我们需要实现一个功能，修改某个值，修改后给用户一个提示，同时给用户一个撤销该操作的按钮，那么就可以通过 SnackBar 来简单实现。还有就是 SnackBar 可以和 floatingActionButton 完美的配合，弹出的时候不会遮挡住 fab 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class _PromptDemoPageState extends State&lt;PromptDemoPage&gt; &#123; var count = 0; @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; super.dispose(); &#125; // 自增操作 increase() &#123; setState(() =&gt; count++); &#125; // 自减操作 decrease() &#123; setState(() =&gt; count--); &#125; _changeValue(BuildContext context) &#123; increase(); Scaffold.of(context).showSnackBar(SnackBar( content: Text('当前值已修改'), action: SnackBarAction(label: '撤销', onPressed: decrease), duration: Duration(milliseconds: 2000))); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Prompt Demo'), ), body: Column(children: &lt;Widget&gt;[ Text('当前值：$count', style: TextStyle(fontSize: 20.0)), Expanded( // 为了方便拓展，我这边提取了 `snackBar` 的方法，并把按钮放在列表 child: ListView(padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ // SnackBar 需要提供一个包含 context，但是 context 不能是 Scaffold 节点下的 context，所以需要通过 Builder 包裹一层 Builder(builder: (context) =&gt; RaisedButton(onPressed: () =&gt; _changeValue(context), child: Text('修改当前值'))), ])) ]), // 当 SnackBar 弹出时，fab 会上移一段距离 floatingActionButton: Builder( builder: (context) =&gt; FloatingActionButton(onPressed: () =&gt; _changeValue(context), child: Icon(Icons.send))), ); &#125;&#125; 可以看下最后的效果图，请注意看 fab 和值的变化： BottomSheetBottomSheet 看命名就知道是从底部弹出的菜单，展示 BottomSheet 有两种方式，分别是 showBottomSheet 和 showModalBottomSheet，两种方式只有在展示类型上的差别，方法调用无差，而且 showBottomSheet 和 fab 有组合动画，showModalBottomSheet 则没有，看下实际的例子吧。在 ListView 中增加一个 BottomSheet 的按钮，因为 BottomSheet 需要的 context 也不能是 Scaffold 下的 context，所以需要通过 Builder 进行包裹一层，然后增加 _showBottomSheet 的方法 12345678910111213141516_showBottomSheet(BuildContext context) &#123; showBottomSheet( context: context, builder: (context) =&gt; ListView( // 生成一个列表选择器 children: List.generate( 20, (index) =&gt; InkWell( child: Container(alignment: Alignment.center, height: 60.0, child: Text('Item $&#123;index + 1&#125;')), onTap: () &#123; print('tapped item $&#123;index + 1&#125;'); Navigator.pop(context); &#125;), )), ); &#125; 把 showBottomSheet 替换成 showModalBottomSheet 就是另外一种展示方式了，内部不需要做任何改变，我们看下两种的运行效果： 可以看到 showBottomSheet 会充满整个屏幕，然后 fab 会跟随一起到 AppBar 的底部位置，而 showModalBottomSheet 展示的高度不会超过半个屏幕的高度，但是 fab 被其遮挡了。假如我们只需要展示 2-3 个 item，但是按照刚才的方式 showModalBottomSheet 的高度太高了，那我们可以在 ListView 外层包裹一层 Container，然后指定 height 即可 123456789101112131415161718_showModalBottomSheet(BuildContext context) &#123; showModalBottomSheet( context: context, builder: (context) =&gt; Container( child: ListView( children: List.generate( 2, (index) =&gt; InkWell( child: Container(alignment: Alignment.center, height: 60.0, child: Text('Item $&#123;index + 1&#125;')), onTap: () &#123; print('tapped item $&#123;index + 1&#125;'); Navigator.pop(context); &#125;), )), height: 120, ), ); &#125; 修改高度后的效果： Dialog相对于 SnackBar 和 BottomSheet，Dialog 的使用场景相对会更多，在 MaterialDesign 下，Dialog 主要有 3 种：AlertDialog，SimpleDialog 和 AboutDialog，当然在 Cupertino 风格下也有相应的 Dialog，因为这个系列以 MaterialDesign 风格为主，所以 Cupertiono 等下次有时间再写吧。 AlertDialog在 ListView 中增加一个 AlertDialog 的按钮，用于点击显示 AlertDialog 用，然后加入显示 AlertDilaog 的方法，并将按钮的 onPressed 指向该方法，Dialog 的 context 可以是 Scaffold 下的 context，所以不需要用 Builder 来包裹一层。 1234567891011121314151617181920212223242526_showAlertDialog() &#123; showDialog( // 设置点击 dialog 外部不取消 dialog，默认能够取消 barrierDismissible: false, context: context, builder: (context) =&gt; AlertDialog( title: Text('我是个标题...嗯，标题..'), titleTextStyle: TextStyle(color: Colors.purple), // 标题文字样式 content: Text(r'我是内容\(^o^)/~, 我是内容\(^o^)/~, 我是内容\(^o^)/~'), contentTextStyle: TextStyle(color: Colors.green), // 内容文字样式 backgroundColor: CupertinoColors.white, elevation: 8.0, // 投影的阴影高度 semanticLabel: 'Label', // 这个用于无障碍下弹出 dialog 的提示 shape: Border.all(), // dialog 的操作按钮，actions 的个数尽量控制不要过多，否则会溢出 `Overflow` actions: &lt;Widget&gt;[ // 点击增加显示的值 FlatButton(onPressed: increase, child: Text('点我增加')), // 点击减少显示的值 FlatButton(onPressed: decrease, child: Text('点我减少')), // 点击关闭 dialog，需要通过 Navigator 进行操作 FlatButton(onPressed: () =&gt; Navigator.pop(context), child: Text('你点我试试.')), ], )); &#125; 最后看下效果： SimpleDialogSimpleDialog 相比于 AlertDialog 少了 content 和 action 参数，多了 children 属性，需要传入 Widget 列表，那就可以自定义全部内容了。那我们这里就实现一个性别选择的 Dialog，选择后通过 Taost 提示选择的内容，Taost 就是之前导入的第三方插件，先看下效果图吧 只要实现 children 是个列表选择器就可以了，比较简单，直接上代码 123456789101112131415161718_showSimpleDialog() &#123; showDialog( barrierDismissible: false, context: context, builder: (context) =&gt; SimpleDialog( title: Text('我是个比较正经的标题...\n选择你的性别'), // 这里传入一个选择器列表即可 children: _genders .map((gender) =&gt; InkWell( child: Container(height: 40.0, child: Text(gender), alignment: Alignment.center), onTap: () &#123; Navigator.pop(context); Fluttertoast.showToast(msg: '你选择的性别是 $gender'); &#125;, )) .toList(), )); &#125; AboutDialogAboutDialog 主要是用于展示你的 App 或者别的相关东西的内容信息的，平时用的比较少，显示 AboutDialog 有两种方式可以展示，一种是前面一样的 showDialog 方法，传入一个 AboutDialog 实例，还有中方法是直接调用 showAboutDialog 方法。我们还是一样在列表加个按钮，并指向显示 AboutDialog 的事件。 1234567891011121314151617_showAboutDialog() &#123; showDialog( barrierDismissible: false, context: context, builder: (context) =&gt; AboutDialog( // App 的名字 applicationName: 'Flutter 入门指北', // App 的版本号 applicationVersion: '0.1.1', // App 基本信息下面会显示一行小字，主要用来显示版权信息 applicationLegalese: 'Copyright: this is a copyright notice topically', // App 的图标 applicationIcon: Icon(Icons.android, size: 28.0, color: CupertinoColors.activeBlue), // 任何你想展示的 children: &lt;Widget&gt;[Text('我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)')], )); &#125; 也可以通过 showAboutDialog 实现同样的效果 12345678910_showAboutDialog() &#123; showAboutDialog( context: context, applicationName: 'Flutter 入门指北', applicationVersion: '0.1.1', applicationLegalese: 'Copyright: this is a copyright notice topically', applicationIcon: Image.asset('images/app_icon.png', width: 40.0, height: 40.0), children: &lt;Widget&gt;[Text('我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)')], );&#125; 最后的效果： AboutDialog 会自带两个按钮 VIEW LICENSES 和 CLOSE，VIEW LICENSES 会跳转一个 Flutter Licenses 的网页，CLOSE 会关闭，至于为什么是英文的，是因为我们没有设置语言的原因，这个涉及到多语言，这边推荐几篇之前看过的文章，如果下次有时间的话会单独拿出来讲下 英文原版多语言设置，介绍两种方式实现 国人翻译版，未持续更新第二种方式 使用插件 in18 版 这边为了支持中文，我们做下如下的修改，首先打开 pubspec.ymal 文件加入如下支持 get package 后给 MaterialApp 加入如下属性，这样就会支持中文了，这里需要导入包 package:flutter_localizations/flutter_localizations.dart，再次运行，就会发现之前的英文变成中文了，当然你也可以设置成别的语言。 Dialog 状态保持假如有个需求，需要在弹出的 Dialog 显示当前被改变的值，然后通过按钮可以修改这个值 ，该如何实现。相信很多小伙伴都会这么认为，通过 setState 来修改不就行了吗，没错，我一开始的确这么去实现的，我们先看下代码好了，增加一个 DialogState 按钮，然后指向对应的点击事件 1234567891011121314151617181920212223242526272829_showStateDialog() &#123; showDialog( context: context, barrierDismissible: false, builder: (context) =&gt; SimpleDialog( title: Text(&apos;我这边能实时修改状态值&apos;), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ Text(&apos;当前的值是： $_count&apos;, style: TextStyle(fontSize: 18.0)), Padding( padding: const EdgeInsets.symmetric(vertical: 12.0), child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( onPressed: increase, child: Text(&apos;点我自增&apos;), ), RaisedButton( onPressed: decrease, child: Text(&apos;点我自减&apos;), ), RaisedButton( onPressed: () =&gt; Navigator.pop(context), child: Text(&apos;点我关闭&apos;), ) ]), ) ], )); &#125; 然后我们运行看下 诶诶诶，怎么 Dialog 的值不改变呢，明明界面上的已经修改了啊。所以说图样图森破咯，看下官方对 showDialog 方法的解释吧 12345// This function takes a `builder` which typically builds a [Dialog] widget.// Content below the dialog is dimmed with a [ModalBarrier]. The widget// returned by the `builder` does not share a context with the location that// `showDialog` is originally called from. Use a [StatefulBuilder] or a// custom [StatefulWidget] if the dialog needs to update dynamically. 糟糕透的翻译又来了：该方法通过 builder 参数来传入一个 Dialog 部件，dialog 下的内容被一个「模态障碍」阻隔，builder 的 context 和调用 showDialog 时候的 context 不是共享的，如果需要动态修改 dialog 的状态值，需要通过 StatefulBuilder 或者自定义 dialog 继承于 StatefulWidget 来实现 所以解决的方法很明确，对上面的代码进行修改，在外层嵌套一个 StatefulBuilder 部件 12345678910111213141516171819202122232425262728293031323334_showStateDialog() &#123; showDialog( context: context, barrierDismissible: false, // 通过 StatefulBuilder 来保存 dialog 状态 // builder 需要传入一个 BuildContext 和 StateSetter 类型参数 // StateSetter 有一个 VoidCallback，修改状态的方法在这写 builder: (context) =&gt; StatefulBuilder( builder: (context, dialogStateState) =&gt; SimpleDialog( title: Text('我这边能实时修改状态值'), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ Text('当前的值是： $_count', style: TextStyle(fontSize: 18.0)), Padding( padding: const EdgeInsets.symmetric(vertical: 12.0), child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( // 通过 StatefulBuilder 的 StateSetter 来修改值 onPressed: () =&gt; dialogStateState(() =&gt; increase()), child: Text('点我自增'), ), RaisedButton( onPressed: () =&gt; dialogStateState(() =&gt; decrease()), child: Text('点我自减'), ), RaisedButton( onPressed: () =&gt; Navigator.pop(context), child: Text('点我关闭'), ) ]), ) ], ))); &#125; 然后再运行下，可以看到 dialog 和界面的值保持一致了 以上部分代码查看 prompt_main.dart 文件 差不多常用弹窗和操作提示就在这了，好好消化吧~]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(八)之Sliver组件及NestedScrollView]]></title>
    <url>%2Fposts%2Ff600e8a7.html</url>
    <content type="text"><![CDATA[上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去 在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。 SliverAppBar相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性 1234567891011121314151617181920212223const SliverAppBar(&#123;Key key,this.leading,this.automaticallyImplyLeading = true,this.title,this.actions,this.flexibleSpace, // 通过这个来设置背景this.bottom,this.elevation,this.forceElevated = false, // 是否显示层次感this.backgroundColor,this.brightness,this.iconTheme,this.textTheme,this.primary = true,this.centerTitle,this.titleSpacing = NavigationToolbar.kMiddleSpacing,this.expandedHeight, // 展开的高度// 以下三个等例子再讲this.floating = false,this.pinned = false,this.snap = false,&#125;) 别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件 12345678910111213141516171819202122232425262728293031323334353637class SliverDemoPage extends StatelessWidget &#123;@overrideWidget build(BuildContext context) &#123;return Scaffold(body: CustomScrollView(slivers: &lt;Widget&gt;[SliverAppBar(title: Text('Sliver Demo'),centerTitle: true,// 展开的高度expandedHeight: 300.0,// 强制显示阴影forceElevated: true,// 设置该属性，当有下滑手势的时候，就会显示 AppBar// floating: true,// 该属性只有在 floating 为 true 的情况下使用，不然会报错// 当上滑到一定的比例，会自动把 AppBar 收缩（不知道是不是 bug，当 AppBar 下面的部件没有被 AppBar 覆盖的时候，不会自动收缩）// 当下滑到一定比例，会自动把 AppBar 展开// snap: true,// 设置该属性使 Appbar 折叠后不消失// pinned: true,// 通过这个属性设置 AppBar 的背景flexibleSpace: FlexibleSpaceBar(// title: Text('Expanded Title'),// 背景折叠动画collapseMode: CollapseMode.parallax,background: Image.asset('images/timg.jpg', fit: BoxFit.cover),),),// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，// 可以在 child 属性加入需要展示的部件SliverFillRemaining(child: Center(child: Text('FillRemaining', style: TextStyle(fontSize: 30.0))),),]));&#125;&#125; 这里分别给出不同的动图来查看三个属性的影响 如果设置了 floating 属性，当有下拉动作时，会显示 AppBar 如果设置了 snap 属性，滑动距离达到一定值后，会根据滑动方向收缩或者展开 如果设置了 pinned 属性，那么 AppBar 就会在界面上不会消失 以上的效果图把 SliverFillRemaining 换成列表 SliverFixedExtentList 效果可能会更加明显，这边给小伙伴自己替换测试吧。 SliverFillViewport这边提到了 SliverFillRemaining 用来填充视图，那么顺带提下 SliverFillViewport 这个部件 12345const SliverFillViewport(&#123;Key key,@required SliverChildDelegate delegate, // 这个 delegate 同 SliverGridthis.viewportFraction = 1.0, // 同屏幕的比例值，1.0 为一个屏幕大小&#125;) 如果一个滑动列表，每个 item 需要占满一个屏幕或者更大，可以使用该部件生成列表，但是如果 item 的高度小于一个屏幕高度，那就不太推荐了，在首尾会用空白 item 来把未填满的补上，就是首尾都会留空白。我们使用 SliverFillViewport 对 SliverFillRemaning 进行替换 12345SliverFillViewport(viewportFraction: 1.0,delegate: SliverChildBuilderDelegate((_, index) =&gt; Container(child: Text('Item $index'), alignment: Alignment.center, color: colors[index % 4]),childCount: 10)) 效果就不展示了，可自行运行查看。 SliverToBoxAdapter还记得上节最后的代码中，有使用 SliverToBoxAdapter 这个部件吗，这个部件只需要传入一个 child 属性。因为在 CustomScrollView 中只允许传入 Sliver 部件，那么类似 Container 等普通部件就不可以使用了，那么这样就需要更多的 Sliver 组件才能完成视图，所以为了方便，直接通过 SliverToBoxAdapter 对普通部件进行包裹，这样就成为一个 Sliver 部件了。总结下 SliverToBoxAdapter 的功能就是 把一个普通部件包裹成为 Sliver 部件，例子就不举了，上节已经有了。 SliverPadding那么在 CustomScrollView 中部件之间如何设置间距呢，可能你会想到用 SliverToBoxAdapter 包裹一个 Padding 来处理，当然没问题。不过 Flutter 也提供了专门的部件 SliverPadding 使用方式同 Padding，但是需要传入一个 sliver 作为子类。 SliverPersistentHeaderFlutter 中，为我们提供了这么一个作为头部的部件 SliverPersistentHeader，这个部件可以根据滚动的距离缩小高度，有点类似 SliverAppBar 的背景效果。 123456const SliverPersistentHeader(&#123;Key key,@required this.delegate, // SliverPersistentHeaderDelegate，用来创建展示内容this.pinned = false, // 同 SliverAppBar 属性this.floating = false,&#125;) SliverPersistentHeaderDelegate这个代理比较特殊，是个抽象类，也就是需要我们自己进行继承后再实现方法。SliverPersistentHeaderDelegate 需要提供一个最大值，最小值，展示内容，以及更新部件条件 比如我们需要展示一个最大高度 300，最小高度 100，居中的文字，那么我们可以这么写这个代理类 123456789101112131415161718class DemoHeader extends SliverPersistentHeaderDelegate &#123;@overrideWidget build(BuildContext context, double shrinkOffset, bool overlapsContent) &#123;return Container(color: Colors.pink,alignment: Alignment.center,child: Text('我是一个头部部件', style: TextStyle(color: Colors.white, fontSize: 30.0)));&#125; // 头部展示内容@overridedouble get maxExtent =&gt; 300.0; // 最大高度@overridedouble get minExtent =&gt; 100.0; // 最小高度@overridebool shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) =&gt; false; // 因为所有的内容都是固定的，所以不需要更新&#125; 使用 SliverPersistentHeader 代替 SliverAppBar，看下效果 1234567891011121314151617class SliverDemoPage extends StatelessWidget &#123;final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];@overrideWidget build(BuildContext context) &#123;return Scaffold(body: CustomScrollView(slivers: &lt;Widget&gt;[SliverPersistentHeader(delegate: DemoHeader(), pinned: true),// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，// 可以在 child 属性加入需要展示的部件SliverFillRemaining(child: Center(child: Text('FillRemaining', style: TextStyle(fontSize: 30.0))),),]));&#125;&#125; 最后的效果图 当然，为了方便扩展，需要重新封装下 Delegate ，通过外部传入范围和展示内容 123456789101112131415161718192021222324252627282930// 自定义 SliverPersistentHeaderDelegateclass CustomSliverPersistentHeaderDelegate extends SliverPersistentHeaderDelegate &#123;final double max; // 最大高度final double min; // 最小高度final Widget child; // 需要展示的内容CustomSliverPersistentHeaderDelegate(&#123;@required this.max, @required this.min, @required this.child&#125;)// 如果 assert 内部条件不成立，会报错: assert(max != null),assert(min != null),assert(child != null),assert(min &lt;= max),super();// 返回展示的内容，如果内容固定可以直接在这定义，如果需要可扩展，这边通过传入值来定义@overrideWidget build(BuildContext context, double shrinkOffset, bool overlapsContent) =&gt; child;@overridedouble get maxExtent =&gt; max; // 返回最大高度@overridedouble get minExtent =&gt; min; // 返回最小高度@overridebool shouldRebuild(CustomSliverPersistentHeaderDelegate oldDelegate) &#123;// 是否需要更新，这里我们定义当高度范围和展示内容被替换的时候进行刷新界面return max != oldDelegate.max || min != oldDelegate.min || child != oldDelegate.child;&#125;&#125; 然后我们就可以愉快的使用了，不需要每个 Delegate 都重新写一遍，例如替换下刚才写死的 DemoHeader 12345678SliverPersistentHeader(// 属性同 SliverAppBarpinned: true,floating: true,// 因为 SliverPersistentHeaderDelegate 是一个抽象类，所以需要自定义delegate: CustomSliverPersistentHeaderDelegate(max: 300.0, min: 100.0, child: Text('我是一个头部部件', style: TextStyle(color: Colors.white, fontSize: 30.0))),), 例如需要替换成一张图片，直接将 Text 修改成 Image 即可。 以上部分代码查看 sliver_main.dart 文件 NestedScrollView讲到这了，不得不提下 Scrollable 中比较重要的一员 NestedScrollView，先看下官方的解释 12/// A scrolling view inside of which can be nested other scrolling views, with/// their scroll positions being intrinsically linked. 糟透了的翻译 X 1：一个内部能够嵌套其他滚动部件，并使其滚动位置联结到一起的滚动部件 1234/// The most common use case for this widget is a scrollable view with a/// flexible [SliverAppBar] containing a [TabBar] in the header (build by/// [headerSliverBuilder], and with a [TabBarView] in the [body], such that the/// scrollable view's contents vary based on which tab is visible. 糟透了的翻译 X 2：最常用的情况，就是在其 headerSliverBuilder 中使用携带 TabBar 的 SliverAppBar（就是使用 SliverAppBar 的 bottom 属性添加 tab 切换也），其 body 属性使用 TabBarView 来展示 Tab 页的内容，这样通过切换 Tab 页就能展示该页下的展示内容。 看下 headerSliverBuilder 的定义 1234567/// Signature used by [NestedScrollView] for building its header.////// The `innerBoxIsScrolled` argument is typically used to control the/// [SliverAppBar.forceElevated] property to ensure that the app bar shows a/// shadow, since it would otherwise not necessarily be aware that it had/// content ostensibly below it.typedef NestedScrollViewHeaderSliversBuilder = List&lt;Widget&gt; Function(BuildContext context, bool innerBoxIsScrolled); 糟透了的翻译 X 3：用于构建 NestScrollView 的头部部件，innerBoxIsScrolled 主要用来控制 SliverAppBar 的 forceElevated 属性，当内部内容滚动时，显示 SliverAppbar 的阴影，主要用来提醒内部的内容低于 SliverAppBar （相当于给人一种物理层次感，否则很容易被认为，头部和内容是连接在一起的） 接下来看下 NestedScrollView 内部个人觉得有点重要的一个方法 sliverOverlapAbsorberHandleFor 12345678910111213/// Returns the [SliverOverlapAbsorberHandle] of the nearest ancestor/// [NestedScrollView].////// This is necessary to configure the [SliverOverlapAbsorber] and/// [SliverOverlapInjector] widgets.////// For sample code showing how to use this method, see the [NestedScrollView]/// documentation.static SliverOverlapAbsorberHandle sliverOverlapAbsorberHandleFor(BuildContext context) &#123; final _InheritedNestedScrollView target = context.inheritFromWidgetOfExactType(_InheritedNestedScrollView); assert(target != null, 'NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.'); return target.state._absorberHandle;&#125; 请注意到中间的注释 糟透了的翻译 X 4：这个方法返回的值对于 SliverOverlapAbsorber 和 SliverOverlapInjector 部件是非常重要的参数 接着请注意代码中的那段 assert 中的文字 糟透了的翻译 X 5：sliverOverlapAbsorberHandleFor 传入的参数 context 中必须包含 NestedScrollView SliverOverlapAbsorber这边又引入了两个部件 SliverOverlapAbsorber + SliverOverlapInjector 还是看源码的解释吧 1234567891011/// Creates a sliver that absorbs overlap and reports it to a/// [SliverOverlapAbsorberHandle].////// The [handle] must not be null.////// The [child] must be a sliver.const SliverOverlapAbsorber(&#123; Key key, @required this.handle, Widget child,&#125;) 糟透了的翻译 X 6：一个 sliver 部件，用于把部件重叠的高度反馈给 SliverOverlapAbsorberHandle，而且指明了 handle 不能空，可以通过 NestedScrollView 的 sliverOverlapAbsorberHandleFor 方法来赋值，并且 child 必须是个 sliver 部件，也就是说我们的 SliverAppBar 需要放到 SliverOverlapAbsorber 里面。 SingleChildScrollView123456789/// Creates a sliver that is as tall as the value of the given [handle]'s/// layout extent.////// The [handle] must not be null.const SliverOverlapInjector(&#123; Key key, @required this.handle, Widget child,&#125;) 糟透了的翻译 X 7：创建一个和指定的 handle 一样高度的 sliver 部件，这个 handle 同 SliverOverlapAbsorber 的 handle 保持一致即可。 分析完源码后，例子的目标很明确，使用 SliverAppBar + TabBar + TabBarView，先看下最后的效果图吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class NestedScrollDemoPage extends StatelessWidget &#123;final _tabs = &lt;String&gt;['TabA', 'TabB'];final colors = &lt;Color&gt;[Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];@overrideWidget build(BuildContext context) &#123;return Scaffold(body: DefaultTabController(length: _tabs.length,child: NestedScrollView(headerSliverBuilder: (context, innerScrolled) =&gt; &lt;Widget&gt;[SliverOverlapAbsorber(// 传入 handle 值，直接通过 `sliverOverlapAbsorberHandleFor` 获取即可handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),child: SliverAppBar(pinned: true,title: Text('NestedScroll Demo'),expandedHeight: 200.0,flexibleSpace: FlexibleSpaceBar(background: Image.asset('images/timg.jpg', fit: BoxFit.cover)),bottom: TabBar(tabs: _tabs.map((tab) =&gt; Text(tab, style: TextStyle(fontSize: 18.0))).toList()),forceElevated: innerScrolled,),)],body: TabBarView(children: _tabs// 这边需要通过 Builder 来创建 TabBarView 的内容，否则会报错// NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView..map((tab) =&gt; Builder(builder: (context) =&gt; CustomScrollView(// key 保证唯一性key: PageStorageKey&lt;String&gt;(tab),slivers: &lt;Widget&gt;[// 将子部件同 `SliverAppBar` 重叠部分顶出来，否则会被遮挡SliverOverlapInjector(handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),SliverGrid(delegate: SliverChildBuilderDelegate((_, index) =&gt; Image.asset('images/ali.jpg'),childCount: 8),gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 4, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0)),SliverFixedExtentList(delegate: SliverChildBuilderDelegate((_, index) =&gt; Container(child: Text('$tab - item$&#123;index + 1&#125;',style: TextStyle(fontSize: 20.0, color: colors[index % 6])),alignment: Alignment.center),childCount: 15),itemExtent: 50.0)],),)).toList()))),);&#125;&#125; 使用的部件和之前讲的没啥大区别，就是多了 SliverOverlapAbsorber 和 SliverOverlapInjector 没啥难度 以上部分代码查看 nested_scroll_main.dart 文件 sliver 部件常用的也就那么多了，望小伙伴好好吸收，跟着例子撸撸代码，撸顺下思路]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(七)之滑动部件]]></title>
    <url>%2Fposts%2F8d9ab46a.html</url>
    <content type="text"><![CDATA[前面的小节基本上讲完了常用的部件和容器部件，也可以完成很多的界面，但是又一个问题，假如我们要显示一段文字，比如将 一段又臭又长的文字 在界面上显示 1000 次，不难完成吧 12// ..省略一些无关代码body: Text('一段又臭又长的文字' * 1000, softWrap: true) 很简单，运行到手机…「诶诶诶，**，怎么只显示了一部分，剩下的怎么画不下去」 日常开发中，会遇到很多这种情况，许多界面不是一页就能够显示完的。那么这里提下可滑动的容器部件 SingleChildScrollView这个部件非常简单，不贴源码了。最简单的使用方式只需要提供一个 child 即可。现在给前面写的 Text 包裹上一层 SingleChildScrollView 然后再运行，文字全部都展示出来了。 如果需要实现一个垂直的滚动列表，可以直接通过 SingleChildScrollView 包裹 Column 来实现，列表内容全部塞到 Column 即可 123456789101112131415161718192021222324class SingleChildScrollDemoPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; /// letters 自由发挥吧...一定要大量，大量，大量 List&lt;String&gt; letters = [......]; return Scaffold( appBar: AppBar( title: Text('Single Child Demo'), ), body: SingleChildScrollView( child: Center( child: Column( children: List.generate( letters.length, (index) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Text(letters[index], style: TextStyle(fontSize: 18.0)), )), ), )), ); &#125;&#125; 运行结果会根据你的 letters 不同而不同，这边就不贴效果图了，反正你可以看到一串列表… 那么如果需要实现横向滚动列表呢，稍稍做下修改就行了 123456789101112131415161718body: SingleChildScrollView( // 设置滚动方向 scrollDirection: Axis.horizontal, child: Center( // 修改为 `Row` 即可 child: Row( children: List.generate( letters.length, // 如果你的 letters 数量比较少，推荐加个 `Container` 把宽度指定大点 (index) =&gt; Container( child: Padding( padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 6.0), child: Text(letters[index], style: TextStyle(fontSize: 18.0)), ), width: 30.0)), ), )) 效果图也不贴了，都比较简单。 该部分代码查看 single_child_scroll_main.dart 文件* ListView平时开发 Android 的时候，如果有相同格式的列表要实现，一般会使用 ListView 或者 RecyclerView 来实现，Flutter 也提供了类似的部件 ListView 实现 ListView 的方法主要有 通过 ListView 设置 children 属性实现 通过 ListView.custom 实现 通过 ListView.builder 实现 通过 ListView.separated 实现带分割线列表 ListView children第一种方法实现列表，和通过 SingleChildScrollView + Column / Row 的方法比较类似，不过可以直接通过指定 ListView 的 scrollDirection 就可以了。 1234567891011body: ListView( // 通过修改滑动方向设置水平或者垂直方向滚动 scrollDirection: Axis.vertical, // 通过 iterable.map().toList 和 List.generate 方法效果是一样的 children: letters .map((s) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: Center( child: Text(s)))) .toList()), ListView.custom1234567891011body: ListView.custom( // 指定 item 的高度，可以加快渲染的速度 itemExtent: 40.0, // item 代理 childrenDelegate: SliverChildBuilderDelegate( // IndexedWidgetBuilder，根据 index 设置 item 中需要变化的数据 (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.red))), // 指定 item 的数量 childCount: letters.length, )), 如果每个 item 的高度可以确定，那么推荐通过 itemExtent 来设置 item 的高度/宽度，能够加快 ListView 的渲染速度。如果不指定高度/宽度，ListView 需要根据每个 item 来计算 ListView 的高度，这个计算过程是需要消耗时间和资源的 ListView.builder该方法同 custom 类似，custom 需要通过一个 Delegate 生成 item，该方法直接通过 builder 生成，同时也可以直接指定 item 的高度 12345body: ListView.builder( itemBuilder: (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.green))), itemExtent: 40.0, itemCount: letters.length),)), 相对比较简单，代码也比较少…就冲这点，我也愿意用这个方法 ListView.separated如果需要在每个 item 之间添加分割线，那么通过以上的方式实现就比较困难了，所以 Flutter 提供了 separated 方法用来快速构建带有分割线的 ListView 加入我们的 item 之间的分割线需要如下样式：奇数位和偶数位之间用黑色分割线，偶数位和奇数位之间用红色分割线 123456789// 需要分割线的时候才使用，不能指定 item 的高度body: ListView.separated( itemBuilder: (_, index) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Center(child: Text(letters[index], style: TextStyle(color: Colors.blue))), ), // 这里用来定义分割线 separatorBuilder: (_, index) =&gt; Divider(height: 1.0, color: index % 2 == 0 ? Colors.black : Colors.red), itemCount: letters.length), 最终的效果如下： 以上代码查看 listview_main.dart 文件 总结下：如果 item 的高度能够准确获取，一定要指定 itemExtent 的值，这样会更加高效，至于要通过哪种方式来生成，完全看个人喜好吧。 ExpansionTile既然讲到了 ListView，在日常开发中，折叠列表也是一个比较常用的，所以这边要提下 ExpansionTile 这个部件，因为相对比较简单，所以直接上代码了 123456789101112131415161718192021222324252627282930313233class ExpansionTilesDemoPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('ExpansionTile Demo'), ), body: ExpansionTile( // 最前面的 widget leading: Icon(Icons.phone_android), // 替换默认箭头// trailing: Icon(Icons.phone_iphone), title: Text('Parent'), // 默认是否展开 initiallyExpanded: true, // 展开时候的背景色 backgroundColor: Colors.yellow[100], // 展开或者收缩的回调，true 表示展开 onExpansionChanged: (expanded) =&gt; print('ExpansionTile is $&#123;expanded ? 'expanded' : 'collapsed'&#125;'), children: List.generate( 10, (position) =&gt; Container( padding: const EdgeInsets.only(left: 80.0), child: Text('Children $&#123;position + 1&#125;'), height: 50.0, alignment: Alignment.centerLeft, )), ), ); &#125;&#125; 这样就完成了一个折叠部件，看下最后的效果 那么实现折叠列表也就是通过 ListView 创建一个 ExpansionTile 列表即可，先准备下模拟的数据 123456789final _keys = ['ParentA', 'ParentB', 'ParentC', 'ParentD', 'ParentE', 'ParentF']; final Map&lt;String, List&lt;String&gt;&gt; _data = &#123; 'ParentA': ['Child A0', 'Child A1', 'Child A2', 'Child A3', 'Child A4', 'Child A5'], 'ParentB': ['Child B0', 'Child B1', 'Child B2', 'Child B3', 'Child B4', 'Child B5'], 'ParentC': ['Child C0', 'Child C1', 'Child C2', 'Child C3', 'Child C4', 'Child C5'], 'ParentD': ['Child D0', 'Child D1', 'Child D2', 'Child D3', 'Child D4', 'Child D5'], 'ParentE': ['Child E0', 'Child E1', 'Child E2', 'Child E3', 'Child E4', 'Child E5'], 'ParentF': ['Child F0', 'Child F1', 'Child F2', 'Child F3', 'Child F4', 'Child F5'] &#125;; 在平时开发过程中，后台返回的数据应该是列表嵌套列表的形式比较多，我这边主要就是为了偷懒就随便弄了，接着修改下 body 的代码 12345678910111213141516body: ListView( children: _keys .map((key) =&gt; ExpansionTile( title: Text(key), children: _data[key] .map((value) =&gt; InkWell( child: Container( child: Text(value), padding: const EdgeInsets.only(left: 80.0), height: 50.0, alignment: Alignment.centerLeft, ), onTap: () &#123;&#125;)) .toList(), )) .toList()), 最终的效果就是个折叠列表了 该部分代码查看 expansion_tile_main.dart 文件 当然了，只要数据到位，别说两层折叠，三层，四层甚至更多层都能够实现，源码中有实现四层的 demo，这边就不贴代码了，有需要的小伙伴可以查看源码 GridView生成列表可以通过 ListView 来实现，那么同样，实现网格列表 Flutter 也提供了 GridView 来实现，实现 GridView 的方法也很多…我数了下，大概有 10 种..对你没看错，就是那么多，(诶诶诶，别走啊…虽然方法有点多，但是，大同小异) GridView GridView 需要一个 gridDelegate，gridDelegate 目前有两种 SliverGridDelegateWithFixedCrossAxisCount 看命名就知道，值固定数量的，这个数量是只单排的数量 SliverGridDelegateWithMaxCrossAxisExtent 这个是设置最大宽度/高度，在这个值范围内取最大值，比如一排能给你排下 6 个，但是远不到设置的最大值，它绝不给你排 6 个 那么接下来的使用就比较简单了 1234567891011121314151617181920212223242526272829303132class GridViewDemoPage extends StatelessWidget &#123; // 自行设置 final List&lt;String&gt; letters = [ ..... ]; // 用于区分网格单元 final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('GridView Demo'), ), body: GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, // 单行的个数 mainAxisSpacing: 10.0, // 同 scrollDirection 挂钩，item 之间在主轴方向的间隔 crossAxisSpacing: 10.0, // item 之间在副轴方法的间隔 childAspectRatio: 1.0 // item 的宽高比 ), // 需要根据 index 设置不同背景色，所以使用 List.generate，如果不设置背景色，也可用 iterable.map().toList children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, child: Text(letters[index]), color: colors[index % 4], )), ), ); &#125;&#125; 关键地方已经添加了注释，跑下运行效果 接下来换一种 delegate 试试效果，当然这个最大值可以根据个人喜好来设置 123456789101112body: GridView( // 通过设置 `maxCrossAxisExtent` 来指定最大的宽度，在这个值范围内，会选取相对较大的值 gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent( maxCrossAxisExtent: 60.0, crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0), children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, child: Text(letters[index]), color: colors[index % 4], )), ) 最后效果： 为了方便写法呢，Flutter 对以上的两种方式进行了封装，省略了 delegate GridView.count/GridView.extent 直接看下如何修改 1234567891011121314// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithFixedCrossAxisCount` 代理的方法 body: GridView.count( crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0, crossAxisCount: 5, childAspectRatio: 2.0, children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ))), 1234567891011121314// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithMaxCrossAxisExtent` 代理的方法 body: GridView.extent( crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0, maxCrossAxisExtent: 60.0, children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ))), 运行的效果入和前面的相同 GridView.custom 这种生成方式，比 GridView 多了一个 childrenDelegate，childrenDelegate 主要分为两种，一种是通过 IndexedWidgetBuilder 来构建 item 的 SliverChildBuilderDelegate，还有一种是通过 List 来构建 item 的 SliverChildListDelegate，所以…这边直接有 4 中生成方式，当然，我们只需要了解 childrenDelegate 如何使用即可 12345678910111213body: GridView.custom( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 1.0), // item 通过 delegate 来生成，内部实现还是 `IndexedWidgetBuilder` childrenDelegate: SliverChildBuilderDelegate( (_, index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ), childCount: letters.length)), 1234567891011121314body: GridView.custom( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 1.0), // 内部通过返回控件列表实现 childrenDelegate: SliverChildListDelegate( List.generate( letters.length, (index) =&gt; Container( child: Text(letters[index]), alignment: Alignment.center, color: colors[index % 4], )), )), 运行效果也同上面。 GridView.builder 前面介绍的方法中，生成 item 的方式基本上是通过 List 进行转换的，在 custom 提到了 IndexWidgetBuilder 的生成方式，当然，在 ListView 的时候也用到了这种生成方式，当然 GridView 也有啊，要「雨露均沾」你说是吧 12345678// 通过 `IndexedWidgetBuilder` 来构建 item，别的参数同上 body: GridView.builder( // 这里又需要分两种 `gridDelegate` gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0), itemCount: letters.length, itemBuilder: (_, index) =&gt; Container(color: colors[index % 4], child: Text(letters[index]), alignment: Alignment.center)), 到这 10 种方式就说完了。终于可以歇一口气了。 该部分代码查看 gridview_main.dart 文件 CustomScrollView在平时的开发中，应该会遇到这么种情况，头部是一个 GridView 接下来拼接一些别的部件，然后再拼接一个列表，例如下图 因为 GridView 和 ListView 亮着都是可滑动的部件，直接拼接肯定会有「滑动冲突」，所以 Flutter 就提供了一个粘合剂，CustomScrollView，那么 Flutter 如何实现呢，因为会涉及到 Sliver 系列部件，所以这边先看下大概的代码，下节会补充 Sliver 系列部件的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class CustomScrollDemoPage extends StatelessWidget &#123; // 这边用的 A-Z 字母 final List&lt;String&gt; letters = [ ..... ]; final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('CustomScrollDemo'), ), body: CustomScrollView( // 这里需要传入 `Sliver` 部件，下节课填坑 slivers: &lt;Widget&gt;[ // SliverGrid 实现同 GridView 实现方式一样 // 同样 SliverGrid 有提供 `count`, `entent` 方法便于快速生成 SliverGrid SliverGrid( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Image.asset('images/ali.jpg'), onTap: () &#123;&#125;, ), childCount: 8), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 4, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0)), // 这里下节讲 SliverToBoxAdapter( child: Container( color: Colors.black12, margin: const EdgeInsets.symmetric(vertical: 10.0), child: Column(children: &lt;Widget&gt;[ Divider(height: 2.0, color: Colors.black54), Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), Text('我是一些别的东西..例如广告', textScaleFactor: 1.5, style: TextStyle(color: Colors.red)) ], ), Divider(height: 2.0, color: Colors.black54), ], mainAxisAlignment: MainAxisAlignment.spaceBetween), alignment: Alignment.center)), // SliverFixedExtentList 实现同 List.custom 实现类似 SliverFixedExtentList( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Container( child: Text(letters[index] * 10, style: TextStyle(color: colors[index % colors.length], letterSpacing: 2.0), textScaleFactor: 1.5), alignment: Alignment.center, ), onTap: () &#123;&#125;, ), childCount: letters.length), itemExtent: 60.0) ], ), ); &#125;&#125; 该部分代码查看 custom_scroll_main.dart 文件 滑动部件其实还有好几个，但是以上介绍的在平时开发过程中够用了，如果后期发现还需要别的部件，我会继续补上。在结束前，我们再说下如何通过 ScrollController 来控制 Scrollable 的滚动位置。例如我们需要实现，当滚动的距离大于一定距离的时候显示一个回到顶部的按钮，有了 ScrollController 就能够非常方便的实现 ScrollController因为需要根据滑动的距离显示回到顶部按钮，那么就需要通过一个状态位来控制按钮显隐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ScrollControllerDemoPage extends StatefulWidget &#123; @override _ScrollControllerDemoPageState createState() =&gt; _ScrollControllerDemoPageState();&#125;class _ScrollControllerDemoPageState extends State&lt;ScrollControllerDemoPage&gt; &#123; var _scrollController = ScrollController(); var _showBackTop = false; @override void initState() &#123; super.initState(); // 对 scrollController 进行监听 _scrollController.addListener(() &#123; // _scrollController.position.pixels 获取当前滚动部件滚动的距离 // window.physicalSize.height 获取屏幕高度 // 当滚动距离大于 800 后，显示回到顶部按钮 setState(() =&gt; _showBackTop = _scrollController.position.pixels &gt;= 800); &#125;); &#125; @override void dispose() &#123; // 记得销毁对象 _scrollController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('ScrollController Demo'), ), body: ListView( controller: _scrollController, children: List.generate( 20, (index) =&gt; Container(height: 50.0, alignment: Alignment.center, child: Text('Item $&#123;index + 1&#125;'))), ), floatingActionButton: _showBackTop // 当需要显示的时候展示按钮，不需要的时候隐藏，设置 null ? FloatingActionButton( onPressed: () &#123; // scrollController 通过 animateTo 方法滚动到某个具体高度 // duration 表示动画的时长，curve 表示动画的运行方式，flutter 在 Curves 提供了许多方式 _scrollController.animateTo(0.0, duration: Duration(milliseconds: 500), curve: Curves.decelerate); &#125;, child: Icon(Icons.vertical_align_top), ) : null, ); &#125;&#125; 最后的效果图]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(六)路由]]></title>
    <url>%2Fposts%2Fb89d6378.html</url>
    <content type="text"><![CDATA[上一节撸了个界面，虽然比较简单，但是把前面讲的知识串联了下，但是界面之间的跳转一直没说，这节就讲下 Flutter 中的「路由」来管理界面。 1、NavigatorFlutter 通过 Navigator 来进行页面之间的跳转，分为 push 系列和 pop 系列操作，带 push 方法为入栈操作，带 pop 方法为出栈操作。Navigator 的 push 方法分两类，一类是带 Name 的，需要在 MaterialApp 下将 routers 属性进行注册，否则将会找不到该路由，还有一个是不带 Name 的，可以通过 Router 直接跳转。 说那么多相信还不如直接上代码和图来的更直接。因为需要展示所有的跳转至少需要 3 个页面，所以我们创建最简单的三个界面，通过文字来区别不同的页面，因为需要调用带有 Name 的方法，所以需要先在 MaterialApp 对路由进行注册。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class DemoApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Learning Demo', // 在这里注册路由，关联 name 和界面 // '/' 表示根页面，也就是 home 所对应的页面，这边就不需要配置 home 属性了 routes: &#123;'/': (_) =&gt; APage(), '/page_b': (_) =&gt; BPage(), '/page_c': (_) =&gt; CPage()&#125;, debugShowCheckedModeBanner: false, ); &#125;&#125;/// Page A，Button 的跳转事件等会进行修改，目前先空着class APage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page A'), ), body: Center(child: RaisedButton(onPressed: () &#123;&#125;, child: Text('To Page B'))), ); &#125;&#125;/// Page Bclass BPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page B'), ), body: Center( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton(onPressed: () &#123;&#125;, child: Text('To Page C')), RaisedButton(onPressed: () &#123;&#125;, child: Text('Back Page A')) ])), ); &#125;&#125;/// Page Cclass CPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page C'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[RaisedButton(onPressed: () &#123;&#125;, child: Text('Back Last Page'))])), ); &#125;&#125; push / pushNamed 方式跳转 我们在 APage 的 RaiseButton 的 onPressed 方法加入如下代码 1Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage())); 或者 1Navigator.pushNamed(context, '/page_b'); 效果相同。跳转后，可以发现，在 BPage 的 AppBar 上有个返回按钮，点击可以返回 APage ，那么也就是说通过 push 或者 pushNamed 方式跳转的时候，界面堆栈的变化是直接在原来的堆栈上添加一个新的 page 为了凸显堆栈的变化，所以绘制的图中，会比使用的实际页面多一个，下图同 pushReplacement / pushReplacementNamed / popAndPushNamed 将 APage 中的跳转方式进行替换 1Navigator.pushReplacement(context, MaterialPageRoute(builder: (_) =&gt; BPage())); 或者 1Navigator.pushReplacementNamed(context, '/page_b'); 或者 123/ 如果是第一个界面跳转到下个界面，勿用，`BPage` 会显示返回按钮，但是点击后，界面会变黑// 因为 `APage` 已经不在堆栈中了，点击后堆栈就没有 `Page` 了，所以界面变黑Navigator.popAndPushNamed(context, '/page_b'); 效果相同，跳转后，可以发现 BPage 的返回按钮消失了，消失了，消失了，我们可以试下点击返回按键，发现 App 直接退出了，也就是说，BPage 替代了 APage 在堆栈中的位置。那么堆栈的变化图就是这样的 pushAndRemoveUntil / pushNamedAndRemoveUntil CASE 1 这个跳转方式需要通过 CPage 来协助完成，将 APage 的跳转方式修改为 push 方式，然后在 BPage 的第一个按钮加入如下代码 12Navigator.pushAndRemoveUntil(context, MaterialPageRoute(builder: (_) =&gt; CPage()), (Route router) =&gt; false); 或者 1Navigator.pushNamedAndRemoveUntil(context, '/page_c', (Route router) =&gt; false); 效果相同，点击 BPage 的跳转 CPage 按钮后，界面来到 CPage，然后发现还是没有返回按钮，没有返回按钮，没有返回按钮，点击下返回按键，然后发现 App 直接退出了，退出了，退出了，那么堆栈变化如图 CASE 2 你以为这两个方法只是为了把堆栈都清空吗，那就太图样图森破了，这边展示另一种。修改跳转的代码 12Navigator.pushAndRemoveUntil(context, MaterialPageRoute(builder: (_) =&gt; CPage()), ModalRoute.withName('/')); 或者 1Navigator.pushNamedAndRemoveUntil(context, '/page_c', ModalRoute.withName('/')); 点击跳转 CPage 以后，发现返回按钮又回来了…就这么回来了…只是修改了一个参数，点击返回按钮，又回到了 APage，你可以在 APage 跳转 BPage 中加入DPage EPage 等等更多的界面，只要保证 BPage 跳转 CPage 的方式不变，点击 CPage 的返回按钮，又回到 APage 了，所以…堆栈的变化图如下 SUMMARY 为什么会这样变化呢，还记得在 MaterialApp 中注册的 router 么，APage 的 name 对应的为 ‘/‘，也就是说，该方法会把堆栈中在 ModalRoute.withName 所对应的 page 上的所有都 pop 出堆栈，如果把参数换成 /page_b，然后在跳转 CPage 之前加入更多的界面，点击 CPage 的返回按钮，就会回到 BPage pop 在 BPage 的第二个按钮中加入 pop 操作 1Navigator.pop(context); 跳转到 BPage 后点击该按钮，界面回到 APage，那么堆栈的变化很明显了，如图 popUntil 这个方法还需要借助 CPage ，在 CPage 的按钮中加入 1Navigator.popUntil(context, ModalRoute.withName('/')); 点击返回按钮，界面跳过 BPage 回到了 APage，解释同 pushAndRemoveUntil 那么堆栈的变化也显而易见咯 2、Navigator 传值CASE 1 传值给下个界面 修改下 BPage 和 APage 的按钮点击事件 1234567891011121314151617class BPage extends StatelessWidget &#123; final String message; BPage(&#123;Key key, @required this.message&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; print('passed value: $message'); return Scaffold( // 省略相同代码 ); &#125;&#125;// APage 跳转事件Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage(message: 'Message From Page A'))); 点击 APage 可以查看控制台有输出 2019-03-17 00:04:06.854 12868-12888/com.kuky.demo.flutterartsdemosapp I/flutter: passed value: Message From Page A 也就是成功把值传递过来了。但是，需要传递参数的话，之前在 MaterialApp 下注册的路由就需要去除了。 CASE 2 传值给上个界面 这边可以查看下 pop 方法 12345@optionalTypeArgs // pop 可以传入一个可选参数 result，这个 result 也就是回传给上个页面的参数值了 static bool pop&lt;T extends Object&gt;(BuildContext context, [ T result ]) &#123; return Navigator.of(context).pop&lt;T&gt;(result); &#125; 既然知道 pop 如何传递值给上个界面，那么如何在上个界面接收这个参数呢，还是看下 push 方法 123456789101112131415@optionalTypeArgs static Future&lt;T&gt; push&lt;T extends Object&gt;(BuildContext context, Route&lt;T&gt; route) &#123; return Navigator.of(context).push(route); &#125;///@optionalTypeArgs Future&lt;T&gt; push&lt;T extends Object&gt;(Route&lt;T&gt; route) &#123; // ...省略无关代码 // 这边返回一个 Future 值，`pop` 所传递的值会在这边返回 return route.popped; &#125;/// The future completes with the value given to [Navigator.pop], if any.Future&lt;T&gt; get popped =&gt; _popCompleter.future; 官方的注释非常明白的指出，会在 Future 中携带 pop 传递的参数，那么我们对 APage跳转 BPage 以及 BPage 返回 APage 的逻辑进行修改 1234567/// APageNavigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage(message: 'Message From Page A'))) .then((value) =&gt; print('BACK MESSAGE =&gt; $value')); /// BPageNavigator.pop(context, 'Message back to PageA From BPage'); 点击返回后，能够在控制台发现有如下输入 2019-03-17 16:35:53.820 13417-13442/com.kuky.demo.flutterartsdemosapp I/flutter: BACK MESSAGE =&gt; Message back to PageA From BPage 上个页面成功接收到下个页面回传的数据。 CASE 3 通过系统返回按钮传值 在 CASE 2 情况下，通过按钮对返回事件进行监听，那加入我们需求没有这个按钮，只能通过系统默认的返回按钮，或者物理返回按键，那该如何传值呢，这里就需要用 WillpopScope 对系统的返回按钮进行监听。我们对 CPage 做下修改，在 Scaffold 外面包裹一个 WillpopScope 1234567891011121314151617181920212223242526class CPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return WillPopScope( child: Scaffold( appBar: AppBar( title: Text('Page C'), ), body: Center( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123; Navigator.popUntil(context, ModalRoute.withName('/')); &#125;, child: Text('Back Last Page')) ])), ), // 这里对系统返回按钮做监听.. // 如果返回的是 `true` 则相当于 `pop` 操作，返回 `false` 则只执行上一步的 `pop` 操作 // 例如双击返回退出，也是通过 `WillpopScope` 来进行监听 onWillPop: () async &#123; Navigator.pop(context, 'Hello~'); return false; &#125;); &#125;&#125; 通过返回按钮，BPage 会成功收到从 CPage 返回的 Hello~ 值 以上代码查看 router_main.dart 文件 3、路由切换动画假如说我们不想用系统自带的切换动画，需要弄一些比较酷炫的效果该怎么办，那就需要用到自定义路由切换动画了。直接修改 BPage 跳转 CPage 的代码 12345678910111213141516Navigator.push( context, PageRouteBuilder( // 返回目标页面 pageBuilder: (context, anim, _) =&gt; CPage(), // 切换动画的切换时长 transitionDuration: Duration(milliseconds: 500), // 切换动画的切换效果，系统自带的常用 Transition // ScaleTransition: 缩放 SlideTransition: 滑动 // RotationTransition: 旋转 FadeTransition: 透明度 transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( // Tween 是 flutter 的补间动画，等讲到动画的时候再提吧，这边先记住这么使用 scale: Tween(begin: 0.0, end: 1.0).animate(anim), // 这个值必须记得要传，否则会不显示界面 child: child, ))); 当再次点击跳转的时候，切换的动画就有开始自带的平滑效果变成缩放效果了。那如果要实现多个动画呢，例如边缩放，边改变透明度，也很容易实现，只需要将 child 替换成 Transition 即可 12345678910111213Navigator.push( context, PageRouteBuilder( pageBuilder: (context, anim, _) =&gt; CPage(), transitionDuration: Duration(milliseconds: 500), transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( scale: Tween(begin: 0.0, end: 1.0).animate(anim), // 替换即可，如果要加入更多的动画，替换 `child` 属性就可以了 child: FadeTransition( opacity: Tween(begin: 0.0, end: 1.0).animate(anim), child: child, ), ))); 当然，为了方便重复利用，需要进行封装，例如我们要封装上面的缩放动画效果 123456789101112class ScalePageRoute extends PageRouteBuilder &#123; final Widget widget; ScalePageRoute(this.widget) : super( transitionDuration: Duration(milliseconds: 500), pageBuilder: (context, anim, _) =&gt; widget, transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( scale: Tween(begin: 0.0, end: 1.0).animate(anim), child: child, ));&#125; 然后直接在 Navigator 跳转的时候调用该 Route 就可以了 该部分代码查看 custom_routes.dart 文件 还记得我们之前写的 demo 都是单个文件写一个入口的吗，现在我们就可以写一个统一管理的页面，对这些界面进行管理了，这个工作就交给大家伙自己了，当然我也在源码做了修改，可以查看 main.dart 文件 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(五)输入处理及登录界面实战]]></title>
    <url>%2Fposts%2F4b62f141.html</url>
    <content type="text"><![CDATA[前面提到基础部件的时候，忘了提输入内容处理部件，这里补上，然后顺带撸个实际的界面吧 1、TextField123456789101112131415161718192021222324252627282930const TextField(&#123; Key key, this.controller, // 定义一个 `TextEditingController` 实例，用来获取输入框内容等操作 this.focusNode, // 定义一个 `FocusNode` 实例，判断当前输入框是否获取到焦点等操作 this.decoration = const InputDecoration(), // 输入框样式，包括提醒字样，hint 等等 TextInputType keyboardType, // 输入文本类型，例如 数字，email 等等 this.textInputAction, // 键盘确认按钮的事件类型 this.textCapitalization = TextCapitalization.none, this.style, // 文字样式 this.textAlign = TextAlign.start, // 对齐方式 this.textDirection, // 文字方向 this.autofocus = false, // 是否自动获取焦点 this.obscureText = false, // 文字是否隐藏，多用于密码 this.autocorrect = true, this.maxLines = 1, // this.maxLength, // 最大长度 this.maxLengthEnforced = true, // 设置最大长度后，输入内容超出后是否强制不给输入 this.onChanged, // 输入内容发生变化时候的回调 this.onEditingComplete, // 输入完毕的回调 this.onSubmitted, // 提交内容的回调 this.inputFormatters, // this.enabled, // 是否可输入，false 不可输入 this.cursorWidth = 2.0, // 游标宽度 this.cursorRadius, // 游标半径 this.cursorColor, // 游标颜色 this.keyboardAppearance, // 该属性只在 iOS 设备有效 this.scrollPadding = const EdgeInsets.all(20.0), this.enableInteractiveSelection, this.onTap, // 点击事件 &#125;) 那么，简单的来个输入框示例吧，然后通过 Text 展示结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; // 可以传入初始值 TextEditingController _editController = TextEditingController(); FocusNode _editNode = FocusNode(); // 保存按钮点击后的输入内容值 String _content = ''; // 监听输入内容变化的内容值 String _spyContent = ''; @override void initState() &#123; super.initState(); // 当输入框获取到焦点或者失去焦点的时候回调用 _editNode.addListener(() &#123; print('edit has focus? =&gt; $&#123;_editNode.hasFocus&#125;'); &#125;); &#125; @override void dispose() &#123; // 记得销毁，防止内存溢出 _editController.dispose(); _editNode.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Input Content'), ), body: Container( padding: const EdgeInsets.symmetric(horizontal: 12.0), child: Column( children: &lt;Widget&gt;[ TextField( controller: _editController, focusNode: _editNode, decoration: InputDecoration( icon: Icon(Icons.phone_iphone, color: Theme.of(context).primaryColor), labelText: '请输入手机号', helperText: '手机号', hintText: '手机号...在这儿输入呢'), keyboardType: TextInputType.number, // 输入类型为数字类型 textInputAction: TextInputAction.done, style: TextStyle(color: Colors.redAccent, fontSize: 18.0), textDirection: TextDirection.ltr, maxLength: 11, // 最大长度为 11 maxLengthEnforced: true, // 超过长度的不显示 onChanged: (v) &#123; // 输入的内容发生改变会调用 setState(() =&gt; _spyContent = v); &#125;, onSubmitted: (s) &#123; // 点击确定按钮时候会调用 setState(() =&gt; _spyContent = _editController.value.text); &#125;, ), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: RaisedButton( onPressed: () &#123; // 获取输入的内容 setState(() =&gt; _content = _editController.value.text); // 清理输入内容 _editController.clear(); setState(() =&gt; _spyContent = ''); &#125;, child: Text('获取输入内容'))), // 展示输入的内容，点击按钮会显示 Text(_content.isNotEmpty ? '获取到输入内容: $_content' : '还未获取到任何内容...'), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), // 监听输入内容的变化，会跟随输入的内容进行改变 child: Text('我是文字内容监听：$_spyContent'), ) ], )), ); &#125;&#125; 这边需要提下的是 setState 方法，该方法只有 StatefulWidget 才有，当需要修改某个值的内容的时候，通过该方法进行修改，最后的效果图如下，当输入框文字发生变化的时候，监听的 Text 内容会随之改变，获取内容的 Text 当点击按钮了才发生变化 该部分代码查看 text_field_main.dart 文件 那么如果有个需求，在点击按钮的时候需要对输入的内容的合理性进行检测，当然可以通过 TextEditingController 的结果进行检测，但是还有个更加方便的方法，可以直接使用部件 TextFormField 来实现，不过需要我们在外层加一个 Form 部件，接下来，就要准备通过 TextFormField 来撸一个登录界面，但是这之前，前面有个坑需要先解决下 2、导入自定义的图标在这之前，涉及到 Icon 部件，都是使用的系统自带的图标，那么如何导入第三方自定义图标呢，马上为你揭晓答案，首先我们需要打开「阿里妈妈」也就是 iconfont，不知道的小伙伴通过链接打开，然后需要注册个账户，也可以直接通过 Github 等三方登录，然后就可以搜索我们需要的图标了，接下来需要撸一个登录，那我们就找一个 用户 和 密码 的图标吧，选择喜欢的图标，然后鼠标放到图标会出现三个按钮，直接点击 购物车 那个按钮，然后就可以通过顶部的 购物车 按钮查看添加的图标，点击下载代码，把资源文件下载到本地。 解压后，需要用到的文件有两个，别的可以忽略 demo_index.html 这边用来查看图标的 unicode iconfont.ttf 这边就是图标资源文件了 回到项目，创建一个文件夹 fonts ，和 images 同级，将 iconfont.ttf 文件放到该文件夹下，然后打开 pubspec.ymal 文件，注册下导入的资源，可以自己命名 iconfont.ttf 文件名，便于自己发现就行，例如我命名为 third_part_icon.ttf，在注册图片下面继续添加 1234fonts: - family: ThirdPartIcons fonts: - asset: fonts/third_part_icon.ttf 注册完了记得点击 Package get，否则会找不到资源。接着新建个 third_icons.dart文件 1234567891011121314import 'package:flutter/material.dart';class ThirdIcons &#123; // codePoint 值通过打开 `demo_index.html` 获取 // 会在相应 icon 下带有相应的 code，把 `&amp;#` 替换成 `0`，然后去掉最后的 `;` 即可 // 例如 &amp;#xe672; 对应我们需要的图标就是 0xe672 static const IconData username = ThirdIconData(0xe672); static const IconData password = ThirdIconData(0xe62f);&#125;class ThirdIconData extends IconData &#123; // fontFamily 就是我们在 `pubspec.yaml` 中注册的 family 值 const ThirdIconData(int codePoint) : super(codePoint, fontFamily: 'ThirdPartIcons');&#125; 接下来就可以通过该类导入需要的第三方图标了。 3、导入第三方插件其实 Flutter 中缺少很多功能，需要通过导入第三方插件来实现功能，插件就是 Flutter 和原生交互的桥梁，也就是说，要写 Flutter 的插件，需要写 Android 和 iOS 两端代码才可，否则只有在其中一个端能够实现功能。好在有很多现成的插件已经开源，可以通过 FlutterPackage 搜索到，例如等会我们会需要用到 FlutterToast 这个插件，用来做提醒用，在 FlutterPackage 中搜索到插件后，打开项目中的 pubspec.ymal 文件，在 dependencies 类目下将 fluttertoast 插件引入，如图： 然后点击 Package get 让其导入即可，别的插件也是这样导入。做好准备工作，我们就可以撸一个登录界面了~ 4、撸一个登录界面在开撸之前，我们先看下最终的效果图吧，虽然是比较常用的界面 因为两个界面比较相似，所以这边只贴外层的代码和登录的代码，具体的代码，可以查看源码，已经推到 Github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191void main() &#123; runApp(LoginApp()); if (Platform.isAndroid) &#123; var style = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(style); &#125;&#125;/// 外层界面，包裹登录界面和注册界面，使用的都是前面讲过的，忘记可以查看之前的章节class LoginApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Login Demo', debugShowCheckedModeBanner: false, theme: ThemeData(primarySwatch: Colors.lightBlue), home: LoginHomePage(), ); &#125;&#125;class LoginHomePage extends StatefulWidget &#123; @override _LoginHomePageState createState() =&gt; _LoginHomePageState();&#125;class _LoginHomePageState extends State&lt;LoginHomePage&gt; with SingleTickerProviderStateMixin &#123; TabController _tabController; List&lt;String&gt; _pageIndicators = ['登录', '注册']; List&lt;Widget&gt; _pages = []; int _position = 0; @override void initState() &#123; super.initState(); _tabController = TabController(length: _pageIndicators.length, vsync: this); // 将登录界面和注册界面添加到列表，用于放到 IndexStack 的 children 属性 _pages..add(LoginPage())..add(RegisterPage()); _tabController.addListener(() &#123; // 当 tab 切换的时候，联动 IndexStack 的 child 页面也进行修改，通过 setState 来修改值 if (_tabController.indexIsChanging) setState(() =&gt; _position = _tabController.index); &#125;); &#125; @override void dispose() &#123; super.dispose(); &#125; @override Widget build(BuildContext context) &#123; // 先忽略... return Theme( data: ThemeData(primarySwatch: Colors.pink, iconTheme: IconThemeData(color: Colors.pink)), child: Scaffold( body: Container( padding: const EdgeInsets.all(20.0), alignment: Alignment.center, decoration: BoxDecoration(image: DecorationImage(image: AssetImage('images/login_bg.png'), fit: BoxFit.cover)), // 先忽略...下面会讲，主要是解决软键盘弹出的时候，界面内容会溢出的问题 child: SingleChildScrollView( child: SafeArea( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 顶部页面切换指示器，代码可以参考 `app_bar_main.dart` 文件 TabBar( indicatorSize: TabBarIndicatorSize.label, controller: _tabController, indicatorWeight: 4.0, indicatorColor: Colors.white, // 返回 tab 列表 tabs: _pageIndicators .map((v) =&gt; Text(v, style: TextStyle(color: Colors.white, fontSize: 24.0))) .toList()), Padding( padding: const EdgeInsets.only(top: 30.0), child: SizedBox( // 切换界面列表 child: IndexedStack(children: _pages, index: _position), // 指定高度 height: MediaQuery.of(context).size.height / 2)) ])), ), ), )); &#125;&#125;/// 登录界面class LoginPage extends StatefulWidget &#123; @override _LoginPageState createState() =&gt; _LoginPageState();&#125;class _LoginPageState extends State&lt;LoginPage&gt; &#123; // 用于后面判断表单内容是否有效 GlobalKey&lt;FormState&gt; _formKey = GlobalKey(); // 用于获取输入框的内容 TextEditingController _usernameController = TextEditingController(); TextEditingController _passwordController = TextEditingController(); @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; // 防止内存溢出，记得销毁..销毁..销毁 _usernameController.dispose(); _passwordController.dispose(); super.dispose(); &#125; _login() &#123; // 取消焦点 FocusScope.of(context).requestFocus(FocusNode()); // 判断表单是否有效 if (_formKey.currentState.validate()) &#123; // 获取输入框内容 var username = _usernameController.value.text; var password = _passwordController.value.text; // 判断登录条件 if (username == 'kuky' &amp;&amp; password == '123456') // 引入的三方插件方法，`Flutter` 没有自带的 `Taost` Fluttertoast.showToast(msg: '登录成功'); else Fluttertoast.showToast(msg: '登录失败'); &#125; &#125; @override Widget build(BuildContext context) &#123; return Form( // 将 key 设置给表单，用于判断表单是否有效 key: _formKey, child: Column( children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), // 表单输入框，参数同 TextField 基本类似 child: TextFormField( controller: _usernameController, style: TextStyle(color: Colors.white, fontSize: 16.0), decoration: InputDecoration( icon: Icon(ThirdIcons.username, size: 24.0, color: Colors.white), labelText: '请输入用户名', labelStyle: TextStyle(color: Colors.white), helperStyle: TextStyle(color: Colors.white)), // 有效条件(为空不通过，返回提示语，通过返回 null) validator: (value) =&gt; value.trim().isEmpty ? '用户名不能为空' : null, ), ), Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: TextFormField( obscureText: true, controller: _passwordController, style: TextStyle(color: Colors.white, fontSize: 16.0), decoration: InputDecoration( icon: Icon(ThirdIcons.password, size: 24.0, color: Colors.white), labelText: '请输入密码', labelStyle: TextStyle(color: Colors.white), helperStyle: TextStyle(color: Colors.white)), validator: (value) =&gt; value.trim().length &lt; 6 ? '密码长度不能小于6位' : null, ), ), Padding( padding: const EdgeInsets.only(top: 20.0), child: SizedBox( // 主要用于使 RaisedButton 和上层容器同宽 width: MediaQuery.of(context).size.width, child: RaisedButton( color: Colors.pink, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(4.0))), onPressed: _login, child: Text( '登录', style: TextStyle(color: Colors.white, fontSize: 20.0), )), ), ) ], )); &#125;&#125; 撸完界面后，可以试下登录效果，如果输入框的内容，和 TextFormField 的 validator的条件不符合，则会显示错误文字的提示 如果按照条件用户名为 kuky 密码为 123456 (条件可以根据自己进行修改)则会显示登录成功的逻辑 以上代码查看 login_home_page.dart 文件 注册界面的逻辑和登录界面的逻辑几乎一样，算是第一次实战了，望小伙伴能够好好的写一遍 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(四)常用布局]]></title>
    <url>%2Fposts%2F14587b6a.html</url>
    <content type="text"><![CDATA[上节填完了 Scaffold 留下的坑，这节继续填坑，之前留下关于 Layout 的坑，又是一堆部件袭来 1、Container为了让我们的界面更容易被扩展，通常会在最外层包裹一层 Container，其构造函数也不是很难理解 1234567891011121314151617181920212223Container(&#123; Key key, this.alignment, // child 的对齐方式，包括左对齐，居中，右对齐，左上对齐..等等 this.padding, // child 和 Container 的边距 Color color, // Container 的背景色 Decoration decoration, // 样式，可以设置背景图，圆角等属性 this.foregroundDecoration, // child 的样式 double width, // 宽度 double height, // 高度 BoxConstraints constraints, // 默认使用 BoxConstraints.tightFor，可以手动传入 this.margin, // Container 同上层容器的边距 this.transform, // 是个 Matrix4 矩阵，(嗯..这个参数基本很少用，没怎么了解 /捂脸) this.child, // 需要展示的内容 &#125;)// ...const BoxConstraints.tightFor(&#123; double width, double height &#125;): minWidth = width != null ? width : 0.0, maxWidth = width != null ? width : double.infinity, minHeight = height != null ? height : 0.0, maxHeight = height != null ? height : double.infinity; 让我们写个圆角矩形的外层，内层值显示白色文字 12345678910111213141516171819202122232425class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, // 宽，高度同上层容器相同 width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, margin: const EdgeInsets.all(8.0), padding: const EdgeInsets.all(20.0), // Container 的样式 decoration: BoxDecoration( borderRadius: BorderRadius.circular(20.0), color: Colors.red,// shape: BoxShape.circle, // 该属性不可同 borderRadius 一起使用 backgroundBlendMode: BlendMode.colorDodge, // 背景图片和颜色混合模式 image: DecorationImage(image: AssetImage('images/ali.jpg'), fit: BoxFit.cover)), child: Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0)),// color: Theme.of(context).primaryColor, // 该属性不可和 decoration 一起使用 )), ); &#125;&#125; 效果图如下 该部分代码查看 column_main.dart 文件 看到这，应该很多小伙伴注意到 margin 和 padding 属性用来和别的部件保持间距，那…那我就是不用 Container 呢(专门来挑事的…)，当然没问题，有个专门用来设置间距的部件 Padding，看名字就可以看出来作用了，修改下 child 部分代码，这边先提前用下接下来会讲的部件 1234567891011child: Column( children: &lt;Widget&gt;[ Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0)), Padding( // 需要传入一个间隔值，`Flutter` 提供了很多 EdgeInsets 来设置间隔， // 参数也很明确，可以一一尝试 padding: const EdgeInsets.symmetric(vertical: 12.0), // 传入需要间隔的部件 child: Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0))) ], ), 效果就不展示了，接下来就要开始我的填坑之旅了…. 2、Flex，Row，Column写 Android 的小伙伴应该比较常用 LinearLayout，在 Flutter 中用两个部件，Row Column来代替 Android 中的 LinearLayout，其中 Row 是横向布局，Column 是垂直布局，因为 Row 和 Column 都是继承于 Flex 部件，Flex 比他们多了 direction 属性用来指定方向，所以主要拿 Column 来讲解，Flex 、Row 用法相同 123456789101112131415Column(&#123; Key key, // 对齐方式，对于 `Column` start 为顶部，对于 `Row` 需要分语言，和语言同向 // 3 种比较特殊的对齐方式，前端的小伙伴会了解， // spaceAround 两个部件之间的间隔是部件和上层容器间隔的两倍 // spaceBetween 两侧部件同上层容器间隔为 0，部件之间的间隔相等 // spaceEvenly 部件之间的间隔同两侧部件与上层容器间隔 MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, // 主轴的大小 CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, // 副轴对齐方式 TextDirection textDirection, // 文字方向，决定 start VerticalDirection verticalDirection = VerticalDirection.down, // 垂直方向 TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[], // 内部子部件 &#125;) Row 和 Column 都有主轴和副轴，如何区分呢，布局平行方向为主轴，垂直方向为副轴，我们把 Container 的 child 修改成 Column，然后把 Text 放到 Column 中，多放几个，然后自己设置 mainAxisAlignment 属性，查看布局的变化 1234567891011// ... 省略相同代码child: Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ Text('Container Text 1', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 2', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 3', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 4', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 5', style: TextStyle(color: Colors.white, fontSize: 30.0)), ], ) 最后的效果图如下 这边 Column 内部的子部件因为高度相同，如果不同还需要等分空间的话，就不可以通过设置 mainAxisAlignment 属性来实现了，这里介绍一个等分的部件 Expanded 12345const Expanded(&#123; Key key, int flex = 1, // 所占比例 @required Widget child, // 子部件 &#125;) 直接给 Text 外层加一个 Expanded 即可实现效果，当然可以按照需求来设置 flex 来修改比例值。 当然，在使用过程中也会遇到那么些坑，我们修改下代码，把 child 的代码修改成如下 123456789child: Row( children: &lt;Widget&gt;[ Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)) ], ) 然后运行下，你的屏幕就提示你 RIGHT OVERFLOWED BY XXX PIXELS 「, ***」我猜你内心肯定这样的，冷静冷静 既然遇到问题，当然要解决，不然和产品去撕逼吗..？这边，我们把 Row 换成另一个布局 Wrap 然后再运行，Prefect，Wrap 和 Row 的参数基本类似 3、Wrap123456789101112Wrap(&#123; Key key, this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, // 两个子部件之间的间隔，默认 0.0，如果值过大，可能导致原来同行的两个部件分行 this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, // 排布方向上 两个子部件的间隔 this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;) 当然，很多时候只有以上的布局是不行的，比如我们需要实现一个圆形头像，然后一段文字在其上面 ，例如下面的效果 接下来介绍一个堆叠的部件 Stack，源码比较简单，就不贴了，直接上效果代码 123456789101112131415161718class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Stack( // 内部子部件的对齐方式 alignment: Alignment.center, children: &lt;Widget&gt;[ // 圆形头像，指定半径，指定背景图为头像即可 CircleAvatar(backgroundImage: AssetImage('images/ali.jpg'), radius: 100.0), Text( 'Kuky', style: TextStyle(color: Colors.white, fontSize: 34.0)), ], )), ); &#125;&#125; 如果我们需要第三个部件，底部距离圆形头像10px，那么只靠 alignment 是不可能实现了 所以，另外一个灰常流弊的部件就出来了 Positioned，其源码也比较简单，我还是不贴了吧~，还是直接上代码，直接修改 12345678910111213141516171819class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ CircleAvatar(backgroundImage: AssetImage('images/ali.jpg'), radius: 100.0), Text( 'Kuky', style: TextStyle(color: Colors.white, fontSize: 34.0), ), Positioned(child: Text('另外一段文字', style: TextStyle(color: Colors.white, fontSize: 20.0)), bottom: 10.0), // left, right, top, bottom 分别表示和 stack 的间距 ], )), ); &#125;&#125; 最后的效果图如下 很好，今天填了布局的这个大坑，而且讲的部件貌似还挺多的，虽然还是比较简单，剩下的就给小伙伴们慢慢消化今天的内容。 下节，除了有常用的部件外，我会尽量加上实战内容 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(三)快速搭建界面]]></title>
    <url>%2Fposts%2F5c762cf7.html</url>
    <content type="text"><![CDATA[上一篇讲完 Flutter 中的一些基本部件，这篇就先填完上篇留下的没写的 AppBar 的坑，以及 Scaffold 其他参数的使用，在开始前，先补一张缩略版的脑图 1、AppBar这一部分，我们只关注 Scaffold 中的 AppBar 剩下的还是埋坑【坑4】(，居然已经埋了那么多坑了，坑虽多，代码还是要继续的)，因为稍后会用到 StatefulWidget 的属性，所以就直接先使用了，和 StatelessWidget 区别用法可以这么记 需要数据更新的界面用 StatefulWidget，当然也不是绝对的，就是之前留的【坑1】所说的状态管理 1234567891011121314151617181920212223242526272829class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, // 标题内容居中 automaticallyImplyLeading: false, // 不使用默认 leading: Icon(Icons.menu, color: Colors.red, size: 30.0), // 左侧按钮 flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), // 背景 title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), // 标题内容 // 末尾的操作按钮列表 actions: &lt;Widget&gt;[ PopupMenuButton( onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], ), ); &#125;&#125; 最后的效果图，未点击右侧按钮如左侧所示，点击右侧按钮会弹出相应的 mune 该部分代码查看 app_bar_main.dart 文件 看到效果图，相信很多小伙伴会吐槽，「**，上面那层半透明的啥玩意，那么丑」，接下来我们来解决这个问题，修改 void main 方法 123456789void main() &#123; runApp(DemoApp()); // 添加如下代码，使状态栏透明 if (Platform.isAndroid) &#123; var style = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(style); &#125;&#125; 关闭后重新运行，就可以看到那层丑丑的「半透明蒙层」没有了 接着介绍下 PopupMenuButton 这个部件，还是按照惯例看构造函数 123456789101112131415161718// itemBuildertypedef PopupMenuItemBuilder&lt;T&gt; = List&lt;PopupMenuEntry&lt;T&gt;&gt; Function(BuildContext context);// onSelectedtypedef PopupMenuItemSelected&lt;T&gt; = void Function(T value);const PopupMenuButton(&#123; Key key, @required this.itemBuilder, // 用于定义 menu 列表，需要传入 List&lt;PopupMenuEntry&lt;T&gt;&gt; this.initialValue, // 初始值，是个泛型 T，也就是类型和你传入的值有关 this.onSelected, // 选中 item 的回调函数，返回 T value，例如选中 `s` 则返回 s this.onCanceled, // 未选择任何 menu，直接点击外侧使 mune 列表关闭的回调 this.tooltip, // 长按时的提示 this.elevation = 8.0, this.padding = const EdgeInsets.all(8.0), this.child, // 用于自定义按钮的内容 this.icon, // 按钮的图标 this.offset = Offset.zero, // 展示时候的便宜，Offset 需要传入 x,y 轴偏移量，会根据传入值平移 &#125;) 2、AppBar - bottomAppBar 还有个 bottom 属性没讲，因为 bottom 这个属性和图片背景一起使用会比较丑，所以就单独拎出来讲，我们直接在原来的代码上修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 这里需要用 with 引入 `SingleTickerProviderStateMixin` 这个类class _HomePageState extends State&lt;HomePage&gt; with SingleTickerProviderStateMixin &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; TabController _tabController; // TabBar 必须传入这个参数 @override void initState() &#123; super.initState(); // 引入 `SingleTickerProviderStateMixin` 类主要是因为 _tabController 需要传入 vsync 参数 _tabController = TabController(length: _abs.length, vsync: this); &#125; @override void dispose() &#123; // 需要在界面 dispose 之前把 _tabController dispose，防止内存泄漏 _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, automaticallyImplyLeading: false, leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, // 选中时的颜色 unselectedLabelColor: Colors.white, // 未选中颜色 controller: _tabController, isScrollable: false, // 是否固定，当超过一定数量的 tab 时，如果一行排不下，可设置 true indicatorColor: Colors.yellow, // 导航的颜色 indicatorSize: TabBarIndicatorSize.tab, // 导航样式，还有个选项是 TabBarIndicatorSize.label tab 时候，导航和 tab 同宽，label 时候，导航和 icon 同宽 indicatorWeight: 5.0, // 导航高度 tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), // 导航内容列表 ), ); &#125;&#125; 最终的效果图如下 3、PageView + TabBar那么如何通过 TabBar 切换界面呢，这边我们需要用到 PageView 这个部件，当然还有别的部件，例如 IndexStack 等，小伙伴可以自己尝试使用别的，这边通过 PageView 和 TabBar 进行关联，带动页面切换，PageViede 的属性参数相对比较简单，这边就不贴啦。最终的效果我们目前只展示一个文字即可，我们先定义一个通用的切换界面 12345678910111213141516class TabChangePage extends StatelessWidget &#123; // 需要传入的参数 final String content; // TabChangePage(this.content); 不推荐这样写构造方法 // 推荐用这样的构造方法，key 可以作为唯一值查找 TabChangePage(&#123;Key key, this.content&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // 仅展示传入的内容 return Container( alignment: Alignment.center, child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0))); &#125;&#125; 定义通用界面后，就可以作为 PageView 的子界面传入并展示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; with SingleTickerProviderStateMixin &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; TabController _tabController; // 用于同 TabBar 进行联动 PageController _pageController; @override void initState() &#123; super.initState(); _tabController = TabController(length: _abs.length, vsync: this); _pageController = PageController(initialPage: 0); _tabController.addListener(() &#123; // 判断 TabBar 是否切换位置了，如果切换了，则修改 PageView 的显示 if (_tabController.indexIsChanging) &#123; // PageView 的切换通过 controller 进行滚动 // duration 表示切换滚动的时长，curve 表示滚动动画的样式， // flutter 已经在 Curves 中定义许多样式，可以自行切换查看效果 _pageController.animateToPage(_tabController.index, duration: Duration(milliseconds: 300), curve: Curves.decelerate); &#125; &#125;); &#125; @override void dispose() &#123; _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, automaticallyImplyLeading: false, leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, unselectedLabelColor: Colors.white, controller: _tabController, isScrollable: false, indicatorColor: Colors.yellow, indicatorSize: TabBarIndicatorSize.tab, indicatorWeight: 5.0, tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), ), // 通过 body 来展示内容，body 可以传入任何 Widget，里面就是你需要展示的界面内容 // 所以前面留下 Scaffold 中 body 部分的坑就解决了 body: PageView( controller: _pageController, children: _abs.map((str) =&gt; TabChangePage(content: str)).toList(), // 通过 Map 转换后再通过 toList 转换成列表，效果同 List.generate onPageChanged: (position) &#123; // PageView 切换的监听，这边切换 PageView 的页面后，TabBar 也需要随之改变 // 通过 tabController 来改变 TabBar 的显示位置 _tabController.index = position; &#125;, ), ); &#125;&#125; 最终的效果图就不贴了，可以发现滑动 PageView 或者点击切换 TabBar 的位置，界面显示的内容都会随之改变，同时，解决前面 Scaffold 留下 body 属性没讲的一个坑，就剩下 drawer 、 bottomNavigationBar 属性没讲了，在解决这两个坑之前，我们先处理下另一个问题 Scaffold 能够使我们快速去搭建一个界面，但是，并不是所有的界面都需要 AppBar 这个标题，那么我们就不会传入 appBar 的属性，我们注释 _HomePageState 中 Scaffold 的 appBar 传入值，把 body 传入的 PageView 修改成单个 TabChangePage ，然后把 TabChangePage 这个类做下修改，把 Container 的 aligment 属性也注释了，这样显示的内容就会显示在左上角 1234567891011121314151617// _HomePageState// ..@override Widget build(BuildContext context) &#123; return Scaffold(body: TabChangePage(content: 'Content')); &#125;class TabChangePage extends StatelessWidget &#123; final String content; TabChangePage(&#123;Key key, this.content&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0))); &#125;&#125; 然后运行下，「**，文字怎么被状态栏给挡了…」不要慌，静下心喝杯茶，眺望下远方，这里就需要用 SafeArea 来处理了，在 TabChangePage 的 Container 外层加一层 SafeArea 123456@override Widget build(BuildContext context) &#123; return SafeArea( child: Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0)))); &#125; 然后重新运行，一切正常，SafeArea 的用途可以看下源码的解释 12345/// A widget that insets its child by sufficient padding to avoid intrusions by/// the operating system.////// For example, this will indent the child by enough to avoid the status bar at/// the top of the screen. 翻译过来大概就是「给子部件和系统点击无效区域留有足够空间，比如状态栏和系统导航栏」，SafeArea 可以很好解决刘海屏覆盖页面内容的问题，那么到目前为止，AppBar 的一些坑就说的差不多了，就要解决剩下的坑了 4、Scaffold - Drawerdrawer 同 endDrawer 属性是一样的，除了滑动的方向，Drawer 这个组件也相对比较简单，只要传入一个 child 即可，在展示之前，先对 appBar 做下处理，设置 leading 为系统默认，点击 leading 的时候 Drawer 就可以滑出来了，当然手动滑也可以 123456789101112131415161718192021222324252627282930313233343536373839@override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true,// automaticallyImplyLeading: false,// leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, unselectedLabelColor: Colors.white, controller: _tabController, isScrollable: false, indicatorColor: Colors.yellow, indicatorSize: TabBarIndicatorSize.tab, indicatorWeight: 5.0, tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), ), // body .... drawer: Drawer( // 记得要先添加 `SafeArea` 防止视图顶到状态栏下面 child: SafeArea( child: Container( child: Text('Drawer', style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0)), )), ), ); // return Scaffold(body: TabChangePage(content: 'Content')); &#125; 最终的效果图也不贴了，当手势从左侧滑出或者点击 leading 图标，抽屉就出来了 5、AppBar - bottomNavigationBarbottomNavigarionBar 可以传入一个 BottomNavigationBar 实例，BottomNavigationBar 需要传入 BottomNavigationBarItem 列表作为 items ，但是这边为了实现一个 bottomNavigationBar 和 floatingActionButton 一个特殊的组合效果，我们不使用 BottomNavigationBar，换做 BottomAppBar，直接上代码吧 1234567891011121314151617181920@override Widget build(BuildContext context) &#123; return Scaffold( /// 一样的代码省略.... bottomNavigationBar: BottomAppBar( shape: CircularNotchedRectangle(), child: Row( mainAxisSize: MainAxisSize.max, mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ IconButton(icon: Icon(Icons.android, size: 30.0, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;), IconButton(icon: Icon(Icons.people, size: 30.0, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;) ], ), ), floatingActionButton: FloatingActionButton(onPressed: () =&gt; print('Add'), child: Icon(Icons.add, color: Colors.white)), // FAB 的位置，一共有 7 中位置可以选择，centerDocked, endDocked, centerFloat, endFloat, endTop, startTop, miniStartTop，这边选择悬浮在 dock floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, ); 最终的效果图 ![image-20190425161447777](/Users/zm/Library/Application Support/typora-user-images/image-20190425161447777.png) 既然提到了 StatefulWidget，顺带提下两种比较简单的部件，也算是基础部件吧。CheckBox、CheckboxListTile，Switch、SwitchListTile 因为比较简单，就直接上代码了，里面都有完整的注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class CheckSwitchDemoPage extends StatefulWidget &#123; @override _CheckSwitchDemoPageState createState() =&gt; _CheckSwitchDemoPageState();&#125;class _CheckSwitchDemoPageState extends State&lt;CheckSwitchDemoPage&gt; &#123; var _isChecked = false; var _isTitleChecked = false; var _isOn = false; var _isTitleOn = false; @override void initState() &#123; super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Check Switch Demo'), ), body: Column(children: &lt;Widget&gt;[ Row( children: &lt;Widget&gt;[ Checkbox( // 是否开启三态 tristate: true, // 控制当前 checkbox 的开启状态 value: _isChecked, // 不设置该方法，处于不可用状态 onChanged: (checked) &#123; // 管理状态值 setState(() =&gt; _isChecked = checked); &#125;, // 选中时的颜色 activeColor: Colors.pink, // 这个值有 padded 和 shrinkWrap 两个值， // padded 时候所占有的空间比 shrinkWrap 大，别的原谅我没看出啥 materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, ), /// 点击无响应 Checkbox(value: _isChecked, onChanged: null, tristate: true) ], ), Row( children: &lt;Widget&gt;[ Switch( // 开启时候，那个条的颜色 activeTrackColor: Colors.yellow, // 关闭时候，那个条的颜色 inactiveTrackColor: Colors.yellow[200], // 设置指示器的图片，当然也有 color 可以设置 activeThumbImage: AssetImage('images/ali.jpg'), inactiveThumbImage: AssetImage('images/ali.jpg'), // 开始时候的颜色，貌似会被 activeTrackColor 顶掉 activeColor: Colors.pink, materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, value: _isOn, onChanged: (onState) &#123; setState(() =&gt; _isOn = onState); &#125;), /// 点击无响应 Switch(value: _isOn, onChanged: null) ], ), CheckboxListTile( // 描述选项 title: Text('Make this item checked'), // 二级描述 subtitle: Text('description...description...\ndescription...description...'), // 和 checkbox 对立边的部件，例如 checkbox 在头部，则 secondary 在尾部 secondary: Image.asset('images/ali.jpg', width: 30.0, height: 30.0), value: _isTitleChecked, // title 和 subtitle 是否为垂直密集列表中一员，最明显就是部件会变小 dense: true, // 是否需要使用 3 行的高度，该值为 true 时候，subtitle 不可为空 isThreeLine: true, // 控制 checkbox 选择框是在前面还是后面 controlAffinity: ListTileControlAffinity.leading, // 是否将主题色应用到文字或者图标 selected: true, onChanged: (checked) &#123; setState(() =&gt; _isTitleChecked = checked); &#125;, ), SwitchListTile( title: Text('Turn On this item'), subtitle: Text('description...description...\ndescription...description...'), secondary: Image.asset('images/ali.jpg', width: 30.0, height: 30.0), isThreeLine: true, value: _isTitleOn, selected: true, onChanged: (onState) &#123; setState(() =&gt; _isTitleOn = onState); &#125;) ]), ); &#125;&#125; 该部分代码查看 checkbox_swicth_main.dart 文件 终于这节把 Scaffold 留下的坑都填完了，然后又讲了两种基础部件，下节要填留下的别的坑了，目测还留了 2 个大坑，那就等以后继续解决吧~ 最后代码的地址还是要的： 文章中涉及的代码：demos 基于郭神 cool weather 接口的一个项目，实现 BLoC 模式，实现状态管理：flutter_weather 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：flutter_shop 作者：Kuky_xs 链接：https://www.jianshu.com/p/9119a1c1a123 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(二)基础部件]]></title>
    <url>%2Fposts%2F88b946ec.html</url>
    <content type="text"><![CDATA[前言主要包括 MaterialApp、Scaffold、Text、Image、Icon、Button 以及 AppBar 部分内容，准备出发~ ​ 看完这篇文章你就在知道怎么写以上效果了 1、Flutter runApp新建 flutter 项目后，可以看到 lib 下的 main.dart 中 void main() =&gt; runApp(MyApp());这句就是程序的入口了。这里可以简单看下源码 123456789101112131415161718192021void runApp(Widget app) &#123; WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame();&#125;///....static WidgetsBinding ensureInitialized() &#123; if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance;&#125;///....void attachRootWidget(Widget rootWidget) &#123; _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;( container: renderView, debugShortDescription: '[root]', child: rootWidget ).attachToRenderTree(buildOwner, renderViewElement);&#125; 首先会创建一个 WidgetsBinding 单例对象，然后把传入的 App 添加到 rootWidget中，scheduleWarmUpFrame 方法比较长，这边看下对该方法的注释第一句就能了解方法的主要功能了 Schedule a frame to run as soon as possible 「安排框架尽快运行起来」(原谅我这渣英语，只能看懂不会翻译..大概就是「快速启动框架」的意思吧) 2、Flutter App接着看下 MyApp 这个类，继承自 StatelessWidget 并在 build 方法返回一个 MaterialApp 实例，(偷偷讲下，其实这边还可以返回 CupertinoApp，这是一个 iOS 风格的 widget，基本上你看到部件带 「Cupertino」的都是 iOS 风格的 widget，这里先不讲 iOS 风格的部件，目前 flutter 对 Cupertino 系列的 widget 支持不是很好，包括部件的广度，多语言的支持等等方面都不是很友好，所以我们还是继续看 MD 风格的 Android 部件吧~)，这里先看下 MaterialApp 的构造函数，介绍一些常用的参数 1234567891011121314151617181920212223242526const MaterialApp(&#123; Key key, this.navigatorKey, this.home, // 主界面的内容 widget this.routes = const &lt;String, WidgetBuilder&gt;&#123;&#125;, // 带 router 和路由跳转有关 this.initialRoute, this.onGenerateRoute, this.onUnknownRoute, this.navigatorObservers = const &lt;NavigatorObserver&gt;[], this.builder, this.title = '', // *类似标题 this.onGenerateTitle, // 主要用于多语言情况下，需要根据当前语言替换 title，需要使用该值 this.color, // 主题色，如果该值未设置，取 theme.primaryColor,未设置 theme 则取蓝色 this.theme, // App 的主题风格，包括主题色，按钮默认颜色等等 this.locale, // 带 locale 的和多语言适配相关 this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const &lt;Locale&gt;[Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, // debug 模式下，是否显示 DEBUG 标示横幅 &#125;) MaterialApp 继承自 StatefulWidget，它和 MyApp 所继承的类 StatelessWidget，就是日常开发中，自定义部件通常继承的抽象类了。 StatelessWidget 是状态不可变部件，通过其构建的部件一般用来展示固定内容，例如需要展示固定的功能按钮列表，不需要根据不同界面状态进行修改其展示内容 StatefulWidget 是可改变状态的部件，比如我们需要通过网络或者数据库获取数据，然后修改部件锁展示的数据内容，则需要通过 StatefulWidget 来构建。当然，不是说 StatelessWidget 不能实现修改界面数据的功能，这就需要涉及到 状态管理 的概念了，后面有机会再讲，这边先埋坑【坑1】 3、Flutter Scaffold进入 App 后就需要构建界面了，Flutter 提供了 Scaffold 来快速构建一个 MaterialDesign 风格的界面，还是先看下 Scaffold 的构造函数吧，了解几个比较常用的部分。 12345678910111213141516const Scaffold(&#123; Key key, this.appBar, // 界面顶部的那条栏，这边需要返回一个 AppBar 实例 this.body, // 界面的内容部分 this.floatingActionButton, // 悬浮部分，可以通过 floatingActionButtonLocation 设置位置 this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.drawer, // 侧滑抽屉部分，从左侧滑出(应该和语言有关，和文字方向同向) this.endDrawer, // 侧滑抽屉部分，从右侧滑出 this.bottomNavigationBar, // 底部导航栏，就是通常看到的底部 TAB 切换部件 this.bottomSheet, // 展示从底部弹出的，起到提示作用的，通过 showModalBottomSheet 展示 this.backgroundColor, // 界面的背景色 this.resizeToAvoidBottomPadding = true, // 避免 body 被底部弹出部件填充，例如输入法键盘 this.primary = true, // 当前的 Scaffold 是否需要被展示在屏幕最上层 &#125;) 来张图吧，简洁明了 了解完 Scaffold 的整体构造后，我们从上到下，通过构造函数来了解下各个 Widget的使用方法 4、AppBar12345678910111213141516171819AppBar(&#123; Key key, this.leading, // 用于设置 AppBar 前置的按钮，例如设置返回我们需要的返回按钮等 this.automaticallyImplyLeading = true, // 是否使用系统默认生成的按钮，如果替换 leading 的默认按钮，最好将该属性设置成 false this.title, // AppBar 所需要展示的组件，传入一个 Widget 实例，通常使用 Text 展示一个标题 this.actions, // AppBar 末尾悬浮的一些操作组件，例如常见的会在末尾设置一个「...」按钮，点击弹出一个 menue 提供给用户操作选择 this.flexibleSpace, // AppBar 的背景，可以设置颜色，背景图等等 this.bottom, // bottom 用于展示顶部导航 TAB this.elevation = 4.0, this.backgroundColor, // AppBar 的背景色，如果只需要修改颜色，可以不通过 flexibleSpace 修改 this.brightness, this.iconTheme, // 按钮的默认样式 this.textTheme, // 文字的默认样式 this.primary = true, this.centerTitle, // 是否将展示的 title 居中 this.titleSpacing = NavigationToolbar.kMiddleSpacing, // AppBar title 两侧的空白间隔 this.toolbarOpacity = 1.0, this.bottomOpacity = 1.0, &#125;) 在展示 AppBar 的 demo 之前，我们先学习几个基本的组件 Text、Image、Icon、Button 分布用于展示文字，图片，图标，按钮 5、Text123456789101112const Text(this.data, &#123; // Text 需要展示的文字 Key key, this.style, // 文字的样式，包括颜色，大小，间距等等属性，这边就不继续展示 TextStyle 构造函数了，不然我怕大家都不想继续看了，稍后通过例子来说明 this.textAlign, // 文字的对齐方式，包括左对齐，右对齐，居中等，详见 TextAlign 类 this.textDirection, // 文字方向，ltr(left to right) 或者 rtl(right to left) this.locale, this.softWrap, // 当文字一行显示不完是否换行 this.overflow, // 如果超出限制的行数，以哪种方式省略未展示的内容 this.textScaleFactor, // 文字缩放比例 this.maxLines, // 最多展示的行数 this.semanticsLabel, &#125;) 说了那么多，相信很多小伙伴都要急着撸代码了吧，接着来展示一些 Text 的示例，接下来的例子都会直接替换 HomePage 内的展示内容，其余都是相同的，接下来请关注 Text 别的部件先忽略，后面会介绍，这边先埋坑【坑2】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';void main() =&gt; runApp(DemoApp());class DemoApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', debugShowCheckedModeBanner: false, theme: ThemeData(primarySwatch: Colors.lightBlue), home: HomePage(), ); &#125;&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('绿色背景黑色文字展示', style: TextStyle( color: Colors.black, // 设置文字颜色，不可和 foreground 同时设置 fontSize: 24.0, // 字体大小 letterSpacing: 2.0, // 每个字符之间的间隔 background: Paint()..color = Colors.green)), // 背景色 Text('这是一个带红色下划线的文字展示', style: TextStyle( color: Colors.black, fontSize: 24.0, // 文字装饰线，除了 underline 还有 overline, lineThrough， // 不同的样式小伙伴可以通过自己修改代码来查看 decoration: TextDecoration.underline, // 文字装饰线的类型，除了 solid 还有 double,dotted,dashed,wavy 可选 decorationStyle: TextDecorationStyle.solid, // 装饰线的颜色 decorationColor: Colors.red)) ], )), )); &#125;&#125; 该部分代码查看源码 text_main.dart 文件 最后的展示效果如下图 6、Image按照惯例，我们还是先看下 Image 的构造函数吧 123456789101112131415161718192021const Image(&#123; Key key, // 一个 ImageProvider 实例，但是 ImageProvider 是一个抽象类，Flutter 已经给我们提供如下 // AssetImage，NetworkImage，FileImage，MemoryImage 这四种图片加载器，为了方便调用 // 我们可以直接通过 Image.asset, Image.network, Image.file, Image.memory 简化， // 通过方法名，可以看出分别从 asset 文件，网络，文件，内存中加载图片 @required this.image, this.semanticLabel, this.excludeFromSemantics = false, this.width, // 图片宽度 this.height, // 图片高度 this.color, // 图片背景色 this.colorBlendMode, // color 和图片的混合模式(这个值比较多，可以一个个尝试) this.fit, // 图片填充方式 fill, cover, contain, fillWidth, fillHeight, scaleDown, none this.alignment = Alignment.center, // 对齐方式 this.repeat = ImageRepeat.noRepeat, // 若未填充满空间，重复展示的方式 this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.filterQuality = FilterQuality.low, &#125;) 好了好了，我知道你们又想自己写代码尝试下了，在这之前，需要你先准备一张本地图片，然后在项目的根目录，也就是 lib 文件夹同层，创建一个新的文件夹，命名为 images，把你准备好的图片放到这个目录下。放好之后打开 pubspec.yaml 把图片资源文件注册下 1234567891011# The following section is specific to Flutter.flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # 这边注册资源文件，以后有图片文件也可以只注册 images 文件夹，会自动读取内部的文件 assets: - images/ali.jpg 注册完成后，就可以继续愉快的撸代码了~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class HomePage extends StatelessWidget &#123; final String _assetAli = 'images/ali.jpg'; final String _picUrl = 'https://timg05.bdimg.com/timg?wapbaike&amp;quality=60&amp;size=b1440_952&amp;cut_x=143&amp;cut_y=0&amp;cut_w=1633&amp;' 'cut_h=1080&amp;sec=1349839550&amp;di=cbbc175a45ccec5482ce2cff09a3ae34&amp;' 'src=http://imgsrc.baidu.com/baike/pic/item/4afbfbedab64034f104872baa7c379310b551d80.jpg'; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 这种展示图片方式和下一种会有相同的效果 Image(image: AssetImage(_assetAli), width: 80.0, height: 80.0), // 接下来加载图片都会使用这些比较方便的方法 Image.asset(_assetAli, width: 80.0, height: 80.0), // 加载一张网络图片 Image.network(_picUrl, height: 80.0, // 横向重复 repeat: ImageRepeat.repeatX, // MediaQuery.of(context).size 获取到的为上层容器的宽高 width: MediaQuery.of(context).size.width), // 通过设置混合模式，可以看到图片展示的样式已经修改 Image.asset(_assetAli, width: 80.0, height: 80.0, color: Colors.green, colorBlendMode: BlendMode.colorDodge), // 会优先加载指定的 asset 图片，然后等网络图片读取成功后加载网络图片，会通过渐隐渐现方式展现 // cover 方式按照较小的边布满，较大的给切割 // contain 会按照最大的边布满，较小的会被留白 // fill 会把较大的一边压缩 // fitHeight, fitWidth 分别按照长宽来布满 FadeInImage.assetNetwork( placeholder: _assetAli, image: _picUrl, width: 120.0, height: 120.0, fit: BoxFit.cover), // Icon 相对属性少了很多，需要传入一个 IconData 实例，flutter 提供了很多图标， // 但是实际情况我们需要加入我们自己的图标，这边再埋坑【坑3】 // size 为图标显示的大小，color 为图标的颜色，这边通过 Theme 获取主题色调 Icon(Icons.android, size: 40.0, color: Theme.of(context).primaryColorDark) ], )), )); &#125;&#125; 该部分代码查看源码 image_main.dart 文件 最后的效果如下 7、ButtonFlutter 提供了各种类型的 Button 几乎是大同小异的，这边就抽取一些比较常用的展示下效果，常用的主要有 RaisedButton 、FlatButton、IconButton、OutlineButton、MaterialButton、FloatActionButton、FloatingActionButton.extended Button 都有一个 onPress 参数，是 VoidCallback 类型的参数，通过查看源码可以知道 VoidCallback 是无参无返回值的一种类型参数。如果该参数传入的值为 null 那么这个按钮的就不可点击状态，无点击效果，等会可以在例子中查看。还有就是 child 参数，这里就是传入你需要展示的内容，比如 Text、Icon 等等。别的参数基本可以通过参数名了解，这边不扩展了(再看源码我怕你们都不想继续看下去了…) Talk is cheap, show me the code 1234567891011121314151617181920212223242526272829303132333435363738class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123; print('This is a Rased Button can be clicked'); &#125;, child: Text('Raised Enable'), ), RaisedButton(onPressed: null, child: Text('Raised Disable')), FlatButton( onPressed: () =&gt; print('This is a Flat Button can be clicker'), child: Text('Flat Enable'), ), FlatButton(onPressed: null, child: Text('Flat Disable')), IconButton(icon: Icon(Icons.android), onPressed: () &#123;&#125;), IconButton(icon: Icon(Icons.android), onPressed: null), MaterialButton(onPressed: () &#123;&#125;, child: Text('Material Enable')), MaterialButton(onPressed: null, child: Text('Material Disable')), OutlineButton(onPressed: () &#123;&#125;, child: Text('Outline Enable')), OutlineButton(onPressed: null, child: Text('Outline Enable')), ], )), ), floatingActionButton: FloatingActionButton.extended(onPressed: () &#123;&#125;, icon: Icon(Icons.android), label: Text('Android')), floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, ); &#125;&#125; 该部分代码查看源码 button_main.dart 部分 最终的效果图 这篇终于到末尾了，最后留了 3 个坑等以后解决 文章 demo 的地址：https://github.com/kukyxs/flutter_arts_demos_app 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：https://github.com/kukyxs/flutter_shop 如果对你有帮助的话，记得给个 Star，先谢过，你的认可就是支持我继续写下去的动力~]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(一)Dart]]></title>
    <url>%2Fposts%2F6114f592.html</url>
    <content type="text"><![CDATA[前言最近 Flutter 真心火爆到不要不要的，随大流，学一波，在这之前，对于语言的语法还是需要有些必要的了解的，Dart 这门语言，说实话对于会 Java 这类面向对象的语言的小伙伴们来说，真的灰常灰常简单，这边我总结了一些 Dart 和 Java 的一些语法差异，当然，只是部分，但是，按照我目前的学习进度来说，了解了这些对于写 Flutter 项目绝对够了。小伙伴也可以自己查看，我这边提供一个自己学习的网址 Dart 快速入门：http://dart.goodev.org/guides/language 温馨提示：本篇文章没有图，没有图，没有图，可能会造成部分不适，请注意，请注意，请注意，系好安全带，我们要「开车了」…… 1、VariablesDart 变量类型可以通过具体的赋值进行推导，例如：var name = ‘kuky’ 则定义了一个 String 类型对象 name，也可以通过指定具体的类型 String name = ‘kuky’，如果没有初始化变量，则默认值为 null，类型为数字的变量默认值同为 null（同 java 不同，java 中 int 默认为 0.）如果需要定义常量，可以通过 final 和 const 进行定义，final 变量只能赋值一次，const 是编译时常量。 2、Build-in-typesDart 内置类型包括 ： Numbers 包括 int[-2^53 ~ 2^53]， double[64-bit 浮点数] *Strings * Dart 字符串是 UTF-16 编码的字符序列， 可以使用单引号或者双引号来创建字符串。 通过 == 判断两个字符串是否相同 通过三对单引号’’’aaa’’’或者双引号”””aaa”””可以创建多行字符串对象 使用前缀 r 创建 raw string，字符串内不会进行转义，例如：var a = r’haha \n breakLine’ 打印 a 对象则会按照输入的输出，不会进行换行 Booleans Dart 中，只有 true 对象才被认为是 true， 所有其他的值都是 false Lists 列表，例如：var list = [1, 2, 3, 4] 通过 const 关键词可以定义一个不可变列表 var list = const [1, 2, 3, 4] 参数化定义var name = [‘Jone’, ‘Jack’] Maps 键值对，例如：var map = {‘one’: 1, ‘two’: 2} 如果键值对需要添加新的键值对，直接指定即可，map[‘three’] = 3，若查找的键不存在，返回 null 参数化定义 var map = &lt;String, int&gt;{‘one’: 1, ‘two’: 2} Runes 代表字符串的 UTF-32 code points，通常使用 \uXXXX 的方式来表示 Unicode code point， XXXX 是4个 16 进制的数，例如 \u2665 返回心形符号 () Symbols 代表 Dart 程序中声明的操作符或者标识符，几乎不使用 3、Function函数方法的可选参数通过在参数列表中用 {} 指定，例如： 1234567void say(String name, &#123;String word = 'hello'&#125;)&#123; print('$name say $word'); &#125;// 通过（可选参数名 + :）进行可选参数的赋值main()&#123; say('zm', word: 'Hello World'); // kuky say Hello World&#125; word 参数为可选参数，默认值为 hello 4、Operators操作符几乎和别的语言类似，提个比较特殊的赋值操作符 ??= 和 ?.操作符 123var a = 1;var b ?? = a; // 如果 b 的值是 null 则将 a 赋值给 b，否则保持不变var c = size?.x; // 如果 size 为 null 则返回 null，否则返回 size.a 的值 5、Conditional ExpressionsDart 可以通过两个特殊的操作符替换 if(){} else{} 表达式 1234/// condition? expr1: expr2 同 java 三目运算符var a = if(a &lt; 0) -a : a/// expr1 ?? expr2 String toString() =&gt; msg ?? super.toString() // 如果 expr1 不为 null 则返回 expr1 否则返回 expr 6、Cascade Notaion(..)级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量 12345678910111213141516class Size&#123; double x; double y; @override String toString() &#123; return 'Size&#123;x: $x, y: $y&#125;'; &#125;&#125;var size = Size();/// 通过级联操作符进行赋值，可以更加简洁，!!如果函数返回值为 void 则不能进行级联!!print(size ..x = 10 ..y = 100 ..toString()); /// 输出 Size&#123;x: 10.0, y: 100.0&#125; 7、foreach通过 foreach 循环遍历一个实现 Iterable 接口的对象 12345var items = [1, 2, 3, 4, 5];var maps = &#123;'a': 1, 'b': 2&#125;;items.where((i) =&gt; i &gt; 2).forEach((i) =&gt; print(i)); // 3, 4, 5maps.forEach((key, value) =&gt; print('$key =&gt; $value')); // a =&gt; 1, b =&gt; 2 8、Switch and case如果需要实现继续到下一个 case 语句中继续执行，则可以 使用 continue 语句跳转到对应的标签处继续执行 1234567891011var command = 'Close';switch (command.toLowerCase()) &#123; case 'close': print('close'); continue open; open: // 这是个标签 case 'open': print('open'); break;&#125; 9、Assert如果条件表达式结果不满足需要，则可以使用 assert 语句俩打断代码的执行，例如：assert(a == 1); 10、Exceptions所有的 Dart 异常是非检查异常。捕捉 exceptions 的时候可以通过 on 指定 exceptions 类型，再使用 catch 捕获 1234567891011try &#123; breedMoreLlamas();&#125; on OutOfLlamasException &#123; buyMoreLlamas();&#125; on Exception catch (e) &#123; print('Unknown exception: $e');&#125; catch (e, s) &#123; // 函数 catch 可以带有一个或两个参数，第一个参数为抛出的异常对象，第二个为堆栈信息 print('Something really unknown: $e'); print('Stack trace:\n $s'); rethrow; // 通过 rethrow 可以将异常重新抛出&#125; 11、ClassesDart 中的类都是单继承，但是同时支持 mixin 的继承机制（除 Object 类，每个类都只有一个超类），所有的类都继承于 Object，通过调用 runtimeType 判断实例的类型。每个实例变量都会自动生成一个 getter 方法（隐含的）， Non-final 实例变量还会自动生成一个 setter 方法。 Constructors Dart 的构造函数同 Java 类似 12345678910class Size &#123; num x, y; Size(num nx, num y)&#123; x = nx; this.y = y; // this 关键字只有当名字冲突时候使用，否则 Dart 推荐省略 this &#125; Size(this.x, this.y); // Dart 通过语法糖省略了构造函数的赋值过程，效果同上&#125; 如果没有定义构造函数，则会有个默认构造函数。默认构造函数没有参数，并且会调用超类的 没有参数的构造函数。子类不会继承超类的构造函数，子类如果没有定义构造函数，则只有一个默认构造函数。 Dart 通过命名构造函数为类创建多个构造函数，同时指明意图 12345678910111213141516class Size &#123; num x, y; Size(this.x, this.y); Size.fromJson(Map json)&#123; this.x = json['x']; this.y = json['y']; &#125; // 因为构造函数不能继承，如果希望子类也有超类一样的命名构造函数，必须在子类中实现该构造函数 // 构造函数体执行之前除了可以调用超类构造函数之外，还可以初始化实例参数 // 初始化列表非常适合用来设置 final 变量的值 Size.fromJsonInit(Map json) : this.x = json['x'], this.y = json['y'];&#125; 常量构造函数（如果类需要提供一个状态不变的对象，通过 const 构造函数实现） 123456class ConstPoint &#123; final num x; final num y; const ConstPoint(this.x, this.y);&#125; 工厂方法构造函数（如果一个类不需要每次都提供一个新的对象，通过 factory 构造函数实现） 12345678910111213141516class HttpCore &#123; HttpCore._internal(); factory HttpCore() &#123; if (_instance == null) _instance = HttpCore._internal(); return _instance; &#125; static HttpCore _instance; static HttpCore get instance =&gt; HttpCore(); void _request()&#123; //... &#125;&#125; 每个类都隐式的定义了一个包含所有实例成员的接口， 并且这个类实现了这个接口，通过抽象类实现类似 Java 接口的功能。 12345678910abstract class Callback &#123; void print(String msg);&#125;class A implements Callback&#123; @override void print(String msg) &#123; print(msg); &#125;&#125; Mixins Dart | 什么是Mixin：https://www.jianshu.com/p/a578bd2c42aa 12、Asynchrony supportFuture 123456789loopIntegers() &#123; // 通过 then 进行获取到 Future 对象后的操作 getListDelay().then((ints) =&gt; ints.forEach((i) =&gt; print(i)));&#125;// 生成一个 Future 对象Future&lt;List&lt;int&gt;&gt; getListDelay() &#123; return Future.delayed(Duration(seconds: 2), () =&gt; List.generate(10, (delta) =&gt; delta));&#125; 通过 async await 简化 Future 操作 1234567891011121314runUsingFuture() &#123; //... findEntrypoint().then((entrypoint) &#123; return runExecutable(entrypoint, args); &#125;).then(flushThenExit);&#125;// 简化了 thenrunUsingAsyncAwait() async &#123; //... var entrypoint = await findEntrypoint(); var exitCode = await runExecutable(entrypoint, args); await flushThenExit(exitCode);&#125; 有时候要求调用很多异步方法，并且等待 所有方法完成后再继续执行，通过使用 Future.wait() 进行管理 12345678Future deleteDone = deleteLotsOfFiles();Future copyDone = copyLotsOfFiles();Future checksumDone = checksumLotsOfOtherFiles();Future.wait([deleteDone, copyDone, checksumDone]) .then((List values) &#123; print('Done with all the long steps'); &#125;); Stream Dart|什么是 Stream：https://www.jianshu.com/p/a5d7758938ef 大概了解了 Dart 的语法，下节就开始写 Flutter 啦~，环境的安装具体查看官网，很详细 Flutter 环境安装 记得一定要配置镜像，配置镜像，配置镜像 https://flutterchina.club/get-started/install/]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发环境搭建Mac版]]></title>
    <url>%2Fposts%2F3223dff5.html</url>
    <content type="text"><![CDATA[系统环境要求Flutter因为是新出的框架，所以对系统还是有一定的要求的。 MacOS （64-bit） 磁盘空间：大于700M，如果算上Android Studio等编辑工具，尽量大于3G。 命令号工具：bash、mkdir、rm、git、curl、unzip、which、brew 这些命令在都可以使用。 注意：一般你会在brew这个命令下载坑，很多mac系统都没有安装这个，你可以进行安装，因为这个和本知识关系性不大，所以我就不写流程了，如果你出现问题，直接点击链接学习安装就可以了。 学习安装brew：https://segmentfault.com/a/1190000013317511 下载Flutter SDK包这里推荐去官网下载就好，我挂了梯子，速度并不慢。 网址：https://flutter.dev/docs/development/tools/sdk/releases?tab=macos 配置环境变量压缩包下载好以后，找个位置进行解压。这个位置很重要，因为下面配置环境变量的时候要用到。比如你配置到了根目录下的app文件夹。 1.打开终端工具（这个我就不用写了吧），使用vim进行配置环境变量，命令如下： 1open ~/.bash_profile 在打开的文件里增加一行代码，意思是配置flutter命令在任何地方都可以使用。 1export PATH=/app/flutter/bin:$PATH 提示：这行命令你要根据你把压缩包解压的位置来进行编写，写的是你的路径，很有可能不跟文章一样。 配置完成后，需要用source命令重新加载一下 ，具体命令如下： 1source ~/.bash_profile 完成这部以后，就算我们flutter的安装工作完成了，但是这还不能进行开发。可以使用命令来检测一下，是否安装完成了。 1flutter -h 检查开发环境到上边为止，我们安装好了Flutter，但是还不具备开发环境。开发还需要很多软件和插件的支持，那到底需要哪些插件和软件那？我们可以使用Flutter为我们提供的命令来进行检查： 1flutter doctor 如果你英文很好，你应该可以很容易读出上面的检测结果，有很多条目都没有通过。需要我们安装检测结果一条条进行安装，直到满足开发环境。（如果有[!]x标志，表示本行检测没有通过，就需要我们设置或者安装相应的软件了。） 如果你有安装，那么第一步要作的是允许协议（android-licenses）。允许方法就是在终端运行如下命令： 1flutter doctor --android-licenses 然后让你输入Y/N的时候，一路Y就可以了（至于什么意思，我也没仔细看，大概就和安装软件的下一步下一步是一样的，你按N是不能成功的）。 这不完成后，我们再使用flutter doctor进行检测后，会看到还是有很多x。 其实大概意思就是我们需要这些软件，Flutter推荐你用brew命令进行安装。 我们可以直接在终端里输入下列命令（每输完一个都要等一会，等待软件包安装完成） 12345brew install --HEAD libimobiledevicebrew install ideviceinstallerbrew install ios-deploybrew install cocoapodspod setup 安装完这些，我们还需要为Android Studio安装一下Flutter插件（这个有可能你安装过，如果出现下面的提示，说明你还没有安装） 12✗ Flutter plugin not installed; this adds Flutter specific functionality.✗ Dart plugin not installed; this adds Dart specific functionality. 打开Android Stuido 软件，然后找到Plugin的配置，搜索Flutter插件。 点中间的Search in repositories,然后点击安装。 安装完成后，你需要重新启动一下Android Studio软件。 Pub源的配置如果你没有梯子，一个人人都知道的原因，你还需要在环境变量里配置一下Pub源，不然你是无法进行使用的。 运行： 1open ~/.bash_profile 增加两行配置 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 重新加载环境变量 1source ~/.bash_profile Android studio新建Flutter项目打开Andorid Studio ，会出现下面的界面，我们选择第二项，新建Flutter项目。 打开第二个窗口后，选择第一个选项Flutter Application(flutter应用)。 这步完成后，系统就会自动为我们创建一个Flutter项目 安装AVD虚拟机 现在需要一个虚拟机来运行我们的程序，可以点击Android Studio中的上方菜单tool -AVD Manager选项。 出现新建菜单，选择Create Virtual Device.....,如果你一个虚拟机也没建过，这个选项在对话框的中间 选择虚拟机类型，这个你随意选就好，我选择的是Nexus 5x。（如果你屏幕小，就选择一个小屏幕的虚拟机）![image-20190528113941915](/Users/zhangmiao/Library/Application Support/typora-user-images/image-20190528113941915.png) 选择系统，这里尽量选择最新的，我选择了Android 9.0系统，选择好后，又是一个漫长的等待过程。 安装好后，点击开始按钮，运行虚拟机了（第一次运行，需要安装系统，会慢一些），运行起来后，如下图。 让Flutter跑起来虚拟机运行以后，可以点击debug按钮，让Flutter程序跑起来。如果你幸运的话，你的Flutter程序经过编译后，就会跑起来了。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android和java泛型扫盲]]></title>
    <url>%2Fposts%2Fc4ef6275.html</url>
    <content type="text"><![CDATA[Android、Java泛型扫盲首先我们定义A、B、C、D四个类，他们的关系如下 1234class A &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125;class D extends C &#123;&#125; 不指明泛型类型12345678//以下代码均编译通过List list = new ArrayList();//不指明泛型类型，泛型默认为Object类型，故能往里面添加任意实例对象list.add(new A());list.add(new B());list.add(new C());//取出则默认为Object类型Object o = list.get(0); 这个好理解，因为所有的类都继承与Object，故能往list里面添加任意实例对象 无边界通配符 ？首先我们要明白一个概念，通配符？意义就是它是一个未知的符号，可以是代表任意的类。 123456789101112131415//我们发现，这样写编译不通过，原因很简单，泛型不匹配，虽然B继承AList&lt;A&gt; listA = new ArrayList&lt;B&gt;(); //以下5行代码均编译通过List&lt;?&gt; list;list = new ArrayList&lt;A&gt;();list = new ArrayList&lt;B&gt;();list = new ArrayList&lt;C&gt;();list = new ArrayList&lt;D&gt;();Object o = list.get(0); //编译通过list.add(new A()); //编译不通过list.add(new B()); //编译不通过list.add(new C()); //编译不通过list.add(new D()); //编译不通过 知识点 无边界通配符 ？ 能取不能存。这个好理解，因为编译器不知道?具体是啥类型，故不能存；但是任意类型都继承于Object，故能取，但取出默认为Object对象。 上边界符 ？extends继续上代码 123456789List&lt;? extends C&gt; listC;listC = new ArrayList&lt;A&gt;(); //编译不通过listC = new ArrayList&lt;B&gt;(); //编译不通过listC = new ArrayList&lt;C&gt;(); //编译通过listC = new ArrayList&lt;D&gt;(); //编译通过C c = listC.get(0); //编译通过listC.add(new C()); //编译不通过listC.add(new D()); //编译不通过 知识点 上边界符 ? extends 只是限定了赋值给它的实例类型(这里为赋值给listC的实例类型)，且边界包括自身。 上边界符 ? extends 跟 ？ 一样能取不能存，道理是一样的，虽然限定了上边界，但编译器依然不知道 ? 是啥类型，故不能存；但是限定了上边界，故取出来的对象类型默认为上边界的类型 下边界符 ？super1234567891011List&lt;? super B&gt; listB;listB = new ArrayList&lt;A&gt;(); //编译通过listB = new ArrayList&lt;B&gt;(); //编译通过listB = new ArrayList&lt;C&gt;(); //编译不通过listB = new ArrayList&lt;D&gt;(); //编译不通过Object o = listB.get(0); //编译通过listB.add(new A()); //编译不通过listB.add(new B()); //编译通过listB.add(new C()); //编译通过listB.add(new D()); //编译通过 知识点 下边界符 ？super，跟上边界符一样，只是限定了赋值给它的实例类型，也包括边界自身 下边界符 ？super 能存能取，因为设定了下边界，故我们能存下边界以下的类型，当然也包括边界自身；然而取得时候编译器依然不知道 ? 具体是什么类型，故取出默认为Object类型。 类型擦除首先我们要明白一点：Java 的泛型在编译期有效，在运行期会被删除 我们来看一段代码 123//这两个方法写在同一个类里public void list(List&lt;A&gt; listA) &#123;&#125; public void list(List&lt;B&gt; listB) &#123;&#125; 上面的代码会有问题吗？显然是有的，编译器报错，提示如下信息： list(List&lt;A&gt;) clashed with list(List&lt;B&gt;) ; both methods have same erasure 翻译过来就是，在类型擦除后，两个方法具有相同的签名，我们来看看类型擦除后是什么样子 12public void list(List listA) &#123;&#125; public void list(List listB) &#123;&#125; 可以看出，两个方法签名完全一致，故编译不通过。 明白了类型擦除，我们还需要明白一个概念 泛型类并没有自己独有的Class类对象 比如并不存在List.class或是List.class，而只有List.class 接下来这个案例就好理解了 123List&lt;A&gt; listA = new ArrayList&lt;A&gt;();List&lt;B&gt; listB = new ArrayList&lt;B&gt;();System.out.println(listA.getClass() == listB.getClass()); //输出true 泛型传递现实开发中，我们经常会用到泛型传递，例如我们经常需要对Http请求返回的结果做反序列化操作 1234567public static &lt;T&gt; T fromJson(String result, Class&lt;T&gt; type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 此时我们传进去是什么类型，就会返回自动该类型的对象 12345678String result="xxx";A a = fromJson(result, A.class);B b = fromJson(result, B.class);C c = fromJson(result, C.class);D d = fromJson(result, D.class);Integer integer = fromJson(result, Integer.class);String str = fromJson(result, String.class);Boolean boo = fromJson(result, Boolean.class); 那如果我们想返回一个集合呢，如List&lt;A&gt;，下面这样明显是不对的。 12//编译报错，前面类型擦除时，我们讲过，不存List&lt;A&gt;.class这种类型ArrayList&lt;A&gt; list = fromJson(result, ArrayList&lt;A&gt;.class)； 那我们该怎么做呢？首先，我们对fromJson改造一下，如下： 123456789//type为一个数组类型public static &lt;T&gt; List&lt;T&gt; fromJson(String result, Class&lt;T[]&gt; type) &#123; try &#123; T[] arr = new Gson().fromJson(result, type);//首先拿到数组 return Arrays.asList(arr); //数组转集合 &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 这个时候我们就可以这么做了 12345678String result="xxx";List&lt;A&gt; listA = fromJson(result, A[].class);List&lt;B&gt; listB = fromJson(result, B[].class);List&lt;C&gt; listC = fromJson(result, C[].class);List&lt;D&gt; listD = fromJson(result, D[].class);List&lt;Integer&gt; listInt = fromJson(result, Integer[].class);List&lt;String&gt; listStr = fromJson(result, String[].class);List&lt;Boolean&gt; listBoo = fromJson(result, Boolean[].class); ok，我在再来，相信大多数Http接口返回的数据格式是这样的： 123456public class Response&lt;T&gt; &#123; private T data; private int code; private String msg; //省略get/set方法&#125; 那这种我们又该如何传递呢？显然用前面的两个fromJson方法都行不通，我们再来改造一下，如下: 12345678//这里我们直接传递一个Type类型public static &lt;T&gt; T fromJson(String result, Type type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 这个Type是什么鬼？点进去看看 12345public interface Type &#123; default String getTypeName() &#123; return toString(); &#125;&#125; 哦，原来就是一个接口，并且只有一个方法，我们再来看看它的实现类 发现有5个实现类，其中4个是接口，另外一个是Class类，我们再来看看Class类的声明 123456public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; //省略内部代码&#125; 现在有没有明白点，现在我们重点来关注下Type接口的其中一个实现接口ParameterizedType，我们来看下它的内部代码，里面就只有3个方法 12345678910111213141516171819202122232425262728293031public interface ParameterizedType extends Type &#123; /** * 例如: * List&lt;String&gt; list; 则返回 &#123;String.class&#125; * Map&lt;String,Long&gt; map; 则返回 &#123;String.class,Long.class&#125; * Map.Entry&lt;String,Long&gt; entry; 则返回 &#123;String.class,Long.class&#125; * * @return 以数组的形式返回所有的泛型类型 */ Type[] getActualTypeArguments(); /** * 例如: * List&lt;String&gt; list; 则返回 List.class * Map&lt;String,Long&gt; map; 则返回 Map.class * Map.Entry&lt;String,Long&gt; entry; 则返回 Entry.class * * @return 返回泛型类的真实类型 */ Type getRawType(); /** * 例如: * List&lt;String&gt; list; 则返回 null * Map&lt;String,Long&gt; map; 则返回 null * Map.Entry&lt;String,Long&gt; entry; 则返回 Map.class * * @return 返回泛型类持有者的类型，这里可以简单理解为返回外部类的类型，如果没有外部类，则返回null */ Type getOwnerType();&#125; 顾名思义，ParameterizedType 代表一个参数化类型。 这个时候我们来自定义一个类，并实现ParameterizedType接口，如下： 12345678910111213141516171819202122public class ParameterizedTypeImpl implements ParameterizedType &#123; private Type rawType;//真实类型 private Type actualType;//泛型类型 public ResponseType(Type rawType,Type actualType) &#123; this.rawType = rawType; this.actualType = actualType; &#125; public Type[] getActualTypeArguments() &#123; return new Type[]&#123;actualType&#125;; &#125; public Type getRawType() &#123; return rawType; &#125; public Type getOwnerType() &#123; return null; &#125;&#125; 我们再次贴出fromJson方法 12345678//这里我们直接传递一个Type类型public static &lt;T&gt; T fromJson(String result, Type type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 此时我们想得到Response&lt;T&gt;对象，就可以这样写 123Response&lt;A&gt; responseA = fromJson(result, new ParameterizedTypeImpl(Response.class, A.class));Response&lt;B&gt; responseB = fromJson(result, new ParameterizedTypeImpl(Response.class, B.class));Response&lt;C&gt; responseC = fromJson(result, new ParameterizedTypeImpl(Response.class, C.class)); 想得到List&lt;T&gt;对象，也可以通过ParameterizedTypeImpl得到，如下: 123List&lt;A&gt; listA = fromJson(result, new ParameterizedTypeImpl(List.class, A.class));List&lt;B&gt; listB = fromJson(result, new ParameterizedTypeImpl(List.class, B.class));List&lt;C&gt; listC = fromJson(result, new ParameterizedTypeImpl(List.class, C.class)); 然而，如果我们想得到Response&lt;List&lt;T&gt;&gt;对象，又该如何得到呢？ ParameterizedTypeImpl一样能够实现，如下： 1234567891011121314//第一步，创建List&lt;T&gt;对象对应的Type类型Type listAType = new ParameterizedTypeImpl(List.class, A.class);Type listBType = new ParameterizedTypeImpl(List.class, B.class);Type listCType = new ParameterizedTypeImpl(List.class, C.class);//第二步，创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型Type responseListAType = new ParameterizedTypeImpl(Response.class, listAType);Type responseListBType = new ParameterizedTypeImpl(Response.class, listBType);Type responseListCType = new ParameterizedTypeImpl(Response.class, listCType);//第三步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType); 然后，能不能再简单一点呢？可以，我们对ParameterizedTypeImpl改造一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * User: ljx * Date: 2018/10/23 * Time: 09:36 */public class ParameterizedTypeImpl implements ParameterizedType &#123; private final Type rawType; private final Type ownerType; private final Type[] actualTypeArguments; //适用于单个泛型参数的类 public ParameterizedTypeImpl(Type rawType, Type actualType) &#123; this(null, rawType, actualType); &#125; //适用于多个泛型参数的类 public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... actualTypeArguments) &#123; this.rawType = rawType; this.ownerType = ownerType; this.actualTypeArguments = actualTypeArguments; &#125; /** * 本方法仅使用于单个泛型参数的类 * 根据types数组，确定具体的泛型类型 * List&lt;List&lt;String&gt;&gt; 对应 get(List.class, List.class, String.class) * * @param types Type数组 * @return ParameterizedTypeImpl */ public static ParameterizedTypeImpl get(@NonNull Type rawType, @NonNull Type... types) &#123; final int length = types.length; if (length &gt; 1) &#123; Type parameterizedType = new ParameterizedTypeImpl(types[length - 2], types[length - 1]); Type[] newTypes = Arrays.copyOf(types, length - 1); newTypes[newTypes.length - 1] = parameterizedType; return get(rawType, newTypes); &#125; return new ParameterizedTypeImpl(rawType, types[0]); &#125; //适用于多个泛型参数的类 public static ParameterizedTypeImpl getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments) &#123; return new ParameterizedTypeImpl(null, rawType, actualTypeArguments); &#125; public final Type[] getActualTypeArguments() &#123; return actualTypeArguments; &#125; public final Type getOwnerType() &#123; return ownerType; &#125; public final Type getRawType() &#123; return rawType; &#125;&#125; 此时，我们就可以这样写 123456789//第一步，直接创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型Type responseListAType = ParameterizedTypeImpl.get(Response.class, List.class, A.class);Type responseListBType = ParameterizedTypeImpl.get(Response.class, List.class, B.class)Type responseListCType = ParameterizedTypeImpl.get(Response.class, List.class, C.class)//第二步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType); 现实开发中，我们还可能遇到这样的数据结构 12345678&#123; "code": 0, "msg": "", "data": &#123; "totalPage": 0, "list": [] &#125;&#125; 此时，Response&lt;T&gt; 里面的泛型传List肯定是不能正常解析的，我们需要再定一个类 12345public class PageList&lt;T&gt;&#123; private int totalPage; private List&lt;T&gt; list; //省略get/set方法&#125; 此时就可以这样解析数据 123456789//第一步，直接创建Response&lt;PageList&lt;T&gt;&gt;对象对应的Type类型Type responsePageListAType = ParameterizedTypeImpl.get(Response.class, PageList.class, A.class);Type responsePageListBType = ParameterizedTypeImpl.get(Response.class, PageList.class, B.class)Type responsePageListCType = ParameterizedTypeImpl.get(Response.class, PageList.class, C.class)//第二步，通过Type对象，获取对应的Response&lt;PageList&lt;T&gt;&gt;对象Response&lt;PageList&lt;A&gt;&gt; responsePageListA = fromJson(result, responsePageListAType);Response&lt;PageList&lt;B&gt;&gt; responsePageListB = fromJson(result, responsePageListBType);Response&lt;PageList&lt;C&gt;&gt; responsePageListC = fromJson(result, responsePageListCType); 注：ParameterizedTypeImpl get(Type... types)仅仅适用于单个泛型参数的时候，如Map等，有两个泛型参数以上的不要用此方法获取Type类型。如果需要获取Map等两个泛型参数以上的Type类型。可调用getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments)构造方法获取，如： 12345//获取 Map&lt;String,String&gt; 对应的Type类型Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, String.classs, String.class)//获取 Map&lt;A,B&gt; 对应的Type类型Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, A.classs, B.class) 到这，泛型相关知识点讲解完毕，如有疑问，请留言。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5 to ESNext 自2015以来JavaScript新增的所有新特性]]></title>
    <url>%2Fposts%2Fbf9085e4.html</url>
    <content type="text"><![CDATA[这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。 JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。 JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。 目录ECMAScript 简介ES2015 let 和 const 箭头函数 类 默认参数 模板字符串 解构赋值 增强的对象字面量 For-of 循环 Promises 模块 String 新方法 Object 新方法 展开运算符 Set Map Generators ES2016 Array.prototype.includes() 求幂运算符 ES2017 字符串填充 Object.values() Object.entries() Object.getOwnPropertyDescriptors() 尾逗号 共享内存 and 原子操作 ES2018 Rest/Spread Properties Asynchronous iteration Promise.prototype.finally() 正则表达式改进 ESNext Array.prototype.{flat,flatMap} try/catch 可选的参数绑定 Object.fromEntries() String.prototype.{trimStart,trimEnd} Symbol.prototype.description JSON improvements Well-formed JSON.stringify() Function.prototype.toString() ECMAScript 简介每当阅读 JavaScript 相关的文章时，我都会经常遇到如下术语： ES3, ES5, ES6, ES7, ES8, ES2015, ES2016, ES2017, ECMAScript 2017, ECMAScript 2016, ECMAScript 2015 等等，那么它们是指代的是什么？ 它们都是指代一个名为 ECMAScript 的标准。 JavaScript 就是基于这个标准实现的，ECMAScript 经常缩写为 ES。 除了 JavaScript 以外，其它基于 ECMAScript 实现语言包括： ActionScript ( Flash 脚本语言)，由于 Adobe 将于 2020 年末停止对 Flash 的支持而逐渐失去热度。 JScript (微软开发的脚本语言),在第一次浏览器大战最激烈的时期，JavaScript 只被Netscape所支持，微软必须为 Internet Explorer 构建自己的脚本语言。 但是现在流传最广、影响最大的基于 ES 标准的语言实现无疑就是 JavaScript了 为啥要用这个奇怪的名字呢？Ecma International 是瑞士标准协会，负责制定国际标准。 JavaScript 被创建以后，经由 Netscape 和 Sun Microsystems 公司提交给欧洲计算机制造商协会进行标准化，被采纳的 ECMA-262 别名叫 ECMAScript。 This press release by Netscape and Sun Microsystems (the maker of Java) might help figure out the name choice, which might include legal and branding issues by Microsoft which was in the committee, according to Wikipedia. IE9 之后微软的浏览器中就看不到对 JScript 这个命名的引用了，取而代之都统称为 JavaScript。 因此，截至201x，JavaScript 成为最流行的基于 ECMAScript 规范实现的语言。 ECMAScript 当前的版本。目前的最新的 ECMAScript 版本是 ES2018。 于 2018 年 6 月发布。 TC39 是什么？TC39（Technical Committee 39）是一个推动 JavaScript 发展的委员会。 TC39的成员包括各个主流浏览器厂商以及业务与浏览器紧密相连的公司，其中包括 Mozilla，Google ，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。 每个标准版本提案都必须经过四个不同的阶段，这里有详细的解释。 ES Versions令我费解的是 ES 版本的命名依据有时根据迭代的版本号，有时却根据年份来进行命名。而这个命名的不确定性又使得人们更加容易混淆 JS/ES 这个两个概念😄。 在 ES2015 之前，ECMAScript 各个版本的命名规范通常与跟着标准的版本更新保持一致。因此，2009年 ECMAScript 规范更新以后的的正式版本是 ES5。 Why does this happen? During the process that led to ES2015, the name was changed from ES6 to ES2015, but since this was done late, people still referenced it as ES6, and the community has not left the edition naming behind — the world is still calling ES releases by edition number. 为什么会发生这一切？在ES2015诞生的过程中，名称由ES6更改为ES2015，但由于最终完成太晚，人们仍然称其为ES6，社区也没有将版本号完全抛之于后 — 世界仍然使用 ES 来定义版本号。 接下来，我们来深入了解 JavaScript 自 ES5 以来增加的特性。 let和constES2015 之前, var 是唯一可以用来声明变量的语句。 1var a = 0 上面语句如果你遗漏了 var，那么你会把这个值（0）赋给一个未声明的变量，其中声明和未声明变量之间存在一些差异。 在现代浏览器开启严格模式时，给未声明的变量赋值会抛出 ReferenceError 异常，在较老的浏览器（或者禁用严格模式）的情况下，未声明的变量在执行赋值操作时会隐式的变为全局对象的属性。 当你声明一个变量却没有进行初始化，那么它的值直到你对它进行赋值操作之前都是 undefined 。 1var a //typeof a === 'undefined' 你可以对一个变量进行多次重新声明，并覆盖它： 12var a = 1var a = 2 你也可以在一条声明语句中一次声明多个变量： 1var a = 1, b = 2 作用域是变量可访问的代码部分。 在函数之外用 var 声明的会分配给全局对象，这种变量可以在全局作用域中被访问到。而在函数内部声明的变量只能在函数局部作用域被访问到，这类似于函数参数。 在函数中定义的局部变量名如何跟全局变量重名，那么局部变量的优先级更高，在函数内无法访问到同名的全局变量。 需要注意的是，var 是没有块级作用域（标识符是一对花括号）的，但是 var 是有函数作用域的，所以在新创建的块级作用域或者是函数作用域里面声明变量会覆盖全局同名变量，因为 var 在这两种情况下没有创建新的作用域。 在函数内部，其中定义的任何变量在所有函数代码中都是可见的，因为JavaScript在执行代码之前实际上将所有变量都移到了顶层（被称为悬挂的东西）。 在函数的内部定义的变量在整个函数作用域中都是可见（可访问），即使变量是在函数体末尾被声明，但是仍然可以再函数体开头部分被引用，因为 JavaScript存在变量提升机制。为避免混淆，请在函数开头声明变量，养成良好的编码规范。 Using letlet 是ES2015中引入的新功能，它本质上是具有块级作用域的 var 。它可以被当前作用域（函数以及块级作用域）以及子级作用域访问到。 现代 JavaScript 开发者在 let 和 var 的选择中可能会更倾向于前者。 如果 let 看起来是一个很抽象的术语，当你阅读到 let color = ‘red’ 这一段，因为使用 let 定义了color 为红色，那么这一切就变的有意义了。 在任何函数之外用 let 声明变量，和 var相反的是 它并不会创建全局变量。 Using const使用变量 var 或 let 声明的变量可以被重新赋值。 使用 const 声明的变量一经初始化，它的值就永远不能再改变，即不可重新被赋值。 1const a = 'test' 我们不能再为 a 进行赋值操作。然而，a 如果它是一个具有属性或者方法的对象，那么我们可以改变它的属性或者方法。 const 并不意味着具有不可变性，只是保证用 const 声明的变量的引用地址不被变更。 类似于 let，const 也具有块级作用域。 现代 JavaScript 开发者在遇到不会进行二次赋值的变量声明时，应该尽量使用 const。 箭头函数箭头函数的引入极大的改变了代码的书写风格和一些工作机制。 在我看来，箭头函数很受开发者欢迎，现在很少在比较新的代码库中看到 function 关键字了，虽然它并未被废弃。 箭头函数看起来会更加的简洁，因为它允许你使用更短的语法来书写函数： 123const myFunction = function() &#123; //...&#125; 到 123const myFunction = () =&gt; &#123; //...&#125; 如果函数体中只包含一条语句，你甚至可以省略大括号并直接书写这条语句： 1const myFunction = () =&gt; doSomething() 参数在括号中传递： 1const myFunction = (param1, param2) =&gt; doSomething(param1, param2) 如果该函数只有一个参数，那么可以省略掉括号： 1const myFunction = param =&gt; doSomething(param) 由于这种简短的语法，使得我们可以更便捷的使用比较简短的函数 隐式返回箭头函数支持隐式返回：可以正常的 return 一个返回值但是可以不使用 return 关键字。 隐式返回只在函数体内只包含一条语句的情况下生效： 12const myFunction = () =&gt; 'test'myFunction() //'test' 需要注意的一种情况，当返回一个对象时，记得将大括号括在括号中以避免产生歧义，误将其（大括号）解析为函数体的大括号。 12const myFunction = () =&gt; (&#123; value:'test' &#125;)myFunction() //&#123;value: 'test'&#125; 箭头函数中的 thisthis 可能是一个很难掌握的概念，因为它会根据上下文而进行变化，并且会在不同的 JavaScript的模式（是否为严格模式）下表现出差异。 理解 this 这个概念对于箭头函数的使用很重要，因为与常规函数相比，箭头函数的表现非常不同。 对象的方法为常规函数时，方法中的this指向这个对象，因此可以这样做： 1234567const car = &#123; model:'Fiesta', manufacturer:'Ford', fullName:function() &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 执行 car.fullName() 会返回 “Ford Fiesta”。 如果上述方法使用是是箭头函数，由于箭头中的 this 的作用域继承自执行上下文，箭头函数自身不绑定 this，因此 this 的值将在调用堆栈中查找，因此在此代码 car.fullName() 中不会返回常规函数那样的结果，实际会返回字符串 “undefined undefined”： 1234567const car = &#123; model:'Fiesta', manufacturer:'Ford', fullName:() =&gt; &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 因此，箭头函数不适合作为对象方法。 同样，箭头函数也不适合使用在作为创建构造函数，因为在实例化对象时会抛出 TypeError。 所以在不需要动态上下文时请使用常规函数。 当然，在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数： 12345678const link = document.querySelector('#link')link.addEventListener('click', () =&gt; &#123; // this === window&#125;)const link = document.querySelector('#link')link.addEventListener('click', function() &#123; // this === link&#125;) Classes类JavaScript 实现继承的方式比较罕见：原型继承。原型继承虽然在我看来很棒，但与其它大多数流行的编程语言的继承实现机制不同，后者是基于类的。 因此 Java、Python 或其它语言的开发者很难理解原型继承的方式，因此 ECMAScript 委员会决定在原型继承之上实现 class 的语法糖，这样便于让其它基于类实现继承的语言的开发者更好的理解 JavaScript 代码。 注意：class 并没有对 JavaScript 底层做修改，你仍然可以直接访问对象原型。 class 定义如下是一个 class 的例子： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125; class 具有一个标识符，我们可以使用 new ClassIdentifier() 来创建一个对象实例。 初始化对象时，调用 constructor方法，并将参数传递给此方法。 类声明语句中也可以增加类需要的一些原型方法。在这种情况下 hello 是 Person 类的一个原型方法，可以在这个类的对象实例上调用： 12const flavio = new Person('Flavio')flavio.hello() Class 继承一个子类可以 extend 另一个类，通过子类实例化出来的对象可以继承这两个类的所有方法。 如果子类中的方法与父类中的方法名重复，那么子类中的同名方法优先级更高： 1234567class Programmer extends Person &#123; hello() &#123; return super.hello() + ' I am a programmer.' &#125;&#125;const flavio = new Programmer('Flavio')flavio.hello() (上述代码会打印出：“Hello, I am Flavio. I am a programmer.”) 类没有显示的类变量声明，但你必须在初始化构造函数 constructor 中去初始化类成员变量。 在子类中，你可以通过调用super()引用父类。 静态方法在类中，通常会把方法直接挂载到实例对象上，直接在实例对象上调用。 而静态方法则是直接使用类名来调用，而不是通过对象实例调用： 123456class Person &#123; static genericHello() &#123; return 'Hello' &#125;&#125;Person.genericHello() //Hello 私有方法JavaScript 没有内置真正意义上的受保护的私有方法。 社区有解决方法，但我不会在这里做讲解。 Getters 和 setters你可以通过增加方法 前缀 get 或者 set 创建一个 getter 和 setter，getter 和 setter会在你去获取特定值或者修改特定值的时候执行 get 或者 set内的相关方法。 1234567891011class Person &#123; constructor(name) &#123; this._name = name &#125; set name(value) &#123; this._name = value &#125; get name() &#123; return this._name &#125;&#125; 如果你只有 getter，该属性无法被设置，并且设置此属性的操作都会被忽略： 12345678class Person &#123; constructor(name) &#123; this._name = name &#125; get name() &#123; return this._name &#125;&#125; 如果你只有一个 setter，则可以更改该值，但不能从外部访问它： 12345678class Person &#123; constructor(name) &#123; this._name = name &#125; set name(value) &#123; this._name = value &#125;&#125; 默认参数函数 doSomething 接收一个 param1 参数。 12const doSomething = (param1) =&gt; &#123;&#125; 我们可以给 param1 设定默认值，如果在调用函数时未传入参数，那么该参数自动设定未默认值。 12const doSomething = (param1 = 'test') =&gt; &#123;&#125; 当然，这种机制同样适用于多个参数： 12const doSomething = (param1 = 'test', param2 = 'test2') =&gt; &#123;&#125; 假如你的函数是一个具有特定属性的对象该怎么处理？ 曾几何时，如果我们必须要取一个对象的特定属性值，为了做兼容处理（对象格式不正确），你必须在函数中添加一些代码： 1234567const colorize = (options) =&gt; &#123; if (!options) &#123; options = &#123;&#125; &#125; const color = ('color' in options) ? options.color :'yellow' ...&#125; 通过解构，你可以给特定属性提供默认值，如此可以大大简化代码： 123const colorize = (&#123; color = &apos;yellow&apos; &#125;) =&gt; &#123; ...&#125; 如果在调用 colorize 函数时没有传递任何对象，我们同样可以得到一个默认对象作为参数以供使用： 123const spin = (&#123; color = 'yellow' &#125; = &#123;&#125;) =&gt; &#123; ...&#125; 模板字符串模板字符串不同于 ES5 以前的版本，你可以用新颖的方式使用字符串。 这个语法看起来非常简便，只需要使用一个反引号替换掉单引号或双引号： 1const a_string = `something` 这个用法是独一无二的，因为它提供了许多普通字符串所没有的功能，如下： 它为定义多行字符串提供了一个很好的语法 它提供了一种在字符串中插入变量和表达式的简单方法 它允许您创建带有模板标签的DSL (DSL意味着领域特定语言，例如：就如同在 React 中使用 styled-components 定义你组件的 CSS 一样) 下面让我们深入每个功能的细节。 多行字符串在 ES6 标准之前，创建跨越两行的字符串只能在一行的结尾使用 ‘’ 字符： 123const string = 'first partsecond part' 这样使得你创建的字符串虽然跨越了两汉，但是渲染时仍然表现成一行： 1first part second part 需要渲染为多行的话，需要在一行结尾添加 ‘ ’，比如这样： 1234const string = 'first line second line' 或者 12const string = 'first line'+ 'second line' 模板字符串使得定义多行字符串变得更加简便。 一个模板字符串由一个反引号开始，你只需要按下回车键来创建新的一行，不需要插入特殊符号，最终的渲染效果如下所示： 1234const string = `Heythisstringis awesome!` 需要特别留意空格在这里是有特殊意义的，如果这样做的话： 12const string = `First Second` 那么它会创建出像下面的字符串： 12First Second 有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格： 123const string = `FirstSecond`.trim() 插值模板字符串提供了插入变量和表达式的便捷方法 你只需要使用 ${…} 语法 12const var = 'test'const string = `something $&#123;var&#125;` //something test 在 ${} 里面你可以加入任何东西，甚至是表达式： 12const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y'&#125;` Template tags标记模板可能是一个听起来不太有用的功能，但它实际上被许多流行的库使用，如 Styled Components 、Apollo 、GraphQL客户端/服务器库，因此了解它的工作原理至关重要。 在 Styled Components 模板标签中用于定义CSS字符串 1234const Button = styled.button` font-size: 1.5em; background-color: black; color: white; 在 Apollo 中，模板标签用于定义 GraphQL 查询模式： 12345const query = gql` query &#123; ... &#125;` 上面两个例子中的styled.button和gql模板标签其实都是函数: 1function gql(literals, ...expressions) &#123;&#125; 这个函数返回一个字符串，可以是任意类型的计算结果。 字面量(literals)是一个包含了表达式插值的模板字面量的序列。 表达式(expressions)包含了所有的插值。 举个例子： 1const string = `something $&#123;1 + 2 + 3&#125;` 这个例子里面的字面量是由2个部分组成的序列。第1部分就是something，也就是第一个插值位置(${})之前的字符串，第2部分就是一个空字符串，从第1个插值结束的位置直到字符串的结束。 这个例子里面的表达式就是只包含1个部分的序列，也就是6。 举一个更复杂的例子： 1234const string = `somethinganother $&#123;'x'&#125;new line $&#123;1 + 2 + 3&#125;test` 这个例子里面的字面量的序列里面，第1个部分是： 12;`somethinganother ` 第2部分是： 12;`new line ` 第3部分是： 12;`test` 这个例子里面的表达式包含了2个部分：x和6。 拿到了这些值的函数就可以对其做任意处理，这就是这个特性的威力所在。 比如最简单的处理就是字符串插值，把字面量和表达式拼接起来： 1const interpolated = interpolate`I paid $&#123;10&#125;€` 插值的过程就是： 12345678function interpolate(literals, ...expressions) &#123; let string = `` for (const [i, val] of expressions) &#123; string += literals[i] + val &#125; string += literals[literals.length - 1] return string&#125; 解构赋值给定一个object，你可以抽取其中的一些值并且赋值给命名的变量： 1234567const person = &#123; firstName:'Tom', lastName:'Cruise', actor:true, age:54, //made up&#125;const &#123;firstName: name, age&#125; = person name和age就包含了对应的值。 这个语法同样可以用到数组当中： 12const a = [1,2,3,4,5]const [first, second] = a 下面这个语句创建了3个新的变量，分别取的是数组a的第0、1、4下标对应的值： 1const [first, second, , , fifth] = a 更强大的对象字面量ES2015赋予了对象字面量更大的威力。 简化了包含变量的语法原来的写法： 1234const something = 'y'const x = &#123; something: something&#125; 新的写法： 1234const something = 'y'const x = &#123; something&#125; 原型原型可以这样指定： 12345678910111213const anObject = &#123; y:'y' &#125;const x = &#123; __proto__: anObject&#125;super()const anObject = &#123; y:'y', test:() =&gt; 'zoo' &#125;const x = &#123; __proto__: anObject, test() &#123; return super.test() + 'x' &#125;&#125;x.test() //zoox 动态属性1234const x = &#123; ['a' + '_' + 'b']:'z'&#125;x.a_b //z For-of循环2009年的ES5引入了forEach()循环。虽然很好用，但是它跟for循环一样，没法break。 ES2015引入了for-of 循环，就是在forEach的基础上加上了break的功能： 123456789//iterate over the valuefor (const v of ['a', 'b', 'c']) &#123; console.log(v);&#125;//get the index as well, using `entries()`for (const [i, v] of ['a', 'b', 'c'].entries()) &#123; console.log(index) //index console.log(value) //value&#125; 留意一下const的使用。这个循环在每次迭代中都会创建一个新的作用域，所以我们可以使用const来代替let。 它跟for…in的区别在于： for…of遍历属性值 for…in遍历属性名 Promisespromise的一般定义： 它是一个代理，通过它可以最终得到一个值. Promise是处理异步代码的一种方式，可以少写很多回调。 异步函数是建立在promise API上面的，所以理解Promise是一个基本的要求。 promise的原理简述一个promise被调用的时候，首先它是处于pending状态。在promise处理的过程中，调用的函数（caller）可以继续执行，直到promise给出反馈。 此时，调用的函数等待的promise结果要么是resolved状态，要么是rejected状态。但是由于JavaScript是异步的，所以promise处理的过程中，函数会继续执行。 为什么JS API使用promises?除了你的代码和第三方库的代码之外，promise在用在现代的Web API中，比如： 电池API Fetch API Service Workers 在现代的JavaScript中，不使用promise是不太可能的，所以我们来深入研究下promise吧。 创建一个promisePromise API暴露了一个Promise构造函数，可以通过new Promise()来初始化： 12345678910let done = trueconst isItDoneYet = new Promise((resolve, reject) =&gt; &#123; if (done) &#123; const workDone = 'Here is the thing I built' resolve(workDone) &#125; else &#123; const why = 'Still working on something else' reject(why) &#125;&#125;) promise会检查done这个全局变量，如果为true，就返回一个resolved promise，否则就返回一个rejected promise。 通过resolve和reject，我们可以得到一个返回值，返回值可以是字符串也可以是对象。 使用一个promise上面讲了怎么创建一个promise，下面就讲怎么使用（consume）这个promise。 1234567891011const isItDoneYet = new Promise()//...const checkIfItsDone = () =&gt; &#123; isItDoneYet .then(ok =&gt; &#123; console.log(ok) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;)&#125; 运行checkIfItsDone()方法时，会执行isItDoneYet()这个promise，并且等待它resolve的时候使用then回调，如果有错误，就用catch回调来处理。 链式promise一个promise可以返回另一个promise，从而创建promise链条（chain）。 一个很好的例子就是Fetch API，它是基于XMLHttpRequest API的一个上层API，我们可以用它来获取资源，并且在获取到资源的时候链式执行一系列promise。 Fetch API是一个基于promise的机制，调用fetch()相当于使用new Promise()来声明我们自己的promise。 链式promise的例子 12345678910111213141516const status = response =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return Promise.resolve(response) &#125; return Promise.reject(new Error(response.statusText))&#125;const json = response =&gt; response.json()fetch('/todos.json') .then(status) .then(json) .then(data =&gt; &#123; console.log('Request succeeded with JSON response', data) &#125;) .catch(error =&gt; &#123; console.log('Request failed', error) &#125;) 在这个例子当中，我们调用fetch()，从根目录的todos.json文件中获取一系列的TODO项目，并且创建一个链式promise。 运行fetch()方法会返回一个response，它包含很多属性，我们从中引用如下属性： status, 一个数值，表示HTTP状态码 statusText, 一个状态消息，当请求成功的时候返回OK response还有一个json()方法，它返回一个promise，返回内容转换成JSON后的结果。 所以这些promise的调用过程就是：第一个promise执行一个我们定义的status()方法，检查response status，判断是否一个成功的响应(status在200和299之间)，如果不是成功的响应，就reject这个promise。 这个reject操作会导致整个链式promise跳过后面的所有promise直接到catch()语句，打印Request failed和错误消息。 如果这个promise成功了，它会调用我们定义的json()函数。因为前面的promise成功之后返回的response对象，我们可以拿到并作为第2个promise的参数传入。 在这个例子里面，我们返回了JSON序列化的数据，所以第3个promise直接接收这个JSON： 123.then((data) =&gt; &#123; console.log('Request succeeded with JSON response', data)&#125;) 然后我们把它打印到console。 处理错误在上一节的的例子里面，我们有一个catch接在链式promise后面。 当promise链中的任意一个出错或者reject的时候，就会直接跳到promise链后面最近的catch()语句。 1234567891011new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;).catch(err =&gt; &#123; console.error(err)&#125;)// ornew Promise((resolve, reject) =&gt; &#123; reject('Error')&#125;).catch(err =&gt; &#123; console.error(err)&#125;) 级联错误如果在catch()里面抛出一个错误，你可以在后面接上第二个catch()来处理这个错误，以此类推。 123456789new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;) .catch(err =&gt; &#123; throw new Error('Error') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 组织多个promisePromise.all()如果你要同时完成不同的promise,可以用Promise.all()来声明一系列的promise，然后当它们全部resolve的时候再执行一些操作。 例子： 123456789const f1 = fetch('/something.json')const f2 = fetch('/something2.json')Promise.all([f1, f2]) .then(res =&gt; &#123; console.log('Array of results', res) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 结合ES2015的解构赋值语法，你可以这样写： 123Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123; console.log('Results', res1, res2)&#125;) 当然这不限于使用fetch， 这适用于任何promise. Promise.race()Promise.race()运行所有传递进去的promise，但是只要有其中一个resolve了，就会运行回调函数，并且只执行一次回调，回调的参数就是第一个resolve的promise返回的结果。 例子： 123456789const promiseOne = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, 'one')&#125;)const promiseTwo = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'two')&#125;)Promise.race([promiseOne, promiseTwo]).then(result =&gt; &#123; console.log(result) // 'two'&#125;) 模块ES Module是用于处理模块的ECMAScript标准。 虽然 Node.js 多年来一直使用 CommonJS标准，但浏览器却从未有过模块系统，因为模块系统的决策首先需要 ECMAScript 标准化后才由浏览器厂商去实施实现。 这个标准化已经完成在 ES2015中，浏览器也开始实施实现这个标准，大家试图保持一致，以相同的方式工作。现在 ES Module 可以在 Chrome Safari Edge 和 Firefox（从60版本开始） 中使用。 模块非常酷，他们可以让你封装各种各样的功能，同时将这些功能作为库暴露给其它 JavaScript 文件使用。 ES 模块语法引入模块的语法: 1import package from 'module-name' CommonJS 则是这样使用： 1const package = require('module-name') 一个模块是一个 JavaScript 文件，这个文件使用 export 关键字 导出 一个或多个值（对象、函数或者变量）。例如，下面这个模块提供了一个将字符串变成大写形式的函数： 12uppercase.jsexport default str =&gt; str.toUpperCase() 在这个例子中，这个模块定义了唯一一个 default export，因此可以是一个匿名函数。否则，需要一个名称来和其它 导出 做区分。 现在，任何其它的 JavaScript 模块 可以通过 import 导入 uppercase.js 的这个功能。 一个 HTML 页面可以通过使用了特殊的 type=module 属性的 &lt;script&gt; 标签添加一个模块。 1&lt;script type="module" src="index.js"&gt;&lt;/script&gt; 注意: 这个模块导入的行为就像 defer 脚本加载一样。具体可以看 efficiently load JavaScript with defer and async 需要特别注意的是，任何通过 type=”module” 载入的脚本会使用 严格模式 加载。 在这个例子中，uppercase.js 模块定义了一个 default export，因此当我们在导入它的时候，我们可以给他起一个任何我们喜欢的名字： 1import toUpperCase from './uppercase.js' 同时我们可以这样使用它: 1toUpperCase('test') //'TEST' 你也可以通过一个绝对路径来导入模块，下面是一个引用来自其它域底下定义的模块的例子： 1import toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js' 下面同样是一些合法的 import语法： 12import &#123; toUpperCase &#125; from '/uppercase.js'import &#123; toUpperCase &#125; from '../uppercase.js' 下面是错误的使用: 12import &#123; toUpperCase &#125; from 'uppercase.js'import &#123; toUpperCase &#125; from 'utils/uppercase.js' 因为这里既不是使用绝对地址，也不是使用的相对地址。 其它的 import/export 语法我们了解了上面的例子： 1export default str =&gt; str.toUpperCase() 这里生成了一个 default export。然而，你可以通过下面的语法在一个文件里面 导出 多个功能： 1234const a = 1const b = 2const c = 3export &#123; a, b, c &#125; 另外一个模块可以使用下面的方式 import 导入所有： 1import * from 'module' 你也可以通过解构赋值的方式仅仅 import 导出一部分： 12import &#123; a &#125; from 'module'import &#123; a, b &#125; from 'module' 为了方便，你还可以使用 as 重命名任何 import 的东西： 1import &#123; a, b as two &#125; from 'module' 你可以导入模块中的默认出口以及通过名称导入任何非默认的出口： 1import React, &#123; Component &#125; from 'react' 这是一篇关于 ES 模块的文章，可以看一下： https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html CORS(跨域资源共享)进行远程获取模块的时候是遵循 CORS 机制的。这意味着当你引用远程模块的时候，必须使用合法的 CORS 请求头来允许跨域访问（例如：Access-Control-Allow-Origin: *）。 对于不支持模块的浏览器应该怎么做？结合 type=”module”、nomodule 一起使用： 12&lt;script type="module" src="module.js"&gt;&lt;/script&gt;&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt; 包装模块ES 模块是现代浏览器中的一大特性。这些特性是 ES6 规范中的一部分，要在浏览器中全部实现这些特性的路还很漫长。 我们现在就能使用它们！但是我们同样需要知道，有一些模块会对我们的页面性能产生性能影响。因为浏览器必须要在运行时执行它们。 Webpack 可能仍然会被大量使用，即使 ES 模块可以在浏览器中执行。但是语言内置这个特性对于客户端和 nodejs 在使用模块的时候是一种巨大的统一。 新的字符串方法任何字符串有了一些实例方法： repeat() codePointAt() repeat() 根据指定的次数重复字符串： 1'Ho'.repeat(3) //'HoHoHo' 没有提供参数以及使用 0 作为参数的时候返回空字符串。如果给一个负数参数则会得到一个 RangeError 的错误。 codePointAt()这个方法能用在处理那些需要 2 个 UTF-16 单元表示的字符上。 使用 charCodeAt 的话，你需要先分别得到两个 UTF-16 的编码然后结合它们。但是使用 codePointAt() 你可以直接得到整个字符。 下面是一个例子，中文的 “𠮷” 是由两个 UTF-16 编码组合而成的： 12"𠮷".charCodeAt(0).toString(16) //d842"𠮷".charCodeAt(1).toString(16) //dfb7 如果你将两个 unicode 字符组合起来： 1"𠮷" //"𠮷" 你也可以用 codePointAt() 得到同样的结果: 1"𠮷".codePointAt(0) //20bb7 如果你将得到的 unicode 编码组合起来： 1"𠮷" //"𠮷" 更多关于 Unicode 的使用方法，参考我的Unicode guide。 新的对象方法ES2015 在 Object 类下引入了一些静态方法： Object.is() 确定两个值是不是同一个 Object.assign() 用来浅拷贝一个对象 Object.setPrototypeOf 设置一个对象的原型 Object.is() 这个方法用来帮助比较对象的值： 使用方式: 1Object.is(a, b) 返回值在下列情况之外一直是 false： a 和 b 是同一个对象 a 和 b 是相等的字符串(用同样的字符组合在一起的字符串是相等的) a 和 b 是相等的数字 a 和 b 都是 undefined, null, NaN, true 或者都是 false 0 和 -0 在 JavaScript 里面是不同的值, 所以对这种情况要多加小心（例如在比较之前，使用 + 一元操作符将所有值转换成 +0）。 Object.assign()在 ES2015 版本中引入，这个方法拷贝所有给出的对象中的可枚举的自身属性到另一个对象中。 这个 API 的基本用法是创建一个对象的浅拷贝。 1const copied = Object.assign(&#123;&#125;, original) 作为浅拷贝，值会被复制，对象则是拷贝其引用（不是对象本身），因此当你修改了源对象的一个属性值，这个修改也会在拷贝出的对象中生效，因为内部引用的对象是相同的。: 1234567891011const original = &#123; name:'Fiesta', car:&#123; color:'blue' &#125;&#125;const copied = Object.assign(&#123;&#125;, original)original.name = 'Focus'original.car.color = 'yellow'copied.name //Fiestacopied.car.color //yellow 我之前提到过，源对象可以是一个或者多个: 123456789const wisePerson = &#123; isWise:true&#125;const foolishPerson = &#123; isFoolish:true&#125;const wiseAndFoolishPerson = Object.assign(&#123;&#125;, wisePerson, foolishPerson)console.log(wiseAndFoolishPerson) //&#123; isWise: true, isFoolish: true &#125;Object.setPrototypeOf() 设置一个对象的原型。可以接受两个参数：对象以及原型。 使用方法: 1Object.setPrototypeOf(object, prototype) 例子: 1234567891011121314const animal = &#123; isAnimal:true&#125;const mammal = &#123; isMammal:true&#125;mammal.__proto__ = animalmammal.isAnimal //trueconst dog = Object.create(animal)dog.isAnimal //trueconsole.log(dog.isMammal) //undefinedObject.setPrototypeOf(dog, mammal)dog.isAnimal //truedog.isMammal //true 展开操作符你可以展开一个数组、一个对象甚至是一个字符串，通过使用展开操作符 …。 让我们以数组来举例，给出： 1const a = [1, 2, 3] 你可以使用下面的方式创建出一个新的数组： 1const b = [...a, 4, 5, 6] 你也可以像下面这样创建一个数组的拷贝： 1const c = [...a] 这中方式对于对象仍然有效。使用下面的方式克隆一个对象： 1const newObj = &#123; ...oldObj &#125; 用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组： 12const hey = 'hey'const arrayized = [...hey] // ['h', 'e', 'y'] 这个操作符有一些非常有用的应用。其中最重要的一点就是以一种非常简单的方式使用数组作为函数参数的能力： 123const f = (foo, bar) =&gt; &#123;&#125;const a = [1, 2]f(...a) （在之前的语法规范中，你只能通过 f.apply(null, a) 的方式来实现，但是这种方式不是很友好和易读。） 剩余参数（rest element）在和数组解构（array destructuring）搭配使用的时候非常有用。 12const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers 下面是展开元素 （spread elements）: 123const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) ES2018 引入了 剩余属性 ，同样的操作符但是只能用在对象上。 剩余属性（Rest properties）:12345678910const &#123; first, second, ...others &#125; = &#123; first:1, second:2, third:3, fourth:4, fifth:5&#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 属性展开（Spread properties）允许我们结合跟在 … 操作符之后对象的属性： 12const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; Set一个 Set 数据结构允许我们在一个容器里面增加数据。 一个 Set 是一个对象或者基础数据类型（strings、numbers或者booleans）的集合，你可以将它看作是一个 Map，其中值作为映射键，map 值始终为 true。 初始化一个 SetSet 可以通过下面的方式初始化： 1const s = new Set() 向 Set 中添加一项你可以使用 add 方法向 Set 中添加项： 12s.add('one')s.add('two') Set 仅会存贮唯一的元素，因此多次调用 s.add(‘one’) 不会重复添加新的元素。 你不可以同时向 set 中加入多个元素。你需要多次调用 add() 方法。 检查元素是否在 set 中我们可以通过下面的方式检查元素是否在 set 中： 12s.has('one') //trues.has('three') //false 从 set 中删除一个元素：使用 delete() 方法： 1s.delete('one') 确定 set 中元素的数量使用 size 属性： 1s.size 删除 set 中的全部元素使用 clear() 方法： 1s.clear() 对 set 进行迭代使用 keys() 或者 values() 方法 - 它们等价于下面的代码： 123456for (const k of s.keys()) &#123; console.log(k)&#125;for (const k of s.values()) &#123; console.log(k)&#125; entries() 方法返回一个迭代器，你可以这样使用它： 12const i = s.entries()console.log(i.next()) 调用 i.next() 将会以 { value, done = false } 对象的形式返回每一个元素，直到迭代结束，这时 done 是 true。 你也可以调用 set 的 forEach() 方法： 1s.forEach(v =&gt; console.log(v)) 或者你就直接使用 for..of 循环吧： 123for (const k of s) &#123; console.log(k)&#125; 使用一些初始值初始化一个 set你可以使用一些值初始化一个 set： 1const s = new Set([1, 2, 3, 4]) 将 set 转换为一个数组 123const a = [...s.keys()]// orconst a = [...s.values()] WeakSet一个 WeakSet 是一个特殊的 Set. 在 set 中，元素不会被 gc（垃圾回收）。一个 weakSet 让它的所有元素都是可以被 gc 的。weakSet 中的每个键都是一个对象。当这个对象的引用消失的时候，对应的值就可以被 gc 了。 下面是主要的不同点： WeakSet 不可迭代 你不能清空 weakSet 中的所有元素 不能够得到 weakSet 的大小 一个 weakSet 通常是在框架级别的代码中使用，仅仅暴露了下面的方法： add() has() delete() Map一份map结构的数据允许我们建立数据和key的关系 在ES6之前在引入Map之前，开发者通常把对象(Object)当Map使用，把某个object或value值与指定的key进行关联: 1234567const car = &#123;&#125;car['color'] = 'red'car.owner = 'Flavio'console.log(car['color']) //redconsole.log(car.color) //redconsole.log(car.owner) //Flavioconsole.log(car['owner']) //Flavio 引入Map之后ES6引入了Map数据结构，它为我们处理这种数据结构提供了一种合适的工具 Map的初始化: 1const m = new Map() 添加条目到Map中 你可以通过set()方法把条目设定到map中： 12m.set(&apos;color&apos;, &apos;red&apos;)m.set(&apos;age&apos;, 2) 通过key值从map中获取条目 你可以通过get()方法从map中取出条目: 12const color = m.get('color')const age = m.get('age') 通过key值从map中删除条目 使用delete()方法： 1m.delete('color') 从map中删除所有条目 使用clear()方法： 1m.clear() 通过key值检查map中是否含有某个条目 使用has()方法 1const hasColor = m.has('color') 获取map中的条目数量 使用 size 属性: 1const size = m.size 用value值初始化一个map 你可以用一组value来初始化一个map： 1const m = new Map([['color', 'red'], ['owner', 'Flavio'], ['age', 2]]) Map 的key值 任何值(对象，数组，字符串，数字)都可以作为一个map的value值(使用key-value键值的形式)，任何值也可以用作key，即使是object对象。 如果你想通过get()方法从map中获取不存在的key，它将会返回undefined 在真实世界中你几乎不可能找到的诡异情况 123456const m = new Map()m.set(NaN, 'test')m.get(NaN) //testconst m = new Map()m.set(+0, 'test')m.get(-0) //test 使用Iterate迭代器获取map的keys值 Map提供了keys()方法，通过该方法我们可以迭代出所有的key值: 123for (const k of m.keys()) &#123; console.log(k)&#125; 使用Iterate迭代器获取map的values值 Map提供了values()方法，通过该方法我们可以迭代出所有的value值: 123for (const v of m.values()) &#123; console.log(v)&#125; 使用Iterate迭代器获取key-value组成的键值对 Map提供了entries()方法，通过该方法我们可以迭代出所有的键值对: 123for (const [k, v] of m.entries()) &#123; console.log(k, v)&#125; 使用方法还可以简化为： 123for (const [k, v] of m) &#123; console.log(k, v)&#125; 将map的keys值转换为数组 1const a = [...m.keys()] 将map的values值转换为数组 1const a = [...m.values()] WeakMapWeakMap是一种特殊的Map 在一个map对象中，定义在其上数据永远不会被垃圾回收，WeakMap替而代之的是它允许在它上面定义的数据可以自由的被垃圾回收走，WeakMap的每一个key都是一个对象，当指向该对象的指针丢失，与之对应的value就会被垃圾回收走。 这是WeakMap的主要不同处： 你不可以在WeakMap上迭代keys值和values值(或者key-value键值对) 你不可以从WeakMap上清除所有条目 你不可以获取WeakMap的大小WeakMap提供了如下几种方法，这些方法的使用和在Map中一样： get(k) set(k, v) has(k) delete(k) 关于WeakMap的用例不如Map的用例那么明显，你可能永远也不会在哪里会用到它，但从实际出发，WeakMap可以构建不会干扰到垃圾回收机制的内存敏感性缓存，还可以满足封装的严谨性及信息的隐藏性需求。 Generators生成器Generators是一种特殊的函数，它能够暂停自身的执行并在一段时间后再继续运行，从而允许其它的代码在此期间运行(有关该主题的详细说明，请参阅完整的“javascript生成器指南”)。 Generators的代码决定它必须等待，因此它允许队列中的其它代码运行，并保留“当它等待的事情”完成时恢复其操作的权力。 所有这一切都是通过一个简单的关键字“yield`”完成的。当生成器包含该关键字时，将停止执行。 generator生成器可以包含许多yield关键字，从而使自己能多次停止运行，它是由*function关键字标识(不要将其与C、C++或Go等低级语言中使用的取消指针引用操作符混淆)。 Generators支持JavaScript中全新的编程范式，包括： 在generator运行时支持双向通信 不会“冻结”长期运行在程序中的while循环 这里有一个解释generator如何工作的例子： 12345function *calculator(input) &#123; var doubleThat = 2 * (yield (input / 2)) var another = yield (doubleThat) return (input * doubleThat * another)&#125; 我们先初始化它： 1const calc = calculator(10) 然后我们在generator中开始进行iterator迭代： calc.next()第一个迭代器开始了迭代，代码返回如下object对象： 1234&#123; done:false value:5&#125; 具体过程如下：代码运行了函数，并把input=10传入到生成器构造函数中，该函数一直运行直到抵达yield，并返回yield输出的内容: input / 2 = 5，因此，我们得到的值为5，并告知迭代器还没有done(函数只是暂停了)。 在第二个迭代处，我们输入7： 1calc.next(7) 然后我们得到了结果： 1234&#123; done:false value:14&#125; 7被作为doubleThat的值，注意：你可能会把input/2作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2. 然后，我们得到第二个yield的值，它返回doubleThat，因此返回值为14。 在下一个，也是最后一个迭代器，我们输入100 1calc.next(100) 这样我们得到: 1234&#123; done:true value:14000&#125; 当迭代器完成时(没有更多的yield关键字)，我们返回input doubleThat another，这相当于10 14100。 这些都是在2015年的ES2015引入的特性，现在我们深入了解下ES2016，它的作用域范围更小。 Array.prototype.includes()该特性引入了一种更简洁的语法，同来检查数组中是否包含指定元素。 对于ES6及更低版本，想要检查数组中是否包含指定元素，你不得不使用indexOf方法，它检查数组中的索引，如果元素不存在，它返回-1，由于-1被计算为true，你需对其进行取反操作，例子如下： 123if (![1,2].indexOf(3)) &#123; console.log('Not found')&#125; 通过ES7引入的新特性，我们可以如此做： 123if (![1,2].includes(3)) &#123; console.log('Not found')&#125; 求幂运算符求幂运算符**相当于Math.pow()方法，但是它不是一个函数库，而是一种语言机制： 1Math.pow(4, 2) == 4 ** 2 对于需要进行密集数学运算的程序来说，这个特性是个很好的增强，在很多语言中，**运算符都是标准(包括Python、Ruby、MATLAB、Perl等其它多种语言)。 这些都是2016年引入的特性，现在让我们进入2017年。 字符串填充字符串填充的目的是给字符串添加字符，以使其达到指定长度。 ES2017引入了两个String方法：padStart()和padEnd()。 12padStart(targetLength [, padString])padEnd(targetLength [, padString]) 使用例子： Object.values()该方法返回一个数组，数组包含了对象自己的所有属性，使用如下： 12const person = &#123; name:'Fred', age:87 &#125;Object.values(person) // ['Fred', 87] Object.values()也可以作用于数组： 12const people = ['Fred', 'Tony']Object.values(people) // ['Fred', 'Tony'] Object.entries()该方法返回一个数组，数组包含了对象自己的所有属性键值对，是一个[key, value]形式的数组，使用如下： 12const person = &#123; name:'Fred', age:87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] Object.entries()也可以作用于数组： 12const people = ['Fred', 'Tony']Object.entries(people) // [['0', 'Fred'], ['1', 'Tony']] Object.getOwnPropertyDescriptors()该方法返回自己(非继承)的所有属性描述符，JavaScript中的任何对象都有一组属性，每个属性都有一个描述符，描述符是属性的一组属性(attributes)，由以下部分组成： value: 熟悉的value值 writable: 属性是否可以被更改 get: 属性的getter函数, 当属性读取时被调用 set: 属性的setter函数, 当属性设置值时被调用 configurable: 如果为false, 不能删除该属性，除了它的value值以为，也不能更改任何属性。 enumerable: 该属性是否能枚举 Object.getOwnPropertyDescriptors(obj)接受一个对象，并返回一个带有描述符集合的对象。 In what way is this useful?ES6给我们提供了Object.assign()方法，它从一个一个或多个对象中复制所有可枚举的属性值，并返回一个新对象。 但是，这也存在着一个问题，因为它不能正确的复制一个具有非默认属性值的属性。 如果对象只有一个setter，那么它就不会正确的复制到一个新对象上，使用Object.assign()进行如下操作： 12345const person1 = &#123; set name(newName) &#123; console.log(newName) &#125;&#125; 这将不会起作用： 12const person2 = &#123;&#125;Object.assign(person2, person1) 但这将会起作用： 123const person3 = &#123;&#125;Object.defineProperties(person3, Object.getOwnPropertyDescriptors(person1)) 通过一个简单的console控制台，你可以查看以下代码： 12345person1.name = 'x'"x"person2.name = 'x'person3.name = 'x'"x" person2没有setter，它没能复制进去，对象的浅复制限定也出现在Object.create()方法中。 尾逗号该特性允许在函数定义时有尾逗号，在函数使用时可以有尾逗号： 1234const doSomething = (var1, var2,) =&gt; &#123; //...&#125;doSomething('test2', 'test2',) 该改变将鼓励开发者停止“在一行开始时写逗号”的丑陋习惯 异步函数JavaScript在很短的时间内从回调函数进化到Promise函数(ES2015)，并自从ES2017以来，异步JavaScript的async/wait语法变得更加简单。 异步函数是Promise和generator的结合，基本上，它是比Promise更高级的抽象，我再重复一般：async/await是基于Promise建立的 为什么要引入async/await它减少了围绕promise的引用，并打破了Promise — “不要打断链式调用”的限制。 当Promise在ES2015中引入时，它的本意是来解决异步代码的问题，它也确实做到了，但在ES2015和ES2017间隔的这两年中，大家意识到：Promise不是解决问题的终极方案。 Promise是为了解决著名的回调地狱而被引入的，但它本身也带来了使用复杂性和语法复杂性。 Promise是很好的原生特性，围绕着它开发人员可以探索出更好的语法，因此当时机成熟后，我们得到了async函数 async函数使代码看起来像是同步函数一样，但其背后却是异步和非堵塞的。 它如何工作一个async函数会返回一个promise，如下例： 12345const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125; 当你想要调用该函数时，你在前面加上了一个wait，这样调用就会被停止，直到该promise进行resolve或reject，需注意的是：外层函数必须定义为async，这是例子： 123const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125; 一个上手示例这是一个使用async/await进行异步函数的简单示例： 1234567891011const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 上面的代码将会在浏览器的console中打印出如下结果： 123BeforeAfterI did something //after 3s 关于 Promise将 async 关键字标记在任何函数上，意味着这个函数都将返回一个 Promise，即使这个函数没有显式的返回，它在内部也会返回一个 Promise，这就是下面这份代码有效的原因： 1234const aFunction = async () =&gt; &#123; return 'test'&#125;aFunction().then(alert) // This will alert 'test' 下面的例子也一样: 1234const aFunction = async () =&gt; &#123; return Promise.resolve('test')&#125;aFunction().then(alert) // This will alert 'test' 更易于阅读的代码正如上述的例子，我们将它与普通回调函数或链式函数进行比较，我们的代码看起来非常的简单。 这是一个很简单的例子，当代码足够复杂时，它会产生更多的收益。 例如，使用 Promise 来获取 JSON 资源并解析它： 12345678const getFirstUserData = () =&gt; &#123; return fetch('/users.json') // get users list .then(response =&gt; response.json()) // parse JSON .then(users =&gt; users[0]) // pick first user .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // get user data .then(userResponse =&gt; response.json()) // parse JSON&#125;getFirstUserData() 这是使用 async/await 实现相同功能的例子： 123456789const getFirstUserData = async () =&gt; &#123; const response = await fetch('/users.json') // get users list const users = await response.json() // parse JSON const user = users[0] // pick first user const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // get user data const userData = await user.json() // parse JSON return userData&#125;getFirstUserData() 串行多个异步功能async 函数非常容易，并且它的语法比 Promise 更易读。 12345678910111213141516const promiseToDoSomething = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 10000) &#125;)&#125;const watchOverSomeoneDoingSomething = async () =&gt; &#123; const something = await promiseToDoSomething() return something + ' and I watched'&#125;const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; &#123; const something = await watchOverSomeoneDoingSomething() return something + ' and I watched as well'&#125;watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; &#123; console.log(res)&#125;) 打印结果: 1I did something and I watched and I watched as well 更简单的调试调试 Promise 就很困难，因为调试器无法跨越异步代码，但调试 async/await 就非常的简单，调试器会像调试同步代码一样来处理它。 共享内存和原子WebWorkers 可以在浏览器中创建多线程程序。 它们通过事件的方式来传递消息，从 ES2017 开始，你可以使用 SharedArrayBuffer 在每一个 Worker 中和它们的创建者之间共享内存数组. 由于不知道写入内存部分需要多长的周期来广播，因此在读取值时，任何类型的写入操作都会完成，Atomics 可以避免竞争条件的发生。 关于它的更多细节可以在proposal中找到。 这是 ES2017，接下来我将介绍 ES2018 的功能。 Rest/Spread PropertiesES2015 引入了解构数组的方法，当你使用时： 12const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers and 展开参数: 123const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) ES2018 为对象引入了同样的功能。 解构: 1234const &#123; first, second, ...others &#125; = &#123; first:1, second:2, third:3, fourth:4, fifth:5 &#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 展开属性 允许通过组合在展开运算符之后传递的对象属性而创建新对象： 12const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; 异步迭代器for-await-of 允许你使用异步可迭代对象做为循环迭代： 123for await (const line of readLines(filePath)) &#123; console.log(line)&#125; 因为它使用的了 await，因此你只能在 async 函数中使用它。 Promise.prototype.finally()当一个 Promise 是 fulfilled 时，它会一个接一个的调用 then。 如果在这个过程中发生了错误，则会跳过 then 而执行 catch。 而 finally() 允许你运行一些代码，无论是成功还是失败： 1234fetch('file.json') .then(data =&gt; data.json()) .catch(error =&gt; console.error(error)) .finally(() =&gt; console.log('finished')) 正则表达式改进ES2018 对正则表达式引入了许多改进，这些都可以在 https://flaviocopes.com/javascript-regular-expressions/ 上找到。 以下是关于 ES2018 正则表达式改进的具体补充： RegExp lookbehind assertions: 根据前面的内容匹配字符串 这是一个 lookahead: 你可以使用 ?= 来匹配字符串，后面跟随一个特定的字符串： 123/Roger(?=Waters)//Roger(?=Waters)/.test('Roger is my dog') //false/Roger(?=Waters)/.test('Roger is my dog and Roger Waters is a famous musician') //true ?! 可以执行逆操作，如果匹配的字符串是no而不是在此后跟随特定的子字符串的话： 123/Roger(?!Waters)//Roger(?!Waters)/.test('Roger is my dog') //true/Roger(?!Waters)/.test('Roger Waters is a famous musician') //false Lookaheads 使用 ?= Symbol，它们已经可以用了。 Lookbehinds, 是一个新功能使用?&lt;=. 123/(?&lt;=Roger) Waters//(?&lt;=Roger) Waters/.test('Pink Waters is my dog') //false/(?&lt;=Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //true 如果一个 lookbehind 是否定，那么使用 ?&gt;!: 123/(?&lt;!Roger) Waters//(?&lt;!Roger) Waters/.test('Pink Waters is my dog') //true/(?&lt;!Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //false Unicode属性转义 p{…} and P{…}在正则表达式模式中，你可以使用 d 来匹配任意的数字，s 来匹配任意不是空格的字符串，w 来匹配任意字母数字字符串，以此类推。 This new feature extends this concept to all Unicode characters introducing p{} and is negation P{}. 这个新功能扩展了unicode字符，引入了 p{} 来处理 任何 unicode 字符都有一组属性，例如 script 确认语言，ASCII 是一个布尔值用于检查 ASCII 字符。你可以将此属性方在() 中，正则表达式将来检查是否为真。 123/^p&#123;ASCII&#125;+$/u.test('abc') //✅/^p&#123;ASCII&#125;+$/u.test('ABC@') //✅/^p&#123;ASCII&#125;+$/u.test('ABC🙃') //❌ ASCII_Hex_Digit 是另一个布尔值，用于检查字符串是否包含有效的十六进制数字： 12/^p&#123;ASCII_Hex_Digit&#125;+$/u.test('0123456789ABCDEF') //✅/^p&#123;ASCII_Hex_Digit&#125;+$/u.test('h') //❌ 此外，还有很多其它的属性。你可以在()中添加它们的名字来检查它们，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji等等： 1234/^p&#123;Lowercase&#125;$/u.test('h') //✅/^p&#123;Uppercase&#125;$/u.test('H') //✅/^p&#123;Emoji&#125;+$/u.test('H') //❌/^p&#123;Emoji&#125;+$/u.test('🙃🙃') //✅ 除了二进制属性外，你还可以检查任何 unicode 字符属性以匹配特定的值，在这个例子中，我检查字符串是用希腊语还是拉丁字母写的： 12/^p&#123;Script=Greek&#125;+$/u.test(&apos;ελληνικά&apos;) //✅/^p&#123;Script=Latin&#125;+$/u.test(&apos;hey&apos;) //✅ 阅读https://github.com/tc39/proposal-regexp-unicode-property-escapes 获取使用所有属性的详细信息。 Named capturing groupsIn ES2018 a capturing group can be assigned to a name, rather than just being assigned a slot in the result array: 123456789101112const re = /(?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;)/const result = re.exec('2015-01-02')// result.groups.year === '2015';// result.groups.month === '01';// result.groups.day === '02';The s flag for regular expressionsThe s flag, short for single line, causes the . to match new line characters as well. Without it, the dot matches regular characters but not the new line:/hi.welcome/.test('hiwelcome') // false/hi.welcome/s.test('hiwelcome') // true ESNext什么是 ESNext ？ ESNext 是一个始终指向下一个版本 JavaScript 的名称。 当前的 ECMAScript 版本是 ES2018，它于2018年6月被发布。 历史上 JavaScript 标准化的版本都是在夏季被发布，因此我们可以预期 ECMAScript 2019 将于 2019 年的夏季被发布。 所以在编写本文时 ES2018 已经被发布，因此 ESNext 指的是 ES2019。 ECMAScript 标准的提案是分阶段组织的，第一到第三阶段属于功能性的孵化，第四阶段的功能才最终确定为新标准的一部分。 在编写本文时主要浏览器都实现了第四阶段大部分的功能，因此我将在本文中介绍它们。 其中一些变化主要在内部使用，但知道发生了什么这也很好。 第三阶段还有一些其它功能，可能会在接下来的几个月内升级到第四阶段，你可以在这个 Github 仓库中查看它们：https://github.com/tc39/proposals。 1Array.prototype.&#123;flat,flatMap&#125; flat() 是一个新的数组实例方法，它可以将多维数组转化成一维数组。 例子: 12['Dog', ['Sheep', 'Wolf']].flat()//[ 'Dog', 'Sheep', 'Wolf' ] 默认情况下它只能将二维的数组转化成一维的数组，但你可以添加一个参数来确定要展开的级别，如果你将这个参数设置为 Infinity 那么它将展开无限的级别到一维数组： 123456['Dog', ['Sheep', ['Wolf']]].flat()//[ 'Dog', 'Sheep', [ 'Wolf' ] ]['Dog', ['Sheep', ['Wolf']]].flat(2)//[ 'Dog', 'Sheep', 'Wolf' ]['Dog', ['Sheep', ['Wolf']]].flat(Infinity)//[ 'Dog', 'Sheep', 'Wolf' ] 如果你熟悉数组的 map 方法，那么你就知道使用它可以对数组的每个元素执行一个函数。 flatMap() 是一个新的数组实例方法，它将 flat() 和 map 结合了起来，当你期望在map函数中做一些处理时这非常有用，同时又希望结果如同 flat ： 1234['My dog', 'is awesome'].map(words =&gt; words.split(' '))//[ [ 'My', 'dog' ], [ 'is', 'awesome' ] ]['My dog', 'is awesome'].flatMap(words =&gt; words.split(' '))//[ 'My', 'dog', 'is', 'awesome' ] Optional catch binding有时候我们并不需要将参数绑定到 try/catch 中。 在以前我们不得不这样做： 12345try &#123; //...&#125; catch (e) &#123; //handle error&#125; 即使我们从来没有通过 e 来分析错误，但现在我们可以简单的省略它： 1234567try &#123; //...&#125; catch &#123; //handle error&#125;Object.fromEntries()Objects have an entries() method, since ES2017. 从 ES2017 开始 Object将有一个 entries() 方法。 它将返回一个包含所有对象自身属性的数组的数组，如[key, value]： 12const person = &#123; name:'Fred', age:87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] ES2019 引入了一个新的 Object.fromEntries() 方法，它可以从上述的属性数组中创建一个新的对象： 123456const person = &#123; name:'Fred', age:87 &#125;const entries = Object.entries(person)const newPerson = Object.fromEntries(entries)person !== newPerson //trueString.prototype.&#123;trimStart,trimEnd&#125; 这些功能已经被 v8/Chrome 实现了近一年的时间，它将在 ES2019 中实现标准化。 trimStart()删除字符串首部的空格并返回一个新的字符串： 1234'Testing'.trimStart() //'Testing'' Testing'.trimStart() //'Testing'' Testing '.trimStart() //'Testing ''Testing'.trimStart() //'Testing' trimEnd()删除字符串尾部的空格并返回一个新的字符串： 1234'Testing'.trimEnd() //'Testing'' Testing'.trimEnd() //' Testing'' Testing '.trimEnd() //' Testing''Testing '.trimEnd() //'Testing' Symbol.prototype.description现在你可以使用 description 来获取 Symbol 的值，而不必使用 toString() 方法： 12const testSymbol = Symbol('Test')testSymbol.description // 'Test' JSON improvements在此之前 JSON 字符串中不允许使用分隔符（）和分隔符（）。 使用 JSON.parse 时，这些字符会导致一个 SyntaxError 错误，但现在它们可以正确的解析并如 JSON 标准定义的那样。 Well-formed JSON.stringify()修复 JSON.stringify() 在处理 UTF-8 code points (U+D800 to U+DFFF)。 在修复之前，调用 JSON.stringify() 将返回格式错误的 Unicode 字符，如（a “�”)。 现在你可以安全放心的使用 JSON.stringify() 转成字符串，也可以使用 JSON.parse() 将它转换回原始表示的形态。 Function.prototype.toString()函数总会有一个 toString 方法，它将返回一个包含函数代码的字符串。 ES2019 对返回值做了修改，以避免剥离注释和其它字符串（如：空格），将更准确的表示函数的定义。 If previously we had 以前也许我们这样过： 1function /* this is bar */ bar () &#123;&#125; 当时的行为： 1bar.toString() //'function bar() &#123;&#125; 现在的行为： 1bar.toString(); // 'function /* this is bar */ bar () &#123;&#125;' 总结一下，我希望这篇文章可以帮助你了解一些最新的 JavaScript 以及我们在 2019 年即将看见的内容。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程看这篇就够了]]></title>
    <url>%2Fposts%2F52228cda.html</url>
    <content type="text"><![CDATA[引如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。 用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。 很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码： 1234void transferMoney(User from, User to, float amount)&#123; to.setMoney(to.getBalance() + amount); from.setMoney(from.getBalance() - amount);&#125; 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。 好了，让我们开始吧。我准备分成几部分来总结涉及到多线程的内容： 扎好马步：线程的状态 内功心法：每个对象都有的方法（机制） 太祖长拳：基本线程类 九阴真经：高级多线程控制类 一、扎好马步：线程的状态先来两张图： ​ 线程状态 ​ 线程状态转换 各种状态一目了然，值得一提的是”Blocked”和”Waiting”这两个状态的区别： 线程在Running的过程中可能会遇到阻塞(Blocked)情况对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。从jdk源码注释来看，blocked指的是对monitor的等待（可以参考下文的图）即该线程位于等待区。 线程在Running的过程中可能会遇到等待（Waiting）情况线程可以主动调用object.wait或者sleep，或者join（join内部调用的是sleep，所以可看成sleep的一种）进入。从jdk源码注释来看，waiting是等待另一个线程完成某一个操作，如join等待另一个完成执行，object.wait()等待object.notify()方法执行。 Waiting状态和Blocked状态有点费解，我个人的理解是：Blocked其实也是一种wait，等待的是monitor，但是和Waiting状态不一样，举个例子，有三个线程进入了同步块，其中两个调用了object.wait()，进入了waiting状态，这时第三个调用了object.notifyAll()，这时候前两个线程就一个转移到了Runnable,一个转移到了Blocked。 从下文的monitor结构图来区别：每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态Blocked,从jstack的dump中来看是 “Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是Waiting，表现在jstack的dump中是 “in Object.wait()”。 此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 二、 内功心法：每个对象都有的方法（机制）synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们 他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 再讲用法： synchronized单独使用： 代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 12345678public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;&#125; 直接用于方法：相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。 12345public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125; synchronized, wait, notify结合:典型场景生产者消费者问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println("产品已满,请稍候再生产"); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println("生产者生产第" + this.product + "个产品."); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println("缺货,稍候再取"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println("消费者取走了第" + this.product + "个产品."); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; volatile 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。 针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。 三、太祖长拳：基本线程类基本线程类指的是Thread类，Runnable接口，Callable接口Thread 类实现了Runnable接口，启动一个线程的方法： 12 MyThread my = new MyThread(); my.start(); Thread类相关方法： 12345678//当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）public static Thread.yield()//暂停一段时间public static Thread.sleep()//在一个线程中调用other.join(),将等待other执行完后才继续本线程。 public join()//后两个函数皆可以被打断public interrupte() 关于中断：它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。Thread.interrupted()检查当前线程是否发生中断，返回booleansynchronized在获锁的过程中是不能被中断的。 中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体 Thread类最佳实践：写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。 如何获取线程中的异常 ​ 不能用try,catch来获取线程中的异常 Runnable 与Thread类似 Callable future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态 12345ExecutorService e = Executors.newFixedThreadPool(3); //submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.Future future = e.submit(new myCallable());future.isDone() //return true,false 无阻塞future.get() // return 返回值，阻塞直到该线程运行结束 四、九阴真经：高级多线程控制类以上都属于内功心法，接下来是实际项目中常用到的工具了，Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。 1.ThreadLocal类 用处：保存线程的独立变量。对一个线程类（继承自Thread)当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。 实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。 主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。 2.原子类（AtomicInteger、AtomicBoolean……） 如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized 12//返回值为booleanAtomicInteger.compareAndSet(int expect,int update) 该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为： 123456if(b.value.compareAndSet(old, value))&#123; return ;&#125;else&#123; //try again // if that fails, rollback and log&#125; AtomicReference 对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号 3.Lock类 lock: 在java.util.concurrent包内。共有三个实现： ReentrantLock ReentrantReadWriteLock.ReadLock ReentrantReadWriteLock.WriteLock 主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。 区别如下： lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序） 提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。 本质上和监视器锁（即synchronized是一样的） 能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。 和Condition类的结合。 性能更高，对比如下图： ​ synchronized和Lock性能对比 ReentrantLock 可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。使用方法是： 1.先new一个实例 1static ReentrantLock r=new ReentrantLock(); 2.加锁 1r.lock()或r.lockInterruptibly(); 此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch） 3.释放锁 1r.unlock() 必须做！何为必须做呢，要放在finally里面。以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。 ReentrantReadWriteLock 可重入读写锁（读写锁的一个实现） 123 ReentrantReadWriteLock lock = new ReentrantReadWriteLock() ReadLock r = lock.readLock(); WriteLock w = lock.writeLock(); 两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码 4.容器类 这里就讨论比较常用的两个： BlockingQueue ConcurrentHashMap BlockingQueue 阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管 道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究 BlockingQueue在队列的基础上添加了多线程协作的功能： 除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队 列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。 常见的阻塞队列有： ArrayListBlockingQueue LinkedListBlockingQueue DelayQueue SynchronousQueue ConcurrentHashMap 高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap 5.管理类 管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean ThreadPoolExecutor 如果不了解这个类，应该了解前面提到的ExecutorService，开一个自己的线程池非常方便： 12345678ExecutorService e = Executors.newCachedThreadPool(); ExecutorService e = Executors.newSingleThreadExecutor(); ExecutorService e = Executors.newFixedThreadPool(3); // 第一种是可变大小线程池，按照任务数来分配线程， // 第二种是单线程池，相当于FixedThreadPool(1) // 第三种是固定大小线程池。 // 然后运行 e.execute(new MyRunnableImpl()); 该类内部是通过ThreadPoolExecutor实现的，掌握该类有助于理解线程池的管理，本质上，他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc： ​ ThreadPoolExecutor参数解释 翻译一下：corePoolSize:池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。maximumPoolSize:线程最大值，线程的增长始终不会超过该值。keepAliveTime：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态unit：时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS workQueue:待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿死(starving)threadFactory:线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让我们聊一聊计算机基础知识的最小集合组]]></title>
    <url>%2Fposts%2F2d2dd747.html</url>
    <content type="text"><![CDATA[前言很多人工作后痛感计算机基础知识的缺乏， 那计算机基础知识都有哪些呢？ 我觉得首先计算机专业的那六大件：组成原理，操作系统，数据库，编译原理，计算机网络，数据结构（这个说太多遍了，这次不再讲了）， 其次还得加上分布式的基础知识， 因为现在的系统都变成分布式的了。 如果你是做应用层开发的，那几门课程中的有些内容和日常工作关联度不大，我挑那些最重要的来说一说，也算是一个最小集合吧！ 一、计算机组成原理如果你不是做操作系统/驱动程序的，直接和硬件打交道的机会很少，因为操作系统已经把他们屏蔽掉了，提供了抽象的API给我们使用。 但是还必须理解冯诺依曼体系的结构，CPU和内存，硬盘，各种外设之间的关系，寄存器、缓存等知识。 CPU有哪些指令，如何执行这些指令，如果实现数组，结构体，函数调用，这就涉及到汇编的知识。 像原码，反码，补码，定点数、浮点数的表示和运算也是编程中必备的知识，几乎每种语言都要涉及。 现在很多语言都是在虚拟机上运行的，你只要是了解了计算机的组成原理，再去看哪些虚拟机，就会发现概念都是相通的。 另外CPU中的缓存，缓存一致性协议，DMA的异步思想都会在应用层中有所体现。 如果能找一本书，尽可能多的囊括这些知识的话，我觉得还是神书《深入理解计算机系统》的前4章。 《编码》是一个更加科普性，但是也更加有趣的讲组成原理的书。 二、操作系统言操作系统是比较枯燥的， 站在应用层的角度，我认为重点是掌握操作系统对外提供的抽象，包括进程、线程，文件，虚拟内存，以及进程间的通信问题。 几乎所有的编程语言都会涉及到对多进程或者多线程编程的支持， 特别是多线程的并发编程，所以必须得搞明白他们的本质是什么，线程都有哪些实现方式（对以后学习各种语言和并发模型有极大好处）。得真正地体会到“进程是资源分配的最小单位，线程是调度的最小单位。” 这句话的含义。 几乎所有的编程语言都会涉及到锁和死锁，最好在最底层理解锁是怎么实现的。 需要理解虚拟内存和物理内存直接的关系，分段和分页，文件系统的基本原理。 对于进程的调度，页面分配/置换算法，磁盘的调度算法，I/O系统，我认为优先级比较低。 三、计算机网络我认为必须要理解的是这些： 什么分组交换 TCP可靠性传输原理，TCP/IP的协议细节， 三次握手，四次挥手，TCP状态转换。 几个重要的协议DHCP，UDP, ARP, DNS。 能够说出一个客户端如何在接入网络以后，通过这些协议，跨域网络和服务器通信的。 和应用层结合非常紧密的Socket知识和网络安全（对称加密，非对称加密，Hash, 数字签名，以及集大成者Https） 至于网络层的路由选择算法，链路层的各种协议，我认为优先级比较低。 还有一个重要的知识点，一般的网络书都没提，就是I/O多路复用，涉及到同步/异步，阻塞/非阻塞，select/epoll ，这个是很多软件的基础，在《Unix网络编程》，《深入理解计算机系统》中有讲述。 以上这些知识，在你学习Redis ,Ngnix, Tomcat, LVS等软件时将有极大的帮助。 四、数据库你这一辈子也许都不会去写一个编译器，但是很有可能会利用现成的工具去生成/操作一个抽象语法树（AST），甚至可以会写一个DSL（领域特定语言）。所以你得理解词法分析、语法分析、语义分析，中间代码生成，代码优化这个基本编译的过程。 学习了编译与原理，会对语言的一些设计有更深的理解，比如LISP。 五、分布式的理论知识由于现在的系统慢慢地变成了分布式， 所以又扩展出了很多相关基础知识需要学习： 数据复制与一致性: CAP理论， BASE原则，幂等性, 2PC, TCC Paxos , Raft , Gossip 数据分片和路由: Hash分片：Hash取模（实际中非常常见的算法）， 虚拟桶（Redis使用），一致性Hash（memcached使用） 范围分片 最后想说的是，不能带着特别功利的目的去学习这些基础，不能想着立刻、马上就应用到实战中，从中获益。更重要的理解掌握它们背后的思想，有一天你会发现：奥，这个问题我在哪里见过，可以用类似的办法来解决啊！]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-数组]]></title>
    <url>%2Fposts%2F979f2162.html</url>
    <content type="text"><![CDATA[一、创建方法1、空数组1var Obj = new Array(); 2、指定长度数组1var Obj = new Array(Size); 3、指定元素数组1var Obj = new Array(元素1,元素2,元素3,...,元素N); 4、单维数组1var Obj = [元素1,元素2,元素3,...,元素N] 5、多维数组1var a = new Array([数组序列1],[数组序列2],[数组序列N]); 二、基本操作1、存取数组元素 单维数组 1数组名[下标索引] 多维数组 1数组名[外层数组下标][内层元素下标] 特性 数组长度是弹性的，可自由伸缩 数组下标从0开始 下标类型 数值 非数值 转为字符串 生成关联数组 下标将作为对象属性的名字 数组元素可添加到对象中 2、增加数组1使用“[]”运算符指定一个新下标 3、删除数组1delete数组名[下标]; 4、遍历数组1for(var 数组元素变量 in 数组) 三、数组属性1、constructor引用数组对象的构造函数 2、length返回数组的长度 3、prototype通过增加属性和方法扩展数组定义 四、ECMAScript 3 方法1、添加 push() 在数组末尾增加数组 unshift 在数组头部添加元素 concat 合并两个数组 2、删除 pop() 删除并返回数值的最后一个元素 shift() 删除并返回数组的第一个元素 队列方法，先进先出 栈方法，后进先出 3、子数组 splice() 删除任意数量的项 要删除的起始下标 要删除的项数 在指定位置插入指定的项 起始下标 0（不删除任何项） 要插入的项 替换任意数量的项 起始下标 要删除的项数 要插入的项 功能 从已有数组中选取部分元素构成新数组 参数 返回项的起始位置 返回项的结束位置 特性 如果是负数，则用数组长度加上该值确定位置 起始位置实为数组的实际下标 结束位置的实际下标为结束数值减1 4、数组排序 reverse() 颠倒数组中元素的顺序 sort() 功能：对字符数组或数字数组进行排序 特性：按数值大小比较，需函数支持（升序） 12345678910functioncompare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125;&#125; 5、数组转换 toString() 转换为字符串并返回 toLocaleString() 转换为本地格式字符串并返回 join() 用指定分隔符分割数组并转换为字符串 五、ECMAScript 5 方法1、位置方法 indexof 从数组的起始位置开始查找 lastIndexof 从数组的结束位置开始查找 参数 要查找的项 标识查找起点的位置索引 2、迭代方法 every 如果该函数对每一项都返回true，则返回true filter 返回值为true的所有数组成员 forEach 无返回值 map 返回每次函数调用的结果数组 some 有任意一项返回true，则返回true 参数 接收参数 要在每一项上运行的函数 运行该函数的作用域对象 传入参数 数组项的值 item 该项在数组中的位置index 数组对象本身 array 3、缩小方法 reduce 从数组起始位开始遍历 reduceRight 从数组末尾开始遍历 参数 接收参数 每一项上调用的函数 作为缩小基础的初始值 传入参数 前一个值 prev 当前值 cur 项的索引 index 数组对象 array]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-函数基础]]></title>
    <url>%2Fposts%2F5768cb4e.html</url>
    <content type="text"><![CDATA[一、定义方法1、静态方法1234function 函数名([虚参数列表])&#123; 函数体; [return[函数返回值;]]&#125; 2、动态匿名方法var 函数名 = new Function([“虚参数列表”],”函数体”); 3、直接量方法函数名 = function([虚参数列表]){函数体;} 二、调用方法1、直接调用函数名(实参列表) 2、在连接中调用1&lt;a herf = &quot;javascript:函数名()&quot;&gt;描述字&lt;/a&gt; 3、在事件中调用事件类型 = “函数名()” 4、递归调用 定义 在函数体内部调用函数自身 格式 1234function 函数名()&#123; 代码; 函数名();&#125; 三、方法1、apply 将函数作为对象的方法来调用 将参数以数组形式传递给该方法 2、call 将函数作为对象的方法来调用 将指定参数传递给该方法 3、toString 返回函数的字符串表示 四、arguments对象1、功能 存放实参的参数列表 2、特性 仅能在函数体内使用 带有下标属性，并非数组 函数声明时自动初始化 3、属性 length 获取函数实参的长度 callee 返回当前正在指向的函数 caler 返回调用当前正在执行的函数的函数名 五、函数参数1、参数类型 形参 定义函数时使用的参数 接收该函数时传递的参数 实参 调用函数时传递给函数的实际参数 2、特性 参数个数没有限制 实参 &lt; 形参 ：多余形参 = undefined 实参 &gt; 形参 ：多余实参被忽略 参数的数据类型没有限制 通过arguments对象访问参数数组 参数始终按值传递 基本类型：传值 引用类型：传址 六、指针标识1、this指向当前操作对象 2、callee指向形参集合所属函数 3、prototype指向函数附带的原型对象 4、constructor指向创建该对象的构造函数]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-运算符]]></title>
    <url>%2Fposts%2F4cf212f3.html</url>
    <content type="text"><![CDATA[一、算术运算符1、运算符a、+ 功能 对数字进行代数求和 对字符串进行连接操作 将一个数值转换成字符串（数值+空字符串） 字符串拼接 字符串+字符串（二者直接拼接） 字符串+数值（数值转为字符串再拼接） b、- 功能 对操作数进行“取反”操作 对数字进行减法操作 将字符串转换成数值（数值型字符串 - 0） c、* 功能 对两个运算数进行乘法运算 符号问题 同号得正，异号得负 d、/ 功能 对两个运算数进行除法运算 符号问题 同号得正，异号得负 e、% 功能 返回两个除数的余数 符号问题 和第一个运算数的符号相同 2、复合赋值运算符 +=、- =、*=、/=、%= 二、自增与自减1、功能相反 ++：对唯一的运算数进行递增操作（每次加1） —：对唯一的运算数进行递减操作（每次减1） 2、规则相同 运算数必须是一个变量、数组的一个元素或者对象的属性 如果运算数是非数值的则运算符会将它转成数值 3、符号位置决定运算结果 运算数之前：先进行递增（递减）操作，再进行求值 运算数之后：先求值，再进行递增（递减）操作 三、关系运算符1、大小关系检测a、运算符 &lt; ：如果A小于B，则返回true，否则返回false &lt;=：如果A小于等于B，则返回true，否则返回false &gt;=：如果A大于等于B，则返回true，否则返回false &gt;：如果A大于B，则返回true，否则返回false b、操作规则 数值与数值的比较：比较它们的代数值 仅一个运算数是数值：将另一个运算数转换成数值，并比较它们的代数值 字符串间的比较：逐字符比较它们的Unicode数值 字符串与非数值的比较：将运算符转换成字符串并进行比较 运算数即非数值也非字符串：转换成数值或字符串后进行比较 运算数无法转换成数值或字符串：返回值为false 与NaN的比较：返回值为false 2、等值关系检测a、相等比较 操作符 ==：比较两个运算数的返回值看是否相等 !=：比较两个运算数的返回值看是否不相等 类型转换 布尔值 true：1 false：0 对象 调用valueOf()，基本类型 字符串与数值的比较 字符串转换为数值 比较原则 null与undefined 相等 比较前不进行任何转换 NaN 与任何数值都不相等包括其本身 对象 是否属于同一对象 是：== 否：!= b、相同比较 运算符 ===：比较两个运算数的返回值及数据类型看是否相同 !==：比较两个运算数的返回值及数据类型看是否不同 比较原则 值类型比较 只有数据类型相同，且数值相等时才能够相同 值类型与引用类型比较 肯定不相同 引用类型间比较 比较它们的引用值（内存地址） 四、对象运算符 in：判断左侧运算数是否为右侧运算数的成员 instancesof：判断对象实例是否属于某个类或构造函数 new：根据构造函数创建一个新的对象，并初始化该对象 delete：删除指定对象的属性，数组元素或变量 .及[]：存取对象或数组元素 ()：函数调用，改变运算运算符优先级等 五、逻辑运算符1、! 逻辑非a、返回值 true 空字符串 0 null NaN undefined false 对象 非空字符串 非0数值（Infinity） b、特性 如果运算数的值为false则返回true，否则返回false 连续使用两次!，可将任意类型转为布尔值 2、&amp;&amp;逻辑与a、规则 第一个操作数是对象：返回第二个操作数 第二个操作数是对象：第一个操作数值为true时返回该对象 两个操作数都是对象：返回第二个操作数 一个操作数是null：返回null 一个操作数是NaN：返回NaN 一个操作数是undefined：返回undefined b、特性 当且仅当两个运算数的值都是true时，才返回true，否则返回false 短路操作：当第一个操作数的值为false则不再对第二个操作数进行求值 3、||逻辑或a、规则 第一个操作数是对象：返回第一个操作数 第一个操作数值为false：返回第二个操作数 两个操作数都是对象：返回第一个操作数 两个操作数是null：返回null 两个操作数是NaN：返回NaN 两个操作数是undefined：返回undefined b、特性 当且仅当连个运算数的值都是false时，才返回false，否则返回true 如果第一个操作数为true，则不会对第二个操作数进行求值 六、位运算符1、基础知识a、类型 有符号 数值位：前31位 符号位：第32位 0：正数 1：负数 无符号 只能是正数 第32位表示数值 数值范围可以加大 b、数值范围 - 2147483648 ~ 2147483647 c、存储方式 正数 纯二进制存储 31位中每一位表示2的幂 用0补充无用位 负数 二进制补码存储 补码的计算步骤 确定该数字的非负版本的二进制表示 求得二进制反码，既要把0替换为1，把1替换为0 在二进制反码上加1 d、当做0来处理的特殊值 NaN Infinity 2、逻辑位运算符a、返回值为1 按位非~：0 按位与&amp;：对应位全是1 按位或|：任何一位都是1 按位异或^：既不同时为0，也不同时为1 b、返回值为0 按位非~：1 按位与&amp;：任何一位都是0 按位或|：对应位全是0 按位异或^：对应位全是0或全是1 3、位移操作a、左移&lt;&lt; 将数值的所有位左移指定的位数 所有空位用0补充 左移1位对其乘2，左移2为对其乘4，以此类推 b、有符号右移&gt;&gt; 将数值的所有位右移指定的位数 移除位被舍弃 保留符号位 右移1位对其除2，右移2为对其除4，以此类推 c、无符号右移&gt;&gt; 正数：与有符号右移结果相同 负数：会出现无限大的数值 4、复合赋值运算符 位操作符与等号结合，复合赋值不会有性能方面的提升 七、其他运算符1、? 条件运算符，简洁的if else 2、type of 类型判定运算符 3、, 逗号，在一行语句中执行多个不同的操作 4、void 舍弃运算数的值，返回undefined作为表达式的值]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-DOM基本操作]]></title>
    <url>%2Fposts%2Faf67cb0c.html</url>
    <content type="text"><![CDATA[一、获取节点1、document getElementById 语法：document.getElementById(元素id) 功能：通过元素ID获取节点 getElementByName 语法：document.getElementByName(元素name属性) 功能：通过元素的name属性获取节点 getElementByTagName 语法：document.getElementByTagName(元素标签) 功能：通过元素标签获取节点 2、节点指针 firstChild 语法：父节点.firstChild 功能：获取元素的首个子节点 lastChild 语法：父节点.lastChild 功能：获取元素的最好一个子节点 childNodes 语法：父节点.childNodes 功能：获取元素的子节点列表 previousSibling 语法：兄弟节点.previousSibling 功能：获取已知节点的前一个节点 nextSibling 语法：兄弟节点.nextSibling 功能：获取已知节点的后一个节点 parentNodes 语法：子节点.parentNodes 功能：获取已知节点的父节点 二、节点操作1、创建节点 createElement 语法：document.createElement(元素标签) 功能：创建元素节点 createAttribute 语法：documen.createAttribute(元素属性) 功能：创建属性节点 createTextNode 语法：document.createTextNode(文本内容) 功能：创建文本节点 2、插入节点 appendChild 语法：appendChild(所添加的新节点) 功能：向节点的子节点列表的末尾添加新的子节点 insertBefore 语法：insertBefore(所要添加的新节点，已知子节点) 功能：在已知子节点钱插入一个新的子节点 3、替换节点 replaceChild 语法：replaceChild(要插入的新元素，将被替换的老元素) 功能：将某个子节点替换为另一个 4、复制节点 cloneNode 语法：需要被复制的节点.cloneNode(true/fasle) 功能：创建置顶节点的副本 参数 true：复制当前节点及其所有子节点 false：仅复制当前节点 5、删除节点 removeChild 语法：removeChild*(要删除的节点) 功能：删除指定的节点 三、属性操作1、获取属性 getAttribute 语法：元素节点.getAttribute(元素属性名) 功能：获取元素节点中指定属性的属性值 2、设置设置属性 setAttribute 语法：元素节点.setAttribute(属性名,属性值) 功能：创建或改变元素节点的属性 3、删除属性 removeAttribute 语法：元素节点.removeAttribute(属性名) 功能：删除元素中的指定属性 四、文本操作 insertData(offset,string) ：从offset指定的位置插入string appendata(sring) ：将string插入到文本节点的末尾处 deleteData(offset,count) ：从offset起删除count个字符 replaceData(off,count,string) ：从off将count个字符用string替代 splitData(offset)：从offset起将文本节点分成两个节点 substring(offset,count)：返回由offset起的count个节点]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-流程语句]]></title>
    <url>%2Fposts%2F121ee7e9.html</url>
    <content type="text"><![CDATA[一、循环语句1、while 语法 123while(条件表达式)&#123; 循环执行代码段&#125; 流程 判断条件表达式的值 当值为true时循环执行代码段 当值为false时退出循环体 热性 先检查条件，再执行循环 条件不满足则循环一次也不执行 时机 一个动作被重复执行到满足某个 条件时 2、do-while 语法 123do&#123; 循环执行的代码段&#125;while(条件表达式) 流程 先执行循环体内代码段再进行判断 如果表达式的值为true，则重复执行代码段 如果表达式的值为false，则退出循环体 特性 先执行循环体，再进行条件判断 循环体内代码至少执行一次 时机 希望一个动作至少被执行一次时 3、for 语法 123for(循环变量 = 初值;循环条件;递增/递减计数器)&#123; 循环代码段&#125; 流程 用循环变量初始值与循环条件相比较，确定返回值 如果返回值为true则执行循环体 执行完一次后进行递增/递减运算 将运算结果与循环条件相比较 如果返回值为true则继续执行循环体 如果返回值为false则退出循环体 时机 重复一个动作到一定次数时 4、for-in 语法 123for(声明变量 in 对象)&#123; 代码段&#125; 作用 枚举对象属性 注意事项 循环输出的属性顺序不可预知 对象的值不能是null或undefined 二、跳转语句1、return 终止函数体的运行，并返回一个值 2、break 终止整个循环，不再进行判断 3、continue 结束本次循环，接着去判断是否执行下次循环 三、选择语句1、if 语法 1234567if(条件表达式1)&#123; 代码段1&#125;else if(条件表达式2)&#123; 代码段2&#125;else&#123; 代码段3&#125; 流程 判断条件1，如果返回值为true则执行代码段1 如果条件1的返回值为false则跳过语句1并检测条件2 如果所有的表达式的值均为false则执行else后面的语句 特性 结构复杂，可嵌套 可测试多个条件表达式 表达式的值具有线性特征 表达式的值是动态的 适用于任意类型的数据 可处理复杂的逻辑关系 2、switch 语句 1234567891011switch(条件表达式)&#123; case 标签1: 代码段1; break; case 标签2: 代码段2; break; …… …… default: 代码段n;&#125; 流程 计算表达式的值，并与各标签相比较 若找到与之匹配的标签，则执行其后的代码段 若没有找到与之匹配的标签则执行default之后的代码段 格式 case标签为常量，可以是字符串或数字 每个标签均以冒号:结束 虽然break与default为可选性，但为了逻辑清晰最好不要省略 case标签的值必须和条件表达式在值完全匹配 特性 结构简洁，专为多重选择设计 仅可测试一条条件表达式 表达式的值具有离散性 表达式的值是固定的，不会动态变化的 仅能应用整数，枚举，字符串等类型数据 仅能处理多个枚举型逻辑关系 四、异常处理语句 throw 主动抛出异常 try 指明需要处理的代码段 catch 捕获异常 finally 后期处理]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-正则表达式]]></title>
    <url>%2Fposts%2F75cf4b3.html</url>
    <content type="text"><![CDATA[一、创建1、方式 字面量：var变量名 = / 表达式 / 模式修饰符 函数构造：var变量名 = ** **new RegExp(“表达式”,”模式修饰符”) 2、说明a、表达式 单个字符与数字 . : 匹配除换行符之外的任意字符 [a-z0-9] ：匹配方括号中的任意字符 [^a-z0-9] ：匹配不在方括号中的任意字符 \d：匹配数字 \D：匹配非数字 \w：匹配字母 \W：匹配非字母 空白字符 \0：匹配null字符 \b：匹配空格字符 \f：匹配换页符 \n：匹配换行符 \r：匹配回车符 \s：匹配空白字符、空格、制表符或换行符 \S：匹配非空白字符 \t：匹配制表符 定位符 ^：行首匹配 $：行尾匹配 \A：只匹配字符串的开始处 \b：匹配单词边界，词在[]内无效 \B：匹配非单词边界 \G：匹配当前搜索的开始位置 \Z：匹配字符串结束处或行尾 \z：只匹配字符串结束处 限定符 x?：匹配0个或1个x x*：匹配0个或任意多个x x+：匹配至少1个x x(m,n)：匹配最少m个，最多n个x 分组 (?:x)：匹配x但不记录匹配结果 x(?=y)：当x后接y时匹配x x(?!y)：当x后不是y时匹配x 引用 \1…\9：$1…$9，返回九个在模式匹配期间找到的、最近保存的部分 或模式 x|y|z：匹配x或z或y b、模式修饰符 g ：全局模式，应用于所有字符串 i ：区分大小写模式 m ：多行匹配模式 二、属性1、实例属性 global：检测是否设置g标记 ignoreCase：检测是否设置i标记 multiline：检测是否设置了m标记 lastIndex：开始检索下一个匹配项的字符位置，开始为0 source：返回正则表达式的字符串表示 2、构造函数属性 $_ input ：返回最近一次匹配的字符串 $&amp; lastMatch：返回最近一次的匹配项 $+ lastParen：返回最近一次匹配的捕获组 $` leftContext：返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符 $’ rightContext：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符 $* multiline：检测表达式是否采用多行模式匹配m 三、方法1、实例方法a、exec 功能：在字符串中执行匹配检索，返回结果数组 参数：要应用模式匹配的字符串 特性 使用全局标记g：持续查找所有匹配项并返回 不使用全局标记g：始终返回第一个匹配项信息 执行过程 检索字符串参数，获取正则表达式匹配文本 找到匹配文本则返回一个数组 第0个元素：与整个模式匹配的字符串 其他元素：与捕获组匹配的字符串 否则返回null 派生属性 index：匹配项在字符串中的位置 input：应用正则表达式的字符串 length：返回数组元素个数 b、test 功能：在字符串中测试模式匹配，返回true或false 2、字符串方法 match：找到一个或多个正则表达式的匹配 replace：替换与正则表达式匹配的子串 seach：检索与正则表达式相匹配的值 split：把字符串分割为字符串数组]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-字符串函数]]></title>
    <url>%2Fposts%2F2675d2d0.html</url>
    <content type="text"><![CDATA[一、查找方法1、字符方法a、charAt() 功能：返回字符串中第n个字符 参数：超出范围，返回空字符串 返回值：string中第n个字符的实际值 b、charCodeAt() 功能：返回字符串中第n个字符的代码 参数：超出范围，返回Nan 返回值： 内容：string中第n个字符的Unicode编码 范围：0~65535之间的16位整数 c、fromCharCode() 功能：根据字符编码创建字符串 参数：0个或多个整数，代码字符的Unicode编码 返回值：由指定编码字符组成的新字符串 特效：静态方法，实为构造函数String()的属性 d、关系charAt和charCodeAt共性 功能：根据下标查找指定字符 参数：n，要查询的字符下标；有效范围，0length1之间 charCodeAt与fromCharCode 互为反向操作 2、位置方法a、indexOf() 从前向后检索字符串，看其是否含有指定子串 b、lastIndexOf() 从后向前检索字符串，看其是否含有指定子串 c、共性 功能：根据字符串查找下标位置 参数： 必选：将要查询的字符串 可选：开始查找的位置下标 值为负数，视作 0 省略，从默认起始位开始查找 超出 0length1，返回 -1 返回值 找到：字串首次出现的下标 未找到：返回-1 3、匹配方法a、match() 功能：找到一个或多个正则表达式的匹配 参数 要进行模式匹配的正则表达式 非正则表达式，将其传递给RegExp()的构造函数，并转换为正则表达式对象 返回值：存放匹配结果的数组 有全局标记g：执行全局检索 找到：返回数组 内容：所有匹配的子串 缺陷 没有派生属性 不提供与子表达式匹配的文本信息 不声明每个匹配子串的位置 弥补：使用RegExp.exec()方法 没找到：返回null 无全局标记g：执行一次匹配 找到：返回数组 内容 第0个元素，匹配文本 其他元素，与正则表达式匹配的文本 属性 input，调用该方法的字符串对象 index，匹配为本的起始字符在字符串中的位置 lastIndex，匹配为本的末尾字符在字符串中的位置 未找到：返回null b、seach() 功能：检索字符串中与正则表达式匹配的子串 参数：与match()相同 返回值 找到：字符串中第一个与正则表达式相匹配的子串的起始位置 未找到：返回 -1 特性：忽略全局标记g与lastIndex()属性 c、replace() 功能：替换一个与正则表达式匹配的子串 参数 参数 1：需要进行替换正则表达式对象或字符串 参数 2：替换文本或替换函数 特性 如果参数1仅为字符串则只进行一次匹配替换，若替代所有子串则必选制定全局标记g 如果参数2仅为字符串则可使用特殊字符序列 $$ : $ $&amp; : 匹配整个模式的子字符串 $’ : 匹配的子字符串之前的子字符串 $` : 匹配的子字符串之后的子字符串 $n : 匹配第n个捕获组的子字符串，n=0~9 $nn: 匹配第nn个捕获组的子字符串，nn=01~99 d、split() 功能：根据指定分隔符将字符串分割成多个子串，并返回成数组 参数 必须：指定的分隔符 可选：指定数组的长度 二、操作方法1、拼接方法a、concat() 语法：string.cancat(varue,…) 功能：连接字符串 参数：要连接到string上的一个或多个值 返回值：把所有参数都连接到字符串string上得到的新字符串 特性：功能与‘’+‘’相同原始字符串的实际值并未被真正修改 2、截取方法a、 根据下标截取子串 *slice() *: 赋值参数，与字符长度相加 substring() **: 赋值参数，转换为0** 共性 ：参数2的子字符串最后一个字符后面的下标 b、根据长度截取子串 substr() 参数2 ：返回的字符个数 赋值参数 参数1：与字符串长度相加 参数2：转换为0 c、共性 功能：截取被操作字符串中的子串 参数1：指定子串的开始位置 省略参数2：以字符串长度为结束位置 3、空格处理 trim：清除前置及后缀空格 trimLeft：清除前置空格 trimRight：清除后缀空格 4、比较方法a、localeCompare() 功能：用本地特定顺序比较两个字符串 参数：与原字符串进行比较的字符串 返回值：说明比较结果的数字 负数：原字符串 &lt; 参数字符串 0 ： 原字符串 = 参数字符串 正数：原字符串 &gt; 参数字符串 三、编码方法1、字符串常规编码与解码 escape() unescape() 2、URI字符串编码与解码 encodeURI() decodeURI() 3、URI组件编码与解码 encodeURIComponent() decodeURIComponent() 四、转换方法1、大小写转换a、转为大写 toUpperCase() toLocaleUpperCase() ：本地 b、转为小写 toLowerCase() toLocaleLowerCase() ：本地 2、代码转换 用js动态格式化html，不具语义性，舍弃]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-变量]]></title>
    <url>%2Fposts%2Fb062d643.html</url>
    <content type="text"><![CDATA[一、命名1、方法a、匈牙利命名法（变量名=类型+对象描述） Int 整型 i float 浮点型 fi Bollean 布尔 b String 字符串 s Array 数组 a Obeject 对象 o Function 函数 fn Regular Expression 正则 re b、驼峰命名法 全部小写 单词与单词间用下划线分割 大小写混合 大驼峰：每个单词首字母大写 小驼峰：第一个单词首字母小写，其他首字母大写 2、规则 首字母：英文字母或者下划线 组成：英文字母，数字，下划线 禁忌：JavaScript关键词与保留字 二、声明1、显示声明 var变量名 2、陋习 没有类型 重复声明 隐式声明 不声明直接赋值 3、正解 先声明、后读写 先赋值、后运算 三、变量类型1、值类型 占用空间固定，保存在栈中 保存与复制的是值本身 使用typeof检测数据的类型 基本类型数据是值类型 2、引用类型 占用空间不固定，保存在堆中 保存与复制的是指向对象的一个指针 使用instanceof检测数据的类型 使用new()方法构造出的对象是引用型 四、作用域1、全局变量a、包含 在函数体外定义的变量 在函数体内定义的无var声明的变量 b、调用 任何位置 2、局部变量a、包含 在函数内部使用var声明的变量 函数的参数变量 b、调用 当前函数体部 3、优先级 局部变量高于同名全局变量 参数变量高于同名全局变量 局部变量高于同名参数变量 4、热性a、忽略块级作用域b、全局变量是全局对象的属性c、局部变量是调用对象的属性d、作用域链 内层函数可访问外层函数局部变量 外层函数不能访问内层函数局部变量 e、生命周期 全局变量：除非被显示删除，否则一直存在 局部变量：自声明起至函数运行完毕或被显示删除 回收机制 标记清除 引用计数]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList和LinkedList集合有什么区别？]]></title>
    <url>%2Fposts%2Fcd624839.html</url>
    <content type="text"><![CDATA[Arraylist底层是基于动态数组，根据下表随机访问数组元素的效率高，向数组尾部添加元素的效率高；但是，删除数组中的数据以及向数组中间添加数据效率低，因为需要移动数组。例如最坏的情况是删除第一个数组元素，则需要将第2至第n个数组元素各向前移动一位。 Linkedlist基于链表的动态数组，数据添加删除效率高，只需要改变指针指向即可，但是访问数据的平均效率低，需要对链表进行遍历。 总结：1、对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。2、各自效率问题： tips： ArrayList是线性表(数组) get()直接读取第几个下标，复杂度O(1) add(E)添加元素，直接在后面添加，复杂度O(1) add(inedx，E)添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O(n) remove()删除元素，后面的元素需要逐个移动，复杂度O(n) linkedlist是链表的操作 get()获取第几个元素，依次遍历，复杂度O(n) add(E)添加到末尾，复杂度O(1) add(index，E)添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(1) remove()删除元素，直接指针指向操作，复杂度O(1)]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件之间8种组件通信方式总结]]></title>
    <url>%2Fposts%2F40775045.html</url>
    <content type="text"><![CDATA[对于vue来说，组件之间的消息传递是非常重要的，下面是我对组件之间消息传递的各种方式的总结，总共有8种方式。 1 props和$emit 2 $attrs和$listeners 3 中央事件总线 4 provide和inject 5 v-model 6 $parent和$children 7 boradcast和dispatch 8 vuex处理组件之间的数据交互 1.props和$emit父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Vue.component(&apos;child&apos;,&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;/div&gt; `, props:[&apos;message&apos;],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit(&apos;getChildData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child :message=&quot;message&quot; v-on:getChildData=&quot;getChildData&quot;&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125;, methods:&#123; //执行子组件触发的事件 getChildData(val)&#123; console.log(val) &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 在上面的例子中，有父组件parent和子组件child。1).父组件传递了message数据给子组件，并且通过v-on绑定了一个getChildData事件来监听子组件的触发事件；2).子组件通过props得到相关的message数据,最后通过this.$emit触发了getChildData事件。 2.$attrs和$listeners第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Vue.component(&apos;C&apos;,&#123; template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt; &lt;/div&gt; `, methods:&#123; passCData(val)&#123; //触发父组件A中的事件 this.$emit(&apos;getCData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;B&apos;,&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt; &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt; &lt;/div&gt; `, props:[&apos;message&apos;],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit(&apos;getChildData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;A&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;B :messagec=&quot;messagec&quot; :message=&quot;message&quot; v-on:getCData=&quot;getCData&quot; v-on:getChildData=&quot;getChildData(message)&quot;&gt;&lt;/B&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos;, messagec:&apos;hello c&apos; //传递给c组件的数据 &#125; &#125;, methods:&#123; getChildData(val)&#123; console.log(&apos;这是来自B组件的数据&apos;) &#125;, //执行C子组件触发的事件 getCData(val)&#123; console.log(&quot;这是来自C组件的数据：&quot;+val) &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;A&gt;&lt;/A&gt; &lt;/div&gt; ` &#125;) 3.中央事件总线上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Vue.component(&apos;brother1&apos;,&#123; data()&#123; return &#123; mymessage:&apos;hello brother1&apos; &#125; &#125;, template:` &lt;div&gt; &lt;p&gt;this is brother1 compoent!&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;/div&gt; `, methods:&#123; passData(val)&#123; //触发全局事件globalEvent bus.$emit(&apos;globalEvent&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;brother2&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is brother2 compoent!&lt;/p&gt; &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, data()&#123; return &#123; mymessage:&apos;hello brother2&apos;, brothermessage:&apos;&apos; &#125; &#125;, mounted()&#123; //绑定全局事件globalEvent bus.$on(&apos;globalEvent&apos;,(val)=&gt;&#123; this.brothermessage=val; &#125;) &#125; &#125;) //中央事件总线 var bus=new Vue(); var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt; &lt;/div&gt; ` &#125;) 4.provide和inject父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。 123456789101112131415161718192021222324252627282930313233343536Vue.component(&apos;child&apos;,&#123; inject:[&apos;for&apos;],//得到父组件传递过来的数据 data()&#123; return &#123; mymessage:this.for &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;tet&quot; v-model=&quot;mymessage&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, provide:&#123; for:&apos;test&apos; &#125;, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 5.v-model父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component(&apos;child&apos;,&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$emit(&apos;input&apos;,this.mymessage);//通过如此调用可以改变父组件上v-model绑定的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @change=&quot;changeValue&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;child v-model=&quot;message&quot;&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 6.$parent和$children12345678910111213141516171819202122232425262728293031323334353637383940414243444546Vue.component(&apos;child&apos;,&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$parent.message = this.mymessage;//通过如此调用可以改变父组件的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @change=&quot;changeValue&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;button @click=&quot;changeChildValue&quot;&gt;test&lt;/button &gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, methods:&#123; changeChildValue()&#123; this.$children[0].mymessage = &apos;hello&apos;; &#125; &#125;, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 7.boradcast和dispatchvue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和on和emit的封装，但在一些基础组件中却很实用。 1234567891011121314151617181920212223242526272829303132function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; var name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat(params)); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;; 8.vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。 详情可参考：https://vuex.vuejs.org/zh-cn/]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（十）DOM0和DOM2级事件]]></title>
    <url>%2Fposts%2F64d673ce.html</url>
    <content type="text"><![CDATA[JS中的DOM0和DOM2事件JS中的事件基础及核心原理以及项目实战事件的定义 事件：元素天生具备的行为方式（和写不写JS代码没有关系）【onclick不是事件，click才是事件，浏览器会把一些常用事件挂载到元素对象的私有属性上，让我们可以实现DOM0事件绑定】，当我们去操作元素的时候会触发元素的很多事件事件绑定：给当前元素的某个事件绑定方法，目的是让当前元素某个事件被触发时，做出一些反应 事件绑定的两种方法 DOM0级事件绑定 curEle.onclick=function(){}; DOM2级事件绑定 标准浏览器：curEle.addEventListener(‘click’,function(){},false) IE6-8:curEle.attachEvent(‘onclick’,function(){}) DOM0事件常用事件汇总[PC端] 表单元素常用的事件 blur:失去焦点 focus:获取焦点 change:内容改变 select:被选中事件 键盘常用事件行为 keydown:键盘按下 keyup:键盘抬起 keypress:键盘按下（中文输入法不能触发，英文状态下可以触发，因为文本被输入到文本框中） 鼠标常用事件行为 click:点击（不是单击） dblclick:双击（300ms之内连续触发两次点击事件） mouseover:鼠标滑过 mouseout:鼠标滑出 mouseenter: 鼠标进入 mouseleave: 鼠标离开 mousedown:鼠标按下（左键） mouseup:鼠标左键抬起 mousewheel:鼠标滚轮滚动 其他常用事件行为 load:加载成功 error:加载失败 scroll: resize:大小改变事件:window.onresize:浏览器窗口改变大小触发该事件 [移动端 移动端键盘一般都是虚拟键盘，虽然存在keydown,keyup,但兼容不好，使用input事件代替移动端没有鼠标，所以鼠标类事件在移动端兼容性非常差，mouse类事件基本无法使用移动端大部分事件是靠手指完成的，所以它独有手指事件-单手指事件：touchstart touchmove touchend touchcancel-多手指事件：gesturestart gestuerchange gestuerend…..移动端还有很多事件是靠硬件完成的：手机传感器，陀螺仪，重力感应器等移动端兼容click事件，它把click当做单击使用（会有300MS的延迟事件） 事件对象 对以下事件绑定的严谨版描述：基于DOM0级事件的绑定方式，给box的click事件绑定了一个方法。当手动触发click事件时，会把绑定的方法执行box.onclick=function(e){arguments[0]===e;//=&gt;e就是事件对象e=e||window.event;(兼容版获取事件对象的写法)};当元素的某个事件行为被触发，不仅会把之前绑定的方法执行，还会给绑定的方法传递一个值（浏览器默认传递的），我们把传递的这个值称为事件对象：（标准浏览器） 这个值是个对象类型的值，里面存储了很多的属性和方法， 这些存储的值都是当前本次操作的基本信息，例如：鼠标位置，触发行为类型。。。。【只和本次操作有关,一个页面中只有一个事件对象】 IE6-8下关于事件对象的机制 方法被触发执行时，浏览器并没有把事件对象当做值传递给函数；(e是undefined) IE6-8下的事件对象需要我们通过window.event来获取 鼠标事件对象（mouseevent） clientX/clientY:当前鼠标触发点距离当前窗口左上角的X/Y坐标 pageX/pageY:当前鼠标触发点距离BODY左上角的X/Y坐标(IE6-8中没有这两个属性)兼容处理 123456789101112131415161718box.onckick=function(e)&#123; if(typeof e==='undefined')&#123; e=window.event; //-&gt;处理e //-&gt;pageX/pageY e.pageX=e.clientX+(document.documentElement.scrollLeft||document.body.scrollLeft); e.pageY=e.clientY+(document.documentElement.scrollTop||document.body.scrollTop); //-&gt;target e.target=e.srcElement; //-&gt;preventDafault e.preventDefault=function()&#123; e.returnValue=false; &#125;; //=&gt;stopPropagation e.stopPropagation=function()&#123; e.cancelBubble=true &#125; &#125; &#125;//该兼容比较完整，当处理一个简单兼容时可简单处理 type:当前触发事件的类型 target：事件源（当前鼠标操作的是那个元素）（IE6-8没有该属性，用srcElement这个属性代表事件源） preventDefault:作用：阻止事件的默认行为；（IE6-8没有该方法，使用 returnValue=false处理） stopPropagation:阻止事件的冒泡传播 [IE6-8不兼容，使用cancelBubble=true来处理] 键盘事件对象(keyboardEvent) code:当前按得键盘按键是哪一个 【IE6-8没有这个属性】key属性和code一样，储存形式不一样 keyCode：存储的是当前按键的码值（大部分按键都有自己的码值） which:和keyCode一样，也是当前按键的码值（which不兼容IE6-8） 这几个码值需要记住（删除：8 、 回车：13、 空格：32、 tab ：9、） 手指事件对象（TouchEvent）touches&amp;&amp;changedTouches&amp;&amp;targetTouches:存储的是当前屏幕上每一个手指操作的位置信息 touches：只有手指在屏幕上我们才能获取相关信息，手指离开后，这样touchend事件中我们就无法通过touches获取手指信息 changedTouches：手指在屏幕上时，和touches一样可以获得相关信息，手指离开后也可以记录手指离开屏幕一瞬间所在的位置信息（最常用的） 1234567891011121314touchesEvent type:'touchStart', target:事件源， touches: 0:&#123; clientX:xxx, clientY:xxx, pageX:xxx, pageY:xxx, ..... &#125; ... lentth：1 chan 详细处理 1234567891011121314151617181920212223242526272829303132333435363738let oBox = document.querySelector('#box');oBox.ontouchstart = function (e) &#123; let point = e.changedTouches[0]; //=&gt;记录当前手指的起始坐标位置(记录在当前元素的自定义属性上) this.strX = point.pageX; this.strY = point.pageY; this.isMove = false;&#125;;oBox.ontouchmove = function (e) &#123; let point = e.changedTouches[0]; //=&gt;一般我们手指操作，都会或多或少的发生一些偏移（习惯性偏移），此时不应该算作滑动，只有滑动的距离超出一定范围，我们按照滑动处理即可（一般都是把10px作为偏差值） let changeX = point.pageX - this.strX, changeY = point.pageY - this.strY; this.changeX = changeX; this.changeY = changeY; if (Math.abs(changeX) &gt; 10 || Math.abs(changeY) &gt; 10) &#123; this.isMove = true; &#125;&#125;;oBox.ontouchend = function (e) &#123; let point = e.changedTouches[0]; //=&gt;手指离开的时候：验证是否发生滑动 if (!this.isMove) &#123; //=&gt;点击操作 console.log('我是点击操作~~'); return; &#125; //=&gt;滑动操作 let dir = null; if (Math.abs(this.changeX) &gt; Math.abs(this.changeY)) &#123; //=&gt;左右滑动 dir = this.changeX &lt; 0 ? 'LEFT' : 'RIGHT'; &#125; else &#123; //=&gt;上下滑动 dir = this.changeY &lt; 0 ? 'UP' : 'DOWN'; &#125; console.log(`当前手指滑动的方向为：$&#123;dir&#125;`);&#125;; 手机移动端的点击、长按、滑动等都是基于内置的原生的touchstart/touchmove/touchend事件模拟出来的一些效果，没有现成的事件市场上有许多成熟的类库，我们直接使用即可1、fastclick.js:目的就是解决了移动端click事件300ms的延迟问题2、百度云touch手指事件库3、hammer.js4、zepto.js:提供移动端事件操作的板块，也是目前市场上使用率最高的 阻止事件的默认行为A标签的默认行为及阻止 1.超链接：点击A标签可以实现页面的跳转2、锚点定位：通过HASH值定位到当前页面的指定ID盒子位置- 首先URL地址栏末尾追加了一个HASH;- 如果地址栏包含hash值，浏览器在渲染页面后，会默认定位到hash值的位置 真实项目中我们想用A标签做一个普通按钮（优势：它的：hover样式是兼容所有浏览器的）此时，要把之前提到的两个默认行为阻止掉才可以 阻止A标签的默认行为 在HTML中阻止默认行为（常用） ; 在JS中阻止 单点击A标签时 首先会触发click事件 其次按照href中的地址页面进行跳转link.onclick=function(){ return false;}//阻止页面行为link.onclick=function(e){​ e=e||window.event;​ e.preventDefault?e.preventDefault():e.returnValue=false;​ } 事件的传播机制事件传播有三个阶段Event.prototype： 1234- 0 NONE:默认值，不代表任何意思- 1 `CAPTURING_PHASE 捕获阶段`- 2 ` AT_TARGET 目标阶段（当前事件源）`- 3 `BUBBLING _PHASE :冒泡阶段` 当前元素的某个事件行为被触发，它的所有的祖先元素（一直到document）的相关事件行为也会被触发执行（由里向外），我们把这种传播机制叫做冒泡传播 mouseover和mouseenter事件的区别mouseover：鼠标滑到元素上：存在事件的冒泡传播机制 mouseenter：鼠标进入元素里；浏览器阻止了它的冒泡传播机制； 不同点 区别 mouseover mouseenter 区别 1 存在冒泡传播机制 冒泡传播机制被浏览器阻止 区别 2 当鼠标从父元素进入到子元素时，首先会触发父元素的mouseout事件，再触发子元素的mouseover事件，由于冒泡传播机制，导致父元素的mouseover事件也被触发 当鼠标从父元素进入到子元素时,并不会触发父元素的mouseout事件，但是触发了子元素的mouseenter事件，由于浏览器阻止了它的冒泡传播，所以父元素的该事件不会被触发 事件委托（very important）原理：利用事件的冒泡传播机制完成（mouseenter不存在冒泡传播） 当一个容器内的很多元素都要为同一事件绑定方法，那么我们只需要给外层容器的该事件绑定方法，当里层元素的事件被出发时，会通过冒泡传播机制传到最外层容器那里，触发外层容器绑定的方法执行，在方法执行时，我们只需要根据判断事件源的不同而做不同的事情。（利用事件委托可提高50%左右的性能） 拖拽当中鼠标焦点丢失问题在拖拽登陆窗口的案例中（11.25） 当鼠标移动速度过快时，鼠标离开了h3，因为盒子跟不上奔跑的速度，所以导致以下几个问题 - 鼠标在h3之外飞，不会触发H3的mousemove，盒子就不动了； - 鼠标在h3之外抬起，也不会触发h3的mouseup，那么原有绑定的dragmove无法被移除，鼠标重新进入h3,此时不管鼠标是否按下，都会触发H3的dragmove； 原因：鼠标飞出h3,再怎么操作就和h3没有关系 解决方案： 1.把mouseup和mousemove事件绑定给document,原因：不管鼠标怎么飞，都飞不出document；（使用箭头函数）只要你鼠标还在文档中，那么mousemove和mouseup永远生效 2.setCapture（不兼容谷歌，支持Ie） DOM2事件绑定123456 //=&gt;标准浏览器 oBox.addEventLister('click',function(e)&#123; //this:obx &#125;,false) //false=&gt;让事件在冒泡传播时执行//true=&gt;让事件在捕获阶段执行（非常少见） 12345//=&gt;IE6-8浏览器 oBox.attachEvent('onclick',function(e)&#123; //e:事件对象，不同于DOM0级事件，浏览器会默认将事件对象传递进来，与window.event的值相同，因此对于：pageX/pageY/target...等依旧存在兼容； &#125;) //=&gt;绑定的方法都是在冒泡传播阶段执行 DOM1? 在DOM第一代升级迭代的时候，事件绑定依然沿用DOM0绑定的方式..so… DOM0于DOM2事件绑定的区别DOM0事件绑定的原理 给当前元素的某一私有属性（onXXX）赋值的过程；（之前属性默认值是null，如果我们赋值了一个函数，就相当于绑定了一个方法） 当我们赋值成功（赋值一个函数），此时浏览器会把DOM元素和赋值的的函数建立关联，以及建立DOM元素的行为监听，当某一行为被用户触发，浏览器会把赋值的函数执行； DOM0事件绑定的特点 只有DOM元素天生拥有这个私有属性（onxxx事件私有属性），我们赋值的方法才叫事件绑定，否则属于设置自定义属性 移除事件绑定的时候，我们只需要赋值为null； 在DOM0事件绑定中，只能给当前元素的某一个事件行为绑定一个方法，绑定多个方法，最后一次的绑定的会替换前面绑定的 DOM2事件绑定的原理 DOM2事件绑定使用的addEventListener/attachEvent方法都是在eventTarget这个内置类的原型上定义的，我们调用的时候，首先要通过原型链找到这个方法，然后执行完成事件绑定的效果 浏览器会给当前元素的某个事件行为开辟一个事件池（事件队列）【浏览器有一个统一的事件池，每个元素绑定的行为都放在这里，通过相关标志区分】，当我们通过 addEventListener/attachEvent进行事件绑定的时候，会把绑定的方法放在事件池中； 当元素的某一行为被触发，浏览器回到对应事件池中，把当前放在事件池的所有方法按序依次执行 特点 所有DOM0支持的行为，DOM2都可以用，DOM2还支持DOM0没有的事件行为（这样说比较笼统）（核心）【浏览器会把一些常用事件挂载到元素对象的私有属性上，让我们可以实现DOM0事件绑定，DOM2：凡是浏览器给元素天生设置的事件在DOM2中都可以使用】例如：onDOMContentLoaded（所有的DOM0和IE6-8的DOM2都不支持）​onDOMContentLoaded//当前浏览器中的DOM结构加载完成，就会触发这个事件 DOM2中可以给当前元素的某一事件行为绑定多个不同方法（因为绑定的所有方法都放在事件池中）； 事件的移除:事件类型、绑定的方法、传播阶段三个完全一致，才可以完成移除(因此在绑定方法时，尽量不要用匿名函数，否则不好移除) 12345678910111213141516171819//=&gt;ON:给当前元素的某个事件绑定某个方法 var on = function (curEle, type, fn) &#123; if (document.addEventListener) &#123; //=&gt;标准浏览器 curEle.addEventListener(type, fn, false); return; &#125; //=&gt;IE6~8 curEle.attachEvent('on' + type, fn);&#125;;//=&gt;OFF:移除当前元素某个事件绑定的某个方法13.var off = function (curEle, type, fn) &#123;14. if (document.removeEventListener) &#123;15. curEle.removeEventListener(type, fn, false);16. return;17. &#125;18. //=&gt;IE6~819. curEle.detachEvent('on' + type, fn);20.&#125;; xxx.removeEventLister(&#39;click&#39;,function(){},false) ==DOM0和DOM2绑定的方法是毫无联系的（因为是两套完全不同的机制），即使绑定的方法相同，也是执行两次，谁先绑定，就先执行谁== window.onload&amp;&amp;$(document).ready()的区别window.onload:当浏览器中的所有资源（DOM结构、文本内容、图片）都加载完成，触发load事件； 它是基于DOM0的事件绑定机制完成的，所以在同一页面中只能为他绑定一个方法，绑定多个，以最后一个为主； 如果想在一个页面中使用多次，应该是基于DOM2绑定的； 123456function fn1()&#123;&#125; function fn1()&#123;&#125;window.addEventListener('load',fn1,false);window.addEventListener('load',fn2,false); $(function(){})或者$(document).ready(function(){});当文档中的DOM结构加载完成，就会触发执行，在一个页面中可以使用多次 JQ中提供的方法，JQ是基于onDOMContentLoaded这个事件完成操作的 JQ中的事件绑定都是基于DOM2事件绑定的 onDOMContentLoaded在IE6-8下attachEvent也是不支持的，JQ在IE6-8下使用readystatechange来完成 DOM2事件的兼容处理 语法上的兼容标准： curEle.addEventListener（’type’,fn,false）;IE6-8: curEle.attachEvent（’on’+type,fn）; 顺序问题标准：按照绑定的顺序依次执行IE6-8:当事件行为被触发，IE6-8执行是乱序 重复问题标准：可以自动去重，已经存在的方法不允许再次添加IE6-8:在向事件池中增加方法时没有去重机制 this问题标准：当事件行为被触发，方法中的this指向当前元素本身IE6-8:当事件行为被触发，方法中的this指向window IE6-8事件池机制vs标准浏览器事件池机制（比较规范的回答） 1、向事件池中添加方法时，标准浏览器是使用addEventListener,IE6-8使用的是attachEvent；而且标准浏览器有自动去重的机制，已经添加的方法不允许再次添加。IE6-8没有去重机制；2、浏览器执行事件池中的方法时，不仅把方法执行，还把事件对象当作实参传递给给对应的方法，但是也是有区别的，IE6-8传递的事件对象的值和window.event是相同 的，因此存在兼容问题；3.当事件行为被触发，标准浏览器是依次执行，方法中的this指向当前元素；IE6-8下，是乱序执行，且方法中的this指向window； 不兼容的本质：IE6-8低版本浏览器对于他的内置事件池处理机制的不完善导致的。DOM2事件绑定兼容处理机制原理：自己创建一个类似于标准浏览器的自定义事件池（针对IE6-8） on :手动创建一个自定义事件池，把需要绑定的方法全部存在自定义事件池中 off: 把不需要绑定的方法从自定义事件池中移除 run：把run放在内置事件池中，当行为触发，需要浏览器把run执行，在run中把自定义事件池的方法执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//向事件池追加方法var on = function (curEle, type, fn) &#123; //标准浏览器无需处理 if (document.addEventListener) &#123; curEle.addEventListener(type, fn, false); return; &#125; //创建自定义事件池：创建到当前元素的自定义属性上，不受作用域限制，以后在其他方法中需要使用，可直接获取（不放在全局是防止全局污染） // 每一个事件都有一个独立的事件池 if (typeof curEle[type + 'pond'] === 'undefined') &#123; curEle[type + 'pond'] = []; //只要执行on,就说明当前方法已被绑定 //把run放到内置事件池中； // curEle.attachEvent('on'+type,run);//需要保证run中的 this是当前元素 curEle.attachEvent('on' + type, function () &#123; run.call(curEle, e);//将run放在一个匿名函数中，强制改变this &#125;); &#125; var aryPond = curEle[type + 'pond']; // 去重操作，当前事件池中是否有当前事件 for (var i = 0; i &lt; ary.length; i++) &#123; if (aryPond[i] === fn) &#123; return; &#125; &#125; aryPond.push(fn);&#125;;//移除事件池的某个方法var off = function (curEle, type, fn) &#123; if (document.removeEventListener) &#123; curEle.removeEventListener(type, fn, false); return; &#125; var aryPond = curEle[type + 'pond']; if (!aryPond) return; for (var i = 0; i &lt; ary.length; i++) &#123; if (aryPond[i] === fn) &#123; // aryPond.splice(i,1);此方法会导致原始数组索引改变，此时正在执行的run循环，索引和想要的索引不一致，数组塌陷 //我们不能让当前数组的索引改变； aryPond[i] = null;//置空，索引没变 &#125; &#125;&#125;;//把自定义事件池中的方法依次执行var run = function (e) &#123; // this=&gt;curEle //e:window.event，不兼容，需要处理 if (typeof e.target === 'undefined') &#123; e.target = e.srcElement; e.which = e.keyCode; e.pageX = e.clientX + document.documentElement.scrollLeft || document.body.scrollLeft; e.stopPropagation = e.cancelBubble = true; e.preventDefault = e.returnValue = false; &#125; var aryPond = curEle[type + 'pond']; if (!aryPond) return; for (var i = 0; i &lt; aryPond.length; i++) &#123; var itemFn = aryPond[i]; // itemFn();=&gt;这样执行itemFn里的this时window，须将他替换成函数里的this if (itemFn === null) &#123; //当前这一项在执行的时候，可以将off中置空的那一项删除 aryPond.slice(i, 1); i--; continue; &#125; itemFn.call(this, e); &#125;&#125;; Bind方法的封装123456789101112131415161718//ES5封装 BIND Function.prototype.myBind = function myBind(context) &#123; //this=&gt;当前需要处理的函数 //context=&gt;我们需要预先改变的this值（如果不传，默认window）； //arguments=&gt;存储包含context在内的所有实参； context = context || window; var outerArg = Array.prototype.slice.call(arguments, 1); var _this = this; if('bind' in this)&#123;//如果不是IE6-8，直接返回 return _this.bind.apply(_this,arguments) ; &#125; return function () &#123; var innerArg = Array.prototype.slice.call(arguments); outerArg = outerArg.contact(innerArg); _this.apply(context, outerArg); &#125; &#125; 123456789//ES6方法 Function.prototype.myBind = function myBind(context = window, ...outer) &#123; //使用ES6中的剩余运算符 if ('bind' in this) &#123; return this.bind(arguments); &#125; return function (...inner) &#123; this.apply(context, outer.concat(inner)); &#125; &#125;;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（九）定时器]]></title>
    <url>%2Fposts%2Fdb9fe196.html</url>
    <content type="text"><![CDATA[JS中的定时器&amp;&amp;动画&amp;&amp;同步异步编程定时器设置一个定时器并设定一个等待时间，当到达时间，执行指定要完成的事情；JS中的定时器一共有两种： window.setTimeout（执行一次） window.setTimeout(function,[interval]):设置了一个定时器，当到达指定时间后执行对应的方法（执行一次定时器就结束了）；（第一个参数是函数，第二个参数是时间，a单位都是毫秒，自己不需要加单位，17是个比较理想的时间） 123window.setTimeout(function()&#123;console.log('ok');//100ms后输出一次 ‘ok'，此时定时器结束，但是定时器并没有被清除；&#125;,100);//定时器等待时间设置为0也不是立马执行，浏览器也有一个最小反应时间（13MS-14ms）， [interval]：时间因子，需要等待的时间 window.setInterval（执行多次） window.setInterval(function,[interval])：设置一个定时器，当达到指定时间后执行对应的方法（以后每隔这么长时间就重新执行这个方法，直到定时器清除为止，执行很多次） 1234var n=0；window.setInterval(function()&#123;console.log(n++);//每隔100ms输出一次 ，1，2，3，4。。。。&#125;,100);//定时器等待时间设置为0也不是立马执行，浏览器也有一个最小反应时间（13MS-14ms）， 定时器的返回值定时器的返回值，不管是setTimeout还是setInterval都会有一个数字类型的返回值，代表当前是在浏览器中设置的第几个定时器（返回的是定时器的序号） setTimeout和setInterval虽然是处理不同需求的定时器，但是都是浏览器的定时器，所以设置的时候，返回的序号是依次排序setInterval：设置完成时定时器会有一个返回值，不管执行多少次，这个代表序号的的返回值不变（设置定时器就会有返回值，执行多少次是定时器的处理 定时器的清除定时器都需要手动清除，下面两个清除的方法没有区别 clearTimeout([定时器排队的序号])clearIterval（[定时器的排队序号]） 当方法执行完成后，我们清除定时器即可 eg: clearTimeout(1) ，这相当于在浏览器中将第一个定时器清除了。同时我们还需要将之前存储序号的变量赋值为null，例如t1=null，优化JS的内存空间 1234567891011var timer1=setInterval(function()&#123; &#125;,192);//timer1=1，是该定时器的返回值（即该定时器序号）var n=0；var timer2=setTimeout(function()&#123; n++;console.log(n); if(n&gt;=10)&#123; clearSetInterval(timer2);//手动清除 &#125;&#125;,192);//timer2=2，是该定时器的返回值 定时器的原理 当我们在JS中创建一个定时器后，浏览器会把计时执行方法的这个任务放在浏览器的等待任务队列（等待任务池）中，并且安排一个监控者（属于浏览器开辟的新线程），也就是记录当前已经走的时间，到达时间后，监控者会通知浏览器时间到了，浏览器（在把主任务队列的内容执行完后）会把之前放在等待任务队列中的方法拿出来执行； JS中动画实现的原理 浏览器实现动画有三种常用发方法CSS动画在CSS3中提供了transtation动画和animation动画两种动画，优势在于性能好，实现简单，（一般能用css写的绝不用其他方式），弊端在于不兼容IE或其他低版本浏览器（移动端的动画一般都是基于css来完成的）JS中的动画在JS中实现动画常用的有：=&gt;使用定时器驱动的动画=&gt;使用requestAnimationFrame来完成动画而所谓的CANVAS动画基本上也是基于站两种方式完成的（CANVAS本身是绘图）FLASH动画早期实现动画的方法，现在一些简单的DOM动画都告别了FLASH时代 基于定时器的动画 基于定时器实现的动画的两种解决方案- 固定步长的动画- 固定时间的动画（比较常用）我们最好封装一个方法，支持固定时间的多方向的匀速或飞匀速运动 如何实现多方向匀速 回调函数(callBack) 把一个函数当做实参传递给另一个函数，在另外一个函数中执行这个函数，这种处理机制叫做回调函数 1234567function fn(callBack) &#123; //=&gt;callBack:传递进来的匿名函数 callBack();&#125;fn(function () &#123; console.log('ok');&#125;); 凡是在当前方法执行的某个阶段，执行一个不确定的事情，我们可以将这件事情当做参数 JS中的同步编程和异步编程 JS是单线程的（一次只能执行一个任务，当前任务没有完成，下面的任务是不进行处理的）同步编程（sync）：当前任务是按照顺序一件件完成的，当前任务没有完成，下面的任务不进行处理异步编程（async）：当前任务在等待执行的时候，我们不去执行，继续完成下面的任务，当下面的任务完成后，也到达的等待的时间了，才去完成当前的任务 定时器都是异步编程的 所有的事件绑定也是异步的 AJAX中有异步编程 有些人把回调函数当做异步编程其余都是同步编程 1234567var startTime=new Date();//获取开始的时间 for (var i = 0; i &lt; 1000; i++) &#123;if(1===99)&#123; console.log(i);&#125;&#125;console.log(new date -startTime);//计算完成循环的时间 在项目中，要避免出现死循环，因为循环时同步编程，当前循环无法结束证明任务没有完成，后续任务无法进行 12345678var n = 0;//第一件任务：创建一个变量 // 第二件任务：创建一个定时器（等待任务，1000MS执行方法是一个等待执行的任务） setTimeout(function () &#123; n++； console.log(n);//再输出n=1 &#125;, 1000);//第三件任务：输出0console.log(n); //首先输出n=0; 同步异步编程的核心原理 JS中有两个任务队列（存放任务列表的空间） 1、主任务队列：同步执行任务（从上到下依次执行）2、等待任务队列：异步执行任务]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（八）盒子模型]]></title>
    <url>%2Fposts%2Fba5b0d45.html</url>
    <content type="text"><![CDATA[JS中DOM盒子模型深入分析CSS盒子模型传统盒子模型width height:不是盒子的宽高，而是盒子中的内容 盒子的宽度=width+border2+padding2//在一个对称的模型中 CSS3新增加的盒子模型增加该属性，width和height的数值就是盒子的宽高； 1box-sizing:border-box; JS盒子模型 提供一些属性和方法用来描述盒子的样式的 clientclientWidth / clientHeight 当前盒子可视区域的宽度和高度可视区域：内容的宽高+padding*2clientHeight=height+padding(top&amp;&amp;bottom)clientWidth=height+padding(left&amp;&amp;right)和内容是否溢出和我们是否设置了overflow:hidden没有关系 1document.documentElement.clientWidth||document.body.clientHight //获取当前页面一屏幕的宽度 在不知盒子宽高的情况下，让盒子居中 123456var winH=document.documentElement.clientHeight||document.body.clientHeight;var winW=document.documentElement.clientWigth||document.body.clientWigth;var boxW=box.clientWidth;var boxH=box.clientHeight;box.style.left=(winW-boxW)/2+'px';box.style.top=(winH-boxH)/2+'px'; clientTop 和 clientLeft 只有top和left，没有其他的clientTop：盒子上边框的高度clientLeft：盒子左边框的宽度通过JS盒子模型获取的结果是不带单位的，而且只能是整数，（他会自动四舍五入） offsetoffsetWidth 和 offsetHeight 在clientHeight和clientWidth的基础上加上了边框的长度；offsetWidth=clientWidth+左右边框(border)offsetHight=clienthight+上下边框真实项目中，如果想要得到盒子的宽度和高度一般都用offsetWidth和offsetHeight，这样就包含了盒子的边框 123456var winH=document.documentElement.offsetHeight||document.bodyElement.offsetHeight;var winW=document.documentElement.offsetWigth||document.bodyElement.offsetclientWigth;var boxW=box.offsetWidth;var boxH=box.offsetHeight;box.style.left=(winW-boxW)/2+'px';box.style.top=(winH-boxH)/2+'px'; offssetParent 当前和盒子的父级参照物（得到父级参照物元素） 父级参照物不等价于父级元素，与父级元素没有直接关系父级参照物：同一平面中最外层容器是所有里层盒子的父级参照物一般情况下，一个页面所有元素的父级参照物都是body，body没有父级参照物； 当我们给元素设置定位（会让元素脱离文档流）的时候，会改变父级参照物（不在一个平面上） offsetTop&amp;offsetLeft:当前元素外边框距离父级参照物的内边框的偏移量（标准IE8浏览器特殊性： 当前元素最外边框距离父级参照物的外边框的偏移里量 ）window.navigator.userAgent 获取浏览器的版本号 获取页面中任何一个元素距离body的左偏移和上偏移，不知道该元素的具体位置。思路： 首先获取自己的偏移量及父级参照物如果父级参照物不是body，我们加上父级参照物的边框和偏移量。。。一直加到父级参照物为body的元素为止 scrollscrollHeight &amp;&amp; scrollWidth 没有内容溢出：获取的结果和clientWidth、clientHeight的结果相同；有内容溢出：真实内容的宽度或高度，包含溢出内容的值，再加上padding或左padding的值scrollWidth&amp;&amp;scrollHeight获取的是约等于的值由于内容溢出，每个浏览器对于行高或文字的渲染不一样，回去的结果也不一样是否设置overflow：hidden对最后的结果也有影响 获取当前页面的真实高度（包含溢出） 1document.documentElement.scrollWidth||document.body.scrollHight scrollLeft &amp;&amp; scrollTop 横向或竖向滚动条卷去的宽度或高度(在拉动滚动条时，上面的内容会被卷去，就是scrollTop) 最小值：0 最大值：scrollHight-clientHight:真实页面高度-一屏幕的高度 前面的JS盒子模型的属性都是只读属性，只能获取，不能修改；而scrollTop&amp;&amp;scrollLeft是可读写属性，既可以获取，也可以修改； window.onscrollwindow.onscroll:浏览器滚动条滚动事件（只要滚动就会触发该事件） * 1、鼠标滚轮控制 或者 手动拖动滚动条 * 2、键盘按键控制 * 3、使用JS代码控制 * … * 不管什么方式,只要滚动条动了就会触发这个事件 在JS中获取元素的具体的样式值 通过JS盒子模型12个属性（不包含offsetParent）获取的结果都是整数，没有单位，如果有小数，浏览器会自动四舍五入通过JS盒子模型 属性获得的值都是组合值，不能单独获取某一个具体样式值 curEle.style.xxx; 获取当前元素所有写在行内样式上的样式值(如果样式没有设置在行内元素上 得到空字符串)特殊：只有把样式写在行内样式上，才可以通过这种方法获取到=》这种方法在真实项目中比较少见，因为我们很少在行内样式上写样式 window.getComputedStyle &amp;&amp; curEle.currentStyle 只要当前元素在页面中显示出来，我们就可以获得其样式值（不管是行内还是样式表），也就是获取所有经过浏览器计算过的值，包括你没有写浏览器默认设置的值。window.getComputedStyle:适用于标准浏览器，IE6-8不兼容，在IE6-8的Window全局对象中，没有提供getComputedStyle这个属性和方法，我们使用curEle.currentStyle来获取需要的样式值 //通过getComputedStyle获得的结果是一个对象,包含当前元素所有的样式属性和属性值 语法：window.getComputedStyle([当前需要操作的元素],[当前元素的伪类，一般写null])window.getComputedStyle(box,null).paddingleft; //通过 curEle.currentStyle来获取样式box.currentStyle.paddingleft; 封装一个公共的方法：getCss 1234567891011121314151617//getCSS：获取当前元素某一个样式的属性值//@parameter curEle:当前需要操作的元素//attr:要获取样式的属性名function getCss(curEle,attr)&#123;var value=null;var reg=null;try&#123;value=window.getComputedStyle(cueEle,null)[attr];&#125;catch(e)&#123;value=curEle.currentStyle&#125;reg=/^-?\d+(\.\d+)?(px|pt|em|rem)?$/i;//去除单位reg.test(value)?value=parseFloat(value):null;return value;&#125;console.log(getCss(box,'display')); 方法二： 1234567891011121314function getCss(curEle, attr) &#123;var value = null,reg = null;if ('getComputedStyle' in window) &#123;value = window.getComputedStyle(curEle, null)[attr];&#125; else &#123;value = curEle.currentStyle[attr];&#125;//=&gt;去除单位reg = /^-?\d+(\.\d+)?(px|pt|rem|em)?$/i;reg.test(value) ? value = parseFloat(value) : null;return value;&#125;console.log(getCss(box, 'display')); 设置元素的样式 curEle.style.xx=xxx;设置当前元素的行内样式；（JS设置样式一般都设置在行内样式上，因为行内样式优先级最大）（JS操作属性不支持-，所有-改成下一个单词大写）curEle.className=xxx;设置元素的样式类名； 1234567891011121314151617181920curEle['style'][attr]=value;//传递value值，如果没有单位，需要补单位//并不是所有的值都需要补单位，//传递的值带单位，不需要不单位 if(attr==='opacity')&#123;curEle.style.opacity=value;curEle.style.filter='alpha(opacity='+value*100%');&#125; !isNaN(value)&amp;&amp;!/^(zoom|lineHeight|zIndex|fontWeight)$/i.test(value)?value+='px':null;curEle['style'][attr]=value;&#125;setCss(box,'padding','20px');将3个方法封装在一个里面var css = function () &#123;var len = arguments.length,type = Object.prototype.toString.call(arguments[1]),fn = getCss;len &gt;= 3 ? fn = setCss : (len === 2 &amp;&amp; type === '[object Object]' ? fn = setGroupCss : null);return fn.apply(this, arguments);&#125;; children 不管在什么浏览器中，都可以获得当前元素的子节点,（元素节点）但在IE6-8下，也会将注释节点获取到，因此有所差别 123function children(curEle)&#123;&#125; 编程常用方法：假设法 排除法 JS中的动画 1、步长偿固定，完成时间不固定2、固定时间动画 12345678910111213141516171819function linear(t, b, c, d) &#123;return t / d * c + b;&#125;var oBox = document.getElementById('box');var time = 0,//已经运动的时间duration = 1000,//总时间begin = utils.css(oBox, 'left'),//左边距target = utils.winBox('clientWidth') - oBox.offsetWidth,//目的地change = target - begin;//总共需要走的距离var timer = setInterval(function () &#123;time += 17;if (time &gt;= duration) &#123;utils.css(oBox, 'left', target);clearInterval(timer);return;&#125;var curL = linear(time, begin, change, duration);utils.css(oBox, 'left', curL);&#125;, 17); 图片懒加载原理：1、IMG标签的SRC不存放图片的地址(如果存放真实的地址,页面一加载图片肯定就加载出来了),我们把真实图片的地址存储在当前IMG标签的自定义属性上(DATA-IMG)2、为了保证当前图片没有真实地址的时候,浏览器中不会出现叉叉或者出现ALT中的内容,我们一般都会把图片先隐藏(display:none opacity:0…)，等到后期把真实图片加载出来，在让当前图片展示3、看不到真实图片了，我们最好给一个占位图片（占位图：要求一定要很小,最好是1KB）：我们在IMG外面包一层DIV盒子,把占位图赋值给当前盒子的背景图片来处理 =&gt;开始IMG不显示,展示的是默认的背景图,当IMG真实地址加载完成后,我们让IMG显示,此时真实图片会覆盖住背景图]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础知识（七）正则]]></title>
    <url>%2Fposts%2Feda90d92.html</url>
    <content type="text"><![CDATA[正则正则的基础知识什么是正则？ 正则就是一个规则，用来处理字符串的规则1、正则匹配 编写一个规则，验证某个字符串是否匹配这个规则，用test方法 2、正则捕获 编写一个规则，在一个字符串中，把符合规则的内容都获取到，使用方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则 var reg=/^$/;//两个斜杠之间包含的内容就是正则，两个斜杠之间的全部内容都是元字符 正则的元字符和修饰符 任何一个正则都是由元字符和修饰符组成的 修饰符 g(global):全局匹配 i(ignore):忽略大小写匹配 m(mutiline)：多行匹配 元字符[量词元字符] +：让前面的元字符出现1到多次 ？：出现0到1次 *：出现0到多次 {n}:出现n次 {n,}:出现n到多次 {n,m}:出现n到m次 [特殊意义的元字符]-\ ：转义字符-.：除了\n（换行符）以外的任意字符-\d：匹配一个0-9的任意字符 \D ：匹配一个非0-9的任意字符 \w ：匹配一个[0-9a-zA-Z_]之间的任意字符 \s ：匹配一个任意空白符 \b ：匹配一个边界符(单词的左右，-的左右两边) x|y：匹配两者中的其中一个 [a-z] ：匹配a-z中的任意一个字符 [^a-z] ：匹配非a-z中的任意一个字符 [xyz] ：匹配xyz中的其中一个 [^xyz]：匹配除了xyz以外的任意字符 ()：正则小分组 ^：以某一个元字符开始 $ ：以某一个元字符结束 ？： 只匹配不捕获 ？=：正向预查 ？！ ：负向预查 1234var reg=/^\d$/; //说明以数字开头，以数字结尾 ，且只包含一个数字 var reg=/^2.3$/;//.代表除了\n以外的任意字符 reg.test(2.3); true 12345678var reg=/^18|19$/;// x|y的情况// 18或19// 以1开头以9结尾，中间是8或1// 以18开头或以19结尾//var reg=/^（18|19）$/;//18或19 //（）正则里的分组，大正则里的小分组，我们可以使用它改变默认的优先级//此时只有18或者19符合规则 （） （）正则里的分组，大正则里的小分组，我们可以使用它变默认的优先级 小分组还有第二个作用：分组引用 小分组第三个作用： 分组捕获 分组引用：\1 表示出现和第1个分组一模一样的字符 1var reg=/^([a-z])([a-z])\2(a-z)$/;// 类似于food week feel oppo等都符合该正则 [ ] [xyz] [^xyz] [^a-z]var reg=/^[a-zA-Z0-9_]$/;//等同于\w[ ]中出现的元字符，一般都代表本身的含义var reg=/^[.?+]$/里面的.代表.本身//需求类的命名规则：数字字母下划线 _，（-不能作为开头）var reg=/^\w[\w-]*$///不要让-出现在中间就可代表其本身的含义，出现在中间表示范围链接符 var reg=/^[18-65]$/代表的意思：1或86或5中的任意一个字符 ，中括号出现的18不代表数字18而是1或者8，当前正则非法18-65岁份三阶段1819 (18|19)2059([2-5]\d)6065(6[0-5]) 验证是否为有效数字 可能正数，可能是负数整数或小数只要出现小数点，后面至少出现一位小数点前必须有数字var reg=/^-?(\d|([1-9]\d+)(\.\d+)?$/ 电话号码 1var reg=/^1\d&#123;10&#125;$/ 中文姓名 123 /^[\u4E00-\u9FA5]$/ :中文汉字的正则var reg = /^[\u4E00-\u9FA5]&#123;2,10&#125;(·[\u4E00-\u9FA5]&#123;2,10&#125;)?$/;尼古拉斯·王武 邮箱 1234567891011reg=/^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/分析需求： * 以数字字母下划线开头 * @前面可以是 数字、字母、下划线、-、. 这些符号 * 不能把 -和. 连续出现，出现一次后面必须跟数字字母下划线 * * @后面的部分支持 * 企业邮箱* .com.cn 多域名情况 *///这样写不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面的每一个小分组也可以分别捕获到"分组捕获" 身份证号 1var reg=/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(X|\d)$/ 正则捕获 把当前字符串中的符合规则的字符捕获到RegExp.prototype.exec实现正则捕获的方法当我们执行reg.exec(str)的时候， 1、先去验证当前字符串和正则是否匹配，如果不匹配则返回结果null； 2、如果匹配，从字符串最左边开始，向右查找匹配内容，并把匹配内容返回 exec捕获到的结果的格式：获取的是一个数组数组中的第一项是当前本次大正则匹配的结果index:记录了本次捕获到结果的起始的索引input：当前正则操作的原始字符串如果当前正则当中有分组，获取的数组中，从第二项开始，都是每个小分组执行一次exec只能把符合正则规则的一个内容捕捉到，若果还有其他符合规则的， 需要再次执行exec才有可能捕获到； 正则捕获的懒惰性正则为什么会存在懒惰性 正则本身有一个属性：lastIndex（下一次正则在字符串匹配查找时的开始索引）默认值：0，从字符串的第一个字符开始查找匹配的内容默认不管执行多少次exec，正则的lastIndex值都不会变，也就是还是从第一个字符开始查找并且当我们手动改变last Index的值时，不会起任何作用由此导致：执行一次exec捕获到第一个符合规定的内容，第二次执行exec，捕获到的依然是第一个匹配内容，后面的无论执行多少次都捕获不到 解决正则的懒惰性 在正则的末尾加修饰符g(全局匹配)加了修饰符g，每次exec结束后，浏览器会默认把lastIndex的值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容了 1var reg=/\d+/g;//开启全局匹配 exec有自己的局限性，执行一次exec只能捕获到一个结果，如果想要全部捕获到，就要执行多次，下面封装的myExecAll方法，可以将正则匹配的全部内容捕获到 12345678910111213141516RegExp.prototype.myExecAll=function()&#123;//this 是当前需要处理的正则//str是当前需要处理的字符串var str=agruments[0]||'';var result=[];//首先判断是否加了全局修饰符G，如果没有加，我们直接将第一次的结果返回即可if(!this.global)&#123; return this.exec(str);&#125;var ary=this.exec(str);while (ary)&#123;//(等同于ary!==null:可以捕获到内容，我们继续下一次捕获 result.push(ary[0]);//第一项为匹配到的结果 ary=this.exec(str);//继续执行下一次捕获&#125;return result;&#125;； 使用字符串中的match实现捕获 使用字符串match捕获， 如果正则加了g,会捕获到所有匹配结果 如果不加g,则只会捕获到第一个匹配结果 match的局限性 在加了修饰符g的情况下，·执行match只会把大正则匹配的结果捕获到，对于小分组里的匹配结果会自动忽略· 使用test实现捕获不管是正则的匹配还是捕获，在处理的时候是没有区别的，从字符串里的第一个字符开始查找符合规则的字符，如果可以找到，则返回true，exec捕获返回捕获的内容，如果没有找到，test返回false，exec捕获返回null 如果正则设置了修饰符g，不管是使用test还是exec的任何方法，都会改变lastIndex值，（下一次查找是基于上一次匹配结果向后查找的） 12345var str='my name is &#123;0&#125;~~';svar reg=/\&#123;(\d+)\&#125;/g;if(reg.test(str))&#123;//-&gt;lastIndex=0console.log(reg.exec(str));//-&gt;null lastIndex值被修改，向后查找，无匹配&#125; test不仅可以找到匹配的内容，也肯能将匹配的内容获取 1console.log(RegExp.$1);//获取当前匹配内容的第1个小分组; 所有支持正则的方法，都可以实现字符串的捕获（一般都是字符串方法） 字符串中常见的支持正则的方法 match ***split *var str=’name=”珠峰”&amp;age=8’;str.split(/(&amp;|=)/); //使用split进行字符串进行拆分的时候，如果正则包含小分组，会把小分组的内容捕获到，放在最后的数组中//本案例()只是为了改变优先级，但我们只想匹配不想捕获分组里的内容，?:可以解决str.split(/?:(&amp;|=)/);// 这样浏览器就不会把小分组的内容捕获到；要计算是第几个分组，从左到右数( =&gt;半括号即可**replace 字符串中原有字符的替换str.replace(old,new) 123var str='珠峰2011珠峰1021';str=str.replace('珠峰','珠峰培训');str.replace(/珠峰/g,'珠峰培训'); 在不使用正则的情况下，执行一次replace只能替换一个原有字符，第二次执行replace，依旧是从第一个字符开始查找，类似于正则的懒惰性 工作中，replace都是和正则一起搭配使用replace原理： 当replace方法执行，第一项传递一个正则 正则不加g,把当前第一个字符串中和正则匹配的内容捕获到，替换成新字符 正则加g,把当前所有和正则匹配的内容都捕获到，并替换成新字符 当replace执行，第二次参数传递的是一个函数（回调函数） 首先用正则在字符串中进行匹配，匹配到一个符合规则的，就把传递的函数执行一次 不仅执行这个函数，还把正则本次捕获的结果（同执行exec捕获的结果,包含小分组）当做实参传递给这个函数（这样就可以在函数中获得这些值，这些值就是正则每一次捕获的结果） 正则捕获方法统计 方法名 不加g 加g exec 懒惰性，只能到捕获第一个匹配值包括小分组 多次捕获可得所有匹配字符，包括小分组 match 懒惰性 同上 一次捕获到所有匹配字符，但不能匹配到小分组 test 懒惰性同上 多次捕获可得全部内容，每执行一次test，就console.log(RegExp.$1)，可得当前匹配字符 replace 懒惰性，只替换一个 全部替换 正则案例=&gt;单词首字母大写 12345678910var str='my name is zhu-feng-pei-xun,i am 8 years old,i am qian duan pei xun no1!';//先把混淆边界符的-替换为下划线 str=str.replace(/-/g,_);//通过边界符匹配到每个单词str=str.replace(/\b(\w)(\w*)\b/g,function()&#123; console.log(agruments); return agruments[1].toUpperCase()+agruments[2];&#125;)str=str.replace(/_/g,-); 12var str='2017-11-07 16:30';//改写成2017年11月07日16时30分//replace 模板匹配（） 1234567891011var template='&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒';var reg=/\d+/g;var ary=str.match(reg)var str='2017-11-07 16:30';//先将str的有效数字匹配出来，得到一个数组（match）//其次 将template中的&#123;0&#125;与之数组对应索引替换（/\&#123;(\d)\&#125;）;var template=template.replace(（/\&#123;(\d)\&#125;）,function()&#123; var index=arguments[1];//有多少个匹配的字符串，函数就会被执行多少次，这是每次匹配的小分组，即0/1/2... var value=ary[index];//将数组中对应索引的值拿出来 return value;&#125;) 正则创建方式字面量方式 1var reg=/\d+/img; 构造函数创建 123new RegExp('元字符'，'修饰符') var reg= new RegExp('\\d+'，'g');//将一个\换成\\才是转义字符的意思，''里面放的都是字符串 构造函数可以动态加入一个变量的值 问号传参（面试题）1234567891011121314let url = 'http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e';//实现方法String.prototype.myQueryURLParameter = function myQueryURLParameter() &#123; let reg = /[?&amp;]([^?&amp;=]+)(?:=([^?&amp;=]*))?/g, obj = &#123;&#125;; this.replace(reg, (...arg) =&gt; &#123; let [, key, value] = arg; obj[key] = value; &#125;) return obj;&#125;;//方法调用let result = url.myQueryURLParameter();=》&#123; a: '1', b: '2', c: '', d: 'xxx', e: undefined &#125;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（六）关于面向对象的理解]]></title>
    <url>%2Fposts%2F2801c46e.html</url>
    <content type="text"><![CDATA[关于面向对象的理解(构造函数、原型链)OOP(面向对象编程思想) 它是一种编程思想，让我们基于类和实例的概念来编程开发和学习。 单例模式单例设计模式是一种把对象数据类型实现把描述同一件事物的属性或者特征归纳汇总在一起，以此避免全局变量冲突问题的方式和思想。把描述同一件事务的属性或者方法存放在某一个命名空间下，多个命名空间中的属性和方法是互不干扰的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//=&gt;单例模式//1、singleton不仅仅是对象名了，在单例模式中，singleton称之为 “命名空间(nameSpace)”var singleton=&#123; xxx:xxx, ...&#125;; var singleton=&#123; nameSpace1:&#123; xxx:xxx, ... &#125;, nameSpace2:&#123; xxx:xxx, ... &#125; ...&#125;;使用单例模式实现模块化开发模块化开发：把一个复杂页面按照具体功能划分成几大块，然后由不同的人分别去开发，这种模块划分的思想就是模块化开发功能。//=&gt;项目主管（开发人员）：公共模块 var utils=&#123; trim:function()&#123;&#125;&#125;; //=&gt;李雷：搜索模块var searchModel=&#123; submit:function()&#123; utils.trim(); &#125;, ...&#125;; //=&gt;韩梅梅：天气模块var weatherModel=&#123; setWeather:function()&#123;&#125;, ...&#125;;//=&gt;小红：频道模块var channelModel=&#123; show:function()&#123; //=&gt;在当前的命名空间下调取其它命名空间的方法：指定好对应的命名空间名字即可，使用 [NameSpace].[property] 就可以操作了 searchModel.submit(); //=&gt;调取本模块中的一些方法，可以直接使用THIS处理即可：此方法中的THIS一般都是当前模块的命名空间 this.setChannel(); &#125;, setChannel:function()&#123;&#125;, ... &#125;; 高级单例模式基于JS高阶编程技巧惰性思想，来实现的单例模式，并且可以把一些常用的设计模式（如：命令模式、发布订阅模式、promise设计模式等）融合进来，最后清晰的规划我们的业务逻辑代码，方便后期二次开发和维护，这种设计思想综合体就是高级单例模式，也是最常用的。 12345678910var serchModel=(function()&#123; function submit()&#123; &#125; return &#123; init:function()&#123; this.submit(); &#125; &#125; &#125;)(); searchModel.init(); 对象、类、实例对象：万物皆对象类：对象的具体细分（按照属性或特性细分的一些类别）实例：某一个类中的具体事物 JS常用的内置类数据类型的类Number：每个数字或者NaN是它的一个实例String：字符串类Boolean：布尔类NullUndefined：浏览器屏蔽了我们操作null和udnefined这个类Object：对象类，每个对象数据类型都是它的实例• Array：数组类• RegExp：正则类• Date：日期类Function：函数类，每个函数都是它的一个实例元素对象或者元素集合的类HTMLCollection：元素集合类• getElementsByTagName()• getElementsByClassName()• querySelectorAllNodeList：节点集合类• childNodes• getElementsByName()HTMLDivElementHTMLElementElement(标签类)Node(节点类，Element只是其中的一个元素节点) 为什么getElementById的上下文只能是document？(即getElementById为什么只能通过document来调用)？因为只有在Document这个类上才有getElementById这个方法，其他类上(如：HTMLDivElement类)没有getElementById这个方法，而document是HTMLDocument这个类的一个实例,能通过document.proto.proto找到Document这个类的原型上公有的getElementById方法。 基于面向对象创建数据创建方式：两种1.字面量创建方式• var obj={}；2.实例创建方式（构造函数方式）• var obj=new Array();如果传递的参数只是一个数值 1、对于引用数据类型来说，两种创建方式是大致相同的，只不过，两种方法创建的语法不同。两种创建方式在核心意义上没有差别，都是创建Array这个类的一个实例，但是在语法上是有区别的 2、构造函数创建方式new Array(10)：创建一个长度为10的数组,数组中的每一项都是空new Array(‘10’)：如果只传递一个实参，并且实参不是数字，相当于把当前值作为数组的第一项存储进来new Array(10,20,30)：如果传递多个实参，不是设置长度，而是把传递的内容当做数组中的每一项存储起来 2、对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象，数据类型值也是标准的对象数据类型，也是标准的内置类的实例；对于字面量方式创建出来的结果是基本数据类型的值，不是严格的实例，但是由于JS的松散特点，导致了可以使用 内置类.prototype上提供的方法； 构造函数设计模式使用构造函数方式，主要是为了创建类和实例的，也就是基于面向对象思想来实现一些需求在JS中，当我们使用new xxx()执行函数的时候，此时的函数就不是普通的函数了，而是变为一个类，返回的结果叫做当前类的实例，我们这种new xxx执行的方式称之为构造函数设计模式 12function fn()&#123; &#125;new fn();//new fn()是fn的一个实例 构造函数执行时new都干了些什么？在new Fn()，执行的时候，是先把函数执行了，后面的Fn()先执行，形成一个私有作用域，形参赋值变量提升，在变量提升完了之后，new操作符才起了作用，此时，浏览器开始创建一个新的对象，让Fn中的this指向这个新创建的对象（实例），然后让这个对象的proto指向Fn.prototype，然后JS代码才开始继续往下执行，开始往类中添加每个实例私有的属性和方法。JS代码执行完成后，会默认返回当前创建的这个对象。 普通函数执行与构造函数执行的区别 在代码从上而下执行之前，构造函数有特殊的操作：浏览器会在当前的作用域中默认创建一个对象数据类型的值，并且会让当前函数中的this指向创建的这个对象。然后JS代码再执行， 代码执行完成后，即使函数中没有写return，在构造函数模式中：浏览器会默认的把创建的对象返回到函数外面 总结： 构造函数执行期间，既具备函数执行的一面，也同时具备自己独有的操作：在构造函数执行期间，浏览器会默认创建一个对象，这个对象就是当前这个构造函数(类)实例，函数执行完成后，浏览器会默认的把这个实例返回。所以new Fn()执行，Fn是一个类，返回的结果就是Fn这个类的一个实例 构造函数执行后面的‘()’问题构造函数执行如果不需要传递参数，函数后面的()可省略，如new Fn()可写为new Fn；注意：• 如果要在new Fn之后直接调用实例的方法，则必须要加小括号，即必须写成new Fn().方法名 构造函数模式的返回值问题构造函数模式中默认返回值是当前的实例，如果有return,返回分2种情况：1、return 后面是一个基本数据类型的值，当前实例是不变的，例如return 100；我们的返回值还是当前类的实例；2、return 后面是一个引用数据类型的值(window除外)，当前实例会被返回的值给替换掉例如return {name:”李雷”}我们的返回值就不再是当前类的实例了，而是对象 {name:”李雷”}； A instanceof B 检测某一个实例是否属于这个类, 判断A实例是否属于B类 hasOwnProperty VS inin：用来检测当前这个属性是否隶属于对象（不管是对象私有的还是公有的属性，只要有返回的就是true） hasOwnProperty：用来检测当前这个属性是否是对象的私有属性（不仅要是对象的属性，而且需要是私有的才可以） 1234attr in object//检测attr是否是object的属性，不管是私有属性还是公有属性只要存在，用in来检测都是truea.hasOwnProperty(attr)//attr是否是A实例的私有属性 原型链模式基于构造函数模式的原型链模式解决了方法或者属性公有的问题，把实例之间公有的属性和方法写在当前类的prototype属性上； 每一个函数数据类型都有一个天生自带的属性：prototype（原型），并且这个属性的属性值是一个对象数据类型的值，浏览器默认为其开辟一个堆内存； 在浏览器给prototype开辟的这个堆内存上浏览器天生给它加了一个constructor属性（构造函数），属性值是当前函数（类）本身； 每一个对象数据类型(普通对象、数组、正则、实例、protoype..)也天生自带一个属性:proto，属性值指向当前实例所属类的原型(prototype);(IE中屏蔽了对象的proto属性，但是确实有，只是不让我们使用而已) Object是JS中所有对象数据类型的基类（最顶层的类）； 原型链模式中的this分两种情况原型模式中的this分两种情况： 在类中this.xxx=xxx;this-&gt;当前类的实例 原型链中提供的私有(公有)方法中的this问题： 总结：看执行的时候”.”前面是谁this就是谁。具体操作步骤如下 需要先确定this的指向（this） 把this替换成对应的的代码 按照原型链查找的机制，一步步的查找结果 重构原型让某个构造函数的原型指向自己开辟的堆内存，但是自己开辟的堆内存当中是没有constructor属性的，所以要往自己开辟的堆内存中添加constructor属性，属性值为当前构造函数本身； contrcutor:fn缺点：重构原型后，会导致之前添加的属性和方法都没有了，只能使用重构之后添加的属性和方法；注意：• 不要忘了重构之后要添加constructor属性指向当前构造函数；• 内置类的原型不能重构，浏览器不允许我们这么做； 类的继承、封装和多态 它是一种编程思想（Object Oriented Programming）,我们的编程和学习其实是按照类和实例来完成的 我们要学习类的继承、封装、多态 封装 把实现一个功能的代码封装在一个函数中，以后再要实现这个功能，只要执行函数方法即可，不需要重新编写代码低耦合高内聚减少页面代码冗余，提高代码利用率 多态一个类（函数）的多种形态：重载、重写 重载 后台JAVA等编程语言中，对于重载的概念：方法名相同，参数名不同，叫做方法的重载JS中没有类似于后台严格意义的重载，JS中，如果方法名相同了，最后只能保留一个（和实参没有关系）JS中的重载：同一个方法，通过传递实参的不同，（arguments）我们完成不同的功能，我们把这个也可以理解为重载 12345678function sum(num1,num2)&#123;return num1+num2;&#125;function sum()&#123;var ary=[].slice.call(arguments);return&#125;//只会执行后面那个sum 重写 不管是后台语言还是JS，都有重写，子类重写父类的方法； 继承 原理：子类继承父类的中的一些属性和方法 原型继承 让子类的原型指向父类的实例；child.prototype=new parent(); 我们首先让子类的原型指向父类的实例，然后在向子类原型上扩展方法，防止提前增加方法，等原型重新指向后，之前在子类原型上扩展的方法都没用了（子类原型已经指向新的空间地址了）； 让子类原型重新指向父类实例，子类原型上的原有constructor就没了，为了保证构造函数的完整性，我们需要重新手动设置constructor: child.protype.constructor.call(child) *原理 *原型继承并不是把父类的属性和方法copy一份给子类，而是给子类和父类之间搭建一个连接的桥梁，以后子类或者子类的实例，可以通过原型链的查找机制，找到父类原型的方法，从而调取这些方法。 特征 子类不仅可以继承父类原型上的公有属性方法，也可以继承父类提供给实例的私有属性和方法，并把其放在子类的公有属性和方法上。 call继承（继承私有的） 原理在子类的构造体中，把父类做普通方法执行，让父类方法中的this指向子类实例特点：把父类 构造体中的私有属性和方法，原封不动复制了一份给子类实例（继承完成后，子类和父类是没有关系的）注意我们一般把call放在第一行，就是创建子类实例的时候，首先继承，然后在给实例赋值自己私有的（好处：自己可以把继承的结果替换掉） 12345678function A()&#123; this.x=100;&#125;function B()&#123;//一般都把call继承放在子类函数体中的第一行,这样做的好处就是子类私有的可以替换掉继承过来的结果； A.call(this); this.y=200&#125; 寄生组合式继承 Object.create（[obj]）:创建一个空对象，把obj作为新对象的原型（继承公有）Object.create不兼容 123var obj=&#123;name:'李雷'&#125;;var newObj=Object.create(obj);newObj.__proto__===obj; child.protype= Object.create(parent.protorype); 利用Object.create创建一个的空对象； 该空对象指向parent.protorype； 将该对象的地址赋值给child.protype，从而导致child和child的实例都可以通过原型链找到parent的原型； 该方法只能继承parent的公有方法和属性 自己实现类似于Object.create的方法 12345Object.myCreate=function myCreate()&#123;var Fn = new Function();Fn.prototype = obj; return new Fn()&#125; ES6中的类及继承123456789101112131415161718192021222324252627282930313233343536class Fn &#123;//constructor就是当前函数本身=Fnconstructor()&#123; this.x='xxx';//给当前实例增加私有属性 .........&#125;//增加公有属性，相当于在原型上添加xxX()&#123; ......... &#125;//这些属性方法都是将Fn当做普通对象设置的私有属性和方法，和实例没有任何关系 static xxx()&#123;.............&#125;&#125; class A &#123; constructor() &#123; this.x = 100; &#125; getX() &#123; console.log(this.x);&#125; &#125; class B extends A &#123; constructor() &#123; super();//=&gt;CALL继承 this.y = 200;&#125; getY() &#123; console.log(this.y);&#125;&#125;var b = new B();]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（五）数组汇总]]></title>
    <url>%2Fposts%2F4834a967.html</url>
    <content type="text"><![CDATA[数组详解给数组开头增加新内容的方法:1234567unshift; ary.[0]=xxx; ary.splice(0,0,X); ary.slice(); //删除数组第一项： shift; splice(0,1); 12345//给数组末尾增加： push; splice(ary.length,0,x) //数组克隆； slice(); 数组的基础结构 数组是对象类型属性名是数字 类数组类似数组 但不是数组（以下是类数组） 通过getElementsByTagName等获取的元素集合 函数中的实参集合argument 记忆数组要按以下几个维度1、方法的意义2、方法的形参3、方法的返回值4、通过此方法，原来数组是否发生改变） 1数组的增加、修改、删除 12var ary=[12,34,5]; ary.push('sd'); 增加 push向数组末尾增加新内容参数：一个到多个，任何数据都可以，用逗号隔开返回值：新增数组后的长度原有的数组变了 unshift向数组开头增加新内容参数：一个到多个，任何数据都可以，用逗号隔开返回值：新增数组后的长度其余同push 把数组当做一个普通的对象，使用对象键值对操作，给其设置新的属性 ary[length]=xxx;向数组末尾添加一个新内容 删除 pop功能：删除数组最后一项参数：无返回值：被删除的那一项原有数组改变了 shift删除数组第一项（后面每一项索引都要向前进一位）参数：无返回值：被删除那一项原有数组改变 delete 把数组当做普通的对象操作 delete ary[索引]删除指定那一项，其余的索引不会改变，数组的length也不变 ary.length–;删除数组最后一项 splice: 数组中内置的方法，可以实现数组的增加、修改、删除 splice实现删除 splice(n,m):从索引n开始删除m个 （m不写是删除到末尾，都不写是不删除）ary.splice(0)全部删除 返回值：被删除的内容（以一个新数组来保存被删除的内容） 原有数组改变 splice实现修改 splice(n,m,x):用x代替删除的内容 splice 实现增加 splice(n,0,x);在修改的基础上，一项都不删除，将x放在n的前面 splice(0,0,x) 向数组开头增加一个 splice(ary.length,0,x) 向数组末尾增加一项 splice(0,1);删除数组第一项 splice(ary.length-1,1) 删除数组最后一项 数组查询slice:数组查询 参数：slice(n,m)从索引n开始找到索引m处（不包含m） 返回值：把找到的部分以一个新数组返回 原来数组不改变 slice(n);从n开始找到末尾 slice(0)/slice();数组克隆，克隆一份和原来一模一样的新数组； slice支持负数，解析时按照：总长度+负数索引 来处理 将两个数组进行拼接concat 将多个数组拼接在一起 参数：要拼接的内容放在原数组后面 返回：拼接后新数组 原有数组不变 concat(),什么都没有拼接，相当于把原有的数组克隆； 数组克隆后出现的是一个新数组，与原有数组不相同，拷贝一份 把数组转化为字符串toString 实现把数组转化为字符串，一逗号分隔 参数：无参数 返回：转换后的字符串 原有数组不变 join 把数组按照指定的分隔符转换为字符串，和字符串中的split相对应 参数：指定连接符 返回值：转化后的字符串 原有数组不变 eval:把字符串变为JS表达式执行var total=eval(ary.join(‘+’)); 可实现数组求和；(一般项目中尽量不要用eval，性能较差) 实现数组中每一项的排序和排列reverse 把数组倒过来排列 参数 ：无 返回值：排序后的数组 原有数组改变 sort 实现数组排序 参数：无或回调函数； 返回值：排序后的 原有数组改变不传参的情况下，只能识别10以内的数字，多位数只识别第一位 1234ary.sort(function(a,b)&#123;return a-b; //升序 a-b&gt;0,a和b交换位置 return b-a;//降序 &#125;) 遍历数组中每一项的方法（ 以下方法在IE6-8都不支持） 方法名 是否操作原数组 方法返回结果 回调函数返回结果 filter（过滤） 否 过滤后的新数组 true/false,若true则放到新数组中 map（映射） 否 新数组 return后的值 find 否 返回找到的那一项，没有返回-1 返回true表示找到了，并停止 some 否 boolean 找true，找不到返回false every 否 boolean 找false，找不到返回true reduce 否 累积后的结果 返回的是下一次的prev 遍历数组或类数组、字符串每一项 for …of 1234let arr = [2, 4, 1, 3]; for(let val of arr)&#123; console.log(val);//2，4，1，3&#125; find 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12345let arr = [2, 4, 1, 3];res=arr.find((item)=&gt;&#123; return item&gt;1; &#125;) console.log(res);//2 findIndex find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 12345res=arr.find((item)=&gt;&#123; return item&gt;1; &#125;) console.log(res);//0=&gt;2的索引//find,findIndex都可以接受第二个参数，用来绑定回调函数的this对象 forEach（不支持return） 对数组中的每一项运行给定函数，没有返回值 1234let arr = [2, 4, 1, 3];arr.forEach(function (item, index) &#123; console.log(item);//2, 4, 1, 3&#125;) some 对数组中的每一项运行给定函数,只要一个条件成立，则返回true，条件都不成立才返回false; 12345let arr = [2, 4, 1, 3];res = arr.some((item, index) =&gt; &#123; return item &gt; 3;&#125;)console.log(res);//true every 对数组中的每一项运行给定函数,条件都成立才返回true，只要有一个不成立，则返回false 12345let arr = [2, 4, 1, 3];let res4 = arr.every((item, index) =&gt; &#123; return item &gt; 3;&#125;)console.log(res4);//false map()：（映射） 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 12345let ary = [2, 4, 1, 3];let res1=ary.map((item,index)=&gt;&#123; return item*2;&#125;);console.log(res1);//[4,8,2,6] 两个归并数组的方法:reduce,reduceRightreduce: 对数组中的每一项运行给定函数,计算数组每一项的累积值 prev:累积项，next当前项4个参数:[pre,next,index,ary] index：next的索引，ary：原数组 12345678910111213let arr = [2, 4, 1, 3];//实现每一项成员的累加let res5 = arr.reduce((prev, next) =&gt; &#123;//当没有第二个参数时，第一次prev是第一项，next是第二项，然后将他们的和赋值给prev，然后next值会等于第三项，prev就等于累加项，以此类推 return prev + next;&#125;,0)//0是给prev设置的默认值，可不加，当prev有默认值时，next从第一项开始console.log(res5);//10 eg2：let arr1= [&#123;price: 10, count: 2&#125;, &#123;price: 3, count: 6&#125;];//求总金额let res6 = arr.reduce((prev,next =&gt; &#123; return prev+next.price+next.count;&#125;), 0);//0是prev的默认值，此时next第一次就等于数组第一项;console.log(res6); reduceRight 使用 reduce()还是 reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。 filter （过滤） 对数组中的每一项运行给定函数, 筛选掉不符合条件的，返回匹配条件的 （返回的是一个新数组） 1234let res2 = ary2.filter((item,index)=&gt;&#123; //删除功能时用的多 return item&lt;4&#125;)console.log(res2);//[2,1,3] 数组方法，验证数组中是否包含某一项indexOf/lastIndexOf :获取当前项在数组中第一次或最后一次出现位置的索引 数组中这两个方法在IE6-8下不兼容 字符串中的这两个方法兼容所有的浏览器 如果当前数组中没有这一项，则返回-1； 数组去重方法一： 遍历数组将数组的每一项和上一项比较，如果相同，则删除这一项（for） 方法二 遍历数组每次将数组的某一项和剩下的比较indexOf，如果相同，就删除该项，那么最后留下来的就没有重复项了； 1234567891011var ary=[2,7,8,9,45,8,78,4,2,7]; for(var i;i&lt;ary.length;i++)&#123; var ary2=ary[i]; ary3=ary.splice(i+1); if (ary3.indexOf(ary2)&gt;-1)&#123; ary.splice（i,1); i--; &#125; &#125; console.log(ary); 方式三（键值对的方式） 遍历数组每一项把每一项作为新对象的属性名和属性值存起来，例如当前项1，则[1,1];所以以后如果出现相同的属性名，则删除该项，typeOf obj.[xxx]===undefined;则该项不是重复值在原型上添加一个数组去重的方法 123456789101112131415Array.prototype.myDistinct= function () &#123; let obj=&#123;&#125;; for (let i = 0; i &lt; this.length; i++) &#123; let item= this[i]; if(typeof obj[item]!=='undefined')&#123;//该项是重复的 this[i]=this[this.length-1];//用最后一项的值赋值给当前项， this.length--;//将最后一项删除（上一步已将最后一项保存至前面） i--; continue; &#125; obj[item]=item; &#125; obj=null; return this;&#125;; 123456789101112131415//另一种写法，不会改变原数组的相对顺序Array.prototype.myDistinct = function myDistinct() &#123; let obj = &#123;&#125;; for (let i = 0; i &lt; this.length; i++) &#123; let item = this[i]; if (obj[item] === this[i]) &#123; this.splice(i, 1); i--; continue; &#125; obj[item] = item; &#125; obj = null; return this;&#125;; 冒泡排序 原理：让数组中的当前项和后面的每一项进行比较，如果当前项大于后一项，我们让两者交换位置（小—大），就好像是气泡升到表面一样，因此得名总共比较：length-1次； 12345678910111213141516function bubble(ary) &#123; //-&gt;外层循环控制的是比较的轮数： for (var i = 0; i &lt; ary.length - 1; i++) &#123; //-&gt;里层循环控制每一轮比较的次数. for (var k = 0; k &lt; ary.length - 1 - i; k++) &#123; //ary[k]:当前本次拿出来这一项 //ary[k+1]:当前项的后一项 if (ary[k] &gt; ary[k + 1]) &#123; //当前项比后一项大,我们让两者交换位置 var temp = ary[k]; ary[k] = ary[k + 1]; ary[k + 1] = temp;//可用结构赋值[ary[k],ary[k+1]]=[ary[k+1],ary[k]]; &#125; &#125; &#125; return ary;&#125; 每一轮从前到后两两比较，虽然不一定实现最后的排序效果，但是可以把当前最大的放在末尾具体比较的轮数：ary.length-1 数组有多长，我们只需要把总长度-1个数分别放在末尾，即可实现最后的排序对于数组[12, 13, 23, 14, 16, 11]；第一轮比较5次：一共六个，不需要和自己比较第二轮比较4次：一共六个，不用和自己比，也不用和第一轮放在末尾的那个最大值比第三轮比较3次每一轮比较的次数 ary.length-1(不用和自己比)-当前已经执行的轮数(执行一轮向末尾放一个最大值,这些值不需要再比较) 数组中的深度克隆首先使用JSON.Stringfy将数组转化为无意义的字符串，在使用JSON.parse将字符串转化为对象]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（四）String和Math中常用的方法]]></title>
    <url>%2Fposts%2Fe28a6795.html</url>
    <content type="text"><![CDATA[字符串中常用的方法 索引特点，从0开始length属性，字符串的长度如果指定索引不存在，会得到undefined真实项目中,我们经常操作字符串，此时我们需要掌握一些常用方法console.dir(String,prototype) charAt&amp;&amp;charCodaAt【兼容所有浏览器】 str.charAt();返回索引指定的字符,当指定索引不存在时返回””,当指定索引不存在时str[100]返回undefined;str.charCodeAt(),在charAt的基础上，获取指定位置字符的unicode编码Str.fromcharCode()通过unicoed码 得到原有字符 与charCodeAt相反 substr&amp;&amp;substring&amp;&amp;slice str.substr(n,m):从索引n开始，截取m个字符（第一个参数支持负数）str.subtring(n,m):从索引n开始，截取到索引m处，不包含m;（不支持负数）str.slice(n,m):从索引n开始，截取到索引m处，不包含m,(支持负数)； 当索引时负数时，是用字符串的总长度加上索引，在按照正数操作注意：如果只传递1个参数n，则从n截取到末尾如果索引超过最大值，则能截取多少是多少如果没有传参数，则相当于把整个字符串都截取了（字符串克隆） toUperCase&amp;&amp;toLowerCase toUperCase():把字母全部大写 str.toUpperCase()toLowerCase():把字母全部小写 indexOf&amp;&amp;lastIndexOf【兼容所有浏览器】 indexOf:获取当前字符首次出现的位置lastIndexOf:获取当前字符最后一次出现的位置 *注意 *如果当前字符串没有出现过，结果为-1；由此可以借用此方法来检查是否具有某元素 split Str.split:按照某一元素将字符串划分为几组,返回的是一个数组若不存在，则保持原来的Str支持正则 12345678str='wedfg';str.split('d');//返回值是个数组(2) ["we", "fg"]0: "we"1: "fg"length: 2__proto__: Array(0) replace Str.replace:实现字符的替换Str.replace(a,b) //用b替换a执行一次只能替换一个，想替换多个的多次执行，真实项目中一般正和则一起使用； trim&amp;&amp;trimLeft&amp;&amp;trimRight Str.trimLeft:去除字符串左边兼容Str.trimRight:去除字符串右边空格Str.trim:去除字符串收尾空格 案例：queryURLParameter 获取地址栏中URL地址问号的传递参数值https://www.baidu.com/s?word=谷歌浏览器&amp;tn=93219212_hao_pg&amp;ie=utf-8问号后面就是我们传递的参数https://www.baidu.com/s?f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;word=小说&amp;tn=94076069_hao_pg 我们的目标：把问号传递的参数值给解析出来obj={word:’谷歌浏览器’,tn:93219212_hao_pg,ie:utf-8} 1234567891011121314151617181920212223&gt; function queryURLParameter(url)&#123;&gt; //=&gt;定义一个函数&gt; var quesIndex=url.indexOf('?');&gt; //获取？的位置&gt; var obj=&#123;&#125;;//定义一个空函数&gt; if(quesIndex===-1)&#123;&gt; //如果？不存在&gt; return obj;&gt; &#125;&gt; url=url.substr(quesIndex+1);&gt; //获取?后面的字符串&gt; var ary=url.split('&amp;');&gt; //用&amp;将字符串划分为数组&gt; for(var i=0;i&lt;ary.length;i++)&#123;&gt; var curAry=ary[i].split('=');&gt; //用=将字符串划分为长度为2的数组&gt; obj[curAry[0]]= curAry[1];&gt; //数组中第一个为属性，第二个为属性值&gt; return obj;&gt; &#125; &gt; &gt; &#125;&gt; Math中常用的方法 数学函数，但是他是对象类型Math 中为我们提供了很多常用操作数字的方法conlse.dir(Math)查看有很多方法 @[abs] Math.abs() 取绝对值 @[ceil/floor] Math.ceil() 向上取整Math.flloor() 向下取整 @[round] Math.round() 四舍五入 @[random] Math.random() 获取[0-1)之间的随机小数 1234//获取0-10之间的随机小数[0-10]Math.round(Math.random()*10)//获取[]3-15]的随机整数Math.round(Math.random())*12+3 注意规律 获取[n,m]之间的随机整数Math.round(Math.random())*(m-n)+n @[max/min] Matn.max:获取一组数据的最大值Math.min:获取一组数据的最小值 @[PI] Math,PI:获取圆周率 @[pow/sqrt] Math.pow:获取一个值的多少次幂Math.sqrt 开平方 案例：验证码基本功能实现 （结合Math和String） 一般是由后台处理，后台返回给客户端一张图片（图片中包含了验证码） （防止批量注册，前端容易被解析）验证码形式1、字母数字2、问答3、选择图片4、成语拼图5、图片拼图6、滑动拖拽 案例主要思想(获取4个字母和数字的组合) 获取文档中的元素(最后数字要放进去)定义一个空数组（用于存放随机获得的字符）定义一个取值区域（0-9，a-z,A-Z）共62个创建for循环获取一个0-61的随机整数（Math.round(Math.random*61)）利用这个整数获取该位置的字符，charAt()]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（三）数据类型汇总]]></title>
    <url>%2Fposts%2F4b7ffcca.html</url>
    <content type="text"><![CDATA[数据类型的转换汇总Number类型的转换把其他数据类型转换为number类型的方法 isNaN,Number,parsseIn,praseFloat在进行加减乘除运算时 12345'12px'=&gt;NaN; "主灯"=&gt;NaN[ ] /null /false / ' ' /=&gt;0&#123; &#125; /^$/ function()&#123;&#125;/ undefined /=&gt;NaN*注：引用类型在转化Number时，先转化为字符串（toString），再转变为数字(Nubber)。*parseFloat('');=&gt;NaN 与number不同 js中的数学运算 +、-、*、/、% 加减乘除取模除了加法有特殊性，其与运算遇到非数字类型时都要先转换为Number在进行运算 注：+有字符串拼接的作用(就是把其他值转化为 字符串再拼接)特殊：({ }).toString()==&gt;&#39;[object object ]&#39;//对象的{}要用（）包起来，否则报错，因为{}会被认为是代码块其余都直接转化为字符串 12345678910111213141516//加法的特殊性12+3+'2'=&gt;152'3'+4 =&gt;34null+'2' =&gt; 'null2'// 其余运算1-'1' =&gt;010*null =&gt;0 2+null+false+undefined+NaN+[1,2]+'珠 峰'+32+null =&gt;2+0=22+false =&gt;2+0=22+undefined =&gt;2+NaN=NaNNaN+NaN=NaNNaN+[1,2] =&gt;NaN+'1,2'=&gt;'NaN1,2'数组要先转化为字符串再转为数字再相加，但在转换为字符串时就会进行字符串的拼接'NaN1,2'+'珠峰'+3='NaN1,2珠峰3' 布尔类型的转换将其他数据转换为布尔类型(3种) Blooean / ! / !!判断语句除以下5种外，其余都为true0, null, ’ ‘, NaN, undefined, 注意 12345678910111213141516171819202122//对象和对象比较：比较的是空间地址,不是同一个空间，肯定是false[]==[] =&gt;false var a=&#123;&#125;;var b=a;a==b =&gt;true //(空间地址相同) //对象和数字比较，先调用toString方法[]==0 =&gt;true(&#123;&#125;)==NaN =&gt;false NaN和任何东西都不等，包括自己 //对象和字符串比较 (把两边都转化为字符串)[]=='' =&gt;true //对象和布尔：（把两边都转化为数字）[]==true =&gt;0==1 =&gt;false[]==false =&gt;true![]==false =&gt;true //![]把数组变为布尔再取反[]=true //字符串和数字：（把两边都转化为数字）//字符串和布尔： （把两边都转化为数字）//布尔和数字： （把两边都转化为数字） 规律，两个等于号比较时，左右两边的的数据类型不一样，浏览器会把两边类型都转为数字再比较（对象类型比较特殊，应该先转化为字符串，再转化为数字），但是null和undefined除外null和undefined和其他任何值都不相等 12null==undefined =&gt;true null===undefined =&gt; false 规律，两个等于号比较时，两边类型相同时，直接比较，对象和对象比较的是空间地址；{}！={}，另外NaN和任何值都不等 JS中的数据类型检测汇总typeof 用来检测数据类型的运算符语法：typeof [value]，typeof后面跟的都是值返回结果：首先是个字符串，字符串中包含了我们需要检测的数据类型typeof null=’object’ &gt;虽然时基本数据类型，但是它属于空对象指针，检测结果是对象（局限性）并且不能细分出当前对象是数组还是正则（局限性）typeof 1&gt;1?1:2; =&gt;2 //优先级，先计算typeof 1;再比较， instanceof&amp;constructor instanceof:检测某一实例是否属于当前类constructor:构造函数使用instanceof检测某个值是否属于某个数据类型 的内之类，从而检测出它是否是这个类型的值，对对象类型的值有明显的区分 instanceof检测的弊端基本类型的值无法基于它检测var num=12; typeof num =&gt; ‘Number’num instanceof Number =&gt;falsevar num2=Number(12); typeof num2 =&gt; ‘object’num2 instanceof Number =&gt;true不管是哪一种方式创建基本类型值，都是自己所属类的实例，只不过类型不一样而已 instanceof 是基于原型链来检测的，是要当前类的实例在原型链上，最后返回的结果都是true,这也是instanceof的弊端 constructor获取要检测数据类型的constructor属性，判断它是否为某个数据类型的内置类来检测ary.constructor===Array; =&gt;true;ary.constructor=’AA’;ary.constructor===”AA’; =&gt;true=&gt;由于constructor的值可以被修改，所以检测结果非常不可靠 Object.prototype.toString.call([value]) 获取Object.prototype的toString方法，将方法中的this改为需要检测数据类型的值，然后执行在Number String Boolean Array……这些类的原型上都有toString方法，这个方法就是把本身的值转换为字符串的在Object这个类的原型上也有一个toString方法，但是这个方法是返回当前值的所属类详细信息，固定结构：[Object 所属的类型]使用该方法检测，不管你是什么值，我们都可以正正常检测出我们需要的结果 1234567891011121314var obj=&#123;name:'珠峰'&#125;;obj.toString() //=&gt;"[object Object]" 调取的正是Object.prototype.toString /** obj.toString()* 首先执行Object.prototype.toString方法* 这个方法中的this就是我们操作的数据值obj* =&gt;总结：Object.prototype.toString执行的时候会返回当前方法中this的所属类信息** 也就是，我想知道谁的所属类信息，我们就把这个toString方法执行，并且让this变为我们检测的这个数据值，那么方法返回的结果就是当前检测这个值的所属类信息** Object.prototype.toString.call([value])* (&#123;&#125;).toString.call([value])*/ 因为alert弹出的都是字符串，所以会自动将（）中的内容调用toString,而对象类型调用toString,会出现[Object 所属的类型]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（二）函数专题]]></title>
    <url>%2Fposts%2F9f7bba47.html</url>
    <content type="text"><![CDATA[函数专题函数是指一段在一起的、可以做某一件事儿的代码。可以随时运行，可以重复使用。 创建函数1234function fn[函数名]()&#123;//=&gt;[函数体]//实现功能的具体JS代码&#125; 函数执行fn(); //=&gt;把创建的函数执行，而且这个函数可以执行很多次 每一次执行都相当于把函数体中实现功能的JS代码重复执行了一遍 在真实项目中，我们一般都会把实现一个具体功能的代码封装在函数中：1、如果当前这个功能需要在页面中执行多次，不封装成为函数，每一次想实现这个功能，都需要重新把代码写一遍；而封装在一个函数中，以后想实现这个功能，只需要把函数重新的执行即可，提高了开发效率；2、封装在一个函数中，页面中就基本上很难出现重复一样的代码了，减少了页面中代码的冗余度，提高了代码的重复利用率：低耦合高内聚 我们把以上的特点称为函数封装（OOP面向对象编程思想，需要我们掌握的就是类的继承、封装、多态） JS中函数的核心原理函数作为JS中引用数据类型中的一种，也是按照引用地址来操作的 1、函数执行首先会形成一个新的私有作用域，目的是为函数体中的代码提供一个执行的环境（而且这个环境是私有的） 2、把创建时候存储的代码字符串copy一份到自己的私有作用域中，然后把字符串转换为JS表达式，再然后依次自上而下执行目的：把之前存储的实现具体功能的JS代码执行 函数执行步骤 形参赋值 私有作用域中的变量提升 把之前创建时候存储的那些JS代码字符串，拿到私有作用域中，然后把它们变为JS表达式从上到下执行 私有作用域是否销毁的问题[根据栈内存是否被占用] 函数中的变量提升 在当前作用域中，js代码自上而下执行之前，浏览器首先会把所有带var/function关键字的进行提前的声明或者定义 声明(declare)：var num; 在当前作用域中吼一嗓子我有num这个名了定义(defined)：num=11; 把声明的名字赋一个值 带var关键字的只是提前的声明一下；带function关键字的在变量提升阶段把声明和定义都完成了； 变量提升详解对于带var和function关键字在与解释的时候操作不一样 var 在预解释的时候只是提前声明 function 在预解释时提前将声明和定义都完成了； 1、.预解释只发生在当前作用域中，开始只对window下的预解释，只有在函数执行时，才会对函数体中的进行预解释2、在if判断中，在预解释时，不管你条件是否成立，都要将带var的进行预解释（在老版本浏览器中，函数会被声明和定义，新版本浏览器中，函数只会被声明）3、var fn=function(){},在匿名函数值函数表达式中只对等号左边进行预解释，右边是值，不参加预解释 真实项目中，应用这个原理，我们创建函数的时候可以使用函数表达式的方式：1、因为只能对等号左边的进行提升，所以变量提升完成后，当前函数只是声明了，没有定义，想要执行函数只能放在赋值的代码之后执行（放在前面执行相当于让undefined执行，会报错的）2、这样让我们的代码逻辑更加严谨，以后想要知道一个执行的函数做了什么功能，只需要向上查找定义的部分即可（不会存在定义的代码在执行下面的情况） 4、function fn（n）{};(10); 自执行函数，在全局作用域下不进行预解释，在执行到该位置是定义和执行一起完成。5、当函数中有return时，return下面的函数不执行，但是会预解释；return后面跟的是返回值，所以不进行预解释。6、在预解释中，如果名字已经声明过了，后面就不重新声明，但会重新赋值； 如何区分私有变量和全局变量 在全局作用域下声明的都是全局变量 在私有作用域下声明的变量和函数的形参都是私有 变量 在私有作用域中，我们代码执行的时候遇到一个变量，首先我们要确定他是否为私有变量，如果是私有变量，那么他和外面没有任何关系；如果不是私有变量，（不加var）那么就要向他的上级查找，一直到window为止； 看当前函数在哪个作用域定义，那么他的上级作用于就是谁，跟在哪里运行没有关系 在全局作用域中带var和不带var的区别 1、带var的可以先进行预解释，所以在赋值前执行不会报错；不带var的没有进行预解释，在前面执行会报错；2、num=12;console.log(num2); ==&gt;12 //含义：相当于给window增加一个属性，属性名=num，属性值=12；3、var num=12;console.log(num); =&gt; 12// 首先给全局作用域增加一个全局变量，而且也为window增加一个属性 in ：判断变量是否存在当前作用域中； ++i和i++的区别都是自增1的意思在运算中不同点i++是先进行运算，再自增++i是先自增1再运算 作用域链函数执行形成一个私有的作用域（保护私有变量），进入到私有作用域中，首先变量提升（声明过的变量是私有的），接下来代码执行1、执行的时候遇到一个变量，如果这个变量是私有的，那么按照私有处理即可2、如果当前这个变量不是私有的，我们需要向它的上级作用域进行查找，上级如果也没有，则继续向上查找，一直找到window全局作用域为止，我们把这种查找机制叫做作用域链1）如果上级作用域有这个变量，我们当前操作的都是上级作用域中的变量（假如我们在当前作用域把值改了，相当于把上级作用域中的这个值给修改了）2）如果上级作用域中没有这个变量(找到window也没有)：变量 = 值 ：相当于给window设置了一个属性，以后再操作window下就有了alert(变量)：想要输出这个变量，但是此时是没有的，所以会报错 闭包函数执行会形成一个私有的作用域，让里面的私有变量和外界互不影响（相互不干扰、外面的无法直接获取里面的变量值），此时我们可以理解为私有作用域把私有变量保护起来的，我们把这种保护机制称之为闭包闭包的作用：保护：私有作用域把私有变量保护起来的保存：函数执行形成一个私有作用域，函数执行完成，形成的这个栈内存一般情况下都会自动释放但是还有其他情况：函数执行完成，当前私有作用域（栈内存）中的某一部分内容被栈内存以外的其它东西（变量/元素的事件）占用了，当前的栈内存就不能释放掉，也就形成了不销毁的私有作用域（里面的私有变量也不会销毁） 堆内存所有的引用数据类型，它们需要存储的内容都在堆内存中（相当于一个仓库，目的是存储信息） 对象会把键值对存储进来函数会把代码当做字符串存储进来释放：如果当前的堆内存被变量（或者函数以及元素事件等）占用了（占用了：堆内存地址赋值给变量了），此时的堆内存是有用的，不能销毁；我们想要手动释放堆内存，只需要让存储地址的变量等于其它值即可（最好等于null，null是空对象指针，本意就是不指向任何的堆内存）； 函数中的形参和实参形参：相当于函数提供的入口，需要用户执行函数的时候把需要的值传递进来，形参是个变量，用来存储和接收这些值 实参：用户执行的时候传递给形参的具体值 在非严格模式下：函数的形参和实参有一一对应的映射关系；当没有传递实参时，这种映射关系被切断，严格模式下不存在映射关系 123456789//=&gt;随便求出两个数的和function sum(num1,num2)&#123;//=&gt;num1/num2就是形参变量(类似于var了一下)var total = num1+num2;total*=10;total=total.toFixed(2);console.log(total);&#125;sum(10,20);//-&gt;10/20是实参 num1=10 num2=20sum(10); //-&gt;num1=10 num2=undefined 定义了形参但是执行的时候没有传递实参，默认实参的值是undefined 此时num2与实参的映射关系被切断 123456789101112function sum(num1, num2) &#123;//=&gt;如果有一个值没有传递的话,我们为了保证结果不是NaN,我们为其设置一个默认的值:0//=&gt;容错处理num1 = num1 || 0;num2 = num2 || 0;var total = num1 + num2;total *= 10;total = total.toFixed(2);console.log(total);&#125;sum(10, 20);//在非严格模式下，函数的两个形参可以重名，但是函数只会接收后一个参数传的值，如果只传入一个实参，则如下图所示： 在严格模式下，形参不可以重名 arguments实参集合 当我们不知道用户具体要传递几个值的时候（传递几个值都行），此时我们无法设置形参的个数；遇到此类需求，需要使用函数内置的实参集合：arguments1、arguments只有函数才有2、不管执行函数的时候是否传递实参，arguments天生就存在，没有传递实参ARG是个空的集合，传递了ARG中包含了所有传递的实参值3、不管是否设置了形参，ARG中始终存储了所有的实参信息 arguments是一个类数组集合1、以数字作为索引(属性名)，从零开始arguments[0] 第一个实参信息arguments[2] 第三个实参信息2、有一个length的属性，存储的是当前几个的长度（当前传递实参的个数）arguments.lengtharguments[‘length’]arguments.callee：存储的是当前函数本身arguments.callee.caller：存储的是当前函数在哪执行的（宿主函数），在全局作用域下执行的，结果是null 在非严格模式下，agruments与形参有一一对应的关系，但当没有传入实参时，这种映射关系会被切断，在严格模式下，agruments与形参的映射关系也被切断了 123456"use strict"; //=&gt;在JS代码执行之前加入这句话：开启JS的严格模式function sum() &#123;console.log(arguments.callee);//=&gt;Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them&#125;sum(10, 20, '珠峰', &#123;name: '珠峰'&#125;);//=&gt;arguments.callee或者arguments.callee.caller一般真正项目中很少使用：因为在严格的JS模式下不允许我们使用这两个属性，然而现有项目大部分都是基于严格模式来的 JS中的返回值 return 返回值是函数提供的一个出口：我们如果想在外面使用函数私有的一些信息，那么就需要通过return，把这些信息返回出来供外面使用 - RETURN后面跟着的都是值（返回的都是值） 如果函数中没有写RETURN或者RETURN后面啥也没有,默认返回的结果就是undefined 在函数体中遇到RETURN后,RETURN后面的代码都不在执行了12345678function sum() &#123;var total = null;return total;//=&gt;RETURN后面跟着的都是值（返回的都是值）：此处不是把TOTAL变量返回，而是把TOTAL存储的值返回而已 &lt;=&gt; RETURN 60;//return 1+1; //&lt;=&gt; RETURN 2;&#125;console.log(sum(10, 20, 30));//=&gt;sum：代表的是函数本身//=&gt;sum()：让函数先执行,代表的是当前函数返回的结果(RETURN 后面是啥,相当于函数返回的是啥) 12345678910function sum() &#123;var total = null;for (var i = 0; i &lt; arguments.length; i++) &#123;var cur = Number(arguments[i]);!isNaN(cur) ? total += cur : null;&#125;return total;&#125;var total = sum(10, 20, 30);//=&gt;外面是全局下的TOTAL和函数中的TOTAL没有必然的联系console.log(total.toFixed(2)); JS中的匿名函数没有名字的函数 函数表达式:把一个函数作为值赋值给一个变量或某个事件（函数表达式右边的都是匿名函数） 自执行函数:创建函数和执行函数放在一起了，创建完成立马执行123oBox.onclick = function()&#123;//=&gt;把一个没有名字的函数(有名字也无所谓)作为值赋值给一个变量或者一个元素的某个事件等：`函数表达式`&#125; 123456789;(function(n)&#123;//=&gt;创建函数和执行函数放在一起了，创建。，完成立马执行：·自执行函数·//n形参 n=10&#125;)(10);//=&gt;以下都是自执行函数，符号只是控制语法规范，~function(n)&#123;&#125;(10);-function(n)&#123;&#125;(10);+function(n)&#123;&#125;(10);!function(n)&#123;&#125;(10); 函数的三种角色和call、apply、bind 第一种角色：普通函数栈内存(私有作用域)作用域链形参argumentsreturn 第二种角色：类类实例私有和公有属性prototypeproto 第三种角色：普通对象键值对操作 三种角色之间没有直接的关系 1234567function Fn()&#123;var name='珠峰培训';this.age=8;&#125;Fn.prototype.say=function()&#123;&#125;//原型上的方法Fn.eat=function()&#123;&#125;//普通函数的方法var f = new Fn(); 阿里超经典面试题 123456789101112131415161718function Foo() &#123;getName = function () &#123;console.log(1);&#125;;return this;&#125;Foo.getName = function () &#123;console.log(2);&#125;;Foo.prototype.getName = function () &#123;console.log(3);&#125;;var getName = function () &#123;console.log(4);&#125;;function getName() &#123;console.log(5);&#125; 1234567Foo.getName(); //执行Foo.getName 输出2getName(); // 执行var getName 输出4Foo().getName();//执行function Foo()，（getName是公有属性，相当于给getName重新赋值） 输出1getName(); //由于上一轮的重新赋值，输出1new Foo.getName();//返回Foo.getName()的一个实例，输出2new Foo().getName();//先new Foo()，返回foo的一个实例，在执行实例.getName()，=》3；new new Foo().getName();// 先new Foo()，返回foo的一个实例，再返回this.getName（）的一个实例 ，3； call apply bind都是天生自带的方法(Function.prototype)，所有的函数都可以调取这三个方法 三个方法都是改变THIS指向的 call fn.call(context,para1,…)把fn方法立即执行，并且让fn方法中的this变为context,而para1…都是给fn传递的实参 123456789101112131415161718192021//=&gt;非严格模式function fn(num1,num2)&#123;console.log(this);&#125;var obj=&#123;fn:fn&#125;;fn();//=&gt;this:windowobj.fn();//=&gt;this:objvar opp=&#123;&#125;;//opp.fn();//=&gt;报错:opp中没有fn这个属性fn.call(opp);//=&gt;this:opp num1&amp;&amp;num2都是undefinedfn.call(1,2);//=&gt;this:1 num1=2 num2=undefinedfn.call(opp,1,2);//=&gt;this:opp num1=1 num2=2//-&gt;CALL方法的几个特殊性fn.call();//=&gt;this:window num1&amp;&amp;num2都是undefinedfn.call(null);//=&gt;this:windowfn.call(undefined);//=&gt;this:window//=&gt;JS严格模式下"use strict";fn.call();//=&gt;this:undefinedfn.call(undefined);//=&gt;this:undefinedfn.call(null);//=&gt;this:null apply apply的语法和call基本一致，作用原理也基本一致，唯一的区别：apply把传递给函数的实参以数组形式存放（但是也相当于在给函数一个个的传递实参值） 1fn.call(null,10,20,30); 1fn.apply(null,[10,20,30]); //=&gt;传递给fn的时候也是一个个的传递进去的 bind 也是改变THIS的方法，它在IE6~8下不兼容；它和call(以及apply)改变this的原理不一样 12345678910111213141516fn.call(opp,10,20); //=&gt;把fn执行,让fn中的this变为opp,并且把10&amp;&amp;20分别传递给fnfn.bind(opp,10,20); //=&gt;预先让fn中的this指向opp,并且把10和20预先传递给fn,此时的fn没有被执行(只有当执行的时候this和实参才会起到应有的作用)//=&gt;需求：点击box这个盒子的时候，需要执行fn，并且让fn中的this指向oppoBox.onclick=fn; //=&gt;点击的时候执行了fn,但此时fn中的this是oBoxoBox.onclick=fn.call(opp); //=&gt;绑定事件的时候就已经把fn立即执行了(call本身就是立即执行函数),然后把fn执行的返回值绑定给事件oBox.onclick=fn.bind(opp);//=&gt;fn.bind(opp)：fn调取Function.prototype上的bind方法，执行这个方法返回了一个匿名函数/** function()&#123;* fn.call(opp);* &#125;*/oBox.onclick=function()&#123;//=&gt;this:oBoxfn.call(opp);&#125; 回调函数 凡是在函数执行的某一阶段需要完成某件不确定的事情，可以利用回到函数机制，把要处理的事情当做函数传进来，传进来的这个参数就是回调函数 我们可以在函数中根据需要随时使用回调函数 我们还可以给回调函数传递参数 我们还可以把回调函数中的this进行修改 我们还可以接收回调函数的返回值 回调函数的this指向回调函数中的this一般都是window（严格模式下是undefined）setTimeout&amp;&amp;setInterval默认执行主体都是window，（严格模式下也是同样的） forEach和map当传第二个参数时，会改变this指向，this会指向传递的第二个参数(some.filter,find,every这些方法的第二个参数都是改变this指向的) 我们一般在执行回调函数的时候，没有特意指定执行主体，所以默认一般都是window。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（一）数据类型基本介绍，检测数据类型端方法简介]]></title>
    <url>%2Fposts%2Fd035ffec.html</url>
    <content type="text"><![CDATA[基础知识 ECMAScript(ES)：规定了JS的一些基础核心的知识（变量、数据类型、语法规范、操作语句等）DOM：document object model 文档对象模型，里面提供了一些属性和方法，可以让我们操作页面中的元素BOM：browser object model 浏览器对象模型，里面提供了一些属性和方法，可以让我们操作浏览器 常用浏览器内核浏览器的内核是分为两个部分的，一是渲染引擎，另一个是JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎。 webkit内核（V8引擎） 谷歌 大部分移动端浏览器 国内大部分浏览器 360 QQ UC 猎豹 搜狗 NODE基于V8来渲染JS Gecko 火狐浏览器 Presto 欧朋浏览器 Trident IE浏览器 数据类型的分类和检测 Number String bloean null:空对象指针基础 undefined:未定义 function 函数类型 object对象数据类型: {}普通对象 数组 /$/ 正则 [对象数据类型:是把描述同一事物的属性和方法放在一个内存空间中，起到了分组的作用] 检测数据类型 typeof:检测数据类型的运算符 instanceof:检测某个实例是否属于这个类 constructor:获取当前实例的构造器 Object.prototype.toString.call:获取当前实例所属的类信息 typeof：结果返回的是一个字符串，字符串内包含的是数据类型 typeof 的局限性 typeof null 的检测结果不是‘null’ 而是’object’: 而null是基本数据类型 ，并不是object 使用typeof 无法具体区分出到底是数组还是正则或普通对象 Boolean 把其他类型转换为布尔类型 只有0，NaN,空字符串、null、undefined为false;其余都是true; ! 或者 !!的意义 ! ：先将数据类型转化为布尔值，再取反 !! ：两次取反相当于没有取反，只是把数据类型转化为布尔类型12!null =&gt; true!!undefined =&gt;false Number[NaN] js中新增了一个数据类型：NaN（not a number 不是一个有效数字，但是属于number） typeof NaN =&gt;’number’ NaN!=NaN NaN和任何值都不等 [isNaN] isNaN:用来检测这个值是否是有效数字，如果不是，则为true,反之，则为false 当时使用isNaN检测时，（）中如果不是number类型： 基本数据类型：先将其他类型值转化为Number类型值再运算 对象数据类型：先将对其调用toString方法，再转化为Number类型值 [Number] 使用Number把字符串转换为数字的时候，空字符串是零，其它字符串中如果出现的字符代表纯数字可以转为正常的数字，如果出现了任何一个非有效数字的字符，最后的结果都是NaN 将引用类型转化数据类型时，先将其转化为字符串，后再转化为number; 123(&#123;name:'zxt'&#125;).toString() =&gt;"[object Object]"Number(undefined) =&gt;NaN[parseInt()] 将其他类型值转换number,和Number不同，提取规则：从左至右依次查找有效数字字符，直到遇见非有效字符为止(不管后面还有没数字) 123parseInt(‘12px’) =&gt;12parseInt(‘px1’) =&gt;NaN parseInt(‘122.3’) =&gt;122 [parseFloat()]与parseInt不同的是支持小数 parseFloat(‘12.34pxc’)= 12.34由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心 123450.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996[toFixed()] 控制数字保留小数点后面几位 12345678910var num = parseFloat('width:12.5px'); //=&gt;NaNif(num==12.5)&#123; alert(12.5); &#125;else if(num==NaN)&#123;//=&gt; NaN!=NaN alert(NaN); &#125;else if(typeof num=='number')&#123;//=&gt; typeof NaN-&gt;'number' alert(0);//=&gt;'0' &#125;else&#123; alert('啥也不是!'); &#125; null 和 undefinednull: 没有,没有开辟内存空间undefined: 未定义“” : 空字符串，什么都没有，但是开辟了内存空间 null：什么都没有，但一般都是自己手动赋值的，后期再自己赋值unfefined：完全不在预期之内 Object对象是由0到多组键值对组成的，每一组之间用逗号分离 每一个对象数据类型，都是有0到多组的属性名和属性值组成的属性名：描述当前对象具备的某些特征（数字/字符串格式）属性值：具体特征的值（任何数据类型）操作一个对象的属性有2种方式obj[‘key’]obj.key(属性名是数字不可以使用这种方法) 创建对象 字面量方式：var obj={}构造函数方式：var obj=new Object(); 对象键值对的操作：增、删、改、查 var obj = {};obj.name = ‘zxt’;//=&gt;增加一个叫做NAME的属性,属性值是:’zxt’obj[‘name’] = 29;//=&gt;修改NAME对应的属性值：一个对象的属性名是不能重复的，之前没有这个属性，我们的操作是增加操作，之前有这个属性，当前操作就是在修改现有属性名的属性值obj.age = null; //=&gt;假删除：把属性值设置为空，但是属性名是存在的 &lt;=&gt; obj[‘age’] = null =&gt;获取age的属性值结果是nulldelete obj.age;//=&gt;真删除：把属性名和属性值彻底从对象中移除掉 =&gt;获取age的属性值结果是undefined获取一个对象某一个属性名对应的属性值，如果当前这个属性在对象中并不存在，获取的结果是undefined obj[name]和obj[‘name’]的区别 //-&gt; age：变量名，代表的是它存储的值//-&gt; ‘age’：常量，字符串的具体值var age = ‘name’;var obj = {name:’zhufeng’,age:8};console.log(obj.age); =&gt;8console.log(obj[‘age’]); =&gt;8console.log(obj[age]); =&gt; obj[age变量] =&gt;obj[‘name’] =&gt;获取name属性名的属性值 =&gt;’zhufeng’ Object.keys: Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的对象上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。可以用来判断对象是否为空：Object.keys(obj).length let obj = { 0 : “a”, 1 : “b”, 2 : “c”};console.log(Object.keys(obj));// [‘0’, ‘1’, ‘2’] 函数数据类型 函数数据类型也是按照引用地址来操作的 函数：具备一定功能的方法 基本数据类型和引用数据类型的区别 JS是运行在浏览器中的（内核引擎），浏览器会给JS提供一个赖以生存的环境，所以我们把这个环境叫做全局作用域 window(global是后台的) JS代码是自上而下依次执行的 基本数据类型是按值操作的：基本数据类型再赋值时，是直接把值赋值给变量即可 var a=12;var b=a; // b=12 把变量a存的值赋值给变量bb=13;alert(a); //a=12 引用数据类型是按空间地址（引用地址）来操作的： var n={name:’主动’}；1、先创建一个变量n;2.浏览器首先会开辟一个存储空间（内存空间），是把对象中需要存储的键值对分别存储在这个空间中，后期为了方便找到这个空间，浏览器会给空间设个地址（16进制）；3、把空间的地址赋值给变量;所以n存储的是一个引用地址，并不是一个具体的值 &amp;&amp;逻辑与||逻辑或 在条件判断中&amp;&amp;：所有都为真，才是真||：只要一个为真，就是真 在赋值操作中 (短路操作)||: a||b;看a的真假，a为真，则返回a的值，a为假，则返回b,不管b是什么&amp;&amp;：a&amp;&amp;b, a为假，则返回a的值，a为真，则返回b,不管b是什么真实项目中应用逻辑或实现默认值的设置操作 逻辑与的优先权高于逻辑或 JavaScript常用的操作语句 通过一系列的逻辑判断，来完成特定的事情for循环if循环:当在判断的操作中,很多条件都是符合的,执行完成第一个符合的条件后,后面的条件不管是否符合都不在处理了 for in 循环用来遍历（循环）对象键值对的, ‘循环数组中的每一项’, ‘条件？条件成立执行：条件不成执行；, 执行步骤： key存储的值都是字符串格式，key中存的是属性名在for in 循环遍历时，大部分浏览器都是先把对象中的键值对进行排序（整数数字在前，由小到大，其余按原来编写顺序排列）（小数算作字母，不算数字）for in循环会遍历对象原型上的方法itin [Tab] for in 循环快捷键 三元运算符 [‘条件？条件成立执行：条件不成执行；]是简单的if、else的另外一种写法如果某种情况并不需要做处理，我们可以用null,undefined,void 0占位即可某一情况执行多条操作，使用（）包起来，每一项处理的事情之间用逗号分隔在三元运算符中不能出现 break/continue/return会出现 SyntaxErrorr 语法错误 switch case 也是if else某种特定情况的简写，可以在switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。每一种case情况结束都需要加break，达到条件成立处理完成，跳出当前判断每一种case情况的比较都是使用===进行比较的：绝对相等 =：赋值，变量=值==：比较，值==值绝对比较，值=== 如果左右两边比较的值是相同类型的，那么直接比较内容是否一样即可；如果两边值的类型不一样，==和===是有区别的：===类型不一样，最后的结果就是false，更加的严谨==类型不一样，浏览器首先会默认的把类型转化为一样的，然后再比较内容，相对松散一些 for循环语句for(初始值;验证条件;步长累加){ 循环体} 设置初始值验证条件条件成立执行循环体，否则推出循环步长累加验证条件···············没有步长累加会陷入死循环 for循环与for in循环的区别：for in 循环可以遍历到原型上的公有属性，而for循环只能遍历私有的属性]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份非常完整的MySQL规范]]></title>
    <url>%2Fposts%2Ff4255724.html</url>
    <content type="text"><![CDATA[一、数据库命令规范 二、数据库基本设计规范 三、数据库字段设计规范 四、索引设计规范 五、常见索引列建议 六、如何选择索引列的顺序 七、避免建立冗余索引和重复索引 八、优先考虑覆盖索引 九、索引SET规范 十、数据库SQL开发规范 十一、数据库操作行为规范 一、数据库命令规范· 所有数据库对象名称必须使用小写字母并用下划线分割 · 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） · 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符 · 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀 · 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低） 二、数据库基本设计规范1、所有表必须使用Innodb存储引擎 没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好 2、数据库和表的字符集统一使用UTF8 兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效 3、所有表和字段都需要添加注释 使用comment从句添加表和列的备注 从一开始就进行数据字典的维护 4、尽量控制单表数据量的大小，建议控制在500万以内 500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小 5、谨慎使用MySQL分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据 6、尽量做到冷热数据分离，减小表的宽度 MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作） 7、禁止在表中建立预留字段 预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定 8、禁止在数据库中存储图片，文件等大的二进制数据 通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息 9、禁止在线上做数据库压力测试 10、禁止从开发环境，测试环境直接连接生成环境数据库 三、数据库字段设计规范1、优先选择符合存储需要的最小的数据类型 · 原因 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差 · 方法 1）将字符串转换成数字类型存储，如：将IP地址转换成整形数据。 mysql提供了两个方法来处理ip地址： 12inet_aton // 把ip转为无符号整型(4-8位)inet_ntoa // 把整型的ip转为地址 插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。 2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储 因为：无符号相对于有符号可以多出一倍的存储空间 12SIGNED INT -2147483648~2147483647UNSIGNED INT 0~4294967295 VARCHAR(N)中的N代表的是字符数，而不是字节数 使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存 2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据 · 建议把BLOB或是TEXT列分离到单独的扩展表中 Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。 而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。 如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。 · TEXT或BLOB类型只能使用前缀索引 因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。 3、避免使用ENUM类型 · 修改ENUM值需要使用ALTER语句 · ENUM类型的ORDER BY操作效率低，需要额外操作 · 禁止使用数值作为ENUM的枚举值 4、尽可能把所有列定义为NOT NULL 原因： · 索引NULL列需要额外的空间来保存，所以要占用更多的空间； · 进行比较和计算时要对NULL值做特别的处理 5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。 TIMESTAMP 占用4字节和INT相同，但比INT可读性高 超出TIMESTAMP取值范围的使用DATETIME类型存储。 经常会有人用字符串存储日期型的数据（不正确的做法）： · 缺点1：无法用日期函数进行计算和比较 · 缺点2：用字符串存储日期要占用更多的空间 6、同财务相关的金额类数据必须使用decimal类型 · 非精准浮点：float,double · 精准浮点：decimal Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。 四、索引设计规范1、限制每张表上的索引数量，建议单张表索引不超过5个 索引并不是越多越好！索引可以提高效率同样可以降低效率。 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。 因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。 2、禁止给表中的每一列都建立单独的索引 5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好 3、每个Innodb表必须有个主键 Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。 每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。 主键建议使用自增ID值。 五、常见索引列建议· 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列 · 包含在ORDER BY、GROUP BY、DISTINCT中的字段 并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好 · 多表join的关联列 六、如何选择索引列的顺序建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 · 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）； · 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）； · 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。 七、避免建立冗余索引和重复索引因为这样会增加查询优化器生成执行计划的时间。 · 重复索引示例：primary key(id)、index(id)、unique index(id) · 冗余索引示例：index(a,b,c)、index(a,b)、index(a) 八、优先考虑覆盖索引对于频繁的查询优先考虑使用覆盖索引。 覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引 覆盖索引的好处： · 避免Innodb表进行索引的二次查询 Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息， 如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。 · 可以把随机IO变成顺序IO加快查询效率 由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。 九、索引SET规范尽量避免使用外键约束 · 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引； · 外键可用于保证数据的参照完整性，但建议在业务端实现； · 外键会影响父表和子表的写操作从而降低性能。 十、数据库SQL开发规范1、建议使用预编译语句进行数据库操作 预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。 2、避免数据类型的隐式转换 隐式转换会导致索引失效。如：select name,phone from customer where id = ‘111’; 3、充分利用表上已经存在的索引 · 避免使用双%号的查询条件。 如a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的） · 一个SQL只能利用到复合索引中的一列进行范围查询 如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。 使用left join或 not exists来优化not in操作 因为not in 也通常会使用索引失效。 4、数据库设计时，应该要对以后扩展进行考虑 5、程序连接不同的数据库使用不同的账号，进制跨库查询 · 为数据库迁移和分库分表留出余地 · 降低业务耦合度 · 避免权限过大而产生的安全风险 6、禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询 原因： · 消耗更多的CPU和IO以网络带宽资源 · 无法使用覆盖索引 · 可减少表结构变更带来的影响 7、禁止使用不含字段列表的INSERT语句 如：insert into values (‘a’,’b’,’c’); 应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’); 8、避免使用子查询，可以把子查询优化为join操作 通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。 子查询性能差的原因： · 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响； · 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大； · 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。 9、避免使用JOIN关联太多的表 对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。 在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。 如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。 10、减少同数据库的交互次数 数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 11、对应同一列进行or判断时，使用in代替or in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。 12、禁止使用order by rand() 进行随机排序 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式 13、WHERE从句中禁止对列进行函数转换和计算 对列进行函数转换或计算时会导致无法使用索引。 · 不推荐： 1where date(create_time)=&apos;20190101&apos; · 推荐： 1where create_time &gt;=&apos;20190101&apos; and create_time &lt;=&apos;20190102&apos; 14、在明显不会有重复值时使用UNION ALL而不是UNION · UNION会把两个结果集的所有数据放到临时表中后再进行去重操作 · UNION ALL不会再对结果集进行去重操作 15、拆分复杂的大SQL为多个小SQL · 大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL · MySQL：一个SQL只能使用一个CPU进行计算 · SQL拆分后可以通过并行执行来提高处理效率 十一、数据库操作行为规范1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作 · 大批量操作可能会造成严重的主从延迟 主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况 · binlog日志为row格式时会产生大量的日志 大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。 · 避免产生大事务操作 大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。 特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。 2、对于大表使用pt-online-schema-change修改表结构 · 避免大表修改产生的主从延迟 · 避免在对表字段进行修改时进行锁表 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。 pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。 把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。 把原来一个DDL操作，分解成多个小的批次进行。 3、禁止为程序使用的账号赋予super权限 当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。 4、对于程序连接数据库账号，遵循权限最小原则 程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀的程序员需要懂那些数学知识？]]></title>
    <url>%2Fposts%2Fdd6f5090.html</url>
    <content type="text"><![CDATA[安利一本书，专门讲程序员需要懂的数学。 一位科技博主Jeremy Kun花了4年时间，写成一本书《程序员数学入门》，在科技论坛Hack News引发热议。 这本书精简了大量数学内容，为程序员提供所需的基本数学知识。 书中主要内容有：多项式、集合、图论、微积分、线性代数、群论等。 好玩的不止这些，这位博主在个人网站中整理了很多数学知识，甚至做成了wiki的形式： https://jeremykun.com/primers/ 里面基本是程序员的大学数学课程内容：虽然没有高等数学（微积分），但是有抽象代数、离散数学、傅立叶分析、拓扑学等等。 这个网站叫做“站在数学和编程的十字路口”（Math ∩ Programming），所以当然不会只有数学课，还包括机器学习、图像生成、自然语言处理、加密学等计算机学方面的内容。 链接：https://www.zhihu.com/question/21425201/answer/615681300]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着9张思维导图学习Javascript]]></title>
    <url>%2Fposts%2Fd64e1f56.html</url>
    <content type="text"><![CDATA[学习的道路就是要不断的总结归纳，好记性不如烂笔头，so，下面将 po 出我收集的 9 张 javascript 相关的思维导图（非原创）。 JavaScript-Learn-MindMapping 思维导图小tips:思维导图又叫心智图，是表达发射性思维的有效的图形思维工具 ，它简单却又极其有效，是一种革命性的思维工具。思维导图运用图文并重的技巧，把各级主题的关系用相互隶属与相关的层级图表现出来，把主题关键词与图像、颜色等建立记忆链接，思维导图充分运用左右脑的机能，利用记忆、阅读、思维的规律，协助人们在科学与艺术、逻辑与想象之间平衡发展，从而开启人类大脑的无限潜能。思维导图因此具有人类思维的强大功能。 分别归类为： javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 文档对象模型DOM javascript正则表达式 能够认真看完就是一次对javascript的回顾与提升，可以很好的检验基础。 javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 文档对象模型DOM BOM浏览器对象模型 javascript正则表达式 是的，没有高深的知识，没有进阶的技巧。 只是，万丈高楼平地起；只是，千里之行始于足下；只是，千里长提溃于蚁穴。 能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享几个优质开源项目 | 电商类app，趣享 gif，研发助手DoraemonKit，github小程序]]></title>
    <url>%2Fposts%2Ff4e97b38.html</url>
    <content type="text"><![CDATA[非常方便的 github 小程序员 趣享 gif 开源版本 酷欧天气的Jetpack版本实现，采用了MVVM架构 充满设计感的电商类APP 滴滴开源的研发助手 非常方便的 github 小程序员经常想在手机上看一些最新的github项目，可以说这是我发现的最方便的小程序了。 GitHub Trending 是根据仓库的最近热门程度展示的，该小程序希望准确获取最近新出现的仓库集合，使用该小程序能够根据语言筛选，获取每天新出现的 Trending 仓库。 开源地址：https://github.com/ZhuPeng/mp-githubtrending 这个小程序已经上线了，可以扫码体验，相信会对你有帮助的 趣享 gif 开源版本这个相信就是老郭对外的开源版本了，相信不少同学早已体验过了，没有的话，可以在各大市场搜索“趣享 gif”体验一下，开源版本也是个非常棒的学习项目。 https://github.com/guolindev/giffun 老郭的MVVM项目酷欧天气的Jetpack版本实现，采用了MVVM架构。 功能比较少，不过老郭写代码一向非常注重代码风格，相信是一个非常值得学习的项目。项目使用语言是kotlin，应该也是为第一行代码第三版做准备。 分享个有意思的事情，之前我和老郭吹逼，我说去 github 搜索 wanandroid有几百个开源版本，一脸自豪… 然后老郭上了个，搜索“cool weather”的截图： 项目架构： https://github.com/guolindev/coolweatherjetpack* 充满设计感的电商类APP 项目涉及的技术要点：1. 组件化+Kotlin结合开发，如何管理第三方依赖 2. BaseActivity和BaseFragment等基类及通用布局的封装 3. MVP+Dagger 2+Retrofit+Rxjava（包括了多个BaseUrl请求的场景处理） 4. 组件化开发下ARouter的运用 5. EventBus的使用 6. Google原生数据库Room的使用 7. Glide的使用（封装加载图片工具类GlideUtils，圆形、圆角图片、背景图片加载等） 8. Kotlin下使用ButterKnife 9. CommonAdapter万能适配器（包括多类型布局的运用—首页的逛模块和视频分类详情都有运用） 10. GSYVideoPlayer实现视频播放（包括全屏切换功能） 11. 5.0新特性CoordinatorLayout +AppBarLayout效果实现（视频分类详情） 12. 沉浸式状态栏（Activity和在Fragment中的使用及不同手机的适配） 13. DataBinding的使用 14. 约束布局ConstraintLayout的使用这是一个来自投稿的项目，我也跑了一下，还有些问题，不过适合用于学习。 https://www.jianshu.com/p/12c09376fa97 https://github.com/GraceJoJo/Designer 研发助手滴滴开源的研发助手。 简称 “DoKit” 。一款功能齐全的客户端（ iOS 、Android ）研发助手，你值得拥有。 https://github.com/didi/DoraemonKit* 开源组件DoraemonKit之Android版本技术实现（一） https://juejin.im/post/5c4dcfe8518825261e1f2978 大家手机上或多或少有一些对学习有用的app，小程序吧？留言分享一下吧！]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>骨架屏</tag>
        <tag>加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github上10个开源免费且优秀的后台控制面板]]></title>
    <url>%2Fposts%2Fa81c9ec4.html</url>
    <content type="text"><![CDATA[Web 开发中几乎的平台都需要一个后台管理，但是从零开发一套后台控制面板并不容易，幸运的是有很多开源免费的后台控制面板可以给开发者使用，那么有哪些优秀的开源免费的控制面板呢？我在 Github 上收集了一些优秀的后台控制面板，并总结得出 Top 10。 AdminLTE vue-Element-Admin tabler Gentelella ng2-admin ant-design-pro blur-admin vue-admin iview-admin material-dashboard AdminLTEGithub Star 数 24969 ， Github 地址：https://github.com/almasaeed2010/AdminLTE。 非常流行的基于 Bootstrap 3.x 的免费的后台 UI 框架。 vue-Element-AdminGithub Star 数 19546， Github 地址： https://github.com/PanJiaChen/vue-element-admin。 一个基于 vue2.0 和 Eelement 的控制面板 UI 框架。 tablerGithub Star 数 15870， Github 地址：https://github.com/tabler/tabler。 构建在 BootStrap 4 之上的免费的 HTML 控制面板框架 GentelellaGithub Star 数 15654， Github 地址：https://github.com/puikinsh/gentelella。 一个基于 Bootstarp 的免费的后台控制面板。 ng2-adminGithub Star 数 13181， Github 地址：https://github.com/akveo/ngx-admin。 基于 Angular 2, Bootstrap 4 和 Webpack 的后台管理面板框架。 ant-design-proGithub Star 数 12707，Github 地址：https://github.com/ant-design/ant-design-pro。 开箱即用的中台前端/设计解决方案 blur-adminGithub Star 数 9241，Github 地址：https://github.com/akveo/blur-admin。 基于 Angular 和 Bootstrap 的后台管理面板框架。 vue-adminGithub Star 数 8676，Github 地址：https://github.com/vue-bulma/vue-admin。 基于 Vue 和 Bulma 的控制面板。 iview-adminGithub Star 数 8668，Github 地址：https://github.com/iview/iview-admin。 基于 iView 的 Vue 2.0 控制面板。 material-dashboardGithub Star 数 7111，Github 地址：https://github.com/creativetimofficial/material-dashboard。 基于 Bootstrap 4 和 Material 风格的控制面板。]]></content>
      <categories>
        <category>Java</category>
        <category>开源</category>
      </categories>
      <tags>
        <tag>后台控制面板</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些架构设计原则]]></title>
    <url>%2Fposts%2F5125d3e0.html</url>
    <content type="text"><![CDATA[《Clean Architecture》一书中对于软件架构目的的解释： The goal of software architecture is to miminize the human resources required to build and maintain the required system. 即：软件架构的目的就是将构建和维护系统需要的人力成本降到最低。 因此，可以得出架构设计的关键思维就是判断和取舍（程序设计的关键思维是逻辑和实现），即如何选择技术、组合技术使得需要的人力资源最少。 需要注意的一点是，脱离业务谈架构是不合理的，技术架构及其演进都是业务目标驱动的。 架构原则 避免过度设计：简单的架构就是最好的架构。最简单的方案最容易实现和维护，也可以避免浪费资源。但方案中需要包括扩展。 冗余设计：对服务、数据库的做结点冗余，保证服务的高可用。通过数据库主从模式、应用集群来实现。 多活数据中心：为了容灾，从根本上保障应用的高可用性。需要构建多活的数据中心，以防止一个数据中心由于不可控因素出现故障后，引起整个系统的不可用。 无状态设计：API、接口等的设计不能有前后依赖关系，一个资源不受其他资源改动的影响。无状态的系统才能更好地进行扩展。如果非得有状态，则要么客户端管理状态，要么服务端用分布式缓存管理状态。 可回滚：对于任何业务尤其是关键业务，都具有恢复机制。可以使用基于日志的WAL、基于事件的Event sourcing等来实现可回滚。 可禁用/自我保护：具有限流机制，当上游的流量超过自身的负载能力时，能够拒绝溢出的请求。可以通过手动开关或者自动开关（监测异常流量行为），在应用前端挡住流量。限流算法包括：令牌桶（支持突发流量）、漏桶（匀速流量）、计数器以及信号量（限制并发访问的数量）。此外永远不要信赖第三方服务的可靠性，依赖于第三方的功能务必有服务降级措施以及熔断管理，如：对于每一个网络操作，都需要设置超时时间，超过这个时间就放弃或者返回兜底响应。 问题可追踪：当系统出现问题时，能够定位请求的轨迹、每一步的请求信息等。分布式链路追踪系统即解决的此方面的问题。 可监控：可监控是保障系统能够稳定运行的关键。包括对业务逻辑的监控、应用进程的监控以及应用依赖的CPU、硬盘等系统资源的监控。每一个系统都需要做好这几个层面的监控。 故障隔离：将系统依赖的资源(线程、CPU)和服务隔离开来能够使得某个服务的故障不会影响其他服务的调用。通过线程池或者分散部署结点可以对故障进行隔离。此外，为不同的用户提供单独的访问通道，不仅仅能够做故障隔离，也有利于做用户权限控制。 成熟可控的技术选型：使用市面上主流、成熟、文档、支持资源多的技术，选择合适的而非最火的技术实现系统。如果面对自研和开源技术的选择，需要考虑契合度：如果功能需求契合度很高，那么选择开源即可；如果开源技术是需求的子集或者超集，那么要衡量吃透这个开源技术的成本和自研的成本那个高。 梯级存储：内存-&gt;SSD硬盘-&gt;传统硬盘-&gt;磁带，可以根据数据的重要性和生命周期对数据进行分级存储。 缓存设计：隔离请求与后端逻辑、存储，是就近原则的一种机制。包括客户端缓存（预先下发资源）、Nginx缓存、本地缓存以及分布式缓存。 异步设计：对于调用方不关注结果或者允许结果延时返回的接口，采用队列进行异步响应能够很大程度提高系统性能；调用其他服务的时候不去等待服务方返回结果直接返回，同样能够提升系统响应性能。异步队列也是解决分布式事务的常用手段。 前瞻性设计：根据行业经验和对业务量的预判，提前把可扩展性、后向兼容性、容量预警设计好。以防止超过系统容量后造成各种问题影响服务。 水平扩展：相比起垂直扩展，能够通过堆机器解决问题是最优先考虑的问题，系统的负载能力也才能接近无限扩展。此外，基于云计算技术根据系统的负载自动调整容量能够在节省成本的同时保证服务的可用性。 小步构建和发布：快速迭代项目，快速试错。不能有跨度时间过长的项目规划。 自动化：打包、测试的自动化称为持续集成，部署的自动化称为持续部署。自动化机制是快速迭代和试错的基础保证。 架构六步思考法 笔者对美团总架构师夏华夏一次分享提出的架构六步思考法的理解。 这里尤其需要注意的一点是在面对问题时，首先要试图将未知问题转化为已知问题，而不是创造新问题。 数据设计原则 注意存储效率 减少事务 减少联表查询 适当使用索引 考虑使用缓存 避免依赖于数据库的运算功能(函数、存储器、触发器等)，将负载放在更容易扩展的业务应用端 数据统计场景中，实时性要求较高的数据统计可以用Redis；非实时数据则可以使用单独表，通过队列异步运算或者定时计算更新数据。此外，对于一致性要求较高的统计数据，需要依靠事务或者定时校对机制保证准确性。 索引区分度法则：辨识度超过20%的属性，如果有查询需求，就应该建立索引。 对于数值型数据，可以使用保序压缩方式在保证顺序不变的前提下减少字符串长度。如：进行36进制转化即一种保序压缩方式。 大量数据的去重计数如果允许误差可以选择基数估计算法（Hyperhyperlog、Loglogcount）或者布隆过滤器。 系统响应性能提升五板斧 异步：队列缓冲、异步请求。 并发：利用多CPU多线程执行业务逻辑。 就近原则：缓存、梯度存储。 减少IO：合并细粒度接口为粗粒度接口、频繁的覆盖操作可以只做最后一次操作。这里一个需要特别注意的地方: 代码中尽量避免在循环中调用外部服务，更好的做法是使用粗粒度批量接口在循环外面只进行一次请求。 分区：频繁访问的数据集规模保持在合理的范围。 系统容量规划需要对系统/关键模块做好评估、量化，以防止超出容量时不至于压垮服务器，仍然能够服务于大部分用户。 根据流量模型、历史数据、预测算法预估未来某一个时间点的业务量：QPS、每日数据量等。 评估单点最大承载量（数据库的单点承载数据量、应用服务器的单点承载并发量）【通过性能测试】，根据业务量计算需要部署的结点数目，做1.5倍部署（DID原则）。 性能压测验证整个系统的负载能力。 设计达到容量预估值时的预警、限流、快速恢复措施以及后续扩展方案。 PS: 在容量预估中，机器数目的计算遵循DID原则：20倍设计、3倍实施/实现、1.5倍部署。即需要部署1.5倍的可承载预估业务流量的机器数目。 架构重构的原则一个系统的架构是随着业务而不断演化的，因此不可避免地会留下很多技术债。如果一味地不去管，那么总有一天技术债会爆发出来造成意想不到的破坏。因此很多时候对架构的重构是必须的。其需要遵循的原则如下： 确定重构的目的和必要性：为了业务需要；有无其他备选方案 定义“重构完成”的界限 渐进式重构 确定当前的架构状态 不要忽略数据 管理好技术债务 远离那些虚荣的东西 做好面对压力的准备 了解业务 做好面对非技术因素的准备 能够掌握代码质量 其他 系统扩展思路 通过克隆扩展-&gt;高可用 通过拆分不同的东西来扩展-&gt;垂直扩展 拆分类似的东西来扩展-&gt;水平扩展 讨论技术方案时，以是否合理为依据，而不要以工作量少为依据。]]></content>
      <categories>
        <category>Java</category>
        <category>架构设计与原则</category>
      </categories>
      <tags>
        <tag>架构设计与原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈架构的概念、架构的形式、架构设计原则]]></title>
    <url>%2Fposts%2Fba1b4470.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>架构设计与原则</category>
      </categories>
      <tags>
        <tag>架构设计与原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序原生高颜值组件库--ColorUI组件库]]></title>
    <url>%2Fposts%2F71ce4a1f.html</url>
    <content type="text"><![CDATA[简介ColorUI是一个Css类的UI组件库！不是一个Js框架。相比于同类小程序组件库，ColorUI更注重于视觉交互！ 浏览GitHub：https://github.com/weilanwl/ColorUI 如何使用？先下载源码包→ Github 引入到我的小程序将 /demo/ 下的 colorui.wxss 和 icon.wxss 复制到小程序的根目录下 在 app.wxss 引入两个文件 12@import "icon.wxss";@import "colorui.wxss"; 使用模板全新开发复制 /template/ 文件夹并重命名为你的项目，微信开发者工具导入为小程序就可以使用ColorUI了 体验沉浸式导航 App.js 获取系统参数并写入全局参数。 12345678910111213//App.jsApp(&#123; onLaunch: function() &#123; wx.getSystemInfo(&#123; success: e =&gt; &#123; this.globalData.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); this.globalData.Custom = custom; this.globalData.CustomBar = custom.bottom + custom.top - e.statusBarHeight; &#125; &#125;) &#125;&#125;) Page.js 页面配置获取全局参数。 123456789//Page.jsconst app = getApp()Page(&#123; data: &#123; StatusBar: app.globalData.StatusBar, CustomBar: app.globalData.CustomBar, Custom: app.globalData.Custom &#125; &#125;) Page.wxml 页面构造导航。更多导航样式请下载Demo查阅 操作条组件。 123456789&lt;view class="cu-custom" style="height:&#123;&#123;CustomBar&#125;&#125;px;"&gt; &lt;view class="cu-bar fixed bg-gradual-pink" style="height:&#123;&#123;CustomBar&#125;&#125;px;padding-top:&#123;&#123;StatusBar&#125;&#125;px;"&gt; &lt;navigator class='action border-custom' open-type="navigateBack" delta="1" hover-class="none" style='width:&#123;&#123;Custom.width&#125;&#125;px;height:&#123;&#123;Custom.height&#125;&#125;px;margin-left:calc(750rpx - &#123;&#123;Custom.right&#125;&#125;px)'&gt; &lt;text class='icon-back'&gt;&lt;/text&gt; &lt;text class='icon-homefill'&gt;&lt;/text&gt; &lt;/navigator&gt; &lt;view class='content' style='top:&#123;&#123;StatusBar&#125;&#125;px;'&gt;操作条&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 自定义系统Tabbar 按照官方 自定义 tabBar 配置好Tabbar (开发工具和版本库请使用最新版)。 使用ColorUI配置Tabbar只需要更改 Wxml 页的内容即可。 更多Tabbar样式请下载Demo查阅 操作条组件。 /custom-tab-bar/index.wxml 12345678 &lt;view class="cu-bar tabbar bg-white shadow"&gt; &lt;view class="action" wx:for="&#123;&#123;list&#125;&#125;" wx:key="index" data-path="&#123;&#123;item.pagePath&#125;&#125;" data-index="&#123;&#123;index&#125;&#125;" bindtap="switchTab"&gt; &lt;view class='icon-cu-image'&gt; &lt;image src='&#123;&#123;selected === index ? item.selectedIconPath : item.iconPath&#125;&#125;' class='&#123;&#123;selected === index ? "animation" : "animation"&#125;&#125;'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='&#123;&#123;selected === index ? "text-green" : "text-gray"&#125;&#125;'&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 作者叨叨ColorUI是一个高度自定义的Css样式库，包含了开发常用的元素和组件，元素组件之间也能相互嵌套使用。我也会不定期更新一些扩展到源码。 感谢阅读。 转自链接：https://juejin.im/post/5c773b746fb9a049f43bff0f]]></content>
      <categories>
        <category>前端</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ColorUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager要被废弃？官方ViewPager2升级版来临]]></title>
    <url>%2Fposts%2Fabf696ca.html</url>
    <content type="text"><![CDATA[从文档注释来看ViewPager2确实是用来替代ViewPager 的，顺带解决之前ViewPager的一些问题，并且加入了 RTL,竖向滚动支持，下面一起来详细看下吧。 ViewPager2 replaces ViewPager, addressing most of its predecessor’s pain-points, including right-to-left layout support, vertical orientation, modifiable Fragment collections, etc. 概述这两天浏览安卓开发者官网的时候，发现google悄然推出了一个新的控件：ViewPager2，一看名称就知道这是一个和我们常用的ViewPager功能相似的控件，算是ViewPager的升级版吧。目前还只是推出了第一个预览版，我们可以直接引入来使用了： 1implementation &apos;androidx.viewpager2:viewpager2:1.0.0-alpha01&apos; https://developer.android.google.cn/reference/androidx/viewpager2/widget/ViewPager2 我们先来看看有哪些功能和使用上的变化： 新功能： 支持RTL布局 支持竖向滚动 完整支持notifyDataSetChanged API的变动： FragmentStateAdapter替换了原来的 FragmentStatePagerAdapter RecyclerView.Adapter替换了原来的 PagerAdapter registerOnPageChangeCallback替换了原来的 addPageChangeListener 看了上面这些介绍，有一点比较吸引人的就是支持竖向滚动了，这是怎么实现的呢？ViewPager2的源码不长，我们来简单分析一下。 简单解析通过查看源码得知，ViewPager2是直接继承ViewGroup的，意味着和ViewPager不兼容，类注释上也写了它的作用是取代ViewPager，不过短时间内ViewPager应该还不会被废弃掉。 继续查看源码，发现了两个比较重要的成员变量： 12private RecyclerView mRecyclerView;private LinearLayoutManager mLayoutManager; 所以很清楚得知，ViewPager2的核心实现就是RecyclerView+LinearLayoutManager了，因为LinearLayoutManager本身就支持竖向和横向两种布局方式，所以ViewPager2也能很容易地支持这两种滚动方向了，而几乎不需要添加任何多余的代码。 其实在此之前也不乏有大神采用RecyclerView来实现轮播图效果的，具体实现发生略有不同，但大体思想是一致的。这次ViewPager2的推出意味着这种方法终于被扶正了。 为了让RecyclerView变得像原来的ViewPager，需要设置下SnapHelper： 1new PagerSnapHelper().attachToRecyclerView(mRecyclerView); 熟悉RecyclerView的同学都知道，SnapHelper用于辅助RecyclerView在滚动结束时将Item对齐到某个位置。PagerSnapHelper的作用让滑动结束时使当前Item居中显示，并且 限制一次只能滑动一页，不能快速滑动，这样就和viewpager的交互很像了。 另外和viewpager一样，viewpager2可以承载fragment，我们需要继承实现它提供的FragmentStateAdapter： 12public abstract class FragmentStateAdapter extends RecyclerView.Adapter&lt;FragmentViewHolder&gt; implements StatefulAdapter 这是一个包含FragmentManager和数据状态恢复功能的RecyclerView.Adapter，具体实现可以参看源码。所以大家也可以用TabLayout+ViewPager2+Fragment来实现联动展示效果。 使用通过android:orientation来指定滚动方向 12345&lt;androidx.viewpager2.widget.ViewPager2 android:id="@+id/viewpager2" android:layout_width="match_parent" android:layout_height="200dp" android:orientation="vertical" /&gt; 在代码中设置一个普通的RecyclerView.adapter： 123ViewPager2 viewPager2=findViewById(R.id.viewpager2);RecyclerviewAdapter adapter = new RecyclerviewAdapter(this);viewPager2.setAdapter(adapter); 这样竖直轮播图就大功告成了。 小结viewpager2利用recyclerview来实现viewpager的功能，无疑使使其可扩展性大大提升，代码也变得更优雅简洁，使用起来也更灵活。不过目前viewpager2只是第一个预览版，还存在稳定性方面的问题，不建议大家引入到正式项目中来，尝尝鲜就好。 PS：如果有谁愿意深入解析，示例对比演示等，欢迎火速联系我，投稿分享给大家。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 函数式编程和 lambda 表达式]]></title>
    <url>%2Fposts%2F81a39ed5.html</url>
    <content type="text"><![CDATA[为什么要使用函数式编程函数式编程更多时候是一种编程的思维方式，是种方法论。函数式与命令式编程的区别主要在于：函数式编程是告诉代码你要做什么，而命令式编程则是告诉代码要怎么做。说白了，函数式编程是基于某种语法或调用API去进行编程。例如，我们现在需要从一组数字中，找出最小的那个数字，若使用用命令式编程实现这个需求的话，那么所编写的代码如下： 1234567891011public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;; int min = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &lt; min) &#123; min = num; &#125; &#125; System.out.println(min);&#125; 而使用函数式编程进行实现的话，所编写的代码如下： 123456public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;; int min = IntStream.of(nums).min().getAsInt(); System.out.println(min);&#125; 从以上的两个例子中，可以看出，命令式编程需要自己去实现具体的逻辑细节。而函数式编程则是调用API完成需求的实现，将原本命令式的代码写成一系列嵌套的函数调用，在函数式编程下显得代码更简洁、易懂，这就是为什么要使用函数式编程的原因之一。所以才说函数式编程是告诉代码你要做什么，而命令式编程则是告诉代码要怎么做，是一种思维的转变。 说到函数式编程就不得不提一下lambda表达式，它是函数式编程的基础。在Java还不支持lambda表达式时，我们需要创建一个线程的话，需要编写如下代码： 12345678public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("running"); &#125; &#125;).start();&#125; 而使用lambda表达式一句代码就能完成线程的创建，lambda强调了函数的输入输出，隐藏了过程的细节，并且可以接受函数当作输入（参数）和输出（返回值）： 123public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println("running")).start();&#125; 注：箭头的左边是输入，右边则是输出 该lambda表达式的作用其实就是返回了Runnable接口的实现对象，这与我们调用某个方法获取实例对象类似，只不过是将实现代码直接写在了lambda表达式里。我们可以做个简单的对比： 1234public static void main(String[] args) &#123; Runnable runnable1 = () -&gt; System.out.println("running"); Runnable runnable2 = RunnableFactory.getInstance();&#125; JDK8接口新特性1.函数接口，接口只能有一个需要实现的方法，可以使用@FunctionalInterface 注解进行声明。如下： 1234@FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i);&#125; 使用lambda表达式获取该接口的实现实例的几种写法： 1234567891011121314public static void main(String[] args) &#123; // 最常见的写法 Interface1 i1 = (i) -&gt; i * 2; Interface1 i2 = i -&gt; i * 2; // 可以指定参数类型 Interface1 i3 = (int i) -&gt; i * 2; // 若有多行代码可以这么写 Interface1 i4 = (int i) -&gt; &#123; System.out.println(i); return i * 2; &#125;;&#125; 2.比较重要的一个接口特性是接口的默认方法，用于提供默认实现。默认方法和普通实现类的方法一样，可以使用this等关键字： 12345678@FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125; 之所以说默认方法这个特性比较重要，是因为我们借助这个特性可以在以前所编写的一些接口上提供默认实现，并且不会影响任何的实现类以及既有的代码。例如我们最熟悉的List接口，在JDK1.2以来List接口就没有改动过任何代码，到了1.8之后才使用这个新特性增加了一些默认实现。这是因为如果没有默认方法的特性的话，修改接口代码带来的影响是巨大的，而有了默认方法后，增加默认实现可以不影响任何的代码。 3.当接口多重继承时，可能会发生默认方法覆盖的问题，这时可以去指定使用哪一个接口的默认方法实现，如下示例： 123456789101112131415161718192021222324252627@FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125;@FunctionalInterfaceinterface Interface2 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125;@FunctionalInterfaceinterface Interface3 extends Interface1, Interface2 &#123; @Override default int add(int x, int y) &#123; // 指定使用哪一个接口的默认方法实现 return Interface1.super.add(x, y); &#125;&#125; 函数接口我们本小节来看看JDK8里自带了哪些重要的函数接口： 可以看到上表中有好几个接口，而其中最常用的是Function接口，它能为我们省去定义一些不必要的函数接口，减少接口的数量。我们使用一个简单的例子演示一下 Function 接口的使用： 123456789101112131415161718192021222324import java.text.DecimalFormat;import java.util.function.Function;class MyMoney &#123; private final int money; public MyMoney(int money) &#123; this.money = money; &#125; public void printMoney(Function&lt;Integer, String&gt; moneyFormat) &#123; System.out.println("我的存款: " + moneyFormat.apply(this.money)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999); Function&lt;Integer, String&gt; moneyFormat = i -&gt; new DecimalFormat("#,###").format(i); // 函数接口支持链式操作，例如增加一个字符串 me.printMoney(moneyFormat.andThen(s -&gt; "人民币 " + s)); &#125;&#125; 运行以上例子，控制台输出如下： 1我的存款: 人民币 99,999,999 若在这个例子中不使用Function接口的话，则需要自行定义一个函数接口，并且不支持链式操作，如下示例： 12345678910111213141516171819202122232425262728import java.text.DecimalFormat;// 自定义一个函数接口@FunctionalInterfaceinterface IMoneyFormat &#123; String format(int i);&#125;class MyMoney &#123; private final int money; public MyMoney(int money) &#123; this.money = money; &#125; public void printMoney(IMoneyFormat moneyFormat) &#123; System.out.println("我的存款: " + moneyFormat.format(this.money)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999); IMoneyFormat moneyFormat = i -&gt; new DecimalFormat("#,###").format(i); me.printMoney(moneyFormat); &#125;&#125; 然后我们再来看看Predicate接口和Consumer接口的使用，如下示例： 123456789public static void main(String[] args) &#123; // 断言函数接口 Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; 0; System.out.println(predicate.test(-9)); // 消费函数接口 Consumer&lt;String&gt; consumer = System.out::println; consumer.accept("这是输入的数据");&#125; 运行以上例子，控制台输出如下： 12false这是输入的数据 这些接口一般有对基本类型的封装，使用特定类型的接口就不需要去指定泛型了，如下示例： 123456789public static void main(String[] args) &#123; // 断言函数接口 IntPredicate intPredicate = i -&gt; i &gt; 0; System.out.println(intPredicate.test(-9)); // 消费函数接口 IntConsumer intConsumer = (value) -&gt; System.out.println("输入的数据是：" + value); intConsumer.accept(123);&#125; 运行以上代码，控制台输出如下： 12false输入的数据是：123 有了以上接口示例的铺垫，我们应该对函数接口的使用有了一个初步的了解，接下来我们演示剩下的函数接口使用方式： 12345678910111213public static void main(String[] args) &#123; // 提供数据接口 Supplier&lt;Integer&gt; supplier = () -&gt; 10 + 1; System.out.println("提供的数据是：" + supplier.get()); // 一元函数接口 UnaryOperator&lt;Integer&gt; unaryOperator = i -&gt; i * 2; System.out.println("计算结果为：" + unaryOperator.apply(10)); // 二元函数接口 BinaryOperator&lt;Integer&gt; binaryOperator = (a, b) -&gt; a * b; System.out.println("计算结果为：" + binaryOperator.apply(10, 10));&#125; 运行以上代码，控制台输出如下： 123提供的数据是：11计算结果为：20计算结果为：100 而BiFunction接口就是比Function接口多了一个输入而已，如下示例： 12345678910111213141516171819202122class MyMoney &#123; private final int money; private final String name; public MyMoney(int money, String name) &#123; this.money = money; this.name = name; &#125; public void printMoney(BiFunction&lt;Integer, String, String&gt; moneyFormat) &#123; System.out.println(moneyFormat.apply(this.money, this.name)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999, "小明"); BiFunction&lt;Integer, String, String&gt; moneyFormat = (i, name) -&gt; name + "的存款: " + new DecimalFormat("#,###").format(i); me.printMoney(moneyFormat); &#125;&#125; 运行以上代码，控制台输出如下： 1小明的存款: 99,999,999 方法引用在学习了lambda表达式之后，我们通常会使用lambda表达式来创建匿名方法。但有的时候我们仅仅是需要调用一个已存在的方法。如下示例： 1Arrays.sort(stringsArray, (s1, s2) -&gt; s1.compareToIgnoreCase(s2)); 在jdk8中，我们可以通过一个新特性来简写这段lambda表达式。如下示例： 1Arrays.sort(stringsArray, String::compareToIgnoreCase); 这种特性就叫做方法引用(Method Reference)。方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号）。 目前方法引用共有以下四种形式： 类型 示例 代码示例 对应的Lambda表达式 引用静态方法 ContainingClass::staticMethodName String::valueOf (s) -&gt; String.valueOf(s) 引用某个对象的实例方法 containingObject::instanceMethodName x::toString() () -&gt; this.toString() 引用某个类型的任意对象的实例方法 ContainingType::methodName String::toString (s) -&gt; s.toString 引用构造方法 ClassName::new String::new () -&gt; new String() 下面我们用一个简单的例子来演示一下方法引用的几种写法。首先定义一个实体类： 1234567891011121314151617181920212223242526public class Dog &#123; private String name = "二哈"; private int food = 10; public Dog() &#123; &#125; public Dog(String name) &#123; this.name = name; &#125; public static void bark(Dog dog) &#123; System.out.println(dog + "叫了"); &#125; public int eat(int num) &#123; System.out.println("吃了" + num + "斤"); this.food -= num; return this.food; &#125; @Override public String toString() &#123; return this.name; &#125;&#125; 通过方法引用来调用该实体类中的方法，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940package org.zero01.example.demo;import java.util.function.*;/** * @ProjectName demo * @Author: zeroJun * @Date: 2018/9/21 13:09 * @Description: 方法引用demo */public class MethodRefrenceDemo &#123; public static void main(String[] args) &#123; // 方法引用，调用打印方法 Consumer&lt;String&gt; consumer = System.out::println; consumer.accept("接收的数据"); // 静态方法引用，通过类名即可调用 Consumer&lt;Dog&gt; consumer2 = Dog::bark; consumer2.accept(new Dog()); // 实例方法引用，通过对象实例进行引用 Dog dog = new Dog(); IntUnaryOperator function = dog::eat; System.out.println("还剩下" + function.applyAsInt(2) + "斤"); // 另一种通过实例方法引用的方式，之所以可以这么干是因为JDK默认会把当前实例传入到非静态方法，参数名为this，参数位置为第一个，所以我们在非静态方法中才能访问this，那么就可以通过BiFunction传入实例对象进行实例方法的引用 Dog dog2 = new Dog(); BiFunction&lt;Dog, Integer, Integer&gt; biFunction = Dog::eat; System.out.println("还剩下" + biFunction.apply(dog2, 2) + "斤"); // 无参构造函数的方法引用，类似于静态方法引用，只需要分析好输入输出即可 Supplier&lt;Dog&gt; supplier = Dog::new; System.out.println("创建了新对象：" + supplier.get()); // 有参构造函数的方法引用 Function&lt;String, Dog&gt; function2 = Dog::new; System.out.println("创建了新对象：" + function2.apply("旺财")); &#125;&#125; 类型推断通过以上的例子，我们知道之所以能够使用Lambda表达式的依据是必须有相应的函数接口。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上Lambda的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。 如果大家想学习以上路线内容，在此我向大家推荐一个架构学习交流群。交流学习群号874811168 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构等这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 所以说 Lambda 表达式的类型是从 Lambda 的上下文推断出来的，上下文中 Lambda 表达式需要的类型称为目标类型，如下图所示： 接下来我们使用一个简单的例子，演示一下 Lambda 表达式的几种类型推断，首先定义一个简单的函数接口： 1234@FunctionalInterfaceinterface IMath &#123; int add(int x, int y);&#125; 示例代码如下： 12345678910111213141516171819202122232425262728public class TypeDemo &#123; public static void main(String[] args) &#123; // 1.通过变量类型定义 IMath iMath = (x, y) -&gt; x + y; // 2.数组构建的方式 IMath[] iMaths = &#123;(x, y) -&gt; x + y&#125;; // 3.强转类型的方式 Object object = (IMath) (x, y) -&gt; x + y; // 4.通过方法返回值确定类型 IMath result = createIMathObj(); // 5.通过方法参数确定类型 test((x, y) -&gt; x + y); &#125; public static IMath createIMathObj() &#123; return (x, y) -&gt; x + y; &#125; public static void test(IMath iMath)&#123; return; &#125;&#125; 变量引用Lambda表达式类似于实现了指定接口的内部类或者说匿名类，所以在Lambda表达式中引用变量和我们在匿名类中引用变量的规则是一样的。如下示例： 12345public static void main(String[] args) &#123; String str = "当前的系统时间戳是: "; Consumer&lt;Long&gt; consumer = s -&gt; System.out.println(str + s); consumer.accept(System.currentTimeMillis());&#125; 值得一提的是，在JDK1.8之前我们一般会将匿名类里访问的外部变量设置为final，而在JDK1.8里默认会将这个匿名类里访问的外部变量给设置为final。例如我现在改变str变量的值，ide就会提示错误： 至于为什么要将变量设置final，这是因为在Java里没有引用传递，变量都是值传递的。不将变量设置为final的话，如果外部变量的引用被改变了，那么最终得出来的结果就会是错误的。 下面用一组图片简单演示一下值传递与引用传递的区别。以列表为例，当只是值传递时，匿名类里对外部变量的引用是一个值对象： 若此时list变量指向了另一个对象，那么匿名类里引用的还是之前那个值对象，所以我们才需要将其设置为final防止外部变量引用改变： 而如果是引用传递的话，匿名类里对外部变量的引用就不是值对象了，而是指针指向这个外部变量： 所以就算list变量指向了另一个对象，匿名类里的引用也会随着外部变量的引用改变而改变： 级联表达式和柯里化在函数式编程中，函数既可以接收也可以返回其他函数。函数不再像传统的面向对象编程中一样，只是一个对象的工厂或生成器，它也能够创建和返回另一个函数。返回函数的函数可以变成级联 lambda 表达式，特别值得注意的是代码非常简短。尽管此语法初看起来可能非常陌生，但它有自己的用途。 级联表达式就是多个lambda表达式的组合，这里涉及到一个高阶函数的概念，所谓高阶函数就是一个可以返回函数的函数，如下示例： 123// 实现了 x + y 的级联表达式Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; function1 = x -&gt; y -&gt; x + y;System.out.println("计算结果为: " + function1.apply(2).apply(3)); // 计算结果为: 5 这里的 y -&amp;gt; x + y 是作为一个函数返回给上一级表达式，所以第一级表达式的输出是 y -&amp;gt; x + y这个函数，如果使用括号括起来可能会好理解一些： 1x -&gt; (y -&gt; x + y) 级联表达式可以实现函数柯里化，简单来说柯里化就是把本来多个参数的函数转换为只有一个参数的函数，如下示例： 12Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; function2 = x -&gt; y -&gt; z -&gt; x + y + z;System.out.println("计算结果为: " + function2.apply(1).apply(2).apply(3)); // 计算结果为: 6 如果大家想学习以上路线内容，在此我向大家推荐一个架构学习交流群。交流学习群号874811168 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构等这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 函数柯里化的目的是将函数标准化，函数可灵活组合，方便统一处理等，例如我可以在循环里只需要调用同一个方法，而不需要调用另外的方法就能实现一个数组内元素的求和计算，代码如下： 1234567891011121314public static void main(String[] args) &#123; Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; f3 = x -&gt; y -&gt; z -&gt; x + y + z; int[] nums = &#123;1, 2, 3&#125;; for (int num : nums) &#123; if (f3 instanceof Function) &#123; Object obj = f3.apply(num); if (obj instanceof Function) &#123; f3 = (Function) obj; &#125; else &#123; System.out.println("调用结束, 结果为: " + obj); // 调用结束, 结果为: 6 &#125; &#125; &#125;&#125; 级联表达式和柯里化一般在实际开发中并不是很常见，所以对其概念稍有理解即可，这里只是简单带过，若对其感兴趣的可以查阅相关资料。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中字符串全部替换]]></title>
    <url>%2Fposts%2F5bf0344a.html</url>
    <content type="text"><![CDATA[在js中字符串全部替换可以用以下方法： 1str.replace(/需要替换的字符串/g，&quot;新字符串&quot;) 比如： 1234&quot;yyyy-MM-dd-hh-mm-ss&quot;.replace(/-/g,&quot;/&quot;)结果如下：&quot;yyyy/MM/dd/hh/mm/ss&quot; 原理请看JavaScript replace() 方法介绍 定义和用法replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 语法1stringObject.replace(regexp/substr,replacement) 参数 描述 regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 返回值一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 说明字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 js字符串替换参考资料：http://www.w3school.com.cn/jsref/jsref_replace.asp js正则使用参考资料：http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取指定字符前/后的字符串简单实例]]></title>
    <url>%2Fposts%2F1dfc2d5c.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt;/* string 字符串; str 指定字符; split(),用于把一个字符串分割成字符串数组; split(str)[0],读取数组中索引为0的值（第一个值）,所有数组索引默认从0开始; */function getStr(string,str)&#123; var str_before = string.split(str)[0]; var str_after = string.split(str)[1]; alert('前：'+str_before+' - 后：'+str_after);&#125;&lt;/script&gt;&lt;body&gt;&lt;input type="button" onClick="getStr('string','r');" value="获取值" /&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles在线破解工具]]></title>
    <url>%2Fposts%2Fc05a8eb3.html</url>
    <content type="text"><![CDATA[点击在线生成破解后的charles.jar文件 用法 输入RegisterName(此名称随意，用于显示 Registered to xxx)，选择本地已安装的版本，点击生成，并下载charles.jar文件 替换本地charles.jar文件 macOS: /Applications/Charles.app/Contents/Java/charles.jar Windows: C:\Program Files\Charles\lib\charles.jar]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac端口被占用的解决办法（Hexo为例）]]></title>
    <url>%2Fposts%2F3a2cfc51.html</url>
    <content type="text"><![CDATA[查看端口 看看端口被哪个进程占用 lsof -i :4000 输入kill PID 记住要杀掉的进程PID，加在kill -9后面 kill -9 16149]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js面试中常问知识点整理]]></title>
    <url>%2Fposts%2Fadbc7180.html</url>
    <content type="text"><![CDATA[看看面试题，只是为了查漏补缺，看看自己那些方面还不懂。切记不要以为背了面试题，就万事大吉了，最好是理解背后的原理，这样面试的时候才能侃侃而谈。不然，稍微有水平的面试官一看就能看出，是否有真才实学还是刚好背中了这道面试题（有空再把例子中代码补上）。 一、对于MVVM的理解？MVVM 是 Model-View-ViewModel 的缩写。 Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。 View 代表UI 组件，它负责将数据模型转化成UI 展现出来。 ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 二、Vue的生命周期beforeCreate（创建前），在数据观测和初始化事件还未开始 created（创建后），完成数据观测，属性和方法的运算，初始化事件， $el 属性还没有显示出来 beforeMount（载入前），在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted（载入后），在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate（更新前），在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated（更新后），在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前），在实例销毁之前调用。实例仍然完全可用。 destroyed（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 1、什么是vue生命周期？ 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 2、vue生命周期的作用是什么？ 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 3、vue生命周期总共有几个阶段？ 答：它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。 4、第一次页面加载会触发哪几个钩子？ 答：会触发下面这几个beforeCreate、created、beforeMount、mounted 。 5、DOM 渲染在哪个周期中就已经完成？ 答：DOM 渲染在 mounted 中就已经完成了。 三、 Vue实现数据双向绑定的原理：Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令，最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定： 1234567891011121314151617181920&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &apos;txt&apos;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&apos;txt&apos;).value = newValue document.getElementById(&apos;show&apos;).innerHTML = newValue &#125; &#125;) document.addEventListener(&apos;keyup&apos;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt; 四、Vue组件间的参数传递1、父组件与子组件传值 父组件传给子组件：子组件通过props方法接受数据； 子组件传给父组件： $emit 方法传递参数 2、非父子组件间的数据传递，兄弟组件传值 eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道）。 五、Vue的路由实现：hash模式 和 history模式hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 六、Vue与Angular以及React的区别？版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟。 1、与AngularJS的区别 相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。 不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 2、与React的区别 相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。 不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。 七、vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next。 to：route即将进入的目标路由对象。 from：route当前导航正要离开的路由。 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 八、vuex是什么？怎么使用？哪种功能场景使用它？只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 在main.js引入store，注入。新建了一个目录store，… export 。 场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车 state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters：类似vue的计算属性，主要用来过滤一些数据。 action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 123456789101112131415const store = new Vuex.Store(&#123; //store实例 state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。 12345678910111213141516const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125; &#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125; &#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB&#125;) 九、其它小知识点1、css只在当前组件起作用 答：在style标签中写入scoped即可 例如： &lt;stylescoped&gt;&lt;/style&gt; 2、v-if 和 v-show 区别 答：v-if按照条件是否渲染，v-show是display的block或none； 3、$route和$router的区别 答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 PS：缺少的案例代码，这几天再补上去。有些地方可能描述的不够清楚，如果有歧义，可能是我理解错了。]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidManifest.xml文件详解（application）]]></title>
    <url>%2Fposts%2F6f32c165.html</url>
    <content type="text"><![CDATA[语法（SYNATX）： 12345678910111213141516171819202122&lt;applicationandroid:allowTaskReparenting=["true" | "false"] android:backupAgent="string" android:debuggable=["true" | "false"] android:description="string resource" android:enabled=["true" | "false"] android:hasCode=["true" | "false"] android:hardwareAccelerated=["true" | "false"] android:icon="drawable resource" android:killAfterRestore=["true" | "false"] android:label="string resource" android:logo="drawable resource" android:manageSpaceActivity="string" android:name="string" android:permission="string" android:persistent=["true" | "false"] android:process="string" android:restoreAnyVersion=["true" | "false"] android:taskAffinity="string" android:theme="resource or theme" android:uiOptions=["none" | "splitActionBarWhenNarrow"] &gt; . . .&lt;/application&gt; 被包含于（CONTAINED IN）：** 1&lt;manifest&gt; 能够包含的元素（CAN CONTAIN）： 1234567891011&lt;activity&gt;&lt;activity-alias&gt;&lt;service&gt;&lt;receiver&gt;&lt;provider&gt;&lt;meta-data&gt; 说明（DESCRIPTION）： 这个元素用于应用程序的 声明。它包含了每个应用程序组件所声明的子元素，并且还有能够影响所有组件的属性。其中的很多属性（如icon、label、permission、 process、taskAffinity和allowTaskReparenting）会给组件元素中对应的属性设置默认值。其他的给是应用程序整体设 置的值（如debuggable、enabled、description、allowClearUserData），并且这些属性值不能被组件的属性所 覆盖。 属性（ATTRIBUTES）： Android:allowTaskReparenting 当一个与当前任务有亲缘 关系的任务被带到前台时，用这个属性来指定应用程序中定义的Activity能否从他们当前的任务中转移到这个有亲缘关系的任务中。如果设置为true， 则能够转移，如果设置为false，则应用程序中的Activity必须保留在它们所在的任务中。默认值是false。 1&lt;activity&gt;元素有它们自己的allowTaskReparenting属性，它能够覆盖&lt;application&gt;元素中的设置。 android:allowBackup Whether to allow the application to participate in the backup and restore infrastructure. If this attribute is set to false, no backup or restore of the application will ever be performed, even by a full-system backup that would otherwise cause all application data to be saved via adb. The default value of this attribute is true. 是否允许备份应用的数据，默认是true,当备份数据的时候，它的数据会被备份下来。如果设为false，那么绝对不会备份应用的数据，即使是备份整个系统。 android:backupAgent 这个属性用于定义应用程 序备份代理的实现类的名称，这个类是BackupAgent类的一个子类。它的属性值应该是完整的Java类的名称 （如，com.example.project.MyBackupAgent）。但是，也可以使用用”.”符号开头的简称 （如，.MyBackupAgent），系统会把元素中指定的包名追加到”.”符号的前面。 android:debuggable 这个属性用于指定应用程序是否能够被调试，即使是以用户模式运行在设备上的时候。如果设置为true，则能够被调试，否则不能调试，默认值是false。 android:description 这个属性用于定义应用程序相关的用户可读文本，它要比应用程序标签更长、更详细。它的的值必须被设置成一个字符串资源的引用。跟label属性不一样，label属性可以使用原生的字符串。这个属性没有默认值。 android:enabled 这个属性用于指定 Android系统能否实例化应用程序组件。如果设置为true，这个可以实例化其组件，否则不能够实例化。如果这个属性被设置为true，那么就会使用 每个组件自己enabled属性的设置来判断其是否能够被实例化。如果这个属性被设置为false，它会覆盖其所有组件自己指定的值，应用程序中的所有组 件都会被禁用。 默认值是true。 android:hasCode 这个属性用于设置应用程序是否包含了代码，如果设置为true，则包含代码，否则不包含任何代码。在这个属性被设置为false的时候，系统在加载组件的时候不会试图加载任何应用程序的代码。默认值是true。 如果应用程序没有使用任何应用内置组件类以外的组件，那么这个应用程序就不会有任何自己的代码，像使用AliasActivity类的Activity，是很少发生的。 android:hardwareAccelerated 这个属性用于设置能够给应用程序中的所有Activity和View对象启用硬件加速渲染。如果设置为true，则应该启用，如果设置为false，则不会启用。默认值是false。 从Android3.0 开始，应用程序可以使用硬件加速的OpenGL渲染器，来改善很多共同的2D图形操作的性能。当硬件加速渲染被启动的时候，在Canvas、Paint、 Xfermode、ColorFilter、Shader和Camera中的大多数操作都会被加速。这样会使动画、滚动更加平滑，并且会改善整体的响应效 果，即使应用程序没有明确的使用框架的OpenGL类库。 要注意的是，不是所有的OpenGL 2D操作都会被加速。如果启用了硬件加速渲染器，就要对应用程序进行测试，以确保使用渲染器时不发生错误。 android:icon 这个属性用于设置应用程 序的整个图标，以及每个应用组件的默认图标。对于、、、、 和元素，请看它们各自的icon属性。 设置这个属性时，必须要引用一个包含图片的可绘制资源（例如，“@drawable/icon”）。没有默认的图标。 android:killAfterRestore 这个属性用于指定在全系统的恢复操作期间，应用的设置被恢复以后，对应的问题程序是否应该被终止。单包恢复操作不会导致应用程序被关掉。全系统的复原操作通常只会发生一次，就是在电话被首次建立的时候。第三方应用程序通常不需要使用这个属性。 默认值是true，这意味着在全系统复原期间，应用程序完成数据处理之后，会被终止。 android:largeHeap Whether your application’s processes should be created with a large Dalvik heap. This applies to all processes created for the application. It only applies to the first application loaded into a process; if you’re using a shared user ID to allow multiple applications to use a process, they all must use this option consistently or they will have unpredictable results.Most apps should not need this and should instead focus on reducing their overall memory usage for improved performance. Enabling this also does not guarantee a fixed increase in available memory, because some devices are constrained by their total available memory.To query the available memory size at runtime, use the methods getMemoryClass() or getLargeMemoryClass().无论您的应用程序的进程应该是一个多大的Dalvik堆。这适用于为应用程序创建的所有进程。它只适用于加载到进程中的第一个应用程序，如果你使用一个共享的用户身份证，允许多个应用程序使用一个进程，他们都必须使用此选项一致或他们将有不可预测的结果。大多数应用程序不应该需要这个，而应该把重点放在减少对性能的整体内存使用上。启用此也不保证可用内存的固定增加，因为一些设备被其总可用内存限制。查询可用的内存大小在运行时，使用的方法getmemoryclass()或getlargememoryclass()。 android:label 这个属性用于设置应用程 序整体的用户可读的标签，并也是每个应用程序组件的默认标签。对于、、、和元素，请看它们各自的 label属性。 设置这个属性值时，应该引用一个字符串资源。以便它能够跟用户界面中的其他字符串一样能够被本地化。但是为了应用程序开发的便利，也能够用原生的字符串来设置。 android:logo 这个属性用于给整个应用程序设置一个Logo，而且它也是所有Activity的默认Logo。 设置这个属性时，必须要引用一个包含图片的可绘制资源（如：“@drawable/logo”）。没有默认的Logo。 android:manageSpaceActivity 这个属性定义了一个完整的Activity子类的名字，系统能够把这个名字加载到由用户管理被应用程序所占用的设备上的内存。这个Activity也应该用元素来声明。 android:name 这整个属性用完整的Java类名，给应用程序定义了一个Application子类的实现。当应用程序进程被启动时，这个类在其他任何应用程序组件被实例化之前实例化。 这个子类实现是可选的，大多数应用程序不需要一个子类的实现。如果没有实现自己的子类，Android系统会使用基本的Application类的一个实例。 android:permission 这个属性定义了一个权限，为了跟应用程序进行交互，客户端必须要有这个权限。这个属性是为给所有的应用程序组件设置权限提供了便利的方法。它能够被独立组件所设置的permission属性所覆盖。 android:persistent 这个属性用户设置应用程序是否应该时刻保持运行状态，如果设置为true，那么就保持，否则不保持。默认值是false。普通的应用程序不应该设置这个属性，持久运行模式仅用于某些系统级的应用程序。 android:process 这个属性用于定义一个进程名称，应用程序的所有组件都应该运行在这个进程中。每个组件都能够用它自己process属性的设置来覆盖这个元素中的设置。 默认情况下，当应用程序的第一个组件需要运行时，Android系统就会给这个应用程序创建一个进程。然后，应用中的所有组件都运行在这个进程中。默认的进程名是跟元素中设置的包名进行匹配的。 通过设置这个属性，能够跟另外一个应用程序共享一个进程名，能够把这两个应用程序中的组件都安排到同一个进程中运行—但是仅限于这两个应用程序共享一个用户ID，并且带有相同的数字证书。 如果这个进程名称用“：”开头，那么在需要的时候，就会给应用程序创建一个新的、私有的进程。如果进程名用小写字符开头，就会用这个名字创建一个全局的进程，这个全局的进程能够被其他应用程序共享，从而减少资源的使用。 android:restoreAnyVersion 设置这个属性表示应用程序准备尝试恢复任何备份的数据集，即使备份比设备上当前安装的应用程序的版本要新。这个属性设置为true，即使是在版本不匹配而产生数据兼容性提示的时候，也会允许备份管理来恢复备份的数据，所以要谨慎使用。 这个属性的默认值是false。 android:taskAffinity 这个属性给应用的所有的Activity设置了一个亲缘关系名，除了那些用它们自己的taskAffinity属性设置不同亲缘关系的组件。 默认情况下，应用程序中的所有Activity都会共享相同的亲缘关系，亲缘关系的名称跟由元素设置的包名相同。 android:theme 这个属性给应用程序中所有的Activity设置默认的主题，属性值要引用一个样式资源。每个独立的Activity的主题会被它们自己的theme属性所覆盖。 android:uiOptions 这个属性设置了Activity的UI的额外选项。它必须是下表中的一个值： 值 说明 none 默认设置，没有额外的UI选项。 splitActionBarWhenNarrow 在水平空间受到限制的时 候，会在屏幕的底部添加一个用于显示ActionBar中操作项的栏，例如：在纵向的手持设备上。而不是在屏幕顶部的操作栏中显示少量的操作项。它会把操 作栏分成上下两部分，顶部用于导航选择，底部用于操作项目。这样就会确保可用的合理空间不仅只是针对操作项目，而且还会在顶部给导航和标题留有空间。菜单 项目不能被分开到两个栏中，它们要显示在一起。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis,mysql,sequelize,node,linux,docker,索引优秀文章集锦]]></title>
    <url>%2Fposts%2F325455a3.html</url>
    <content type="text"><![CDATA[redis Redis 数据库入门指南 Redis 数据类型之字符串(String)类型 Redis 数据类型之哈希(Hash)类型 Redis 数据类型之列表(List)类型 Redis 数据类型之集合(Set)类型 Redis 数据类型之有序集合(Sorted Set) Redis 键(Key)的操作命令 redis - Node.js Redis客户端模块 mysql Linux 源码编译安装MySQL 5.7 MySQL 自定义函数和存储过程的使用 MySQL 事件调度器(Event Scheduler)创建定时任务 MySql视图view的使用：创建、修改、删除 MySql触发器trigger的使用 使用MySQL的DATE_FORMAT()函数进行日期/时间格式化 索引 参考1 参考2 Sequelize 定义索引 MySQL索引使用－创建、查看、删除MySQL索引 MySQL索引的优点和缺点及注意事项 sequelize Sequelize 中文API文档－1. 快速入门、Sequelize类 Sequelize 中文API文档－2. Model 的定义、使用与Model类的API Sequelize 中文API文档－3. 模型（表）之间的关系/关联 Sequelize 中文API文档－4. 查询与原始查询 Sequelize 中文API文档－5. 实例的使用、Instance类介绍 Sequelize 中文API文档－6. 事务的使用与Transaction类 Sequelize 中文API文档－8. 钩子函数的使用、Hooks相关API Sequelize 中文API文档－7. Scopes 作用域的使用 Sequelize 中文API文档－9. 数据类型类 DataTypes 及其API Sequelize 中文API文档－10. Migrations 数据迁移与QueryInterface对象 Sequelize 嵌套模型查询及嵌套模型字段排序 Sequelize 连接查询时include中model与association的区别 在Sequelize中使用group by分组聚合查询 Node.js Sequelize 实现数据库读写分离 Sequelize belongsToMany关系的使用及 is not associated with 问题的处理 Sequelize 中事务的使用－启动、提交、回滚 NODE Node.js 基于流将日志、错误分别写入不同文件 Node.js 核心(原生)模块整理 Node.js 中有哪些类型的错误 Node.js 事件循环（Event Loop）介绍 Node.js（npm）中的包和模块 Linux curl 命令行工具的使用及命令参数说明 ssh-keygen实现基于SSH密钥的SSH、SCP无密码登录 Linux命令ftp文件传输 搭建FTP服务器 Linux命令grep查找文件里符合条件的字符串 加快网页访问速度Nginx配置gzip压缩功能 docker Docker 的安装 MySQL 官方Docker镜像的使用 使用 Docker 部暑Node.js应用 Docker 容器数据卷(Data Volume)与数据管理 Docker镜像构建文件Dockerfile及相关命令介绍 构建自已的 Docker 镜像 Docker 镜像(Image)与仓库(Repository)基础 Docker 容器(Container)的管理]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[editorConfig编辑器配置]]></title>
    <url>%2Fposts%2F6d832a8b.html</url>
    <content type="text"><![CDATA[当多人团队进行一个项目开发时，每个人可能喜欢的编辑器不同，有人喜欢Webstrom、有人喜欢sublime、还有人喜欢Hbuilder。 这个时候，问题便迎面而来，如何使使用不同编辑器的开发者能够轻松惬意的遵守最基本的代码规范呢？ 最后终于找到了editorConfig这个东东，发现在这里配置的代码规范规则优先级高于编辑器默认的代码格式化规则。比如我使用的是Webstrom编辑器，我每一次写完代码之后，都习惯性的按下“Ctrl+Alt+L”快捷键去整理代码格式。如果我没有配置editorconfig，执行的就是编辑器默认的代码格式化规则；如果我已经配置了editorConfig，则按照我设置的规则来，从而忽略浏览器的设置。 下面说说它的常用配置和使用方法： 常用配置 （1）charset 编码格式 （2）indent_style 缩进方式 （3）indent_size 缩进大小 （4）insert_final_newline 是否让文件以空行结束 （5）trim_trailing_whitespace 自动删除文件末尾空白行 （6）max_line_length 疑似最大行宽 使用方法 （1）下载相关编辑器的editorconfig插件。 （2）在项目根目录下，新建.editorconfig文件。 （3）配置规范，如下图所示： 12345678910111213141516171819202122# http://editorconfig.orgroot = true[*]#缩进风格：空格indent_style = space#缩进大小2indent_size = 2#换行符lfend_of_line = lf#字符集utf-8charset = utf-8#是否删除行尾的空格trim_trailing_whitespace = true#是否在文件的最后插入一个空行insert_final_newline = true[*.md]trim_trailing_whitespace = false[Makefile]indent_style = tab 官方网站 atom网站：https://atom.io/packages/editorconfig GitHub：https://github.com/sindresorhus/atom-editorconfig 使用建议配合代码检查工具使用，比如说：ESLint和TSLint，统一代码风格。 支持的编辑器 虽然editor编辑器的可用配置并不多，但目前现有的一些配置也差不多能满足最基本格式需求。]]></content>
      <categories>
        <category>前端</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>editorConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webstorm激活破解方法大全]]></title>
    <url>%2Fposts%2F9468177.html</url>
    <content type="text"><![CDATA[webstorm 作为最近最火的前端开发工具,也确实对得起那个价格,但是秉着勤俭节约的传统美德,我们肯定是能省则省啊。 方法一：（更新时间：2018/4/8）v3.3 不一定长期有效注册时，在打开的License Activation窗口中选择“License server”，在输入框输入下面的网址： http://180.76.140.202:9123 (2018/07/20) http://idea.wrbugtest.tk/ (2018/06/16) 点击：Activate即可。 方法二：获取注册码（推荐）打开网址IntelliJ IDEA 注册码，我们能看到下面的界面，直接点击获取激活码，将生成的激活码粘贴到WebStorm激活对话框中的Lisence Code输入框，点击OK即可破解。 方法三：使用破解补丁（推荐）首先下载补丁，看图！ 最新版本下载地址：IntelliJ IDEA 注册码 第一步:将补丁复制到安装目录的bin目录下 1\...\WebStorm\bin PS：一定要把这个jar包复制到这个bin目录，不然后面操作可能无法进行。 *第二步：修改同目录下的 WebStorm.vmoptions * 用文本编辑器打开之后，在文件最上面加一行代码 ： 1-javaagent: D:/Program Files (x86)/JetBrains/WebStorm/bin/破解补丁名字.jar 第三步：配置好之后，保存文件。在此再次启动WebStorm，选择activation code，并将-javaagent:你的WebStorm路径前缀/WebStorm/bin/破解补丁名字.jar 方法四:自己搭建IntelliJ IDEA授权服务器这个比较繁琐,喜欢折腾的人可以试试: IntelliJ IDEA License Server本地搭建教程 ilanyu’s大牛的博客里有详细的步骤 如果有更好的方法,欢迎留言交流。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome的控制台,Console命令的各种用法你真的都已经了解了吗？]]></title>
    <url>%2Fposts%2F8910c6e9.html</url>
    <content type="text"><![CDATA[前言作为前端工程师，我们每天都离不开用控制台调试代码，console.log也成了我们最常用的命令，那除了用console.log，还有许多console的方法可以使用，熟练掌握它们，可以让我们在控制台看到的信息更美观准确，也会大大提高我们的开发效率哦，下面就跟小肆一起来看看吧. Chrome的控制台大部分常用浏览器都有各自的控制台，不过小肆用着最习惯的还是Chrome的控制台，打开chrome，win系统按F12，mac系统按command+option+J就可以呼出控制台了，切换到Console标签就能看到如下信息： 我们可以看到，baidu还在控制台给我们留了个小彩蛋，我想这个彩蛋也是为我们程序员同学留的吧。让我们先学第一个命令清除控制台来开始吧。 清除控制台在chorme下清除控制台的方法有很多： 输入console.clear()命令或clear()命令 使用快捷键 Control + J 或 Command + K 点击控制台左上角第二个图标 🚫 显示信息的命令12345console.log('技术放肆聊') // 输出普通信息console.info('技术放肆聊') // 输出提示信息console.warn('技术放肆聊') // 输出警告信息console.error('技术放肆聊') // 输出错误信息console.debug('技术放肆聊') // 输出调试信息 console.log、console.info、console.debug这三个命令可以理解为一个，我们只需要用console.log就行，并且chrome还不支持console.debug命令。 console.warn命令输出警告信息，信息前带有黄色警告符号。console.error输出错误信息，信息前带有红色错误符号，表示出错，同时会显示错误发生的堆栈。上段代码在chrome控制台输出效果如下: 在safari输出效果如下: 占位符console上述的命令支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）: 占位符 作用 %s 字符串 %d or %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 123456//字符(%s)console.log("%s","技术放肆聊");//整数(%d或%i)console.log("%d年%d月%d日",2019,1,6); //浮点数(%f)console.log("PI=%f",3.1415926); 显示效果如下： %o、%O 都是用来输出 Object 对象的，对普通的 Object 对象，两者没区别，但是打印dom节点时就不一样了： %c 占位符是最常用的。使用 %c 占位符时，对应的后面的参数必须是 CSS 语句，用来对输出内容进行 CSS 渲染。常见的输出方式有两种：文字样式、图片输出。 信息分组console.group()用于将显示的信息分组，可以把信息进行折叠和展开。console.groupEnd()结束内联分组 将对象以树状结构展现console.dir()可以显示一个对象所有的属性和方法. 显示某个节点的内容console.dirxml()用来显示网页的某个节点(node)所包含的html/xml代码 判断变量是否是真console.assert()用来判断一个表达式或变量是否为真，此方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 计时功能console.time()和console.timeEnd()，用来显示代码的运行时间 12345console.time("控制台计时器");for(var i = 0; i &lt; 10000; i++)&#123; for(var j = 0; j &lt; 10000; j++)&#123;&#125; &#125;console.timeEnd("控制台计时器"); 性能分析performance profileconsole.profile()和console.proileEnd()用来分析程序各个部分的运行时间，找出瓶颈所在。 123456789101112131415 function All()&#123; for(var i = 0; i &lt; 10; i++)&#123; funcA(100); &#125; funcB(1000); &#125; function funcA(count)&#123; for(var i = 0; i &lt; count; i++)&#123;&#125;; &#125;function funcB(count)&#123; for(var i = 0; i &lt; count; i++)&#123;&#125;;&#125;console.profile("性能分析器");All();console.profileEnd(); 详细的信息在chrome控制台里的”profile”选项里查看 console.count()统计代码被执行的次数123456function myFunction()&#123; console.count("myFunction 被执行的次数");&#125;myFunction(); //myFunction 被执行的次数: 1myFunction(); //myFunction 被执行的次数: 2myFunction(); //myFunction 被执行的次数: 3 console.table表格显示方法 总结合理的利用console的各种方法，会使我们的调试过程更加愉悦，今天的分享就到这里了，记得右下角点好看呦！ 转自：https://mp.weixin.qq.com/s/8jcqYIPZGQVsLo3fou41Zw]]></content>
      <categories>
        <category>前端</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强力推荐！那些你不能错过的GitHub插件和工具]]></title>
    <url>%2Fposts%2Ff033121.html</url>
    <content type="text"><![CDATA[以代码托管平台起家的 GitHub 网站，已然成为全球程序员工作和生活中不可或缺的一份子。从优秀的企业，到优秀的程序员，都将自己最优秀的代码作品存放在这片开源净土里，供彼此学习交流。 GitHub Trending 栏目甚至已经成为 IT 从业人员的新闻日报，每日必读。 既然 GitHub 这么重要，又被我们使用得这么频繁，那关于 GitHub 的一些优秀浏览器插件或者其他工具，我们就一定不可错过啦。本文就来整理一些，都是我平常使用最得心应手的东西，全都倾力推荐出来，绝对干货！ Chrome 扩展程序 备注：这个分类的部分均可以在 Chrome 应用商店 搜索得到，也可以直接点击小标题直接跳转至插件详情页。 Octotree 很好奇的是，GitHub 作为代码托管平台，竟然没有提供项目目录，方便用户在线快速浏览项目结构。所以，在线分析项目源码就会变得很繁琐，必须一层一层点击，然后再一次一次地向上返回。要知道，本来 GitHub 网站在中国区的访问就已经很慢了。最无奈的做法就是，下载到本地，再使用 Sublime 等编辑器打开。 Octotree 作为 Chrome 浏览器的一款插件，刚好解决这个使用痛点。他能够像 IDE 一样提供项目目录，快捷导航，方便浏览。同时支持 GitHub 和 GitLab 两个常用的代码托管网站。更贴心的是，你可以自行选择是否显示目录。 GitHub Plus 同样作为 Chrome 的插件，GitHub Plus 提供的功能也是非常实用。能够显示代码仓库的大小，以及其中每个文件的大小和下载链接。使用这款插件，我们再也不用因为需要某个单一文件而被迫下载整个项目源码，尤其是在网速不给力的时候。 GitHub Hovercard 使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。有点类似 StackOverflow 网站的用户头像的鼠标悬停效果。Hovercard 插件支持的悬停位置更多，包括用户头像，仓库地址，Issue 链接，个人主页等。咱们还是用图说话比较直接： Sourcegraph for GitHub 代码搜索，查看引用，自动跳转，项目目录导航，这些 IDE 上常用的功能操作，借助 Sourcegraph 插件，都能帮你直接在线使用。如图： Octo Mate 这款插件提供的功能与前面提到的 GitHub Plus 有点类似，展示项目大小，任意文件点击下载等。如图： Awesome Autocomplete for GitHub GitHub 智能搜索插件。有点类似自动补全功能，实时监听输入的搜索关键字，自动列出相关内容。正如官方介绍那样，致力于打造 GitHub 上最好的搜索引擎，助你在搜索仓库和用户方面，比以往更快人一步。 Isometric Contributions 3D 像素立体展示 GitHub 上的仓库提交记录。相比传统的方块图表，更有美感。当然，使用这款插件之后，你可以自由切换展示方式，而不是一刀切。 高效率管理工具 前面提到的都是 Chrome 的插件系列，基本上可以解决平时我们使用 GitHub 在线搜索或者浏览某一仓库时所遇到的痛点问题。但是还有一个很重要的痛点没有解决，那就是我们 Star 过的仓库管理问题。 任何一个 IT 领域，GitHub 网站都有成千上万个优秀开源项目可供参考学习。所以，收藏关注几十几百个项目是再平常不过的一件事了。没有标签，没有便捷的检索功能，如何高效率地管理这些关注过的项目呢？也许你可以尝试这些网站提供的工具。 OhMyStar2 强力推荐 OhMyStar2 客户端，号称是管理 GitHub Stars 最好的方式。自动同步 GitHub 账号的 Stars，拥有标签和评分两种分类方式助你分组管理项目，根据名称、日期等指标自动排序，三方分享功能，甚至提供每日 Trending 浏览，说是最好，名符其实！ Astral 也是提供标签式的方式管理 GitHub 账号关注的项目。只不过，通过网站在线管理，没有提供 PC 版客户端。免费试用。 Insight.io 这个工具使用起来有点类似 IDE，提供开发中常用的快速导航、代码搜索功能、查看引用和点击跳转等功能。 我想，有了这些工具，一定能大幅提高我们程序员使用 GitHub 时的效率。工欲善其事，必先利其器。站在巨人的肩膀上，更容易事半功倍。利用好工具，换种角度来看，也是一种不可忽视的能力。 从事 IT 行业以来，越发觉得，互联网对于我们每个人来说，都是公平的，如何开拓视野，利用网络平台提升自己的学习能力和工作效率，显得尤为重要。很庆幸，我们都在这个最潮流的行业，共同学习，一起进步。 备注：更多开发中的优秀 Chrome 插件，可访问我的 GitHub 仓库地址：https://github.com/zhangmiaocc/powerful-chrome-plugins]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediaMetadataRetriever获取网络/本地视频第一帧图片]]></title>
    <url>%2Fposts%2Ff0cf7486.html</url>
    <content type="text"><![CDATA[获取视频第一帧图片，这种需求不多，项目中用到了这个功能踩了点坑，很骚。 获取网络视频123MediaMetadataRetriever mmr = new MediaMetadataRetriever();//后面这个是传请求Headers，如果有需要可以添加mmr.setDataSource(url, new HashMap()); 获取本地视频(setDataSource中不需要传第二个参数，直接传路径就好)123MediaMetadataRetriever mmr = new MediaMetadataRetriever();//后面这个是传请求Headers，如果有需要可以添加mmr.setDataSource(path, new HashMap()); 封装的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class MediaUtils &#123; public static final int MEDIA_TYPE_IMAGE = 1; public static final int MEDIA_TYPE_VIDEO = 2; public static File file; /** * Create a file Uri for saving an image or video */ public static Uri getOutputMediaFileUri(Context context, int type) &#123; Uri uri = null; //适配Android N if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; return FileProvider.getUriForFile(context, context.getApplicationContext().getPackageName() + ".provider", getOutputMediaFile(type)); &#125; else &#123; return Uri.fromFile(getOutputMediaFile(type)); &#125; &#125; /** * Create a File for saving an image or video */ public static File getOutputMediaFile(int type) &#123; // To be safe, you should check that the SDCard is mounted // using Environment.getExternalStorageState() before doing this. File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), "image"); // This location works best if you want the created images to be shared // between applications and persist after your app has been uninstalled. // Create the storage directory if it does not exist if (!mediaStorageDir.exists()) &#123; if (!mediaStorageDir.mkdirs()) &#123; return null; &#125; &#125; // Create a media file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); File mediaFile; if (type == MEDIA_TYPE_IMAGE) &#123; mediaFile = new File(mediaStorageDir.getPath() + File.separator + "IMG_" + timeStamp + ".jpg"); &#125; else if (type == MEDIA_TYPE_VIDEO) &#123; mediaFile = new File(mediaStorageDir.getPath() + File.separator + "VID_" + timeStamp + ".mp4"); &#125; else &#123; return null; &#125; file = mediaFile; return mediaFile; &#125; /** * 获取视频的第一帧图片 */ public static void getImageForVideo(String videoPath, OnLoadVideoImageListener listener) &#123; LoadVideoImageTask task = new LoadVideoImageTask(listener); task.execute(videoPath); &#125; public static class LoadVideoImageTask extends AsyncTask&lt;String, Integer, File&gt; &#123; private OnLoadVideoImageListener listener; public LoadVideoImageTask(OnLoadVideoImageListener listener) &#123; this.listener = listener; &#125; @Override protected File doInBackground(String... params) &#123; MediaMetadataRetriever mmr = new MediaMetadataRetriever(); String path = params[0]; if (path.startsWith("http")) //获取网络视频第一帧图片 mmr.setDataSource(path, new HashMap()); else //本地视频 mmr.setDataSource(path); Bitmap bitmap = mmr.getFrameAtTime(); //保存图片 File f = getOutputMediaFile(MEDIA_TYPE_IMAGE); if (f.exists()) &#123; f.delete(); &#125; try &#123; FileOutputStream out = new FileOutputStream(f); bitmap.compress(Bitmap.CompressFormat.JPEG, 90, out); out.flush(); out.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mmr.release(); return f; &#125; @Override protected void onPostExecute(File file) &#123; super.onPostExecute(file); if (listener != null) &#123; listener.onLoadImage(file); &#125; &#125; &#125; public interface OnLoadVideoImageListener &#123; void onLoadImage(File file); &#125;&#125; 因为考虑到处理视频比较耗时，上面代码使用了AsycTask+Callback的方式来实现，先保存到本地后在加载本地的图片。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷炫的Activity切换动画，打造更好的用户体验]]></title>
    <url>%2Fposts%2F908dd83e.html</url>
    <content type="text"><![CDATA[毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。 我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码： 123Intent intent=new Intent(this,SecondActivity.class);startActivity(intent);overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim); 在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊： ​ 先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。 1 使用内置Activity之间切换动画代码步骤Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示： enter：用于决定第一次打开当前Activity时的动画 exit : 用于决定退出当前Activity时的动画 reenter: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画 shared elements:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果 那么应该怎么去使用Activity切换动画呢？我们看看使用步骤： 1.首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画 1getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 2.接下来就是加载切换动画 其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。 1Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode); 3.告诉Window，当前的Activity在什么情况下使用上面的动画 上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果： 123456//退出时使用getWindow().setExitTransition(explode);//第一次进入时使用getWindow().setEnterTransition(explode);//再次进入时使用getWindow().setReenterTransition(explode); 当然了，你也可以不使用代码的方式，直接在你使用的主题&lt;style&gt;标签里添加类似如下代码： 123&lt;item name="android:windowExitTransition"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowEnterAnimation"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowReenterTransition"&gt;@transition/explode&lt;/item&gt; 4.调用startActivity 跟我们之前使用的startActivity(Intent intent);不同，这里多了一个参数Bundle，我们是先通过makeSceneTransitionAnimation函数创建一个ActivityOptions对象，再将其转为Bundle对象: 1startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); 整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~ 2 Explode效果Explode即爆炸效果，使用Explode效果很简单，在res/transition目录下新建一个xml文件(如explode.xml)，内容如下： 12&lt;explode xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; 其中duration表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200500毫秒比较合适。我们看看效果吧 3 Slide效果即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如slide.xml)，内容如下： 123&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot; android:slideEdge=&quot;end&quot;/&gt; 其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧 GIF 效果看的比较死板，可以下载我的源码实际运行一下~ 如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定： 12345678&lt;slide xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:interpolator/decelerate_cubic" android:slideEdge="end"&gt; &lt;targets&gt; &lt;target android:excludeId="@android:id/navigationBarBackground" /&gt; &lt;target android:excludeId="@android:id/statusBarBackground" /&gt; &lt;/targets&gt;&lt;/slide&gt; 4 Fade效果Fade效果即淡化效果，使用淡化效果依然是很简单，在res/transition目录下新建一个xml文件(如fade.xml)，内容如下： 12&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~ 5 Shared Element效果即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下： 从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~ 接下来我们看看如何实现这个效果： 1.将两个Activity中需要过渡的View加上android:transitionName属性 两个View的android:transitionName属性取值要一致，比如： 第一个Activity布局： 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:id="@+id/firstSharedView" android:layout_width="100dp" android:layout_height="100dp" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 第二个Activity布局： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:layout_width="match_parent" android:layout_height="300dp" android:layout_alignParentBottom="true" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 两个绿色的View都添加android:transitionName属性，并且取名一致。 2.调用startActivity ActivityOptions的makeSceneTransitionAnimation函数第一个参数Activity没啥解释的，第二个参数就是第一个Activity中的View对象，第三个参数就是两个Activity的View的 android:transitionName属性的值。 1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView, "sharedView").toBundle()); 现在就可以实现这种Shared Element效果啦，但是可能你会想实现同时让两个View有这样的效果，可是makeSceneTransitionAnimation函数却只能让我们设置一个View和一个transitionName属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。 除了需要将两个Activity中需要过渡的View对应取相同的名称外，还需将需要过渡的View和transitionName取值对应的String这两个对象封装到一个Pair对象中： 123Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView)); 然后调用ActivityOptionsCompat类的makeSceneTransitionAnimation的另一个重载函数makeSceneTransitionAnimation(Activity activity, Pair&lt;View, String&gt;... sharedElements)，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。 12ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second); 最后调用startActivity 12ActivityCompat.startActivity(this, intent, transitionActivityOptions.toBundle()); 说了这么多步骤，我们来看看效果吧~ 多个子View的过渡效果 5.1 自定义 Shared Element切换动画如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下： 1.创建一个View的过渡移动的轨迹路径PathMotion类 我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看【ArcMotion官方文档】 123ArcMotion arcMotion = new ArcMotion();arcMotion.setMinimumHorizontalAngle(50f);arcMotion.setMinimumVerticalAngle(50f); 2.定义ChangeBounds类 我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数： 1.ViewGroup sceneRoot：屏幕根View，即DecorView，第二个Activity的DecorView。 TransitionValues startValues ：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数captureStartValues里放置，因此你可以重写captureStartValues函数，并把你自定义的属性动画中的属性放进去。 TransitionValues endValues ：与startValues类似，表示属性动画结束时的属性值。可以通过重写captureEndValues函数，并把你自定义的属性动画里面的最终属性值放进去。 我们先看一个最简单的示例： 1234567891011121314151617181920212223242526package com.zm.util;import android.animation.Animator;import android.transition.ChangeBounds;import android.transition.TransitionValues;import android.view.ViewGroup;import android.view.animation.AnimationUtils;public class CustomChangeBounds extends ChangeBounds &#123; @Override public Animator createAnimator(final ViewGroup sceneRoot, TransitionValues startValues, final TransitionValues endValues) &#123; Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues); if (startValues == null || endValues == null || changeBounds == null) return null; changeBounds.setDuration(300); changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(), android.R.interpolator.fast_out_slow_in)); return changeBounds; &#125;&#125; 看看效果吧~ 参考资料：https://labs.ribot.co.uk/exploring-meaningful-motion-on-android-1cd95a4bc61d#.cf6pub9xu https://github.com/hitherejoe/animate]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity切换动画常用实现方式]]></title>
    <url>%2Fposts%2Fa8391ded.html</url>
    <content type="text"><![CDATA[一. overridePendingTransition()：此方式只需要在启动另一个activity和退出activity的时候调用就行，这个方法接收两个参数，一个是新启动的activity进入时的动画，另一个是当前activity消失时的动画。 启动： 12startActivity(newIntent(MainActivity.this,TestActivityWithTheme.class));overridePendingTransition(R.anim.open_in, R.anim.open_out); 退出： 12345@Override public void finish() &#123; super.finish(); overridePendingTransition(R.anim.close_in, R.anim.close_out); &#125; 二. ActivityOptionsCompat：这个类是supportv4中新加的一个类，可以为activity添加各种动画效果，这里面的api至少要求4.0以上的系统，部分要求5.0以上，谷歌为我们封装好了的一些拉伸扩散动画，共享元素动画等等，下面只介绍一种简单效果的实现方式， 启动： 12ActivityOptionsCompat compat = ActivityOptionsCompat.makeCustomAnimation(MainActivity.this, R.anim.open_in, R.anim.open_out);ActivityCompat.startActivity(MainActivity.this,intent, compat.toBundle()); 退出： 12345Overridepublic void onBackPressed() &#123; super.onBackPressed(); ActivityCompat.finishAfterTransition(this);&#125; 注意：该退出方法不能达到预期的动画效果，还需要使用第一种方式实现退出overridePendingTransition(R.anim.close_in, R.anim.close_out); 三.AppTheme: 直接在主题中修改activity动画样式：我们可以在 AndroidManifest.xml 文件中，通过Android:theme 属性设置 Activity 的主题。主题中可以定义 Activity 的切换动画。这是应用 Activity 切换动画的一种方法。下面是通过主题来设置 Activity 间的切换动画的实现方式。 3.1、定义包含动画的 Activity 主题res/values/styles.xml 123&lt;style name="AnimActivityTheme" parent="@android:style/Animation.Activity"&gt; &lt;item name="android:windowAnimationStyle"&gt;@style/MyWindowAnimTheme&lt;/item&gt;&lt;/style&gt; 就是使用 windowAnimationStyle 这个属性，指定切换动画的style即可。 3.2、定义切换动画 styleres/values/styles.xml 123456&lt;style name="MyWindowAnimTheme"&gt; &lt;item name="android:activityOpenEnterAnimation"&gt;@anim/top_to_bottom_in&lt;/item&gt; &lt;item name="android:activityOpenExitAnimation"&gt;@anim/top_to_bottom_out&lt;/item&gt; &lt;item name="android:activityCloseEnterAnimation"&gt;@anim/bottom_to_top_in&lt;/item&gt; &lt;item name="android:activityCloseExitAnimation"&gt;@anim/bottom_to_top_out&lt;/item&gt;&lt;/style&gt; 下面具体介绍这4个属性的意思，假设我们有 2 个 Activity，分别是 A 和 B： A 启动 B 时，A 从屏幕上消失，这时执行的是A的 android:activityOpenExitAnimation A 启动 B 时，B 出现在屏幕上，这时执行的是B的 android:activityOpenEnterAnimation 从 B 返回A时，B从屏幕上消失，这时执行的是B的 android:activityCloseExitAnimation 从 B 返回A时，A 出现在屏幕上，这时执行的是A的 android:activityCloseEnterAnimation 3.3、定义具体动画文件 res/anmi/res/top_to_bottom_in.xml res/anmi/res/top_to_bottom_out.xml res/anmi/res/bottom_to_top_in.xml res/anmi/res/bottom_to_top_out.xml 这里不再介绍动画文件的实现。 3.4、应用到对应 ActivityAndroidMenifest.xml 12&lt;activity android:name=".MainActivity" android:theme="@style/AnimActivityTheme”&gt; 3.5、另外在使用AppTheme设置动画时发现了两个问题，3.5.1、添加动画后，出现从黑屏到新activity的过度。原因：没有设置相应的消失动画。 解决方法：设置相应的消失动画，如果不想设置消失动画，可以使用写一个假动画，这个动画是没有任何效果，只是为了避免出现黑屏，运行效果为原acticity静止不动，新启动的activity执行进入动画。 3.5.2、没有动画，或动画与设置不一致原因：当页面切换时需要进入和消失两个动画，当没有进入动画时，消失动画也不会执行，会执行系统动画，如果没有系统动画则没有动画，或者某个页面使用第一或第二种方式设置了动画（动画执行优先级，系统动画 &lt; AppTheme &lt; (overridePendingTransition\ActivityOptionsCompat)）。 解决方法：为了保证进入和消失都有动画，要将动画主题设置到两个Activity上。也可以将主题设置到application上，这样整个应用都是用该切换动画。如果是某个页面使用第一或第二种方式设置了动画，那么在启动和退出时最好都要设置，不然会造成启动和退出不一致的情况。 总结：第一种方式：灵活可以随意控进入消失动画，但是实现不方便。第二种方式：与第一种方式类似，但是该种方式为我们提供了多种特殊动画。第三种方式：使用方便，只需要配置主题，不需要添加过多代码，但是不够灵活 建议：定义一种动画主题，并设置到application上，将整个应用的切换动画统一，如果某个页面有特殊要求，再根据不用需求使用第一或第二种类型单独处理。]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android横竖屏切换]]></title>
    <url>%2Fposts%2Fa6a76007.html</url>
    <content type="text"><![CDATA[Android开发中，大多APP可能根据实际情况直接将APP的界面方向设死了，或竖屏或横屏。但是，我们还是会遇到横竖屏切换的功能需求，不管是通过物理重力感应触发，还是用户手动触发。所以，我们有必要去弄清楚Android中横竖屏切换到底做了什么。 Follow me …… 一、android:screenOrientation &amp; android:configChanges android:screenOrientation是用来设置 activity在设备上的显示方向的，只能是下面的唯一值： 值 描述 unspecified 默认值。系统自动选择屏幕方向 behind 跟activity堆栈中的下面一个activity的方向一致 landscape 横屏方向，显示的宽比高长 portrait 竖屏方向，显示的高比宽长 sensor 由设备的物理方向传感器决定，如果用户旋转设备，这屏幕就会横竖屏切换 nosensor 忽略物理方向传感器，这样就不会随着用户旋转设备而横竖屏切换了（”unspecified”设置除外） user 用户当前首选的方向 reverseLandscape API 9 以上，反向横屏 reversePortrait API 9 以上，反向竖屏 sensorLandscape API 9 以上，横屏，但是可以根据 物理方向传感器来切换正反向横屏 sensorPortrait API 9 以上，竖屏，但是可以根据 物理方向传感器来切换正反向竖屏 fullSensor API 9 以上，上下左右四个方向，由物理方向传感器决定 locked API 18 以上，锁死当前屏幕的方向 如果你上传应用到 Google Play，需要注意以下提示： Note: When you declare one of the landscape or portrait values, it is considered a hard requirement for the orientation in which the activity runs. As such, the value you declare enables filtering by services such as Google Play so your application is available only to devices that support the orientation required by your activities. For example, if you declare either”landscape”, “reverseLandscape”, or “sensorLandscape”, then your application will be available only to devices that support landscape orientation. However, you should also explicitly declare that your application requires either portrait or landscape orientation with the element. For example, . This is purely a filtering behavior provided by Google Play (and other services that support it) and the platform itself does not control whether your app can be installed when a device supports only certain orientations. android:configChanges用来设置 activity配置改变（不仅仅是屏幕方向，还有语言、地区等等）的集合。当一个配置改变在运行中发生时，activity默认情况下会先销毁然后重新创建。但是，如果通过这个属性声明了某个配置后，将可以避免上面的情况，而是依然运行，并回调 onConfigurationChanged() 方法。该属性可以设置多个值： 值 描述 mcc IMSI移动台的国家代码（MCC）发生变化——一个SIM被探测到并且更新MCC mnc IMSI移动台的网络代码（MNC）发生变化——一个SIM被探测到并且更新MNC locale 区域发生变化——用户选择了一个文本需要显示的新语言 keyboard 键盘类型发生变化——例如：用户插入了外接键盘。 keyboardHidden 键盘的可访问性发生变化——例如：用户发现了硬件键盘。 screenLayout 屏幕布局发生变化——这个会导致显示不同的Activity。 orientation 屏幕方向发生变化——用户旋转了屏幕。注意：如果应用程序的目标API级别是13或更高（通过属性minSdkVersion和属性targetSdkVersion声明），你也需要声明配置项screenSize，因为这将在设备选择肖像和屏幕方向时发生改变。 screenSize 当前可用屏幕大小发生变化。这代表一个当前可用大小的变化，和当前的比率相关，因此当用户选择不同的画面和图像，会发生变化。然而，如果你的程序目标API级别是12或更低，你的Activity总是会自己处理这个配置变化（这个变化不会引起Activity的重启，甚至在Android 3.2或更新的设备上）。在API级别13里加入的。 smallestScreenSize 物理屏幕大小的变化。不管方向的变化，仅仅在实际物理屏幕打包变化的时候，如：外接显示器。这个配置项的变化引起在smallestWidth configuration里的变化。然而，如果你的程序目标API级别是12或更低，你的Activity将自己处理这个变化（这个变化不会引起Activity的重启，甚至在Android 3.2或更新的设备上）在API级别13里加入的。 layoutDirection 布局方向变化。例如书写方式从左向右（LTR）转换为从右向左（RTL） 想了解更多就看官方文档。 二、横竖屏切换对Activity生命周期的影响通过打印Activity各个生命周期的执行情况，我们根据以下几种情况来分析： 1. 不配置 configChanges2. 配置 android:configChanges=&quot;orientation&quot;3. 配置android:configChanges=&quot;orientation|keyboardHidden&quot; 竖屏切横屏 1234567811-02 20:17:44.898 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-02 20:17:45.008 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-02 20:17:45.008 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-02 20:17:45.018 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-02 20:17:45.038 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 横屏切竖屏： 1234567811-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-02 20:19:00.318 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 从上面的 3种方式配置 打印的 Log （三种方式 Log是一样的，故合并显示），我们可以总结如下： 不设置Activity的android:configChanges时，或 设置Activity的android:configChanges=&quot;orientation&quot;时，或设置Activity的android:configChanges=&quot;orientation|keyboardHidden&quot;时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次方法。 而我们经常在其他地方看到的结论如下： 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 4. 所以是什么原因导致我们的结论不一样呢？需要说明的是：** 我的测试环境是 targetSdkVersion 24，测试模拟器是 系统API 5.0！** 查看官方文档，发现有如下提示： 注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本系统的应用时，若要避免由于设备方向改变而导致运行时重启（正如 minSdkVersion 和 targetSdkVersion 属性中所声明），则除了”orientation”值以外，您还必须添加 “screenSize”值。即，您必须声明 android:configChanges=”orientation|screenSize”。但是，如果您的应用是面向 API 级别 12 或更低版本的系统，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重启 Activity）。 我们现在测试第四种配置方式。 5. 配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 竖屏切横屏 111-02 20:44:06.568 7792-7792/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 横屏切竖屏 111-02 20:44:52.918 7792-7792/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 结论： 从 API 13开始，配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，才不会销毁 activity，且只调用 onConfigurationChanged方法。 6. 横竖屏切换小结 （一）、Android 3.2 （API 级别 13）以前1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 注意： 不设置Activity的android:configChanges时，切换竖屏activity的各个生命周期执行两次，有人说是 在API 2.x下，我未测试，大家可以考证下。 （二）、从 Android 3.2 (API级别 13)开始1、不设置Activity的android:configChanges，或设置Activity的android:configChanges=&quot;orientation&quot;，或设置Activity的android:configChanges=&quot;orientation|keyboardHidden&quot;，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次。2、配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，才不会销毁 activity，且只调用 onConfigurationChanged方法。 三、代码中动态切换横竖屏在代码中切换屏幕的方向主要调用 setRequestedOrientation（int requestedOrientation） 方法，此方法的作用等同于在 AndroidManifest.xml设置Activity 的android:screenOrientation，所以，其可传递的参数如 android:screenOrientation表格中一样。 示例代码： 1234567891011121314findViewById(R.id.btn_click).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.d(TAG,"被点击了"); //判断当前屏幕方向 if(getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &#123; //切换竖屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125;else&#123; //切换横屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125; &#125;&#125;); 非重启Activity模式：即设置了android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，Log输出（横竖屏切换一样） 1211-03 10:38:33.998 20317-20317/com.ys.yoosir.screenconfigchange D/MainActivity: 被点击了11-03 10:38:34.108 20317-20317/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 重启Activity模式：即没有设置android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，Log输出（横竖屏切换一样） 12345678911-03 10:59:23.268 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: 被点击了11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-03 10:59:23.428 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 注意： 通过 setRequestedOrientation（int requestedOrientation） 修改了屏幕方向后，就类似于设置了android:screenOrientation，效果是一样的，比如：调用setRequestedOrientation（ActivityInfo.SCREEN_ORIENTATION_PORTRAIT），无论屏幕怎么旋转，都不会切换屏幕方向。如果要恢复为响应横竖屏随物理方向传感器设备变换，那么就需要手动调用类似setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);代码进行恢复。 四、横竖屏切换我们需要做的事 重启Activity模式在重启Activity模式下，横竖屏切换的时候会导致数据丢失，我们可以通过如下代码来保正数据不丢失： 1234567891011121314151617181920 @Overrideprotected void onSaveInstanceState(Bundle outState) &#123; Log.d(TAG," -- onSaveInstanceState"); Log.d(TAG," -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture"); outState.putString("name","yoosir"); outState.putInt("age",24); outState.putBoolean("handsome",true); super.onSaveInstanceState(outState);&#125;.... @Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); Log.d(TAG," -- onRestoreInstanceState"); if(savedInstanceState != null) &#123; String name = savedInstanceState.getString("name"); int age = savedInstanceState.getInt("age"); boolean isHandsome = savedInstanceState.getBoolean("handsome"); Log.d(TAG, " -- onRestoreInstanceState get: name = " + name + ",age = " + age + ",handsome = " + isHandsome); &#125;&#125; 横竖屏切换Log 输出： 123456789101111-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture11-03 12:03:31.688 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-03 12:03:31.688 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-03 12:03:31.758 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-03 12:03:31.758 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate get: name = yoosir,age = 24,handsome = true11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState get: name = yoosir,age = 24,handsome = true11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 如上，大家可以看到在 onCreate() 中也是可以拿到我们之前保存的数据的。 补充一点： 如果大家在资源目录res 中添加了 layout-land（横向布局文件夹） 和 layout-port （竖想布局文件夹），重启Activity模式的横竖屏切换，系统会自动帮我们显示正确方向的布局UI。 非重启Activity模式非重启Activity模式下横竖屏切换，我们的Activity 不会销毁重建，数据也不会丢失。但是，如果我们想根据不同的屏幕方向来展示不同UI或做不同的事，应该怎么做呢？直接上代码： 12345678910111213141516171819@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.d(TAG," -- onConfigurationChanged"); if(newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)&#123; //切换到竖屏 //修改布局文件 setContentView(R.layout.activity_main); //findViewById .... //TODO something Log.d(TAG," -- onConfigurationChanged 可以在竖屏方向 to do something"); &#125;else&#123; //切换到横屏 //修改布局文件 setContentView(R.layout.activity_main); //findViewById .... //TODO something Log.d(TAG," -- onConfigurationChanged 可以在横屏方向 to do something"); &#125;&#125; 横竖屏切换Log 输出： 1211-03 14:56:50.465 28612-28612/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged11-03 14:56:50.495 28612-28612/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 可以在横屏方向 to do something 大家可以看到，在非重启Activity模式下，横竖屏切换修改UI布局文件时，其实挺麻烦的（我是这样的看法，^_~），需要重新初始化一遍UI。不过，不需要我们手动保存数据倒是挺方便的。 五、横竖屏切换对Fragment的影响打印 Activity 和 Fragment 各个生命周期，并在Activity 的 onCreate() 中添加如下代码： 12345678910//是否已经 add 了 Fragmentif(getSupportFragmentManager().findFragmentByTag("child") == null) &#123; Log.d(TAG, " -- onCreate has no child "); FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction(); blankFragment = BlankFragment.newInstance("one", "two"); fragmentTransaction.add(R.id.root_view, blankFragment, "child"); fragmentTransaction.commit();&#125;else&#123; Log.d(TAG, " -- onCreate has child ");&#125; 重建Activity模式Log： 带有 BlankFragment 即为 Fragment 的打印，其他则为 Activity 的打印进入Activity的Log： 我们可以关注下第 2 行log——-- onCreate has no child 1234567891011121311-03 17:56:19.465 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate - orientation11-03 17:56:19.525 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate has no child 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- newInstance 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onAttach 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreate 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreateView 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStart 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStart11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onResume11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onResume 11-03 17:57:02.285 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- one btn click 11-03 17:57:05.705 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- two btn click 横竖屏切换的Log： 1、我们关注一下 第17行 onCreate has child ，所以** Fragment 本身是没有被 destroy，它的views 是被destroy 的** 2、关注一下 第5、6、19 和 20 行，Fragment 的局部变量数据被销毁了，我们可以在onSaveInstanceState 保存数据，虽然 Fragment 不像 Activity 拥有 onRestoreInstanceState 方法，但是我们可以在 onActivityCreated 中获取之前保存的数据。 123456789101112131415161718192021222324252611-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onPause 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onPause11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onSaveInstanceState11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onSaveInstanceState 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onSaveInstanceState save str11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStop 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStop11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDestroyView 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDestroy 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDetach 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onDestroy11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onAttach 11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreate 11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate - orientation11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate get: name = yoosir,age = 24,handsome = true11-03 17:57:40.175 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate has child 11-03 17:57:40.175 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreateView 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated get 我设置了参数11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStart 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStart11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onRestoreInstanceState11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onRestoreInstanceState get: name = yoosir,age = 24,handsome = true11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onResume11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onResume 非重建Activity模式：横竖屏切换Log(进入Activity的Log 与 重建Activity模式一样 )：横竖屏切换时，Fragment 和 Activity 都只会调用 onConfigurationChanged 方法。 12345611-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onConfigurationChanged 11-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged11-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged 可以在横屏方向 to do something11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onConfigurationChanged 11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged 可以在竖屏方向 to do something 六、其他小技巧如果我们应用是手机和平板都可用的，且手机的只能是竖屏不可切换，平板的只能是横屏不可切换。首先，我们要区分设备是手机还是平板，然后设置屏幕方向。代码如下： 123456789101112131415161718/** * 判断是否平板设备 * @param context * @return true:平板,false:手机 */private boolean isTabletDevice(Context context) &#123; return (context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) &gt;= Configuration.SCREENLAYOUT_SIZE_LARGE;&#125;//设置屏幕方向private void setScreenOrientation(Context context)&#123; if(!isTabletDevice(context))&#123; //手机，竖屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125;else&#123; //平板，横屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125;&#125; 参考学习的文章：The Real Best Practices to Save/Restore Activity’s and Fragment’s state 《===== 重点推荐阅读 [译] 保存/恢复 Activity 和 Fragment 状态的最佳实践 《=== 上面一篇文章的译文 如何在Android设备旋转时暂存数据以保护当前的交互状态？ Android横竖屏切换小结 附图两张： 小小总结通过一步一步代码验证，我们终于明白了横竖屏切换时发生了什么，又可以愉快的写代码了，啦啦啦…，I AM CODER！若有错误的地方，欢迎大家指正和评论，谢谢！:-)]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awesome-comment神级注释]]></title>
    <url>%2Fposts%2F86664ecf.html</url>
    <content type="text"><![CDATA[一时兴起就收集了以下神注释，希望能为广大ITer带来快乐，缓解你们工作中的压力，下面开车，先自爆头像，下文会给出制作链接。 魔性图 123456789101112131415161718192021222324252627282930313233343536/** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 * 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 * 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 * 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 * 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 * 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 * 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 * 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 * 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己 * 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙 * 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙 * 丶十乙十十丶 丶丶亅十瓦鬼車瓦己 * 丶亅亅丶 亅日瓦日 * 丶 */ 就不卖关子了，图片转字符可以上这个传送门，白底的话会按空格补全，否则都为字符。 前面的传送门貌似出了点问题，下面再补上个新的传送门，也是很好用的，可以选择质量。 这不，下面的两只doge和一头滑稽就是产自于它，have fun，快去制作专属的字符注释吧。 再补上一个好玩的网站Ascii World，由于这网站的图形太多了，我就不贴上来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738/** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM&amp;59M#As..,,,,:,is, * .rr,,,;9&amp;1 hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s; r9&amp;BMHBHMB9: . .,,,,;ri. * :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */ /** * ii. ;9ABH, * SA391, .r9GG35&amp;G * &amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:&amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB&amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1&amp;@@@@@@MXs. . .,,:,:&amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s&amp;: .... .sS553B@@HX3s;,. .,;13h. .:::&amp;1 * SXr . ...;s3G99XA&amp;X88Shss11155hi. ,;:h&amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi * 1831, .,;irrrrrs&amp;@ * ;5A8r. .:;iiiiirrss1H * :X@H3s....... .,:;iii;iiiiirsrh * r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1 * ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h * 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h * i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111 * 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111 *//** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM&amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;&amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ /** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ *//** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ____/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * * ............................................. * 佛祖保佑 永无BUG *//** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ *//** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ___/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * ............................................. * 佛曰：bug泛滥，我已瘫痪！ *//** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ *//** * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::' * '::::::::::::' * .:::::::::: * '::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::' .:::. * ::::' ':::::' .::::::::. * .::::' :::: .:::::::'::::. * .:::' ::::: .:::::::::' ':::::. * .::' :::::.:::::::::' ':::::. * .::' ::::::::::::::' ``::::. * ...::: ::::::::::::' ``::. * ```` ':. ':::::::::' ::::.. * '.:::::' ':'````.. *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ &gt; &lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! *//** * ___====-_ _-====___ * _--^^^#####// \\#####^^^--_ * _-^##########// ( ) \\##########^-_ * -############// |\^^/| \\############- * _/############// (@::@) \\############\_ * /#############(( \\// ))#############\ * -###############\\ (oo) //###############- * -#################\\ / VV \ //#################- * -###################\\/ \//###################- * _#/|##########/\######( /\ )######/\##########|\#_ * |/ |#/\#/\#/\/ \#/\##\ | | /##/\#/ \/\#/\#/\#| \| * ` |/ V V ` V \#\| | | |/#/ V ' V V \| ' * ` ` ` ` / | | | | \ ' ' ' ' * ( | | | | ) * __\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! *//** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \_|// |||\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \/ ||| \\ _/~~- * __---~~~.==~||\=_ -_--~/_-~|- |\\ \\ _/~ * _-~~ .=~ | \\-_ '-~7 /- / || \ / * .~ .~ | \\ -_ / /- / || \ / * / ____ / | \\ ~-_/ /|- _/ .|| \ / * |~~ ~~|--~~~~--_ \ ~==-/ | \~--===~~ .\ * ' ~-| /| |-~\~~ __--~~ * |-~~-_/ | | ~\_ _-~ /\ * / \ \__ \/~ \__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ '.|||' -_| ~~-/ , . _|| * -_ ~\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\ * 神兽保佑 * 代码无BUG! *//** _ * _._ _..._ .-', _.._(`)) * '-. ` ' /-._.-' ',/ * ) \ '. * / _ _ | \ * | a a / | * \ .-. ; * '-('' ).-' ,' ; * '-; | .' * \ \ / * | 7 .__ _.-\ \ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ '`-' *//** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-" "-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * | "=._"(_ ^^ _)"_.=" | * * | "=\__|IIIIII|__/=" | * * | _.="| \IIIIII/ |"=._ | * * | _ _.="_.="\ /"=._"=._ _ | * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * | &gt; _.=" "=._ &lt; | * * | (_/ \_) | * * | | * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * ************************************************************** *//** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ *//** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ *//** * ,%%%%%%%%, * ,%%/\%%%%/\%% * ,%%%\c "" J/%%% * %. %%%%/ o o \%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%' * // ;%%%%`\-/%%%' * (( / `%%%%%%%' * \\ .' | * \\ / \ | | * \\/ ) | | * \ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |'_ \ * \ V /| |\ V /| | (_| | | | | * \_/ |_| \_/ |_|\__,_|_| |_| *//** * https://gold.xitu.io/ * １１１ １ * １１１ １１１１１１１１１１１１ １１１ * １１ １１１１１１１１１１１１ １１１１１ * １１ １１１ １１ １１１１１１１ * １１１１ １ １１１１１１１１１１１ １１１ １１１１ * １１１１１１ １１１１１１１１１１１ １１１１ １１１１１ * １１１１１１ １１ １１１１ １１１１１１ * １１ １１１１１１１１ １１ １１１１１１１１１１１１１１１１１１ * １１ １１１１１１１１１１１ １１１１１１１１１１１１１１１１１１１ * １１１１１１１１１ １１ １１ １１ １１ * １１１１１１１１１１１１１１１１１１ １１ * １１１１ １１１１１１１１１１１１ １１１１１１１１１１１１１１ * １１１１ １１ １１ １１１１１１１１１１１１１１ * １１ １１ １１ １１ １１１ １１ １１ １１１ * １１ １１ １１ １１ １１ １１１ １１ １１１ * １１ １１１ １１ １１ １１ １１１ １１ １１１ * １１１１ １１１ １１１１１１１１１ １１ １１１ １１ １１１１１１１ * １１１１１１ １１１１１１１１１１ １１１１１１１１１１１１１１１１１ * １１ １１１ １１１ １１１１１１１１１１１１１１１１１ *//** * https://www.zhihu.com/ * _____ _____ _____ _____ * /\ \ /\ \ /\ \ /\ \ * /::\____\ /::\ \ /::\ \ /::\ \ * /:::/ / \:::\ \ /::::\ \ /::::\ \ * /:::/ / \:::\ \ /::::::\ \ /::::::\ \ * /:::/ / \:::\ \ /:::/\:::\ \ /:::/\:::\ \ * /:::/____/ \:::\ \ /:::/__\:::\ \ /:::/__\:::\ \ * /::::\ \ /::::\ \ /::::\ \:::\ \ /::::\ \:::\ \ * /::::::\ \ _____ ____ /::::::\ \ /::::::\ \:::\ \ /::::::\ \:::\ \ * /:::/\:::\ \ /\ \ /\ \ /:::/\:::\ \ /:::/\:::\ \:::\____\ /:::/\:::\ \:::\ \ * /:::/ \:::\ /::\____\/::\ \/:::/ \:::\____\/:::/ \:::\ \:::| |/:::/__\:::\ \:::\____\ * \::/ \:::\ /:::/ /\:::\ /:::/ \::/ /\::/ |::::\ /:::|____|\:::\ \:::\ \::/ / * \/____/ \:::\/:::/ / \:::\/:::/ / \/____/ \/____|:::::\/:::/ / \:::\ \:::\ \/____/ * \::::::/ / \::::::/ / |:::::::::/ / \:::\ \:::\ \ * \::::/ / \::::/____/ |::|\::::/ / \:::\ \:::\____\ * /:::/ / \:::\ \ |::| \::/____/ \:::\ \::/ / * /:::/ / \:::\ \ |::| ~| \:::\ \/____/ * /:::/ / \:::\ \ |::| | \:::\ \ * /:::/ / \:::\____\ \::| | \:::\____\ * \::/ / \::/ / \:| | \::/ / * \/____/ \/____/ \|___| \/____/ *//** * http://www.freebuf.com/ * _.._ ,------------. * ,' `. ( We want you! ) * / __) __` \ `-,----------' * ( (`-`(-') ) _.-' * /) \ = / ( * /' |--' . \ * ( ,---| `-.)__` * )( `-.,--' _`-. * '/,' ( Uu", * (_ , `/,-' ) * `.__, : `-'/ /`--' * | `--' | * ` `-._ / * \ ( * /\ . \. freebuf * / |` \ ,-\ * / \| .) / \ * ( ,'|\ ,' : * | \,`.`--"/ &#125; * `,' \ |,' / * / "-._ `-/ | * "-. "-.,'| ; * / _/["---'""] * : / |"- ' * ' | / * ` | *//** * https://campus.alibaba.com/ * `:::::::::::, * `::;:::::::;:::::::, ` * `::;;:::::::@@@@;:::::::` * ,:::::::::::::@ #@':::::` * :::::::::::::::'@@ @;:::: * ::::::::::::'@@@@'``` .+:::` * ::::::::::;@@@#. ,:::, * .::::::::+@#@` :::: * :::::::+@@' :::: * `:::::'@@: `:::. * ,::::@@: ` :::: * ;::::::@ .:::; * :;:::::;@` ` :::; * :::::::::@` @ ;:::: * :::::::::#` @` ,:::: * :::::::::@` +@ @ .::::` * .::::::'@@` `@@' @ ::::, * :::::::++@@@@@@@@@@. ::::; * ;:::::::+, `..` ::::: * ,::::::::', ::::: * :::::::::+, :::::` * :::::::::+@. ,::::.` `, * ::::::;;@+ .::;:: `; * :::::::@@ `:::;: `::`` * ::::::#@ ;:::: .::` * :::::;@ :::::` .;::` * :::::@ `:;::: `::::; * :::::# :::::. `,;::::: * :::::: ` ::::::,.,::::::::::. * ,::::::` .:: ::::::::::::::::;` * ;::::::::,````.,:::::, ::::::::::::::. * :::::::::::::::::: ` `::::::::::` * `::::::::::::, .:::. * `..` *//** * http://www.flvcd.com/ * .--, .--, * ( ( \.---./ ) ) * '.__/o o\__.' * &#123;= ^ =&#125; * &gt; - &lt; * / \ * // \\ * //| . |\\ * "'\ /'"_.-~^`'-. * \ _ /--' ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 *//** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 *//** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 *//** * /88888888888888888888888888\ * |88888888888888888888888888/ * |~~____~~~~~~~~~"""""""""| * / \_________/"""""""""""""\ * / | \ \ * / | 88 88 \ \ * / | 88 88 \ \ * / / \ | * / | ________ \ | * \ | \______/ / | * /"\ \ \____________ / | * | |__________\_ | | / / * /""""\ \_------' '-------/ -- * \____/,___________\ -------/ * ------* | \ * || | \ * || | ^ \ * || | | \ \ * || | | \ \ * || | | \ \ * \| / /"""\/ / * ------------- | | / * |\--_ \____/___/ * | |\-_ | * | | \_ | * | | \ | * | | \_ | * | | ----___ | * | | \----------| * / | | ----------""\ * /"\--"--_| | | \ * |_______/ \______________/ ) * \___/ *//** * d*##$. * zP"""""$e. $" $o * 4$ '$ $" $ * '$ '$ J$ $F * 'b $k $&gt; $ * $k $r J$ d$ * '$ $ $" $~ * '$ "$ '$E $ * $ $L $" $F ... * $. 4B $ $$$*"""*b * '$ $. $$ $$ $F * "$ R$ $F $" $ * $k ?$ u* dF .$ * ^$. $$" z$ u$$$$e * #$b $E.dW@e$" ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#" . zo$&gt; #$r .uF * $L .u$*" $&amp;$$$k .$$d$$F * $$" ""^"$$$P"$P9$ * JP .o$$$$u:$P $$ * $ ..ue$" "" $" * d$ $F $ * $$ ....udE 4B * #$ """"` $r @$ * ^$L '$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $"" $F * '$ $ * $L $ * '$ $ * $ $ *//** * ,----------------, ,---------, * ,-----------------------, ," ,"| * ," ,"| ," ," | * +-----------------------+ | ," ," | * | .-----------------. | | +---------+ | * | | | | | | -==----'| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ," * | `-----------------' |," .;'| |(((( | ," * +-----------------------+ ;; | | |," * /_)______________(_/ //' | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \,"----------- * / ==ooooooooooooooo==.o. ooo= // ,`\--&#123;)B ," * /_==__==========__==_ooo__ooo=_/' /___________," * *//** * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.' ~. .~ `.__ * .'// \./ \\`. * .'// | \\`. * .'// .-~"""""""~~~~-._ | _,-~~~~"""""""~-. \\`. * .'//.-" `-. | .-' "-.\\`. * .'//______.============-.. \ | / ..-============.______\\`. * .'______________________________\|/______________________________`. * *//** 无可奉告 一颗赛艇 * uJjYJYYLLv7r7vJJ5kqSFFFUUjJ7rrr7LLYLJLJ7 * JuJujuYLrvuEM@@@B@@@B@B@B@@@MG5Y7vLjYjJL * JYjYJvr7XM@BB8GOOE8ZEEO8GqM8OBBBMu77LLJ7 * LJLY7ru@@@BOZ8O8NXFFuSkSu25X0OFZ8MZJ;vLv * YvL7i5@BM8OGGqk22uvriiriii;r7LuSZXEMXrvr * vv7iU@BMNkF1uY7v7rr;iiii:i:i:ii7JEPNBPir * L7iL@BM8Xjuujvv77rr;ri;i;:iiiii:iLXFOBJ: * 7ri@B@MOFuUS2Y7L7777rii;:::::i:iirjPG@O: * 7:1B@BBOPjXXSJvrL7rr7iiii:i::::i;iv5MBB, * r:0@BBM8SFPX2Y77rri::iirri:::::iii75O@G. * 7:SB@BBGqXPk0122UJL::i::r:::i:i;i:v2@Bk. * ri:MB@BBEqEMGq2JLLL1u7.iX51u77LF27iSB@r, * ri,v@B@MB8@qqNEqN1u:5B8BOFE0S7ii7qMB@F:: * ii,J80Eq1MZkqPPX5YkPE@B@iXPE52j7:vBjE7:: * ii:7MSqkS0PvLv7rrii0@L.Z1iLr::ir:rO,vi:: * ii::EZXPSkquLvii:iF@N:.,BUi7ri,::UY;r::: * i::.2ONXqkPXS5FUUEOPP;..iSPXkjLYLLrr:::, * :::,iMXNP0NPLriiLGZ@BB1P87;JuL7r:7ri:::, * :::,.UGqNX0EZF2uUjUuULr:::,:7uuvv77::::. * ::::..5OXqXNJ50NSY;i:.,,,:i77Yvr;v;,,::. * :::,:.jOEPqPJiqBMMMO8NqP0SYLJriirv:.:,:. * ,:,,,.,Zq0P0X7vPFqF1ujLv7r:irrr7j7.,,::. * ,,,....0qk0080v75ujLLv7ri:i:rvj2J...,,,. * ......8@UXqZEMNvJjr;ii::,:::7uuv...,.,,. * .....B@BOvX88GMGk52vririiirJS1i.......,. * .JEMB@B@BMvL0MOMMMO8PE8GPqSk2L:......... * @B@@@B@M@B@L:7PGBOO8MOMOEP0Xri@B@Mk7,... * B@B@BBMBB@B@0::rJP8MO0uvvu7..,B@B@B@B@Z7 * MMBM@BBB@B@B@Br:i,..:Lur:....7@OMMBM@B@@ * 8OOMMMOMMMMBB@B:....,PZENNi..JBOZ8GMOOOO */ 神注释 1234/** * 这个公司没有年终奖的,兄弟别指望了,也别来了,我准备辞职了 * 另外这个项目有很多*Bug* 你坚持不了多久的,拜拜! */ 123456789101112131415161718192021222324252627282930313233/** * 1只羊 == one sheep * 2只羊 == two sheeps * 3只羊 == three sheeps * 4只羊 == four sheeps * 5只羊 == five sheeps * 6只羊 == six sheeps * 7只羊 == seven sheeps * 8只羊 == eight sheeps * 9只羊 == nine sheeps * 10只羊 == ten sheeps * 11只羊 == eleven sheeps * 12只羊 == twelve sheeps * 13只羊 == thirteen sheeps * 14只羊 == fourteen sheeps * 15只羊 == fifteen sheeps * 16只羊 == sixteen sheeps * 17只羊 == seventeen sheeps * 18只羊 == eighteen sheeps * 19只羊 == nineteen sheeps * 20只羊 == twenty sheeps * 21只羊 == twenty one sheeps * 22只羊 == twenty two sheeps * 23只羊 == twenty three sheeps * 24只羊 == twenty four sheeps * 25只羊 == twenty five sheeps * 26只羊 == twenty six sheeps * 27只羊 == twenty seven sheeps * 28只羊 == twenty eight sheeps * 29只羊 == twenty nine sheeps * 30只羊 == thirty sheeps * 现在瞌睡了吧，好了，不要再改下面的代码了，睡觉咯~~ */ 12345678910111213/** * You may think you know what the following code does. * But you dont. Trust me. * Fiddle with it, and youll spend many a sleepless * night cursing the moment you thought youd be clever * enough to "optimize" the code below. * Now close this file and go play with something else. *//** * 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。 * 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。 * 现在请关闭这个文件去玩点别的吧。 */ 12345678/** * somedev1 - 6/7/02 Adding temporary tracking of Login screen * somedev2 - 5/22/07 Temporary my ass *//** * 一些修改1 - 2002/6/7 增加临时的跟踪登录界面 * 一些修改2 - 2007/5/22 我临时的犯傻 */ 1234567/** * 程序员1（于2010年6月7日）：在这个坑临时加入一些调料 * 程序员2（于2011年5月22日）：临你个屁啊 * 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕 * 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！ * 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you're died */ 1234567891011121314/** * For the brave souls who get this far: You are the chosen ones, * the valiant knights of programming who toil away, without rest, * fixing our most awful code. To you, true saviors, kings of men, * I say this: never gonna give you up, never gonna let you down, * never gonna run around and desert you. Never gonna make you cry, * never gonna say goodbye. Never gonna tell a lie and hurt you. *//** * 致终于来到这里的勇敢的人： * 你是被上帝选中的人，是英勇的、不敌辛苦的、不眠不休的来修改我们这最棘手的代码的编程骑士。 * 你，我们的救世主，人中之龙，我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己， * 永远不要哭啼，永远不要说再见，永远不要说谎来伤害自己。 */ 123456789101112131415161718/** * Dear maintainer: * * Once you are done trying to 'optimize' this routine, * and have realized what a terrible mistake that was, * please increment the following counter as a warning * to the next guy: * * total_hours_wasted_here = 42 *//** * 亲爱的维护者： * * 如果你尝试了对这段程序进行'优化' * 下面这个计数器的个数用来对后来人进行警告 * * 浪费在这里的总时间 = 42h */ 12Exception up = new Exception("Something is really wrong.");throw up; //ha ha 12345678/** * When I wrote this, only God and I understood what I was doing * Now, God only knows *//*** 写这段代码的时候，只有上帝和我知道它是干嘛的* 现在，只有上帝知道*/ 1stop(); // Hammertime! 1// Autogenerated, do not edit. All changes will be undone. 12// sometimes I believe compiler ignores all my comments// 有时候我相信编译器忽略了我所有的注释 12345/** * I dedicate all this code, all my work, to my wife, Darlene, who will * have to support me and our three children and the dog once it gets * released into the public. */ 12// drunk, fix later// 有点晕了，以后再修改 12// Magic. Do not touch.// 麻鸡。勿动。 1#define TRUE FALSE// Happy debugging suckers 1// I'm sorry. 1return 1; # returns 1 123456/** * Always returns true. */public boolean isAvailable() &#123; return false;&#125; 12&lt;!-- Here be dragons --&gt;&lt;!-- 前方高能 --&gt; 12double penetration; // ouch// 自行了解，不方便解释 123456// To understand recursion, see the bottom of this fileAt the bottom of the file:// To understand recursion, see the top of this file// 想要明白递归须看文件末尾到了文末// 想要明白递归须看文件顶部 1/* Please work */ 12long long ago; /* in a galaxy far far away */// 很久很久以前 在一个遥远的银河中（出自星球大战） 1234// This code sucks, you know it and I know it. // Move on and call me an idiot later.// 你我都知道这代码很烂// 先不要骂我2B了，请先继续往下看 12// I am not sure why this works but it fixes the problem.// 虽然我不知道为什么这样管用，但它却是修复了问题 12// If this comment is removed the program will blow up// 如果删了此处注释程序就炸了 12// This function has been here since 1987. DON'T FXXKING TOUCH IT// 这函数1987年就这在了，别他娘动它 12// if i ever see this again i'm going to start bringing guns to work// 如果要是再让我看见这样的代码，也许我会带着一把枪来上班 1234// no comments for you// it was hard to write// so it should be hard to read// 难写的代码，肯定很难读。因此，我没有注释留给你。 12// I will give you two of my seventy-two virgins if you can fix this.// 要是你能修正这个问题的话，我会在我的七十二个处女中挑两个送你 123// I am not responsible of this code.// They made me write it, against my will.// 下面的代码，我不负责。因为是他们逼我写的，违背了我的意愿。 12/* You are not expected to understand this *//* 你绝不会明白的 */ 12// I have to find a better job// 看来我需要找份更好的工作了 123/** * 这个类是Object的子类 */]]></content>
      <categories>
        <category>Android</category>
        <category>注释模板</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>注释模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构，如何巧妙设计？]]></title>
    <url>%2Fposts%2Fda9c2260.html</url>
    <content type="text"><![CDATA[重构不止是代码整理，它提供了一种高效且受控的代码整理技术 （一）重构原则1、何谓重构对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 另一种解释是：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 2、为何重构改进软件设计：如果没有重构，程序的设计会逐渐变质，重构很像是在整理代码，你所做的就是让所有的东西回到应处的位置上。帮助找到bug：对代码进行重构，可以深入理解代码的作为，在搞清楚程序结构的同时，想不把bug揪出来都难。提高编程速度：良好的设计是快速开发的根本，改善设计、提高可读性，减少错误，这些都是提高质量。 3、何时重构任何情况下我都反对专门拨出时间进行重构。重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地的进行。 三次法则 第一次做某件事情是只管去做；第二次做类似的事情会产生反感；第三次再做类似的事，你就应该重构 最常见的重构时机是想给软件添加新特性的时候； 重构的另个一原动力是：代码的设计无法帮助我轻松的添加所需要的特性 修改错误的时候，review代码的时重构 间接层和重构 计算机科学是这样一门科学：它相信所有的问题都可以通过增加一个间接层来解决。 大多数重构都为程序引入了更多的间接层，重构往往把大型的对象拆成多个小型的对象，把大型的函数拆成多个小型的函数。但是，间接层是一把双刃剑。每次把一个东西分成两份，你就需要多管理一个东西。如果某个对象委托另一个对象，后者又委托另一个对象，程序会愈加难以阅读。 何时不该重构：有时候既有代码实在太混乱，重构它还不如重新写一个来得简单。 重写而非重构的一个清楚讯号是：现有代码根本不能正常运作。 （二）代码的坏味道1、重复代码如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将它们合二为一，程序会变得更好 。 同一个类中有相同的表达式：提炼出重复的代码，然后让两个地方都调用被提炼出来的那一段代码； 两个互为兄弟的子类内含有相同的表达式：提炼出相同代码，将它推入超类内； 两个毫不相干的类中出现：将重复的代码提炼到一个独立的类中。 2、过长的类拥有短函数的对象活得比较好、比较长。 间接层所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型函数支持的。 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。 如何确定提炼哪一段代码？寻找注释是一个很好的技巧。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是提醒你：可以将这段代码替换成一个函数。 条件表达式和循环常常也是提炼的信号。 3、过大的类如果想利用单个类做太多的事情，其内往往就会出现太多实力变量。类内如果有太多代码，也是代码重复、混乱病最终走向死亡的源头。 4、过长参数列太长的参数列难以理解，太多的参数会造成前后不一致、不容易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给函数，大多数修改都将没有必要。 5、发散式变化如果某个类经常因为不同的原因在不同的方向上发生变化，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因为一种变化而需要修改。 6、散弹式修改如果没遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是散弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。 把所有需要修改的代码放进同一个类中，如果眼下没有合适的类可以安置这些代码就创造一个。 7、依恋情结对象技术的要点在于：将数据和对数据的操作行为包装在一起.有一种经典的气味是：函数对某个类的兴趣高过对自己所处类的兴趣。某个函数为了计算某个值，从另一个对象那调用几乎半打的取值函数。 一个函数往往会用到几个类的功能，那么它该置于何处？我们的原则是：判断哪个类拥有最大被此函数使用的数据，然后就把这个函数和那些数据放在一起。 8、数据泥团很多地方看到相同的三四项数据一起出现。这些总是绑在一起出现的数据应该拥有属于他们自己的对象。 首先找到这些数据以字段形式出现的地方，将它们提炼到一个独立的对象中。这么做的直接好处是可以将很多参数列缩短简化函数调用。 9、基本类型偏执对象的一个极大价值在于：它们模糊了横旦与基本数据和体积较大的类之间的界限 对象技术的新手通常不愿意在小任务上运用小对象——结合数值和比重的money类、有一个起始值和一个结束值组成的range类。将原本单独存在的数值替换成对象，从而走出传统的洞窟，进入炙手可热的对象世界。 10、switch惊悚现身面向对象的一个最明显的特征是：少用switch语句一看到switch语句，就应该考虑以多态来替换它。 如果只是在单一函数中有些选择实例，且并不想改动它们，那么多态就有点杀鸡用牛刀了。 11、平行集成体系每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。 12、冗余类某个类原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作，这个时候请让这个类庄严赴义吧。 13、夸夸其谈未来性企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种怀味道就出现了。如果用到了那就值得去做，如果用不到那就不值得，只会挡你的路，所以把它挪开吧。 如果你的某个抽象类其实没有起到太大的作用，函数上的某些参数未被使用…可以移除它们了。 14、令人迷惑的暂时字段某个实例变量仅为某种特定的情况而设。这样的代码让人不易理解。在变量未被使用的情况下猜测当初其设置目的，会让你发疯的。 15、过度耦合消息链如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另个一对象……..这就是消息链。采用这种方式，意味着客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应的修改。 16、中间人封装往往伴随着委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。 17、狎昵关系有时会看到两个类过于亲密，话费太多的时间去探究彼此的private成分。过分狎昵的类必须拆散，帮它们划清界线，从而减少狎昵行径。继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让孩子独立生活了，让他离开继承。 18、异曲同工的类两个函数做同一件事，却有着不同的签名。 19、不完美的类库类库函数构造的不够好，又不能修改它们： 如果只想修改类的一两个函数，可以引入外加函数。如果想要添加一大堆额外行为，建立一个新类包含这些额外行为，让其成为子类。 20、纯稚的数据类纯稚的数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。 封装public字段; 恰当封装容器类字段; 移除不应修改的字段的设置函数; 提炼调用函数以隐藏取值/设值函数; 21、被拒绝的遗赠子类只运用了父类的一部分函数和数据。 为子类建立一个兄弟类,将所有用不到的字段/函数下移至兄弟类,保证超类的纯粹; 22、过多的注释注释之所以存在是因为代码很糟糕 。注释的最高境界——代码即注释。 当你感觉需要撰写注释时，请先尝试重构，试着让所有的注释都变得多余。 （三）重新组织函数1、提炼函数动机：看到一个过长的函数或者一段需要注释才能让人理解用途的代码，将这段代码放一个独立的函数中；做法： 创造一个新函数，根据这个函数的意图来命名它； 只要新函数的名称能够以更好的方式昭示代码意图，你也应该提炼它。但如果想不到一个更有意义的名称就别动 将提炼的代码从原函数复制到新建的目标函数中；将被提炼代码段中需要读取的局部变量，当作参数传递给目标函数；在源函数中，将被提炼代码段替换为目标函数调用。 2、内联函数一个函数的本体与名称同样清楚易懂。在函数调用点插入函数本体，然后移除该函数。动机： 一群组织不甚合理的函数。你可以将它们都内联到一个大函数中，再从中提炼出组织合理的小型函数。使用的太多的间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在委托动作之间晕头转向。 做法： 1、检查函数，确定不具备多态；如果子类继承了这个函数，就不要将此函数内联，因为子类无法复写一个根本不存在的函数。 2、找出这个函数的所有调用点；3、将这个函数的所有调用点都替换成函数本体。3、内联临时变量有一个临时变量，只被一个简单的表达是赋值一次，而它妨碍了其他重构手法。将所有对该变量的引用动作，替换为对它赋值的那个表达式自身double basePrice = anOrder.basePrice();return (base &gt; 10000 ); 替换为： return (anOrder.basePrice &gt; 1000); 4、以查询取代临时变量你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立的函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。 123456double basePrice = quantity * timePrice;if(basePrice &gt; 1000)&#123; return basePrice * 09.5;&#125; else &#123; return basePrice * 0.98;&#125; 替换为： 12345678if(basePrice() &gt; 1000)&#123; return basePrice * 09.5;&#125; else &#123; return basePrice * 0.98;&#125;double basePrice()&#123; return quantity * timePrice;&#125; 临时变量只在所属的函数中可见，如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个份信息，这将带给你极大的帮助，使你能够为这个类编写更清晰的代码。 5、引入注释性变量你有一个复杂的表达式。将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。 123if ((platform.toUpperCase().indexOf("MAC") &gt; -1) &amp;&amp; (browser.toUpperCase().indexOf("IE") &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt;0)&#123; //do smothing&#125; 替换为： 123456final boolean isMacOs = platform.toUpperCase().indexOf("MAC") &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf("IE") &gt; -1;final boolean wasResized = resize &gt;0;if(isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123; //do smothing&#125; 表达式有可能非常复杂难以理解。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。 在条件逻辑中，你可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。另一种情况是：在较长的算法中，可以运用临时变量来解释每一步运算的意义。 6、分解临时变量你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。 针对每次赋值，创造一个独立、对应的临时变量。 1234double temp = 2 * (height + width);System.out.println(temp);temp = height * width;System.out.println(temp); 替换为： 1234double perimeter = 2 * (height + width);System.out.println(perimeter);double area = height * width;System.out.println(area); 如果临时变量被赋值超过一次，就意味着它们在函数中承担了一个以上的责任。如果临时变量承担多个责任，它就应该被替换为多个临时变量。每个变量只承担一个责任，同一个临时变量承担两件不同的事情会令代码阅读者糊涂 7、移除对参数的赋值代码对一个参数进行复制。以一个临时变量取代该参数的位置。 123int discount (int inputVal, int quantity, int yearToData)&#123; if(inputVal &gt; 50) inputVal -= 2;&#125; 替换为： 1234int discount (int inputVal, int quantity, int yearToData)&#123; int result = inputVal; if(inputVal &gt; 50) result -= 2;&#125; 如果代码的语义是按引用传递的，请在调用段检查调用后是否还使用了这个参数。 8、替换算法想要把某个算法替换为另一个更清晰的算法。将函数本体替换成为另一个算法。 1234567891011121314String foundPerson(String[] people)&#123; for(int i = 0;i &lt; people.length; i++)&#123; if(people[i].equals("Don"))&#123; return "Don"; &#125; if(people[i].equals("John"))&#123; return "John"; &#125; if(people[i].equals("Kent"))&#123; return "Kent"; &#125; &#125; return "";&#125; 替换为： 123456789String foundPerson(String[] people)&#123; List candidates = Arrays.asList(new String[]&#123;"Don", "John", "Kent"&#125;); for(int i = 0;i &lt; people.length; i++)&#123; if(candidates.contains(people[i]))&#123; return prople[i]; &#125; &#125; return "";&#125; （四）在对象之间搬移特性在对象设计过程中，决定把责任放在哪儿是即使不是最重要的事，也是最重要的事之一。 常常只使用搬移函数和搬移字段简单地移动对象行为，就可以解决这些问题。如果这两个重构手法都需要用到，我会首先使用搬移字段，再使用搬移方法。 如果一个类承担了太多责任而变得臃肿不堪，这种情况下会使用提炼类将一部分责任分离出去。如果一个类变得太不负责任，使用将类内联化将它融入到另一个类中。 1、搬移函数你的程序中，有个函数与其所驻类之外的另个一类进行跟过的交流：调用后者或被后者调用。在该函数最长引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或者将旧函数完全移除。如果一个类有太多行为，或如果一个类与另一个类有太多合作而高度耦合，就需要搬移函数。可以是系统中的类更简单 2、搬移字段程序中，某个字段被其所驻类之外的另一个类更多的用到。在目标类新建一个字段，修改原字段的所有用户，令他们改用新字段 3、提炼类某个类做了应该由两个类做的事。建立一个新类，将相关字段和函数从就类搬到新类。 4、将类内联化某个类没有做太多的事情，不在承担足够责任，不再有的那单独存在的理由。将这个类的所有特性搬移到另一个类中，然后移除原类。 5、隐藏“委托关系”客户通过一个委托类来调用另一个对象。在服务类上建立客户所需要的所有函数，用来隐藏委托关系。 封装意味每个对象都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的对象就会比较少。 如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数。那么客户就必须知晓这一层委托关系。万一委托关系变化，客户也要相应变化。 6、移除中间人某个类做了过多的简单委托。让客户直接调用委托类。每当客户要使用手委托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受委托类的特性越来越多，这一过程会让你很痛苦。 7、引入外加函数你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。 1Date newStart = new Date(year, month, date + 1); 替换为： 1234Date newStart = nextDay(nowDate);private static Date nextDay(Date arg)&#123; retrun new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);&#125; 如果可以修改源码，你可以自行添加一个新函数；如果不能，你就得在客户端编码，补足你要的那个函数 8、引入本地扩展你需要为服务类踢狗一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。 ##（五）重新组织数据 1、自封装字段直接访问一个字段。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。 1234private int low, high;boolean includes(int arg)&#123; retrun arg &gt;= low &amp;&amp; arg &lt;= high;&#125; 替换为： 12345678910private int low, high;boolean includes(int arg)&#123; retrun arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();&#125;int getLow()&#123; retrun low;&#125;int getHigh()&#123; return high;&#125; 在“字段访问方式”这个问题上，存在两种截然不同的观点： 在该变量定义所在的类中，你可以自由的访问。 即使在这个类中你也应该只使用访问函数间接访问。*间接访问的好处是：子类可以通过复写一个函数而改变获取数据的途径；它支持更灵活的数据管理方式，例如延迟初始化。 2、以对象取代数据值你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变为对象。 一开始你肯能会用一个字符串来表示“电话号码”概念，但是随后你会发现，电话号码需要“格式化”、“区号”之类的行为。这时候就需要为带替换的数值新建一个类。 3、将值对象改为引用对象你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。 4、将引用对象改为值对象你有一个引用对象，很小且不可改变，而且不易管理。将它变成一个值对象。 5、以对象取代数组你有一个数组，其中的元素各自代表不同的东西。以对象替换数组。对于数组中的每个元素，以一个字段来表示 6、复制“被监视数据”你有一些领域数据置身GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。 7、将单向关联改为双向关联两个类都需要使用对方特性，但其间只有一条单向连接。添加一个反向指针，并使修改函数能够同时更新两条连接。 8、将双向关联改为单向关联两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。 9、以字面常量取代魔数你有一个字面数值，带有特别含义。 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为常量。 10、封装字段你的类中存在一个public字段。将它声明为private，并提供相应的访问函数。 11、封装集合有个函数返回一个集合。让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。 ##（六）简化条件表达式 1、分解条件表达式有一复杂的条件语句。从if、then、else三个段落中分别提炼出独立函数。 2、合并表达式你有一系列条件测试，都得到相同结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼成一个独立函数。 3、合并重复的条件代码在表达式的每个分支上都执行了相同的一段代码。 将这段重复代码搬移到条件表达式之外。 4、移除控制标记在一系列布尔表达式中,某个变量带有”控制标记”的作用。 以break/return语句取代控制标记。 5、以多态取代条件表达式有个条件表达式根据对象类型的不同而选择不同的行为。 将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数 （七）简化函数调用1、函数改名函数的名称未能揭示其用途。 修改函数名称。 2、添加参数某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带仅函数所需信息。 3、移除参数函数本体不再需要某个参数。 去除参数。 4、分离查询函数和修改函数某个函数既返回对象状态值，又修改对象值。 建立两个不同函数,其中一个负责查询,另一个负责修改。 5、令函数携带参数若干函数做了类似的工作，但在函数本体中包含了不同的值。建立单一函数,以参数表达那些不同的值。有这样两个函数：它们做着类似的工作，但因少数几个值致使行为略有不同。在这种情况下，你可以将这些各自分离的函数同一起来，并通过参数来处理那些变化情况，用以简化问题。 6、以明确函数取代参数你有一个函数，其中完全取决于参数值而采用不同行为。 针对该参数的每一个可能值，建立一个独立函数。如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，那么就应该使用本项重构。 7、保持对象完整从某个对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。 8、以函数取代参数对象调用某个函数，并将所得结果作为参数，传递给另一函数，而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该参数，直接调用前一个函数。 9、引入参数对象某些参数总是很自然的同时出现。以一个对象取代这些参数。 10、移除设值函数类中某个字段在对象创建时被设值，然后不再改变。去掉该字段的所有设值函数。 11、隐藏函数某个函数，从来没有被其他任何类用到 。将函数修改为private。 12 、以工厂函数取代构造函数希望在创建对象时不仅仅是做简单的建构动作 。 将构造函数替换为工厂函数。 ##（八）处理概括关系 1、字段上移两个子类拥有相同的字段。将该字段移至超类。 2 、函数上移有些函数在各子类中产生完全相同的结果。将该函数移至超类。 3 、构造函数本体上移各个子类中有一些构造函数本体几乎完全一致 。在超类中新建一个构造函数，并在子类构造函数中调用它。 4、函数下移超类中的某个函数只与部分(而非全部)子类用到。 将函数移到相关的子类中。 5、字段下移超类中的某个字段只被部分(而非全部)子类用到。 将字段移到需要它的子类中。 6、提炼子类类中的某些特性只被某些(而非全部)实例用到。 新建一个子类，将上述部分的特性移到子类中。 7、提炼超类两个类有相似特性。 为这两个类建立一个超类,将相同特性移至超类。 8、提炼接口若干客户使用类接口中的同一子集，或两个类的接口有部分相同。将相同的子集提炼到一个独立接口中。 9、折叠继承体系超类和子类之间无太大区别。 将它们合为一体。 10、塑造模板函数子类中某些函数以相同顺序执行类似操作，但各操作细节略有不同。将操作放进独立函数(保持签名相同)，然后将它们移至超类。 11、以委托取代继承某个子类只使用超类接口中的一部分或根本不需要继承而来的数据。子类新建字段保存超类，调整子类函数为委托超类，取消继承关系。 12、以继承取代委托你在两个类中使用委托关系，并经常为整个接口编写许多极简单的委托函数。`让委托类继承受托类。]]></content>
      <categories>
        <category>Android</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UUID通用唯一识别码]]></title>
    <url>%2Fposts%2Fb4fbe497.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526import java.util.UUID; public class UploadUtils &#123; /** * 传入文件的名称，返回的唯一的名称 * 例如：gril.jpg 返回sdjsljfsjdl.jpg * @param filename * @return */ public static String getUUIDName(String filename)&#123; // 先查找 int index = filename.lastIndexOf("."); // 截取 String lastname = filename.substring(index, filename.length()); // 唯一 字符串 fsd-sfsdf-sfsd-sdfsd String uuid = UUID.randomUUID().toString().replace("-", ""); return uuid+lastname; &#125; public static void main(String[] args) &#123; String filename = "girl.jpg"; String uuid = getUUIDName(filename); System.out.println(uuid); &#125;&#125; UUID含义是通用唯一识别码 (Universally Unique Identifier)，这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部份。UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。目前最广泛应用的 UUID，即是微软的 Microsoft’s Globally Unique Identifiers (GUIDs)，而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。 UUID.randomUUID().toString()是javaJDK提供的一个自动生成主键的方法。UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的，是由一个十六位的数字组成,表现出来的形式。由以下几部分的组合：当前日期和时间(UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同)，时钟序列，全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得），UUID的唯一缺陷在于生成的结果串会比较长。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android:label=REPLACE and android:label=REPLACE]]></title>
    <url>%2Fposts%2Fc46aabc2.html</url>
    <content type="text"><![CDATA[Multiple entries with same key: 尝试从tools:replace列表中删除空格。 1tools:replace=&quot;android:label,theme,allowBackup,android:icon,android:supportsRtl&quot; 这为我修复了构建错误，但我仍在试图找出为什么忽略空格后的条目.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习]]></title>
    <url>%2Fposts%2Fd3a7443d.html</url>
    <content type="text"><![CDATA[JavaScript权威指南第6版中文版JavaScript高级程序设计（第3版）中文你不知道的 JavaScript（上卷）你不知道的 JavaScript（中卷）你不知道的 JavaScript（下卷）]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 主题 next 添加图片背景]]></title>
    <url>%2Fposts%2F60e96c42.html</url>
    <content type="text"><![CDATA[前言next 主题默认背景是白色, 看多了难免感觉乏味. 我们可以通过自定义样式为其添加背景图片. 操作流程我们直接在 NEXT 预留的自定义样式文件 “themes/next/source/css/_custom/custom.styl” 中添加自己的样式即可, 在自定义样式文件中写入以下代码: 12345678910111213141516171819// 添加背景图片body &#123; background: url(https://source.unsplash.com/random/1600x900?wallpapers); background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%;&#125;// 修改主体透明度.main-inner &#123; background: #fff; opacity: 0.8;&#125;// 修改菜单栏透明度.header-inner &#123; opacity: 0.8;&#125; 其中: background: url() 中填写的是背景图片的 url 地址, 这里调用了 Unsplash 的 API, 随机选用该网站的高清美图作为博客背景. 该网站所有图片都是免费商用的, 所以无须担心侵权问题;网站 API 还有很多有趣的玩法, 参见: Documentation opacity 指定了对应元素的透明度, 这里是 “0.8”, 可以按需更改.]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo修改永久链接的默认格式]]></title>
    <url>%2Fposts%2F36589e41.html</url>
    <content type="text"><![CDATA[Hexo的永久链接的默认格式是:year/:month/:day/:title/，比如访问站点下某一篇文章时，其路径是 2018/04/12/xxxx/，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。 *解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。 * 安装插件在站点根目录使用 git bash 执行命令： 1npm install hexo-abbrlink --save 修改站点配置文件打开根目录下的_config.yml 文件，修改如下配置： 123456# permalink: :year/:month/:day/:title/# permalink_defaults:permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 这里将页面都添加了.html的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。 接下来重新部署三连，可以看到我们的文章路径变成了/posts/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation位移渐变组合动画了解一下]]></title>
    <url>%2Fposts%2F91718fcd.html</url>
    <content type="text"><![CDATA[一：需求分析最近要实现一个view上下循环滚动的动画，需要带有位置移动和透明度转变的动画。类似于从A到B发生位移动画，且view逐渐显示。而从B到C发生位移动画，且view渐变暗消失。实现效果如图所示： 二：需求拆分接到这个需求后，首先将需求进行细分，分为位移动画和逐渐变量（变暗）两个部分。对应的Android的动画类分别是TranslateAnimation(位移动画)和AlphaAniamtion(透明度变化动画)。首先先熟悉一下这两种动画。 1：TranslateAnimation 位移动画123456789101112131415private void startTranslateAnimation() &#123; /** * 进行位移动画，标准步骤 * 1. 创建位移动画对象 * 构造函数 TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) * 参数含义：相对于原图位置 fromXDelta X轴起点相对于原图偏移 toXDelta X轴终点相对于原图偏移 * fromYDelta Y轴起点相对于原图偏移 toYDelta Y轴终点相对于原图偏移 * 2. 设置动画终点是否保持 setFillAfter ： true 动画结束后留在终点 false:动画结束后返回起点 */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -200.0f); translateAnimation.setFillAfter(true); translateAnimation.setDuration(1000); mTextView.startAnimation(translateAnimation);&#125; 这里需要注意的一个小点：设置FillAfter的值，为true代表动画后View停留在终点位置处，false代表动画结束后返回起点。 2：AlphaAnimation 透明度转变动画123456789101112private void startAlphaAnimation() &#123; /** * 进行透明度变化动画，标准步骤 * 1. 创建AlphaAnimation动画 * 构造函数 AlphaAnimation fromAlphaVal toAlphaVal */ AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); alphaAnimation.setFillAfter(true); alphaAnimation.setDuration(1000); mTextView.startAnimation(alphaAnimation);&#125; 3：同时完成位移和透明度动画需求1234567891011121314151617private void startAppearanceAnimation() &#123; /** * 核心类 AnimationSet 顾名思义，可以简单理解为将多种动画放在一个set集合里面 * 产生渐渐显示+位移动画，将加速小火箭渐渐显示出来; * */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -200.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); mTextView.startAnimation(animationSet);&#125; 实现叠加的动画效果：这里一定要注意的是，对AnimationSet动画，fillAfter和duration需要在AniamtionSet对象中设置，不要设置单个动画对象上。 4：完成的动画过程（位移+渐渐显示 停留 位移+渐渐隐藏）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.zm.animationdemo;import android.os.Bundle;import android.os.Handler;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.animation.AlphaAnimation;import android.view.animation.Animation;import android.view.animation.AnimationSet;import android.view.animation.TranslateAnimation;import android.widget.Button;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; TextView tv_text; Button btn; List&lt;String&gt; textList = new ArrayList&lt;String&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_text = findViewById(R.id.tv_text); btn = findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startAppearanceAnimation(); &#125; &#125;); textList.add("Hello World!"); textList.add("Welcome to my blog!"); textList.add("https://zhangmiao.cc"); textList.add("Knowledge is power."); textList.add("Learn and live."); textList.add("可以不成功，但不可以不成长！"); textList.add("加油💪"); &#125; private void startAppearanceAnimation() &#123; /** * 核心类 AnimationSet 顾名思义，可以简单理解为将多种动画放在一个set集合里面 * 产生渐渐显示+位移动画 * */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -50.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); animationSet.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; startDisappearanceAnimation(); &#125; &#125;, 1500); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); tv_text.startAnimation(animationSet); int index = (int) (Math.random() * textList.size()); tv_text.setText(textList.get(index)); &#125; private void startDisappearanceAnimation() &#123; TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, -50.0f, -100.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f, 0.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); animationSet.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; startAppearanceAnimation(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); tv_text.startAnimation(animationSet); &#125;&#125; 总结 位移动画TranslateAnimation实现位移，SetFIllAfter=true可让View停留在动画终点处,false返回动画起点 透明度动画 AlphaAnimation实现透明度变化，可实现View的渐显或者渐隐效果 动画效果可以叠加展示，通过AnimationSet实现。整个动画的fillAfter和duration需要设置在AnimationSet对象上，而不是单个对象单独设置（单独设置不会有效果）]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种获取栈顶Activity的方法]]></title>
    <url>%2Fposts%2F104e2eeb.html</url>
    <content type="text"><![CDATA[有时候，需要获取当前位于栈顶的activity的实例。这里介绍2种方法，以及各自适用的场景。 第一种方法：获取栈顶activity的实例应用场景：项目中，activity都继承于一个BaseActivity，在这个base中，有个广播接收器，收到广播，就弹出一个dialog。现打开多个activity，这个时候，通过三方推送等方法，发出一个广播，base接收到。因为只需要在栈顶的activity弹出，而不是每个activity都弹出，所以，需要获取栈顶activity的实例（即上下文，传给dialog的构造方法），而不能简单的传个this，否则，会导致每个activity都有dialog弹出。 获取方法：在application中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MyApplication extends Application &#123; private static MyApplication mInstance; private Activity app_activity = null; @Override public void onCreate() &#123; super.onCreate(); mInstance = this; initGlobeActivity(); &#125; private void initGlobeActivity() &#123; registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; app_activity = activity; Log.e("onActivityCreated===", app_activity + ""); &#125; @Override public void onActivityDestroyed(Activity activity) &#123; app_activity = activity; Log.e("onActivityDestroyed===", app_activity + ""); &#125; /** Unused implementation **/ @Override public void onActivityStarted(Activity activity) &#123; app_activity = activity; Log.e("onActivityStarted===", app_activity + ""); &#125; @Override public void onActivityResumed(Activity activity) &#123; app_activity = activity; Log.e("onActivityResumed===", app_activity + ""); &#125; @Override public void onActivityPaused(Activity activity) &#123; app_activity = activity; Log.e("onActivityPaused===", app_activity + ""); &#125; @Override public void onActivityStopped(Activity activity) &#123; app_activity = activity; Log.e("onActivityStopped===", app_activity + ""); &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; &#125;); &#125; /** * 获取实例 * @return */ public static MyApplication getInstance() &#123; return mInstance; &#125; /** * 公开方法，外部可通过 MyApplication.getInstance().getCurrentActivity() 获取到当前最上层的activity */ public Activity getCurrentActivity() &#123; return app_activity; &#125;&#125; 注意：initGlobeActivity()、getInstance()、getCurrentActivity() 这3个方法 使用方法：在base的展示dialog方法中123Activity currentActivity = MyApplication.getInstance().getCurrentActivity();Dialog dialog = new Dialog(currentActivity, R.style.PushDialog); 第二种方法：获取栈顶activity的完整包名应用场景：仅仅为了判断当前activity是不是在栈顶，以便决定要不要弹toast等等。注意：获取到的仅仅是完整包名，判断当前activity在不在栈顶，需要用到String方法中的contains方法等。这个时候需要注意，以免出错。如：栈顶activity名为AB，里面包含A，就认为A是在栈顶，就出错了。最好这个activity的名字很特殊，和其他的没有重合部分 在工具类中创建方法：123456789101112131415/** * 获得栈中最顶层的Activity * * @param context * @return */public static String getTopActivity(Context context) &#123; android.app.ActivityManager manager = (android.app.ActivityManager) context.getSystemService(context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = manager.getRunningTasks(1); if (runningTaskInfos != null) &#123; return (runningTaskInfos.get(0).topActivity).toString(); &#125; else return null; &#125; 使用：12String topActivity_1 = Util.getTopActivity(this);Log.e("topActivity_1", topActivity_1);]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Viewpager+Fragment动态处理（添加、删除）]]></title>
    <url>%2Fposts%2Fbcdbaf4f.html</url>
    <content type="text"><![CDATA[问题在进行Fragment的添加和删除时，适配器刷新之后发现并没有什么变化，这是为什么呢？ 理解FragmentPagerAdapter 适合少量的页面显示。该类每一个生成的Fragment对象都会储存在内存中，所以适合相对静态、页面少的情况，如果是页面多，且Fragment的处理相对动态（添加、删除等）时，使用FragmentStatePagerAdapter较为适合。 FragmentStatePagerAdapter 适合大量的页面显示，当页面处于不可见时，可能会被销毁，只保留该片段的保存状态。与FragmentPagerAdapter切换页面产生的大量开销对比，这允许了适配器保持与每个被访问页面相关联的更少的存储器。 分析在切换页面时，FragmentPagerAdapter与FragmentStatePagerAdapter对于上上页（预加载默认1，所以取上上页）的处理是不相同的，FragmentPagerAdapter只是销毁对应Fragment的视图，而FragmentStatePagerAdapter则是把Fragment的实例和视图都销毁了。 当我们对页面进行动态处理时，添加（或删除）是对适配器所持有的list对象进行长度的变化，操作完之后就进行适配器的刷新，也就是notifyDataSetChanged方法，先看看该方法： 12345678910//PagerAdapter.classpublic void notifyDataSetChanged() &#123; synchronized (this) &#123; if (mViewPagerObserver != null) &#123; //根据源码可知mViewPagerObserver的对象是ViewPager里面PagerObserver类的实例 mViewPagerObserver.onChanged(); &#125; &#125; mObservable.notifyChanged(); &#125; 123456789101112131415//ViewPager.classprivate class PagerObserver extends DataSetObserver &#123; PagerObserver() &#123; &#125; @Override public void onChanged() &#123; //调用的是该方法 dataSetChanged(); &#125; @Override public void onInvalidated() &#123; dataSetChanged(); &#125; &#125; 对FragmentPagerAdapter（或FragmentStatePagerAdapter）执行的方法大概进行注释一下，方便理解， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//ViewPager.classvoid dataSetChanged() &#123; // This method only gets called if our observer is attached, so mAdapter is non-null. final int adapterCount = mAdapter.getCount(); mExpectedAdapterCount = adapterCount; boolean needPopulate = mItems.size() &lt; mOffscreenPageLimit * 2 + 1 &amp;&amp; mItems.size() &lt; adapterCount; int newCurrItem = mCurItem; boolean isUpdating = false; //遍历所有item for (int i = 0; i &lt; mItems.size(); i++) &#123; final ItemInfo ii = mItems.get(i); //先调用adapter的getItemPosition方法，获得newPos值 final int newPos = mAdapter.getItemPosition(ii.object); if (newPos == PagerAdapter.POSITION_UNCHANGED) &#123; continue; &#125; if (newPos == PagerAdapter.POSITION_NONE) &#123; mItems.remove(i); i--; if (!isUpdating) &#123; mAdapter.startUpdate(this); isUpdating = true; &#125; //newPos值为PagerAdapter.POSITION_NONE的时候才会执行destroyItem方法 mAdapter.destroyItem(this, ii.position, ii.object); needPopulate = true; if (mCurItem == ii.position) &#123; // Keep the current item in the valid range newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1)); needPopulate = true; &#125; continue; &#125; if (ii.position != newPos) &#123; if (ii.position == mCurItem) &#123; // Our current item changed position. Follow it. newCurrItem = newPos; &#125; ii.position = newPos; needPopulate = true; &#125; &#125; if (isUpdating) &#123; //finishUpdate方法主要是对事务的操作进行commit mAdapter.finishUpdate(this); &#125; Collections.sort(mItems, COMPARATOR); if (needPopulate) &#123; // Reset our known page widths; populate will recompute them. final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = getChildAt(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (!lp.isDecor) &#123; lp.widthFactor = 0.f; &#125; &#125; // setCurrentItemInternal(newCurrItem, false, true); requestLayout(); &#125; &#125; Adapter.getItemPosition方法默认返回的是PagerAdapter.POSITION_UNCHANGED值，如果我们不重写getItemPosition方法，使其返回PagerAdapter.POSITION_NONE的话，那么默认是不操作destroyItem方法的，而在destroyItem方法中，FragmentPagerAdapter和FragmentStatePagerAdapter 对Fragment对象的操作也不一样，上面有说过，FragmentPagerAdapter是只销毁视图，FragmentStatePagerAdapter 是把实例和视图都销毁，就是在destroyItem方法实现的，贴代码： 123456789101112131415161718192021222324252627282930//FragmentPagerAdapter@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Detaching item #" + getItemId(position) + ": f=" + object + " v=" + ((Fragment)object).getView()); //这里是对fragment进行detach操作，fragmentManager中还保存该实例 mCurTransaction.detach((Fragment)object); &#125;//FragmentStatePagerAdapter @Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object + " v=" + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) &#123; mSavedState.add(null); &#125; mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); //而这里是对fragment进行remove，直接在fragmentManager中移除掉 mCurTransaction.remove(fragment); &#125; 解决根据上面的分析，在进行添加删除的时候，我采用了FragmentStatePagerAdapter的子类，进行方法的重写，主要是对该类的两个方法（instantiateItem和destroyItem）进行重写，替换父类的实现，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.voctex.adapter;import android.os.Parcelable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentStatePagerAdapter;import android.support.v4.view.PagerAdapter;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;public class DynamicFragmentAdapter extends FragmentStatePagerAdapter &#123; private FragmentManager mFragmentManager; private List&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;(); public DynamicFragmentAdapter(FragmentManager fm, List&lt;Fragment&gt; list) &#123; super(fm); this.mFragmentManager = fm; if (list == null) return; this.mFragments.addAll(list); &#125; public void updateData(List&lt;Fragment&gt; mlist) &#123; if (mlist == null) return; this.mFragments.clear(); this.mFragments.addAll(mlist); notifyDataSetChanged(); &#125; @Override public Fragment getItem(int arg0) &#123; return mFragments.get(arg0);// &#125; @Override public int getCount() &#123; return mFragments.size();// &#125; @Override public Parcelable saveState() &#123; return null; &#125; @Override public int getItemPosition(Object object) &#123; if (!((Fragment) object).isAdded() || !mFragments.contains(object)) &#123; return PagerAdapter.POSITION_NONE; &#125; return mFragments.indexOf(object); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; Fragment instantiateItem = ((Fragment) super.instantiateItem(container, position)); Fragment item = mFragments.get(position); if (instantiateItem == item) &#123; return instantiateItem; &#125; else &#123; //如果集合中对应下标的fragment和fragmentManager中的对应下标的fragment对象不一致，那么就是新添加的，所以自己add进入；这里为什么不直接调用super方法呢，因为fragment的mIndex搞的鬼，以后有机会再补一补。 mFragmentManager.beginTransaction().add(container.getId(), item).commitNowAllowingStateLoss(); return item; &#125; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; //如果getItemPosition中的值为PagerAdapter.POSITION_NONE，就执行该方法。 if (mFragments.contains(fragment)) &#123; super.destroyItem(container, position, fragment); return; &#125; //自己执行移除。因为mFragments在删除的时候就把某个fragment对象移除了，所以一般都得自己移除在fragmentManager中的该对象。 mFragmentManager.beginTransaction().remove(fragment).commitNowAllowingStateLoss(); &#125; &#125; 结束语 在不断的看源码，查资料，调试程序中，终于是把该问题解决了，网上的资料都说得模棱两可，很多时候都得自己操刀，理解了才是自己的，特别是Fragment在FragmentManager中的mIndex值，有点坑，这里没拿出来说，以后有机会再补补。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Viewpager</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的 Mac 技巧 - 截图，Gif 制作及 App 推荐]]></title>
    <url>%2Fposts%2Fae0ce15d.html</url>
    <content type="text"><![CDATA[概述首先要说明的是，我不可能，也不打算把所有快捷键都列出来。写这篇博文的目的是列出来那些我经常使用的，而且我认为可以显著的提高工作效率的快捷键。所以多少会有些主观色彩 Anyway，老规矩，如果大家有任何疑问、意见或者建议，请在下方留言评论 截图macOS 系统内置了截图功能，每次截图都会发出声音，当然这个声音可以关，后面会提到。基础操作有以下四种（快捷键也可以自定义，后面也会提到）： 1. 截图并保存至桌面123Cmd + Shift + 3 截取整个屏幕，并保存截图至桌面Cmd + Shift + 4 截取区域，并保存截图至桌面 激活区域截图之后，鼠标指针会变成下图这样，然后按住拖动就可以了 2. 截图并复制有些时候，截图内容只是我们临时要用一下的，而不打算保存下来。我们只需要： 123Cmd + Ctrl + Shift + 3 截取整个屏幕并复制Cmd + Ctrl + Shift + 4 截取区域并复制 以上两个快捷键，截图之后，我们只需要 “Cmd” + “v” 就可以随意粘贴了 3. 关于新版 MacBook 的 Touch Bar新版的 MacBook 加入了 Touch Bar，同时系统也为我们提供了截取 Touch Bar 屏幕的快捷键： 123Cmd + Shift + 6 截取 Touch Bar 显示内容，并保存至桌面Cmd + Ctrl + Shift + 6 截取 Touch Bar 显示内容并复制 4. 一些高级操作a. 截取窗口一个比较常用的功能就是截取某个窗口，不需要用截取区域的快捷键然后拉满整个窗口，只需要在 “Cmd” + [“Ctrl” +] “Shift” + “4” 之后按一下 空格，然后鼠标和窗口就会变成这样： 鼠标会变成红色箭头指的那个照相机形状，要截取的窗口也会变成“选中”模式的颜色。这时候只要单击一下鼠标就可以了直接截取窗口了，要取消的话就按 “ESC”。同样道理，快捷键加上了 “Ctrl” 就会复制这个窗口的截图。如果没加，那就会把这个窗口截图保存至桌面 可能有些人会问，为什么上面的“选中”模式是这么漂（nan）亮（kan）的颜色，在这里就可以设置，颜色是我自己调的，非系统默认： b. 实时调整大小还有一些高级操作，都是在开启区域模式并选中一个区域，松开鼠标按键前可以执行的，这里就简单提一下，感兴趣的朋友可以自己试试： 这时候按住 “空格” 并移动鼠标，就可以保持区域大小不变，同时移动区域 这时候按住 “Shift” 并移动鼠标，就可以保持区域的其他三个边不变，移动一个边的位置 这时候按住 “Alt” 并移动鼠标，就可以对称地调整区域大小 就我个人而言，空格那个我偶尔会用下，不过 “Shift” 和 “Alt” 这两个，我是用的真不多 3. 截图标注我们只需要用自带的 Preview（预览）就可以完成截图标注 对于保存到桌面的截图，首先我们在桌面上单击一下图片，然后直接按下 “空格”。空格键是 macOS 上的 Quick View（快速预览），以后的文章中我们会细说。然后只需要点击下图箭头指的这个 Open with Preview： 然后再点一下箭头指的这个工具箱图标，就可以进行标注了。macOS 为我们提供的标注功能有选取（圆形、矩形及套索）、亮度选取、画笔、几何图形标注（圆形、矩形、箭头等）、文字、签名、调色以及裁剪： 这里不得不提一下亮度选取，这个功能可以根据亮度智能选取背景。举个例子，上面的截图，点击亮度选取，然后按住鼠标，左右（或上下）拖动，就能看到选取区域的变化。选好背景后，我们反转一下选取（快捷键 “Cmd” + “Shift” + “i”），然后直接 “delete”，就得到了这个： 4. 延时截图及 Grab 应用a. Grab有时候我们需要延时截图，macOS 为我们提供了这个功能，只是藏的比较深。我们可以直接用 Alfred 或者 macOS 自带的 Spotlight 搜索到，直接输入 Grab 即可： 回车之后没有打开任何窗口，你可能觉得刚刚是打开了假的 App。但其实，这个 App 本身就是没有 UI 的，只会在 Menu Bar 上面显示一条菜单。我们可以在这里找到延时截图的选项： 点击之后，按照提示操作就好，默认的延时时间是 10 秒。要注意的是，延时截图会截取整个屏幕，不能截区域。我们可以先把图片保存下来，然后再打开 Preview（预览）App 裁剪就好了 b. 个性化默认的延时时间和保存路径都是可以更改的。只要打开 Terminal（终端），然后输入这个命令并执行： 1screencapture -T 10 screenshot1.jpg 其中，10 就表示延时十秒，”screenshot1” 就是默认的文件名，你可以把它改成其他文件名，也可以给它加上一个文件夹路径用于设置默认的保存位置 5. 截图功能的配置a. 禁用提示音截图提示音是可以关闭的，大家只需要打开 System Preferences，然后选择 Sound (声音)，然后只要把红色箭头指的这个关掉就行： b. 快捷键设置可能有朋友觉得系统自带快捷键好麻烦，讲真，习惯几天就好了。原则上我不是很建议大家自己改，因为如果快捷键设置的不当，就很可能会在某些 App 中产生快捷键冲突。比如，你把截图快捷键改成了 “Ctrl” + “c”，那么恭喜你，以后关闭 Server 只能 “kill ${pid}” 了?。当然，如果你足够熟悉快捷键，改改倒是也无妨，大不了弄乱了直接恢复成默认 我们可以在 “系统设置 -&gt; 键盘 -&gt; 快捷键” 中设定快捷键，先定位到 Services （服务），然后就可以找到设置截图的快捷键了： 就算把这些都关掉，像上图那样，文中之前提到的那些快捷键也都是能用的，因为那些都是系统默认的快捷键。同时，我们注意到这里也提供了延时截图的快捷键，如果你常用这个功能，那不妨也绑定一个快捷键吧，比如 “Cmd” + “Shift” + “5”，方便又好记 c. 截图默认保存路径设置同样，我也不推荐改这个设置，虽然改一下也不会炸。比如你想把截图放到桌面的 myScreenshot 文件夹，那么打开 Terminal（终端），输入： 1defaults write com.apple.screencapture location ~/Desktop/myScreenshot 然后，记得要重启一下系统的 UI 服务，执行这个命令： 1killall SystemUiServer 之后，如果你再通过 “Cmd” + “Shift” + “3/4” 截图，图片就会保存在这个文件夹里 macOS 上截图相关的快捷键就介绍到这里，能想到的也就这些了。以下为 App 推荐环节，写给有需要的朋友 截图 App 推荐经常会被问到，Mac 上如何制作 Gif，以及有什么截图 App 可以替代原生的截图工具。这里推荐以下几款，从免费到收费的都有。顺便提一句，Windows 系统自带的截图工具就很方便了，另外 PicPick 也是极好的。可以一直免费试用，不需要去找破解，只是这款 App 没有 Mac 版本 1. 系统截图 App 替代品以下提到的三款软件均免费，至少在标注方面比原生的略胜一筹，详情请点击链接查看 a. 浏览器插件 Awesome ScreenshotAwesome Screenshot 是一款免费的截图工具，非本地 App，只是一个浏览器插件。它支持延时截图区域截图等常用功能。也内置了一个网页版的标注工具 b. Evernote 旗下的 SkitchSkitch | Evernote 也是一款免费的截图 App，标注功能相比 Awesome Screenshot 会稍好一些。如果你用 Evernote（印象笔记），经常需要截图并保存到自己的笔记中，那么这款 App 可能会比较适合你。同时，Skitch 也有 iOS 版本 c. JingJing 同样是一款免费的截图 App，来自 TechSmith 公司，这家公司出品的另一款更为强大的截图工具 SnagIt 会在后文详细说明 2. 制作 Gif经常会被问到，如何在 macOS 上制作 Gif。这里给大家推荐以下几个不错的 App a. LICEcap (收费)LICEcap 是一款老牌的 macOS 系统 Gif 制作工具，不免费。相比其他 App，LICEcap 本身并不提供分享和上传功能，所以我本人并不是很推荐 b. Giphy Capture (免费)GIPHY Capture 是由一个很火的 Gif 分享网站 GIPHY 开发的。一个很方便的功能就是可以直接上传至 giphy.com（可能需要 VPN 才能访问），然后把链接 Share 给朋友就可以了。同样，保存至本地也没问题 3. SnagIt - 全套解决方案我一般的习惯是，如果截图只是为了粘贴到聊天框之类的地方，而且不需要标注的话，就会用系统截图。如果需要标注，或者想要留下来，就会用一个第三方的 App：Snagit)。虽然是付费软件，价格也有点儿高，但我觉得还是很值得购买的。目前我的博客和 GitHub 上的截图、动图都是用这个做的 a. 截图功能SnagIt 在截图方面提供了区域延时截图、全景截图、Expose 模式截图甚至摄像头输入内容截图这些很实用的功能。个人觉得，它 Menu Bar 的 Panel（面板）本身颜值就很高： 而且自带一个颜值更高，功能也更多的图片编辑器： 保存的图片格式也可以自己选择，还可以保存为感人的 Retina 清晰度 b. 编辑功能作为一款付费 App，它确实为我们提供了相比 macOS 原生 Preview 更多的编辑功能。暂且不去比较已有的箭头之类的功能，虽然我还是觉得 SnagIt 里面的元素更好看些，SnagIt 还提供了打码功能，效果嘛，大家可以参考下上面 Grab 那里的配图。放大镜功能也是极好的，突出重点的时候很有用。还有 Stamp（图章），有茫茫多的图章选择，从 PC 键盘按键图章，到 Emoji 表情，再到数学符号和花体英文字母，都可以直接扔到截图上。虽然没有提供直接的拼图工具，但拼起来也不麻烦，裁好图，加上分割线，粘贴到一起就可以了 c. 视频功能首先，SnagIt 可以录制很高清的视频，时长也是没有限制的。支持全屏和区域录制两种模式，同时也可以录制摄像头输入和麦克风输入，这个功能用来录制会议视频应该也是极好的。另一个应用场景就是，我们在一些网站上看到喜欢的视频想留下来，而网站又不提供下载，那我们就可以直接选好视频播放的区域来自己录成视频 d. 上传与同步功能TechSmith 自己提供了 http://screencast.com 和 TechSmith relay 服务，当然我们也可以选择上传到 Google Drive 或者 Dropbox。也以配置自己的 FTP，或者直接扔到 iCloud 文件夹也是没问题的。同样，也可以选择本地文件夹保存，支持命名规则等方面的设置]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础控件ViewFlipper的使用，垂直滚动广告条]]></title>
    <url>%2Fposts%2Fced0f833.html</url>
    <content type="text"><![CDATA[学习，学习，学以致用ViewFlipper是安卓自带的控件，很多人可能很少知道这个控件，这个控件很简单，也很好理解。 从源码可以看出，其实ViewFlipper间接的继承了FrameLayout，也可以说ViewFlipper其实就是个FrameLayout，只不过在内部封装了动画实现和Handler实现一个循环而已。 ViewFlipperDemo ###一、ViewFlipper的布局实现布局的编写很简单，跟普通布局一样的 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ViewFlipper android:id="@+id/marqueeView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginTop="10dip" android:layout_marginBottom="30dip" android:autoStart="true" android:background="#fff" android:flipInterval="3000" android:inAnimation="@anim/anim_marquee_in" android:outAnimation="@anim/anim_marquee_out" android:paddingLeft="30dp"/&gt;&lt;/LinearLayout&gt; 这里介绍ViewFlipper用到的属性，这些属性其实都可以使用代码实现，只不过这里为了代码看上去美观，才放在布局里的 android:autoStart：设置自动加载下一个View android:flipInterval：设置View之间切换的时间间隔 android:inAnimation：设置切换View的进入动画 android:outAnimation：设置切换View的退出动画 下面是ViewFlipper常用的方法介绍，除了可以设置上面的属性之外，还提供了其他方法 isFlipping： 判断View切换是否正在进行 setFilpInterval：设置View之间切换的时间间隔 startFlipping：开始View的切换，而且会循环进行 stopFlipping：停止View的切换 setOutAnimation：设置切换View的退出动画 setInAnimation：设置切换View的进入动画 showNext： 显示ViewFlipper里的下一个View showPrevious：显示ViewFlipper里的上一个View 这里还涉及到两个动画其实就是一个平移的动画，它们都保存在anim文件夹中 anim_marquee_in.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="1500" android:fromYDelta="100%p" android:toYDelta="0"/&gt;&lt;/set&gt; anim_marquee_out.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="1500" android:fromYDelta="0" android:toYDelta="-100%p"/&gt;&lt;/set&gt; 当然，如果你对动画xml比较熟悉，自己可以实现更多好看的效果 ###二、自定义ViewFlipper的广告条当我们准备好了ViewFlipper之后，就应该在ViewFlipper里面添加我们的广告条了，下面是其中一个广告条的布局文件，另外两个雷同，只不过改了文字而已 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="25dip" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/iv_image" android:layout_width="25dip" android:layout_height="25dip" android:src="@mipmap/ic_launcher"/&gt; &lt;TextView android:id="@+id/tv_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dip" android:text="华为王牌亮相，5G+4000万徕卡"/&gt;&lt;/LinearLayout&gt; ###三、代码为ViewFlipper添加广告条所有的准备条件都准备好了，该开始使用代码将准备好的东西黏在一起了，代码很简单，这里就不多解释了 12345678910111213141516171819202122232425262728293031323334353637package com.zm.viewflipperdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.LayoutInflater;import android.view.View;import android.widget.TextView;import android.widget.ViewFlipper;public class MainActivity extends AppCompatActivity &#123; private ViewFlipper marqueeView; private String[] textArray = &#123;"华为王牌亮相，5G+4000万徕卡", "圣诞来袭，扫码关注领取大礼！", "2018即将过去，说说您的心里话"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; marqueeView = findViewById(R.id.marqueeView); &#125; private void initData() &#123; LayoutInflater inflater = LayoutInflater.from(this); for (int i = 0; i &lt; textArray.length; i++) &#123; View view = inflater.inflate(R.layout.marquee_scroll_content, null); TextView text = view.findViewById(R.id.tv_text); text.setText(textArray[i]); marqueeView.addView(view); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewFlipper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View获取width和height的四种方法]]></title>
    <url>%2Fposts%2Fdd1673d3.html</url>
    <content type="text"><![CDATA[很经常当我们动态创建某些View时，需要通过获取他们的width和height来确定别的view的布局，但是在onCreate()获取view的width和height会得到0.view.getWidth()和view.getHeight()为0的根本原因是控件还没有完成绘制，你必须等待系统将绘制完View时，才能获得。这种情况当你需要使用动态布局（使用wrap_content或match_parent）就会出现。一般来讲在Activity.onCreate(…)、onResume()方法中都没有办法获取到View的实际宽高。所以，我们必须用一种变通的方法，等到View绘制完成后去获取width和Height。下面有一些可行的解决方案。 1、监听Draw/Layout事件：ViewTreeObserverViewTreeObserver监听很多不同的界面绘制事件。一般来说OnGlobalLayoutListener就是可以让我们获得到view的width和height的地方.下面onGlobalLayout内的代码会在View完成Layout过程后调用。 12345678910view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; mScrollView.post(new Runnable() &#123; public void run() &#123; view.getHeight(); //height is ready &#125; &#125;); &#125;&#125;); 但是要注意这个方法在每次有些view的Layout发生变化的时候被调用（比如某个View被设置为Invisible）,所以在得到你想要的宽高后，记得移除onGlobleLayoutListener： 在 SDK Lvl &lt; 16时使用public void removeGlobalOnLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim) 在 SDK Lvl &gt;= 16时使用public void removeOnGlobalLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim) 2、将一个runnable添加到Layout队列中：View.post()这个解决方案是我最喜欢的，但是几乎没人知道有这个方法。简单地说，只要用View.post()一个runnable就可以了。runnable对象中的方法会在View的measure、layout等事件后触发，具体的参考Romain Guy： UI事件队列会按顺序处理事件。在setContentView()被调用后，事件队列中会包含一个要求重新layout的message，所以任何你post到队列中的东西都会在Layout发生变化后执行。 12345678final View view=//smth;...view.post(new Runnable() &#123; @Override public void run() &#123; view.getHeight(); //height is ready &#125; &#125;); 这个方法比ViewTreeObserver好：1、你的代码只会执行一次，而且你不用在在每次执行后将Observer禁用，省心多了。2、语法很简单参考：http://stackoverflow.com/a/3602144/774398http://stackoverflow.com/a/3948036/774398 3、重写View的onLayout方法这个方法只在某些场景中实用，比如当你所要执行的东西应该作为他的内在逻辑被内聚、模块化在view中，否者这个解决方案就显得十分冗长和笨重。 1234567view = new View(this) &#123; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); view.getHeight(); //height is ready &#125;&#125;; 需要注意的是onLayout方法会调用很多次，所以要考虑好在这个方法中要做什么，或者在第一次执行后禁用掉你的代码。 4、获取固定宽高如果你要获取的view的width和height是固定的，那么你可以直接使用： 12View.getMeasureWidth()View.getMeasureHeight() 但是要注意，这两个方法所获取的width和height可能跟实际draw后的不一样。官方文档解释了不同的原因： View的大小由width和height决定。一个View实际上同时有两种width和height值。 第一种是measure width和measure height。他们定义了view想要在父View中占用多少width和height（详情见Layout）。measured height和width可以通过getMeasuredWidth() 和 getMeasuredHeight()获得。 第二种是width和height，有时候也叫做drawing width和drawing height。这些值定义了view在屏幕上绘制和Layout完成后的实际大小。这些值有可能跟measure width和height不同。width和height可以通过getWidth()和getHeight获得。 参考链接 https://stackoverflow.com/questions/3591784/getwidth-and-getheight-of-view-returns-0/24035591#24035591]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpannableString之富文本显示效果]]></title>
    <url>%2Fposts%2F9e398b2.html</url>
    <content type="text"><![CDATA[TextViewSpannableString一：简介SpannableString其实和String一样，都是一种字符串类型，SpannableString可以直接作为TextView的显示文本，不同的是SpannableString可以通过使用其方法setSpan方法实现字符串各种形式风格的显示,重要的是可以指定设置的区间，也就是为字符串指定下标区间内的子字符串设置格式。 setSpan(Object what, int start, int end, int flags)方法需要用户输入四个参数，what表示设置的格式是什么，可以是前景色、背景色也可以是可点击的文本等等，start表示需要设置格式的子字符串的起始下标，同理end表示终了下标，flags属性就有意思了，共有四种属性： Spanned.SPAN_INCLUSIVE_EXCLUSIVE 从起始下标到终了下标，包括起始下标Spanned.SPAN_INCLUSIVE_INCLUSIVE 从起始下标到终了下标，同时包括起始下标和终了下标Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 从起始下标到终了下标，但都不包括起始下标和终了下标Spanned.SPAN_EXCLUSIVE_INCLUSIVE 从起始下标到终了下标，包括终了下标 SpannableString的setSpan()方法可以同时使用多个，实现多种效果叠加。 二：Span常用的格式2.1：ForegroundColorSpan ForegroundColorSpan，为文本设置前景色，效果和TextView的setTextColor()类似，实现方法如下： 1234SpannableString spannableString = new SpannableString("设置文字的前景色为淡蓝色");ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor("#0099EE"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 设置的区间是9到字符串的最后，也就是图中“淡蓝色”三字。 2.2：BackgroundColorSpan BackgroundColorSpan，为文本设置背景色，效果和TextView的setBackground()类，实现方法如下： 1234SpannableString spannableString = new SpannableString("设置文字的背景色为淡绿色");BackgroundColorSpan colorSpan = new BackgroundColorSpan(Color.parseColor("#AC00FF30"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.3：RelativeSizeSpan RelativeSizeSpan，设置文字相对大小，在TextView原有的文字大小的基础上，相对设置文字大小，实现方法如下： 123456789101112131415161718SpannableString spannableString = new SpannableString("万丈高楼平地起");RelativeSizeSpan sizeSpan01 = new RelativeSizeSpan(1.2f);RelativeSizeSpan sizeSpan02 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan03 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan04 = new RelativeSizeSpan(1.8f);RelativeSizeSpan sizeSpan05 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan06 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan07 = new RelativeSizeSpan(1.2f);spannableString.setSpan(sizeSpan01, 0, 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan02, 1, 2, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan03, 2, 3, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan04, 3, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan05, 4, 5, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan06, 5, 6, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan07, 6, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.4：StrikethroughSpan StrikethroughSpan，为文本设置中划线，也就是常说的删除线，实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置删除线");StrikethroughSpan strikethroughSpan = new StrikethroughSpan();spannableString.setSpan(strikethroughSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.5：UnderlineSpan UnderlineSpan，为文本设置下划线，具体实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置下划线");UnderlineSpan underlineSpan = new UnderlineSpan();spannableString.setSpan(underlineSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.6：SuperscriptSpan SuperscriptSpan，设置上标，具体实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置上标");SuperscriptSpan superscriptSpan = new SuperscriptSpan();spannableString.setSpan(superscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 从效果图可以看出，被设置为上标的文字大小和下面的文本文字大小一样，只要我们稍加修饰，结合RelativeSizeSpan设置小字体文本作为上标，分分钟实现指数公式有木有，再也不用2^2+3^2=13这样缺乏审美的数学公式了，是不是超实用？ 2.7：SubscriptSpan SubscriptSpan，设置下标，功能与设置上标类似，不做过多描述，具体实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置下标");SubscriptSpan subscriptSpan = new SubscriptSpan();spannableString.setSpan(subscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.8：StyleSpan StyleSpan，为文字设置风格（粗体、斜体），和TextView属性textStyle类似，实现方法如下： 1234567SpannableString spannableString = new SpannableString("为文字设置粗体、斜体风格");StyleSpan styleSpan_B = new StyleSpan(Typeface.BOLD);StyleSpan styleSpan_I = new StyleSpan(Typeface.ITALIC);spannableString.setSpan(styleSpan_B, 5, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(styleSpan_I, 8, 10, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString); 2.9：ImageSpan ImageSpan，设置文本图片，实现方法如下： 123456SpannableString spannableString = new SpannableString("在文本中添加表情（表情）");Drawable drawable = getResources().getDrawable(R.mipmap.a9c);drawable.setBounds(0, 0, 42, 42);ImageSpan imageSpan = new ImageSpan(drawable);spannableString.setSpan(imageSpan, 6, 8, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 这一个是不是很炫酷？再加一个解析算法，将文本中特定的文本转换成特定的表情图片，分分钟实现聊天表情显示效果有木有啊朋友们！ 3.0：ClickableSpanClickableSpan，设置可点击的文本，设置这个属性的文本可以相应用户点击事件，至于点击事件用户可以自定义，就像效果图显示一样，用户可以实现点击跳转页面的效果，具体实现方法如下： 123456SpannableString spannableString = new SpannableString("为文字设置点击事件");MyClickableSpan clickableSpan = new MyClickableSpan("https://zhangmiao.cc/");spannableString.setSpan(clickableSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696")); textView.setText(spannableString); 12345678910111213141516171819202122class MyClickableSpan extends ClickableSpan &#123; private String content; public MyClickableSpan(String content) &#123; this.content = content; &#125; @Override public void updateDrawState(TextPaint ds) &#123; ds.setUnderlineText(false); &#125; @Override public void onClick(View widget) &#123; Intent intent = new Intent(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString("content", content); intent.putExtra("bundle", bundle); startActivity(intent); &#125;&#125; 代码中我们自定义MyClickableSpan类，继承至ClickableSpan，并重写其中一些方法。ds.setUnderlineText()控制是否让可点击文本显示下划线，很明显，在上面代码中我选择了false，不显示下滑写。onClick点击事件的具体实现方法写在其中。如上代码，我们重写ClickableSpan的onClick方法实现Activity的跳转效果，并传递跳转数据。 注意：使用ClickableSpan的文本如果想真正实现点击作用，必须为TextView设置setMovementMethod方法，否则没有点击相应，至于setHighlightColor方法则是控制点击是的背景色。 URLSpanURLSpan，设置超链接文本，其实聪明的小伙帮在讲到ClickableSpan的时候就能实现超链接文本的效果了，重写onClick点击事件就行，也确实看了URLSpan的源码，URLSpan就是继承自ClickableSpan，也和想象中一样，就是重写了父类的onClick事件，用系统自带浏览器打开链接，具体实现方法如下： 123456SpannableString spannableString = new SpannableString("为文字设置超链接");URLSpan urlSpan = new URLSpan("https://zhangmiao.cc/");spannableString.setSpan(urlSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString); URLSpanonClick事件的源码如下： 123456789101112@Overridepublic void onClick(View widget) &#123; Uri uri = Uri.parse(getURL()); Context context = widget.getContext(); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName()); try &#123; context.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Log.w("URLSpan", "Actvity was not found for intent, " + intent.toString()); &#125;&#125; 除此之外，还有MaskFilterSpan可以实现模糊和浮雕效果，RasterizerSpan可以实现光栅效果，因为以上两个使用频率不高，而且效果也不是很明显，就不做详细说明，有兴趣的小伙伴不妨去试一试。 SpannableStringBuilder应该有不少开发的小伙伴知道StringBuilder，可以使用append()方法实现字符串拼接，非常方便。同样，SpannableString中也有SpannableStringBuilder，顾名思义，就是实现对，SpannableString的一个拼接效果，同样是append()方法，可以实现各种风格效果的SpannableString拼接，非常实用。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SpannableString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android跳转权限设置界面的终极适配（支持各大定制ROM）]]></title>
    <url>%2Fposts%2F559aa4a0.html</url>
    <content type="text"><![CDATA[前言： 当我们的用户使用App时不小心拒绝了某项必要权限，而导致无法正常使用。这时候希望重新去打开该权限，那么问题来了，Android厂家定制的room五花八门，很多时候却发现找不到权限管理的入口。为了解决这一问题，如果我们应用中直接提供权限管理入口给用户，是不是会很方便的解决用户这一困扰呢?经过一番研究，整理出了大部分国产手机直接打开权限管理界面的方法 权限界面的跳转一般项目中我们都会通过一个类来管理我们的Permission，即PermissionPageUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/** * 权限请求页适配，不同手机系统跳转到不同的权限请求页 * * @author Donkor */public class PermissionPageUtils &#123; private final String TAG = "PermissionPageManager"; private Context mContext; //自己的项目包名 private String packageName="com.zm.demo"; public PermissionPageUtils(Context context) &#123; this.mContext = context; &#125; public void jumpPermissionPage() &#123; String name = Build.MANUFACTURER; L.e(TAG, "jumpPermissionPage --- name : " + name); switch (name) &#123; case "HUAWEI": goHuaWeiMainager(); break; case "vivo": goVivoMainager(); break; case "OPPO": goOppoMainager(); break; case "Coolpad": goCoolpadMainager(); break; case "Meizu": goMeizuMainager(); break; case "Xiaomi": goXiaoMiMainager(); break; case "samsung": goSangXinMainager(); break; case "Sony": goSonyMainager(); break; case "LG": goLGMainager(); break; default: goIntentSetting(); break; &#125; &#125; private void goLGMainager()&#123; try &#123; Intent intent = new Intent(packageName); ComponentName comp = new ComponentName("com.android.settings", "com.android.settings.Settings$AccessLockSummaryActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private void goSonyMainager()&#123; try &#123; Intent intent = new Intent(packageName); ComponentName comp = new ComponentName("com.sonymobile.cta", "com.sonymobile.cta.SomcCTAMainActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private void goHuaWeiMainager() &#123; try &#123; Intent intent = new Intent(packageName); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); ComponentName comp = new ComponentName("com.huawei.systemmanager", "com.huawei.permissionmanager.ui.MainActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private static String getMiuiVersion() &#123; String propName = "ro.miui.ui.version.name"; String line; BufferedReader input = null; try &#123; Process p = Runtime.getRuntime().exec("getprop " + propName); input = new BufferedReader( new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); return null; &#125; finally &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return line; &#125; private void goXiaoMiMainager() &#123; String rom = getMiuiVersion(); L.e(TAG,"goMiaoMiMainager --- rom : "+rom); Intent intent=new Intent(); if ("V6".equals(rom) || "V7".equals(rom)) &#123; intent.setAction("miui.intent.action.APP_PERM_EDITOR"); intent.setClassName("com.miui.securitycenter", "com.miui.permcenter.permissions.AppPermissionsEditorActivity"); intent.putExtra("extra_pkgname", packageName); &#125; else if ("V8".equals(rom) || "V9".equals(rom)) &#123; intent.setAction("miui.intent.action.APP_PERM_EDITOR"); intent.setClassName("com.miui.securitycenter", "com.miui.permcenter.permissions.PermissionsEditorActivity"); intent.putExtra("extra_pkgname", packageName); &#125; else &#123; goIntentSetting(); &#125; mContext.startActivity(intent); &#125; private void goMeizuMainager() &#123; try &#123; Intent intent = new Intent("com.meizu.safe.security.SHOW_APPSEC"); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.putExtra("packageName", packageName); mContext.startActivity(intent); &#125; catch (ActivityNotFoundException localActivityNotFoundException) &#123; localActivityNotFoundException.printStackTrace(); goIntentSetting(); &#125; &#125; private void goSangXinMainager() &#123; //三星4.3可以直接跳转 goIntentSetting(); &#125; private void goIntentSetting() &#123; Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts("package", mContext.getPackageName(), null); intent.setData(uri); try &#123; mContext.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void goOppoMainager() &#123; doStartApplicationWithPackageName("com.coloros.safecenter"); &#125; /** * doStartApplicationWithPackageName("com.yulong.android.security:remote") * 和Intent open = getPackageManager().getLaunchIntentForPackage("com.yulong.android.security:remote"); * startActivity(open); * 本质上没有什么区别，通过Intent open...打开比调用doStartApplicationWithPackageName方法更快，也是android本身提供的方法 */ private void goCoolpadMainager() &#123; doStartApplicationWithPackageName("com.yulong.android.security:remote"); /* Intent openQQ = getPackageManager().getLaunchIntentForPackage("com.yulong.android.security:remote"); startActivity(openQQ);*/ &#125; private void goVivoMainager() &#123; doStartApplicationWithPackageName("com.bairenkeji.icaller"); /* Intent openQQ = getPackageManager().getLaunchIntentForPackage("com.vivo.securedaemonservice"); startActivity(openQQ);*/ &#125; /** * 此方法在手机各个机型设置中已经失效 * * @return */ private Intent getAppDetailSettingIntent() &#123; Intent localIntent = new Intent(); localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= 9) &#123; localIntent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); localIntent.setData(Uri.fromParts("package", mContext.getPackageName(), null)); &#125; else if (Build.VERSION.SDK_INT &lt;= 8) &#123; localIntent.setAction(Intent.ACTION_VIEW); localIntent.setClassName("com.android.settings", "com.android.settings.InstalledAppDetails"); localIntent.putExtra("com.android.settings.ApplicationPkgName", mContext.getPackageName()); &#125; return localIntent; &#125; private void doStartApplicationWithPackageName(String packagename) &#123; // 通过包名获取此APP详细信息，包括Activities、services、versioncode、name等等 PackageInfo packageinfo = null; try &#123; packageinfo = mContext.getPackageManager().getPackageInfo(packagename, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; if (packageinfo == null) &#123; return; &#125; // 创建一个类别为CATEGORY_LAUNCHER的该包名的Intent Intent resolveIntent = new Intent(Intent.ACTION_MAIN, null); resolveIntent.addCategory(Intent.CATEGORY_LAUNCHER); resolveIntent.setPackage(packageinfo.packageName); // 通过getPackageManager()的queryIntentActivities方法遍历 List&lt;ResolveInfo&gt; resolveinfoList = mContext.getPackageManager() .queryIntentActivities(resolveIntent, 0); Log.e("PermissionPageManager", "resolveinfoList" + resolveinfoList.size()); for (int i = 0; i &lt; resolveinfoList.size(); i++) &#123; Log.e("PermissionPageManager", resolveinfoList.get(i).activityInfo.packageName + resolveinfoList.get(i).activityInfo.name); &#125; ResolveInfo resolveinfo = resolveinfoList.iterator().next(); if (resolveinfo != null) &#123; // packageName参数2 = 参数 packname String packageName = resolveinfo.activityInfo.packageName; // 这个就是我们要找的该APP的LAUNCHER的Activity[组织形式：packageName参数2.mainActivityname] String className = resolveinfo.activityInfo.name; // LAUNCHER Intent Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); // 设置ComponentName参数1:packageName参数2:MainActivity路径 ComponentName cn = new ComponentName(packageName, className); intent.setComponent(cn); try &#123; mContext.startActivity(intent); &#125; catch (Exception e) &#123; goIntentSetting(); e.printStackTrace(); &#125; &#125; &#125;&#125; 另外：当前已适配测试的机型包括小米，华为，三星，锤子。代码仅供参考。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
        <tag>Android Tips</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Omniplan 5分钟入个门]]></title>
    <url>%2Fposts%2F3df11d4f.html</url>
    <content type="text"><![CDATA[https://xclient.info/s/omni-plan.html 00:00 什么要用omniplan？最近工作当中，对项目交付的要求越来越高了。 这意味着不能像之前那样，做完方案就丢给开发，然后到了指定时间再收获了。 那么怎么掌握项目全部的进度呢，用万能的excel画格子吗？ 画格子 当然在产品经理面前，Excel无所不能，上到画原型，下到数据库管理。但是在面对一个较大的项目的时候，仍然会有一些问题： 我的项目进度到哪了？ 项目瓶颈是什么？ 还有没有更好的项目组织的方案？ 这些问题的答案就是 omniplan。 00:30 打开omniplan看看什么，才过了30秒？是的。 安装下载omniplan可以直接到官网或者mac app store购买下载，对于一个生产力工具来说，价格不算贵。 当然你要是找到了别的渠道来下载……那我是管不着的。 界面 恩，这些红字加的很不优雅，但不重要。 左边是任务列表，可以加分组，中间是时间的甘特图，可以拖拽。上边是面板的切换。 右边是信息列表，可以填写一些更仔细的信息。 相信我，5分钟时间里，你基本是用不到右侧的这些内容的。 01:00 录入任务，分组点击左边的列表，就可以录入任务，打完之后按回车，快速新建下一个任务。 分组 另一个很有用的功能是多选多个任务，新建一个群组。群组的时间和进度会根据子任务计算。 同样的，你也可以拖拽任务上下移，排序，剪切，复制什么的。 01:20 给任务安排时间给任务安排时间很简单，鼠标放到蓝条的最右边，然后拖拽拉长就行。 我们都知道，任务实际上是存在逻辑顺序的，比如得先完成原型，才能做视觉，才能开始开发。 所以我们需要给这些任务加上关联关系： 拖拽这个右边的箭头关联到下一个任务上，就完成了 A任务完成时-B任务开始的逻辑。 omniplan会根据你的任务逻辑关系自动安排时间，看起来不错！ 02:00 节奏好像不对？所有的项目都安排好了时间，但是现在有两个时间上的问题： web上线好像是一个节点而不是一个时间段。 app发版是按固定节奏来的，并不是做完就上线，只有在发版之后，才算是开发完毕。 为了解决这个问题，我们需要另外两个表现任务节点的工具。 里程碑 弹性任务（omniplan中叫做吊床任务） 里程碑是一种没有时间消耗的任务，用来标记一个项目的状态变化，或者把一个大项目拆成若干阶段都是很好用的。 弹性任务很有意思，它自己本身的起点和终点都取决于前后的任务。在这个例子中，直到发版之前，工程师都可以继续对性能调优。 想要切换任务状态很简单，在右边信息面板中切换就行（怎么感觉打自己脸了）。 03:00 谁来负责？完成了所有项目节奏之后，接下来要解决的问题是人员安排的问题（当然你可以先把人员确定之后再安排时间节奏。） 点第二个视图，切换到下一个界面。 这里是资源列表（资源可以是人，也可以是设备，素材等。）考虑到我们的例子是个开发的项目，我添加一些工程师进去吧。 好像全是犬科动物……后面的单位表示这个人是全职（100%工时）。 接下来给他们把工作都分配一下，很简单，用拖动的办法。 这时返回任务面板看一下： 看起来不错！ 04:00 项目在运行项目开始运行起来之后，我们需要时刻关注其中的进度变化。 比如田园犬完成了自己的原型，我们需要在甘特图中标识出来。 拖动这个进度指示器来展示工作的进度。 如果任务建了分组，那么分组的进度也会变化。 04:30 糟糕，项目延误了！这大概是大家都不愿意遇到的问题，项目遇到了一些不按预期进展的情况。 这里假设一下，产品经理这几天状态不好，比实际上用时晚了一天。 本来23号设计师就开始工作了，但是因为产品经理不给力，导致24号才开始。这里我们需要将产品经理的用时拉长一天，其他的任务会一起后移。 怎么体现出来产品经理确实延误了呢？ 我们需要讲一下今天最后一个功能：基线。 这个功能是将当前的项目进度保存一份，方便与实际的进度进行比对。 点击面板切换右边的基线比对选项，直接选择 拆分：实际 vs 基线。 这么一比对就很清晰了 都是产品经理的锅！！ 05:00 结语五分钟时间带着大家飞快的过了一下核心的功能，但是omni家的这些软件其实功能都很强大，还有很多值得研究学习的。 希望大家都能把项目跑的平稳，吃好喝好不加班！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
        <tag>omniplan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genymotion上不能安装APK软件的问题]]></title>
    <url>%2Fposts%2Ff1cdd64c.html</url>
    <content type="text"><![CDATA[Genymotion模拟器不能安装APK的原因官网给出的解释：Genymotion模拟器使用的是x86架构，在第三方市场上的应用有部分不采用x86这么一种架构，所以在编译的时候不通过，报“APP not installed”，可以下载Genymotion提供的ARM转换工具包，将应用市场中的ARM架构的apk转换成Genymotion可以编译的x86架构； 直接安装报错如下图：An error occured while deploying the file.This probably means that the app contains ARM native code and your Genymotion device cannot run ARM instructions. You should either build your native code to x86 or install an ARM translation tool in your device.部署文件时出错。这可能意味着应用程序包含本地ARM代码和你的genymotion设备无法运行ARM指令。你可以建立你的原生代码的x86或在您的设备上安装一个臂的翻译工具。 解决方法1.用Android Studio 创建一个ARM的虚拟机；（当然这个不是你想要的）2.下载Genymotion-ARM-Translation-Librarities工具转换包；下载路径： 链接:https://pan.baidu.com/s/1OOj72JqNnTtSZJnCXCoFzA 密码:p8c4 将下载号的工具包直接拖拽到Genymotion中，然后提示重启模拟器；]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Genymotion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美解决Genymotion无法使用adb命令的问题]]></title>
    <url>%2Fposts%2Fc3520239.html</url>
    <content type="text"><![CDATA[我在运行Genymotion虚拟机进行android应用调试的时候，无法用Powershell(cmd)进入adb shell，显示的界面是这样的： 导致无法正常进行adb调试，找了很多方法都没用，后来修改了genymotion中的settings 中的ADB选项中的SDK路径，保持跟你当前应用的eclipse或者android studio中的SDK库一致，然后问题就解决了；]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Genymotion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活计划]]></title>
    <url>%2Fposts%2Fa5f172c4.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp3源码分析二]]></title>
    <url>%2Fposts%2F9c0f9a31.html</url>
    <content type="text"><![CDATA[1.前言 Android开发过程中，使用第三方的框架库已成家常便饭，使用第三方好处避免重复造轮子、降低成本、提升效率、降低风险等等，当遇到框架库不能满足现有业务、框架库设计缺陷或者漏洞、API使用深度不够时，如果停留只会使用层面，就会增加修改过程的难度，所以对于使用的框架库最好还是有个系统的认识； 本文带大家深入讲解 OkHttp； 2.目录 3.定义 一款处理网络请求的开源项目，由Square公司贡献。 4.作用 通过建造者模式（Builder Pattern）方式，完成复杂的网络请求。 5.特点 1.同时支持HTTP1.1与支持HTTP2.0； 2.同时支持同步与异步请求； 3.同时具备HTTP与WebSocket功能； 4.拥有自动维护的socket连接池，减少握手次数； 5.拥有队列线程池，轻松写并发； 6.拥有Interceptors(拦截器)，轻松处理请求与响应额外需求(例：请求失败重试、响应内容重定向等等)； 6.OkHttp系统图 7.OkHttpClient(封装请求参数) OkHttpClient通过建造者模式方式，完成请求参数配置。常用如下： connectTimeout ：连接超时 readTimeout：读取超时 writeTimeout：写入超时 pingInterval：websocket情况下连接心跳间隔 interceptors：自定义拦截器 networkInterceptors：自定义网络连接成功的拦截器 OkHttpClient 除了完成请求参数的配置之外，还提供获取WebSocket、Call(Call实现类为RealCall，下文会介绍)相关类； 7.1 WebSocket WebSocket是一种在单个TCP连接上进行全双工通信的协议，支持服务器想客户端的发送请求，由OkHttpClient创建，源码如下： 12345678/** * Uses &#123;@code request&#125; to connect a new web socket. */@Override public WebSocket newWebSocket(Request request, WebSocketListener listener) &#123; RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);// 1 webSocket.connect(this); return webSocket;&#125; 注释1：WebSocket是一个接口，它的实现类RealWebSocket，该类完成WebSocket的连接、数据请求与接收功能。 7.2 Call初始化1234567891011//OkHttpClient 初始化Call的函数@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125;// RealCall 初始化函数static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call;&#125; 8.RealCall同步异步 RealCall 是真正触发网络请求的类(实现Call接口，一次请求 = 一个RealCall实例)，它提供了同步请求、异步请求； 8.1 同步请求12345678910111213141516171819202122232425262728293031323334353637 @Override public Response execute() throws IOException &#123; // 处理不能重复请求，因为一个RealCall对应一个请求。 synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this);//1 Response result = getResponseWithInterceptorChain();//2 if (result == null) throw new IOException("Canceled"); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis());//3 return chain.proceed(originalRequest);//4 &#125; 注释1：将RealCall实例添加至Dispatcher中(下文会介绍Dispatcher)。注释2：通过getResponseWithInterceptorChain()获取响应。注释3：通过封装好的拦截器集合，获取第一个拦截器的任务。注释4：触发第一个拦截器的任务，该任务就触发一下拦截器的任务，以此类推，原理(Android事件传递机制)如下图： 8.2 异步请求123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));//1&#125; 注释1：把AsyncCall请求对象传递进Dispatcher线程池管理； AsyncCall 将请求业务放入到Runnable中。 1234567891011121314151617181920212223242526final class AsyncCall extends NamedRunnable &#123; // ...... @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain();//2 if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;&#125; 注释2：通过getResponseWithInterceptorChain()获取响应; 9.Dispatcher线程池 Dispatcher 管理网络请求的线程池，其实就是把同步(RealCall)与异步(AsyncCall)的请求放进集合中统一管理，然后通过线程池执行AsyncCall的请求。 9.1 Dispatcher中同步(RealCall) RealCall在Dispatcher中，其实主要就是一个存储功能(即用一个集合把RealCall的请求进行存储)。 9.2 Dispatcher中异步(AsyncCall) AsyncCall在Dispatcher中，除了使用集合存储AsyncCall的请求，Dispatcher还初始化了一个线程池(ThreadPoolExecutor)处理AsyncCall的网络请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public final class Dispatcher &#123; //最大请求数量 private int maxRequests = 64; //相同host的最大请求数据 private int maxRequestsPerHost = 5; // ...... public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false));//1 &#125; return executorService; &#125; // ...... synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;//2 runningAsyncCalls.add(call);//3 executorService().execute(call);//4 &#125; else &#123; readyAsyncCalls.add(call);//5 &#125; &#125; /** Used by &#123;@code AsyncCall#run&#125; to signal completion. */ void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true); &#125; /** Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call, false);//6 &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls();//7 runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125; &#125; // ......&#125; 注释1：获取自定义线程池；注释2：判断正在执行的异步请求数量与请求集合中相同host的数量是否满足，如果满足就添加到执行中的集合中，并添加至线程池中执行请求；如果不满足就添加至待执行请求的集合中，等待执行中的请求完成之后，再执行相同host数量判断满足才添加至线程池中执行请求；注释3：将请求对象AsyncCall添加进请求执行的集合中；注释4：将请求对象AsyncCall添加进线程池中执行；注释5：当不满足执行条件时(注释2)，把请求对象添加至待执行的集合中；注释6：每当一个请求执行完毕时，就会调用finished()去掉对应集合中的存储对象，并在次判断待执行的集合中是否有满足条件的请求，若满足就添加至执行的集合与线程池中执行，若不满足继续等待下一个请求完成再次判断。注释7：判断待执行的集合中是否满足可执行的对象。 10.Interceptor拦截器及调用链 Interceptor 拦截器，供使用者可在请求过程或者响应过程中自定义额外的业务处理(例如：最常见的请求失败重试、响应数据的重定向等等)。 OkHttp3中，除了可自定义额外的拦截器之外，它内部也存储一些固定的拦截器处理其内部业务逻辑，下面就会介绍它们(RetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、CallServerInterceptor)； 10.1 RetryAndFollowUpInterceptor 定义：重定向拦截器； 作用：在无法请求服务器或者请求失败时，服务器会告诉客户端可以处理请求的url，然后重定向拦截器承当重新请求新url的作用(服务器返回3XX错误码为重定向，可以通过响应头的Location获取新请求的url); 10.2 BridgeInterceptor 定义：桥拦截器； 作用：封装请求头(Content-Type、Connection、Cookie…)与响应头(“Content-Encoding…)的信息。 10.3 CacheInterceptor 定义：缓存拦截器； 作用：为网络请求提供缓存功能，加快相同请求的访问速度，减少资源损耗。 10.4 ConnectInterceptor 定义：连接拦截器； 作用：与服务器建立通讯连接。 10.5 CallServerInterceptor 定义：请求服务器拦截器； 作用：与服务器进行数据通讯(包含请求头、请求内容)。 10.6 调用链 上文也提到任务链结构图(责任链模式)： 其实它的原理类似于(Android 事件传递机制)，向下传递请求，向上反馈响应，在调用RealInterceptorChain的proceed()时，创建下一个拦截器的任务，并通过拦截器中intercept()把任务传递至当前拦截器进行关联，然后以此类推，相关代码如下： 12345678910111213141516public final class RealInterceptorChain implements Interceptor.Chain &#123; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; // ...... // 创建下一个拦截器的任务 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); // 获取当前任务中的拦截器 Interceptor interceptor = interceptors.get(index); // 将下一个任务传递至当前拦截器中进行关联，并在拦截器中传入的任务触发执行下一个拦截器 Response response = interceptor.intercept(next); // ...... return response; &#125;&#125; 11.缓存机制CacheInterceptor 看看缓存机制CacheInterceptor的实现原理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public final class CacheInterceptor implements Interceptor &#123; // .... @Override public Response intercept(Chain chain) throws IOException &#123; // 根据请求内容通过Cache类判断是否已经存在响应的缓存信息 Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // 通过请求对象与缓存对象获取缓存策略，根据请求头的内容(Date、Expires、Last-Modified....)制定缓存策略 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; // 记录请求过程的相关数据（请求次数、缓存次数....） if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // 当请求头中包含only-if-cached时，networkRequest 与 cacheResponse 都为空，表示不进行网络请求 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // 不进行网络请求，并请求头包含缓存标识时，构建缓存内容. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; // 执行下一个拦截器任务 networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // 如果本地有缓存，并且响应结果为没有修改时，直接从本地缓存获取相关信息数据 if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // 更新响应对象至缓存中 cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; // 没有响应缓存时，封装请求返回的响应并添加至本地缓存中 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // 添加本地缓存中 CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; // 去掉（POST\PUT\DELETE\MOVE\PATCH）请求方法的本地缓存 if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125;&#125; 12.连接与请求（StreamAllocation，RealConnection，HttpCodec） OkHttp3把网络连接、请求数据通讯过程封装StreamAllocation，RealConnection，HttpCodec中； StreamAllocation：负责初始化RealConnection、HttpCodec，并将前2者与RealCall进行关联；1.StreamAllocation初始化(在RetryAndFollowUpInterceptor进行实例化) 12345678910public final class RetryAndFollowUpInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; //...... // 实例化 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; //...... &#125;&#125; 2.RealConnection与HttpCodec初始化(RealConnection在ConnectInterceptor中通过StreamAllocation的newStream()初始化，而HttpCodec在RealConnection中被初始化) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final class ConnectInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); boolean doExtensiveHealthChecks = !request.method().equals("GET"); // 获取HttpCodec 对象 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125;public final class StreamAllocation &#123; //...... public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; // 初始化RealConnection，最后会调用RealConnection的connect函数建立网络连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); // 通过RealConnection 实例化HttpCpdec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125; &#125;&#125;public final class RealConnection extends Http2Connection.Listener implements Connection &#123; public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation) throws SocketException &#123; //判断HTTP是否为Http2，如果是实例化Http2Codec，否则实例化Http1Codec if (http2Connection != null) &#123; return new Http2Codec(client, chain, streamAllocation, http2Connection); &#125; else &#123; socket.setSoTimeout(chain.readTimeoutMillis()); source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS); sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS); return new Http1Codec(client, streamAllocation, source, sink); &#125; &#125;&#125; RealConnection：真正的负责完成网络连接； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class RealConnection extends Http2Connection.Listener implements Connection &#123;public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) &#123; if (protocol != null) throw new IllegalStateException("already connected"); RouteException routeException = null; List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs(); ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs); if (route.address().sslSocketFactory() == null) &#123; if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123; throw new RouteException(new UnknownServiceException( "CLEARTEXT communication not enabled for client")); &#125; String host = route.address().url().host(); if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw new RouteException(new UnknownServiceException( "CLEARTEXT communication to " + host + " not permitted by network security policy")); &#125; &#125; else &#123; if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123; throw new RouteException(new UnknownServiceException( "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS")); &#125; &#125; while (true) &#123; try &#123; if (route.requiresTunnel()) &#123; connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) &#123; // We were unable to connect the tunnel but properly closed down our resources. break; &#125; &#125; else &#123; // 最后会调用socket.connect()进行网络连接 connectSocket(connectTimeout, readTimeout, call, eventListener); &#125; establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener); eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol); break; &#125; catch (IOException e) &#123; closeQuietly(socket); closeQuietly(rawSocket); socket = null; rawSocket = null; source = null; sink = null; handshake = null; protocol = null; http2Connection = null; eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e); if (routeException == null) &#123; routeException = new RouteException(e); &#125; else &#123; routeException.addConnectException(e); &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException; &#125; &#125; &#125; if (route.requiresTunnel() &amp;&amp; rawSocket == null) &#123; ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: " + MAX_TUNNEL_ATTEMPTS); throw new RouteException(exception); &#125; if (http2Connection != null) &#123; synchronized (connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams(); &#125; &#125; &#125;&#125; HttpCodec： 负责完成发送请求头与数据内容(使用okio完成数据的写入与读出)； Http1Codec：处理HTTP1.1协议的数据传递。 Http2Codec：处理HTTP2.0协议的数据传递。 13.实例 编写一个简单GET请求： 12345678910111213141516171819public void get()&#123; OkHttpClient okHttpClient = new OkHttpClient() .newBuilder()// .addInterceptor() .readTimeout(30, TimeUnit.SECONDS) .build(); Request request = new Request.Builder()// .header() .url("http://www.baidu.com") .build(); okHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;);&#125; 14.总结 到此，Android OkHttp3就讲解完毕。]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp3源码分析一]]></title>
    <url>%2Fposts%2F1eadb261.html</url>
    <content type="text"><![CDATA[一、OkHttp3流程图 二、源码整体架构 上图是OkHttp3的整体框架，大致可以分为以下几层： Interface——接口层：接收用户的网络访问请求（同步请求/异步请求），发起实际的网络访问 Protocol——协议层：处理协议逻辑 Connection——连接层：管理网络连接，发送新的请求，接收服务器访问 Cache——缓存层：管理本地缓存 I/O——I/O层：实际数据读写实现 Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑 2.1 Interface——接口层接口层接收用户的网络访问请求（同步请求/异步请求），发起实际的网络访问 OkHttpClient：是OkHttp框架的客户端，更确切的说是一个用户面板。用户使用OkHttp进行各种设置，发起各种网络请求都是通过OkHttpClient完成的。每个OkHttpClient内部都维护了属于自己的任务队列，连接池，Cache，拦截器等，所以在使用OkHttp作为网络框架时应该全局共享一个OkHttpClient实例。 Call：Call是描述一个实际的访问请求，用户的每一个网络请求都是一个Call实例。Call本身只是一个接口，定义了Call的接口方法，实际执行过程中，OkHttp会为每一个请求创建一个RealCall,每一个RealCall内部有一个AsyncCall，AsyncCall是RealCall的一个内部类并且继承NamedRunnable，那么首先看NamedRunnable类是什么样的，如下： 1234567891011121314public abstract class NamedRunnable implements Runnable &#123; ...... @Override public final void run() &#123; ...... try &#123; execute(); &#125; ...... &#125; protected abstract void execute();&#125; NamedRunnable实现了Runnable接口并且是一个抽象类，有一个抽象方法execute()，这个方法在run()中被调用。这也就意味着NamedRunnable是一个线程，并且其子类应该实现execute方法。下面再看AsyncCall的实现： 1234567891011121314151617181920212223242526272829final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super("OkHttp %s", redactedUrl()); this.responseCallback = responseCallback; &#125; ......final class RealCall implements Call &#123; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; ...... responseCallback.onFailure(RealCall.this, e);&#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; AsyncCall继承NamedRunnable，实现了抽象方法execute（），所以每一个Call就是一个线程，而执行Call的过程就是执行其execute（）方法的过程。 Dispatcher(调度器)是OkHttp的任务队列，其内部维护了一个线程池，当有接收到一个Call时，Dispatcher负责在线程池中找到空闲的线程并执行其execute方法。 针对异步请求，Dispatcher使用了两个Deque，一个保存准备执行的请求，一个保存正在执行的请求，为什么要用两个呢？因为Dispatcher默认支持最大的并发请求是64个，单个Host最多执行5个并发请求，如果超过，则Call会先被放入到readyAsyncCall中，当出现空闲的线程时，再将readyAsyncCall中的线程移入到runningAsynCalls中，执行请求。 如果正在执行的请求总数&lt;=64 &amp;&amp; 单个Host正在执行的请求&lt;=5，则将请求加入到runningAsyncCalls集合中，紧接着就是利用线程池执行该请求，否则就将该请求放入readyAsyncCalls集合中。 2.2 Protocol——协议层Protocol层负责处理协议逻辑，OkHttp支持Http1/Http2/WebSocket协议，并在3.7版本中放弃了对Spdy协议，鼓励开发者使用Http/2。在早期的版本中，OkHttp支持Http1.0,1.1,SPDY协议，但是Http2协议的问世，导致OkHttp也做出了改变，OkHttp鼓励开发者使用HTTP2，不再对SPDY协议给予支持。另外，新版本的OkHttp还有一个新的亮点就是支持WebScoket，这样我们就可以非常方便的建立长连接了。在安全方便，OkHttp目前支持了TLS版本，以确保一个安全的Socket连接。 2.3 Connection——连接层：管理网络连接，发送新的请求，接收服务器访问连接层顾名思义就是负责网络连接。在连接层中有一个连接池，统一管理所有的Socket连接，当用户新发起一个网络请求时，OkHttp会首先从连接池中查找是否有符合要求的连接，如果有则直接通过该连接发送网络请求；否则新创建一个网络连接。虽然你只需要提供URL,但OkHttp计划它连接到您的网络服务器需要使用三种类型:URL,地址和路线. RealConnection：描述一个物理Socket连接，连接池中维护多个RealConnection实例。StreamAllocation： 由于Http/2支持多路复用，一个RealConnection可以支持多个网络访问请求，所以OkHttp又引入了StreamAllocation来描述一个实际的网络请求开销（从逻辑上一个Stream对应一个Call，但在实际网络请求过程中一个Call常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个Stream对应一次请求，而一个Call对应一组有逻辑关联的Stream），一个RealConnection对应一个或多个StreamAllocation,所以StreamAllocation可以看做是RealConenction的计数器，当RealConnection的引用计数变为0，且长时间没有被其他请求重新占用就将被释放。 2.4 Cache——缓存层Cache层负责维护请求缓存，当用户的网络请求在本地已有符合要求的缓存时，OkHttp会直接从缓存中返回结果，从而节省网络开销。 缓存策略：提到缓存策略，就要提到CacheInterceptor拦截器，如下图 CacheStrategy实现缓存策略，CacheStrategy使用Factory模式进行构造，该类决定是使用缓存还是使用网络请求 Cache是封装了实际的缓存操作；DiskLruCache:Cache基于DiskLruCache； 2.5 I/O层I/O层负责实际的数据读写。OkHttp的另一大有点就是其高效的I/O操作，这归因于其高效的I/O库okio。 2.6 Inteceptor——拦截器层拦截器是一种强大的机制,可以监视、重写和重试调用。拦截器层提供了一个类AOP接口，方便用户可以切入到各个层面对网络访问进行拦截并执行相关逻辑。 三、为什么okHttp3 好用呢？OkHttp是一个精巧的网络请求库,有如下特性: 支持http2，对一台机器的所有请求共享同一个socket 内置连接池，支持连接复用，减少延迟 支持透明的gzip压缩响应体 通过缓存避免重复的请求 请求失败时自动重试主机的其他ip，自动重定向 好用的API 四、实现网络请求方法:OkHttp3的最底层是Socket，而不是URLConnection，它通过Platform的Class.forName()反射获得当前Runtime使用的socket库 socket发起网络请求的流程一般是：(1). 创建socket对象;(2). 连接到目标网络;(3). 进行输入输出流操作。 (1)(2)的实现，封装在connection接口中，具体的实现类是RealConnection。(3)是通过stream接口来实现，根据不同的网络协议，有Http1xStream和Http2xStream两个实现类由于创建网络连接的时间较久(如果是HTTP的话，需要进行三次握手)，而请求经常是频繁的碎片化的，所以为了提高网络连接的效率，OKHttp3实现了网络连接复用 五、运用到的设计模式：单例模式：（建议用单例模式创建okHttpClient）OkHttpClient， 可以通过 new OkHttpClient() 或 new OkHttpClient.Builder() 来创建对象， 但是—特别注意， OkHttpClient() 对象最好是共享的， 建议使用单例模式创建。 因为每个 OkHttpClient 对象都管理自己独有的线程池和连接池。 这一点很多同学，甚至在我经历的团队中就有人踩过坑， 每一个请求都创建一个 OkHttpClient 导致内存爆掉 *外观模式 : *OKHttpClient 里面组合了很多的类对象。其实是将OKHttp的很多功能模块，全部包装进这个类中，让这个类单独提供对外的API，这种设计叫做外观模式（外观模式：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口） Builder模式 : OkHttpClient 比较复杂， 太多属性， 而且客户的组合需求多样化， 所以OKhttp使用建造者模式（Build模式：使用多个简单的对象一步一步构建成一个复杂的对象，一个 Builder 类会一步一步构造最终的对象） 工厂方法模式：Call接口提供了内部接口Factory(用于将对象的创建延迟到该工厂类的子类中进行，从而实现动态的配置，工厂方法模式。（工厂方法模式：这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。） 享元模式：在Dispatcher的线程池中，所用到了享元模式，一个不限容量的线程池 ， 线程空闲时存活时间为 60 秒。线程池实现了对象复用，降低线程创建开销，从设计模式上来讲，使用了享元模式。（享元模式：尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象，主要用于减少创建对象的数量，以减少内存占用和提高性能） 责任链模式：很明显，在okhttp中的拦截器模块，执行过程用到。OkHttp3 的拦截器链中， 内置了5个默认的拦截器，分别用于重试、请求对象转换、缓存、链接、网络读写（责任链模式：为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。） 策略模式 ：CacheInterceptor 实现了数据的选择策略， 来自网络还是来自本地？ 这个场景也是比较契合策略模式场景， CacheInterceptor 需要一个策略提供者提供它一个策略（锦囊）， CacheInterceptor 根据这个策略去选择走网络数据还是本地缓存。缓存的策略过程：1、 请求头包含 “If-Modified-Since” 或 “If-None-Match” 暂时不走缓存2、 客户端通过 cacheControl 指定了无缓存，不走缓存3、客户端通过 cacheControl 指定了缓存，则看缓存过期时间，符合要求走缓存。 4、 如果走了网络请求，响应状态码为 304（只有客户端请求头包含 “If-Modified-Since” 或 “If-None-Match” ，服务器数据没变化的话会返回304状态码，不会返回响应内容）， 表示客户端继续用缓存。 （策略模式：一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。） 六、源码中用到的几个重要的类及作用解释：OkhttpClient :对外的API，OKHttp的很多功能模块，全部包装进这个类；创建分为两种：一种是new OkHttpClient()的方式，另一种是使用建造者（Builder）模式 – new OkHttpClient.Builder()….Build()。那么这两种方式有什么区别呢？ 第一种：new OkHttpClient()，OkHttp做了很多工作，很多我们需要的参数在这里都获得默认值,也就是默认值设定。 第二种：默认的设置和第一种方式相同，但是我们可以利用建造者模式单独的设置每一个属性；注意事项：OkHttpClient强烈建议全局单例使用，因为每一个OkHttpClient都有自己单独的连接池和线程池，复用连接池和线程池能够减少延迟、节省内存。 RealCall类：集成Call类，从源代码中，可看到使用Call类，发送出（同步／异步）请求.RealCall的主要作用：发送请求，当中还有拦截器的建立过程，异步回调。 Dispatcher类（调度器，多线程）：保存同步和异步Call的地方，并负责执行异步AsyncCall 拦截器链：有用户自定义的interceptor、retryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、 networkInterceptors、CallServerInterceptor。依次通过以上拦截器，传递给RealCall中的ApplicationInterceptorChain。拦截器之所以可以依次调用，并最终再从后先前返回Response，都依赖于ApplicatiionInterceptorChain的proceed方法. HttpEngine类：OKhttp底层的实现]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android各系统版本新特性]]></title>
    <url>%2Fposts%2F50d707a8.html</url>
    <content type="text"><![CDATA[一. 低版本SDK如何实现高版本api？平时如果你的minSdk比较小，但是想调用高版本的一些API，android studio会提醒该方法在XX版本上才有，当前项目minSdk是多少。很多低版本的系统上就会找不到这个方法。 那怎么做呢？可以去support包中找相应的方法。 例如5.0才出的background tint，那么如果你的minSdk是小于5.0的话，那么studio就报错了，你可以去使用support-v4包中的DrawableCompat类。 例如：在5.0上如下调用 12Drawable d = getContext().getResources().getDrawable(R.drawable.defalut_icon_big);d.setTint(0xffffffff); 那么使用DrawableCompat可以这样调用： 12Drawable d = getContext().getResources().getDrawable(R.drawable.defalut_icon_big);DrawableCompat.setTint(d,0xffffffff); 在新的SDK上总是会出现让人眼前一亮非常方便好用的API。但是这些新的API呢在低版本的SDK上是没有的，所以当我们的minSdkVersion的版本低于新API所在的版本时，我们直接使用新API在编译时会出现报错。如果只是想解决编译报错的问题呢，Android给我们提供了两种注解的方式避免编译时报错： @SuppressLint @TargetApi 这两种方法又有什么区别呢？ .SupressLint 和 TargetApi SupressLint很显然的意思是忽略Lint检查，对于我们使用高版本API来说，可以使用@SuppressLint(“NewApi”)的方式让Lint在编译时忽略所调用API对版本的要求。而@TargetApi是忽略特定版本的API调用报错。 举个栗子：当你的项目minSdkVersion=9，你想使用API 11的新的方法时。此时，使用@TargetApi(11)和@SuppressLint(“NewApi”）的效果一样，代码都不会报错。但是如果你使用了Api 19才出现的新的方法时，在使用@TargetApi的方法中还是会给你报错，而在另一个方式中依然不会报错。 那这么讲使用@SuppressLint(“NewApi”)就更好了？ 二. Android 各版本特点Android 1.5（Cupcake纸杯蛋糕）： 智能虚拟键盘；使用widgets实现桌面个性化；在线文件夹(Live Folder)快速浏览在线数据；视频录制和分享；图片上传； 更快的标准兼容浏览器；Voice search 语音搜索；立体声蓝牙和免提电话 Android 1.6（Donut甜甜圈）： 完全重新设计的Android Market，可以显示更多的屏幕截图；手势支持，可以让开发者生成针对某个应用程序的手势库； 支持CDMA网络：中国电信的用户可以期待EVDO的Android手机了； TXT-2-Speech，支持了更多语言的发音，包括英语、法语、德语、意大利语等 快速搜索框，可直接搜索括联系人，音乐，浏览历史，书签等手机内容； 全新的拍照界面：新版相机程序启动速度快了39%，拍照间的延迟减少了28%； 应用程序耗电查看：这下好了，哪个软件耗多少电，现在一见了然了； 新增面向视觉或听觉困难人群的易用性插件； Linux内核升级到2.6.29； 其他：支持更多的屏幕分辨率，如WVGA，QVGA等 Android 2.0 （2.0~2.1 Eclair松饼（闪电泡芙））: 由于文件结构的改动优化，使得整个操作流畅性得到了很大的提升; 自带的Chrome Lite浏览器现在加入了对双击屏幕进行缩放的支持; 加强了网络社交功能，比如Facebook好友整合至联系人功能; 强化了语音识别的搜索控制。整个系统多处都支持语音控制，并拥有独立的控制面板; 谷歌地图服务更新，加入了全新的导航系统，甚至比转业的导航软件更为先进; 加入了原生微软Exchange邮件服务支持; 提供了多个不同帐户，统一的邮件收件箱; 只需双击就能上传图片至YouTube; 优化了驾车时的体验，新的“Car Home”应用程序为各功能提供了易于操作的快捷链接，还能方便地使用语音控制功能，便于用户驾车时使用 Android 2.1 可以同时绑定多个Google账号; 无线控件里有了VPN设置; 增加了连接到PC设置; 增强了语言和声音的转换功能，并加入了文字到语音转换; 全新的拨号界面，按键更大，更易于操作; 更多桌面Widget; 新的Google地图可以使用谷歌地图导航功能; 新的浏览器版本，加强了稳定性和网页渲染能力; 全局搜索功能加强; 全新的Market程序，搜索更快布局更合理 Android 2.2(Froyo冻酸奶): 全面支持Flash 10.1; 应用程序自动升级，让升级更加人性化; 支持应用程序安装在外置内存上; Linux内核将升级为最新的2.6.32版本，系统更加稳定; 对系统性能进一步优化，让手机有更多的运行内存; 增加了轨迹球LED指示灯变色这个新功能; 增加了对3D性能的优化，3D性能更加强大; FM功能也将在新系统中得到全面支持 Android 2.3(2.3 Gingerbread姜饼) 用户界面更美观; 提升游戏体验; 提升多媒体能力; 增加官方进程管理; 改善电源管理; NFC近场通信; 全局下载管理; 全新虚拟键盘; 原生支持前置前置摄像头; SIP网络电话 Android3.0到3.1(3.0 Honeycomb 蜂巢)：安卓3.0系统主要用于安卓的平板产品，画面动感，可操控性更强，代表有摩托罗拉的平板产品XOOM，3.1也已经发布，也主要用于平板产品。 Android4.0(4.0 Ice CreamSandwich)1、单一系统 Android 4.0将只提供一个版本，同时支持智能手机、平板电脑、电视等设备。2、一流的新UI3、开源 此前Android 3.0曾一度宣布不采取开源措施，然而谷歌深知Android系统一大成功特性就是开源。平板上吃到的苦头势必在全新的Android 4.0上避免，用户为中心的刷机资源一定会让Android 4.0锦上添花。 Android5.01、android 5.0 Hello 5.0 5.0的版本号就能告诉我们，这是一个大的升级版本。 2、基于Linux内核3.0 Linux刚刚发布Linux 3.0内核没多久，后来又更新到了3.0.1 。 3、通过Android Market购买音乐谷歌已经试水性质的推出了Google Music Beta ，允许上传2万首音乐到Google的云端服务器，自动创建播放列表在任何支持flash的设备上回放，我们有理由相信这种在Appstore影响下的数字视频、音频服务内容的提供也将会出现在Android上。 4、多核处理器优化现在各厂商都在推双核的智能手机，实际的效果如何我们不予评说，但Android 4.0将特别为使用双核乃至多核处理器的手机进行专门的优化。 5、运行速度比3.1提高1.8倍Google的人员只是这么一说，并没有提及这个性能具体体现在什么方面，因此我们不知道这是关于浏览器、GPU还是整体性能，只有等待。 6、集成Google电视和Chrome OS的智能停放 7、为OEM提供了官方的主题引擎 有了这个引擎，便可通过Google的升级程序更新到这些第三方的主题。 8、苹果游戏中心的一个真正的竞争者 9、支持现有的智能手机 据称现行所有运行Android 2.3的手机都有可能升级到4.0版本，这条消息是我喜闻乐见的，而Google官方的Nexus One和Nexus S将是第一批升级到4.0的手机。 10、新的摄影技巧以及虚拟摄像机 这将为开发者提供更丰富的摄像头控制API。 android 6.0锁屏下语音搜索 用户可以直接在锁屏状态下进行语音搜索，虽然现在的一些安卓手机支持语音唤醒功能，但这些语音唤醒都是第三方厂商开发的，而此次的Android 6.0在系统层面加入锁屏下语音搜索，这无疑会在体验上有一个明显的提升。 指纹识别 说到指纹识别，很多用户都会觉得现在的中高端安卓手机都支持，但事实上这些安卓手机的指纹识别都是各个厂商自行开发的并没有系统底层的支持。Android 6.0则在系统层面加入指纹识别，能提供原生指纹识别API，这不但降低了厂商开发指纹识别模块的成本，最重要的是原生指纹识别将会大大提升安卓手机的指纹识别支付安全性。 更完整的应用权限管理 在此前的原生安卓系统中有应用通知管理功能，但更为深入的应用权限管理只能靠第三方应用实现。Android 6.0进一步强化应用权限管理，应用权限管理也成为系统级的功能，不过这对于那些权限管理软件来说并不是什么好消息。 Doze电量管理 Android 6.0自带Doze电量管理功能，在“Doze”模式下，手机会在一段时间未检测到移动时，让应用休眠清杀后台进程减少功耗，谷歌表示，当屏幕处于关闭状态，平均续航时间提高30%。 Now on Tap功能 Now on Tap功能是和Google搜索紧密结合的功能，它可以让谷歌从任何应用中进行搜索。例如，在微信中聊天的时候提到餐馆，那么就可以在不跳转的情况下进行谷歌搜索。 App Links 通过App Links功能，Android平台能够向网络服务器提出申请，自主识别链接内容。直接跳转到App客户端中，改善用户体验，有利于让用户在体验更完善的App客户端完成更多操作。 此外，在Android 6.0谷歌还加入了Android Pay进一步强化移动支付，同时也是为了对抗Apple Pay。在发布会上谷歌表示Android 6.0将在下周开始推送，Nexus5/6/7/9以及Nexus Player将能够在第一时间得到升级。 Android7.0分屏多任务 进入后台多任务管理页面，然后按住其中一个卡片，然后向上拖动至顶部即可开启分屏多任务，支持上下分栏和左右分栏，允许拖动中间的分割线调整两个APP所占的比例。目前，安卓7.0开发者预览版支持全部第三方应用尝试分屏操作，但个别应用适配可能存在问题，分屏后可能导致界面显示不全等问题. 全新下拉快捷开关页 在安卓7.0中，下拉打开通知栏顶部即可显示5个用户常用的快捷开关，支持单击开关以及长按进入对应设置。如果继续下拉通知栏即可显示全部快捷开关，此外在快捷开关页右下角也会显示一个“编辑”按钮，点击之后即可自定义添加/删除快捷开关，或拖动进行排序。 通知消息快捷回复 安卓7.0加入了全新的API，支持第三方应用通知的快捷操作和回复，例如来电会以横幅方式在屏幕顶部出现，提供接听/挂断两个按钮；信息/社交类应用通知，还可以直接打开键盘，在输入栏里进行快捷回复。 通知消息归拢 安卓7.0会将同一应用的多条通知提示消息归拢为一项，点击该项即可展开此前的全部通知，允许用户对每个通知执行单独操作。 夜间模式 安卓7.0中重新加入了夜间深色主题模式，该功能依然需要在系统调谐器中开启，从顶部下划打开快捷设置页，然后长按其中的设置图标，齿轮旋转10秒钟左右即可提示已开启系统调谐器，之后用户在设置中即可找到“系统调谐器”设置项。点开其中的“色彩和外观”，即可找到夜间模式，开启后即可使用全局的深色主题模式，同时亮度和色彩也会进行一定的调整，该功能可以基于时间或地理位置自动开启。另外，系统调谐器中也提供了RGB红绿蓝三色调节滑动条，允许用户手动精细调节，例如减少蓝色或增加红色以提供类似护眼模式的效果。 流量保护模式 安卓7.0新增的流量保护模式不仅可以禁止应用在后台使用流量，还会进一步减少该应用在前台时的流量使用。其具体实现原理目前尚不清楚，推测其有可能使用了类似Chrome浏览器的数据压缩技术。此外，谷歌还扩展了ConnectivityManager API的能力，使得应用可以检测系统是否开启了流量保护模式，或者检测自己是否在白名单中。安卓7.0允许用户单独针对每个应用，选择是否开启数据保护模式。 全新设置样式 安卓7.0启用了全新的设置样式，首先每个分类下各个子项之间的分割线消失了，只保留分类之间的分割线。全新的设置菜单还提供了一个绿色的顶栏，允许用户通过后方的下拉箭头，快速设定勿扰模式等。除了勿扰模式外，顶栏菜单还可以显示诸多其他的设置状态，例如数据流量的使用情况，自动亮度是否开启等。谷歌也在安卓7.0的设置中加入了汉堡菜单，在二级设置界面中的左上角，你就会看到这个汉堡菜单，点击后即可看到所有设置项，方便用户快速跳转。 改进的Doze休眠机制 谷歌在安卓7.0中对Doze休眠机制做了进一步的优化，在此前的安卓6.0中，Doze深度休眠机制对于改善安卓的续航提供了巨大的作用。而在安卓7.0中，谷歌对Doze进行了更多的优化，休眠机制的使用规则和场景有所扩展，例如只要手动在后台删掉应用卡片，关屏后该应用就会被很快深度休眠。 系统级电话黑名单功能 安卓7.0将电话拦截功能变成了一个系统级功能。其它应用可以调用这个拦截名单，但只有个别应用可以写入，包括拨号应用、默认的短信应用等。被拦截号码将不会出现在来电记录中，也不会出现通知。另外用户也可以通过账户体系备份和恢复这个拦截名单，以便快速导入其它设备或账号。 菜单键快速应用切换 双击菜单键，就能自动切换到上一个应用。此外，如果你不停地点击菜单键的话，就会在所有应用中不间断地轮换，应用窗口会自动放大，顶部还会出现倒计时条，停止点击且倒计时结束后，当前应用会自动放大并返回到前台。 Android8.0的正式版 Android Oreo（奥利奥）1.通知中心 用户在通知界面可以发现顶部的快捷键有了更充裕的空间，并且根据网络大数据的用户使用频繁度调整了这几个快捷键的顺序；并且长按推送消息可以看到一个开关，操作它可以开启和关闭这个该应用的未来所有通知。 2.设置菜单 在新的AndroidO系统中，设置的界面有了大幅变化，主菜单的覆盖性变得更广，更多的功能将在子菜单中体现，并且在菜单界面中重新设计了很多图标。 3.PinnedShortcuts 安卓创造出了PinnedShortcuts功能，类似苹果的3DTouch，长按一个软件后可以弹出子菜单，然后就可以通过这个方式快捷的使用该应用的部分功能。 4.图标形状 新的系统中开发者可以使用不同的应用图标，比如圆角矩形或者圆形图标，不过所有的图标需要保证是同一个形状，不能有一个方一个圆这样“个性”的样式出现。 5.后台限制 AndroidO将进一步优化后台程序，减少应用在没完全退出后占用系统的资源，并且减少电量的消耗。 6.安装限制 新系统中用户可以在权限设置中添加安装限制功能，这样可以有效的避免带有中国特色的“全家桶”行为。 7.TensorFlowLite 这个新功能并不会直接体现在手机和系统中，它是谷歌的一项新技术，用来把人工智能在更多的软件上继续拓展，并提高工作处理的效率，让你的手机更“聪明”。 8.分屏 在AndroidO中，分屏画中画功能得到了强化，变得更加流畅，而且悬浮窗可以随意拖动位置，然后在主屏幕中继续工作 NotificationDots 在谷歌的Pixel手机上，安卓8还新加了通知功能Notification Dots，会标出用户的行程、信息等，有些通知还可以被设定为稍后提醒。此外长按某个应用图标现在可以显示一些信息，与iOS上的3D Touch类似，这项功能在安卓7.0上已经有所体现 10.SmartTextSelection 系统将会预测用户将使用某些电话或者其他选项出现在将会用到的应用中，举个例子就是如果邀请朋友来吃饭，系统会根据发送的地址来开启地图并且导航 。 11.自动保存密码 这个功能将会保存用户的部分帐号和密码，用于在网站或者应用中的快速登录，效率提升了不少 。 12.GooglePlayProtect 这个功能主要用于GooglePlay中，下载的应用和游戏将会经过它的排查，来看看是否是有害甚至携带病毒的应用，不过国内用户可能不能访问GooglePlay 。 13.应用加速 在AndroidO中，大部分应用的启动速度将会快上一倍，这个要归功于新系统的优化，使后台占用资源减少，并且对并发进程等问题的处理更加出色，也是个相当有用的功能 。 14.字体优化 AndroidO中谷歌还增加了对系统字体的更多支持，开发者可以自行更改字体样式，让用户有了更多字体的选择 。 15.表情符号 安卓8还带来了符合Unicode 10标准的表情符号，比原来新加超过60个表情符，这也是比较明显的改变之一 AndroidP 9.0新功能包括：谷歌统一推送升级、深度集成Project Treble模式、更加封闭、原生支持通话录音等。 1.全面屏的全面支持 2.通知栏的多种通知 3.多摄像头的更多画面 4.GPS定位之外的WiFi定位 5.网络还有神经网络 6.Material Design迎来2.0时代 新设计： Android 9.0将会新增支持类似于iPhone X的刘海屏设计，具体体现为优化屏幕内容显示，能够让系统或者应用充分利用整块屏幕，尤其是两只“猫耳朵”位置。在Android 9.0系统当中，谷歌还会进一步将谷歌助手集成到应用中、进一步优化电池续航、支持多屏和可折叠屏等。 新特性： 全局黑夜模式 为具备Always-on display（屏幕常显）功能手机加入原生的天气支持。 AndroidQ 10.0暗黑模式 Android Q 的暗黑模式和 Android Pie 的暗黑模式不同，在 Android Q 中，暗黑模式适用于任何地方，如果应用不支持暗黑模式，那么系统将自动设置一个暗黑模式。 隐私增强 Android Q 还将更多地使用 Android Pie 中推出的隐私功能。 在 Android Q中，您可以选择应用程序在后台运行时是否可以访问该位置。 运营商锁定 如果你从运营商那里购买锁定的 Android Q 设备，他们将有能力阻止你使用其他特定运营商的SIM卡。 多显示器支持 系统底层支持将设备连接到外接的显示器，并可以同时使用两个屏幕显示。如手机/平板电脑或独立显示器，实际效果可以参考已经从第三方获得支持的华为Mate 10、三星Galaxy Note 9。 Vulkan API 系统底层支持用于 UI 呈现的 Vulkan API 接口规范，基于这项技术原理的更多扩展，将完成更强的系统及程序优化，以更好的获得延长电池寿命、实现更流畅的动画展现和菜单转换效果。 面部识别 XDA 团队发现了一串字符串，这些字符串表明 Android 10 将具有内部面部识别功能。 这意味着谷歌官方支持面部解锁系统。 桌面模式 Android Q 将支持桌面模式，类似三星 Dex 和华为的投影模式。它提供类似一个类似于 PC 的体验，但是远远不能代替 PC。 屏幕录制 得益于OPPO、三星和华为等第三方OEM厂商，我们以前在安卓手机上见过录屏功能。遗憾的是，原生安卓系统还缺少这个功能，但看起来我们在Android Q系统上终于要看到它了。 更安全Smart Lock 谷歌早在Android Lollipop时代就引入了Smart Lock功能，本质上就是当你的手机不在身边时，你可以把远程它锁起来。这个功能还可以让用户根据位置(比如家和二公司)、不同的蓝牙设备(比如运动手环)，或者不同的使用时间来自动解锁设备。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android权限大全]]></title>
    <url>%2Fposts%2Fcf915ee9.html</url>
    <content type="text"><![CDATA[概述Android安全架构规定：默认情况下，任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。这包括读写用户的私有数据（如联系人或电子邮件等）、读写其他应用的文件、执行网络访问、使设备保持唤醒状态等等。如果要使用这些受保护的设备功能，首先要在应用的清单文件(AndroidManifest.xml)中添加一个或多个 标记： 12345&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.app.myapp" &gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; ...&lt;/manifest&gt; 概述 权限 说明 访问登记属性 android.permission.ACCESS_CHECKIN_PROPERTIES 读取或写入登记check-in数据库属性表的权限 获取错略位置 android.permission.ACCESS_COARSE_LOCATION 通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米 获取精确位置 android.permission.ACCESS_FINE_LOCATION 通过GPS芯片接收卫星的定位信息，定位精度达10米以内 访问定位额外命令 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 允许程序访问额外的定位提供者指令 获取模拟定位信息 android.permission.ACCESS_MOCK_LOCATION 获取模拟定位信息，一般用于帮助开发者调试应用 获取网络状态 android.permission.ACCESS_NETWORK_STATE 获取网络信息状态，如当前的网络连接是否有效 访问Surface Flinger android.permission.ACCESS_SURFACE_FLINGER Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 获取WiFi状态 android.permission.ACCESS_WIFI_STATE 获取当前WiFi接入的状态以及WLAN热点的信息 账户管理 android.permission.ACCOUNT_MANAGER 获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 验证账户 android.permission.AUTHENTICATE_ACCOUNTS 允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 电量统计 android.permission.BATTERY_STATS 获取电池电量统计信息 绑定小插件 android.permission.BIND_APPWIDGET 允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 绑定设备管理 android.permission.BIND_DEVICE_ADMIN 请求系统管理员接收者receiver，只有系统才能使用 绑定输入法 android.permission.BIND_INPUT_METHOD 请求InputMethodService服务，只有系统才能使用 绑定RemoteView android.permission.BIND_REMOTEVIEWS 必须通过RemoteViewsService服务来请求，只有系统才能用 绑定壁纸 android.permission.BIND_WALLPAPER 必须通过WallpaperService服务来请求，只有系统才能用 使用蓝牙 android.permission.BLUETOOTH 允许程序连接配对过的蓝牙设备 蓝牙管理 android.permission.BLUETOOTH_ADMIN 允许程序进行发现和配对新的蓝牙设备 变成砖头 android.permission.BRICK 能够禁用手机，非常危险，顾名思义就是让手机变成砖头 应用删除时广播 android.permission.BROADCAST_PACKAGE_REMOVED 当一个应用在删除时触发一个广播 收到短信时广播 android.permission.BROADCAST_SMS 当收到短信时触发一个广播 连续广播 android.permission.BROADCAST_STICKY 允许一个程序收到广播后快速收到下一个广播 WAP PUSH广播 android.permission.BROADCAST_WAP_PUSH WAP PUSH服务收到后触发一个广播 拨打电话 android.permission.CALL_PHONE 允许程序从非系统拨号器里输入电话号码 通话权限 android.permission.CALL_PRIVILEGED 允许程序拨打电话，替换系统的拨号器界面 拍照权限 android.permission.CAMERA 允许访问摄像头进行拍照 改变组件状态 android.permission.CHANGE_COMPONENT_ENABLED_STATE 改变组件是否启用状态 改变配置 android.permission.CHANGE_CONFIGURATION 允许当前应用改变配置，如定位 改变网络状态 android.permission.CHANGE_NETWORK_STATE 改变网络状态如是否能联网 改变WiFi多播状态 android.permission.CHANGE_WIFI_MULTICAST_STATE 改变WiFi多播状态 改变WiFi状态 android.permission.CHANGE_WIFI_STATE 改变WiFi状态 清除应用缓存 android.permission.CLEAR_APP_CACHE 清除应用缓存 清除用户数据 android.permission.CLEAR_APP_USER_DATA 清除应用的用户数据 底层访问权限 android.permission.CWJ_GROUP 允许CWJ账户组访问底层信息 手机优化大师扩展权限 android.permission.CELL_PHONE_MASTER_EX 手机优化大师扩展权限 控制定位更新 android.permission.CONTROL_LOCATION_UPDATES 允许获得移动网络定位信息改变 删除缓存文件 android.permission.DELETE_CACHE_FILES 允许应用删除缓存文件 删除应用 android.permission.DELETE_PACKAGES 允许程序删除应用 电源管理 android.permission.DEVICE_POWER 允许访问底层电源管理 应用诊断 android.permission.DIAGNOSTIC 允许程序到RW到诊断资源 禁用键盘锁 android.permission.DISABLE_KEYGUARD 允许程序禁用键盘锁 转存系统信息 android.permission.DUMP 允许程序获取系统dump信息从系统服务 状态栏控制 android.permission.EXPAND_STATUS_BAR 允许程序扩展或收缩状态栏 工厂测试模式 android.permission.FACTORY_TEST 允许程序运行工厂测试模式 使用闪光灯 android.permission.FLASHLIGHT 允许访问闪光灯 强制后退 android.permission.FORCE_BACK 允许程序强制使用back后退按键，无论Activity是否在顶层 访问账户Gmail列表 android.permission.GET_ACCOUNTS 访问GMail账户列表 获取应用大小 android.permission.GET_PACKAGE_SIZE 获取应用的文件大小 获取任务信息 android.permission.GET_TASKS 允许程序获取当前或最近运行的应用 允许全局搜索 android.permission.GLOBAL_SEARCH 允许程序使用全局搜索功能 硬件测试 android.permission.HARDWARE_TEST 访问硬件辅助设备，用于硬件测试 注射事件 android.permission.INJECT_EVENTS 允许访问本程序的底层事件，获取按键、轨迹球的事件流 安装定位提供 android.permission.INSTALL_LOCATION_PROVIDER 安装定位提供 安装应用程序 android.permission.INSTALL_PACKAGES 允许程序安装应用 内部系统窗口 android.permission.INTERNAL_SYSTEM_WINDOW 允许程序打开内部窗口，不对第三方应用程序开放此权限 访问网络 android.permission.INTERNET 访问网络连接，可能产生GPRS流量 结束后台进程 android.permission.KILL_BACKGROUND_PROCESSES 允许程序调用killBackgroundProcesses(String).方法结束后台进程 管理账户 android.permission.MANAGE_ACCOUNTS 允许程序管理AccountManager中的账户列表 管理程序引用 android.permission.MANAGE_APP_TOKENS 管理创建、摧毁、Z轴顺序，仅用于系统 高级权限 android.permission.MTWEAK_USER 允许mTweak用户访问高级系统权限 社区权限 android.permission.MTWEAK_FORUM 允许使用mTweak社区权限 软格式化 android.permission.MASTER_CLEAR 允许程序执行软格式化，删除系统配置信息 修改声音设置 android.permission.MODIFY_AUDIO_SETTINGS 修改声音设置信息 修改电话状态 android.permission.MODIFY_PHONE_STATE 修改电话状态，如飞行模式，但不包含替换系统拨号器界面 格式化文件系统 android.permission.MOUNT_FORMAT_FILESYSTEMS 格式化可移动文件系统，比如格式化清空SD卡 挂载文件系统 android.permission.MOUNT_UNMOUNT_FILESYSTEMS 挂载、反挂载外部文件系统 允许NFC通讯 android.permission.NFC 允许程序执行NFC近距离通讯操作，用于移动支持 永久Activity android.permission.PERSISTENT_ACTIVITY 创建一个永久的Activity，该功能标记为将来将被移除 处理拨出电话 android.permission.PROCESS_OUTGOING_CALLS 允许程序监视，修改或放弃播出电话 读取日程提醒 android.permission.READ_CALENDAR 允许程序读取用户的日程信息 读取联系人 android.permission.READ_CONTACTS 允许应用访问联系人通讯录信息 屏幕截图 android.permission.READ_FRAME_BUFFER 读取帧缓存用于屏幕截图 读取收藏夹和历史记录 com.android.browser.permission.READ_HISTORY_BOOKMARKS 读取浏览器收藏夹和历史记录 读取输入状态 android.permission.READ_INPUT_STATE 读取当前键的输入状态，仅用于系统 读取系统日志 android.permission.READ_LOGS 读取系统底层日志 读取电话状态 android.permission.READ_PHONE_STATE 访问电话状态 读取短信内容 android.permission.READ_SMS 读取短信内容 读取同步设置 android.permission.READ_SYNC_SETTINGS 读取同步设置，读取Google在线同步设置 读取同步状态 android.permission.READ_SYNC_STATS 读取同步状态，获得Google在线同步状态 重启设备 android.permission.REBOOT 允许程序重新启动设备 开机自动允许 android.permission.RECEIVE_BOOT_COMPLETED 允许程序开机自动运行 接收彩信 android.permission.RECEIVE_MMS 接收彩信 接收短信 android.permission.RECEIVE_SMS 接收短信 接收Wap Push android.permission.RECEIVE_WAP_PUSH 接收WAP PUSH信息 录音 android.permission.RECORD_AUDIO 录制声音通过手机或耳机的麦克 排序系统任务 android.permission.REORDER_TASKS 重新排序系统Z轴运行中的任务 结束系统任务 android.permission.RESTART_PACKAGES 结束任务通过restartPackage(String)方法，该方式将在外来放弃 发送短信 android.permission.SEND_SMS 发送短信 设置Activity观察器 android.permission.SET_ACTIVITY_WATCHER 设置Activity观察器一般用于monkey测试 设置闹铃提醒 com.android.alarm.permission.SET_ALARM 设置闹铃提醒 设置总是退出 android.permission.SET_ALWAYS_FINISH 设置程序在后台是否总是退出 设置动画缩放 android.permission.SET_ANIMATION_SCALE 设置全局动画缩放 设置调试程序 android.permission.SET_DEBUG_APP 设置调试程序，一般用于开发 设置屏幕方向 android.permission.SET_ORIENTATION 设置屏幕方向为横屏或标准方式显示，不用于普通应用 设置应用参数 android.permission.SET_PREFERRED_APPLICATIONS 设置应用的参数，已不再工作具体查看addPackageToPreferred(String)介绍 设置进程限制 android.permission.SET_PROCESS_LIMIT 允许程序设置最大的进程数量的限制 设置系统时间 android.permission.SET_TIME 设置系统时间 设置系统时区 android.permission.SET_TIME_ZONE 设置系统时区 设置桌面壁纸 android.permission.SET_WALLPAPER 设置桌面壁纸 设置壁纸建议 android.permission.SET_WALLPAPER_HINTS 设置壁纸建议 发送永久进程信号 android.permission.SIGNAL_PERSISTENT_PROCESSES 发送一个永久的进程信号 状态栏控制 android.permission.STATUS_BAR 允许程序打开、关闭、禁用状态栏 访问订阅内容 android.permission.SUBSCRIBED_FEEDS_READ 访问订阅信息的数据库 写入订阅内容 android.permission.SUBSCRIBED_FEEDS_WRITE 写入或修改订阅内容的数据库 显示系统窗口 android.permission.SYSTEM_ALERT_WINDOW 显示系统窗口 更新设备状态 android.permission.UPDATE_DEVICE_STATS 更新设备状态 使用证书 android.permission.USE_CREDENTIALS 允许程序请求验证从AccountManager 使用SIP视频 android.permission.USE_SIP 允许程序使用SIP视频服务 使用振动 android.permission.VIBRATE 允许振动 唤醒锁定 android.permission.WAKE_LOCK 允许程序在手机屏幕关闭后后台进程仍然运行 写入GPRS接入点设置 android.permission.WRITE_APN_SETTINGS 写入网络GPRS接入点设置 写入日程提醒 android.permission.WRITE_CALENDAR 写入日程，但不可读取 写入联系人 android.permission.WRITE_CONTACTS 写入联系人，但不可读取 写入外部存储 android.permission.WRITE_EXTERNAL_STORAGE 允许程序写入外部存储，如SD卡上写文件 写入Google地图数据 android.permission.WRITE_GSERVICES 允许程序写入Google Map服务数据 写入收藏夹和历史记录 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS 写入浏览器历史记录或收藏夹，但不可读取 读写系统敏感设置 android.permission.WRITE_SECURE_SETTINGS 允许程序读写系统安全敏感的设置项 读写系统设置 android.permission.WRITE_SETTINGS 允许读写系统设置项 编写短信 android.permission.WRITE_SMS 允许编写短信 写入在线同步设置 android.permission.WRITE_SYNC_SETTINGS 写入Google在线同步设置]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的绘制流程]]></title>
    <url>%2Fposts%2Fbfd836fe.html</url>
    <content type="text"><![CDATA[Android 中 Activity 是作为应用程序的载体存在，代表着一个完整的用户界面，提供了一个窗口来绘制各种视图，当 Activity 启动时，我们会通过 setContentView 方法来设置一个内容视图，这个内容视图就是用户看到的界面。 PhoneWindow 是 Android 系统中最基本的窗口系统，每个 Activity 会创建一个。PhoneWindow 是 Activity 和 View 系统交互的借口。DecorView 本质上是一个 FrameLayout，是 Activity 中所有 View 的祖先。 绘制的整体流程当一个应用启动时，会启动一个主 Activity，Android 系统会根据 Activity 的布局来对它进行绘制。绘制会从根视图 ViewRoot 的 performTraversals() 方法开始，从上到下遍历整个视图树，每个 View 控制负责绘制自己，而 ViewGroup 还需要负责通知自己的子 View 进行绘制操作。视图操作的过程可以分为三个步骤，分别是测量(Measure)、布局(Layout)和绘制(Draw)。performTraversals 方法在类 ViewRootImpl 内，其核心代码如下。 1234567891011int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);...// 测量performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);...// 布局performLayout(lp, mWidth, mHeight);...// 绘制performDraw(); MeasureSpecMeasureSpec 表示的是一个 32 位的整数值，它的高 2 位表示测量模式 SpecMode，低 30 位表示某种测量模式下的规格大小 SpecSize。MeasureSpec 是 View 类的一个静态内部类，用来说明应该如何测量这个View。 三种测量模式。 UNSPECIFIED：不指定测量模式，父视图没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少使用到。 EXACTLY：精确测量模式，当该视图的 layout_width 或者 layout_height 指定为具体数值或者 match_parent 时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值。 AT_MOST：最大值模式，当前视图的 layout_width 或者 layout_height 指定为 wrap_content 时生效，此时子视图的尺寸可以是不超过父视图运行的最大尺寸的任何尺寸。 对 DecorView 而言，它的 MeasureSpec 由窗口尺寸和其自身的 LayoutParams 共同决定；对于普通的 View，它的 MeasureSpec 由父视图的 MeasureSpec 和其本身的 LayoutParams 共同决定。 MeasureMeasure 用来计算 View 的实际大小。页面的测量流程从 performMeasure 方法开始。 1234567891011private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 具体操作是分发给 ViewGroup 的，由 ViewGroup 在它的 measureChild 方法中传递给子 View。ViewGroup 通过遍历自身所有的子 View，并逐个调用子 View 的 measure 方法实现测量操作。 123456789101112131415161718192021222324// 遍历测量 ViewGroup 中所有的 Viewprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125;// 测量某个指定的 Viewprotected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; View (ViewGroup) 的 Measure 方法，最终的测量是通过回调 onMeasure 方法实现的，这个通常由 View 的特定子类自己实现，可以通过重写这个方法实现自定义 View。 1234567891011121314151617181920212223242526272829public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... onMeasure(widthMeasureSpec, heightMeasureSpec); ....&#125;// 如果需要自定义测量，子类需重写这个方法protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;// 如果 View 没有重写onMeasure 方法，默认会直接调用 getDefaultSize public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; LayoutLayout 过程用来确定 View 在父容器的布局位置，他是父容器获取子 View 的位置参数后，调用子 View 的 layout 方法并将位置参数传入实现的。ViewRootImpl 的 performLayout 代码如下。 123456private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125; View 的 layout 方法代码。 1234567public void layout(int l, int t, int r, int b) &#123; onLayout(changed, l, t, r, b);&#125;// 空方法，子类如果是 ViewGroup 类型，则重写这个方法，实现 ViewGroup 中所有 View 控件布局protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; DrawDraw 操作用来将控件绘制出来，绘制的流程从 performDraw 方法开始。performDraw 方法在类 ViewRootImpl 内，其核心代码如下。 123456789101112131415161718private void performDraw() &#123; boolean canUseAsync = draw(fullRedrawNeeded);&#125;private boolean draw(boolean fullRedrawNeeded) &#123; ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) &#123; return false; &#125;&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets) &#123; ... mView.draw(canvas); ...&#125; 最终调用到每个 View 的 draw 方法绘制每个具体的 View，绘制基本上可以分为六个步骤。 123456789101112131415161718192021222324public void draw(Canvas canvas) &#123; ... // Step 1, draw the background, if needed if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; ... // Step 2, save the canvas' layers saveCount = canvas.getSaveCount(); ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers canvas.drawRect(left, top, right, top + length, p); ... canvas.restoreToCount(saveCount); ... // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas);&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中RelativeLayout和LinearLayout性能分析]]></title>
    <url>%2Fposts%2Fe61a64df.html</url>
    <content type="text"><![CDATA[Optimizing Layout HierarchiesIt is a common misconception that using the basic layout structures leads to the most efficient layouts. However, each widget and layout you add to your application requires initialization, layout, and drawing. For example, using nested instances of LinearLayout can lead to an excessively deep view hierarchy. Furthermore, nesting several instances ofLinearLayout that use the layout_weight parameter can be especially expensive as each child needs to be measured twice. This is particularly important when the layout is inflated repeatedly, such as when used in a ListViewor GridView. 这句话是对减少布局层次的描述。 有一个误解就是，使用基类布局可用产生更有效的布局方式。然而每一个你添加到application里面的控件和布局，都需要初始化，布局，绘制。例如，布局复杂的时候使用LinearLayout，会导致深层次的布局嵌套问题，而进一步来说，使用LinearLayout的weight属性给每个子view去分配位置的时候，会导致每一个子view被绘制两次，而LinearLayout嵌套LinearLayout使用weight会更加严重。如果布局被重复的inflated的话，当我们使用ListView或者GridView的时候就会特别明显的影响绘制效率。 先看一些现象吧：用eclipse或者Android studio，新建一个Activity自动生成的布局文件都是RelativeLayout，或许你会认为这是IDE的默认设置问题，其实不然，这是由 android-sdk\tools\templates\activities\BlankActivity\root\res\layout\activity_simple.xml.ftl 这个文件事先就定好了的，也就是说这是Google的选择，而非IDE的选择。那SDK为什么会默认给开发者新建一个默认的RelativeLayout布局呢？当然是因为RelativeLayout的性能更优，性能至上嘛。但是我们再看看默认新建的这个RelativeLayout的父容器，也就是当前窗口的顶级View——DecorView，它却是个垂直方向的LinearLayout，上面是标题栏，下面是内容栏。那么问题来了，Google为什么给开发者默认新建了个RelativeLayout，而自己却偷偷用了个LinearLayout，到底谁的性能更高，开发者该怎么选择呢？ View的一些基本工作原理先通过几个问题，简单的了解写android中View的工作原理吧。 View是什么？简单来说，View是Android系统在屏幕上的视觉呈现，也就是说你在手机屏幕上看到的东西都是View。 View是怎么绘制出来的？View的绘制流程是从ViewRoot的performTraversals（）方法开始，依次经过measure（），layout（）和draw（）三个过程才最终将一个View绘制出来。 View是怎么呈现在界面上的？Android中的视图都是通过Window来呈现的，不管Activity、Dialog还是Toast它们都有一个Window，然后通过WindowManager来管理View。Window和顶级View——DecorView的通信是依赖ViewRoot完成的。 View和ViewGroup什么区别？不管简单的Button和TextView还是复杂的RelativeLayout和ListView，他们的共同基类都是View。所以说，View是一种界面层控件的抽象，他代表了一个控件。那ViewGroup是什么东西，它可以被翻译成控件组，即一组View。ViewGroup也是继承View，这就意味着View本身可以是单个控件，也可以是多个控件组成的控件组。根据这个理论，Button显然是个View，而RelativeLayout不但是一个View还可以是一个ViewGroup，而ViewGroup内部是可以有子View的，这个子View同样也可能是ViewGroup，以此类推。 RelativeLayout和LinearLayout性能PK基于以上原理和大背景，我们要探讨的性能问题，说的简单明了一点就是：当RelativeLayout和LinearLayout分别作为ViewGroup，表达相同布局时绘制在屏幕上时谁更快一点。上面已经简单说了View的绘制，从ViewRoot的performTraversals（）方法开始依次调用perfromMeasure、performLayout和performDraw这三个方法。这三个方法分别完成顶级View的measure、layout和draw三大流程，其中perfromMeasure会调用measure，measure又会调用onMeasure，在onMeasure方法中则会对所有子元素进行measure，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程，接着子元素会重复父容器的measure，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw也分别完成perfromMeasure类似的流程。通过这三大流程，分别遍历整棵View树，就实现了Measure，Layout，Draw这一过程，View就绘制出来了。那么我们就分别来追踪下RelativeLayout和LinearLayout这三大流程的执行耗时。如下图，我们分别用两用种方式简单的实现布局测试下 LinearLayoutMeasure：0.738ms Layout：0.176ms draw：7.655ms RelativeLayoutMeasure：2.280ms Layout：0.153ms draw：7.696ms 从这个数据来看无论使用RelativeLayout还是LinearLayout，layout和draw的过程两者相差无几，考虑到误差的问题，几乎可以认为两者不分伯仲，关键是Measure的过程RelativeLayout却比LinearLayout慢了一大截。 Measure都干什么了RelativeLayout的onMeasure()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768View[] views = mSortedHorizontalChildren; int count = views.length; for (int i = 0; i &lt; count; i++) &#123; View child = views[i]; if (child.getVisibility() != GONE) &#123; LayoutParams params = (LayoutParams) child.getLayoutParams(); int[] rules = params.getRules(layoutDirection); applyHorizontalSizeRules(params, myWidth, rules); measureChildHorizontal(child, params, myWidth, myHeight); if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123; offsetHorizontalAxis = true; &#125; &#125; &#125; views = mSortedVerticalChildren; count = views.length; final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion; for (int i = 0; i &lt; count; i++) &#123; View child = views[i]; if (child.getVisibility() != GONE) &#123; LayoutParams params = (LayoutParams) child.getLayoutParams(); applyVerticalSizeRules(params, myHeight); measureChild(child, params, myWidth, myHeight); if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123; offsetVerticalAxis = true; &#125; if (isWrapContentWidth) &#123; if (isLayoutRtl()) &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; width = Math.max(width, myWidth - params.mLeft); &#125; else &#123; width = Math.max(width, myWidth - params.mLeft - params.leftMargin); &#125; &#125; else &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; width = Math.max(width, params.mRight); &#125; else &#123; width = Math.max(width, params.mRight + params.rightMargin); &#125; &#125; &#125; if (isWrapContentHeight) &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; height = Math.max(height, params.mBottom); &#125; else &#123; height = Math.max(height, params.mBottom + params.bottomMargin); &#125; &#125; if (child != ignore || verticalGravity) &#123; left = Math.min(left, params.mLeft - params.leftMargin); top = Math.min(top, params.mTop - params.topMargin); &#125; if (child != ignore || horizontalGravity) &#123; right = Math.max(right, params.mRight + params.rightMargin); bottom = Math.max(bottom, params.mBottom + params.bottomMargin); &#125; &#125; &#125; 根据源码我们发现RelativeLayout会对子View做两次measure。这是为什么呢？首先RelativeLayout中子View的排列方式是基于彼此的依赖关系，而这个依赖关系可能和布局中View的顺序并不相同，在确定每个子View的位置的时候，就需要先给所有的子View排序一下。又因为RelativeLayout允许A，B 2个子View，横向上B依赖A，纵向上A依赖B。所以需要横向纵向分别进行一次排序测量。 LinearLayout的onMeasure()方法12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 与RelativeLayout相比LinearLayout的measure就简单明了的多了，先判断线性规则，然后执行对应方向上的测量。随便看一个吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == View.GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; if (hasDividerBeforeChildAt(i)) &#123; mTotalLength += mDividerHeight; &#125; LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); totalWeight += lp.weight; if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123; // Optimization: don't bother measuring children who are going to use // leftover space. These views will get measured again down below if // there is any leftover space. final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin); &#125; else &#123; int oldHeight = Integer.MIN_VALUE; if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123; // heightMode is either UNSPECIFIED or AT_MOST, and this // child wanted to stretch to fill available space. // Translate that to WRAP_CONTENT so that it does not end up // with a height of 0 oldHeight = 0; lp.height = LayoutParams.WRAP_CONTENT; &#125; // Determine how big this child would like to be. If this or // previous children have given a weight, then we allow it to // use all available space (and we will shrink things later // if needed). measureChildBeforeLayout( child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0); if (oldHeight != Integer.MIN_VALUE) &#123; lp.height = oldHeight; &#125; final int childHeight = child.getMeasuredHeight(); final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); if (useLargestChild) &#123; largestChildHeight = Math.max(childHeight, largestChildHeight); &#125; &#125; 父视图在对子视图进行measure操作的过程中，使用变量mTotalLength保存已经measure过的child所占用的高度，该变量刚开始时是0。在for循环中调用measureChildBeforeLayout（）对每一个child进行测量，该函数实际上仅仅是调用了measureChildWithMargins(),在调用该方法时，使用了两个参数。其中一个是heightMeasureSpec，该参数为LinearLayout本身的measureSpec；另一个参数就是mTotalLength，代表该LinearLayout已经被其子视图所占用的高度。 每次for循环对child测量完毕后，调用child.getMeasuredHeight()获取该子视图最终的高度，并将这个高度添加到mTotalLength中。在本步骤中，暂时避开了lp.weight&gt;0的子视图，即暂时先不测量这些子视图，因为后面将把父视图剩余的高度按照weight值的大小平均分配给相应的子视图。源码中使用了一个局部变量totalWeight累计所有子视图的weight值。处理lp.weight&gt;0的情况需要注意，如果变量heightMode是EXACTLY，那么，当其他子视图占满父视图的高度后，weight&gt;0的子视图可能分配不到布局空间，从而不被显示，只有当heightMode是AT_MOST或者UNSPECIFIED时，weight&gt;0的视图才能优先获得布局高度。最后我们的结论是：如果不使用weight属性，LinearLayout会在当前方向上进行一次measure的过程，如果使用weight属性，LinearLayout会避开设置过weight属性的view做第一次measure，完了再对设置过weight属性的view做第二次measure。由此可见，weight属性对性能是有影响的，而且本身有大坑，请注意避让。 小结从源码中我们似乎能看出，我们先前的测试结果中RelativeLayout不如LinearLayout快的根本原因是RelativeLayout需要对其子View进行两次measure过程。而LinearLayout则只需一次measure过程，所以显然会快于RelativeLayout，但是如果LinearLayout中有weight属性，则也需要进行两次measure，但即便如此，应该仍然会比RelativeLayout的情况好一点。 RelativeLayout另一个性能问题对比到这里就结束了嘛？显然没有！我们再看看View的Measure（）方法都干了些什么？ 12345678910111213public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; ...... &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension &#125; View的measure方法里对绘制过程做了一个优化，如果我们或者我们的子View没有要求强制刷新，而父View给子View的传入值也没有变化（也就是说子View的位置没变化），就不会做无谓的measure。但是上面已经说了RelativeLayout要做两次measure，而在做横向的测量时，纵向的测量结果尚未完成，只好暂时使用myHeight传入子View系统，假如子View的Height不等于（设置了margin）myHeight的高度，那么measure中上面代码所做得优化将不起作用，这一过程将进一步影响RelativeLayout的绘制性能。而LinearLayout则无这方面的担忧。解决这个问题也很好办，如果可以，尽量使用padding代替margin。 结论1.RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure 2.RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。 3.在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。 最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWord Vue项目创建]]></title>
    <url>%2Fposts%2F55860431.html</url>
    <content type="text"><![CDATA[准备 node &amp; npm 1$ brew install node 检查 node &amp; npm 12$ node -v$ npm -v vue-cli 1$ npm install -g vue-cli 或 1$ npm install -g @vue/cli @vue/cli-init @vue/cli-service-global 初始化 1$ vue create hello-world 根据提示依次输入相关信息↓ 最后出现finished安装完成 ↓ 在终端中运行 ↓ 即可查看初始化完成的效果 12cd hello-world/npm run serve 添加依赖项目初始化完成后添加项目常用依赖包 12npm install --save vuex axios qsnpm install --save-dev node-sass sass-loader pug pug-loader 包含vuex、axios、qs、sass、pug等，其他依赖包根据项目需求自己选择vue-router在脚手架 init 的时候会提示是否选择安装 完善项目结构添加views文件夹 src 下添加 views 文件夹主要存放页面级的 vue 组件src 下的 components 文件夹主要用于存放通用的组件 在 views 文件夹中创建Home.vue作为主页 删除App.vue中无用的内容，只保留router-view 12345&lt;template&gt; &lt;div id="app"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 如果是移动端项目用 rem 作为单位，可以在src/main.js中添加如下代码做自适应 ↓ 1234567891011121314if (window.addEventListener) &#123; const html = document.documentElement function setFont() &#123; const k = 750 html.style.fontSize = (html.clientWidth / k) * 100 + 'px' &#125; setFont() setTimeout(function() &#123; setFont() &#125;, 300) document.addEventListener('DOMContentLoaded', setFont, false) window.addEventListener('resize', setFont, false) window.addEventListener('load', setFont, false)&#125; 调整router配置 更多路由相关使用方法请访问：https://router.vuejs.org/zh-cn/ 目录结构 ↓ 123456router ├── index.js # 我们组装模块并导出 store 的地方 └── modules ├── home.js # 首页模块 ├── cart.js # 购物车模块 └── products.js # 产品模块 修改路由主文件router/index.js 使用require.context实现路由去中心化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)let router = new Router(&#123; base: '/', // 应用的基路径 mode: 'hash', // "hash" (URL hash 模式) | "history"(HTML5 History 模式) | "abstract" (Node.js 环境) scrollBehavior(to, from, savedPosition) &#123; // 路由切换的滚动行为，只在 HTML5 history 模式下可用 if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125; &#125;, routes: (r =&gt; &#123; // 去中心化 // console.log('r', r); // __webpack_require__ let sourceMap = [] let res = r.keys().map(key =&gt; &#123; let rKey = r(key) sourceMap.push(...rKey.default) // console.log('key', key, rKey); // ./modules/home/route.js // &#123;default: Array(3), __esModule: true&#125; return rKey &#125;) return sourceMap &#125;)(require.context('./', true, /^\.\/modules\/\w+\.js$/)),&#125;)router.beforeEach((to, from, next) =&gt; &#123; // console.log('router beforeEach=&gt;', to, from) // 全局路由切换前执行 // 是否有用户信息，并且用户ID是否存在 // if (window.localStorage.getItem("loginInfo") &amp;&amp; JSON.stringify(window.localStorage.getItem("loginInfo")).userId) &#123; // next(&#123;path: '/login'&#125;)//重定向到登录页面 // &#125; else &#123; // next()//正常跳转 // &#125; next()&#125;)router.afterEach((to, from) =&gt; &#123; // console.log('router afterEach=&gt;', router)&#125;)export default router 在 router 文件夹下添加 modules 文件夹 在 modules 文件夹下添加 home.js ，这个 home.js 对应首页业务模块，首页相关的路由页面都可以写到 home.js 文件里。 如果以后添加其他业务模块，只需要在 modules 文件夹添加相对应的业务模块文件，并在其中添加业务相关的路由页面。这样所有不同业务线的开发人员就可以互不干扰 ↓ 1234567891011121314import Home from '../../views/Home'const routes = [ &#123; path: '/', name: 'index', redirect: '/home', &#125;, &#123; path: '/home', name: 'home', component: Home, &#125;,]export default routes 对于不需要即时加载的非一级页面可以使用异步路由组件 123456789101112// region 异步组件 - 路由地址demo// ES 提案的 import（推荐）&#123; name: 'index', path: '/', component: () =&gt; import('../views/index')&#125;,// ES 提案的 import，带分组，指定webpackChunkName，相同的name打包到一个js文件&#123; name: 'index', path: '/', component: () =&gt; import(webpackChunkName:'viewsIndex','../views/index')&#125;,// Webpack 风格的异步组件&#123; name: 'index', path: '/', component: resolve =&gt; require.ensure(['views/Foo.vue'], () =&gt; resolve(require('views/Foo.vue')))&#125;,// Webpack 风格的异步组件，带分组&#123; name: 'index', path: '/', component: resolve =&gt; require.ensure([], () =&gt; resolve(require('views/index.vue')), 'group-index')&#125;,// AMD 风格的异步组件&#123; name: 'index', path: '/', component: resolve =&gt; require(['views/index.vue'], resolve)&#125;,// endregion 添加store文件夹 src 下的 store 文件夹主要是存放 vuex 相关信息的更多 vuex 相关使用方法请访问：https://vuex.vuejs.org/zh-cn/ 在 store 文件夹下创建目录结构 ↓ 12345678910store ├── index.js # 我们组装模块并导出 store 的地方 ├── getters.js # 根级别的 getter ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── mutation-types.js # 定义链接 action 和 mutation 的方法名常量 └── modules ├── base.js # 首页模块 ├── cart.js # 购物车模块 └── products.js # 产品模块 下面开始改造 store 文件夹 ↓ 在mutation-types.js中添加一个常量 123export const BASE = &#123; SET_USER_INFO: 'SET_USER_INFO',&#125; 在action-types.js中添加一个常量 123export const BASE = &#123; login: 'login',&#125; 修改modules/base.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from 'vue'import &#123; base &#125; from '../mutation-types'import axios from 'axios'import qs from 'qs'const state = &#123; version: '', token: null, user: &#123; userID: '', userName: '', name: '', tel: '', email: '', head: '', &#125;,&#125;const getters = &#123; versionGetter(state, getters) &#123; return state.version &#125;,&#125;const mutations = &#123; [BASE.SET_USER_INFO](state, userInfo) &#123; userInfo.userID &amp;&amp; (state.user.userID = userInfo.userID) userInfo.USERNAME &amp;&amp; (state.user.userName = userInfo.USERNAME) userInfo.NAME &amp;&amp; (state.user.name = userInfo.NAME) userInfo.TEL &amp;&amp; (state.user.tel = userInfo.TEL) userInfo.EMAIL &amp;&amp; (state.user.email = userInfo.EMAIL) userInfo.HEAD &amp;&amp; (state.user.head = userInfo.HEAD) &#125;,&#125;const actions = &#123; async login(&#123; commit, dispatch, state &#125;, &#123; userName, password &#125;) &#123; let userInfo = await axios.post('/api/login', qs.stringify(&#123; userName, password &#125;)) commit(BASE.SET_USER_INFO, userInfo) &#125;,&#125;export default &#123; // namespaced: true, // https://vuex.vuejs.org/zh/guide/modules.html#命名空间 state, mutations, actions, getters,&#125; 修改 vuex 主文件index.js，组合所有状态模块 12345678910111213141516171819202122232425262728293031import Vue from 'vue'import Vuex from 'vuex'import getters from './getters'import actions from './actions'import mutations from './mutations'import base from './modules/base'import cart from './modules/cart'import products from './modules/products'// import createLogger from 'vuex/dist/logger' //vuex内置的Logger日志插件const debug = process.env.NODE_ENV !== 'production' // 发布品种时需要用 Webpack 的 DefinePlugin 来转换 process.env.NODE_ENV !== 'production' 的值为 falseVue.use(Vuex)const state = &#123;&#125;export default new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; base, cart, products, // https://vuex.vuejs.org/zh/guide/modules.html#模块动态注册 &#125;, strict: debug, // 开发阶段使用 // plugins: debug ? [createLogger()] : []//vuex插件,https://vuex.vuejs.org/zh/guide/plugins.html&#125;) 修改main.js，引入 vuex 123456789101112//...import store from './store/index'//...new Vue(&#123; el: '#app', router, store, // components: &#123; App &#125;, // template: '&lt;App/&gt;', render: h =&gt; h(App), // https://cn.vuejs.org/v2/guide/render-function.html#JSX&#125;) https://juejin.im/post/5bcd967b6fb9a05d07197b1e Vuex 实战：如何在大规模 Vue 应用中组织 Vuex 代码 super-vuex 添加mixins文件夹目录结构 ↓ 12mixins ├── index.js # 全局mixin 添加filters文件夹目录结构 ↓ 12filters ├── index.js # 全局过滤器 添加utils文件夹目录结构 ↓ 1234utils ├── fetch.js # axios ├── filters.js # 全局filter └── mixin.js # 全局mixin src/main.js中添加全局引用 ↓ 12345678910import * as filters from './utils/filters'import fetch from './utils/fetch'/* 全局注册fetch */Vue.prototype.$fetch = fetch/* 注册全局过滤器 */Object.keys(filters).forEach(key =&gt; &#123; Vue.filter(key, filters[key])&#125;) 封装 axios123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import Vue from 'vue'import router from '../router'import axios from 'axios'import qs from 'qs'import Toast from '../components/toast'// #region config// 每页条数export const ROW = 10// 加载最小时间export const MINI_TIME = 300// 超时时间（超时时间）export const TIME_OUT_MAX = 8000// 环境valueexport const _env = process.env.NODE_ENV// 请求组（判断当前请求数）export const _requests = []// #endregion// #region 实例化axiosconst _instance = axios.create(&#123; timeout: TIME_OUT_MAX,&#125;)// #endregion// region request统一处理操作_instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'// POST传参序列化_instance.interceptors.request.use( config =&gt; &#123; if (config.method === 'post') &#123; config.data = qs.stringify(config.data) &#125; return config &#125;, error =&gt; &#123; Toast('错误的传参') return Promise.reject(error) &#125;,)// endregion// region response统一处理操作_instance.interceptors.response.use( res =&gt; &#123; let _message = null if (res.status !== 200) &#123; console.error(res) switch (res.status) &#123; case 404: _message = '404,错误请求' break case 401: router.push(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;) _message = '未授权' break case 403: _message = '禁止访问' break case 408: _message = '请求超时' break case 500: _message = '服务器内部错误' break case 501: _message = '功能未实现' break case 503: _message = '服务不可用' break case 504: _message = '网关错误' break default: _message = '未知错误' &#125; Toast(_message) return Promise.reject(_message) &#125; else &#123; return res &#125; &#125;, error =&gt; &#123; console.error(error) Toast(error || '服务器繁忙，请稍后重试') return Promise.reject(error || '服务器繁忙，请稍后重试') &#125;,)// endregion// #region send get/postlet toast = null/** * 发送GET请求 * @param api 接口api * @param params 请求参数 * @returns &#123;Promise.&lt;T&gt;&#125; */async function get(api, params) &#123; try &#123; if (!toast) toast = Toast(&#123; time: -1, message: '加载中', icon: 'loading' &#125;) let &#123; data &#125; = await _instance.get(api, &#123; params &#125;) toast.close() return data &#125; catch (e) &#123; toast.close() Toast(&#123; message: '网络异常', position: 'bottom' &#125;) throw e &#125;&#125;/** * 发送POST请求 * @param api 接口api * @param params 请求参数 * @returns &#123;Promise.&lt;T&gt;&#125; */async function post(api, params) &#123; try &#123; if (!toast) toast = Toast(&#123; time: -1, message: '加载中', icon: 'loading' &#125;) let &#123; data &#125; = await _instance.post(api, qs.stringify(params)) toast.close() return data &#125; catch (e) &#123; toast.close() Toast(&#123; message: '网络异常', position: 'bottom' &#125;) throw e &#125;&#125;// #endregionexport default &#123; _instance, get, post,&#125; config 配置build 生成的文件路径使用相对路径修改config/index.js文件中build节点的assetsPublicPath值 1234567891011module.exports = &#123; dev: &#123; // ... &#125;, build: &#123; // ... assetsPublicPath: './', // ... &#125;,&#125; 开发的的时候需要使用代理(proxy)跨域访问服务器接口修改config/index.js文件中dev节点的proxyTable值 123456789101112131415module.exports = &#123; dev: &#123; // ... proxyTable: &#123; '/api': &#123; target: 'https://123.57.89.97:8081', changeOrigin: true, // pathRewrite: &#123; // '^/api': '/api' // &#125; &#125;, &#125;, // ... &#125;,&#125; 分离线上环境和本地环境的配置信息修改config/dev.env.js与config/prod.env.js，为不同的环境配置文件添加与NODE_ENV同级的环境变量 1234module.exports = &#123; NODE_ENV: '"development"', API: '"https://123.57.89.97:8081"',&#125; 通用样式(SCSS)目录结构 ↓ 1234567assets └── scss ├── base.scss # 基础样式 ├── common.scss # 通用样式 ├── fun.scss # 函数 ├── mixin.scss # 混合 └── variable.js # 变量 base.scss12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@charset "utf-8";@import 'variable';@import 'fun';@import 'mixin';@import 'common';/*基础样式*/html,body,#app &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1; width: 100%; height: 100%; font-family: Arial, 'Microsoft YaHei', '微软雅黑', Verdana, sans-serif;&#125;ul,li &#123; padding: 0; margin: 0; list-style: none;&#125;* &gt; img &#123; max-width: 100%; max-height: 100%;&#125;button &#123; position: relative; display: block; margin-left: auto; margin-right: auto; padding-left: 14px; padding-right: 14px; box-sizing: border-box; font-size: 18px; text-align: center; text-decoration: none; line-height: 2.55555556; border-radius: 5px; -webkit-tap-highlight-color: transparent; overflow: hidden; color: #000000; background-color: #f8f8f8; &amp;::after &#123; content: ' '; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid rgba(0, 0, 0, 0.2); -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0; box-sizing: border-box; border-radius: 10px; &#125;&#125;//页面切换动画.slide &#123; &amp;-enter, &amp;-leave-to &#123; -webkit-transform: translate(100%, 0); transform: translate(100%, 0); &#125; &amp;-enter-active, &amp;-leave-active &#123; transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1); &#125; &amp;-enter-to, &amp;-leave &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0); &#125;&#125; common.scss123456789101112131415161718192021222324252627282930313233@charset "UTF-8";@import 'fun';@import 'mixin';@import 'variable';/*通用样式*/* &#123; box-sizing: border-box;&#125;.clear &#123; display: block !important; clear: both !important; float: none !important; margin: 0 !important; padding: 0 !important; height: 0; line-height: 0; font-size: 0; overflow: hidden;&#125;.clearfix &#123; zoom: 1;&#125;.clearfix:after &#123; content: ''; display: block; clear: both; height: 0;&#125; fun.scss1234567@charset "UTF-8";/*函数*/@function rem($pixels) &#123; @return $pixels / 100px * 1rem;&#125; mixin.scss1234567891011@charset "UTF-8";/*混合*/@mixin fullpage &#123; position: absolute; top: 0; bottom: 0; right: 0; left: 0;&#125; variable.scss1234567@charset "UTF-8";@import 'fun';/*变量*/$headerHeight: rem(50px); 查缺补漏我用了 axios , 为什么 IE 浏览器不识别(IE9+)那是因为 IE 整个家族都不支持 promise, 解决方案: 1234npm install es6-promise// 在 main.js 引入即可// ES6的polyfillrequire('es6-promise').polyfill()]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Style Guide For 前端]]></title>
    <url>%2Fposts%2F16482fed.html</url>
    <content type="text"><![CDATA[命名 文件夹、.JS、.CSS: 小驼峰(little camel-case) .vue 组件: 大驼峰(big camel-case)* css的class命名遵循 BEM 重构组件组件存放位置只有 一个 页面内的组件，放在页面文件夹下的 components 文件夹下； 两个 页面共用的组件，放在第一个页面文件夹下的 components 文件夹下； 三个以上 页面的共用组件，放在项目文件夹下的 components 文件夹下。 组件存放的位置会在开发过程中不断的调整重构。 添加项目级公用组件需将组件参数及用法描述添加到 README.md 。 Vue 引用组件一律使用 大驼峰(big camel-case) 命名。 如遇 Footer 组件则可将组件名定义为 VFooter ，不要使用 MyFooter 。 weex页面文件夹命名使用 小驼峰(little camel-case) ，文件夹由 至少两个单词组成 。 gittag 命名规范 分支+版本号+日期。版本号前3位逢9进1，最后一位极限逢99进1。例如：dev-v0.3.3.01-20180110 pre-v0.3.9.05-20181101 master-v0.3.9.05-20180101 master的tag根据pre的最后一个版本。 更多 Vue 风格指南 Airbnb JavaScript Style Guide]]></content>
      <categories>
        <category>前端</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这次，彻底弄懂接口及抽象类]]></title>
    <url>%2Fposts%2F912e5c18.html</url>
    <content type="text"><![CDATA[本文旨在讨论抽象类和接口的作用、实例及使用场景，都是我的理解和总结。更多关于接口和抽象类的概念知识，可自行查阅相关文档。 1. 抽象类及其作用抽象类，顾名思义，即类的抽象。 在介绍面向对象概念时，我们知道类是客观事物的抽象，而抽象类又是类的进一步抽象，该怎么理解呢？ 举个例子，我们定义若干个类 class BMW、class Benz、class Audi，分别对客观事物“宝马”、“奔驰”、“奥迪”三种汽车进行抽象，包含相关属性和行为（即方法）。但是我们知道，汽车都有通用的属性和行为，比如品牌、发动机、方向盘、轮胎等属性，前进、后退、转弯等行为，所以我们可以在宝马、奔驰等汽车之上，进一步抽象出“汽车”类 abstract class Car，包含通用的特性（属性和方法）。让 BMW、Benz、Audi 等继承抽象类 extends Car，便拥有了汽车的通用特性，然后在抽象类基础上定义各自的特殊属性及方法。 这里的 abstract class Car 即抽象类，可以看出，抽象类是用来捕捉子类的通用特性的，包括属性及行为。 2. 接口及其作用下面我们来看看接口，假使我研发出来一台会飞的汽车“伯特莱斯”（Bote-Royce），在程序中定义如下： 12345678910class BoteRoyce extends Car &#123; //...省略通用特性 /** * 可以飞 */ void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 看起来没问题： BoteRoyce extends Car：表达这是一辆汽车； fly() 方法：体现这车可以飞。 但是，随着技术发展，出现了众多可以制造飞行汽车的厂商，难道每一个可以飞的汽车都去定义一个 fly() 方法？ 心想这还不简单，在抽象类 Car 中定义一个抽象方法 abstract void fly() 让子类去实现，不就可以了吗？ No No No… 正如不是所有牛奶都叫特仑苏一样，不是所有汽车都会飞，飞行功能不是汽车的通用特性。将 fly() 方法定义在 Car 中，显然违背了“抽象类用来捕捉子类的通用特性”这一原则。 在这种场景下，解决方案之一就是使用接口，如下： 1234567/** * 飞行器接口 */public interface Aircraft &#123; //定义抽象方法 void fly();&#125; 类 BoteRoyce 的定义修改如下： 12345678910111213/* * 实现 Aircraft 接口，表示具备飞行器能力 */class BoteRoyce extends Car implements Aircraft &#123; /** * 覆写接口方法，实现飞行能力 */ @Override void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 再有其他品牌的飞行汽车，都可以通过 extends Car implements Aircraft 实现飞行能力。 上述定义的 interface Aircraft 即为接口，我们通常使用接口对行为进行抽象。 3. 接口和抽象类的区别关于二者的区别，可以结合前面的例子，来加深理解。 抽象类是对类本质的抽象，表达的是 is a 的关系，比如：BMW is a Car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是 like a 的关系。比如：Bote-Royce like a Aircraft（像飞行器一样可以飞），但其本质上 is a Car。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。 4. 接口与抽象类的使用场景熟悉 Java 的同学可能会质疑，上述关于接口的使用，完全可以通过再次抽象 Car 去实现： 12345678/** * 会飞的汽车 */abstract class FlyCar extends Car &#123; //定义抽象方法 public abstract void fly();&#125; 普通的汽车依然 extends Car，可以飞行的汽车 extends FlyCar 即可： 12345678910111213/* * 继承 FlyCar，表示是可以飞行的汽车 */class BoteRoyce extends FlyCar &#123; /** * 覆写抽象方法，实现飞行能力 */ @Override public void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 如果你也这么想，表示你 get 到了抽象类的点。不过话说回来，这样的话接口岂不是没有存在的意义了？ 当然不是了。就 BoteRoyce 而言，如果你关心的是“飞行汽车”这个整体，那么定义抽象类 FlyCar 是个不错的选择；如果你关心的是汽车具备“飞行”的行为，那不妨继续沿用前面使用 Aircraft 接口的方案。 这一点与设计模式中六大原则之一的“里氏替换原则”不谋而合，该原则指出：所有引用基类（抽象类或接口）的地方必须能透明地使用其子类的对象。也就是说，当你遵循该原则时，你必须要考虑你关心的是“飞行汽车”实体，还是“飞行”行为，并将其作为基类，从而决定程序所能接受的子类对象。 同时，“接口隔离原则”指导我们，一个类对另一个类的依赖应该建立在最小的接口上。相比于抽象类 FlyCar，接口 Aircraft 能最大限度的减少对外暴露的接口，并隐藏细节，更符合这一原则。 所以说啊，面向对象只是指导我们编程的思想，而非条条框框。在实际开发中，具体使用抽象类还是接口，并没有绝对限制，而是取决于你的业务场景和架构设计。 5. 总结好了，本次关于接口与抽象类的总结就到这儿，你彻底弄懂了吗？下期分享再见~]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夯实Java：从面向对象说起]]></title>
    <url>%2Fposts%2F92341839.html</url>
    <content type="text"><![CDATA[刚学习 Java 那会就接触了“面向对象”的概念，但当时并没有太多实战经验，所以对其的理解也仅限于概念。当工作两年后再回顾一下，有些概念能够落地了，遂记录一下。 1. 什么是面向对象面向对象是一种程序设计的思想，而不是一种方法，亦或准则。其指导我们从现实世界中客观存在的事物出发，进行程序设计。 2. 什么是对象Everything is Object，在 Java 语言的世界中，万事万物皆对象。上面提到“从现实世界中客观存在的事物出发”，这里客观存在的事物，我们称之为“对象”。 在程序中，对象是程序的基本构成单元，是客观存在的事物的体现。一个对象通常由一组属性和对这组属性进行操作的若干服务（方法）构成。 3. 面向对象与面向过程的出现面对简单的软件程序，我们往往不需要考虑过多的设计，任何一个小的功能单元或模块，都可以按照一定的步骤去实现，这种 step by step 的方式即为面向过程。 随着程序的复杂性提升，我们无法按步骤去描述并实现编码，所以面向过程已无法适应。加之考虑到代码的可读及复用性等，便有了对象的概念，以及面向对象的编程思想。 当然，还有面向组件、面向服务等设计思想，不在此讨论。 4. 面向对象与面向过程的区别要知道，二者并不是非此即彼，而是相辅相成的。 面向对象思想要求我们从宏观上进行程序设计，抽象出一个个“对象”。而面向过程，则在微观上对“对象”内部进行具体的实现。 可以看出，面向对象最终还是离不开面向过程。 举例来说，需要编程实现绘制圆形、三角形、矩形。 面向过程实现： 123drawCircle... //一坨绘制相关的代码，下同drawTriangledrawRect 面向对象实现： 123456789101112131415//抽象出画笔对象class Painter &#123; drawCircle()&#123; //上述面向过程实现，下同 &#125; drawTriangle()&#123;&#125; drawRect()&#123;&#125;&#125;//面向对象，使用画笔绘制1. painter.drawCircle() //此处只需要调用对象的方法，下同1. painter.drawTriangle()2. painter.drawRect() 5. 对象与类前面介绍了对象以及面向对象，下面回到 Java 中聊聊类的概念。 5.1 类我们常说“物以类聚”，表达“ 同类的东西聚在一起”。其实 Java 中的类也可以这么去理解：“物”即客观存在的“对象”，同类物体的特征描述，即为“类”。 上面是我的个人理解，用术语概括就是：类是客观事物的抽象，或者说是对现实生活中事物的一种描述（属性和行为）。 例如前面定义的 Painter 类，是对客观事物画笔的抽象，包含了一些绘制的方法（行为）。 5.2 对象与类的关系类进行实例化可生成对象，所以，类的具体表现或者实例就是对象，而对象的抽象或者总概括就是类。 6. 面向对象的三大特性说到面向对象，就不得不说其三大特性：封装、继承和多态。 下面简单说说自己的理解吧，就不再贴相关示例了，网上有很多优秀的例子。 6.1 封装封装是面向对象最基础的特性。在前面介绍对象时，提到“一个对象通常由一组属性和对这组属性进行操作的若干服务（方法）构成”，这里的构成体现的就是封装性。 封装，是指对外隐藏对象内部的属性和实现细节，只提供相应的接口和方法进行交互。一方面，外部只需专注于对象所提供的能力，而不用关心内部实现细节；另一方面，避免了外部随意修改或访问内部属性和方法，从而提升了程序的健壮性；同时，封装能提升代码的复用率。 6.2 继承继承指一个对象从另一个对象中获得属性和方法的过程，继承者称为子类，被继承者称为父类。继承使得子类对象拥有父类对象的全部属性与方法（非私有）。 Key point: 子类也可以被其他类继承成为父类； 父类可以拥有多个子类，但一个子类只能有一个父类。这一点与现实中父亲与孩子的关系是一致的； Java 中任何类都是 java.lang.Object 的直接或间接子类； 子类不能继承父类中访问权限为 private 的成员变量和方法； 子类可以重写（override）父类的方法； 子类可以通过 super 关键字访问父类的成员变量、方法和构造器； final 声明的类或方法，不能被继承或重写； 6.3 多态多态是在继承的基础上实现的，多态实现的三个必要条件： 继承 方法重写（override） 父类引用指向子类对象，例如：Human human = new Man()，这里 Man extends Human。 当使用多态方式调用方法时，会依据以下规则： 首先检查父类中是否有该方法，如果没有，则编译错误； 若子类重写了该方法，调用子类的重写方法； 若子类没有重写该方法，则调用父类的方法； 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 7. 总结以上是本文的全部内容，希望能对你有所启发。内容说不上全面、无误，还望读者朋友补充、指正。 最后，感谢阅读。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的.so文件、abi兼容，通用armeabi-v7a和arm64-v8a架构的方法]]></title>
    <url>%2Fposts%2F75a88a70.html</url>
    <content type="text"><![CDATA[了解完 armeabi、armeabi-v7a、arm64-v8a、mips、mips64、x86、x86_64等abi的原理后，很久以前一般都只是用armeabi在做兼容。 现在其实市面上主流的手机都支持armeabi-v7a和arm64-v8a。请看如下简介：各版本的分析如下所示： mips / mips64: 极少用于手机可以忽略，有兴趣的可以百度一下。 x86 / x86_64: x86 架构的手机都会包含由 Intel 提供的称为 Houdini 的指令集动态转码工具，实现 对 arm .so 的兼容，再考虑 x86 1% 以下的市场占有率，x86 相关的两个 .so 也是可以忽略的 armeabi: ARM v5 这是相当老旧的一个版本，缺少对浮点数计算的硬件支持，在需要大量计算时有性能瓶颈 armeabi-v7a: ARM v7 目前主流版本，一般市面上的骁龙系列或者麒麟系列的处理器绝大部分都是这种架构 arm64-v8a: 64位支持所谓的ARMv8架构，就是在MIPS64架构上增加了ARMv7架构中已经拥有的的TrustZone技术、虚拟化技术及NEON advanced SIMD技术等特性，研发成的。 综上所述建议大家兼容armeabi-v7a和arm64-v8a这两个，其他架构少之又少，armeabi基本淘汰所以现在就不怎么考虑了。对于一般项目来说，足够了。 在build.gradle的android里的defaultConfig内添加如下内容: 12345defaultConfig &#123; ndk &#123; abiFilters &quot;armeabi-v7a&quot; abiFilters &quot;arm64-v8a&quot; &#125; 然后在项目中集成so文件的时候 只把armeabi-v7a和arm64-v8a这两个的so文件夹copy到libs里面，具体细节第三方平台的教程里面都写得很详细 如果报错: 12Error:(15, 1) A problem occurred evaluating project ':app'.&gt; Error: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set "android.useDeprecatedNdk=true" in gradle.properties to continue using the current NDK integration. 请在 gradle.properties 中 添加 1android.useDeprecatedNdk=true 对于新手Android开发者来说，像集成百度地图SDK、JPush等再出现找不到.so文件的问题直接只使用armeabi-v7a和arm64-v8a就足以。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>.so文件</tag>
        <tag>armeabi-v7a</tag>
        <tag>arm64-v8a</tag>
        <tag>abi兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的.so文件、ABI和CPU的关系]]></title>
    <url>%2Fposts%2Fb9d5fd68.html</url>
    <content type="text"><![CDATA[早期的Android系统几乎只支持ARMv5的CPU架构，你知道现在它支持多少种吗？ Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。 应用程序二进制接口ABI（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。 为什么你需要重点关注.so文件 项目中使用到了NDK，它将会生成.so文件。 如果只使用Java语言进行编码，你可能在想不需要关注.so文件了吧，因为Java是跨平台的。但你可能并没有意识到项目中依赖的函数库或者引擎库里面已经嵌入了.so文件，并依赖于不同的ABI。 Android应用支持的ABI取决于APK中位于lib/ABI目录中的.so文件，其中ABI可能是上面说过的七种ABI中的一种。 本地库监视器Native Libs Monitor这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。 ABI和CPU的关系很多设备都支持多于一种的ABI。当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。但最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等）。 我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件 ABI目录（横向）和cpu（纵向） armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64 ARMv5 支持 ARMv7 支持 支持 ARMv8 支持 支持 支持 MIPS 支持 MIPS64 支持 支持 x86 支持 支持 支持 x86_64 支持 支持 支持 不同的ABI，针对不同的cpu架构有不同的优先权 例如： x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件。 x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备。 64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。 .so文件重要法则处理.so文件时有一条简单却并不知名的重要法则。 你应该尽可能的提供专为每个ABI优化过的.so文件，你不应该混合着使用（不能就装对不同cpu架构的so文件，放在同一个ABI目录下）。你应该为每个ABI目录提供对应的.so文件。 NDK兼容性使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是后向兼容（兼容过去的版本）的，而是前向兼容（兼容将来的版本）的。推荐使用app的minSdkVersion对应的编译平台。 这也意味着当你引入一个预编译好的.so文件时，你需要检查它被编译所用的平台版本。 混合使用不同C++运行时编译的.so文件.so文件可以依赖于不同的C++运行时，静态编译或者动态加载。混合使用不同版本的C++运行时可能导致很多奇怪的crash，是应该避免的。 一个经验法则 当只有一个.so文件时，静态编译C++运行时是没问题的， 当存在多个.so文件时，应该让所有的.so文件都动态链接相同的C++运行时。 这意味着当引入一个新的预编译.so文件，而且项目中还存在其他的.so文件时，我们需要首先确认新引入的.so文件使用的C++运行时是否和已经存在的.so文件一致。 ###关于.so文件的错误示例*问题： *你的app目前只支持armeabi-v7a和x86架构，你想让app支持更多的cpu类型，新增了一个函数库依赖，这个函数库包含.so文件并支持更多的CPU架构。 发布我们的app后，会发现它在某些设备上会发生Crash，例如Galaxy S6，最终可以发现只有64位目录下的.so文件被安装进手机。 解决方案： 重新编译我们的.so文件使其支持缺失的ABIs 也可以设置ndk.abiFilters显示指定支持的ABIs 在IDE中的路径 Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定） Eclipse工程放在libs/ABI目录中（这也是ndk-build命令默认生成.so文件的目录） 在AAR压缩包中的路径AAR压缩包中位于jni/ABI目录中（.so文件会自动包含到引用AAR压缩包的APK中） 在APK中的路径最终APK文件中的lib/ABI目录中 通过PackageManager安装后，.so文件路径通过PackageManager安装后，在小于Android 5.0的系统中，.so文件位于app的nativeLibraryPath目录中；在大于等于Android 5.0的系统中，.so文件位于app的nativeLibraryRootDir/CPU_ARCH目录中。 生成不同ABI版本的APK以减少APK包大小为由是一个错误的借口，因为你也可以选择在应用市场上传指定ABI版本的APK，生成不同ABI版本的APK可以在build.gradle中如下配置： 12345678910111213141516171819202122android &#123; ... splits &#123; abi &#123; enable true reset() include 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a' //select ABIs to build APKs for universalApk true //generate an additional APK that contains all the ABIs &#125; &#125; // map for the version code project.ext.versionCodes = ['armeabi': 1, 'armeabi-v7a': 2, 'arm64-v8a': 3, 'mips': 5, 'mips64': 6, 'x86': 8, 'x86_64': 9] android.applicationVariants.all &#123; variant -&gt; // assign different version code for each output variant.outputs.each &#123; output -&gt; output.versionCodeOverride = project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode &#125; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>ABI</tag>
        <tag>CPU</tag>
        <tag>.so文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你必须知道的ABI和CPU关系]]></title>
    <url>%2Fposts%2F8c0a549.html</url>
    <content type="text"><![CDATA[ABI和CPU的重要知识1、 大部分cpu都支持多于一种的ABI。2、 当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。3、 ABI目录（横向）和cpu（纵向） armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64 ARMv5 支持 ARMv7 支持 支持 ARMv8 支持 支持 支持 MIPS 支持 MIPS64 支持 支持 x86 支持 支持 支持 x86_64 支持 支持 支持 注意：上表格中的空白部分，是我不知道它是否支持，极有可能是不支持 解析： x86设备上，选择ABI的优先级 libs/x86目录中如果存在.so文件的话，会被安装 如果不存在，则会选择armeabi-v7a中的.so文件 如果也不存在，则选择armeabi目录中的.so文件 x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备，因为是运行在x86设备上模拟arm的虚拟层上。 4、 64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。 5、 最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等）。 6、 会安装优先级较高的ABI目录，则其它优先级较低的ABI目录（包括其它module中的ABI目录），都无法安装。例如：在cpu是ARMv7架构的手机上，如果检测到armeabi-v7a，就会选择安装armeabi-v7a，则armeabi下的文件，都无法安装了。 7、 相应的ABI二进制文件，要放进相应的ABI目录中 8、一般情况下不要简单得修改架构目录名 我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件，如果在对应的lib／ABI目录中存在.so文件的话。 ###工具查看项目中ABI文件的架构类型腾讯bugly，符号表工具，下载地址：http://bugly.qq.com/whitebook Native Libs Monitor这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。 ###疑难杂症虽然规则制定出来了，但总是会出现一些，不合规的现象，导致一些错误，难以理解。现在就让我们来一起把把脉，看看到底是什么疑难杂症 ####一、.so文件，放进了优先级低的ABI目录 1、如果你的项目中，有其他优先级更高的ABI目录，但是你把ABI文件放到了优先级低的目录，则你的ABI文件无法被加载2、如果你的项目中，ABI文件放在了，项目中优先级最高的ABI目录中（这个ABI目录是手机所支持的在项目中优先级最高的，但不一定是手机所支持的优先级最高的），则这个ABI文件，可以被加载，加载为ABI目录的所表示的架构类型。例子： 我的手机cpu架构是ARMv7，ABI文件是armeabi-v7a，但是放进了armeabi目录中 在运行的过程中会出现两种情况： 1、项目中有armeabi-v7a的目录，armeabi目录中的文件，无法被加载，运行后报错，出现如下log信息。 1Caused by: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/.xx../base.apk"],nativeLibraryDirectories=[/data/app/.xx../lib/arm, /vendor/lib, /system/lib]]] couldn't find "lib..xx...so" 2、项目中只有armeabi的目录，armeabi目录是该项目优先级最高的ABI目录（虽然armeabi目录在ARMv7所支持的优先级最高的ABI目录不是最高），作为armv5，安装到手机上。 ####二、ABI二进制文件，放进了优先级高的ABI目录可以被加载使用，被加载为ABI文件所表示的结构类型 例子： 我的手机cpu架构是ARMv7，ABI文件是armeabi-v5te，但是放进了armeabi-v7a目录中。 可以被加载，但是加载为ABI文件所表示的架构类型。这样就出现了，同一个应用中ABI文件，出现两种的情况。 ####三、两个第三的SDK中ABI文件优先级不一样问题： 两个第三方的SDK中ABI文件优先级不一样，手机加载运行时，会导致优先级低的库，无法被加载 例子： 我的手机cpu架构是ARMv7，项目中使用两个第三方SDK：企业A和企业B 企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。 在运行时，会发现运行后crash，出现如下log信息。 1Caused by: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/.xx../base.apk"],nativeLibraryDirectories=[/data/app/.xx../lib/arm, /vendor/lib, /system/lib]]] couldn't find "lib..xx...so" 解决办法： #####1、使用同一优先级的ABI文件，ABI文件放入优先级相同的ABI目录 企业A：ABI文件是armeabi-v5te，放进armeabi目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。或企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。 #####2、使用不同优先级的ABI文件，ABI文件放入优先级相同的ABI目录。一般情况不建议这么做。 企业A：ABI文件是armeabi-v7a，但是放进armeabi目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。或企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v5te，但是放进armeabi-v7a目录中。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>ABI</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android下setTextSize的正确使用姿势]]></title>
    <url>%2Fposts%2F99d586fa.html</url>
    <content type="text"><![CDATA[问几个问题先在app/src/main/res/values/dimens.xml中定义尺寸如下： 1&lt;dimen name="font1"&gt;18sp&lt;/dimen&gt; 在代码中引用此尺寸如下： 1234mText.setTextSize(18); // 方法1mText.setTextSize(getResources().getDimension(R.dimen.font1)); // 方法2mText.setTextSize(TypedValue.COMPLEX_UNIT_PX,getResources().getDimension(R.dimen.font1)); // 方法3mText.setTextSize(TypedValue.COMPLEX_UNIT_SP,18); // 方法4 问题1: 方法1和方法2设置的文字尺寸大小相同么？问题2:方法3和方法4设置的文字尺寸大小相同么？问题3:方法1和方法4设置的文字尺寸大小相同么？ 如果你能很清楚的给出上面问题的答案，那就没必要再向下看了；如果你对以上问题感到模棱两可的话，请继续往下看: 要想解开以上疑惑，其实主要从以下两个方法的源码入手 setTextSize(…)进入TextView类，找到setTextSize(…)方法，发现它调用了另一个重载方法，注意这里调用重载方法时传入的第一个参数是一个默认值 TypedValue.COMPLEX_UNIT_SP，因此方法1和方法4设置的文字尺寸大小相同. 1234567891011121314public void setTextSize(float size) &#123; setTextSize(TypedValue.COMPLEX_UNIT_SP, size);&#125;public void setTextSize(int unit, float size) &#123; Context c = getContext(); Resources r; if (c == null) r = Resources.getSystem(); else r = c.getResources(); setRawTextSize(TypedValue.applyDimension(unit, size, r.getDisplayMetrics()));&#125; 重载方法中有两个方法需要重点看setRawTextSize(…)方法通过它的几个方法会发现它的作用就是真正设置文字大小并刷新显示： 12345678910private void setRawTextSize(float size) &#123; if (size != mTextPaint.getTextSize()) &#123; mTextPaint.setTextSize(size); if (mLayout != null) &#123; nullLayouts(); requestLayout(); invalidate(); &#125; &#125;&#125; TypedValue类中的applyDimension(…)方法根据传入的unit单位来处理文字大小，返回的尺寸为px (通过第一个case条件得知). 1234567891011121314151617public static float applyDimension(int unit, float value, DisplayMetrics metrics)&#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0;&#125; 如果传入的unit为COMPLEX_UNIT_PX，则会将value直接返回如果传入的unit为COMPLEX_UNIT_SP，则会将value处理成px返回 getDimension(…)进入Resources类，找到getDimension(…)方法 12345678910111213public float getDimension(@DimenRes int id) throws NotFoundException &#123; synchronized (mAccessLock) &#123; TypedValue value = mTmpValue; if (value == null) &#123; mTmpValue = value = new TypedValue(); &#125; getValue(id, value, true); if (value.type == TypedValue.TYPE_DIMENSION) &#123; return TypedValue.complexToDimension(value.data, mMetrics); &#125; throw new NotFoundException("Resource ID #0x" + Integer.toHexString(id) + " type #0x" + Integer.toHexString(value.type) + " is not valid"); &#125;&#125; 这里方法不多，点getValue(…)方法进去看会发现它内部又调用了native方法，这里我无法进一步追溯它的实现，不过没关系，因为我发现有个方法很眼熟那就是：TypedValue.complexToDimension(…) ，进入此方法会惊奇的发现它也调用了上面讲到的applyDimension(…)方法. 1234public static float complexToDimension(int data, DisplayMetrics metrics)&#123; return applyDimension( (data&gt;&gt;COMPLEX_UNIT_SHIFT)&amp;COMPLEX_UNIT_MASK, complexToFloat(data), metrics);&#125; 由此可以大胆的猜测 getDimension(…)方法最终也会将数据处理成px返回，因此方法3和方法4设置的文字尺寸大小相同，只是写法不同而已. 好了，回到开篇提到的四个问题，可以得出以下结论： 方法1：文字尺寸以sp为单位，大小为18方法2：文字尺寸以sp为单位，大小为（18sp转换为px的值）方法3：文字尺寸以px为单位，大小为（18sp转换为px的值）方法4：文字尺寸以sp为单位，大小为18方法1=方法3=方法4!＝方法2 至此，文章结束，希望此文能帮助到你，如果对此文有不同见解，欢迎直接评论！]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>TypedValue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用Handler造成内存泄露的分析和解决]]></title>
    <url>%2Fposts%2F91b033d9.html</url>
    <content type="text"><![CDATA[Java使用有向图机制，通过GC自动检查内存中的对象（什么时候检查由虚拟机决定），如果GC发现一个或一组对象为不可到达状态，则将该对象从内存中回收。也就是说，一个对象不被任何引用所指向，则该对象会在被GC发现的时候被回收；另外，如果一组对象中只包含互相的引用，而没有来自它们外部的引用（例如有两个对象A和B互相持有引用，但没有任何外部对象持有指向A或B的引用），这仍然属于不可到达，同样会被GC回收。 Android中使用Handler造成内存泄露的原因123456Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; mImageView.setImageBitmap(mBitmap); &#125;&#125; 上面是一段简单的Handler的使用。当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。 内存泄露的危害只有一个，那就是虚拟机占用内存过高，导致OOM（内存溢出），程序出错。对于Android应用来说，就是你的用户打开一个Activity，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制，FC。 使用Handler导致内存泄露的解决方法 通过程序逻辑来进行保护1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。 将Handler声明为静态类静态类不持有外部类的对象，所以你的Activity可以随意被回收。代码如下： 123456static class MyHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; mImageView.setImageBitmap(mBitmap); &#125;&#125; 但其实没这么简单。使用了以上代码之后，你会发现，由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）： 123456789101112131415static class MyHandler extends Handler &#123; WeakReference&lt;Activity &gt; mActivityReference; MyHandler(Activity activity) &#123; mActivityReference= new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; final Activity activity = mActivityReference.get(); if (activity != null) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;&#125; 将代码改为以上形式之后，就算完成了。 具体示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * * 实现的主要功能。 * * @version 1.0.0 * @author Abay Zhuang &lt;br/&gt; * Create at 2014-7-28 */public class HandlerActivity2 extends Activity &#123; private static final int MESSAGE_1 = 1; private static final int MESSAGE_2 = 2; private static final int MESSAGE_3 = 3; private final Handler mHandler = new MyHandler(this); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandler.sendMessageDelayed(Message.obtain(), 60000); // just finish this activity finish(); &#125; public void todo() &#123; &#125;; private static class MyHandler extends Handler &#123; private final WeakReference&lt;HandlerActivity2&gt; mActivity; public MyHandler(HandlerActivity2 activity) &#123; mActivity = new WeakReference&lt;HandlerActivity2&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; System.out.println(msg); if (mActivity.get() == null) &#123; return; &#125; mActivity.get().todo(); &#125; &#125; 上面这样就可以了吗？ 当Activity finish后 handler对象还是在Message中排队。 还是会处理消息，这些处理有必要？正常Activitiy finish后，已经没有必要对消息处理，那需要怎么做呢？解决方案也很简单，在Activity onStop或者onDestroy的时候，取消掉该Handler对象的Message和Runnable。通过查看Handler的API，它有几个方法：removeCallbacks(Runnable r)和removeMessages(int what)等。 代码如下： 12345@Overridepublic void onDestroy() &#123; // If null, all callbacks and messages will be removed. mHandler.removeCallbacksAndMessages(null);&#125; 延伸：什么是WeakReference？WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Handler</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法总结]]></title>
    <url>%2Fposts%2Fe3c0f347.html</url>
    <content type="text"><![CDATA[我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。 排序算法大体可分为两种： 一种是比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。 另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 下表给出了常见比较排序算法的性能： 一点我们很容易忽略的是排序算法的稳定性 排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。 对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。 例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。 其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。 1、冒泡排序(Bubble Sort)​ 冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 ​ 冒泡排序算法的运作如下： 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。冒泡排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package sort;/** * 冒泡排序 * 从小到大排列 * 分类 -------------- 内部比较排序 * 数据结构 ---------- 数组 * 最差时间复杂度 ---- O(n^2) * 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n) * 平均时间复杂度 ---- O(n^2) * 所需辅助空间 ------ O(1) * 稳定性 ------------ 稳定 */public class BubbleSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //冒泡排序 public static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swapArr(arr, j, j + 1); &#125; &#125; &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); bubbleSort(arr); //冒泡排序 printArr(arr); //打印数组 &#125;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序的实现过程如下 尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。 2、鸡尾酒排序 鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。 鸡尾酒排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package sort;/** * 鸡尾酒排序：冒泡排序的改进 * 从小到大排列 * 分类 -------------- 内部比较排序 * 数据结构 ---------- 数组 * 最差时间复杂度 ---- O(n^2) * 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n) * 平均时间复杂度 ---- O(n^2) * 所需辅助空间 ------ O(1) * 稳定性 ------------ 稳定 */public class CocktailSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //鸡尾酒排序 public static void CocktailSort(int[] arr) &#123; //初始化边界 int left = 0; int right = arr.length - 1; while (left &lt; right) &#123; //前半部分 for (int i = left; i &lt; right; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; //将最大元素放到后边 swapArr(arr, i, i + 1); &#125; &#125; right--; //后半部分 for (int j = right; j &gt; left; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; //将最小元素放到前边 swapArr(arr, j, j - 1); &#125; &#125; left++; &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); CocktailSort(arr); //鸡尾酒排序 printArr(arr); //打印数组 &#125;&#125; 以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。 3、选择排序(Selection Sort) 选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。 选择排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package sort;/** * 选择排序 * 从小到大排列 * // 分类 -------------- 内部比较排序 * 数据结构 ---------- 数组 * 最差时间复杂度 ---- O(n^2) * 最优时间复杂度 ---- O(n^2) * 平均时间复杂度 ---- O(n^2) * 所需辅助空间 ------ O(1) * 稳定性 ------------ 不稳定 */public class SelectionSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //选择排序 public static void SelectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minValue = i; //定义一个最小下标，假设i为最小值的下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; //注意：j&lt;arr.length if (arr[minValue] &gt; arr[j]) //如果有有比arr[minValue]小的，则将minValue = j minValue = j; &#125; //判断最小下标是否改变，如果改变则将最小的放到i的位置上 if (minValue != i) &#123; swapArr(arr, minValue, i); //数组元素交换 &#125; &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); SelectionSort(arr); //选择排序 printArr(arr); //打印数组 &#125;&#125; 上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图 使用选择排序为一列数字进行排序的宏观过程： 选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。 比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。 4、插入排序(Insertion Sort)插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌 对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 插入排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package sort;/** * 插入排序 */public class InserttionSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //插入排序 public static void InsertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; //假设第一个元素为已排序序列，从第二个元素开始起插入 int j = i - 1; //已排序序列元素个数，下标从0开始，0代表一个 int get = arr[i]; while (j &gt;= 0 &amp;&amp; arr[j] &gt; get) &#123; //将要插入元素与已排序的序列从右向左进行比较 arr[j + 1] = arr[j]; //如果该元素大于要插入元素，则将其后移 j--; &#125; arr[j + 1] = get; //直到该元素小于或等于要插入元素，则将其插入到该元素的后边 &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); InsertionSort(arr); //直接插入排序 printArr(arr); //打印数组 &#125;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下 使用插入排序为一列数字进行排序的宏观过程： 插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 5、二分插入排序 插入排序的改进 对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package sort;/** * 二分插入排序 */public class DichotomyInsertionSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //二分插入排序 public static void DichotomyInsertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; //初始化已排序序列的边界 int left = 0; int right = i - 1; int get = arr[i]; //二分查找，找到已排序元素序列中小于或等于要插入元素的位置left while (left &lt;= right) &#123; int mid = (left + right) / 2; if (arr[mid] &gt; get) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; for (int j = i - 1; j &gt;= left; j--) &#123; arr[j + 1] = arr[j]; //&gt;=left位置之后的元素整体后移 &#125; arr[left] = get; //将left位置赋值为get &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); DichotomyInsertionSort(arr); //二分插入排序 printArr(arr); //打印数组 &#125;&#125; 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。 6、希尔排序(Shell Sort) 插入排序的更高效改进： 希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。 希尔排序的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package sort;/** * 希尔排序：插入排序的更高级改进 * 从小到大排列 */public class ShellSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; // 希尔排序 public static void ShellSort(int[] arr) &#123; int h = 0; while (h &lt;= arr.length) &#123; // 生成初始化增量 h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; arr.length; i++) &#123; int j = i - h; int get = arr[i]; while (j &gt;= 0 &amp;&amp; arr[j] &gt; get) &#123; arr[j + 1] = arr[j]; j = j - h; &#125; arr[j + h] = get; &#125; h = (h - 1) / 3; // 递减增量 &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; // 数组初始化 System.out.print("原数组元素："); printArr(arr); // 打印数组 System.out.print("希尔排序后数组元素："); ShellSort(arr); // 希尔排序 printArr(arr); // 打印数组 &#125;&#125; 以23, 10, 4, 1的步长序列进行希尔排序： 希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。 比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和 { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。 7、归并排序(Merge Sort) 归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。 归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。 归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 归并排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package sort;/** * 归并排序 * 从小到大排序 */public class MergeSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 合并两个已排好序的数组A[left...mid]和A[mid+1...right] public static void merge(int A[], int left, int mid, int right) &#123; int len = right - left + 1; int[] temp = new int[len]; int index = 0; int i = left; //前一数组的起始元素 int j = mid + 1; //后一数组的起始元素 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; // 带等号保证归并排序的稳定性 &#125; while (i &lt;= mid) &#123; temp[index++] = A[i++]; &#125; while (j &lt;= right) &#123; temp[index++] = A[j++]; &#125; for (int k = 0; k &lt; len; k++) &#123; A[left++] = temp[k]; &#125; &#125; // 递归实现的归并排序 public static void mergeSortRecursion(int A[], int left, int right) &#123; // 当待排序的序列长度为1时，递归开始回溯，进行merge操作 if (left == right) &#123; return; &#125; int mid = (left + right) / 2; mergeSortRecursion(A, left, mid); mergeSortRecursion(A, mid + 1, right); merge(A, left, mid, right); &#125; // 非递归(迭代) 实现的归并排序（自底向上） public static void mergeSortIteration(int A[], int len) &#123; // 子数组索引，前一个为A[left...mid]，后一个子数组为A[mid+1...right] int left, mid, right; for (int i = 1; i &lt; len; i *= 2) &#123; // 子数组的大小i初始化为1，每轮翻倍 left = 0; while (left + i &lt; len) &#123; // 后一个数组存在（需要归并） mid = left + i - 1; right = mid + i &lt; len ? mid + i : len - 1; // 后一个子数组大小可能不够 merge(A, left, mid, right); left = right + 1; // 前一个子数组向后移动 &#125; &#125; &#125; public static void main(String[] args) &#123; // 从小到大归并排序 int[] A1 = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; int[] A2 = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; int n1 = A1.length; int n2 = A2.length; System.out.print("A1原数组元素："); printArr(A1); // 打印数组 System.out.print("递归实现的归并排序结果："); mergeSortRecursion(A1, 0, n1 - 1); // 递归实现 printArr(A1); System.out.print("A2原数组元素："); printArr(A2); // 打印数组 System.out.print("非递归实现的归并排序结果："); mergeSortIteration(A2, n2); // 非递归实现 printArr(A2); &#125;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下 使用归并排序为一列数字进行排序的宏观过程： 归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对。 8、堆排序(Heap Sort)​ 堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。 我们可以很容易的定义堆排序的过程： 由输入的无序数组构造一个最大堆，作为初始的无序区 把堆顶元素（最大值）和堆尾元素互换 把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整 重复步骤2，直到堆的尺寸为1 堆排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package sort;/** * 堆排序 * 从小到大排列 */public class HeapSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; // 从A[i]向下进行堆调整 public static void heapify(int A[], int i, int size) &#123; int left_child = 2 * i + 1; // 左孩子索引 int right_child = 2 * i + 2; // 右孩子索引 int max = i; // 选出当前节点与其左右孩子三者之中的最大值 if (left_child &lt; size &amp;&amp; A[left_child] &gt; A[max]) &#123; max = left_child; &#125; if (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) &#123; max = right_child; &#125; if (max != i) &#123; swapArr(A, i, max); // 把当前节点和它的最大（直接）子节点进行交换 heapify(A, max, size); // 递归调用，继续从当前节点向下进行堆调整 &#125; &#125; // 建堆 public static int buildHeap(int A[], int n) &#123; int heap_size = n; for (int i = heap_size / 2 - 1; i &gt;= 0; i--) // 从每一个非叶子结点开始向下进行调整 heapify(A, i, heap_size); return heap_size; &#125; // 堆排序 public static void heapSort(int A[], int n) &#123; int heap_size = buildHeap(A, n); // 建立一个最大堆 while (heap_size &gt; 1) &#123; // 堆（无序区）元素个数大于1，未完成排序 // 将堆顶元素与堆的最后一个元素交换，并从堆中去掉最后一个元素 // 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法 swapArr(A, 0, --heap_size); heapify(A, 0, heap_size); // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(log n) &#125; &#125; // 主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; // 数组初始化 System.out.print("原数组元素："); printArr(arr); // 打印数组 System.out.print("堆排序后数组元素："); heapSort(arr, arr.length); // 堆排序 printArr(arr); // 打印数组 &#125;&#125; 堆排序算法的演示： 动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。 堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。 比如序列：{ 9, 5, 7, 5 }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { 5, 5, 7, 9 }，再进行堆调整得到{ 7, 5, 5, 9 }，重复之前的操作最后得到{ 5, 5, 7, 9 }从而改变了两个5的相对次序。 9、快速排序(Quick Sort)​ 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为： 从序列中挑出一个元素，作为”基准”(pivot). 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。 快速排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package sort;/** * 快速排序 * 从小到大排列 */public class QuickSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; // 划分函数 public static int partition(int A[], int left, int right) &#123; int pivot = A[right]; // 这里每次都选择最后一个元素作为基准 int tail = left - 1; // tail为小于基准的子数组最后一个元素的索引 for (int i = left; i &lt; right; i++) &#123; //遍历基准以外的其他元素 if (A[i] &lt;= pivot) &#123; // 把小于等于基准的元素放到前一个子数组末尾 swapArr(A, ++tail, i); &#125; &#125; // 最后把基准放到前一个子数组的后边，剩下的儿子数组既是大于基准的子数组 // 该操作很有可能把后面的稳定性打乱，所以快速排序是不稳定的排序算法 swapArr(A, tail + 1, right); return tail + 1; &#125; // 快速排序 public static void quickSort(int A[], int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int pivot_index = partition(A, left, right); // 基准的索引 quickSort(A, left, pivot_index - 1); quickSort(A, pivot_index + 1, right); &#125; // 主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; // 数组初始化 System.out.print("原数组元素："); printArr(arr); // 打印数组 System.out.print("快速排序后数组元素："); quickSort(arr, 0, arr.length - 1); // 快速排序 printArr(arr); // 打印数组 &#125;&#125; 使用快速排序法对一列数字进行排序的过程： 快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。 比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。 Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？ 答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序优化]]></title>
    <url>%2Fposts%2F4ef397b8.html</url>
    <content type="text"><![CDATA[前一阵子有个读者在微信里跟我聊了一件很有趣的事情，他去美团实习，面试让他哭笑不得，因为败在了冒泡排序上。 情况是这样子的，当时和面试官聊的感觉还可以，就在他觉得好像差不多快结束的时候，面试官给他扔了个题：“我这刚好有纸和笔，你来写个冒泡排序吧。” 这位读者心里一慌，为什么慌，倒并不是因为不会写，因为作为一个程序员，冒泡排序基本上没有不会写的，而是事发突然，感觉不太妙。当时他是这么写的： 123456789public void bubbleSort(int[] a) &#123; for(int i = a.length - 1; i &gt; 0; i--) &#123; for(int j = 0; j &lt; i; j++) &#123; if(a[j] &gt; a[j+1]) //交换，具体实现略 swap(a, j, j+1); &#125; &#125;&#125; 果不其然，他写了之后，面试官就问他，这种写法有没有什么问题？能否继续优化？结果还真没答上来。（看到这里，读者们不妨也先思考下如何优化。） 今天就这个冒泡排序，我们再多聊几句，回归一下经典。也希望以后有朋友实习也好，校招也罢，不要再栽在同样的问题上了。 冒泡排序算法的时间复杂度高，如果不清楚算法复杂度如何计算，可以参考下这篇文章：循序渐进带你学习时间复杂度和空间复杂度。但是冒泡排序简单，基本流程是：每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。如何实现？就如上面这位朋友所写的那样，基本上大家都会写。 但是今天主要讨论的是如何优化，有人可能会说，这是再简单不过的算法了，还有什么好优化的？确实，上面这段代码没有毛病，但的确是有可优化之处的。 我们可以假设一种场景，比如 8 1 2 3 5 7，进行一次排序之后，结果就变成了 1 2 3 5 7 8，那我们还有必要再像上面代码里那样继续循环下去吗？肯定没有必要了，因为这已经是最终结果了。 那针对上面的代码，我们优化的点主要在于：假如某一趟排序之后已经有序，我们需要减少排序的趟数。否则就做了很多无用功。 针对这个问题，我们可以考虑在算法中加入一个布尔变量，来标识该轮有没有进行数据的交换，若在某一趟排序中未发现数据位置的交换，则说明待排序的无序区中所有的项均已满足排序后的结果。那么就没有必要再次排序下去了。可以如下改造： 12345678910111213public void bubbleSort(int[] a) &#123; boolean exchange; for(int i = a.length - 1; i &gt; 0; i--) &#123; exchange = false; for(int j = 0; j &lt; i; j++) &#123; if(a[j] &gt; a[j+1]) &#123; swap(a, j, j+1); exchange = true; &#125; &#125; if(!exchange) return; &#125;&#125; 这样就优化完了，其实代码逻辑很简单，通过一个布尔变量即可监控一趟过程有没有进行数据交换。 冒泡排序最好的情况是初始状态是正序的，一次扫描即可完成排序，所以最好的时间复杂度为O(N)；最坏的情况是反序的，此时最坏的时间复杂度为O(N^2)。平均情况，每轮N/2次循环，N轮时间复杂度为O(N^2)。所以它并不是个好的排序算法。这个问题的讨论就到此结束，如果有更好的优化算法也欢迎留言讨论。 冒泡排序并不好，但为什么面试官还会去问？针对这件事情，我们需要注意什么呢？ 经典的东西，可能已经不用了，但是从经典的东西身上，我们能学到的还有很多，否则也不会成为经典。特别是那些面试经常被问到的，总有它存在的合理性。 教科书上的东西不代表实战，所以很多时候考虑到非理想情况下，就可能不那么适用了。面试官往往更加注重的是在不适用的情况下，面试者是如何应对的。面试官更加看重的是面试者的思路。 应届生不能浮躁，特别是在准备面试的时候，一定要步步为营，切忌好高骛远，浅尝辄止，多学习学习经典的数据结构和算法，多做做算法题还是很有必要的。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle依赖配置说明]]></title>
    <url>%2Fposts%2F7a69db10.html</url>
    <content type="text"><![CDATA[之前对Android Gradle构建的依赖一直傻傻分不清，这段时间正好接入集团的一个二方库，踩了很多坑，也顺带把Gradle依赖这块搞清楚了，主要整理了下Gradle依赖的类型、依赖配置、如何查看依赖、依赖冲突如何解决。 依赖类型dependencies DSL标签是标准Gradle API中的一部分，而不是Android Gradle插件的特性，所以它不属于android标签。 依赖有三种方式，如下面的例子： 1234567891011121314apply plugin: 'com.android.application'android &#123; ... &#125;dependencies &#123; // Dependency on a local library module implementation project(":mylibrary") // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3'&#125; 本地library模块依赖 1implementation project(":mylibrary") 这种依赖方式是直接依赖本地库工程代码的（需要注意的是，mylibrary的名字必须匹配在settings.gradle中include标签下定义的模块名字）。 本地二进制依赖 1implementation fileTree(dir: 'libs', include: ['*.jar']) 这种依赖方式是依赖工程中的 module_name/libs/目录下的Jar文件（注意Gradle的路径是相对于build.gradle文件来读取的，所以上面是这样的相对路径）。 如果只想依赖单个特定本地二进制库，可以如下配置： 1implementation files('libs/foo.jar', 'libs/bar.jar') 远程二进制依赖 1implementation 'com.example.android:app-magic:12.3' 上面是简写的方式，这种依赖完整的写法如下： 1implementation group: 'com.example.android', name: 'app-magic', version: '12.3' group、name、version共同定位一个远程依赖库。需要注意的点是，version最好不要写成”12.3+”这种方式，除非有明确的预期，因为非预期的版本更新会带来构建问题。远程依赖需要在repositories标签下声明远程仓库，例如jcenter()、google()、maven仓库等。 依赖配置目前Gradle版本支持的依赖配置有：implementation、api、compileOnly、runtimeOnly和annotationProcessor，已经废弃的配置有：compile、provided、apk、providedCompile。此外依赖配置还可以加一些配置项，例如AndroidTestImplementation、debugApi等等。 常用的是implementation、api、compileOnly三个依赖配置，含义如下： implementation与compile对应，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。使用这个配置，可以显著提升构建时间，因为它可以减少重新编译的module的数量。建议，尽量使用这个依赖配置。 api与compile对应，功能完全一样，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现，也就是会泄漏一些不应该不使用的实现。举个例子，A依赖B，B依赖C，如果都是使用api配置的话，A可以直接使用C中的类（编译时和运行时），而如果是使用implementation配置的话，在编译时，A是无法访问C中的类的。 compileOnly与provided对应，Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。这可以减少输出的体积，在只在编译时需要，在运行时可选的情况，很有用。 runtimeOnly与apk对应，gradle添加依赖只打包到APK，运行时使用，但不会添加到编译路径。这个没有使用过。 annotationProcessor与compile对应，用于注解处理器的依赖配置，这个没用过。 查看依赖树可以查看单个module或者这个project的依赖，通过运行依赖的Gradle任务，如下： 1、View -&gt; Tools Windows -&gt; Gradle（或者点击右侧的Gradle栏）； 2、展开 AppName -&gt; Tasks -&gt; android，然后双击运行AndroidDependencies。运行完，就会在Run窗口打出依赖树了。 ### 依赖冲突解决随着很多依赖加入到项目中，难免会出现依赖冲突，出现依赖冲突如何解决？ 定位冲突 依赖冲突可能会报类似下面的错误： 1Program type already present com.example.MyClass 通过查找类的方式（command + O）定位到冲突的依赖，进行排除。 如何排除依赖 1、dependencies中排除（细粒度） 1234compile('com.taobao.android:accs-huawei:1.1.2@aar') &#123; transitive = true exclude group: 'com.taobao.android', module: 'accs_sdk_taobao'&#125; 2、全局配置排除 123456configurations &#123; compile.exclude module: 'cglib' //全局排除原有的tnet jar包与so包分离的配置，统一使用aar包中的内容 all*.exclude group: 'com.taobao.android', module: 'tnet-jni' all*.exclude group: 'com.taobao.android', module: 'tnet-so'&#125; 3、禁用依赖传递 1234567compile('com.zhyea:ar4j:1.0') &#123; transitive = false&#125;configurations.all &#123; transitive = false&#125; 还可以在单个依赖项中使用@jar标识符忽略传递依赖： 1compile 'com.zhyea:ar4j:1.0@jar' 4、强制使用某个版本 如果某个依赖项是必需的，而又存在依赖冲突时，此时没必要逐个进行排除，可以使用force属性标识需要进行依赖统一。当然这也是可以全局配置的： 123456789compile('com.zhyea:ar4j:1.0') &#123; force = true&#125;configurations.all &#123; resolutionStrategy &#123; force 'org.hamcrest:hamcrest-core:1.3' &#125;&#125; 5、在打包时排除依赖 先看一个示例： 1234567891011task zip(type: Zip) &#123; into('lib') &#123; from(configurations.runtime) &#123; exclude '*unwanted*', '*log*' &#125; &#125; into('') &#123; from jar from 'doc' &#125;&#125; 代码表示在打zip包的时候会过滤掉名称中包含“unwanted”和“log”的jar包。这里调用的exclude方法的参数和前面的例子不太一样，前面的参数多是map结构，这里则是一个正则表达式字符串。 也可以使用在打包时调用include方法选择只打包某些需要的依赖项： 1234567891011task zip(type: Zip) &#123; into('lib') &#123; from(configurations.runtime) &#123; include '*ar4j*', '*spring*' &#125; &#125; into('') &#123; from jar from 'doc' &#125;&#125; 主要是使用dependencies中排除和全局配置排除。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android优化总结]]></title>
    <url>%2Fposts%2F51192665.html</url>
    <content type="text"><![CDATA[目录介绍 1.OOM和崩溃优化 1.1 OOM优化 1.2 ANR优化 1.3 Crash优化 2.内存泄漏优化 2.0 动画资源未释放 2.1 错误使用单利 2.2 错误使用静态变量 2.3 handler内存泄漏 2.4 线程造成内存泄漏 2.5 非静态内部类 2.6 未移除监听 2.7 持有activity引用 2.8 资源未关闭 2.9 其他原因 3.布局优化 3.1 include优化 3.2 ViewStub优化 3.3 merge优化 3.4 其他建议 4.代码优化 4.1 lint代码检测 4.2 代码规范优化 4.3 View异常优化 4.4 去除淡黄色警告优化 4.5 合理使用集合 4.6 Activity不可见优化 4.7 节制的使用Service 5.网络优化 5.1 图片分类 5.2 获取网络数据优化 5.3 网络请求异常拦截优化 6.线程优化 6.1 使用线程池 7.图片优化 7.1 bitmap优化 7.2 glide加载优化 8.加载优化 8.1 懒加载优化 8.2 启动页优化 9.其他优化 9.1 静态变量优化 9.2 注解替代枚举 9.3 多渠道打包优化 9.4 TrimMemory和LowMemory优化 9.5 轮询操作优化 9.6 去除重复依赖库优化 9.7 四种引用优化 9.8 加载loading优化 9.9 对象池Pools优化 10.RecyclerView优化 10.1 页面为何卡顿 10.2 具体优化方案 1.OOM和崩溃优化1.2 ANR优化 ANR的产生需要满足三个条件 主线程：只有应用程序进程的主线程响应超时才会产生ANR； 超时时间：产生ANR的上下文不同，超时时间也会不同，但只要在这个时间上限内没有响应就会ANR； 输入事件/特定操作：输入事件是指按键、触屏等设备输入事件，特定操作是指BroadcastReceiver和Service的生命周期中的各个函数，产生ANR的上下文不同，导致ANR的原因也会不同； ANR优化具体措施 将所有耗时操作，比如访问网络，Socket通信，查询大量SQL 语句，复杂逻辑计算等都放在子线程中去，然 后通过handler.sendMessage、runonUIThread、AsyncTask 等方式更新UI。无论如何都要确保用户界面作的流畅 度。如果耗时操作需要让用户等待，那么可以在界面上显示度条。 使用AsyncTask处理耗时IO操作。在一些同步的操作主线程有可能被锁，需要等待其他线程释放相应锁才能继续执行，这样会有一定的ANR风险，对于这种情况有时也可以用异步线程来执行相应的逻辑。另外，要避免死锁的发生。 使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。 Activity的onCreate和onResume回调中尽量避免耗时的代码 BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。 各个组件的生命周期函数都不应该有太耗时的操作，即使对于后台Service或者ContentProvider来讲，应用在后台运行时候其onCreate()时候不会有用户输入引起事件无响应ANR，但其执行时间过长也会引起Service的ANR和ContentProvider的ANR 2.内存泄漏优化 内存检测第一种：代码方式获取内存 123456789101112131415/** * 内存使用检测：可以调用系统的getMemoryInfo()来获取当前内存的使用情况 */private void initMemoryInfo() &#123; ActivityManager activityManager = (ActivityManager) Utils.getApp() .getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); if (activityManager != null) &#123; activityManager.getMemoryInfo(memoryInfo); LogUtils.d("totalMem=" + memoryInfo.totalMem + ",availMem=" + memoryInfo.availMem); if (!memoryInfo.lowMemory) &#123; // 运行在低内存环境 &#125; &#125;&#125; 内存检测第二种：leakcanary工具 LeakCanary的原理是监控每个activity，在activity ondestory后，在后台线程检测引用，然后过一段时间进行gc，gc后如果引用还在，那么dump出内存堆栈，并解析进行可视化显示。 2.0 动画资源未释放 问题代码 123456789101112public class LeakActivity extends AppCompatActivity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); textView = (TextView)findViewById(R.id.text_view); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(textView,"rotation",0,360); objectAnimator.setRepeatCount(ValueAnimator.INFINITE); objectAnimator.start(); &#125;&#125; 解决办法 在属性动画中有一类无限循环动画，如果在Activity中播放这类动画并且在onDestroy中去停止动画，那么这个动画将会一直播放下去，这时候Activity会被View所持有，从而导致Activity无法被释放。解决此类问题则是需要早Activity中onDestroy去去调用objectAnimator.cancel()来停止动画。 12345@Overrideprotected void onDestroy() &#123; super.onDestroy(); mAnimator.cancel();&#125; 2.1 错误使用单利 在开发中单例经常需要持有Context对象，如果持有的Context对象生命周期与单例生命周期更短时，或导致Context无法被释放回收，则有可能造成内存泄漏。比如：在一个Activity中调用的，然后关闭该Activity则会出现内存泄漏。 解决办法： 要保证Context和AppLication的生命周期一样，修改后代码如下： this.mContext = context.getApplicationContext(); 1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。 2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。 2.2 错误使用静态变量 使用静态方法是十分方便的。但是创建的对象，建议不要全局化，全局化的变量必须加上static。全局化后的变量或者对象会导致内存泄漏！ 原因分析 这里内部类AClass隐式的持有外部类Activity的引用，而在Activity的onCreate方法中调用了。这样AClass就会在Activity创建的时候是有了他的引用，而AClass是静态类型的不会被垃圾回收，Activity在执行onDestory方法的时候由于被AClass持有了引用而无法被回收，所以这样Activity就总是被AClass持有而无法回收造成内存泄露。 2.3 handler内存泄漏 造成内存泄漏原因分析 通过内部类的方式创建mHandler对象,此时mHandler会隐式地持有一个外部类对象引用这里就是MainActivity，当执行postDelayed方法时，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，MessageQueue是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。 解决Handler内存泄露主要2点 有延时消息，要在Activity销毁的时候移除Messages监听 匿名内部类导致的泄露改为匿名静态内部类，并且对上下文或者Activity使用弱引用。 2.4 线程造成内存泄漏 早时期的时候处理耗时操作多数都是采用Thread+Handler的方式，后来逐步被AsyncTask取代，直到现在采用RxJava的方式来处理异步。 造成内存泄漏原因分析 在处理一个比较耗时的操作时，可能还没处理结束MainActivity就执行了退出操作，但是此时AsyncTask依然持有对MainActivity的引用就会导致MainActivity无法释放回收引发内存泄漏。 解决办法 在使用AsyncTask时，在Activity销毁时候也应该取消相应的任务AsyncTask.cancel()方法，避免任务在后台执行浪费资源，进而避免内存泄漏的发生。 2.5 非静态内部类 非静态内部类创建静态实例造成的内存泄漏。有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法。 问题代码 12345678910111213private static TestResource mResource = null;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mResource == null)&#123; mResource = new TestResource(); &#125;&#125;class TestResource &#123; //里面代码引用上下文，Activity.this会导致内存泄漏&#125; 解决办法 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。 分析问题 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。 2.6 未移除监听 问题代码 1234567//add监听，放到集合里面tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123; @Override public void onWindowFocusChanged(boolean b) &#123; //监听view的加载，view加载出来的时候，计算他的宽高等。 &#125;&#125;); 解决办法 12//计算完后，一定要移除这个监听tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this); 注意事项： 12tv.setOnClickListener();//监听执行完回收对象，不用考虑内存泄漏tv.getViewTreeObserver().addOnWindowFocusChangeListene,add监听，放到集合里面，需要考虑内存泄漏 2.7 持有activity引用2.8 资源未关闭 在使用IO、File流或者Sqlite、Cursor等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果及时不关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。 BroadcastReceiver，ContentObserver，FileObserver，Cursor，Callback等在 Activity onDestroy 或者某类生命周期结束之后一定要 unregister 或者 close 掉，否则这个 Activity 类会被 system 强引用，不会被内存回收。值得注意的是，关闭的语句必须在finally中进行关闭，否则有可能因为异常未关闭资源，致使activity泄漏。 2.9 其他原因 静态集合使用不当导致的内存泄漏 有时候我们需要把一些对象加入到集合容器（例如ArrayList）中，当不再需要当中某些对象时，如果不把该对象的引用从集合中清理掉，也会使得GC无法回收该对象。如果集合是static类型的话，那内存泄漏情况就会更为严重。因此，当不再需要某对象时，需要主动将之从集合中移除。 不需要用的监听未移除会发生内存泄露 问题代码 1234567//add监听，放到集合里面tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123; @Override public void onWindowFocusChanged(boolean b) &#123; //监听view的加载，view加载出来的时候，计算他的宽高等。 &#125;&#125;); 解决办法 12//计算完后，一定要移除这个监听tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this); 注意事项： 123tv.setOnClickListener();//监听执行完回收对象，不用考虑内存泄漏 tv.getViewTreeObserver().addOnWindowFocusChangeListene,add监听，放到集合里面，需要考虑内存泄漏 复制代码 3.布局优化3.1 include优化 重用布局文件 标签可以允许在一个布局当中引入另一个布局，那么比如说我们程序的所有界面都有一个公共的部分，这个时候最好的做法就是将这个公共的部分提取到一个独立的布局中，然后每个界面的布局文件当中来引用这个公共的布局。 如果我们要在标签中覆写layout属性，必须要将layout_width和layout_height这两个属性也进行覆写，否则覆写效果将不会生效。 标签是作为标签的一种辅助扩展来使用的，它的主要作用是为了防止在引用布局文件时引用文件时产生多余的布局嵌套。布局嵌套越多，解析起来就越耗时，性能就越差。因此编写布局文件时应该让嵌套的层数越少越好。 举例：比如在LinearLayout里边使用一个布局。里边又有一个LinearLayout，那么其实就存在了多余的布局嵌套，使用merge可以解决这个问题。 3.2 ViewStub优化 仅在需要时才加载布局[ViewStub] 某个布局当中的元素不是一起显示出来的，普通情况下只显示部分常用的元素，而那些不常用的元素只有在用户进行特定操作时才会显示出来。 举例：填信息时不是需要全部填的，有一个添加更多字段的选项，当用户需要添加其他信息的时候，才将另外的元素显示到界面上。用VISIBLE性能表现一般，可以用ViewStub。 ViewStub也是View的一种，但是没有大小，没有绘制功能，也不参与布局，资源消耗非常低，可以认为完全不影响性能。 ViewStub所加载的布局是不可以使用标签的，因此这有可能导致加载出来出来的布局存在着多余的嵌套结构。 自定义全局的状态管理器【充分使用ViewStub】 针对多状态，有数据，空数据，加载失败，加载异常，网络异常等。针对空数据，加载失败，异常使用viewStub布局，一键设置自定义布局，也是优化的一种。 项目地址： 3.3 merge优化 视图层级 这个标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。但是就有一点不好，无法预览布局效果！ 3.4 其他建议 减少太多重叠的背景(overdraw) 这个问题其实最容易解决，建议就是检查你在布局和代码中设置的背景，有些背景是隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。如果采用的是selector的背景，将normal状态的color设置为”@android:color/transparent”,也同样可以解决问题。 避免复杂的Layout层级 这里的建议比较多一些，首先推荐使用Android提供的布局工具Hierarchy Viewer来检查和优化布局。第一个建议是：如果嵌套的线性布局加深了布局层次，可以使用相对布局来取代。第二个建议是：用标签来合并布局。第三个建议是：用标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了。记住，这些建议的最终目的都是使得你的Layout在Hierarchy Viewer里变得宽而浅，而不是窄而深。 总结：可以考虑多使用merge和include，ViewStub。尽量使布局浅平，根布局尽量少使用RelactivityLayout,因为RelactivityLayout每次需要测量2次。 4.代码优化 都是一些微优化，在性能方面看不出有什么显著的提升的。使用合适的算法和数据结构是优化程序性能的最主要手段。 4.1 建议使用lint检查去除无效代码 lint去除无效资源和代码 如何检测哪些图片未被使用 点击菜单栏 Analyze -&gt; Run Inspection by Name -&gt; unused resources -&gt; Moudule ‘app’ -&gt; OK，这样会搜出来哪些未被使用到未使用到xml和图片，如下： 如何检测哪些无效代码 使用Android Studio的Lint，步骤：点击菜单栏 Analyze -&gt; Run Inspection by Name -&gt; unused declaration -&gt; Moudule ‘app’ -&gt; OK 4.2 代码规范优化 避免创建不必要的对象 不必要的对象应该避免创建： 如果有需要拼接的字符串，那么可以优先考虑使用StringBuffer或者StringBuilder来进行拼接，而不是加号连接符，因为使用加号连接符会创建多余的对象，拼接的字符串越长，加号连接符的性能越低。 当一个方法的返回值是String的时候，通常需要去判断一下这个String的作用是什么，如果明确知道调用方会将返回的String再进行拼接操作的话，可以考虑返回一个StringBuffer对象来代替，因为这样可以将一个对象的引用进行返回，而返回String的话就是创建了一个短生命周期的临时对象。 尽可能地少创建临时对象，越少的对象意味着越少的GC操作。 nDraw方法里面不要执行对象的创建 静态优于抽象 如果你并不需要访问一个对系那个中的某些字段，只是想调用它的某些方法来去完成一项通用的功能，那么可以将这个方法设置成静态方法，调用速度提升15%-20%，同时也不用为了调用这个方法去专门创建对象了，也不用担心调用这个方法后是否会改变对象的状态(静态方法无法访问非静态字段)。 对常量使用static final修饰符 static int intVal = 42; static String strVal = “Hello, world!”; 编译器会为上面的代码生成一个初始方法，称为方法，该方法会在定义类第一次被使用的时候调用。这个方法会将42的值赋值到intVal当中，从字符串常量表中提取一个引用赋值到strVal上。当赋值完成后，我们就可以通过字段搜寻的方式去访问具体的值了。 final进行优化: static final int intVal = 42; static final String strVal = “Hello, world!”; 这样，定义类就不需要方法了，因为所有的常量都会在dex文件的初始化器当中进行初始化。当我们调用intVal时可以直接指向42的值，而调用strVal会用一种相对轻量级的字符串常量方式，而不是字段搜寻的方式。 这种优化方式只对基本数据类型以及String类型的常量有效，对于其他数据类型的常量是无效的。 在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。 基本数据类型的数组也要优于对象数据类型的数组。另外两个平行的数组要比一个封装好的对象数组更加高效，举个例子，Foo[]和Bar[]这样的数组，使用起来要比Custom(Foo,Bar)[]这样的一个数组高效的多。 4.3 View异常优化 view自定义控件异常销毁保存状态 经常容易被人忽略，但是为了追求高质量代码，这个也有必要加上。举个例子！ 12345678910111213141516171819202122@Overrideprotected Parcelable onSaveInstanceState() &#123; //异常情况保存重要信息。 //return super.onSaveInstanceState(); final Bundle bundle = new Bundle(); bundle.putInt("selectedPosition",selectedPosition); bundle.putInt("flingSpeed",mFlingSpeed); bundle.putInt("orientation",orientation); return bundle;&#125;@Overrideprotected void onRestoreInstanceState(Parcelable state) &#123; if (state instanceof Bundle) &#123; final Bundle bundle = (Bundle) state; selectedPosition = bundle.getInt("selectedPosition",selectedPosition); mFlingSpeed = bundle.getInt("flingSpeed",mFlingSpeed); orientation = bundle.getInt("orientation",orientation); return; &#125; super.onRestoreInstanceState(state);&#125; 4.4 去除淡黄色警告优化 淡黄色警告虽然不会造成崩溃，但是作为程序员还是要尽量去除淡黄色警告，规范代码 4.5 合理使用集合 使用优化过的数据集合 Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。 4.6 Activity不可见优化 当Activity界面不可见时释放内存 当用户打开了另外一个程序，我们的程序界面已经不可见的时候，我们应当将所有和界面相关的资源进行释放。重写Activity的onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发说明用户离开了程序，此时就可以进行资源释放操作了。 当时看到这个觉得很新奇的，但是具体还是没有用到，要是那个大神有具体操作方案，可以分享一下。 4.7 节制的使用Service 节制的使用Service 如果应用程序需要使用Service来执行后台任务的话，只有当任务正在执行的时候才应该让Service运行起来。当启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，系统可以在LRUcache当中缓存的进程数量也会减少，导致切换程序的时候耗费更多性能。我们可以使用IntentService，当后台任务执行结束后会自动停止，避免了Service的内存泄漏。 5.网络优化5.1 图片分类 图片网络优化 比如我之前看到豆瓣接口，提供一种加载图片方式特别好。接口返回图片的数据有三种，一种是高清大图，一种是正常图片，一种是缩略小图。当用户处于wifi下给控件设置高清大图，当4g或者3g模式下加载正常图片，当弱网条件下加载缩略图【也称与加载图】。 简单来说根据用户的当前的网络质量来判断下载什么质量的图片（电商用的比较多）。豆瓣开源接口可以参考一下！ 5.2 获取网络数据优化 移动端获取网络数据优化的几个点 连接复用：节省连接建立时间，如开启 keep-alive。 对于Android来说默认情况下HttpURLConnection和HttpClient都开启了keep-alive。只是2.2之前HttpURLConnection存在影响连接池的Bug，具体可见：Android HttpURLConnection及HttpClient选择 请求合并：即将多个请求合并为一个进行请求，比较常见的就是网页中的CSS Image Sprites。如果某个页面内请求过多，也可以考虑做一定的请求合并。 减少请求数据的大小：对于post请求，body可以做gzip压缩的，header也可以做数据压缩(不过只支持http 返回数据的body也可以做gzip压缩，body数据体积可以缩小到原来的30%左右。（也可以考虑压缩返回的json数据的key数据的体积，尤其是针对返回数据格式变化不大的情况，支付宝聊天返回的数据用到了） 5.3 网络请求异常拦截优化 在获取数据的流程中，访问接口和解析数据时都有可能会出错，我们可以通过拦截器在这两层拦截错误。 1.在访问接口时，我们不用设置拦截器，因为一旦出现错误，Retrofit会自动抛出异常。比如，常见请求异常404，500，503等等。 2.在解析数据时，我们设置一个拦截器，判断Result里面的code是否为成功，如果不成功，则要根据与服务器约定好的错误码来抛出对应的异常。比如，token失效，禁用同账号登陆多台设备，缺少参数，参数传递异常等等。 3.除此以外，为了我们要尽量避免在View层对错误进行判断，处理，我们必须还要设置一个拦截器，拦截onError事件，然后使用ExceptionUtils，让其根据错误类型来分别处理。 具体可以直接看lib中的ExceptionUtils类，那么如何调用呢？入侵性极低，不用改变之前的代码！ 12345@Overridepublic void onError(Throwable e) &#123; //直接调用即可 ExceptionUtils.handleException(e);&#125; 6.线程优化6.1 使用线程池 将全局线程用线程池管理 直接创建Thread实现runnable方法的弊端 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失 为什么要用线程池 重用线程池中的线程，避免频繁地创建和销毁线程带来的性能消耗；有效控制线程的最大并发数量，防止线程过大导致抢占资源造成系统阻塞；可以对线程进行一定地管理。 使用线程池管理的经典例子 RxJava，RxAndroid，底层对线程池的封装管理特别值得参考 关于线程池，线程，多线程的具体内容 参考：轻量级线程池封装库，支持异步回调，可以检测线程执行的状态 该项目中哪里用到频繁new Thread 保存图片[注意，尤其是大图和多图场景下注意耗时太久]；某些页面从数据库查询数据；设置中心清除图片，视频，下载文件，日志，系统缓存等缓存内容 使用线程池管理库好处，比如保存图片，耗时操作放到子线程中，处理过程中，可以检测到执行开始，异常，成功，失败等多种状态。 7.图片优化7.1 bitmap优化 加载图片所占的内存大小计算方式 加载网络图片：bitmap内存大小 = 图片长度 x 图片宽度 x 单位像素占用的字节数【看到网上很多都是这样写的，但是不全面】 加载本地图片：bitmap内存大小 = width * height * nTargetDensity/inDensity 一个像素所占的内存。注意不要忽略了一个影响项：Density 第一种加载图片优化处理：压缩图片 质量压缩方法：在保持像素的前提下改变图片的位深及透明度等，来达到压缩图片的目的，这样适合去传递二进制的图片数据，比如分享图片，要传入二进制数据过去，限制500kb之内。 采样率压缩方法：设置inSampleSize的值(int类型)后，假如设为n，则宽和高都为原来的1/n，宽高都减少，内存降低。 缩放法压缩：Android中使用Matrix对图像进行缩放、旋转、平移、斜切等变换的。功能十分强大！ 第二种加载图片优化：不压缩加载高清图片如何做？ 使用BitmapRegionDecoder，主要用于显示图片的某一块矩形区域，如果你需要显示某个图片的指定区域，那么这个类非常合适。 7.2 glide加载优化 在画廊中加载大图 假如你滑动特别快，glide加载优化就显得非常重要呢，具体优化方法如下所示 12345678910111213recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; LoggerUtils.e("initRecyclerView"+ "恢复Glide加载图片"); Glide.with(ImageBrowseActivity.this).resumeRequests(); &#125;else &#123; LoggerUtils.e("initRecyclerView"+"禁止Glide加载图片"); Glide.with(ImageBrowseActivity.this).pauseRequests(); &#125; &#125;&#125;); 8.加载优化8.1 懒加载优化 该优化在新闻类app中十分常见 ViewPager+Fragment的搭配在日常开发中也比较常见，可用于切换展示不同类别的页面。 懒加载,其实也就是延迟加载,就是等到该页面的UI展示给用户时,再加载该页面的数据(从网络、数据库等),而不是依靠ViewPager预加载机制提前加载两三个，甚至更多页面的数据。这样可以提高所属Activity的初始化速度,也可以为用户节省流量.而这种懒加载的方式也已经/正在被诸多APP所采用。 具体看这篇文章 www.jianshu.com/p/cf1f4104d… 8.2 启动页优化 启动时间分析 系统创建进程的时间和应用进程启动的时间，前者是由系统自行完成的，一般都会很快，我们也干预不了，我觉得能做的就是去优化应用进程启动，具体说来就是从发Application的onCreate()执行开始到MainActivity的onCreate()执行结束这一段时间。 启动时间优化 Application的onCreate()方法 MainActivity的onCreate()方法 优化的手段也无非三种，如下所示： 延迟初始化 后台任务 启动界面预加载 启动页白屏优化 为什么存在这个问题？ 当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态，于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是Preview Window，即预览窗口。 实际上就是是activity默认的主题中的android:windowBackground为白色或者黑色导致的。 总结来说启动顺序就是：app启动——Preview Window(也称为预览窗口)——启动页 解决办法 常见有三种，这里解决办法是给当前启动页添加一个有背景的style样式，然后SplashActivity引用当前theme主题，注意在该页面将window的背景图设置为空！ 更多关于启动页为什么白屏闪屏，以及不同解决办法，可以看我这篇博客：App启动页面优化 启动时间优化 IntentService子线程分担部分初始化工作 现在application初始化内容有：阿里云推送初始化，腾讯bugly初始化，im初始化，神策初始化，内存泄漏工具初始化，头条适配方案初始化，阿里云热修复……等等。将部分逻辑放到IntentService中处理，可以缩短很多时间。 开启IntentSerVice线程，将部分逻辑和耗时的初始化操作放到这里处理，可以减少application初始化时间 关于IntentService使用和源码分析，性能分析等可以参考博客：IntentService源码分析 9.其他优化9.1 静态变量优化 尽量不使用静态变量保存核心数据。这是为什么呢？ - 这是因为android的进程并不是安全的，包括application对象以及静态变量在内的进程级别变量并不会一直呆着内存里面，因为它很有会被kill掉。 - 当被kill掉之后，实际上app不会重新开始启动。Android系统会创建一个新的Application对象，然后启动上次用户离开时的activity以造成这个app从来没有被kill掉的假象。而这时候静态变量等数据由于进程已经被杀死而被初始化，所以就有了不推荐在静态变量（包括Application中保存全局数据静态数据）的观点。 9.2 注解替代枚举 使用注解限定传入类型 比如，尤其是写第三方开源库，对于有些暴露给开发者的方法，需要限定传入类型是有必要的。举个例子： 刚开始的代码 123456789/** * 设置播放器类型，必须设置 * 注意：感谢某人建议，这里限定了传入值类型 * 输入值：111 或者 222 * @param playerType IjkPlayer or MediaPlayer. */public void setPlayerType(int playerType) &#123; mPlayerType = playerType;&#125; 优化后的代码，有效避免第一种方式开发者传入值错误 12345678910111213141516171819202122/** * 设置播放器类型，必须设置 * 注意：感谢某人建议，这里限定了传入值类型 * 输入值：ConstantKeys.IjkPlayerType.TYPE_IJK 或者 ConstantKeys.IjkPlayerType.TYPE_NATIVE * @param playerType IjkPlayer or MediaPlayer. */public void setPlayerType(@ConstantKeys.PlayerType int playerType) &#123; mPlayerType = playerType;&#125;/** * 通过注解限定类型 * TYPE_IJK IjkPlayer，基于IjkPlayer封装播放器 * TYPE_NATIVE MediaPlayer，基于原生自带的播放器控件 */@Retention(RetentionPolicy.SOURCE)public @interface IjkPlayerType &#123; int TYPE_IJK = 111; int TYPE_NATIVE = 222;&#125;@IntDef(&#123;IjkPlayerType.TYPE_IJK,IjkPlayerType.TYPE_NATIVE&#125;)public @interface PlayerType&#123;&#125; 使用注解替代枚举，代码如下所示 1234567@Retention(RetentionPolicy.SOURCE)public @interface ViewStateType &#123; int HAVE_DATA = 1; int EMPTY_DATA = 2; int ERROR_DATA = 3; int ERROR_NETWORK = 4;&#125; 9.3 多渠道打包优化 还在手动打包吗？尝试一下python自动化打包吧…… 瓦力多渠道打包的Python脚本测试工具，通过该自动化脚本，自需要run一下或者命令行运行脚本即可实现美团瓦力多渠道打包，打包速度很快。配置信息十分简单，代码中已经注释十分详细。可以自定义输出文件路径，可以修改多渠道配置信息，简单实用。 项目地址：github.com/yangchong21… 9.4 TrimMemory和LowMemory优化 可以优化什么？ 在 onTrimMemory() 回调中，应该在一些状态下清理掉不重要的内存资源。对于这些缓存，只要是读进内存内的都算，例如最常见的图片缓存、文件缓存等。拿图片缓存来说，市场上，常规的图片加载库，一般而言都是三级缓存，所以在内存吃紧的时候，我们就应该优先清理掉这部分图片缓存，毕竟图片是吃内存大户，而且再次回来的时候，虽然内存中的资源被回收掉了，依然可以从磁盘或者网络上恢复它。 大概的思路如下所示 在lowMemory的时候，调用Glide.cleanMemory()清理掉所有的内存缓存。 在App被置换到后台的时候，调用Glide.cleanMemory()清理掉所有的内存缓存。 在其它情况的onTrimMemory()回调中，直接调用Glide.trimMemory()方法来交给Glide处理内存情况。 9.5 轮询操作优化 什么叫轮训请求？ 简单理解就是App端每隔一定的时间重复请求的操作就叫做轮训请求，比如：App端每隔一段时间上报一次定位信息，App端每隔一段时间拉去一次用户状态等，这些应该都是轮训请求。比如，电商类项目，某个抽奖活动页面，隔1分钟调用一次接口，弹出一些获奖人信息，你应该某个阶段看过这类轮询操作！ 具体优化操作 长连接并不是稳定的可靠的，而执行轮训操作的时候一般都是要稳定的网络请求，而且轮训操作一般都是有生命周期的，即在一定的生命周期内执行轮训操作，而长连接一般都是整个进程生命周期的，所以从这方面讲也不太适合。 建议在service中做轮询操作，轮询请求接口，具体做法和注意要点，可以直接看该项目代码。看app包下的LoopRequestService类即可。 大概思路：当用户打开这个页面的时候初始化TimerTask对象，每个一分钟请求一次服务器拉取订单信息并更新UI，当用户离开页面的时候清除TimerTask对象，即取消轮训请求操作。 9.6 去除重复依赖库优化 我相信你看到了这里会有疑问，网上有许多博客作了这方面说明。但是我在这里想说，如何查找自己项目的所有依赖关系树 注意要点：其中app就是项目mudule名字。 正常情况下就是app！ 1gradlew app:dependencies 关于依赖关系树的结构图如下所示，此处省略很多代码 12345678910111213| | | | | | \--- android.arch.core:common:1.1.1 (*)| | | | \--- com.android.support:support-annotations:26.1.0 -&gt; 28.0.0| +--- com.journeyapps:zxing-android-embedded:3.6.0| | +--- com.google.zxing:core:3.3.2| | \--- com.android.support:support-v4:25.3.1| | +--- com.android.support:support-compat:25.3.1 -&gt; 28.0.0 (*)| | +--- com.android.support:support-media-compat:25.3.1| | | +--- com.android.support:support-annotations:25.3.1 -&gt; 28.0.0| | | \--- com.android.support:support-compat:25.3.1 -&gt; 28.0.0 (*)| | +--- com.android.support:support-core-utils:25.3.1 -&gt; 28.0.0 (*)| | +--- com.android.support:support-core-ui:25.3.1 -&gt; 28.0.0 (*)| | \--- com.android.support:support-fragment:25.3.1 -&gt; 28.0.0 (*)\--- com.android.support:multidex:1.0.2 -&gt; 1.0.3 然后查看哪些重复jar 然后修改gradle配置代码 1234api (rootProject.ext.dependencies[&quot;zxing&quot;])&#123; exclude module: &apos;support-v4&apos; exclude module: &apos;appcompat-v7&apos;&#125; 9.7 四种引用优化 软引用使用场景 正常是用来处理大图片这种占用内存大的情况 代码如下所示 1234567Bitmap bitmap = bitmaps.get(position);//正常是用来处理图片这种占用内存大的情况bitmapSoftReference = new SoftReference&lt;&gt;(bitmap);if(bitmapSoftReference.get() != null) &#123; viewHolder.imageView.setImageBitmap(bitmapSoftReference.get());&#125;//其实看glide底层源码可知，也做了相关软引用的操作 这样使用软引用好处 通过软引用的get()方法，取得bitmap对象实例的强引用，发现对象被未回收。在GC在内存充足的情况下，不会回收软引用对象。此时view的背景显示 实际情况中,我们会获取很多图片.然后可能给很多个view展示, 这种情况下很容易内存吃紧导致oom,内存吃紧，系统开始会GC。这次GC后，bitmapSoftReference.get()不再返回bitmap对象，而是返回null，这时屏幕上背景图不显示，说明在系统内存紧张的情况下，软引用被回收。 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 弱引用使用场景 弱引用–&gt;随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。 对于使用频次少的对象，希望尽快回收，使用弱引用可以保证内存被虚拟机回收。比如handler，如果希望使用完后尽快回收，看下面代码 1234567891011121314private MyHandler handler = new MyHandler(this);private static class MyHandler extends Handler&#123; WeakReference&lt;FirstActivity&gt; weakReference; MyHandler(FirstActivity activity) &#123; weakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what)&#123; &#125; &#125;&#125; 到底什么时候使用软引用，什么时候使用弱引用呢？ 个人认为，如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 9.8 加载loading优化 一般实际开发中会至少有两种loading 第一种是从A页面进入B页面时的加载loading，这个时候特点是显示loading的时候，页面是纯白色的，加载完数据后才显示内容页面。 第二种是在某个页面操作某种逻辑，比如某些耗时操作，这个时候是局部loading[一般用个帧动画或者补间动画]，由于使用频繁，因为建议在销毁弹窗时，添加销毁动画的操作。 自定义loading加载 github.com/yangchong21… 9.9 对象池Pools优化 对象池Pools优化频繁创建和销毁对象 使用对象池，可以防止频繁创建和销毁对象而出现内存抖动 在某些时候，我们需要频繁使用一些临时对象，如果每次使用的时候都申请新的资源，很有可能会引发频繁的 gc 而影响应用的流畅性。这个时候如果对象有明确的生命周期，那么就可以通过定义一个对象池来高效的完成复用对象。 具体参考案例，可以看该项目：github.com/yangchong21… 10.RecyclerView优化10.1 页面为何卡顿 RecyclerView滑动卡顿的原因有哪些？ 第一种：嵌套布局滑动冲突 导致嵌套滑动难处理的关键原因在于当子控件消费了事件, 那么父控件就不会再有机会处理这个事件了, 所以一旦内部的滑动控件消费了滑动操作, 外部的滑动控件就再也没机会响应这个滑动操作了 第二种：嵌套布局层次太深，比如六七层等 测量，绘制布局可能会导致滑动卡顿 第三种：比如用RecyclerView实现画廊，加载比较大的图片，如果快速滑动，则可能会出现卡顿，主要是加载图片需要时间 第四种：在onCreateViewHolder或者在onBindViewHolder中做了耗时的操作导致卡顿。按stackoverflow上面比较通俗的解释：RecyclerView.Adapter里面的onCreateViewHolder()方法和onBindViewHolder()方法对时间都非常敏感。类似I/O读写，Bitmap解码一类的耗时操作，最好不要在它们里面进行。 关于RecyclerView封装库 github.com/yangchong21… 10.2 具体优化方案 03.SparseArray替代HashMap 04.瀑布流图片错乱问题解决 05.item点击事件放在哪里优化 06.ViewHolder优化 07.连续上拉加载更多优化 08.拖拽排序与滑动删除优化 09.暂停或停止加载数据优化 11.异常情况下保存状态 12.多线程下插入数据优化 14.recyclerView优化处理 15.adapter优化 具体看这篇博客：recyclerView优化 关于其他内容介绍于博客汇总链接 1.技术博客汇总 2.开源项目汇总 3.生活博客汇总 4.喜马拉雅音频汇总 5.其他汇总]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android骨架屏，了解一下]]></title>
    <url>%2Fposts%2F2114cdef.html</url>
    <content type="text"><![CDATA[以前做应用开发时，在数据尚未加载前一般会先给用户一个提示，最简单粗暴的方式就是菊花图，大多数做法是放一张有个性的静态图，示意正在加载数据，这样体验会好些，直到出现 Skeleton Screen（中文一般叫做骨架屏）极大地提升用户感知体验。其实一开始我并不知道这个效果叫什么名字，后来在 GitHub 看到有人开源了，赶紧 Star。今天我给大家推荐几个 Skeleton Screen 相关库，来了解学习一波。 1、ShimmerRecyclerView简介A custom recycler view with shimmer views to indicate that views are loading （英语渣渣，这句话始终翻译不顺/捂脸）。 效果预览 2、Skeleton简介这个库提供了一种显示骨架加载视图的简便方法，它现在使用闪存动画的内存优化版本，因此速度更快，您也可以设置更大的布局动画。 效果预览 3、spruce-android简介Spruce 是一个轻量级动画库，可帮助编排屏幕上的动画。该库同时支持 iOS。 效果预览]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>骨架屏</tag>
        <tag>加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，Flutter]]></title>
    <url>%2Fposts%2Fbe2502a3.html</url>
    <content type="text"><![CDATA[什么是Flutter2018年2月27日，在2018世界移动大会上，Google发布了Flutter的第一个Beta版本。Flutter是Google用以帮助开发者在Ios和Android两个平台开发高质量原生应用的全新移动UI框架，点击查看Flutter介绍视频。 其实我第一次听说Flutter是在收到谷歌开发者公众号的推送里，当时读完了那篇文章觉得Flutter的优点确实比较突出： 热重载（Hot Reload），作为一个菜鸟安卓开发者，能热重载真的太舒服了，利用Android Studio直接一个ctrl+s就可以保存并重载，模拟器立马就可以看见效果，就这一点比原生安卓制作简直不知道高到哪里去了。 一切皆为Widget的理念，对于Flutter来说，手机应用里的所有东西都是Widget，通过可组合的空间集合、丰富的动画库以及分层课扩展的架构实现了富有感染力的灵活界面设计。 借助可移植的GPU加速的渲染引擎以及高性能本地代码运行时以达到跨平台设备的高质量用户体验。 这段介绍是直接抄下来的，虽然我并不知道什么叫可移植的GPU加速的渲染引擎，但是最终结果就是利用Flutter构建的应用在运行效率上会和原生应用差不多。 酷安上有一个Flutter的演示Demo，Flutter Gallery。 如果经常逛酷安的一定会发现这个画廊的演示Demo的图标和另一个演示Demo的图标是一样的，Google Fuchsia OS Preview,这个应用的是传闻的Google正在研发的新一代操作系统，所以个人认为，Flutter的存在可能不仅仅是实现在安卓和IOS上的运行，更是为了日后丰富Fuchsia这个新系统的软件生态而存在的。 Flutter的核心内容接下来我想写一下我自己通过这两天的接触对于Flutter的核心内容也就是上面好处的第二点的理解。 一切都是控件（Widget）在Flutter中，每个应用程序都是Widget，这点和其他的应用框架不一样，Flutter的对象模型是统一的，也就是控件。 一个控件可以定义： 结构元素（比如按钮或者菜单） 风格元素（比如字体或者颜色方案） 布局 一些业务逻辑 等等。。。。 控件是基于构图形成层次结构，每个控件嵌套在其中，并从其父代继承属性，没有单独的“应用程序”对象，只有根控件。 您可以通过告知框架用另一个控件替换层次结构中的控件来响应事件，比如用户交互，然后框架会对比新的控件和旧的控件，并有效的更新用户界面，即更新有变化的控件。 也就是说，在Flutter中，一个应用就是有许许多多的Widget组合而成的。 构建第一个Flutter实例先来介绍一下Flutter里面的基本空间： Text：文本控件，在应用中创建各种样式的文本。 Row,Column：Flex控件，可以创建水平(Row)或垂直(Column)方向的布局，是基于Web的flexbox的布局模式设计的。 Stack：非线性布局（水平或垂直），控件可以堆叠在其他控件上，可以使用Positioned控件控制Stack相对顶部、右部、底部和左部的位置，是基于Web的absolute定位的布局模式。 Container：创建矩形的可视元素，可以用BoxDecoration来设计样式，比如背景、边框和阴影，Container也有边距、填充和大小限制，另外，还可以在三维空间利用矩阵进行变换。 结合实例分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import 'package:flutter/material.dart';class MyAppBar extends StatelessWidget &#123; MyAppBar(&#123;this.title&#125;); final Widget title; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Container( height: 56.0, padding: const EdgeInsets.symmetric(horizontal: 8.0), decoration: new BoxDecoration(color: Colors.blue[500]), //new Row意味着该子布局为水平布局 child: new Row( children: &lt;Widget&gt;[ //布局依次为图标按钮，剩余容器和图标按钮，如果把第二个IconButton移动到Expanded前则内容会发生改变 new IconButton( icon: new Icon(Icons.menu), tooltip: '导航菜单', onPressed: null ), //Expanded的作用可以使用剩余的所有空间。 new Expanded( child: title ), new IconButton( icon: new Icon(Icons.search), tooltip: '搜索', onPressed: null ) ], ), ); &#125;&#125;class MyScaffold extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Material( child: new Column( children: &lt;Widget&gt;[ new MyAppBar( title: new Text( '示例标题', style: Theme .of(context) .primaryTextTheme .title, ), ), new Expanded( child: new Center( child: new Text('你好世界！'), ), ) ], ), ); &#125;&#125;void main() &#123; runApp(new MaterialApp( title: '我的应用', home: new MyScaffold(), ));&#125; 其实说真的我第一眼看到这段代码的时候，第一想法就是，为什么会有这么多括号？但是这不是重点，有点编程经验的都知道要先从main函数看起，这里的main函数里面套了一个runApp函数， runApp函数接受指定的控件(Widget)，并使其作为控件树(widget tree)的根控件。 runApp里面new了一个MaterialApp对象，然后这个对象有两个参数，第一个是titile，指明了这个控件的标题是啥，第二个参数是home，指明了这个控件的主体是啥。 再深入的看就会发现，home的值是一个new出来的MyScaffold对象，这时我们就可以去查看MyScaffold这个类的声明代码。 MyScaffold控件为子控件设置垂直布局，在垂直顶部放置一个MyAppBar的实例（这个控件也是自己创建的），将MyAppBar的Text控件作为标题使用，将控件作为参数传递给其他控件非常方便实用的，你可以创建通用的控件，以各种方式重复的使用。最后，MyScaffold使用Expanded，用一个中心文本来填充剩余的空间。 MyAppBar控件创建了一个Container(容器)，高度为56设备无关像素(device-independent pixels)，内部左右填充8像素(pixels)。在容器内部，MyAppBar为子控件设置Row(水平)布局，中间的title控件被设置成Expanded，Expanded的作用是展开Row、Column和Flex的子控件，意味它可以使用剩余的所有空间。 其实上述的分析过程就是一个对控件数的一个遍历，从根控件到里面的子控件，Flutter的设计理念就是一切皆为控件，组件套组建。虽然上述代码不是java，c等主流代码，但是理解起来却并不是非常难懂，上手难度确实不大，值得体验。 最后，推荐一些链接： Flutter官网 Flutter教程 Flutter中文开发者论坛]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP长连接说明]]></title>
    <url>%2Fposts%2Fa8aa4c4c.html</url>
    <content type="text"><![CDATA[[HTTP协议与TCP/IP协议的关系] [如何理解HTTP协议是无状态的] 什么是长连接、短连接？ [TCP连接] [TCP短连接] [TCP长连接] [长连接和短连接的优点和缺点] 目前腾讯云负载均衡对七层负载均衡的HTTP长连接配置，可设置为默认值75s，用户可对不同的负载均衡实例进行自定义配置。那么，HTTP长连接、短连接究竟是什么？ HTTP协议与TCP/IP协议的关系HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。 如何理解HTTP协议是无状态的HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 什么是长连接、短连接？在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 TCP连接当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。 经典的三次握手建立连接示意图： 经典的四次握手关闭连接示意图： TCP短连接模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。 短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。 TCP长连接我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。 如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态： 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。 长连接和短连接的优点和缺点由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。 长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。 转自腾讯云：HTTP长连接说明]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>HTTP长连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动App网络优化概述]]></title>
    <url>%2Fposts%2F38627c74.html</url>
    <content type="text"><![CDATA[一般开发一个 APP，会直接调用系统提供的网络请求接口去服务端请求数据，再针对返回的数据进行一些处理，或者使用AFNetworking/OKHttp这样的网络库，管理好请求线程和队列，再自动做一些数据解析，就结束了。 但对于一些大型 APP，还会想针对网络的一些问题进行进一步优化，包括： 速度：网络请求的速度怎样能进一步提升？ 弱网：移动端网络环境随时变化，经常出现网络连接很不稳定可用性差的情况，怎样在这种情况下最大限度最快地成功请求？ 安全：怎样防止被第三方窃听/篡改或冒充，防止运营商劫持，同时又不影响性能？ 对基于浏览器的前端开发来说，网络这块能做的事情很少，但对于客户端 APP 来说，整个网络请求过程是自由控制的，可以做很多事情，很多大型 APP 都针对这三个问题做了很多网络层的优化，一些新的网络层协议像 HTTP2 / QUIC 也是在这些方面进行了不少优化，在这里边学习边整理，大致列举一下常见的做法。 速度正常一条网络请求需要经过的流程是这样： DNS 解析，请求DNS服务器，获取域名对应的 IP 地址。 与服务端建立连接，包括 tcp 三次握手，安全协议同步流程。 连接建立完成，发送和接收数据，解码数据。 这里有明显的三个优化点： 直接使用 IP 地址，去除 DNS 解析步骤。 不要每次请求都重新建立连接，复用连接或一直使用同一条连接(长连接)。 压缩数据，减小传输的数据大小。 逐条来看能做什么。 1.DNSDNS 完整的解析流程很长，会先从本地系统缓存取，若没有就到最近的 DNS 服务器取，若没有再到主域名服务器取，每一层都有缓存，但为了域名解析的实时性，每一层缓存都有过期时间，这种 DNS 解析机制有几个缺点： 缓存时间设置得长，域名更新不及时，设置得短，大量 DNS 解析请求影响请求速度。 域名劫持，容易被中间人攻击，或被运营商劫持，把域名解析到第三方 IP 地址，据统计劫持率会达到7%。 DNS 解析过程不受控制，无法保证解析到最快的IP 一次请求只能解析一个域名。 为了解决这些问题，就有了 HTTPDNS，原理很简单，就是自己做域名解析的工作，通过 HTTP 请求后台去拿到域名对应的 IP 地址，直接解决上述所有问题： 域名解析与请求分离，所有请求都直接用IP地址，无需 DNS 解析，APP 定时请求 HTTPDNS 服务器更新IP地址即可。 通过签名等方式，保证 HTTPDNS 请求的安全，避免被劫持。 DNS 解析由自己控制，可以确保根据用户所在地返回就近的 IP 地址，或根据客户端测速结果使用速度最快的 IP。 一次请求可以解析多个域名。 其余细节就不多说了，HTTPDNS 优点这么多，几乎成为中大型 APP 的标配。至此解决了第一个问题 — DNS 解析耗时的问题，顺便把一部分安全问题 — DNS 劫持也解决了。 2.连接第二个问题，连接建立耗时的问题，这里主要的优化思路是复用连接，不用每次请求都重新建立连接，如何更有效率地复用连接，可以说是网络请求速度优化里最主要的点了，并且这里的优化仍在演进过程中，值得了解下。 keep-aliveHTTP 协议里有个 keep-alive，HTTP1.1默认开启，一定程度上缓解了每次请求都要进行TCP三次握手建立连接的耗时。原理是请求完成后不立即释放连接，而是放入连接池中，若这时有另一个请求要发出，请求的域名和端口是一样的，就直接拿出连接池中的连接进行发送和接收数据，少了建立连接的耗时。 实际上现在无论是客户端还是浏览器都默认开启了keep-alive，对同个域名不会再有每发一个请求就进行一次建连的情况，纯短连接已经不存在了。但有个问题，就是这个 keep-alive 的连接一次只能发送接收一个请求，在上一个请求处理完成之前，无法接受新的请求。若同时发起多个请求，就有两种情况： 若串行发送请求，可以一直复用一个连接，但速度很慢，每个请求都要等待上个请求完成再进行发送。 若并行发送这些请求，那么首次每个请求都要进行tcp三次握手建立新的连接，虽然第二次可以复用连接池里这堆连接，但若连接池里保持的连接过多，对服务端资源产生较大浪费，若限制了保持的连接数，并行请求里超出的连接仍每次要建连。 对这个问题，新一代协议 HTTP2 提出了多路复用去解决。 多路复用HTTP2 的多路复用机制一样是复用连接，但它复用的这条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行，也就解决了上面说的并发请求需要建立多条连接带来的问题，网络上有张图可以较形象地表现这个过程： ￼ HTTP1.1的协议里，在一个连接里传送数据都是串行顺序传送的，必须等上一个请求全部处理完后，下一个请求才能进行处理，导致这些请求期间这条连接并不是满带宽传输的，即使是HTTP1.1的pipelining可以同时发送多个request，但response仍是按请求的顺序串行返回，只要其中一个请求的response稍微大一点或发生错误，就会阻塞住后面的请求。 HTTP2 这里的多路复用协议解决了这些问题，它把在连接里传输的数据都封装成一个个stream，每个stream都有标识，stream的发送和接收可以是乱序的，不依赖顺序，也就不会有阻塞的问题，接收端可以根据stream的标识去区分属于哪个请求，再进行数据拼接，得到最终数据。 解释下多路复用这个词，多路可以认为是多个连接，多个操作，复用就是字面上的意思，复用一条连接或一个线程。HTTP2这里是连接的多路复用，网络相关的还有一个I/O的多路复用(select/epoll)，指通过事件驱动的方式让多个网络请求返回的数据在同一条线程里完成读写。 客户端来说，iOS9 以上 NSURLSession 原生支持 HTTP2，只要服务端也支持就可以直接使用，Android 的 okhttp3 以上也支持了 HTTP2，国内一些大型 APP 会自建网络层，支持 HTTP2 的多路复用，避免系统的限制以及根据自身业务需要增加一些特性，例如微信的开源网络库 mars，做到一条长连接处理微信上的大部分请求，多路复用的特性上基本跟 HTTP2 一致。 TCP队头阻塞HTTP2 的多路复用看起来是完美的解决方案，但还有个问题，就是队头阻塞，这是受限于 TCP 协议，TCP 协议为了保证数据的可靠性，若传输过程中一个 TCP 包丢失，会等待这个包重传后，才会处理后续的包。HTTP2的多路复用让所有请求都在同一条连接进行，中间有一个包丢失，就会阻塞等待重传，所有请求也就被阻塞了。 对于这个问题不改变 TCP 协议就无法优化，但 TCP 协议依赖操作系统实现以及部分硬件的定制，改进缓慢，于是 GOOGLE 提出 QUIC 协议，相当于在 UDP 协议之上再定义一套可靠传输协议，解决 TCP 的一些缺陷，包括队头阻塞。具体解决原理网上资料较多，可以看看。 QUIC 处于起步阶段，少有客户端接入，QUIC 协议相对于 HTTP2 最大的优势是对TCP队头阻塞的解决，其他的像安全握手 0RTT / 证书压缩等优化 TLS1.3 已跟进，可以用于 HTTP2，并不是独有特性。TCP 队头阻塞在 HTTP2 上对性能的影响有多大，在速度上 QUIC 能带来多大提升待研究。 3.数据第三个问题，传输数据大小的问题。数据对请求速度的影响分两方面，一是压缩率，二是解压序列化反序列化的速度。目前最流行的两种数据格式是 json 和 protobuf，json 是字符串，protobuf 是二进制，即使用各种压缩算法压缩后，protobuf 仍会比 json 小，数据量上 protobuf 有优势，序列化速度 protobuf 也有一些优势，这两者的对比就不细说了。 压缩算法多种多样，也在不断演进，最新出的 Brotli 和Z-standard实现了更高的压缩率，Z-standard 可以根据业务数据样本训练出适合的字典，进一步提高压缩率，目前压缩率表现最好的算法。 除了传输的 body 数据，每个请求 HTTP 协议头的数据也是不可忽视，HTTP2 里对 HTTP 协议头也进行了压缩，HTTP 头大多是重复数据，固定的字段如 method 可以用静态字典，不固定但多个请求重复的字段例如 cookie 用动态字典，可以达到非常高的压缩率，这里有详细介绍。 通过 HTTPDNS，连接多路复用，更好的数据压缩算法，可以把网络请求的速度优化到较不错的程度了，接下来再看看弱网和安全上可以做的事情。 弱网手机无线网络环境不稳定，针对弱网的优化，微信有较多实践和分享，包括： 提升连接成功率复合连接，建立连接时，阶梯式并发连接，其中一条连通后其他连接都关闭。这个方案结合串行和并发的优势，提高弱网下的连接成功率，同时又不会增加服务器资源消耗：￼ 制定最合适的超时时间对总读写超时(从请求到响应的超时)、首包超时、包包超时(两个数据段之间的超时)时间制定不同的计算方案，加快对超时的判断，减少等待时间，尽早重试。这里的超时时间还可以根据网络状态动态设定。 调优TCP参数，使用TCP优化算法。对服务端的TCP协议参数进行调优，以及开启各种优化算法，使得适合业务特性和移动端网络环境，包括RTO初始值，混合慢启动，TLP，F-RTO等。 针对弱网的这些细致优化未成为标准，系统网络库没有内置，不过前两个客户端优化微信的开源网络库 mars 有实现，若有需要可以使用。 安全标准协议 TLS 保证了网络传输的安全，前身是 SSL，不断在演进，目前最新是 TLS1.3。常见的 HTTPS 就是 HTTP 协议加上 TLS 安全协议。 安全协议概括性地说解决两个问题：1.保证安全 2. 降低加密成本 在保证安全上： 使用加密算法组合对传输数据加密，避免被窃听和篡改。 认证对方身份，避免被第三方冒充。 加密算法保持灵活可更新，防止定死算法被破解后无法更换，禁用已被破解的算法。 降低加密成本上： 用对称加密算法加密传输数据，解决非对称加密算法的性能低以及长度限制问题。 缓存安全协议握手后的密钥等数据，加快第二次建连的速度。 加快握手过程：2RTT-&gt; 0RTT。加快握手的思路，就是原本客户端和服务端需要协商使用什么算法后才能加密发送数据，变成通过内置的公钥和默认的算法，在握手的同时就把数据发出去，也就是不需要等待握手就开始发送数据，达到0RTT。 这些点涉及的细节非常多，对 TLS 的介绍有一篇雄文，说得很详细，在此推荐。 目前基本主流都支持 TLS1.2，iOS 网络库默认使用 TLS1.2，Android4.4 以上支持 1.2。TLS1.3 iOS 还处于测试阶段，Android 未查到消息。对于普通 APP，只要正确配置证书，TLS1.2 已经能保证传输安全，只是在建连速度上会有所损耗，有一些大型 APP 像微信就自行实现了 TLS1.3 的部分协议，早一步全平台支持。 最后网络优化这个话题非常庞大，本文只是在学习过程中从优化思路上列举了目前业界常见的优化点，还有很多细节很多更深入的优化没涉及到，网络层实践开发经验不足，若有错误欢迎指出。]]></content>
      <categories>
        <category>Android</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公司Android项目架构演进]]></title>
    <url>%2Fposts%2F600a4740.html</url>
    <content type="text"><![CDATA[入职ZTC接近两年，因为业务繁重，从入职开始一直在做业务上的需求，项目还是MVC模式开发，由此可见工程的耦合度极高，也是众多反锁的业务互相关联导致最初开发的时候没有很好的设计架构。经过大半年的边重构项目边合并老项目新需求的开发，见证了开发团队一路走来的努力，Android团队也在自己预期的想法中向前迈进。 前言在公司的发展方向上，由单一的求职平台，到人脉社交，问答社区的扩展，让我察觉到组件化必然是正确的演进方向。在项目gradle升级到3.x后，依赖隔离的新特性更是帮助我对组件化的推进工作。 组件化优点在现在的大环境下组件化的优点相信大家都比较熟悉。 高内聚，低耦合，代码边界清晰，每一个组件都可以拆分出来独立运行 功能集中，每一个组件负责属于自己组件的工作，不受其他组件影响也不影响其他组件功能 提高开发效率，每个组件可单独调试，保证代码质量 减少重复造轮子和维护工作量 加快编译速度，最理想的情况是，App工程仅仅是一个空壳，用于加载各个组件 组件化方案现在GitHub上面流行着各大家公司开源的路由库，他们基本采用组件化的方案是 这个是比较通用组件化的一个方式，当然不同厂有着会根据自己的实际情况进行改造流程，但是基本大同小异，我们五花八门讨论得最多的是不同业务组件的路由通讯协议封装，我们将一个个业务组件细化拆分，不可能最后是互相直接依赖使用导致各种混乱和耦合，我们此时需要的是路由，它帮我们管理各业务组件间有序地通讯，路由重点划一下:事件分发和动态拦截。 我第一期组件化的工作方向是功能模块化与业务组件化相结合。这是因为我们项目是一直遵循着模块化，对功能的整理比较好，我这边不对每一个业务进行拆分组件化，也就是不采用现很热门的路由通讯方式，因为如果我将项目弄成完全组件化，是过度封装了，导致开发成本不协调，然而目前我们首要处理的问题是业务组件复用问题，所以避免我们重复造轮子，我们先将咨询组件、支付组件、定位组件、网络请求组件、推送组件进行分离，同时优化封装图片加载库、普通工具库、Banner工具库、友盟第三方库、图片选择库、JSBridge库、地图库等非业务性的基础库。 总结组件化的推进工作，从简单的分离代码，里面帮助我们更好地梳理了陈旧代码，及时整理好wiki。到享受面向过程、面向对象、面向接口、面向切面的编程乐趣。 展望到了最后，这次组件化构架演进，只是一个开始，就如一开始所说的，将来会有一天多款App会进行整合，我个人推荐的是通过插件化的方式加载对应的业务模块，在前段时间官方所推出的动态化框架Android App Bundles更适合未来的发展。另外在未来大前端完全介入商城日常开发，架构还会继续进行调整。以上是我的简单总结和对模块化的一些尝试，不足之处还望大家交流指正。]]></content>
      <categories>
        <category>Android</category>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中JSBridge的原理与实现]]></title>
    <url>%2Fposts%2F88a3890e.html</url>
    <content type="text"><![CDATA[Android中的JSBridge是H5与Native通信的桥梁，其作用是实现H5与Native间的双向通信。要实现H5与Native的双向通信，解决如下四个问题即可： 1、Java如何调用JavaScript 2、JavaScript如何调用Java 3、方法参数以及回调如何处理 4、通信的数据格式是怎么样的 下面从以上问题依次开始讨论: 1、Java如何调用JavaScript在Android 中，Java与JavaScript的一切交互都是依托于WebView的。可通过如下方法来完成，其中function（）即为JavaScript代码，来实现相应的具体H5层功能 1WebView.loadUrl("javascript:function()"); 2、JavaScript如何调用Java要实现在JavaScript中调用Java，就需要在JavaScript中有触发Java方法的对象和方法。在JavaScript中，当调用window对象的prompt方法时，会触发Java中的WebChromeClient对象的onJsPrompt方法，因此可以利用这个机制来实现js调用native的代码。 3、方法参数以及回调处理任何IPC通信都涉及到参数序列化的问题，同理，Java与JavaScript之间只能传递基础类型（包括基本类型和字符串），不包括其他对象或者函数。所以可以采用json格式来传递数据。JavaScript与Java相互调用不能直接获取返回值，只能通过回调的方式来获取返回结果。 4、通信的数据格式Java与JavaScript通信需要遵循一定的通信协议，可以仿照HTTPS协议来将此协议定义为jsbridge协议： 1jsbridge://className:port/methodName?jsonObj 当js调用native功能时，应当指定native层要完成某个功能调用的类名（className）和方法名（methodName），以及js传递过来的参数（jsonObj）。port值是指当native需要将操作结果返回给js时，在js中定义一个callback，并将这个callback存储在指定的位置上，这个port就定义了callback的存储位置。 JSBridge的具体工作流程图如上所示：1、js触发调用native层的行为 1JSBridge.call(className, methodName, params, callback); 将call方法中的参数组合成jsbridge协议格式的url。然后通过prompt方法将url传递到native层。 1window.prompt(url); 2、通过WebChromeClient来获取js传递过来的url. 1234567public class JSBridgeWebChromeClient extends WebChromeClient &#123; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; result.confirm(JSBridge.callJava(view, message)); return true; &#125;&#125; 3、JSBridge类管理暴露给前端方法，前端调用的方法应该在此类中注册才可使用。register的实现是从Map中查找key是否存在，不存在则反射取得对应class中的所有方法,具体方法是在BridgeImpl中定义的，方法包括三个参数分别为WebView、JSONObject、CallBack。如果满足条件，则将所有满足条件的方法put到map中。 12345678910private static Map&lt;String, HashMap&lt;String, Method&gt;&gt; exposedMethods = new HashMap&lt;&gt;();public static void register(String exposedName, Class&lt;? extends IBridge&gt; clazz) &#123; if (!exposedMethods.containsKey(exposedName)) &#123; try &#123; exposedMethods.put(exposedName, getAllMethod(clazz)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; JSBridge类中的callJava方法就是将js传递过来的URL解析，根据将要调用的类名从刚刚建立的Map中找出，根据方法名调用具体的方法，并将解析出的三个参数传递进去。 123456789101112131415161718192021222324252627282930313233public static String callJava(WebView webView, String uriString) &#123; String methodName = ""; String className = ""; String param = "&#123;&#125;"; String port = ""; if (!TextUtils.isEmpty(uriString) &amp;&amp; uriString.startsWith("JSBridge")) &#123; Uri uri = Uri.parse(uriString); className = uri.getHost(); param = uri.getQuery(); port = uri.getPort() + ""; String path = uri.getPath(); if (!TextUtils.isEmpty(path)) &#123; methodName = path.replace("/", ""); &#125; &#125; if (exposedMethods.containsKey(className)) &#123; HashMap&lt;String, Method&gt; methodHashMap = exposedMethods.get(className); if (methodHashMap != null &amp;&amp; methodHashMap.size() != 0 &amp;&amp; methodHashMap.containsKey(methodName)) &#123; Method method = methodHashMap.get(methodName); if (method != null) &#123; try &#123; method.invoke(null, webView, new JSONObject(param), new Callback(webView, port)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; return null; &#125; 4、CallBack类是用来回调js中回调方法的Java对应类。Java层处理好的返回结果是通过CallBack类来实现的。在这个回调类中传递的参数是JSONObject（返回结果）、WebView和port，port应与js传递过来的port相对应。 1234567891011121314151617181920private static Handler mHandler = new Handler(Looper.getMainLooper()); private static final String CALLBACK_JS_FORMAT = "javascript:JSBridge.onFinish('%s', %s);"; private String mPort; private WeakReference&lt;WebView&gt; mWebViewRef; public Callback(WebView view, String port) &#123; mWebViewRef = new WeakReference&lt;&gt;(view); mPort = port; &#125; public void apply(JSONObject jsonObject) &#123; final String execJs = String.format(CALLBACK_JS_FORMAT, mPort, String.valueOf(jsonObject)); if (mWebViewRef != null &amp;&amp; mWebViewRef.get() != null) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mWebViewRef.get().loadUrl(execJs); &#125; &#125;); &#125; &#125; 5、JSBridgeImpl类中定义所有暴露给前端的方法的具体实现。本文以showToast为例来通过native代码显示toast，并给出js的回调函数，返回一个JSONObject对象。 1234567891011121314public static void showToast(WebView webView, JSONObject param, final Callback callback) &#123; String message = param.optString("msg"); Toast.makeText(webView.getContext(), message, Toast.LENGTH_SHORT).show(); if (null != callback) &#123; try &#123; JSONObject object = new JSONObject(); object.put("key", "value"); object.put("key1", "value1"); callback.apply(getJSONObject(0, "ok", object)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 6、在js中通过 12JSBridge.call('bridge','showToast',&#123;'msg': 'Hello'&#125;, function(res)&#123;alert(JSON.stringi fy(res))&#125;)" 即可调用在Java层定义的showToast方法，调用前不要忘记在java层的JSBridge中注册该方法。 1JSBridge.register("bridge", BridgeImpl.class); 二、总结：JSBridge的基本原理为：H5-&gt;通过某种方式触发一个url-&gt;Native捕获到url,进行分析-&gt;原生做处理-&gt;Native调用H5的JSBridge对象传递回调。如下图 三、安全性： Android4.2以下，addJavascriptInterface方法有安全漏洞，js代码可以获取到Java层的运行时对象，来伪造当前用户执行恶意代码。 ios7以下，JavaScript无法调用native代码。 通过js声明的对象，是通过loadUrl注入到页面中的，所以这个对象是js对象，而不是Java对象，没有getClass等Object方法，因此也无法获得Runtime对象，避免了恶意代码的注入。 JSBridge采用URL解析的交互方式，是一套成熟的解决方案，便于拓展，无重大安全性问题。]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[127.0.0.1和0.0.0.0地址的区别]]></title>
    <url>%2Fposts%2F21cd72b5.html</url>
    <content type="text"><![CDATA[1. 问题引入之前在使用tomcat的时候，启动tomcat默认都会绑定到127.0.0.1这个地址，最近在使用hexo写博客的时候发现通过 hexo server命令启动服务的时候绑定的ip地址是0.0.0.0。那么这两个IP地址到底有什么不同呢? 在讲解两个地址的不同之前，我们先回顾一下IP地址的基础知识。 2. IP地址分类2.1 IP地址表示IP地址由两个部分组成，net-id和host-id，即网络号和主机号。net-id:表示ip地址所在的网络号。host-id：表示ip地址所在网络中的某个主机号码。 即： 1IP-address ::= &#123; &lt;Network-number&gt;, &lt;Host-number&gt; &#125; 2.2 IP地址分类IP地址一共分为5类，即A～E，它们分类的依据是其net-id所占的字节长度以及网络号前几位。 A类地址:网络号占1个字节。网络号的第一位固定为0。 B类地址：网络号占2个字节。网络号的前两位固定为10。 C类地址：网络号占3个字节。网络号的前三位固定位110。 D类地址：前四位是1110，用于多播(multicast)，即一对多通信。 E类地址：前四位是1111，保留为以后使用。其中，ABC三类地址为单播地址（unicast),用于一对一通信，是最常用的。 2.3 特殊IP地址特殊IP地址就是用来做一些特殊的事情。RFC1700中定义了以下特殊IP地址。 {0,0}:网络号和主机号都全部为0，表示“本网络上的本主机”，只能用作源地址。 {0，host-id}:本网络上的某台主机。只能用作源地址。 {-1,-1}：表示网络号和主机号的所有位上都是1（二进制），用于本网络上的广播，只能用作目的地址，发到该地址的数据包不能转发到源地址所在网络之外。 {net-id,-1}:直接广播到指定的网络上。只能用作目的地址。 {net-id,subnet-id,-1}:直接广播到指定网络的指定子网络上。只用作目的地址。 {net-id,-1,-1}:直接广播到指定网络的所有子网络上。只能用作目的地址。 {127，}:即网络号为127的任意ip地址。都是内部主机回环地址(loopback),永远都不能出现在主机外部的网络中。 3. 问题解答接下来我们来看之前问过的问题：127.0.0.1和0.0.0.0地址的区别是什么？我们先来看下共同点： 都属于特殊地址。 都属于A类地址。 都是IPV4地址。 接下来我们分别看下这两个地址： 0.0.0.0IPV4中，0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。 在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。 在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。 用途总结 当一台主机还没有被分配一个IP地址的时候，用于表示主机本身。（DHCP分配IP地址的时候） 用作默认路由，表示”任意IPV4主机”。用来表示目标机器不可用。 用作服务端，表示本机上的任意IPV4地址。 127.0.0.1127.0.0.1属于{127,}集合中的一个，而所有网络号为127的地址都被称之为回环地址，所以回环地址！=127.0.0.1,它们是包含关系，即回环地址包含127.0.0.1。回环地址：所有发往该类地址的数据包都应该被loop back。 用途 回环测试,通过使用ping 127.0.0.1 测试某台机器上的网络设备，操作系统或者TCP/IP实现是否工作正常。 DDos攻击防御：网站收到DDos攻击之后，将域名A记录到127.0.0.1，即让攻击者自己攻击自己。 大部分Web容器测试的时候绑定的本机地址。 localhost相比127.0.0.1，localhost具有更多的意义。localhost是个域名，而不是一个ip地址。之所以我们经常把localhost与127.0.0.1认为是同一个是因为我们使用的大多数电脑上都讲localhost指向了127.0.0.1这个地址。在ubuntu系统中，/ets/hosts文件中都会有如下内容： 1127.0.0.1 localhost127.0.1.1 jason-Lenovo-V3000# The following lines are desirable for IPv6 capable hosts::1 ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters 上面第一行是几乎每台电脑上都会有的默认配置。但是localhost的意义并不局限于127.0.0.1。 localhost是一个域名，用于指代this computer或者this host,可以用它来获取运行在本机上的网络服务。在大多数系统中，localhost被指向了IPV4的127.0.0.1和IPV6的::1。 1127.0.0.1 localhost::1 localhost 所以，在使用的时候要注意确认IPV4还是IPV6 4. 总结127.0.0.1 是一个环回地址。并不表示“本机”。0.0.0.0才是真正表示“本网络中的本机”。在实际应用中，一般我们在服务端绑定端口的时候可以选择绑定到0.0.0.0，这样我的服务访问方就可以通过我的多个ip地址访问我的服务。 比如我有一台服务器，一个外网地址A,一个内网地址B，如果我绑定的端口指定了0.0.0.0，那么通过内网地址或外网地址都可以访问我的应用。但是如果我只绑定了内网地址，那么通过外网地址就不能访问。所以如果绑定0.0.0.0,也有一定安全隐患，对于只需要内网访问的服务，可以只绑定内网地址。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradle.properties文件使用]]></title>
    <url>%2Fposts%2Ffb76c4ba.html</url>
    <content type="text"><![CDATA[在一些项目中会分拆app 和 lib , 这时候引用support的时候,一旦更改版本会出现需要同步更改两个地方的问题.这种情况,可以通过配置gradle.properties实现替换.在项目编译过程中,gradle.properties配置的值会被编译解析,其作为配置文件使用是很有必要的. 1. 概述在Android Studio 创建一个项目的时候，Project下面会生成gradle.properties和local.properties文件，如下图: 2. properties的数据格式properties里面的数据格式采用键值对的方式，大概有以下几种写法: 12341. key=value 2. key:value 3. key :value 4. # 作为注释 这里主要参考以下链接：https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html*注意: *在Android Studio 中最好使用第一种写法，要不会有警告 3. 如何使用3.1 在项目根目录的gradle.properties文件配置:1234567891011121314151617# Project-wide Gradle settings.#添加ndk支持(按需添加)android.useDeprecatedNdk=true# 应用版本名称VERSION_NAME=1.0.0# 应用版本号VERSION_CODE=100# 支持库版本SUPPORT_LIBRARY=24.2.1# MIN_SDK_VERSIONANDROID_BUILD_MIN_SDK_VERSION=14# TARGET_SDK_VERSIONANDROID_BUILD_TARGET_SDK_VERSION=24# BUILD_SDK_VERSIONANDROID_BUILD_SDK_VERSION=24# BUILD_TOOLS_VERSIONANDROID_BUILD_TOOLS_VERSION=24.0.3 3.2 这时候配置app和lib的build.gradle可以这样写:1234567891011121314151617181920212223android &#123; compileSdkVersion project.ANDROID_BUILD_SDK_VERSION as int buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION defaultConfig &#123; applicationId project.APPLICATION_ID // lib项目不需要配置这一项 versionCode project.VERSION_CODE as int versionName project.VERSION_NAME minSdkVersion project.ANDROID_BUILD_MIN_SDK_VERSION as int targetSdkVersion project.ANDROID_BUILD_TARGET_SDK_VERSION as int &#125;&#125;dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) //这里注意是双引号 compile &quot;com.android.support:appcompat-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:design:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:recyclerview-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:support-annotations:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:cardview-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:support-v4:$&#123;SUPPORT_LIBRARY&#125;&quot;&#125; 这样配置后,当你需要升级你的编译版本,版本号,支持库等的时候,仅需要修改项目根目录的gradle.properties文件即可,是不是又方便了一点点?]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unable to resolve dependency for ':trunk@debug/compileClasspath']]></title>
    <url>%2Fposts%2F4cae3fd9.html</url>
    <content type="text"><![CDATA[1234repositories &#123; google() jcenter() &#125; Go to File-&gt;Settings-&gt;Build, Execution, Deployment-&gt;Gradle-&gt;Uncheck Offline work option.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码规范指南]]></title>
    <url>%2Fposts%2F89cc132f.html</url>
    <content type="text"><![CDATA[前言 无论你是个人开发还是团队，一个良好的代码规范，能够在项目当中发挥举足轻重的作用；它不仅能使你们的开发更加高效，而且还会减少BUG产生的几率，增强代码可维护性及稳定性。 关于规范，我们分两部分来讲，因为Android主要是用Java语言来写的，所以我们区别对待。 JAVA代码规范强制性规范: 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 类名使用UpperCamelCase 风格，必须遵从驼峰形式。 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长例如：MAX_STOCK_COUNT。 抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类 命名以它要测试的类的名称开始。 杜绝不规范的英文缩写：AbstractClass 缩写成AbsClass；condition缩写成condi;此类随意缩写严重降低了代码的可阅读性。 如果使用到了设计模式，建议在类名中体现出具体的模式： 关于Service或Dao层的命名 123public class ComponentFactorypublic class BufferStrategypublic class ScrollerProxy 实体类必须重载toString()方法，这样可以通过调用对象的toString()来排查问题。 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例: “test”.equals(object); 反例: object.equals(“test”); 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 推荐规范： 集合初始化时，尽量指定集合初始值大小； ArrayList尽量使用ArrayList(int initialCapacity) 初始化 。 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历 说明:keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效 率更高。如果是 JDK8，使用 Map.foreach 方法。 高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格: 集合类 Key Value Super 说明 Hashtable 不允许为null 不允许为null Dictionary 线程安全 ConcurrentHashMap 不允许为null 不允许为null AbstractMap 分段锁技术 TreeMap 不允许为null 允许为null AbstractMap 线程不安全 HashMap 允许为null 允许为null AbstractMap 线程不安全 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。 通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优 化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题 解决方案中较为简单一种(适用于 JDK5 及以上版本)，将目标属性声明为 volatile 型。 1234567891011121314*反例*：class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members... &#125; Android代码规范代码： Activity 命名一律使用 模块名+Activity 的方式。例如，LoginActivity、SignupActivity； Fragment 命名一律使用 模块名+Fragment 的方式； 自定义View：Custom(建议)+功能名+View/ViewGroup(具体的组件名称)。例如：CustomImageScroller、CustomRatingBar。 Widget 小组件：ScanWidget、WeatherWidget。 Dialog对话框：功能名+Dialog。例如：LoginDialog、ProgressDialog 尽量在每一个Activity或类中加入TAG,方便我们查看Activity的信息。(Tip : 使用Android Studio提供的快捷键logt可快速生成当前 类的常量) 对于使用Intent传递数据，声明一些Key的时候： EXTRA_KEY_+具体Key名称，例如我们现在有一个人的名字和年龄要传那么首先定义： 12public static final String EXTRA_KEY_PERSON_NAME=&quot;EXTRA_KEY_PERSON_NAME&quot;public static final String EXTRA_KEY_PERSON_AGE=&quot;EXTRA_KEY_PERSON_AGE&quot; 然后在具体的页面 new Intent()，依次传递进去值，这样写其实没什么问题；但是试想一下，如果你要调用的Activity是类似于一个工具性质或通用的Activity（图片选择器、登录、注册等等），这时候你要传递的key又很多，如果业务复杂的话，你应该会被这样冗余且不易阅读的代码直接搞崩溃掉。 所以最好的办法就是在你要调用Activity提供一个静态工厂方法，要知道静态工厂方法所带来的好处太多了，由于Activity是不允许通过new的方式来初始化的，所以静态工厂方法的好处在此就不那么明显，但是已经足够我们优化我们的代码了。举个例子，我们有一个笔记 NoteActivity，用于创建笔记和修改笔记， 123456789101112131415161718192021222324//笔记Idprivate static final String EXTRA_KEY_NOTE_ID =&quot;EXTRA_KEY_NOTE_ID&quot; ;//笔记内容private static final String EXTRA_KEY_NOTE_CONTENT =&quot;EXTRA_KEY_NOTE_CONTENT&quot; ;//笔记模式private static final String EXTRA_KEY_NOTE_MODE =&quot;EXTRA_KEY_NOTE_MODE&quot; ;//用于创建笔记public static void startForCreate(Context context, int noteId) &#123; start(context, noteId, null, MODE_CREATE);&#125; //用于编辑笔记public static void startForEdit(Context context, int noteId, String content) &#123; start(context, noteId, content, MODE_UPDATE);&#125;public static void start(Context context, int noteId, String content, int mode) &#123; Intent starter = new Intent(context, TableShareListSettingActivity.class); starter.putExtra(EXTRA_KEY_NOTE_ID,noteId); starter.putExtra(EXTRA_KEY_NOTE_CONTENT,content); starter.putExtra(EXTRA_KEY_NOTE_CONTENT,mode); context.startActivity(starter);&#125; 通过以上方法，我们能够很好的解耦复杂的Activity之间的调用，再加上静态方法工厂方法名，代码可阅读行大大提高，最终我们看到的调用NoteActivity将会是很简洁的一段代码： 12NoteActivity.startForCreate(this,noteId);NoteActivity.startForEdit(this,noteId,content); 此外，Android Studio工具中其实已经在Live Template中提供了这样的代码:CMD+J( For MAC OS),简单的输入starter就可以快速地在当前的Activity中添加一个Intent的静态操作方法，这其实也说明了Android官方团队也鼓励我们这么做。 如下图所示： 一下子省了好多代码，简直太赞了有木有！ 增加类注释，使用Android Studio的 File And Code Template： 所有的常量加上注释，且功能相同的排放在一起，不同的进行换行； Activity中变量采用m开头+类名。例如，mTable、mPerson； Activity中的控件：m+模块名+控件类型名称。例如，mLoginEditText,mLoginTextView; 资源Res1.按照资源的类型，分为以下几种 控件Id命名：控件缩写 _模块（module) _功能名(function) 控件类型 ID命名规则 TextView tv_module_function EditText et_module_function ImageView iv_module_function Button btn_module_function ListView lv_module_function GridView gv_module_function CheckBox check_module_function RadioButton radio_module_function LinearLayout ll_module_function RelativeLayout rl_module_function FrameLayout fl_module_function GridLayout gl_module_function ··· ··· Color资源命名 Resources Type 命名规则 color 组件名+具体作用名。例 R.color.button_text String资源命名 Resources Type 命名规则 string 具体功能。 例 R.string.hello Drawable资源命名 Resources Type 命名规则 launcher icon ic_launcher。例R.drawable.ic_launcher normal icon ic_具体模块_功能。例R.drawable.ic_audio_pause Toolbar icon ic_ab_功能名。例如ic_ab_search selector selector_模块_功能名。例如 selector_login_button shape shape_模块功能名状态。例如 R.drawable.shape_login_button_normal Layout资源命名 类型 命名规则 activity activity_模块名。例如 R.layout.activity_login fragment fragment_模块名。例如 R.layout.fragment_login_layout_header include layout_模块名_功能名。例如 @layout/layout_login_bottom adapter adapter_item_模块名_功能名。例如 R.layout.adapter_item_simple_text dialog dialog_模块_功能名。例如 R.layout.dialog_time_picker list header header_模块_功能。例如 R.layout.header_main_top_ad list footer footer_模块_功能。例如 R.layout.footer_main_bottom_action widget widget_模块_功能。例如 R.layout.widget_app_clock ··· ··· Menu资源命名 Resources Type 命名规则 menu menu_模块名。例如 menu_login Values资源命名 Resources Type 命名规则 color 模块名_color。例如 material_design_color dimens 模块名_dimens。例如 material_design_dimens style 模块名_style。例如 material_design_style themes 模块名_themes。例如 material_design_themes 总结其实代码规范只是一个Guideline，没有说非要某一种风格来编写代码。如果你的团队有自己的一套代码规范，然后开发也很高效，代码也很容易阅读且可维护，就完全可以按照自己的团队的技术规范来。我想表达的是，在编写的代码的时候，能有一个Guideline（准则）或者说是一个约定，我们共同遵守这样的约定，来达到我一开始说的代码规范性所带来的意义。 正所谓，“离娄之明，公输子之巧，不以规矩，不能成方圆。” 参考资料阿里巴巴Java开发手册]]></content>
      <categories>
        <category>Android</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置iPhone来电铃声]]></title>
    <url>%2Fposts%2Fb0d3dc9.html</url>
    <content type="text"><![CDATA[步骤 1保证电脑上有可以播放的音乐，找到喜欢的一首歌曲，鼠标右击用 iTunes 打开，「选中歌曲《故乡》」—「右键」—「歌曲信息」，如下图： 点击「歌曲信息」后，出现一个弹框，点击「选项」，勾选「停止」，右边的输入框里面输入 0:28，因为铃声必须是40秒之内的，然后点击「好」，如图： （PS：假设这首歌的时间是5:20，你可以任意设置播放的时间段，假如高潮部分是1:32到2:05，则勾选’开始’并输入1:32，勾选’停止’并输入2:05） 步骤 2还是选中歌曲《故乡》，右上角，依次选择「文件」—「转换」—「创建 AAC 版本」，如图： 然后可能会听到一个声音，说明创建成功，在刚刚选中的歌曲《故乡》下面会多出一个一模一样的来，只不过时间变成刚刚我填写的，如图： 步骤 3选中时间较短的《故乡》，右键选择「在 Finder 中显示」，如图： 这时可以看到故乡.m4a这样一个文件，是可以播放的，把它复制到桌面上来。鼠标选中桌面上的故乡.m4a，改为故乡.m4r，选择「使用 .m4r」，如图： 步骤 4选择你的手机，如图： 勾选「手动管理音乐和视频」，之后点击「应用」，等待完成，如图： 步骤 5在桌面上把故乡.m4r歌曲拖到手机上，如下图： 这时候发现手机下的「铃声」目录，会出现刚刚的歌曲，如图： 继续选择你的手机，点击同步，静静等待完成。 在同步的过程中，如果出现如下图所示，则说明设置的铃声时间过长，应当在 40s 之内： 结束同步完成后，算是大功告成了，拿起iPhone，按顺序 选择「设置」—「声音」—「电话铃声」，激动人心的时刻终于来了~ 大功告成.png]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidView的绘制流程]]></title>
    <url>%2Fposts%2Fd94c207f.html</url>
    <content type="text"><![CDATA[本文主要是梳理 View 绘制的整体流程，帮助开发者对 View 的绘制有一个更深层次的理解。 整体流程View 绘制中主要流程分为measure，layout， draw 三个阶段。 measure ：根据父 view 传递的 MeasureSpec 进行计算大小。 layout ：根据 measure 子 View 所得到的布局大小和布局参数，将子View放在合适的位置上。 draw ：把 View 对象绘制到屏幕上。 那么发起绘制的入口在哪里呢？在介绍发起绘制的入口之前，我们需要先了解Window，ViewRootImpl，DecorView之间的联系。 一个 Activity 包含一个Window，Window是一个抽象基类，是 Activity 和整个 View 系统交互的接口，只有一个子类实现类PhoneWindow，提供了一系列窗口的方法，比如设置背景，标题等。一个PhoneWindow 对应一个 DecorView 跟 一个 ViewRootImpl，DecorView 是ViewTree 里面的顶层布局，是继承于FrameLayout，包含两个子View，一个id=statusBarBackground 的 View 和 LineaLayout，LineaLayout 里面包含 title 跟 content，title就是平时用的TitleBar或者ActionBar，contenty也是 FrameLayout，activity通过 setContent（）加载布局的时候加载到这个View上。ViewRootImpl 就是建立 DecorView 和 Window 之间的联系。 这三个阶段的核心入口是在 ViewRootImpl 类的 performTraversals() 方法中。 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 在源码中这个方法贼长，但是核心还是这三个步骤，就是判断根据之前的状态判断是否需要重新 measure，是否需要重新 layout ，是否需要重新 draw。 measureSpeac在介绍 measure 方法之前，需要了解一个很核心的概念：measureSpeac 。在 Google 官方文档中是这么定义 measureSpeac 的 A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. A MeasureSpec is comprised of a size and a mode.大概意思是：MeasureSpec 封装了从父View 传递给到子View的布局需求。每个MeasureSpec代表宽度或高度的要求。每个MeasureSpec都包含了size（大小）和mode（模式）。 我觉得这是measureSpeac 最好的解释了。 后面两句不难理解。MeasureSpec 一个32位二进制的整数型，前面2位代表的是mode，后面30位代表的是size。mode 主要分为3类，分别是 EXACTLY：父容器已经测量出子View的大小。对应是 View 的LayoutParams的match_parent 或者精确数值。 AT_MOST：父容器已经限制子view的大小，View 最终大小不可超过这个值。对应是 View 的LayoutParams的wrap_content UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。(这种不怎么常用，下面分析也会直接忽略这种情况) 封装了从父 View 传递给到子 View 的布局需求，这句话又怎么理解呢？ View 的 MeasureSpec 并不是父 View 独自决定，它是根据父 view 的MeasureSpec加上子 View 的自己的 LayoutParams，通过相应的规则转化。 看代码： View 测量流程是父 View 先测量子 View，等子 View 测量完了，再来测量自己。在ViewGroup 测量子 View 的入口就是 measureChildWithMargins 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //获取子View的LayoutParam final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //通过父View的MeasureSpec和子View的margin，父View的padding计算，算出子View的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //通过计算出来的MeasureSpec，让子View自己测量。 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //计算子View的大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // 父View是EXACTLY的 case MeasureSpec.EXACTLY: //子View的width或height是个精确值,则size为精确值，mode为 EXACTLY if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 EXACTLY &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; //子View的width或height是WRAP_CONTENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 2、父View是AT_MOST的 case MeasureSpec.AT_MOST: //子View的width或height是个精确值,则size为精确值，mode为 EXACTLY if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 父View是UNSPECIFIED的 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 通过代码我们很可以很看到 View 的子 View 的 MeasureSpec 转化规则，但是感觉可能有点懵，我们用一个”商城-衣服”例子来比喻一下： 我们把父 View 看做成商城，子 View 看做成衣服，EXACTLY / MATCH_PARENT 看做成高档品牌，AT_MOST / WRAP_CONTENT 看做成杂牌，精确值看做成价格，View的大小看做价格。 如果是衣服（子 View）产地是高档品牌（LayoutParams = LayoutParams.MATCH_PARENT），商城是（父 View）高档的商城（EXACTLY），那么衣服的价格（size 大小）就会根据高档商城价格来定，能有多高就卖多高（View的大小取决于父View大小）。 如果是衣服（子 View）产地是高档品牌（LayoutParams = LayoutParams.MATCH_PARENT），商城是（父 View）杂牌的商城（AT_MOST），那么衣服的价格（size 大小）也会根据低档商城价格来定，太高普通人也买不起呀（View的大小取决于父View大小）。 如果是衣服（子 View）产地是杂牌（LayoutParams = LayoutParams.WRAP_CONTENT），商城是（父 View）高档的商城（EXACTLY），那么衣服的价格（size 大小）也会根据高档商城价格来定，能有多高就卖多高，毕竟店大欺人，绝不打折（View的大小取决于父View大小）。 如果是衣服（子 View）产地是杂牌（LayoutParams = LayoutParams.WRAP_CONTENT），商城是（父 View）杂牌的商城（AT_MOST），那么衣服的价格（size 大小）就会根据低档商城价格来定，小巷步行街不都是这样卖的吗（View的大小取决于父View大小） 如果是衣服（子 View）已经全国明码标价（android:layout_xxxx=”200dp”），商城是（父 View）无论是杂牌的商城（AT_MOST）还是高档的商城（EXACTLY），那么衣服的价格（size 大小）就不会变的。，不然打你小屁屁。 如果你觉得例子真的糟糕透了，那么看以下一表正经总结： 一表正经总结以下： 当父View的mode是EXACTLY的时候：说明父View的大小是确定的 子View的宽或高是MATCH_PARENT： 子View的宽或高是WRAP_CONTENT：子View是包裹布局，说明子View的大小还不确定，所以子View最大不能超过父View的大小mode=AT_MOST。 子View的宽或高是具体数值：子viewd大小已经固定了，子View的大小就是固定这个数值，mode=EXACTLY。 当父View的mode是AT_MOST的时候：说明父View大小是不确定的。 子View的宽或高是MATCH_PARENT：父View大小是不确定的，子View是填充布局情况，也不能确定大小，所以View大小不能超过父View的大小，mode=AT_MOST 子View的宽或高是WRAP_CONTENT：子View是包裹布局，大小不能超过父View的大小，mode=AT_MOST。 子View的宽或高是具体数值：子viewd大小已经固定了，子View的大小就是固定这个数值，mode=EXACTLY。 需要注意一点就是，此时的MeasureSpec并不是View真正的大小，只有setMeasuredDimension之后才能真正确定View的大小。 measuremeasure 主要功能就是测量设置 View 的大小。该方法是 final 类型，子类不能覆盖，在方法里面会调用 onMeasure()，我们可以复写 onMeasure（） 方法去测量设置 View 的大小。 1234567public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; /*-----------省略代码---------------* onMeasure(widthMeasureSpec, heightMeasureSpec); /*-----------省略代码---------------*/ &#125; 在 onMeasure( ) 方法中 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; onMeasure( ) 方法就是执行测量设置 View 代码的核心所在。 我们先来看下 getSuggestedMinimumWidth() 1234protected int getSuggestedMinimumWidth() &#123; //返回建议 View 设置最小值宽度 return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; 这里返回的建议最小值就是我们xml 布局中用的属性 minWidth或者是背景大小。 同理可得 getSuggestedMinimumHeight()。 看下 getDefaultSize 主要作用就是根据View的建议最小值，结合父View传递的measureSpec，得出并返回measureSpec 看代码 123456789101112131415161718 public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; //获取父View传递过来的模式 int specMode = MeasureSpec.getMode(measureSpec); //获取父View传递过来的大小 int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size;//View的大小父View未定，设置为建议最小值 break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; getDefaultSize 的逻辑跟我们之前分析的 MeasureSpec 转化规则非常相似。就是根据specMode设置大小。如果specMode是UNSPECIFIED 未确定大小，则会使用建议最小值，如果其他两种情况，则使用父View传递过来的大小。再次强调：并不是父View 独自决定，它是根据父 view 的MeasureSpec加上子vIew的自己的LayoutParams，通过相应的规则转化而得到的大小。 再来看下 setMeasuredDimension setMeasuredDimension 作用就是将测量好的宽跟高进行存储。在onMeasure（） 必须调用这个方法，不然就会抛出 IllegalStateException 异常。 我们重新梳理一下刚才那些流程： 在measure 方法，核心就是调用onMeasure( ) 进行View的测量。在onMeasure( )里面，获取到最小建议值，如果父类传递过来的模式是MeasureSpec.UNSPECIFIED，也就是父View大小未定的情况下，使用最小建议值，如果是AT_MOST或者EXACTLY模式，则设置父类传递过来的大小，然后调用setMeasuredDimension 方法进行存储大小。 layout()作用描述measure（） 方法中我们已经测量出View的大小，根据这些大小，我们接下来就需要确定 View 在父 View 的位置进行排版布局，这就是layout 作用。对 View 进行排版布局，还是要看父 View，也就是 ViewGroup。 看代码 123456789101112@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 代码不多，大致作用就是判断 View 是否在执行动画，如果是在执行动画，则等待动画执行完调用 requestLayout()，如果没有添加动画或者动画已经执行完了，则调用 layout（），也就是调用View的 layout（）。 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) &#123; /*-----------省略代码---------------*/ boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; /*-----------省略代码---------------*/&#125; View 的 layout 的方法也是非常长。大致作用就是设置 View 的在父 View 的位置，然后判断位置是否发生变化，是否需要重新调用排版布局，如果是需要重新布局则用了 onLayout（）方法。在OnLayout 方法中，View 里面是一个空实现，而 ViewGroup 则是一个抽象方法。为什么这么设计呢？因为onLayout中主要就是为了给遍历View然后进行排版布局，分别设置View在父View中的位置。既然如此，那么View的意义就不大了，而ViewGruo 必须实现，不然没法对子View进行布局。那么如何对 View 进行排版呢？举例个简单的demo。 12345678910111213protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); for ( int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); child.layout(l, t, r, b); &#125;&#125; 就是遍历所有的子 View 然后调用 child.layout(l, t, r, b)。 大家有兴趣也可以参考一下 FrameLayout， LinearLayout这类布局。 draw（）经过前面两部的测量跟布局之后，接下来就是绘制了，也就是真正把 View 绘制在屏幕可见视图上。draw（）作用就是绘制View 的背景，内容，绘制子View,还有前景跟滚动条。看下 View 的draw（） 源码 1234567891011121314151617181920212223242526272829303132333435@CallSuperpublic void draw(Canvas canvas) &#123; /*-----------省略代码---------------*/ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; /*-----------省略代码---------------*/ if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); /*-----------省略代码---------------*/ return; &#125; draw 过程中一共分成7步，其中两步我们直接直接跳过不分析了。 第一步：drawBackground(canvas)： 作用就是绘制 View 的背景。 第二步：onDraw(canvas) ：绘制 View 的内容。View 的内容是根据自己需求自己绘制的，所以方法是一个空方法，View的继承类自己复写实现绘制内容。 第三步：dispatchDraw（canvas）：遍历子View进行绘制内容。在 View 里面是一个空实现，ViewGroup 里面才会有实现。在自定义 ViewGroup 一般不用复写这个方法，因为它在里面的实现帮我们实现了子 View 的绘制过程，基本满足需求。 第四步：onDrawForeground(canvas)：对前景色跟滚动条进行绘制。 第五步：drawDefaultFocusHighlight(canvas)：绘制默认焦点高亮。 好了，整个绘制流程就分析完毕了！]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年轻人一定要知道的71条做饭技巧，让你做出美味又营养的美食！]]></title>
    <url>%2Fposts%2F7de80bae.html</url>
    <content type="text"><![CDATA[1、煮水饺时，在水里放一颗大葱或在水开后加点盐，再放饺子，饺子味道鲜美不粘连；在和面时，每500克面粉加拌一个鸡蛋，饺子皮挺刮不粘连2、 炖肉时，在锅里加上几块桔皮，可除异味和油腻并增加汤的鲜味3、煮骨头汤时加一小匙醋，可使骨头中的磷、钙溶解于汤中，并可保存汤中的维生素。5、烧豆腐时，加少许豆腐乳或汁，味道芳香7、将绿豆在铁锅中炒10分钟再煮能很快煮烂，但注意不要炒焦8、煮蛋时水里加点醋可防蛋壳裂开，事先加点盐也可 9、煮海带时加几滴醋易烂；放几棵波菜也行 10、煮火腿之前，将火腿皮上涂些白糖，容易煮烂，味道更鲜美12、煮水饺时，在锅中加少许食盐，锅开时水也不外溢 15、熬粥或煮豆时不要放碱，否则会破坏米、豆中的营养物质 16、用开水煮新笋容易熟，且松脆可口；要使笋煮后不缩小，可加几片薄荷叶或盐17、猪肚煮熟后，切成长块，放在碗内加一些鲜汤再蒸一会儿，猪肚便会加厚一倍18、煮猪肚时，千万不能先放盐，等煮熟后吃时再放盐，否则猪肚会缩得象牛筋一样硬 20、煮牛肉和其他韧、硬肉类以及野味禽类时，加点醋可使其软化。 21、炖老鸡：在锅内加二三十颗黄豆同炖，熟得快且味道鲜；或在杀老鸡之前，先灌给鸡一汤匙食醋，然后再杀，用文火煮炖，就会煮得烂熟；或放３～４枚山楂，鸡肉易烂 23、炖老鸭：在锅里放几个田螺容易烂熟 24、烧鸭子时，把鸭子尾端两侧的臊豆去掉，味道更美 25、煮咸肉：用十几个钻有许多小孔的核桃同煮，可消除臭味26、红烧牛肉时，加少许雪里红，肉味鲜美 27、做红烧肉前，先用少许硼砂把肉腌一下，烧出来的肉肥而不腻，甘香可口 28、油炸食物时，锅里放少许食盐，油不会外溅 29、在春卷的拌馅中适量加些面粉，能避免炸制过程中馅内菜汁流出糊锅底的现象30、炸土豆之前，先把切好的土豆片放在水里煮一会儿，使土豆皮的表面形成一层薄薄的胶质层，然后再用油炸 31、炸猪排时，在有筋的地方割２～３个切口，炸出来的猪排就不会收缩 32、将鸡肉先腌一会儿，封上护膜放入冰箱，待炸时再取出，炸出的鸡肉酥脆可口33、煎荷包蛋时，在蛋黄即将凝固之际浇一点冷开水，会使蛋又黄又嫩34、煎鸡蛋时，在平底锅放足油，油微热时蛋下锅，鸡蛋慢慢变熟，外观美，不粘锅35、煎鸡蛋时，在热油中撒点面粉，蛋会煎得黄亮好看，油也不易溅出锅外36、用羊油炒鸡蛋，味香无异味 38、炒鸡蛋时加入几滴醋，炒出的蛋松软味香 39、炒茄子时，在锅里放点醋，炒出的茄子颜色不会变黑 40、炒土豆时加醋，可避免烧焦，又可分解土豆中的毒素，并使色、味相宜41、炒豆芽时，先加点黄油，然后再放盐，能去掉豆腥味 42、炒波菜时不宜加盖 43、炒肉片：肉切成薄片加酱油、黄油、淀粉，打入一个鸡蛋，拌匀，炒散；等肉片变色后，再加佐料稍炒几下，肉片味美、鲜嫩45、炒肉菜时放盐过早熟得慢，宜在将熟时加盐，在出锅前再加上几滴醋，鲜嫩可口48、做肉饼和肉丸子时，一公斤肉馅放2小匙盐 49、做丸子按50克肉10克淀粉的比例调制，成菜软嫩 50、做滑炒肉片或辣子肉丁，按50克肉５克淀粉的比例上浆，成菜鲜嫩味美51、做馒头时，如果在发面里揉进一小块猪油，蒸出来的馒头不仅洁白、松软，而且味香52、蒸馒头时掺入少许桔皮丝，可使馒头增加清香 53、蒸馒头碱放多了起黄，如在原蒸锅水里加醋２～３汤匙，再蒸10～15分钟可变白54、将少量明矾和食盐放入清水中，把切开的生红薯浸入十几分钟，洗净后蒸煮，可防止或减轻腹胀56、放有辣椒的菜太辣时或炒辣椒时加点醋，辣味大减57、烹调时，放酱油若错倒了食醋，可撒放少许小苏打，醋味即可消除58、菜太酸，将一只松花蛋捣烂放入，菜太辣，放一只鸡蛋同炒 ，菜太苦，滴入少许白醋62、汤太咸又不宜兑水时，可放几块豆腐或土豆或几片蕃茄到汤中；也可将一把米或面粉用布包起来放入汤中63、汤太腻，将少量紫菜在火上烤一下，然后撒入汤中64、花生米用油炸熟，盛入盘中，趁热撒上少许白酒，稍凉后再撒上少许食盐，放置几天几夜都稣脆如初65、菜籽油有一股异味，可把油烧热后投入适量生姜、蒜、葱、丁香、陈皮同炸片刻，油即可变香66、用菜油炸一次花生米就没有怪味了，炒出的菜肴香味可口，并可做凉拌菜67、炸完食物后的油留下一些残渣并变得混浊，可将白萝卜切成厚圆片，用筷子把萝卜戳几个洞，放入剩油中炸，残渣会附着在萝卜片上，取出清除残渣，再反复放入锅中炸，混浊的油可变清澈69、当锅内温度达到最高时加入料酒，易使酒蒸发而去除食物中的腥味70、熬猪油：在电饭褒内放一点水或植物油，然后放入猪板油或肥肉，接通电源后，能自动将油炼好，不溅油，不糊油渣，油质清纯71、泡菜坛中放十几粒花椒或少许麦芽糖，可防止产生白花]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端使用技巧，切换到其他路径和目录]]></title>
    <url>%2Fposts%2F14a2657.html</url>
    <content type="text"><![CDATA[如果你想将当前 command line 会话切换到其他目录，需要用到三个命令：pwd，ls和cd pwd的含义是“print working directory”，会显示当前目录的绝对路径。 ls的含义是“list directory contents”，它会列出当前目录的内容。这个命令还有其他参数可选。 cd的含义是“change directory”，它会改变当前目录到你指定的目录。如果你不指定，则会返回你的 home folder。 命令 含义 pwd 当前工作目录 cd（不加参数） 进root cd（folder） 进入文件夹 cd .. 上级目录 cd ~ 返回root cd - 返回上一个访问的目录 rm 文件名 删除 cat 文件名 在终端下查看文件 ls 列出目录下所有文件 cp 文件名 目标目录 将文件拷贝到目标目录下 ~代表root 如：~/Document/ZM/ mkdiv 新建文件夹]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio混淆模板及常用第三方混淆]]></title>
    <url>%2Fposts%2F9a4f9efd.html</url>
    <content type="text"><![CDATA[首先要在build.gradle中开启混淆，也就是 minifyEnabled true ，我用的build.gradle具体如下所示： 123456789101112131415161718192021222324252627282930313233def releaseTime() &#123; return new Date().format("yyyy.MM.dd", TimeZone.getTimeZone("UTC"))&#125;android &#123; .... buildTypes &#123; release &#123; // 混淆 minifyEnabled true // Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为appname-1.0-beta1-xxxx-xx-xx.apk def fileName = "app-$&#123;defaultConfig.versionName&#125;-beta1-$&#123;releaseTime()&#125;.apk" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; ....&#125; 上面注释中写到proguard-android.txt文件，这是系统默认的混淆文件，具体在../sdk/tools/proguard/目录下，其中包含了android最基本的混淆，一般不需要改动，我们需要配置的是项目中app下的proguard-rules.pro文件，在此提供一份混淆模板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165############################################### 对于一些基本指令的添加############################################### 代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5 # 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames # 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses # 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose # 指定不去忽略非公共库的类成员-dontskipnonpubliclibraryclassmembers # 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify # 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses # 避免混淆泛型-keepattributes Signature # 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable # 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/* ############################################### Android开发中一些需要保留的公共部分############################################## # 保留我们使用的四大组件，自定义的Application等等这些类不被混淆# 因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService # 保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125; # 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.** # 保留R下面的资源-keep class **.R$* &#123;*;&#125; # 保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; # 保留在Activity中的方法参数是view的方法，# 这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125; # 保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; # 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125; # 保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125; # 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125; # 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event); void *(**On*Listener);&#125; # webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125; # 移除Log类打印各个等级日志的代码，打正式包的时候可以做为禁log使用，这里可以作为禁止log打印的功能使用# 记得proguard-android.txt中一定不要加-dontoptimize才起作用# 另外的一种实现方案是通过BuildConfig.DEBUG的变量来控制#-assumenosideeffects class android.util.Log &#123;# public static int v(...);# public static int i(...);# public static int w(...);# public static int d(...);# public static int e(...);#&#125; ############################################### 项目中特殊处理部分############################################## #-----------处理反射类--------------- #-----------处理js交互--------------- #-----------处理实体类---------------# 在开发的时候我们可以将所有的实体类放在一个包内，这样我们写一次混淆就行了。#-keep public class com.ljd.example.entity.** &#123;# public void set*(***);# public *** get*();# public *** is*();#&#125; #-----------处理第三方依赖库--------- 下面介绍常用第三方混淆配置（已按字母排序，不定期更新）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275# AndroidEventBus-keep class org.simple.** &#123; *; &#125;-keep interface org.simple.** &#123; *; &#125;-keepclassmembers class * &#123; @org.simple.eventbus.Subscriber &lt;methods&gt;;&#125;# 百度地图（jar包换成自己的版本，记得签名要匹配）-libraryjars libs/baidumapapi_v2_1_3.jar-keep class com.baidu.** &#123;*;&#125;-keep class vi.com.** &#123;*;&#125;-keep class com.sinovoice.** &#123;*;&#125;-keep class pvi.com.** &#123;*;&#125;-dontwarn com.baidu.**-dontwarn vi.com.**-dontwarn pvi.com.**# Bugly-dontwarn com.tencent.bugly.**-keep class com.tencent.bugly.** &#123;*;&#125;# ButterKnife-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125; -keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;# EventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Facebook-keep class com.facebook.** &#123;*;&#125;-keep interface com.facebook.** &#123;*;&#125;-keep enum com.facebook.** &#123;*;&#125;# FastJson-dontwarn com.alibaba.fastjson.**-keep class com.alibaba.fastjson.** &#123; *; &#125;-keepattributes Signature-keepattributes *Annotation*# Fresco-keep class com.facebook.fresco.** &#123;*;&#125;-keep interface com.facebook.fresco.** &#123;*;&#125;-keep enum com.facebook.fresco.** &#123;*;&#125;# 高德相关依赖# 集合包:3D地图3.3.2 导航1.8.0 定位2.5.0-dontwarn com.amap.api.**-dontwarn com.autonavi.**-keep class com.amap.api.**&#123;*;&#125;-keep class com.autonavi.**&#123;*;&#125;# 地图服务-dontwarn com.amap.api.services.**-keep class com.map.api.services.** &#123;*;&#125;# 3D地图-dontwarn com.amap.api.mapcore.**-dontwarn com.amap.api.maps.**-dontwarn com.autonavi.amap.mapcore.**-keep class com.amap.api.mapcore.**&#123;*;&#125;-keep class com.amap.api.maps.**&#123;*;&#125;-keep class com.autonavi.amap.mapcore.**&#123;*;&#125;# 定位-dontwarn com.amap.api.location.**-dontwarn com.aps.**-keep class com.amap.api.location.**&#123;*;&#125;-keep class com.aps.**&#123;*;&#125;# 导航-dontwarn com.amap.api.navi.**-dontwarn com.autonavi.**-keep class com.amap.api.navi.** &#123;*;&#125;-keep class com.autonavi.** &#123;*;&#125;# Glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;# Gson-keepattributes Signature-keepattributes *Annotation*-keep class sun.misc.Unsafe &#123; *; &#125;-keep class com.google.gson.stream.** &#123; *; &#125;# 使用Gson时需要配置Gson的解析对象及变量都不混淆。不然Gson会找不到变量。# 将下面替换成自己的实体类-keep class com.example.bean.** &#123; *; &#125;# Jackson-dontwarn org.codehaus.jackson.**-dontwarn com.fasterxml.jackson.databind.**-keep class org.codehaus.jackson.** &#123; *;&#125;-keep class com.fasterxml.jackson.** &#123; *; &#125;# 极光推送-dontoptimize-dontpreverify-dontwarn cn.jpush.**-keep class cn.jpush.** &#123; *; &#125;# OkHttp-keep class com.squareup.okhttp.** &#123; *; &#125;-keep interface com.squareup.okhttp.** &#123; *; &#125;-dontwarn com.squareup.okhttp.**# OkHttp3-dontwarn com.squareup.okhttp3.**-keep class com.squareup.okhttp3.** &#123; *;&#125;-dontwarn okio.**# Okio-dontwarn com.squareup.** -dontwarn okio.** -keep public class org.codehaus.* &#123; *; &#125; -keep public class java.nio.* &#123; *; &#125;# OrmLite-keepattributes *DatabaseField* -keepattributes *DatabaseTable* -keepattributes *SerializedName* -keep class com.j256.**-keepclassmembers class com.j256.** &#123; *; &#125;-keep enum com.j256.**-keepclassmembers enum com.j256.** &#123; *; &#125;-keep interface com.j256.**-keepclassmembers interface com.j256.** &#123; *; &#125;# Realm-keep class io.realm.annotations.RealmModule-keep @io.realm.annotations.RealmModule class *-keep class io.realm.internal.Keep-keep @io.realm.internal.Keep class * &#123; *; &#125;-dontwarn javax.**-dontwarn io.realm.**# Retrofit-dontwarn retrofit2.**-keep class retrofit2.** &#123; *; &#125;-keepattributes Signature-keepattributes Exceptions# Retrolambda-dontwarn java.lang.invoke.*# RxJava RxAndroid-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;# Universal-Image-Loader-v1.9.5-libraryjars libs/universal-image-loader-1.9.5-SNAPSHOT-with-sources.jar-dontwarn com.nostra13.universalimageloader.**-keep class com.nostra13.universalimageloader.** &#123; *; &#125;# 微信支付-dontwarn com.tencent.mm.**-dontwarn com.tencent.wxop.stat.**-keep class com.tencent.mm.** &#123;*;&#125;-keep class com.tencent.wxop.stat.**&#123;*;&#125;# 信鸽-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep class com.tencent.android.tpush.** &#123;* ;&#125;-keep class com.tencent.mid.** &#123;* ;&#125;-keepattributes *Annotation*# 新浪微博-keep class com.sina.weibo.sdk.* &#123; *; &#125; -keep class android.support.v4.* &#123; *; &#125; -keep class com.tencent.* &#123; *; &#125; -keep class com.baidu.* &#123; *; &#125; -keep class lombok.ast.ecj.* &#123; *; &#125; -dontwarn android.support.v4.** -dontwarn com.tencent.**s -dontwarn com.baidu.** # 讯飞语音-dontwarn com.iflytek.**-keep class com.iflytek.** &#123;*;&#125;# xUtils3.0-keepattributes Signature,Annotation-keep public class org.xutils.** &#123;public protected *;&#125;-keep public interface org.xutils.** &#123;public protected *;&#125;-keepclassmembers class * extends org.xutils.** &#123;public protected *;&#125;-keepclassmembers @org.xutils.db.annotation.* class * &#123;;&#125;-keepclassmembers @org.xutils.http.annotation. class * &#123;*;&#125;-keepclassmembers class * &#123;@org.xutils.view.annotation.Event ;&#125;# 银联-dontwarn com.unionpay.**-keep class com.unionpay.** &#123; *; &#125;# 友盟统计分析-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keepclassmembers enum com.umeng.analytics.** &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 友盟自动更新-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keep public class cn.irains.parking.cloud.pub.R$*&#123; public static final int *; &#125;-keep public class * extends com.umeng.**-keep class com.umeng.** &#123; *; &#125;# 支付宝钱包-dontwarn com.alipay.**-dontwarn HttpUtils.HttpFetcher-dontwarn com.ta.utdid2.**-dontwarn com.ut.device.**-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125;-keep class com.alipay.mobilesecuritysdk.*-keep class com.ut.*]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的会写单例吗]]></title>
    <url>%2Fposts%2F6bfd7458.html</url>
    <content type="text"><![CDATA[提到单例模式，相信都不会陌生，今天对其进行总结。 以下是单例模式的特点： 单例类只能有一个实例。 单例类必须自己自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 种类的话不好说有几类，因为要考虑到是否在多线程下运行，下面来介绍主要的几类： 懒汉类123456789101112131415//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 懒汉么，所以在多线程下会失效，所以下面介绍三种懒汉的升级版来适应多线程 在getinstance前加上synchronized（同步），但这导致的是每次getInstance都会去同步，消耗资源。 1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; // 静态工厂方法 public static synchronized Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 双重检查锁，它是在以上做的修改，判断两次空，所以只有在第一次调用的时候会同步，避免了每次同步资源的消耗，注意 volatile 关键字。 123456789101112131415161718public class Singleton &#123; private Singleton() &#123; &#125; private volatile static Singleton singleton = null; // 声明成 volatile //静态工厂方法 public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 内部静态类，这种我觉得是最好的，既实现了线程安全，也避免了同步带来的性能影响。 123456789101112public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 饿汉类饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。 123456789101112//饿汉式单例类.在类初始化时，已经自行实例化public class Singleton &#123; private Singleton() &#123; &#125; private static final Singleton single = new Singleton(); //静态工厂方法 public static Singleton getInstance() &#123; return single; &#125;&#125; 这种也是我比较喜欢的，因为简单易懂，但当实现了Serializable接口后，反序列化时单例会被破坏，实现Serializable接口需要重写readResolve，才能保证其反序列化依旧是单例： 123private Object readResolve() throws ObjectStreamException &#123; return single; &#125; 枚举类123456public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。 以上就是常用的单例模式，一般的情况下，我会使用饿汉式，只有在要明确实现lazy loading效果时才会使用内部静态类，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android发送短信的两种方式]]></title>
    <url>%2Fposts%2F9f23975a.html</url>
    <content type="text"><![CDATA[Demo地址：SendSMSDemo SMS涉及的主要类SmsManager实现SMS主要用到SmsManager类，该类继承自java.lang.Object类，下面我们介绍一下该类的主要成员。 公有方法： ArrayList divideMessage(String text)当短信超过SMS消息的最大长度时，将短信分割为几块。参数：text——初始的消息，不能为空返回值：有序的ArrayList，可以重新组合为初始的消息 static SmsManager getDefault()获取SmsManager的默认实例。返回值：SmsManager的默认实例 void SendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data,PendingIntent sentIntent, PendingIntent deliveryIntent)发送一个基于SMS的数据到指定的应用程序端口。参数：1)、destinationAddress——消息的目标地址2)、scAddress——服务中心的地址or为空使用当前默认的SMSC 3)destinationPort——消息的目标端口号4)、data——消息的主体，即消息要发送的数据5)、sentIntent——如果不为空，当消息成功发送或失败这个PendingIntent就广播。结果代码是Activity.RESULT_OK表示成功，或RESULT_ERROR_GENERIC_FAILURE、RESULT_ERROR_RADIO_OFF、RESULT_ERROR_NULL_PDU之一表示错误。对应RESULT_ERROR_GENERIC_FAILURE，sentIntent可能包括额外的“错误代码”包含一个无线电广播技术特定的值，通常只在修复故障时有用。每一个基于SMS的应用程序控制检测sentIntent。如果sentIntent是空，调用者将检测所有未知的应用程序，这将导致在检测的时候发送较小数量的SMS。6)、deliveryIntent——如果不为空，当消息成功传送到接收者这个PendingIntent就广播。异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。 void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList parts,ArrayList sentIntents, ArrayList deliverIntents)发送一个基于SMS的多部分文本，调用者应用已经通过调用divideMessage(String text)将消息分割成正确的大小。参数：1)、destinationAddress——消息的目标地址2)、scAddress——服务中心的地址or为空使用当前默认的SMSC3)、parts——有序的ArrayList，可以重新组合为初始的消息4)、sentIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent5)、deliverIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。 void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent,PendingIntent deliveryIntent)发送一个基于SMS的文本。参数的意义和异常前面的已存在的一样，不再累述。 常量： public static final int RESULT_ERROR_GENERIC_FAILURE 表示普通错误，值为1(0x00000001) public static final int RESULT_ERROR_NO_SERVICE表示服务当前不可用，值为4 (0x00000004) public static final int RESULT_ERROR_NULL_PDU表示没有提供pdu，值为3 (0x00000003) public static final int RESULT_ERROR_RADIO_OFF表示无线广播被明确地关闭，值为2 (0x00000002) public static final int STATUS_ON_ICC_FREE表示自由空间，值为0 (0x00000000) public static final int STATUS_ON_ICC_READ表示接收且已读，值为1 (0x00000001) public static final int STATUS_ON_ICC_SENT表示存储且已发送，值为5 (0x00000005) public static final int STATUS_ON_ICC_UNREAD表示接收但未读，值为3 (0x00000003) public static final int STATUS_ON_ICC_UNSENT表示存储但为发送，值为7 (0x00000007) 第一：调用系统短信接口直接发送短信；主要代码如下： 12345678910111213141516/** * 直接调用短信接口发短信 * * @param phoneNumber * @param message */ public void sendSMS(String phoneNumber, String message) &#123; // 获取短信管理器 android.telephony.SmsManager smsManager = android.telephony.SmsManager .getDefault(); // 拆分短信内容（手机短信长度限制） List&lt;String&gt; divideContents = smsManager.divideMessage(message); for (String text : divideContents) &#123; smsManager.sendTextMessage(phoneNumber, null, text, sentPI,deliverPI); &#125; &#125; 第二：调起系统发短信功能；主要代码如下： 12345678910111213/** * 调起系统发短信功能 * * @param phoneNumber * @param message */ public void doSendSMSTo(String phoneNumber, String message) &#123; if (PhoneNumberUtils.isGlobalPhoneNumber(phoneNumber)) &#123; Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:" + phoneNumber)); intent.putExtra("sms_body", message); startActivity(intent); &#125; &#125; 下面来主要讲解第一种方法，第一种方法可以监控发送状态和对方接收状态使用的比较多。 处理返回的状态代码如下: 1234567891011121314151617181920212223242526272829303132333435363738//处理返回的发送状态 String SENT_SMS_ACTION = "SENT_SMS_ACTION"; Intent sentIntent = new Intent(SENT_SMS_ACTION); sentPI= PendingIntent.getBroadcast(this, 0, sentIntent, 0); // register the Broadcast Receivers this.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context _context, Intent _intent) &#123; switch (getResultCode()) &#123; case Activity.RESULT_OK: Toast.makeText(MainActivity.this, "短信发送成功", Toast.LENGTH_SHORT) .show(); break; case SmsManager.RESULT_ERROR_GENERIC_FAILURE: break; case SmsManager.RESULT_ERROR_RADIO_OFF: break; case SmsManager.RESULT_ERROR_NULL_PDU: break; &#125; &#125; &#125;, new IntentFilter(SENT_SMS_ACTION)); //处理返回的接收状态 String DELIVERED_SMS_ACTION = "DELIVERED_SMS_ACTION"; // create the deilverIntent parameter Intent deliverIntent = new Intent(DELIVERED_SMS_ACTION); deliverPI = PendingIntent.getBroadcast(this, 0,deliverIntent, 0); this.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context _context, Intent _intent) &#123; Toast.makeText(MainActivity.this,"收信人已经成功接收", Toast.LENGTH_SHORT) .show(); &#125; &#125;, new IntentFilter(DELIVERED_SMS_ACTION)); 别忘了权限的问题： 1&lt;uses-permission android:name="android.permission.SEND_SMS" /&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>SMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0～9.0适配]]></title>
    <url>%2Fposts%2Fdd367189.html</url>
    <content type="text"><![CDATA[1.前言 大家还记得Android 6.0权限适配的泪水吗？而现在谷歌已经出了Android P的稳定版，而且谷歌粑粑，为了大家能给辛苦熬夜加班，特地的和个大市场合作，要强制推出9.0的适配，而近期在下不才，为了报着多踩坑的心态，做了一下7.0～9.0的适配，脸颊也是老泪两行 2.安卓6.0的适配2.1 怎么适配 ● 在6.0所有权限都需要申请？ 曰：当然不是。只有属于危险权限的才需要申请。危险权限看下表1-2 ● 那危险权限也很多啊，也要一个个申请？ 曰：当然不是。你看看下面的表，都分好组了（9组），对于同一组内的权限，只要有一个被同意，其他的都会被同意。 ● 谁最帅 曰：当然是子信。 2.2 列举权限的分组 表1-2危险权限分组 分组 名字 分割线 PHONE android.permission.READ_PHONE_STATE android.permission.CALL_PHONE android.permission.READ_CALL_LOG android.permission.ADD_VOICEMAIL android.permission.WRITE_CALL_LOG android.permission.USE_SIP android.permission.PROCESS_OUTGOING_CALLS CALENDAR android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR CAMERA android.permission.CAMERA CONTACTS android.permission.READ_CONTACTS android.permission.WRITE_CONTACTS android.permission.GET_ACCOUNTS LOCATION android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_COARSE_LOCATION MICROPHONE android.permission.RECORD_AUDIO SENSORS android.permission.BODY_SENSORS SMS android.permission.SEND_SMS android.permission.RECEIVE_SMS android.permission.READ_SMS android.permission.RECEIVE_WAP_PUSH android.permission.RECEIVE_MMS STORAGE android.permission.READ_EXTERNAL_STORAGE android.permission.WRITE_EXTERNAL_STORAGE 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 危险权限 start --&gt;&lt;!--PHONE--&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt;&lt;uses-permission android:name="android.permission.READ_CALL_LOG"/&gt;&lt;uses-permission android:name="android.permission.ADD_VOICEMAIL"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CALL_LOG"/&gt;&lt;uses-permission android:name="android.permission.USE_SIP"/&gt;&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;&lt;!--CALENDAR--&gt;&lt;uses-permission android:name="android.permission.READ_CALENDAR"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CALENDAR"/&gt;&lt;!--CAMERA--&gt;&lt;uses-permission android:name="android.permission.CAMERA"/&gt;&lt;!--CONTACTS--&gt;&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CONTACTS"/&gt;&lt;uses-permission android:name="android.permission.GET_ACCOUNTS"/&gt;&lt;!--LOCATION--&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;&lt;!--MICROPHONE--&gt;&lt;uses-permission android:name="android.permission.RECORD_AUDIO"/&gt;&lt;!--SENSORS--&gt;&lt;uses-permission android:name="android.permission.BODY_SENSORS"/&gt;&lt;!--SMS--&gt;&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_SMS"/&gt;&lt;uses-permission android:name="android.permission.READ_SMS"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_WAP_PUSH"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_MMS"/&gt;&lt;!--STORAGE--&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;!-- 危险权限 Permissions end --&gt; 以上是列出9组需要动态申请的权限，建议自己代码统一封装成一个工具类，这里就不细说了， Android6.0权限工具 3.Android 7.0的适配3.1 应用间共享文件 在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 Android 7.0 行为变更 通过FileProvider在应用间共享文件这篇文章 3.2 APK signature scheme v2 Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。 1）只勾选v1签名就是传统方案签署，但是在7.0上不会使用V2安全的验证方式。 2）只勾选V2签名7.0以下会显示未安装，7.0上则会使用了V2安全的验证方式。 3）同时勾选V1和V2则所有版本都没问题。 3.3 org.apache不支持问题 1234// build.gradle里面加上这句话defaultConfig &#123; useLibrary 'org.apache.http.legacy' &#125; 3.3 SharedPreferences闪退 12SharedPreferences read = getSharedPreferences(RELEASE_POOL_DATA, MODE_WORLD_READABLE);//MODE_WORLD_READABLE ：7.0以后不能使用这个获取，会闪退，修改成MODE_PRIVATE 4.Android 8.0的适配4.1 安卓8.0中PHONE权限组新增两个权限 12ANSWER_PHONE_CALLS：允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 acceptRingingCall() 函数。READ_PHONE_NUMBERS ：权限允许您的应用读取设备中存储的电话号码。 4.2 通知适配 安卓8.0中，为了更好的管制通知的提醒，不想一些不重要的通知打扰用户，新增了通知渠道，用户可以根据渠道来屏蔽一些不想要的通知 兼容的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 安卓8。0通知的兼容类哦， * NotifyCompatYc yc : 是雨辰的简写，谢谢哦，嘿嘿 ----高贵的子信 */public class NotifyCompatYc &#123; public static final String QFMD_CHANNEL_ID = "com.oms.mingdeng"; public static final String QFMD_CHANNEL_NAME = "祈福明燈"; public static final String LJMS_DEFAULT_CHANNEL_NAME = "靈機妙算"; public static final String LJMS_CHANNEL_ID = "com.oms.mmcnotity"; public static final String XYS_CHANNEL_ID = "com.oms.xuyuanshu"; public static final String XYS_CHANNEL_NAME = "許願樹"; public static void setONotifyChannel(NotificationManager manager, NotificationCompat.Builder builder, String channeId, String channelName) &#123; if (TextUtils.isEmpty(channeId)||TextUtils.isEmpty(channelName))&#123; L.e("NotifyCompatYc: ".concat("安卓8.0的通知兼容库中 channeId 与 channelName 不能为empty")); &#125; if (Build.VERSION.SDK_INT &gt;= 26) &#123; //第三个参数设置通知的优先级别 NotificationChannel channel = new NotificationChannel(channeId, channelName, NotificationManager.IMPORTANCE_DEFAULT); channel.canBypassDnd();//是否可以绕过请勿打扰模式 channel.canShowBadge();//是否可以显示icon角标 channel.enableLights(true);//是否显示通知闪灯 channel.enableVibration(true);//收到小时时震动提示 channel.setBypassDnd(true);//设置绕过免打扰 channel.setLockscreenVisibility(NotificationCompat.VISIBILITY_SECRET); channel.setLightColor(Color.RED);//设置闪光灯颜色 channel.getAudioAttributes();//获取设置铃声设置 channel.setVibrationPattern(new long[]&#123;100, 200, 100&#125;);//设置震动模式 channel.shouldShowLights();//是否会闪光 if (manager != null) &#123; manager.createNotificationChannel(channel); &#125; if (builder != null) &#123; builder.setChannelId(channeId);//这个id参数要与上面channel构建的第一个参数对应 &#125; &#125; &#125; public static void setONotifyChannel(NotificationManager manager, String channeId, String channelName) &#123; setONotifyChannel(manager,null,channeId,channelName); &#125; public static Notification getNotification(Context context, String channelId) &#123; NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(context, channelId); Notification notification = notificationBuilder.setOngoing(true) .setSmallIcon(R.drawable.ic_launcher) .setPriority(NotificationManager.IMPORTANCE_MIN) .setCategory(Notification.CATEGORY_SERVICE) .build(); return notification; &#125;&#125;复制代码public class NotifyManager &#123; // 单例开始 private volatile static NotifyManager INSTANCE; private NotifyManager(Context context) &#123; initNotifyManager(context); &#125; public static NotifyManager getInstance(Context context) &#123; if (INSTANCE == null) &#123; synchronized (NotifyManager.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new NotifyManager(context); &#125; &#125; &#125; return INSTANCE; &#125; // 单例结束 private NotificationManager manager; // NotificationManagerCompat private NotificationCompat.Builder builder; //初始化通知栏配置 private void initNotifyManager(Context context) &#123; context = context.getApplicationContext(); manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); // 如果存在则清除上一个消息// manager.cancel(news_flag); builder = new NotificationCompat.Builder(context,NotifyCompatYc.QFMD_CHANNEL_ID); NotifyCompatYc.setONotifyChannel(manager,builder,NotifyCompatYc.QFMD_CHANNEL_ID,NotifyCompatYc.QFMD_CHANNEL_NAME); // 设置标题 builder.setContentTitle(context.getResources().getString(R.string.qfmd_notify_title1)); // 状态栏的动画提醒语句 builder.setTicker(context.getResources().getString(R.string.qfmd_notify_ticker)); // 什么时候提醒的 builder.setWhen(System.currentTimeMillis()); // 设置通知栏的优先级 builder.setPriority(Notification.PRIORITY_DEFAULT); // 设置点击可消失 builder.setAutoCancel(true); // 设置是否震动等 builder.setDefaults(Notification.DEFAULT_VIBRATE); // 设置icon builder.setSmallIcon(R.drawable.lingji_icon); // 设置点击意图 Intent intent = new Intent(context, GongdenggeActivity.class); Bundle bundle = new Bundle(); bundle.putBoolean(Contants.INTENT_GOTO_MYLMAP, true); intent.putExtras(bundle); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pendingIntent = PendingIntent.getActivity(context, 230, intent, PendingIntent.FLAG_UPDATE_CURRENT); builder.setContentIntent(pendingIntent); &#125; /** * 显示祈福明灯过期通知 */ public void showQiFuLampOutOfDateNotify(Context context) &#123; // 设置内容 builder.setContentText(context.getResources().getString(R.string.qfmd_notify_content1)); manager.notify(13251, builder.build()); &#125; public void showQiFuLampBlessNotify(Context context) &#123; builder.setContentText(context.getResources().getString(R.string.qfmd_notify_content2)); manager.notify(13255, builder.build()); &#125;&#125; 4.3 安装APK 首先在AndroidManifest文件中添加安装未知来源应用的权限: 1&lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/&gt; 这样系统会自动询问用户完成授权。当然你也可以先使用 canRequestPackageInstalls()查询是否有此权限，如果没有的话使用Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES这个action将用户引导至安装未知应用权限界面去授权。 12345678910111213141516171819202122232425262728private static final int REQUEST_CODE_UNKNOWN_APP = 100; private void installAPK()&#123; if (Build.VERSION.SDK_INT &gt;= 26) &#123; boolean hasInstallPermission = getPackageManager().canRequestPackageInstalls(); if (hasInstallPermission) &#123; //安装应用 &#125; else &#123; //跳转至“安装未知应用”权限界面，引导用户开启权限 Uri selfPackageUri = Uri.parse("package:" + this.getPackageName()); Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri); startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP); &#125; &#125;else &#123; //安装应用 &#125; &#125; //接收“安装未知应用”权限的开启结果 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123; installAPK(); &#125; &#125; 4.4 SecurityException的闪退 问题原因：项目使用了ActiveAndroid，在 8.0 或 8.1 系统上使用 26 或以上的版本的 SDK 时，调用 ContentResolver 的 notifyChange 方法通知数据更新，或者调用 ContentResolver 的 registerContentObserver 方法监听数据变化时，会出现上述异常。 解决方案： （1）在清单文件配置 1234567&lt;provider android:name=&quot;com.activeandroid.content.ContentProvider&quot; android:authorities=&quot;com.ylmf.androidclient&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;&gt;&lt;/provider&gt;复制代码 （2）去掉这个监听刷新的方法，改为广播刷新 4.5 静态广播无法正常接收 问题原因： Android 8.0 引入了新的广播接收器限制，因此您应该移除所有为隐式广播 Intent 注册的广播接收器 解决方案： 使用动态广播代替静态广播 4.6 Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation 123456问题原因： Android 8.0 非全屏透明页面不允许设置方向（后面8.1系统谷歌就去掉了这个限制，可能很多人真的不习惯吧）解决方案： （1）android:windowIsTranslucent设置为false (2)如果还是想用的话，就去掉清单文件中Activity中的android:screenOrientation=&quot;portrait&quot;， （3）就是使用透明的dialog或者PopupWindow来代替，也可以用DialogFragment，看自己的需求和喜好. Android 9.0的适配9.1 CLEARTEXT communication to life.115.com not permitted by network security policy 问题原因： Android P 限制了明文流量的网络请求，非加密的流量请求都会被系统禁止掉 解决方案： 在资源文件新建xml目录，新建文件 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 清单文件配置： 1234567&lt;application android:networkSecurityConfig="@xml/network_security_config"&gt; &lt;!--9.0加的，哦哦--&gt; &lt;uses-library android:name="org.apache.http.legacy" android:required="false" /&gt; &lt;/application&gt; 但还是建议都使用https进行传输 9.2 其他Api的修改 java.lang.IllegalArgumentException: Invalid Region.Op - only INTERSECT and DIFFERENCE are allowed 12345if (Build.VERSION.SDK_INT &gt;= 26) &#123; canvas.clipPath(mPath); &#125; else &#123; canvas.clipPath(mPath, Region.Op.REPLACE); &#125; 总结 经过几天的踩坑，终于把targetSdkVersion升级到28，对于以上的经验，也许还存在某些疏漏的，也希望大家可以指正，补充，告诉，希望对你有一定的帮助，鄙人也很开心。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>适配</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端-iTerm2使用]]></title>
    <url>%2Fposts%2Fe6bc65de.html</url>
    <content type="text"><![CDATA[iTerm2 https://www.zhihu.com/question/27447370 https://medium.com/ayuth/iterm2-zsh-oh-my-zsh-the-most-power-full-of-terminal-on-macos-bdb2823fb04c https://jeremysu0131.github.io/Tool-Mac-iTerm-2-Oh-My-Zsh-Powerlevel9k-設定/ 智能选中双击选中、三击选中整行、四击智能选中（智能规则可配置），选中即复制 巧用 ⌘ 键按住 ⌘ 键 可以拖拽选中的字符串； 点击 url：调用默认浏览器访问该网址； 点击文件：调用默认程序打开文件； 如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行； 点击文件夹：在 finder 中打开该文件夹； 同时按住⌥键，可以以矩形选中，类似于 vim 中的⌃ v操作。 快捷键标签新建标签：⌘ + t 关闭标签：⌘ + w 切换标签：⌘ + 数字 ⌘ + 左右方向键 切换全屏：⌘ + enter 查找：⌘ + f 分屏垂直分屏：⌘ + d 水平分屏：⌘ + ⇧ + d 切换屏幕：⌘ + ⌥ + 方向键⌘ + [ 或 ⌘ + ] 查看历史命令：⌘ + ; 查看剪贴板历史：⌘ + ⇧ + h 其他清除当前行：⌃ + u 到行首：⌃ + a 到行尾：⌃ + e 前进后退：⌃ + f/b (相当于左右方向键) 上一条命令：⌃ + p 搜索命令历史：⌃ + r 删除当前光标的字符：⌃ + d 删除光标之前的字符：⌃ + h 删除光标之前的单词：⌃ + w 删除到文本末尾：⌃ + k 交换光标处文本：⌃ + t 清屏 1：⌘ + r 清屏 2：⌃ + l 时间线：⌘ + ⇧ + e 自带有哪些很实用的功能/快捷键⌘ + 数字 在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 /⌘ + ⇧ + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ⌃ + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + ⇧ + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 常用的一些快捷键⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 1⌘←` / `⌘→` 到一行命令最左边/最右边 ，这个功能同 `C+a` / `C+e ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在 Iterm 中已经预定义好了，⌥f / ⌥b，看个人习惯了 好像就这几个 设置方法如下 当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但 iterm 中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的自负 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 标记跳转 类似编辑器的 mark 工具，iTerm2 也可以在命令行位置设置标记 设置标记：⌘ + ⇧ + m 跳转到上个标记：⌘ + ⇧ + j 多个标记切换：⌘ + ⇧ + 方向键 选中即复制iterm2 有 2 种好用的选中即复制模式。 一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自 动复制了。另一种是无鼠标模式，⌘+f,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 tab，查找窗口将自动变化内容，并将其复制。如果输入的是 ⇧+tab，则自动将查找内容的左边选中并复制。 自动完成输入打头几个字母，然后输入 ⌘+; iterm2 将自动列出之前输入过的类似命令。 剪切历史输入 ⌘+⇧+h，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 Preferences &gt; General &gt; Save copy/paste history to disk 中设置。 及时回放 某个交互命令会覆写屏幕上的输入，之前的历史信息可能会被覆盖掉，无法查看，iterm2 这个及时回放功能，会记录历史输入，输出，有点类似视频录制。 进入回放：⌘ + opt + b 方向键控制时间 ：arrow 退出回放：esc oh-my-zsh https://www.zhihu.com/question/29977255 智能补全cd ~/ 切换目录，敲击两下tab，会列出当前目录下的所有目录，并且可以使用键盘上下左右键来选择要进入的目录。 命令选项补齐，比如输入 docker，然后按 tab，即可显示出 docker 都有哪些命令选项。 智能切换目录进入一个很深的目录，例如 /var/log/nginx/error/lastyear/may/first/monday, 用 zsh 可以这样输入 cd /v/l/n/e/l/m/f/m 然后按 tab 即可补全整个路径。或者你实现知道当前目录名称，可以直接输入目录，即可进去目录。 在 zsh 下可以记录最近进过的 10 个目录，只需要输入d，然后就可以看到对应的 0-9 的目录，输入cd -数字即可进入对应的目录。 或者直接输入 cd - 然后 tab，会列出最近使用过的 31 个目录。 配置需要的时候把 iterm2 呼出来,不需要的时候自动隐藏iTerm2 &gt; Preferences &gt; Keys，左侧 Hotkey 选项 勾选 Show/hide iTerm2 with a system-wide hotkey，设置快捷键 复用上个会话的目录1iTerm2 &gt; Preferences &gt; Profiles &gt; Working Directory &gt; Reuse previous session’s directory 别名1alias zsh-config=&apos;vim ~/.zshrc&apos; 终端下命令行下用 Sublime、vscode、atom 打开文件夹或目录vscode 命令行调用VS Code 提供了一个 code 命令，用来在 shell 环境下调用编辑器。使用快捷键 ⇧⌘P（或 F1） 唤起命令面板，输入以下命令即可完成安装。 code 命令后可接多个路径或文件： 1code pro6.js pro6.scss ../ 文件对比： 1code -d new-file.js old-file.js 打开文件并跳至指定行： 1code -g source/cn/static/global/tracker.js:15 更多 code 命令行使用方法，参见《Additional Command line arguments》。 手动添加 打开终端，随便一个目录输入 1cd 检查是否有.zshrc文件 1ls -al 1) 添加启动命令 1sudo nano .zshrc 在文件末尾加上别名： alias atom=&apos;/Applications/Atom.app/Contents/MacOS/Atom&apos;alias subl=&apos;/Applications/SublimeText.app/Contents/SharedSupport/bin/subl&apos;alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos; `⌘ + X` 再输入 `y` 保存，重启 iterm2。 查找 APP 路径： vim配色终端输入vim ~/.vimrc，设置内容如下， 123syntax onset numberset ruler powerlevel9k主题 配置项Stylizing Your Prompt 其他人的配置Show Off Your Config 我的配置123456789101112131415161718export DEFAULT_USER=&quot;Leo&quot;export TERM=&quot;xterm-256color&quot;ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;# 调整字体模式POWERLEVEL9K_MODE=&apos;nerdfont-complete&apos;# 左侧提示符显示内容:系统时间(time)、root权限指示(root_indicator)、username and host(context)、当前工作目录(dir)、目录写入权限(dir_writable)、git信息(vcs)POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(time root_indicator dir dir_writable vcs)# 右侧提示符显示内容:上一命令执行状态(status)、后台任务个数(background_jobs)、上一命令执行时间(command_execution_time)、可用RAM(ram)、系统的负载均值(load)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs command_execution_time ram load)# context也就是你的用户名以及终端名称，默认是 `%n@%m`。POWERLEVEL9K_CONTEXT_TEMPLATE=&quot;Leo&quot;# 低于这个值的命令执行时间不显示，0 也就是命令执行时间多长都显示POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=&quot;0&quot;# 时间格式化POWERLEVEL9K_TIME_FORMAT=&quot;%D&#123;%H:%M&#125;&quot;# 显示分支版本POWERLEVEL9K_SHOW_CHANGESET=true 如果图标显示不出来可以进入 iTerm 的设置 &gt; Profiles &gt; Text &gt; Change Font &gt; 选择 Hack Nerd Font 字体 Regular 大小 18pt，完成后重新启动 iTerm ，设置完成。 插件 打开配置文件：~/.zshrc autojump：快速切换目录 zsh-syntax-highlighting：zsh 可用命令高亮 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting zsh-autosuggestions：命令自动提示 1git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 1plugins=(brew git node npm osx autojump zsh-autosuggestions zsh-syntax-highlighting)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感恩节的简介和习俗]]></title>
    <url>%2Fposts%2F3b06da8c.html</url>
    <content type="text"><![CDATA[感恩节的简介每年11月的第四个星期四是感恩节。感恩节是美国人民独创的—个古老节日，也是美国人合家欢聚的节日，因此美国人提起感恩节总是倍感亲切。 感恩节的由来，要一直追溯到美国历史的发端。1620年9月，著名的“五月花”号船，满载不堪忍受英国国内迫害的清教徒102人离港启航。在漫无边际的大洋中，漂泊了整整65天，经历了狂风巨浪的种种折磨，方才在马萨诸塞州科德角顶的普洛文斯敦港靠岸。接着，“五月花”号按计划继续南行，打算在弗吉尼亚的詹姆斯敦靠岸，但因航行误差，他们来到了普利茅斯附近。在那里，由于对地形和环境茫无所知，他们十分谨慎地让大部分人仍然留在船上，只派一批精明强干的人出外探测地形。1个月后，他们终于发现了普利茅斯港口，并且意外地在这里找到了一个优良的渔港。这里有几块已经收获过的玉米田，有清亮的淡水小溪，还有十分宜于筑垒设防的山丘，但空无一人。原来这里是一个印第安人的村落、不久前天花流行。夺去了全体村民的生命。几天后，“五月花”号就渡过科德角湾，在普利茅斯港抛锚上岸。这里成为英国移民在美洲的第二块永久居留地。后来他们把登岸的一块大礁石命名为普利茅斯石。​到了1620年和1621年之交的冬天，他们遇到了难以想象的困难。在寒冷无比的冬季，他们自己搭盖的简陋房屋难以抵御风雪，粮食也不足，再加上繁重的劳动和传染病的侵袭，待到冬天结束，活下来的移民只有50来人了。​开春时节，普利茅斯村的移民结识了一位名叫斯·昆图的印第安人。斯·昆图对移民们十分友好。不久，他把自己部落的酋长马萨索德介绍给移民。心地善良的印第安人热情地欢迎远道而来的客人，马萨索德不仅给移民带来礼物，还特地派本部落的人教会移民们怎样狩猎、捕鱼和种植玉米、南瓜、蚕豆。在印第安人的帮助下，移民们终于获得了丰收。​移民们在欢庆丰收的日子里，按照传统习俗，规定了感谢上帝的日子，并决定为感谢印第安朋友的真诚帮助，邀请他们一同来欢庆节日。印第安人欣然接受了邀请，并且提前送来了5只鹿，表示他们的友好情谊。这就是感恩节的由来。 感恩节的习俗集体庆祝初时感恩节没有固定日期，由各州临时决定，直到美国独立后，感恩节才成为全国性的节日。 每逢感恩节这一天，美国举国上下热闹非常，基督徒按照习俗前往教堂做感恩祈祷，城市乡镇到处都有化装游行、戏剧表演或体育比赛等。分别了一年的亲人们也会从天南海北归来，一家人团圆，品尝以“火鸡”为主的感恩节美食。 ​美国当地最著名的庆典则是从1924年开始的梅西百货感恩节游行（Macy’s Thanksgiving Day Parade）。 每逢感恩节这一天，美国举国上下热闹非凡，人们按照习俗前往教堂做感恩祈祷，城乡市镇到处举行化装游行、戏剧表演和体育比赛等，学校和商店也都按规定放假休息。孩子们还模仿当年印第安人的模样穿上离奇古怪的服装，画上脸谱或戴上面具到街上唱歌、吹喇叭。散居在他乡外地的家人也会回家过节，一家人团团围坐在一起，大嚼美味火鸡，并且对家人说：“谢谢！”。感恩节后，学校会让同学们画一张感恩节的画，大部分学生都画的是火鸡。 同时，好客的美国人也忘不掉这一天邀请好友、单身汉或远离家乡的人共度佳节。从18世纪起，美国就开始出现一种给贫穷人家送一篮子食物的风俗。当时有一群年轻妇女想在一年中选一天专门做善事，认为选定感恩节是最恰当不过的。所以感恩节一到，她们就装上满满一篮食物亲自送到穷人家。这件事远近传闻，不久就有许多人学着她们的样子做起来。不管遇到谁，他们都会说：“Thank you！” 节日购物感恩节购物已经成为了美国人的习俗。从感恩节到圣诞节这一个月，美国零售业奥巴马特赦火鸡“勇气”。​总销售额能占到全年的1/3强，是各个商家传统的打折促销旺季。疯狂的购物月从感恩节的次日（星期五）开始，这一天即被称为Black Friday（黑色星期五）。之所以叫这个名字，据说是因为周五这天一大早，所有人都要摸着黑冲到商场排队买便宜货，这种行为有个非常形象的说法，叫Early Bird（早起的鸟儿）[4]。在外国“感恩节”和中国的春节一样重要！ 每年一度的总统放生火鸡仪式始于1947年杜鲁门总统当政时期，但实际上这个传统仪式可以追溯到美国内战林肯总统当政的时期。1863年的一天，林肯的儿子泰德突然闯入内阁会议请求赦免一只名叫杰克的宠物火鸡，因为这只被送进白宫的火鸡，即将成为人们的感恩节大餐。 ​2006年11月22日，布什在白宫玫瑰花园举行感恩节放生仪式上，特赦了一只名布什特赦“飞鸟”火鸡叫“飞鸟”的火鸡。 美国总统奥巴马25号特赦感恩节火鸡．并将火鸡被命名为“勇气”。这也是他上任以来，首次特赦火鸡．奥巴马并对保护美国人民身家安全的英勇战士表示感恩。 每年11月的第4个星期四是美国感恩节。在女儿萨莎和玛丽亚的陪伴下，奥巴马特赦了本来要用做盘中餐的火鸡．奥巴马说，我原本打算吃掉这只火鸡。由于萨莎和玛丽亚的干预，我赦免了“勇气”。这只火鸡将被送到迪士尼乐园。为防止意外，当局还准备了一只备用火鸡，名叫“卡罗琳娜”。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webview常见问题汇总]]></title>
    <url>%2Fposts%2F8c79d027.html</url>
    <content type="text"><![CDATA[前言 通常我们在自己开发的 APP 中打开网页无非两种方法： 一是跳转到系统自带的浏览器，二是使用 WebView 控件加载页面。使用 WebView 控件的好处就是可以通过各种 api 接口来定制各种行为，常用的几个设置地方为 WebSettings、JavaScriptInterface、WebViewClient 和WebChromeClient。平时出现的问题都可以通过修改这些设置来解决。 问题总结1、使用了 WebView 还是跳转到了系统自带的浏览器？ 很简单的解决方法，为你的 webview 设置一个新的 WebViewClient。 1234567webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125;&#125;); 12// 或者直接添加，效果是一样的webView.setWebViewClient(new WebViewClient()); 2、获取网页的标题和图标 通过 WebChromeClient 可以获取到这些信息。 1234567891011121314webView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onReceivedTitle(WebView view, String title) &#123; super.onReceivedTitle(view, title); setTitle(title); &#125; @Override public void onReceivedIcon(WebView view, Bitmap icon) &#123; super.onReceivedIcon(view, icon); setIcon(icon); &#125;&#125;); 但是，这里有个问题，当通过 webView.goBack() 方式返回上一级Web页面的时候不会触发这个方法，因此会导致标题无法跟随历史记录返回上一级页面。所以需要在 onPageFinished() 中对界面标题重新设置。 1234567webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); setTitle(String.valueOf(view.getTitle())); &#125;&#125;); 3、返回键实现网页的后退键 在 WebView 中可以通过 goBack() 方法后退到历史记录的上一项。 12345678// 在 Actvity 中监听返回键按钮 @Override public void onBackPressed() &#123; if (webView.canGoBack()) webView.goBack(); else super.onBackPressed(); &#125; 4、设置 WebView 的 header 在 WebView 的 loadUrl() 方法中传入 Header 参数即可。 1234567public void loadURLWithHTTPHeaders() &#123; final String url = "http://cpacm.net"; WebView webView = new WebView(getActivity()); Map&lt;String,String&gt; extraHeaders = new HashMap&lt;String, String&gt;(); extraHeaders.put("Referer", "http://www.google.com"); webView.loadUrl(url, extraHeaders);&#125; 5、设置 WebView 的 User-Agent 不要试图在 Header 里面去修改，而是在 WebSettings 修改 1webView.getSettings().setUserAgentString("Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0"); 6、如何设置 WebView 的缓存 当需要本地缓存网页的时候就需要打开 WebViewSettings 的缓存开关,这样子当下次进到该页面无网络的情况下也能打开页面。 123456789WebSettings settings = webView.getSettings();settings.setAppCacheEnabled(true); //启用应用缓存settings.setDomStorageEnabled(true); //启用或禁用DOM缓存。settings.setDatabaseEnabled(true); //启用或禁用DOM缓存。if (SystemUtil.isNetworkConnected()) &#123; //判断是否联网 settings.setCacheMode(WebSettings.LOAD_DEFAULT); //默认的缓存使用模式&#125; else &#123; settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY); //不从网络加载数据，只从缓存加载数据。&#125; 7、无法下载文件？ 在自己写的 WebView 下是无法直接下载文件，需要自己监听下载事件并对下载的动作进行处理。 12345678910111213/*** 当下载文件时打开系统自带的浏览器进行下载，当然也可以对捕获到的 url 进行处理在应用内下载。**/webView.setDownloadListener(new FileDownLoadListener());private class FileDownLoadListener implements DownloadListener &#123; @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123; Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); &#125;&#125; 8、无法打开文件选择器？ 通过重写 WebChromeClient 来实现点击 来打开系统文件选择器。 一个完整的Activity示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class MainActivity extends AppCompatActivity &#123; /** Android 5.0以下版本的文件选择回调 */ protected ValueCallback&lt;Uri&gt; mFileUploadCallbackFirst; /** Android 5.0及以上版本的文件选择回调 */ protected ValueCallback&lt;Uri[]&gt; mFileUploadCallbackSecond; protected static final int REQUEST_CODE_FILE_PICKER = 51426; protected String mUploadableFileTypes = "image/*"; private WebView mWebView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initWebView(); &#125; private void initWebView() &#123; mWebView = (WebView) findViewById(R.id.my_webview); mWebView.loadUrl("file:///android_asset/index.html"); mWebView.setWebChromeClient(new OpenFileChromeClient()); &#125; private class OpenFileChromeClient extends WebChromeClient &#123; // Android 2.2 (API level 8)到Android 2.3 (API level 10)版本选择文件时会触发该隐藏方法 @SuppressWarnings("unused") public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; openFileChooser(uploadMsg, null); &#125; // Android 3.0 (API level 11)到 Android 4.0 (API level 15))版本选择文件时会触发，该方法为隐藏方法 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; openFileChooser(uploadMsg, acceptType, null); &#125; // Android 4.1 (API level 16) -- Android 4.3 (API level 18)版本选择文件时会触发，该方法为隐藏方法 @SuppressWarnings("unused") public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; openFileInput(uploadMsg, null, false); &#125; // Android 5.0 (API level 21)以上版本会触发该方法，该方法为公开方法 @SuppressWarnings("all") public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) &#123; if (Build.VERSION.SDK_INT &gt;= 21) &#123; final boolean allowMultiple = fileChooserParams.getMode() == FileChooserParams.MODE_OPEN_MULTIPLE;//是否支持多选 openFileInput(null, filePathCallback, allowMultiple); return true; &#125; else &#123; return false; &#125; &#125; &#125; @SuppressLint("NewApi") protected void openFileInput(final ValueCallback&lt;Uri&gt; fileUploadCallbackFirst, final ValueCallback&lt;Uri[]&gt; fileUploadCallbackSecond, final boolean allowMultiple) &#123; //Android 5.0以下版本 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(null); &#125; mFileUploadCallbackFirst = fileUploadCallbackFirst; //Android 5.0及以上版本 if (mFileUploadCallbackSecond != null) &#123; mFileUploadCallbackSecond.onReceiveValue(null); &#125; mFileUploadCallbackSecond = fileUploadCallbackSecond; Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); if (allowMultiple) &#123; if (Build.VERSION.SDK_INT &gt;= 18) &#123; i.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true); &#125; &#125; i.setType(mUploadableFileTypes); startActivityForResult(Intent.createChooser(i, "选择文件"), REQUEST_CODE_FILE_PICKER); &#125; public void onActivityResult(final int requestCode, final int resultCode, final Intent intent) &#123; if (requestCode == REQUEST_CODE_FILE_PICKER) &#123; if (resultCode == Activity.RESULT_OK) &#123; if (intent != null) &#123; //Android 5.0以下版本 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(intent.getData()); mFileUploadCallbackFirst = null; &#125; else if (mFileUploadCallbackSecond != null) &#123;//Android 5.0及以上版本 Uri[] dataUris = null; try &#123; if (intent.getDataString() != null) &#123; dataUris = new Uri[] &#123; Uri.parse(intent.getDataString()) &#125;; &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= 16) &#123; if (intent.getClipData() != null) &#123; final int numSelectedFiles = intent.getClipData().getItemCount(); dataUris = new Uri[numSelectedFiles]; for (int i = 0; i &lt; numSelectedFiles; i++) &#123; dataUris[i] = intent.getClipData().getItemAt(i).getUri(); &#125; &#125; &#125; &#125; &#125; catch (Exception ignored) &#123; &#125; mFileUploadCallbackSecond.onReceiveValue(dataUris); mFileUploadCallbackSecond = null; &#125; &#125; &#125; else &#123; //这里mFileUploadCallbackFirst跟mFileUploadCallbackSecond在不同系统版本下分别持有了 //WebView对象，在用户取消文件选择器的情况下，需给onReceiveValue传null返回值 //否则WebView在未收到返回值的情况下，无法进行任何操作，文件选择器会失效 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(null); mFileUploadCallbackFirst = null; &#125; else if (mFileUploadCallbackSecond != null) &#123; mFileUploadCallbackSecond.onReceiveValue(null); mFileUploadCallbackSecond = null; &#125; &#125; &#125; &#125;&#125; 9、怎么为 WebView 的加载添加进度条 这里的 onPageFinished() 有个问题，不能在这里监听页面是否加载完毕（我自己测试的时候，好像在重定向和加载完 iframes 时都会调用这个方法）。 把页面加载完毕的判断放在 onProgressChanged() 里可能会更为准确。 12345678910111213141516171819webView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onProgressChanged(WebView view, int position) &#123; progressBar.setProgress(position); if (position == 100) &#123; progressBar.setVisibility(View.GONE); &#125; super.onProgressChanged(view, position); &#125;&#125;);webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; progressBar.setVisibility(View.VISIBLE); super.onPageStarted(view, url, favicon); &#125;&#125;); 10、怎样对页面进行 Js 注入？ 首先你要在 WebView 开启 JavaScript,然后搭建桥梁 1234567891011WebSettings webSettings = webView.getSettings();webSettings.setJavaScriptEnabled(true);webView.addJavascriptInterface(new WebAppBridge(new WebAppBridge.OauthLoginImpl() &#123; @Override public void getResult(String s) &#123; //TODO &#125; &#125;), "oauth");webView.loadUrl("javascript:" + getAssetsJs("autologin.js"));webView.loadUrl("javascript:adduplistener()"); WebAppBridge的代码 123456789101112131415161718public class WebAppBridge &#123; private OauthLoginImpl oauthLogin; public WebAppBridge(OauthLoginImpl oauthLogin) &#123; this.oauthLogin = oauthLogin; &#125; @JavascriptInterface public void getResult(String str) &#123; if (oauthLogin != null) oauthLogin.getResult(str); &#125; public interface OauthLoginImpl &#123; void getResult(String s); &#125;&#125; 简单的说就是向网页注入一段 js, 在这段 js 里面设置回调到java中的方法 getResult()，由 WebAppBridge.getResult 来回收。其中js的核心代码为: 1oauth.getResult(str); 其中 oauth 这个名称要与 webView.addJavascriptInterface()方法的第二个参数一样。 具体的代码可以参考这个项目中写的 js 注入逻辑 OauthDialog地址：https://github.com/cpacm/MoeMusic/blob/master/app/src/main/java/com/cpacm/moemusic/ui/widgets/dialogs/OauthDialog.java 11、如何手动添加 Cookie 需要获得 CookieManager 的对象并将 cookie 设置进去。 从服务器的返回头中取出 cookie 根据Http请求的客户端不同，获取 cookie 的方式也不同，请自行获取。 123456789101112131415161718/*** 将cookie设置到 WebView* @param url 要加载的 url* @param cookie 要同步的 cookie*/public static void syncCookie(String url,String cookie) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); /** * cookie 设置形式 * cookieManager.setCookie(url, "key=value;" + "domain=[your domain];path=/;") **/ cookieManager.setCookie(url, cookie);&#125; 删除 Cookie 的方法 12345678910111213141516171819/*** 这个两个在 API level 21 被抛弃* CookieManager.getInstance().removeSessionCookie();* CookieManager.getInstance().removeAllCookie();** 推荐使用这两个， level 21 新加的* CookieManager.getInstance().removeSessionCookies();* CookieManager.getInstance().removeAllCookies();**/public static void removeCookies() &#123; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeAllCookie(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; cookieManager.flush(); &#125; else &#123; CookieSyncManager.createInstance(Application.getInstance()); CookieSyncManager.getInstance().sync(); &#125;&#125; 12、如何使 HTML5 video 在 WebView 全屏显示 当网页全屏播放视频时会调用 WebChromeClient.onShowCustomView() 方法，所以可以通过将 video 播放的视图全屏达到目的。 1234567891011121314151617181920212223242526272829@Overridepublic void onShowCustomView(View view, CustomViewCallback callback) &#123; if (view instanceof FrameLayout &amp;&amp; fullScreenView != null) &#123; // A video wants to be shown this.videoViewContainer = (FrameLayout) view; this.videoViewCallback = callback; fullScreenView.addView(videoViewContainer, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); fullScreenView.setVisibility(View.VISIBLE); isVideoFullscreen = true; &#125;&#125;@Overridepublic void onHideCustomView() &#123; if (isVideoFullscreen &amp;&amp; fullScreenView != null) &#123; // Hide the video view, remove it, and show the non-video view fullScreenView.setVisibility(View.INVISIBLE); fullScreenView.removeView(videoViewContainer); // Call back (only in API level &lt;19, because in API level 19+ with chromium webview it crashes) if (videoViewCallback != null &amp;&amp; !videoViewCallback.getClass().getName().contains(".chromium.")) &#123; videoViewCallback.onCustomViewHidden(); &#125; isVideoFullscreen = false; videoViewContainer = null; videoViewCallback = null; &#125;&#125; 但是很多的手机版本在网页视频播放时是不会调用这个方法的，所以这个方法局限性很大。 13、Android5.0上 WebView中Http和Https混合问题 12345678/*** MIXED_CONTENT_ALWAYS_ALLOW：允许从任何来源加载内容，即使起源是不安全的；* MIXED_CONTENT_NEVER_ALLOW：不允许Https加载Http的内容，即不允许从安全的起源去加载一个不安全的资源；* MIXED_CONTENT_COMPATIBILITY_MODE：当涉及到混合式内容时，WebView 会尝试去兼容最新Web浏览器的风格。**/if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);&#125; 14、如何避免 WebView 的内存泄露问题 可以将 Webview 的 Activity 新起一个进程，结束的时候直接System.exit(0);退出当前进程； 不在xml中定义 WebView，而是在代码中创建，使用 getApplicationgContext() 作为传递的 Conetext； 在 Activity 销毁的时候，将 WebView 置空 1234567891011@Overrideprotected void onDestroy() &#123; if (webView != null) &#123; webView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null); webView.clearHistory(); ((ViewGroup) webView.getParent()).removeView(webView); webView.destroy(); webView = null; &#125; super.onDestroy();&#125; 总结 如果你踩到了 WebView 上的坑，请先默哀一分钟，然后努力找找解决方法吧，总会有人体验过你的悲剧，也会有人重蹈你的覆辙。当然 WebView 里肯定不止我上面列出来的这些问题，如果你有更多的 WebView 问题解决方案欢迎评论交流。]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南]]></title>
    <url>%2Fposts%2Fca8423a1.html</url>
    <content type="text"><![CDATA[随着ReactNative、Weex与Flutter等跨端框架的发展，大前端的概念也逐渐普及开来，纯粹的Native开发相对变得比较少，前端也成为了客户端同学必须要掌握的一门技术，但是客户端同学做的是跨端开发，在学习路线上和前端同学又稍有不同，下面从客户端同学的视角去讨论如何学习前端知识。 这里为大家整理了一份跨端技术图谱，这份图谱并没有去穷尽所有的前端技术，只是从客户端开发的视角去梳理常用的技术点，帮助大家理清脉络。 更多关于跨端技术的讨论可以参见BeesHybrid项目。 开发工具IDE推荐VSCode，轻量级、插件丰富，常用插件如下所示： Terminal：命令行工具。 Git History：查看单行提交记录和文件提交记录。 Git Project Manager：Git项目管理工具。 Git Len：解决日常开发协作痛点，推荐安装。 vscode-icons：让你的文件都带上好看的图标。 Path Intellisense：文件路径自动补全。 Auto Close Tag：自动闭合HTML标签。 Baracket Pair Colorizer：成对括号分颜色显示，方便区分。 Settings Sync：同步你的配置和扩展，参见同步教程。 VS Color Picker：取色器。 ES7 React/Redux/GraphQL/React-Native snippets：React代码提示。 Vue 2 Snippets：Vue2代码提示。 更多关于VSCode的使用技巧可以参见强大的VSCode。 前端基础对于客户端同学来说，要想上手React、Vue这些框架，需要先掌握HTML、CSS与JavaScript等基础知识，这部分的内容建议通过书籍来学习 ，一点一滴打捞基础，要有耐心。 HTML书籍：《HTML5权威指南》 CSS书籍：《CSS权威指南》、《精通CSS》 JavaScript书籍：《JavaScript高级程序设计》、《你不知道的Javascript》 除了基础的JavaScript知识，你还需要掌握ES6相关概念，这块可以参考ECMAScript 6 入门。 NPM我们还需要了解NPM相关知识，NPM就像Android里的Maven仓库一样，它是一个JavaScript仓库。 Node.js的包管理工具。 官方文档 NPM新手教程 前端框架Vue Vue.js（读音 /vjuː/，类似于 view 的读音）是一套构建用户界面(user interface)的渐进式框架。 官方文档 awesome-vue Vue.js 2.0 快速上手精华梳理 Vue学习看这篇就够 [译] 从1万篇文章中挑出的40篇最棒的 Vue 学习指南（2018版） React 用于构建用户界面的 JavaScript 库。 官方文档 React.js 小书 React入门教程 揭秘react生态体系 [译] 从1.8万篇文章中脱颖而出45个最棒的 React.js 学习指南（2018版） [译] State of Vue.js report 2017 中文版 跨端框架从PC时代开始，Native与Web就一直是相互竞争、相互融合的关系，我们先来简单看看它们之间的优势与劣势。 Native Web 性能 高 低 用户体验 好 差 功能 可以充分利用平台自身的能力 只有使用W3C的标准能力 迭代 周期长，需要发布 周期短，随时发布 维护成本 高 低 跨平台 差 好 线程 多线程 单线程 可以看出，Native与Web之间各有优劣，在移动互联网发展的过程中，开发者们也一直在寻找融合双方优势的方案，经历了以下四个阶段的发展： Hybrid 1.0：为Web页面提供Naive API的能力，也就是用JS Bridge去增强系统的WebView的功能。缺点是：体验差，如滚动、动画与交互等，稳定性差，如列表内存占用大等。 Hybrid 2.0：将Native组件覆盖在WebView之上，例如微信的cover-view，提供更多的扩展能力。缺点是：用户体验融合性不好，如层级、事件、布局等。 Hybrid 3.0：前端DSL开发，Native渲染，例如React Native与Weex。缺点：对W3C标准能力支持有限，存在平台差异，三端并不完全统一。 Hybrid 4.0：百花齐放的小程序、快应用、轻应用方案，这个容器也有两种：WebView容器与类ReatNative容器。技术方案上并没有太多的花样，这种方案的兴起由微信带起，本质上 还是源于各大公司对于流量入口和生态的竞争。后续我们会着重聊一下。 注：值得一提的是，同层渲染现在已经逐渐在Android和iOS平台的WebView上实现，未来Hybrid会有更多的玩法。 ReactNative 使用JavaScript和React编写原生移动应用. 官方文档 React-Native学习指南 给所有开发者的React Native详细入门指南（第一阶段） Weex Weex是一个基于现代web开发经验构建高性能移动应用程序的框架。 官方文档 awesome-weex WEEX从入门到放肆-图文视频教程（完整版） awesome-weex：Weex 学习与开发资料 Flutter Flutter允许您通过一个代码库在iOS和Android上构建漂亮的本地应用程序。 官方文档 Flutter 开发资源汇总 [译] Awesome Flutter：带你从入门到进阶的 Flutter 指南 小程序小程序也属于跨端框架的范畴，但它与Weex这些框架不同，比起像ReactNative这种技术创新，它更像是一种商业创新，它源于各大巨头对于流量与入口的竞争。详情可参见2018年上半年小程序生态白皮书。 我们先就他们的技术方案做个简单的对比，如下所示： 微信小程序：基于WebView渲染，自建的DSL，与Vue 1.0有点像，不是很好用，后续又出了WePY、mpVue、Taro等DSL。 支付宝小程序：基于WebView与ReactNative两套容器渲染，自建了一套类React的DSL。 快应用：基于Native进行渲染，自己定义了一套类Vue的DSL。 淘宝轻应用：基于WebView与Weex两套容器渲染，自建了一套类Vue的DSL。 事实上，小程序承载的更多是业务形态，我们从业务开发角度对小程序的前端架构做个总结。 微信小程序 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 官方文档 微信小程序公开课 微信小程序开发资源汇总 支付宝小程序 支付宝小程序是一种全新的开放模式，它运行在支付宝客户端，可以被便捷地获取和传播，为终端用户提供更优的用户体验. 官方文档 支付宝小程序社区 快应用 快应用是基于手机硬件平台的新型应用形态；标准是由主流手机厂商组成的快应用联盟联合制定；快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台；以平台化的生态模式对个人开发者和企业开发者全品类开放。 官方文档 快应用官方开源项目 快应用开发圈资源汇总 小米直达服务介绍与开发实战 淘宝小程序 官方文档 模块化 commonjs AMD(CMD) UMD ES Module 任务管理器 npm scripts grunt gulp 模块打包工具 r.js webpack rollup browserify CSS预处理器 Sass Less Stylus Postcss 静态检查器 flow typescript 测试工具 mocha jasmine jest ava 代码检测工具 eslint jslint 附录资源 前端资源库 前端技能树 前端开发技能树魔兽天赋游戏版 JavaScript算法与数据结构 怎样成长为一个优秀的 Web 前端开发工程师？ 技术栈前端技术从底层到顶层一共可以分为20个，如下所示： 浏览器 渲染引擎、JavaScript引擎 HTML/JavaScript/CSS三支柱 编辑器 编译任务 编译工具 打包、调试、质量 测试 JS基础类库 JS类库 UI框架 CSS预处理器 模板 现代化 安全/模式 中间语言 跨平台解决方案 图片来源]]></content>
      <categories>
        <category>前端</category>
        <category>学习指南</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin常用语法以及注意事项]]></title>
    <url>%2Fposts%2Fa1a08df3.html</url>
    <content type="text"><![CDATA[类型的声明与使用val与varval 不可变引用，var 可变引用。 我们应该尽可能使用val关键字来声明所有的kotlin变量，why？ 首先一个变量在声明时是不可变的，那就代表你在使用的时候不需要考虑其他地方会对它重新赋值和改变(对于对象注意只是引用不可变)，直接使用。 val声明的类型由于必须初始化,它是线程安全的。 kotlin为了保证类型安全，所有变量声明的地方必须要做初始化，即显示赋一个初值。 空与非空kotlin对于可空类型和非空类型认为是两个完全不同的类型，比如Int与Int?,他们俩就不是相同的类型。利用这个特点和编译时检查，kotlin基本可以避免空指针异常。 上面已经说了kotlin的类型声明时必须要有初值，所以空与非空类型和val与var一组合就会变成4种情况，下面我们对一个Person对象进行声明: 1234val p:Person = Person() val p:Person? = null // 这个情况是没有意义的var p:Person = Person() // 如果这个对象是非空类型，那么初始化的时候必须赋一个非null初值var p:Person? = null //可以给一个null,也可以给一个对象实例 上面这段代码基本解释了val与var和空与非空的关系。 空与非空的使用kotlin对空与非空做了严格的限制，那我们在使用时不都要对可空类型类型做判断吗？为了避免这个问题，kotlin提供了许多运算符来使开发人员对于可空与非空编码更加愉快。 安全调用运算符 “?.” 比如我们声明了这样一个类型var p:Person? = null。如果我们直接使用p.name，kotlin编译器是会报错的无法编译通过，所有我们必须这么做: 1if(p != null) p.name 这种代码写多了实在是太没有意义了，所有kotlin提供了?.。上面代码我们可以直接这样代替p?.name。它的实际执行过程是这样的:如果p为空则不操作，如果p不为空则调用p.name。 Elvis 运算符 “?:” 在kotlin中我们会写这种代码: 1val name = if(p != null) p.name else &quot;&quot; //kotlin中的if是一个表达式 不过使用?:可以更简单实现上面的逻辑 : val name = p?.name ?: &quot;&quot; 。 它的实际执行逻辑是如果p为null，p?.name就会为null， ?:会检查前面的结果，如果是null，那么则返回&quot;&quot;。 安全转换 “as?” 在kotlin中类型转换关键字为as。不过类型转换会伴随着转换失败的风险。使用as?我们可以更优雅的写出转换无风险的代码: 12345//Person类中的方法fun equals(o:Any?):Boolean&#123; val otherPerson = o as? Person ?: return false ....&#125; 即as?在转换类型失败时会返回null 非空断言 “!!” 如果使用一个可空类型的方法，并且你不想做非空判断，那么你可以这样做: person!!.getAge()。 不过如果person为null，这里就会抛出空指针异常。 其实还是在蛮多case下可以使用它，但是不建议使用，意难忘你完全可以使用？、？来做更优雅的处理，你也可以使用lateinit来避免编译器的可空提示。 val与bylazy、var与lateinit bylazy 它只能和val一块使用。 123private val mResultView：View = bylazy&#123; initResultView()&#125; 使用bylazy我们可以对一个变量延迟初始化，即懒加载。它是线程安全的。具体原理是:当我们使用bylazy声明的变量时，如果这个变量为null,那么就会调用bylazy代码块来初始化这个变量。 lateinit 它只能和var一块使用，并且不允许修饰可空类型，那它的使用场景是什么呢？ 在有些case下，比如一个构造复杂的对象，我们就是想把变量声明为非空类型并且就是不想给他一个初值(代价太大了),这时候我们就可以使用lateinit : 123456lateinit var p : Person //Person的构造函数太复杂了，不想在这里给一个初值fun refreshUI(p2:Person)&#123; //p = p2 val name = p.name //注意这个地方是可能会抛p为初始化异常的！！！如果你没有初始化&#125; 由于使用lateinit的时候我们要人工保证这个变量已经被初始化，并且kotlin在你每个使用这个变量的地方都会添加一个非null判断。所以lateinit尽量少用。 when 与 ififif在kotlin中不只是一个控制结构它也是一个表达式,即它是有返回结果的，我们可以利用它来代替java中的三目运算符: 1val background = if(isBlcak) R.drawable.black_image else R.drawable.white_image when它的使用方法有多种: 代替switch的功能 1234when(color)&#123; &quot;red&quot;,&quot;green&quot; -&gt;&#123; &#125; &quot;blue&quot;-&gt;&#123; &#125;&#125; kotlin中的when可以用来判断任何对象，它会逐一检查每一个分支，如果满足这个分支的条件就执行。 多条件判断 可以使用when来避免if..elseif..elseif..else的写法: 12345678val a = 1val b = 2when&#123; a &gt; 0 &amp;&amp; b &gt; 0 -&gt;&#123;&#125; a &lt; 0 &amp;&amp; b &gt; 0 -&gt;&#123;&#125; a &lt; 0 &amp;&amp; b &lt; 0 -&gt;&#123;&#125; else -&gt;&#123; &#125;&#125; when是带有返回值的表达式 和if一样，when也是一个表达式: 12345val desColor = when(color)&#123; &quot;red&quot;, &quot;gren&quot; -&gt; &quot;red&amp;green&quot; &quot;blue&quot; -&gt; &quot;blue&quot; else -&gt; &quot;black&quot; // when作为表达式时必须要有else分支。 &#125; 类类的构造与主构造函数 简单的声明一个 javabean 在kotlin中我们可以这样简单的定义一个类: class Person(val name:String = &quot;&quot;, var age:Int = 0) 这样就定义了一个Person类，这个类有两个属性:name和age。并且他有一个两个参数的构造函数来对这两个属性初始化。可以看出kotlin将一个类的声明变的十分方便。 主构造函数 普通的java构造函数是有代码块的，即可以做一些逻辑操作，那按照kotlin上面的方式，我们怎么做构造函数的逻辑操作呢? kotlin提供了初始化代码块: 123456class Person(val name:String = &quot;&quot;, var age:Int = 0)&#123; init&#123; name = &quot;susion&quot; age = 13 &#125;&#125; init代码块会在主构造函数之后运行，注意不是所有的构造函数。 数据类 data class更方便的定义一个javabean，我们可以使用数据类: 1data class Person(val name:String = &quot;&quot;, val age:Int = 0) 使用data定义的Person会默认生成equals、hashCode、toString方法。需要注意的是数据类的属性我们应该尽量定义成val的。这是因为在主构造函数中声明的这些属性都会纳入到equals和hashCode方法中。如果某个属性是可变的， 那么这个对象在被加入到容器后就会是一个无效的状态。 object 和 companion object在kotlin中没有静态方法，也没有静态类。不过kotlin提供了object与companion object object 单例类 使用object我们可以很轻松的创建一个单例类 : 12345678object LoginStatus&#123; var isLogin = false fun login()&#123; isLogin = true &#125; ...&#125; 我们可以这样直接使用LoginStatus.isLogin()。 那这个单例在kotlin中是怎么实现的呢？我们可以反编译看一下它生成的java代码: 123456789101112131415161718public final class LoginStatus &#123; private static boolean isLogin; public static final LoginStatus INSTANCE; // for java调用 ..... //省略不重要的部分 public final void login() &#123; isLogin = true; &#125; private LoginStatus() &#123; INSTANCE = (LoginStatus)this; &#125; static &#123; //类加载的时候构造实例 new LoginStatus(); &#125;&#125; 即kotlin object实现的单例是线程安全的。它的对象是在类创建的时候就产生了。 object的静态方法的使用 上面我们已经知道object创建单例的原理了。这在某些case下就很棒，但是某些时候我们不是想要单例，我们只是想要一些静态方法呢？比如我们经常创建的一些工具类(UIUtils、StringUtils)等。我们可以直接使用object来完成: 123456public object UIUtils&#123; ... ... ... ..很多方法&#125; 按照kotlin单例的设计，我们只要一旦使用这些方法，那么一直有一个单例对象UIUtils存在于内存中。那么这样好吗? 我们是否可以这样写呢 : 123456public class UIUtils&#123; ... ... ... ..很多方法&#125; 然后在使用的时候:UIUtils().dp2Px(1)。这样至少不会有一个对象一直在内存中。我想我们在某些case下可以这样使用我们的工具类。或者你可以使用kotlin的扩展函数或顶层函数来定义一些工具方法。所以对于kotlin的object的使用需要注意。 companion object companion object主要是为了方便我们可以在一个类中创建一些静态方法而存在的，比如: 123456class Person(val name: String) &#123; companion object &#123; fun isMeal(p: Person) = false &#125; &#125; 依旧看一下它反编译后的java代码: 123456789101112131415public final class Person &#123; ... public static final Person.Companion Companion = new Person.Companion((DefaultConstructorMarker)null); .... public static final class Companion &#123; public final boolean isMeal(@NotNull Person p) &#123; Intrinsics.checkParameterIsNotNull(p, &quot;p&quot;); return false; &#125; private Companion() &#123; &#125; ..... &#125;&#125; 即它也是生成了一个单例类Person.Companion。不过这个单例类是一个静态类。不允许构造。不过它的实现机制几乎和object相同。 lambdakotlin中lambda的本质就是可以传递给其他函数的一小段代码。kotlin中lambda使用的最多的就是和集合一块使用。 lambad与java接口 比如我们经常给View设置onClickListener,在kotlin中我们可以很方便的实现这段代码: 123userView.setOnClickListener&#123;&#125; // 如果lambda是函数的最后一个参数，那么是可以放在括号外面的。 即你可以直接传递给它一个lambda。kotlin在实际编译的时候会把这个lambda编译成一个匿名内部类。 那么所有java传对象的地方都可以这样使用吗？ 当然不是, 只有java参数满足下面条件才可以使用: 这个参数是一个接口，并且这个接口只有一个抽象方法。就可以这样使用，比如Runnable、Callable等。 with 与 apply with个人感觉比较鸡肋，这里就不讲它了。不过apply是十分实用的。在kotlin中apply被实现为一个函数: 1public inline fun &lt;T&gt; T.apply(block: T.() -&gt; kotlin.Unit): T &#123; &#125; 即它是一个扩展函数，接收一个lambda，并返回对象本身,并且他是一个内联的函数(下面会讲) 我最常用的一个case是给view设置参数: 123456val tvName = TextView(context).apply&#123; textSize = 10 textColor = xx text = &quot;susion&quot; ...&#125; 常用的库函数内联函数kotlin集合库中很多函数可以接收lambda作为参数。但我们前面说了kotlin的lambda表达式会被编译为一个匿名内部类，即每一次lambda的调用都会创建一个匿名内部类，所以会带来运行时的开销。 kotlin集合库中函数时给我们使用的，如果有这种开销的话，这肯定是一个不好的设计，因此kotlin集合库中的大部分函数都是内联函数。 比如上面的apply声明 : public inline fun &lt;T&gt; T.apply(block: T.() -&gt; kotlin.Unit): T { .... } 何为内联呢？: 当一个函数被声明为inline时，它的函数体是内联的，即函数体会被直接替换到函数被调用的地方。即不会存在运行时开销，下面要说的filter和map都是内联函数。 filter 与 map filter接收一个返回Boolean的lambda，用于对一个集合做筛选工作,并返回一个新集合: 1val wangList = userList.filter&#123;it.firstName == &quot;wang&quot;&#125; map也是接收一个lambda，它的返回值是另一个类型的集合，即map可以把一个类型的集合变成另一个类型的集合。 1val ageList = userList.map&#123; it.age &#125; 这两个函数虽然好用，不过我们要注意他们的实现，以免带来不必要的性能损耗 : filter和map函数都会创建一个新集合，因此如果你是下面这种用法就可能出现不必要的集合创建: 1val wangList = userList.map&#123; it.name &#125;.filter&#123;it == &quot;wang&quot;&#125; 在这种情况下，userList集合非常大的话，那么map操作之后生成的中间集合也可能非常大，对于这种情况可以考虑使用 kotlin序列。 count与find count用于统计集合中满足某个条件的数量，可以对比下面这种写法 123val wangCount= userList.filter&#123;it.firstName == &quot;wang&quot;&#125;.sizeval wangCount2 = userList.count&#123;it.firstName == &quot;wang&quot;&#125; //很明显，这种写法远好于第一种 find用来寻找集合中满足某个case的元素。 具体用法就不写了。 Kotlin的一些优秀的设计思想kotlin是基于java的，不过它在设计摒弃了很多java不好的思想。下面简单列举一些: kotlin中并不区分受检查异常和未受检查异常。即不用指定函数抛出的异常，而且也可以不处理异常 kotlin中类和类的方法默认是final的，即不允许继承和重写。这主要是为了减少继承，避免脆弱基类的问题 kotlin中集合接口分为访问集合数据和修改集合数据。比如kotlin.collections.Collection中就没有修改集合的方法。 kotlin中的函数支持默认参数，避免了多次重写一个函数的情况 kotlin支持扩展函数。它实际上就是某个类的静态方法。 …..]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让hexo的首页只显示文章的部分内容而不是全部]]></title>
    <url>%2Fposts%2Fe778c36e.html</url>
    <content type="text"><![CDATA[Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？目标 &gt; 在网站首页只显示每篇文章的部分内容，不要全部内容都展示出来。解决 &gt; 要解决这个问题有两个方法：一是修改 主题 _config.yml 文件设置，而是直接在你的 md 中加一句代码即可。 第一种方法用文本编辑器打开 themes/ 目录下的对应的主题的theme文件夹下的 _config.yml 文件，找到这段代码，如果没有则新建，可能不同的主题会不支持这种方法： 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。 修改后重启 hexo 就ok了。 第二种方法在你写 md 文章的时候，可以在内容中加上 &lt;!--more--&gt;，这样首页和列表页展示的文章内容就是 &lt;!--more--&gt; 之前的文字，而之后的就不会显示了。 效果 上面两种方式展示出来的效果是不一样的。 第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …。 而第二种加上 &lt;!--more--&gt;展示出来的就是你原本文章的样式，最后不会有…。 第三种方式在文章的 front-matter 中添加 description，并提供文章摘录 1234567891011---title: 让hexo的首页只显示文章的部分内容而不是全部id: set-hexo-show-more-button-on-indexcategories: - WEB开发date: 2017-09-30 11:01:40tags: - blog - hexodescription: Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？正如你现在看到的本篇文章，只显示到这里。--- 但是使用这种方式生成的描述信息在文章的详情页是不再显示的。 总结各种方式展示的效果各有好处，第二种方法保留了样式而且可以自行选择显示哪些内容来预览，推荐使用此方法，第一种方法显示的每篇文章的预览都是一样的高度，第三种则需要在文章的[front-matter]{https://hexo.io/docs/front-matter.html}里面添加。 综合考虑的话还是建议使用第二种方法，毕竟以后各种插件也能准确的获取到你想要输出的本篇的描述信息。 参考链接： http://www.5isjyx.com/coding/201704/nextreadthefulltext.html http://theme-next.iissnan.com/faqs.html]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudioGit设置忽略文件不生效]]></title>
    <url>%2Fposts%2F40a53d12.html</url>
    <content type="text"><![CDATA[在Android中git提交想忽略某些不想提交的文件，可以在项目目录中新建一个.gitignore，如果没有这个文件，可以手动建一个。里面匹配一下你不想提交的文件。 下面这是Android Studio的忽略规则 1234567891011121314151617181920212223242526272829303132333435363738394041# OSX*.DS_Store# Gradle filesbuild/.gradle/*/build/# IDEA*.iml.idea/.name.idea/encodings.xml.idea/inspectionProfiles/Project_Default.xml.idea/inspectionProfiles/profiles_settings.xml.idea/misc.xml.idea/modules.xml.idea/scopes/scope_settings.xml.idea/vcs.xml.idea/workspace.xml.idea/libraries# Built application files*.apk*.ap_# Files for the Dalvik VM*.dex# Java class files*.class# Generated filesantLauncher/binantLauncher/gen# Local configuration file (sdk path, etc)local.properties# Log Files*.log 规则网上很多，可以自己搜下，或者自己写一个也行。但是当我们提交的时候，却发现这些规则并没有失效，原因就是因为.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启你的终端装逼第一步]]></title>
    <url>%2Fposts%2F9253a935.html</url>
    <content type="text"><![CDATA[作为开发人员，和终端的亲密度那肯定不是一般地高，以上便是我打开终端迎面而来的画面，是不是逼格满满，23333，下面来教大家如何在 mac 上配置，其他系统应该也同理。 首先打开终端（这一步要是不会，那老铁你就别配置了吧）。 输入 cd /etc 进入目录。 输入 sudo pico motd,然后输入密码后进入修改页面。 然后在其中输入你想显示的装逼内容，再此提供一个图形界面网站：这是一个神奇的网站，干货满满吧。 最后 control + x，输入 y 保存，重启终端就可以看到逼格满满的欢迎页了。 如下图是我的：]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>博客</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 性能优化]]></title>
    <url>%2Fposts%2F20aedb71.html</url>
    <content type="text"><![CDATA[数据处理和视图加载分离我们知道，从远端拉取数据肯定是要放在异步的，在我们拉取下来数据之后可能就匆匆把数据丢给了 VH 处理，其实，数据的处理逻辑我们也应该放在异步处理，这样 Adapter 在 notify change 后，ViewHolder 就可以简单无压力地做数据与视图的绑定逻辑，比如： 1mTextView.setText(Html.fromHtml(data).toString()); 这里的 Html.fromHtml(data) 方法可能就是比较耗时的，存在多个 TextView 的话耗时会更为严重，这样便会引发掉帧、卡顿，而如果把这一步与网络异步线程放在一起，站在用户角度，最多就是网络刷新时间稍长一点。 数据优化分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 来进行局部刷新数据，而不是一味地全局刷新数据。 布局优化减少过渡绘制减少布局层级，可以考虑使用自定义 View 来减少层级，或者更合理地设置布局来减少层级，不推荐在 RecyclerView 中使用 ConstraintLayout，有很多开发者已经反映了使用它效果更差，相关链接有：Is ConstraintLayout that slow?、constraintlayout 1.1.1 not work well in listview。 减少 xml 文件 inflate 时间这里的 xml 文件不仅包括 layout 的 xml，还包括 drawable 的 xml，xml 文件 inflate 出 ItemView 是通过耗时的 IO 操作，尤其当 Item 的复用几率很低的情况下，随着 Type 的增多，这种 inflate 带来的损耗是相当大的，此时我们可以用代码去生成布局，即 new View() 的方式，只要搞清楚 xml 中每个节点的属性对应的 API 即可。 减少 View 对象的创建一个稍微复杂的 Item 会包含大量的 View，而大量的 View 的创建也会消耗大量时间，所以要尽可能简化 ItemView；设计 ItemType 时，对多 ViewType 能够共用的部分尽量设计成自定义 View，减少 View 的构造和嵌套。 其他其他并不代表不重要，而是我不能把他们进行分类哈，其中可能某些操作会对你的 RecyclerView 有很大的优化。 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可参考 RecyclerView 数据预取。 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout浪费资源； 设置 RecyclerView.addOnScrollListener(listener); 来对滑动过程中停止加载的操作。 如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提神效率。 对 TextView 使用 String.toUpperCase 来替代 android:textAllCaps=&quot;true&quot;。 对 TextView 使用 StaticLayout 或者 DynamicLayout 的自定义 View 来代替它。 通过重写 RecyclerView.onViewRecycled(holder) 来回收资源。 通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。 通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示： 123456new LinearLayoutManager(this) &#123; @Override protected int getExtraLayoutSpace(RecyclerView.State state) &#123; return size; &#125;&#125;;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC应用无法打开或文件损坏的处理方法]]></title>
    <url>%2Fposts%2Fef30a8ec.html</url>
    <content type="text"><![CDATA[有些用户下载了一些程序之后，却发现无法在MAC中安装，安装时会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。那么该如何解决这个问题呢？ 在MAC下安装一些软件时提示”来自身份不明开发者”，其实这是MAC新系统启用了新的安全机制。默认只信任 Mac App Store 下载的软件和拥有开发者 ID 签名的应用程序。换句话说就是 MAC 系统默认只能安装靠谱渠道（有苹果审核的 Mac App Store）下载的软件或被认可的人开发的软件。 这当然是为了用户不会稀里糊涂安装流氓软件中招，但没有开发者签名的 “老实软件” 也受影响了，安装就会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。 出现这个问题的解决方法有2种： 最简单的方式：按住Control后，再次点击软件图标，即可。 修改系统配置：系统偏好设置… -&gt; 安全性与隐私。 系统偏好设置 安全性与隐私 认证 修改为任何来源 高能预警！！！！！！！！(专门为不仔细看文章的准备的。。。。。。。没办法，只能放这么大了，要不老有人在评论里面问)如果没有这个选项的话（macOS Sierra 10.12）,打开终端，输入sudo spctl --master-disable然后按回车。然后会看见个password后面还有个钥匙图标，然后不用管他直接再继续输入你自己电脑解锁密码（输入的时候不显示你输入的密码，感觉就是输入不了东西一样，也不用管，凭感觉输入完按回车键）。然后再回到隐私里，就看见任何来源了。 ©软件著作权归作者所有;本站所有软件均来源于网络，仅供学习使用，请支持正版！ 转载请注明出处：精品MAC应用分享 » MAC应用无法打开或文件损坏的处理方法]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发技巧]]></title>
    <url>%2Fposts%2F56f29aad.html</url>
    <content type="text"><![CDATA[有同学问我，对应用开发你有没有值得注意或小技巧的地方可以分享的。比如适配、优化、排查错误什么的。鸡排把自己的总结笔记整理出来了。供大家参考。 开工准备在项目业务代码开工之前，最好把这些问题都解决掉，否则必将酿成大祸害。它们是： 组件路由 异步处理 组件化模块工程 全局网络拦截器 异常统一处理器 基础视图组件封装 日志记录工具 解决写无数次一模一样代码的模板（如自定义MVP模板） 机型适配特定的机型上出问题时，别着急。我们可以尝试以下几个办法。 反编译rom，看底层改动(条件略高) 联系该厂商的工程师（如果可以的话） 拷贝整个我们调用api的源码进行单独依赖，而放弃系统内的 逆向在该机型上正常的同类app，参考逆向后的代码实现 参考各个版本不同的Android API变化，可以从源码入手进行对 利用反射获取该特定机型上的某个我们想知道的方法，动态调试 排查崩溃闪退日志: 如果app在调试的过程中出现闪退,此时在logcat下日志会被新起来的进程冲刷掉。这时需要把过滤器选择为No filter 把日志级别选为 error即可查看到上一次崩溃的日志。 有一种情况是手机并不在我们身边,我们也无法使用调试工具。此时可以接入一些第三方的日志记录工具。在开发状态下不建议使用友盟 360之类sdk,因为很有可能我们的app根本无法连接到网络就崩溃了。 可以选择把日志存到本地文件中。再又使用手机的人发回来。一般这个人是测试。 如果app未接入任何日志保存工具,可以在data/anr/目录下查看到所有的ANR异常信息。但需要su权限。否则无法访问到。 APP性能体验优化 素材有必要使用压缩后的。推荐熊猫PNG压缩。 资源能用代码画尽量使用代码去画，而不要使用静态资源。 在复杂的布局上,比如很多app的首页需要加载不同类型的item。使用了RecyclerView多类型加载,刷新数据时一定要使用单独对item刷新api。切勿使用notifyitemchanged()方法,这里要用两个参数的notifyItemChanged(1,&quot;gfg&quot;)方法。 数据懒加载，或排队加载 混淆可以使包减小含:(xml 资源 class等) 如果玩得不是很6，尽量不要写静态引用，匿名内部类这种会导致内存泄漏的东西。如果很担心自己失误的写了，一定要去分析它们，把他们揪出来。 Activity的层级不要太深。过深会在低内存设备上被回收栈底的。 建议和技巧 发现某处代码可以复用性的封装一下或者改良一下会更好的时候一定要乘早，不要拖延。（烂泥巴只会越来越烂，后面改=永远没可能） debug编译期间可以把用不到的abi过滤掉，会让我们加速部署。 尽量保持较新的 support library依赖。因为较高的版本中修复了一些bug。 接入第三方包时，最好与自身模块保持独立，做到随时解耦，随便复用。 多个native库依赖时，若发现某些abi上不支持，那么就需要保持最小的abi。否则会给某些机型优先读取它更合适的架构。会造成灾难性的崩溃。如:ARM文件夹中含两个so，ARMv8中只有一个。届时手机优先加载了ARMV8的情况下，将带来找不到so库的崩溃异常。 不要太随性的引入第三方依赖库，如果只是用了很小一部分功能，建议剥出来自己封装。 第三方的包含私有api为暴露时，记得用反射去实现。当然这一切需要我们能翻他们的sdk源码读。也许被混淆了。这时就可以使用动态调试去跟踪。 多数情况下官方的support包比第三方要好得多。只是我们不知道，或者不熟悉。 渐变图、纯色图、带一根线的图用shape，不要静态图。会引发血案！ 当无法通过搜索解决问题的时候，读源码是最快的解决思路。千万不要瞎猜和尝试随缘写代码来解决问题。 封装控件时注意对资源类型做校验如:Image.setImageResource(img);这里的img需要做强校验，类型检测，防止别人用的时候不小心写错了。因为如果我们不主动抛出异常。靠LayoutInflater通过反射去解析xml时提示出了的错误日志非常难看。一般还会伴随一大堆调用栈和闪退出现。 冷启动优化，不要在Application启动时里做过多的任务&amp;第一个Activity里也是一样。最好把初始化的白屏Window设上一张图片过渡一下。 有不妥之处，欢迎指出和补充，拼死挣扎的Android程序员。]]></content>
      <categories>
        <category>Android</category>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 8.0采坑以及解决方法]]></title>
    <url>%2Fposts%2Fb2677b13.html</url>
    <content type="text"><![CDATA[虽然 Android 9.0 都已经面世了，本篇文章写的有点迟了。 但是迟到好过不到，因此基于此这边还是记录一下项目中遇到的 Android 8.0 的坑及对应解决方法。 每次系统升级，虽然系统功能更加强大了，各方面性能也提高了。 但是对于开发者而言，一个困扰的问题也是随之而来——兼容。 尤其对于一些已经上市的 App 而言，在新系统发布之前就要了解到底有哪些改动，以避免用户升级新系统后导致 App 没法正常运行。 好了，回归主题，说说 Android 8.0 里面的几个坑吧。 唤不起系统安装器如果你的 App 提供了更新功能，用户点击更新，你下载完 Apk 之后会自动弹出安装界面。 这个安装界面的弹出就是依赖于系统的安装器。 假设你在 Android 8.0 以下的手机操作正常，但是在 8.0 的手机上，你会发现，下载完之后完全没反应。 假设你以为说弹个提示让用户自己安装，我想说用户才不会理你。用户分分钟就不更新了。 所以说我们要解决这个问题。让这个安装器在 Android 8.0 的手机也能正常唤起。 其实解决方法非常简单。 只需要在 AndroidManifest.xml 中声明以下权限即可。 1&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt; 而且还不需要你在代码动态申请，是不是 So easy。 一行代码解决这个兼容性问题。 通知问题假设你的 App 需要在任务栏显示通知。如果你是按照 Android 8.0 之前的写法的话。那么在 8.0 的手机上面你是显示不了的。 那怎么办呢？ 关于通知的基本写法这边就不再赘余，如果不清楚的小伙伴自行查阅资料。这边重点说下解决方法。 首先说下下面代码出现的几个变量： 123private static NotificationManager manager;public static final String NOTIFICATION_CHANNEL = &quot;your app pkg name&quot;;private static final String NOTIFICATION_CHANNEL_NAME = &quot;App Channel&quot;; 第一个写过通知的都知道，一个管理类。 第二个是通知的一个 CHANNEL，这个也是 8.0 之后才引入的。取值 App 包名即可。 第三个自定义，只要保证唯一即可。 兼容有两步需要操作。 1. 创建Channel12345678910private static void createChannel() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; NotificationChannel notifyChannel = new NotificationChannel(NOTIFICATION_CHANNEL, NOTIFICATION_CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT); notifyChannel.setLightColor(Color.GREEN); notifyChannel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE); manager.createNotificationChannel(notifyChannel); &#125; &#125; 2. 获取 Notification.Builder1234567private Notification.Builder getNotificationBuilder(Context sourceContext) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; return new Notification.Builder(sourceContext, NOTIFICATION_CHANNEL); &#125; else &#123; return new Notification.Builder(sourceContext); &#125; &#125; 可以看到，上面的操作都以 8.0 作为分界处理。 做完这两步，之前不能显示通知的 App 就可以显示了。 更多内容可以看官方示例： github.com/googlesampl…]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio清理缓存CleanProject与InvalidateCaches]]></title>
    <url>%2Fposts%2Fc7a76d2f.html</url>
    <content type="text"><![CDATA[####Android studio 有时找不到R文件、 导入的资源、布局 、 jar包 等 . 可能是studio 缓存造成的 . 1.使用clean project工具栏 Build –&gt; clean project 2. 使用invalidate caches restart选择工具栏 File –&gt; Invalidate Caches /Restart… -&gt; Invalidate and Restart 重启Android studio]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext点击搜索一直转圈圈，解决控制字符问题]]></title>
    <url>%2Fposts%2Fb30a2a4e.html</url>
    <content type="text"><![CDATA[1. 环境 macOS Sierra 10.13.6 vscode 1.29.0 最新版 2. 如何重现这个问题在使用中文输入法输入中文的时候，一直按后退键，例如输入sfsf，当你按了4下后退键时，你会发现，搜狗输入法弹出框虽然消失了，但是页面上还会剩下一个s, 这是你如何再次按一下后退的话，s就会变成bs, 变成隐藏字符。这个一般是右边有markdown渲染插件时才会出现。 从更确切的角度说，是你的编辑器一旦开了webview，就会出现这个问题，即使是vscode的欢迎页，也是webview，也会导致这个问题。所以最好在写代码时尽量关闭webview。 3. 如何让隐藏字符现身Mac版的vscode控制字符一般是不会显示出来的，可以用一下的方法让其显示出来 1&quot;editor.renderControlCharacters&quot;: true 在编辑器中显示的像很小的BS, 表示backspace的意思。一般是在输入时，按了后退或者删除会偶尔出现这个字符。 4. 隐藏的控制字符会出现什么问题？4.1. 控制字符在github上会出现问号例如下图的的和同字之间就是出现一个隐藏字符，在github上就会出现一个带有背景的问号。 4.2. 控制字符在Hexo NexT Local Search 会导致search.xml渲染失败，搜索框一直在转圈如果你使用浏览器打开search.xml，会发现解析报错 5. 如何解决5.1. 手动删除隐藏字符可以使用替换，先复制一个隐藏字符，然后把隐藏字符替换成空 5.2. 使用插件 Remove backspace control characterRemove backspace control character 在本家chromium已被合并，因此，在8月上旬发行的vscode 1.15将会重新确定(vscode 1.15, electron 1.7.4)。事实上，到现在这个问题还是没解决的 特点 格式化程序，用于删除打开的文档中包含的控制字符。要被删除的控制字符默认如下。 1/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm 用法 “editor.formatOnSave”: true 如果被设定,保存时启动 “editor.formatOnType”: true 在被设定的情况下，进行变换时;输入时启动 7. 参考 Mac 上的 VSCode 编写 Markdown 总是出现隐藏字符？ Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层 Backspace can not erase the last one character during Chinese/Japanese IME conversion (macOS) #24981 Backspace can not erase the last one character during Japanese IME conversion (macOS) #9173 Two backspaces required to delete last character in webview input 控制字符 Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同的国家/地区与语言缩写代码]]></title>
    <url>%2Fposts%2Ff8376e8.html</url>
    <content type="text"><![CDATA[国家/地区 语言代码 国家地区 语言代码 简体中文(中国) zh-cn 简体中文(台湾地区) zh-tw 繁体中文(香港) zh-hk 英语(香港) en-hk 英语(美国) en-us 英语(英国) en-gb 英语(全球) en-ww 英语(加拿大) en-ca 英语(澳大利亚) en-au 英语(爱尔兰) en-ie 英语(芬兰) en-fi 芬兰语(芬兰) fi-fi 英语(丹麦) en-dk 丹麦语(丹麦) da-dk 英语(以色列) en-il 希伯来语(以色列) he-il 英语(南非) en-za 英语(印度) en-in 英语(挪威) en-no 英语(新加坡) en-sg 英语(新西兰) en-nz 英语(印度尼西亚) en-id 英语(菲律宾) en-ph 英语(泰国) en-th 英语(马来西亚) en-my 英语(阿拉伯) en-xa 韩文(韩国) ko-kr 日语(日本) ja-jp 荷兰语(荷兰) nl-nl 荷兰语(比利时) nl-be 葡萄牙语(葡萄牙) pt-pt 葡萄牙语(巴西) pt-br 法语(法国) fr-fr 法语(卢森堡) fr-lu 法语(瑞士) fr-ch 法语(比利时) fr-be 法语(加拿大) fr-ca 西班牙语(拉丁美洲) es-la 西班牙语(西班牙) es-es 西班牙语(阿根廷) es-ar 西班牙语(美国) es-us 西班牙语(墨西哥) es-mx 西班牙语(哥伦比亚) es-co 西班牙语(波多黎各) es-pr 德语(德国) de-de 德语(奥地利) de-at 德语(瑞士) de-ch 俄语(俄罗斯) ru-ru 意大利语(意大利) it-it 希腊语(希腊) el-gr 挪威语(挪威) no-no 匈牙利语(匈牙利) hu-hu 土耳其语(土耳其) tr-tr 捷克语(捷克共和国) cs-cz 斯洛文尼亚语 sl-sl 波兰语(波兰) pl-pl 瑞典语(瑞典) sv-se 西班牙语 (智利) es-cl]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android组件化，完全解耦]]></title>
    <url>%2Fposts%2Fd7e6359d.html</url>
    <content type="text"><![CDATA[目前,Android 组件化普遍使用于移动开发,但是组件化的初衷是为了解耦代码,并行开发效率;小型app似乎会care不到,完全解耦的组件化会在app越来越臃肿的时候带来很大的提升; 1.组件化介绍ok,那么我们需要知道完全解耦的组件化框架应该注意哪些点: 主app只加载业务组件,不可调用组件;组件与组件之间不存在调用关系;这样无论是主app和业务组件都是完全独立,完全解耦的; 主app和组件都依赖common组件,通过common的注册和分发实现组件之间的交互,这个common我们姑且叫做业务主线 android中page使用common下层接口和路由进行实现(在本框架中,ARouter实现Activity跳转,ARouter-Interceptor实现Activity跳转的拦截;Fragment通过common下沉注册分发实现Fragment的填充) 每一个组件应当是一个app可单独编译:Library和Application之间转化使用gradle配置相应的Manifest和applicationId 2.单独编译组件化配置(gradle)依赖关系 App 依赖common Home/Login/News 依赖common common 依赖component-base 2.1. 首先在整个工程的gradle.properties中配置组件 Library/Application切换的开关: 123isRunLogin = false //login组件isRunHome = false //home组件isRunNews = false //news组件 2.2. 由于android中Library(组件)/Application切换时的差异,需要单独配置主见以home组件为例:首先开build.gradle: 12345678910111213141516171819202122232425//注释1: 配置切换application/Library的打包if (isRunHome.toBoolean())&#123; apply plugin: &apos;com.android.application&apos;&#125;else&#123; apply plugin: &apos;com.android.library&apos;&#125;android &#123; ....... sourceSets &#123; //注释2: Library/Application切换 AndroidManifest main &#123; if (isRunLogin.toBoolean())&#123; manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; &#125;else&#123; manifest.srcFile &apos;src/main/manifest/AndroidManifest.xml&apos; &#125; &#125; &#125; ......&#125;...... 注释1: 切换application/Libaray的打包配置 注释2: Application为单独编译,需要有applicationId,并且主Activity需要配置main属性;Libaray为集成编译,组件不能有applicationId,且不可以设置启动的main Activity下面看集成编译(Library)和单独编译(Application)的Manifest配置: 123456789//集成编译,打包为Library&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="component.android.com.home"&gt; &lt;application android:theme="@style/home_AppTheme"&gt; &lt;activity android:name=".view.activity.HomeActivity"/&gt; &lt;/application&gt;&lt;/manifest&gt; 12345678910111213141516171819202122//单独编译,打包为单独Application 可单独编译&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="component.android.com.home"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:name=".global.HomeApp" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/home_AppTheme"&gt; &lt;activity android:name=".view.activity.HomeActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 3.组件之间activity跳转(Actiivity跳转)3.1. 组件之间的activity跳转,这里使用ARouter ARouter是阿里开源的一种页面跳转task 首先看ARouter在build.gralde的配置: 12345678910111213141516171819202122//主app build.gradle......dependencies &#123; ...... androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' &#125;//home/login/news 组件 build.gradledependencies &#123; ........ annotationProcessor 'com.alibaba:arouter-compiler:1.1.4'&#125;//common build.gradledependencies &#123; ...... api 'com.alibaba:arouter-api:1.3.1' // arouter-compiler 的注解依赖需要所有使用 ARouter 的 module 都添加依赖 annotationProcessor 'com.alibaba:arouter-compiler:1.1.4'&#125; 3.2 在app和各组件中进行page跳转 首先是ARouter的初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MainApplication extends BaseApp &#123; @Override public void onCreate() &#123; super.onCreate(); //在主app中初始化ARouter initRouter(); initMoudleApp(this); initMoudleData(this); &#125; private void initRouter() &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); &#125; @Override public void initMoudleApp(Application application) &#123; for (String moduleApp : AppConfig.moduleApps) &#123; try &#123; Class clazz = Class.forName(moduleApp); BaseApp baseApp = (BaseApp) clazz.newInstance(); baseApp.initMoudleApp(this); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void initMoudleData(Application application) &#123; for (String moduleApp : AppConfig.moduleApps) &#123; try &#123; Class clazz = Class.forName(moduleApp); BaseApp baseApp = (BaseApp) clazz.newInstance(); baseApp.initMoudleData(this); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//组件中 home--HomeApplicationpublic class HomeApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 这里需要注意一下 当集成编译时候 ,组件仅仅是一个组件,不会单独具备Applicagtion入口,所以需要在主app的MainApplication中利用反射的方式 initMoudleData/initMoudleData进行ARouter等初始化的配置; 下面看ARouter的跳转实例: 123456789//app/MainActivity....private void initClick() &#123; findViewById(R.id.btn_nav_home).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ARouter.getInstance().build("/home/homeActivity").navigation() &#125;&#125; 在app中实现跳转,但是这个 path/home/homeActivity需要在home组件目标位置添加注解才能实现activity的跳转: 123456789@Route(path = "/myhome/homeActivity")public class HomeActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_home); &#125;&#125; 这样 就成功实现类组件之间的activity的跳转; 4.组件之间的逻辑交互App点击跳转home,须判断登录逻辑: 1.登录则跳转home组件的homeActivity 2.未登录则跳转login组件的loginActivity,点击登录,再重复以上逻辑这样 主app,home和login就实现了一个简单的交互逻辑首先开component: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//ILoginServicepublic interface ILoginService &#123; boolean getLoginStatus(); int getLoginUserId();&#125;//DefultLoginServicepublic class DefultLoginService implements ILoginService &#123; @Override public boolean getLoginStatus() &#123; return false; &#125; @Override public int getLoginUserId() &#123; return 0; &#125;&#125;//ComponentServiceFactorypublic class ComponentServiceFactory &#123; ...... public static ComponentServiceFactory getInstance(Context context)&#123; if (instance == null)&#123; synchronized (ComponentServiceFactory.class)&#123; if (instance == null)&#123; instance = new ComponentServiceFactory(); &#125; &#125; &#125; return instance; &#125; private ILoginService loginService; public void setLoginService(ILoginService iloginService)&#123; loginService = iloginService; &#125; public ILoginService getLoginService()&#123; if (loginService == null)&#123; loginService = new DefultLoginService(); &#125; return loginService; &#125;&#125; 然后在login中通过common的ComponentServiceFactory注册对应的loginService 12345678910111213141516171819202122232425262728293031323334//LoginServicepublic class LoginService implements ILoginService &#123; @Override public boolean getLoginStatus() &#123; return AccountUtils.getInstance().isAccountStatus(); &#125; @Override public int getLoginUserId() &#123; return 0; &#125;&#125;//Login组件LoginApp注册service........public class LoginApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; Log.i("LoginApp","initMoudleApp"); if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); ComponentServiceFactory.getInstance(this).setLoginService(new LoginService()); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 在App-MainActivity中跳转homeActivity,在home组件中使用ARouter的拦截器: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//app-mainActivityprivate void initClick() &#123; findViewById(R.id.btn_nav_home).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ARouter.getInstance().build("/home/homeActivity").navigation(MainActivity.this, new NavCallback() &#123; //ARouter拦截器的监听 @Override public void onArrival(Postcard postcard) &#123; LogUtils.LogI("loginInterceptor","done"); &#125; @Override public void onFound(Postcard postcard) &#123; //super.onFound(postcard); LogUtils.LogI("loginInterceptor","found"); &#125; @Override public void onLost(Postcard postcard) &#123; //super.onLost(postcard); LogUtils.LogI("loginInterceptor","lost"); &#125; @Override public void onInterrupt(Postcard postcard) &#123; //super.onInterrupt(postcard); LogUtils.LogI("loginInterceptor","interrupt"); &#125; &#125;); &#125; &#125;); &#125;//home-HomeInterceptor@Interceptor(priority = 1,name = "homeInterceptor")public class HomeInterceptor implements IInterceptor &#123; private Context context; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; switch (postcard.getPath())&#123; case "/myhome/homeActivity": //通过component进行逻辑交互 if (ComponentServiceFactory.getInstance(context).getLoginService().getLoginStatus())&#123; callback.onContinue(postcard); &#125;else &#123; ARouter.getInstance().build("/login/loginActivity").navigation(); //callback.onInterrupt(new RuntimeException("请登录")); //callback.onContinue(postcard); &#125; break; default: callback.onContinue(postcard); break; &#125; &#125; @Override public void init(Context context) &#123; this.context = context; &#125;&#125;//login-loginInterceptor@Interceptor(priority = 2,name = "loginInterceptor")public class LoginInterceptor implements IInterceptor &#123; private Context context; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; switch (postcard.getPath())&#123; case "/login/loginActivity": LogUtils.LogI("loginInterceptor","请点击登录按钮"); callback.onContinue(postcard); break; default: callback.onContinue(postcard); //在每一个组件中添加一个navi的拦截器 逻辑在 &#125; &#125; @Override public void init(Context context) &#123; this.context = context; &#125;&#125; 1.在跳转homeActivity时,跳转到home组件的homeInterceptor拦截器 2.在homeInterceptor中通过component获取login注册的lohginservice来获取登录状态,实现下一步跳转 可以看到 app 通过ARouter跳home home通过component的注册分发,判断登录逻辑 进行下一步跳转;这样就实现了不依赖其他组件的逻辑交互 5.组件化fragment解耦在android中我们使用最多的就是fragment,一般情况下 我们会实例化fragment再进行下一步逻辑;为了解耦我们在component中注册fragment接口,在相应组件中注册fragmentservice,在其他组件中实现分发: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//component-LoginFragmentServicepublic class LoginFragmentService implements IFragmentService &#123; @Override public Fragment getFragment(String tag) &#123; return new LginHomeFragment(); &#125; @Override public void newFragment(Activity activity, int resId, FragmentManager fragmentManager, Bundle bundle, String tag) &#123; FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.add(resId,new LginHomeFragment(),tag); transaction.commit(); &#125;&#125;//component-ComponentServiceFactorypublic class ComponentServiceFactory &#123; private static volatile ComponentServiceFactory instance; private IFragmentService newsFragmentService; private IFragmentService homeFragmentService; private IFragmentService loginFragmentService; public static ComponentServiceFactory getInstance(Context context)&#123; if (instance == null)&#123; synchronized (ComponentServiceFactory.class)&#123; if (instance == null)&#123; instance = new ComponentServiceFactory(); &#125; &#125; &#125; return instance; &#125;........ //主册fragmentservice入口 public void setHomeFragmentService(IFragmentService iFragmentService)&#123; homeFragmentService = iFragmentService; &#125; public void setLoginFragmentService(IFragmentService iFragmentService)&#123; loginFragmentService = iFragmentService; &#125; public void setNewsFragmentService(IFragmentService iFragmentService)&#123; newsFragmentService = iFragmentService; &#125; public IFragmentService getNewsFragmentService() &#123; return newsFragmentService; &#125; public IFragmentService getHomeFragmentService() &#123; return homeFragmentService; &#125; public IFragmentService getLoginFragmentService() &#123; return loginFragmentService; &#125;&#125; 在home组件中进行fragmentservice的注册工作: 1234567891011121314151617181920//home-HomeApppublic class HomeApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); ComponentServiceFactory.getInstance(this).setHomeFragmentService(new HomeFragmentService()); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 在App中调用: 1234567// app-MainActivity:private void initBaseView() &#123; FragmentManager supportFragmentManager = getSupportFragmentManager(); ComponentServiceFactory.getInstance(this) .getHomeFragmentService().newFragment(this,R.id.content,supportFragmentManager,null,null); &#125; 这样一个home组件中的homeFragment就加载到主app的xml中同理组件之间的fragment引用亦如此注意框架中component-IFragmentService实现了两个方法: 12345//获取目标的fragment来进行操作 Fragment getFragment(String tag); //用于固定的区域来填充相应fragment void newFragment(Activity activity, int resId, FragmentManager fragmentManager, Bundle bundle, String tag); getFragment(String tag);为获取目标fragment接口,获取到实例之后开发者自己实现fragment相关逻辑 newFragment(...);适用于在布局中静态添加fragment,一步到位 当然框架中还有部分限制组件资源的gradle配置,有兴趣可以在github下载demo]]></content>
      <categories>
        <category>Android</category>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Handler消息机制学习]]></title>
    <url>%2Fposts%2F7a63eeca.html</url>
    <content type="text"><![CDATA[1.概述 Handler允许你发送和处理Message，以及和线程相关联的Runnable对象。每一个Handler实例都与一个线程及该线程的MessageQueue相关联。既当你创建一个Handler时，该Handler必须绑定一个线程以及该线程的消息队列，一旦它被创建，它能把messages和runnables传送到message queue，并在它们从message queue中出来的时候执行它们。 Handler主要有两个主要用途： 在未来的某个时间点调度messages和runnables的执行 将要在不同线程上执行的操作加入队列 当你的应用程序被创建出来的时候，主线程会专门运行一个message queue来管理最顶级的应用对象(如activities, broadcast receivers，等等)以及它们创建的任何其它窗口。你可以创建你自己的线程，通过Handler来与主线程建立联系 2.源码分析2.1 MessageQueue-消息队列 MessageQueue是一个通过Looper分发它持有的消息列表的低层级类。Messages没有直接添加到MessageQueue中，而是通过与Looper相关联的Handler对象。 Message-消息 该类实现了Parcelable接口，你可以把它看作一个数据类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849** * * Defines a message containing a description and arbitrary data object that can be * sent to a &#123;@link Handler&#125;. This object contains two extra int fields and an * extra object field that allow you to not do allocations in many cases. * 定义包含描述和任意数据对象的消息 * 发送到Handler。这个对象包含两个额外的int字段和一个 * 额外的对象字段，允许您在很多情况下不进行分配。 * &lt;p class="note"&gt;While the constructor of Message is public, the best way to get * one of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the * &#123;@link Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull * them from a pool of recycled objects.&lt;/p&gt; * 注意：不要直接使用New Message()创建Message对象，最好的方式是通过Handler.obtainMessage() * 方法，它会从对象回收池中拉取该消息对象 */public final class Message implements Parcelable &#123; /** @hide */ public static final Object sPoolSync = new Object(); /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. * 从全局池返回一个新的消息实例。让我们在很多情况下避免分配新对象。 */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; ** * Same as &#123;@link #obtain()&#125;, but sets the value for the target member on the Message returned. * 与obtain()相同，但在返回的消息上设置目标成员的值。 * @return A Message object from the global pool. * 返回来自全局池的消息对象 */ public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h;//接收传递过来的Handler return m; &#125;&#125; 2.2 Looper-消息轮询器 Looper用于为线程轮询messages。线程默认是没有与之相关联的Lopper，我们必须通过Looper.prepare()方法去创建它。示例： 123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; ThreadLocal提供线程的局部变量，通过它访问线程独立初始化变量的副本。即Looper通过ThreadLocal类来与当前线程进行交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//私用构造方法//quitAllowed是否允许退出private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//实例化消息队列 mThread = Thread.currentThread();//获取当前线程&#125;/** Initialize the current thread as a looper.* This gives you a chance to create handlers that then reference* this looper, before actually starting the loop. Be sure to call* &#123;@link #loop()&#125; after calling this method, and end it by calling* &#123;@link #quit()&#125;.* 初始化当前线程的Looper* 在它准备轮询之前，给你一个时机点去创建一个Handler并引用它* 调用该方法后一定记得Looper.loop()方法，并结束的时候调用Looper.quit()方法退出*/public static void prepare() &#123; prepare(true);&#125;// sThreadLocal.get() will return null unless you have called prepare().//必须先调用Looper.prepare()方法，否则返回空static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) &#123; //每一个线程只能有唯一的一个looper if (sThreadLocal.get() != null) &#123;//不为空抛出异常 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//设置Looper&#125;/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. * 返回与当前线程关联的looper */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125;/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. * 在当前线程运行消息队友 */public static void loop() &#123; final Looper me = myLooper();//获取looper if (me == null) &#123;//为空则抛出异常 throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue;//获取looper的消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. //确保这个线程的标识是本地进程的标识， //并跟踪身份令牌的实际情况。 Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0); boolean slowDeliveryDetected = false; for (;;) &#123;//无限轮询 Message msg = queue.next(); // might block if (msg == null) &#123; //没有message则不往下执行 // No message indicates that the message queue is quitting. return; &#125; ***省略代码*** final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg);//调用Handler的dispatchMessage(msg)方法 dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; //回收可能正在使用的消息。 //在处理消息队列时，MessageQueue和Looper在内部使用。 msg.recycleUnchecked(); &#125;&#125;//sThreadLocal.get()public T get() &#123; Thread t = Thread.currentThread();//通过Thread的静态方法获取当前的线程 //ThreadLocalMap是一个定制的HashMap(),仅适用于维护线程局部值,每一个线程都持有一个ThreadLocalMap对象 ThreadLocalMap map = getMap(t);//传入当前线程获取当前线程的ThreadLocalMap对象-------------------------------------------------------------------------------————————————— ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;-------------------------------------------------------------------------------————————————— if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 2.3 Handler2.3.1 创建Handler对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. * 如果你不想通过继承Handler来实现，你必须实现Callback接口 */public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ public boolean handleMessage(Message msg);&#125;//默认构成器//如果该Handler所绑定的线程没有looper，它将收不到任何messages，并且会抛出异常public Handler() &#123; this(null, false);&#125;//默认构造器的Callback为空，所以当我们通过new Handler()来创建实例时，//我们必须重写Handler的handleMessage(Message msg)方法，即：companion object &#123;//注意写成静态内部类的形式，避免内存泄漏 private class MyHandler :Handler()&#123; override fun handleMessage(msg: Message?) &#123; super.handleMessage(msg) &#125; &#125;&#125;-------------------------------------------------------------------------------—————————————//主动实现Callback接口，来创建Handler实例public Handler(Callback callback) &#123; this(callback, false);&#125; companion object &#123; private val mHandler1:Handler = Handler(object :Handler.Callback&#123; override fun handleMessage(msg: Message?): Boolean &#123; return true &#125; &#125;) 或 private val mHandler2:Handler = Handler(Handler.Callback &#123; true &#125;)&#125;-------------------------------------------------------------------------------————————————— /** * Use the provided &#123;@link Looper&#125; instead of the default one. * * @param looper The looper, must not be null. * //不使用默认的looper */public Handler(Looper looper) &#123; this(looper, null, false);&#125;//之前我看到某些前辈是通过下面这种方式来创建Handler实例，通过传递主线程的looper//但这是没必要的，Handler默认就是使用主线程的looper(下面会分析)//并且源码注释也说了，使用你自己的提供的looper而不是默认的private val mHandler:Handler = object :Handler(Looper.getMainLooper())&#123; override fun handleMessage(msg: Message?) &#123; super.handleMessage(msg) &#125;&#125;-------------------------------------------------------------------------------—————————————//该构造同上，如果你不想重写handleMessage(msg: Message?)方法，那么你就重写Callback接口public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;//是否需要异步处理messages，默认是异步的public Handler(boolean async) &#123; this(null, async);&#125;//自己提供looper，实现Callback接口，决定是否异步public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125;-------------------------------------------------------------------------------—————————————/* * Set this flag to true to detect anonymous, local or member classes * that extend this Handler class and that are not static. These kind * of classes can potentially create leaks. * 将此标志设置为true以检测匿名类、本地类或成员类 * 继承了Handler不是静态的，可能存在内存泄漏 */private static final boolean FIND_POTENTIAL_LEAKS = false;//通过Handler()、Handler(Callback callback)、Handler(boolean async)//都会调用该构造器public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123;//检查可能存在的内存泄漏，默认是false final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//获取looper if (mLooper == null) &#123;//如果为空抛出异常 throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//获取Looper中的消息队列 mCallback = callback; mAsynchronous = async;&#125;private static void handleCallback(Message message) &#123; message.callback.run();//执行Message持有的Runnable&#125;/** * Handle system messages here. * 处理系统Messages */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123;//如果Message的Runnable不为空 handleCallback(msg);调用Handler的handleMessage(msg)方法处理Message &#125; else &#123; if (mCallback != null) &#123;//如果Handler的Callback不为空 if (mCallback.handleMessage(msg)) &#123;//调用Callback的handleMessage(msg)方法 return; &#125; &#125; //否则调用Handler的handleMessage(msg)方法 handleMessage(msg); &#125;&#125; 2.3.2 创建Message对象1234567891011121314151617181920public final Message obtainMessage()&#123; return Message.obtain(this);&#125;public final Message obtainMessage(int what)&#123; return Message.obtain(this, what);&#125;public final Message obtainMessage(int what, Object obj)&#123; return Message.obtain(this, what, obj);&#125;public final Message obtainMessage(int what, int arg1, int arg2)&#123; return Message.obtain(this, what, arg1, arg2);&#125;public final Message obtainMessage(int what, int arg1, int arg2, Object obj)&#123; return Message.obtain(this, what, arg1, arg2, obj);&#125; 2.3.3 发送Message123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * Causes the Runnable r to be added to the message queue. * The runnable will be run on the thread to which this handler is * attached. * 将Runnable添加到消息队列中。 * runnable将在此Handler所在的线程上运行。 * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. * Runnable成功添加到消息队列中返回ture，失败返回false */public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain();创建Message对象 m.callback = r;把Runnale传递给Message return m;&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123;//延迟时间小于0，则置为0 delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;//延迟发送public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postDelayed(Runnable r, Object token, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r, token), delayMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this;//把当前的Handler传递给Message的Handler if (mAsynchronous) &#123;//是否异步 msg.setAsynchronous(true); &#125; //最终调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis);&#125;MessageQueue：boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123;//Message的Handler为空，抛出异常 throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123;//Message正在使用，抛出异常 throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123;//判断是否退出 IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle();//回收Message return false; &#125; msg.markInUse();设置Message是否正在使用的Flag msg.when = when; Message p = mMessages; boolean needWake;//是否需要唤醒 if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. //插入到队列的中间。通常我们不需要唤醒 //启动消息队列，除非队列头部有阻碍 //消息是队列中最早的异步消息。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123;//开启无限轮询 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; ###]]></content>
      <categories>
        <category>Android</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARouter路由框架]]></title>
    <url>%2Fposts%2Fa9949862.html</url>
    <content type="text"><![CDATA[1一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦 Demo展示Demo apk下载、Demo Gif一、什么是路由说简单点就是映射页面跳转关系的，当然它也包含跳转相关的一切功能。 二、为什么需要路由Android系统已经给我们提供了api来做页面跳转，比如startActivity，为什么还需要路由框架呢？我们来简单分析下路由框架存在的意义： 在一些复杂的业务场景下（比如电商），灵活性比较强，很多功能都是运营人员动态配置的，比如下发一个活动页面，我们事先并不知道具体的目标页面，但如果事先做了约定，提前做好页面映射，便可以自由配置。 随着业务量的增长，客户端必然随之膨胀，开发人员的工作量越来越大，比如64K问题，比如协作开发问题。App一般都会走向组件化、插件化的道路，而组件化、插件化的前提就是解耦，那么我们首先要做的就是解耦页面之间的依赖关系。 简化代码。数行跳转代码精简成一行代码。 其他… 三、为什么需要路由ARouter是阿里巴巴开源的Android平台中对页面、服务提供路由功能的中间件，提倡的是简单且够用。GitHub：https://github.com/alibaba/ARouter 四、功能介绍 支持直接解析标准URL进行跳转，并自动注入参数到目标页面中 支持多模块工程使用 支持添加多个拦截器，自定义拦截顺序 支持依赖注入，可单独作为依赖注入框架使用 支持InstantRun 支持MultiDex(Google方案) 映射关系按组分类、多级管理，按需初始化 支持用户指定全局降级与局部降级策略 页面、拦截器、服务等组件均自动注册到框架 支持多种方式配置转场动画 支持获取Fragment 完全支持Kotlin以及混编(配置见文末 其他) 支持第三方 App 加固(使用 arouter-register 实现自动注册) 支持生成路由文档 五、典型应用 从外部URL映射到内部页面，以及参数传递与解析 跨模块页面跳转，模块间解耦 拦截跳转过程，处理登陆、埋点等逻辑 跨模块API调用，通过控制反转来做组件解耦 六、基础功能 添加依赖和配置 1234567891011121314151617181920android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName()] &#125; &#125; &#125;&#125;dependencies &#123; // 替换成最新版本, 需要注意的是api // 要与compiler匹配使用，均使用最新版可以保证兼容 compile &apos;com.alibaba:arouter-api:x.x.x&apos; annotationProcessor &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125;// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末&apos;其他#4&apos;// Kotlin配置参考文末&apos;其他#5&apos; 添加注解 123456// 在支持路由的页面上添加注解(必选)// 这里的路径需要注意的是至少需要有两级，/xx/xx@Route(path = "/test/activity")public class YourActivity extend Activity &#123; ...&#125; 初始化SDK 12345if (isDebug()) &#123; // 这两行必须写在init之前，否则这些配置在init过程中将无效 ARouter.openLog(); // 打印日志 ARouter.openDebug(); // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)&#125;ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化 发起路由操作 123456789// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)ARouter.getInstance().build("/test/activity").navigation();// 2. 跳转并携带参数ARouter.getInstance().build("/test/1") .withLong("key1", 666L) .withString("key3", "888") .withObject("key4", new Test("Jack", "Rose")) .navigation(); 添加混淆规则(如果使用了Proguard) 123456789-keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;-keep public class com.alibaba.android.arouter.facade.**&#123;*;&#125;-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125;# 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider# 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现# -keep class * implements com.alibaba.android.arouter.facade.template.IProvider 使用 Gradle 插件实现路由表的自动加载 1234567891011apply plugin: &apos;com.alibaba.arouter&apos;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &quot;com.alibaba:arouter-register:?&quot; &#125;&#125; 可选使用，通过 ARouter 提供的注册插件进行路由表的自动加载(power by AutoRegister)， 默认通过扫描 dex 的方式进行加载通过 gradle 插件进行自动注册可以缩短初始化时间解决应用加固导致无法直接访问dex 文件，初始化失败的问题，需要注意的是，该插件必须搭配 api 1.3.0 以上版本使用！ 七、进阶用法 通过URL跳转1234567891011// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可public class SchameFilterActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); ARouter.getInstance().build(uri).navigation(); finish(); &#125;&#125; AndroidManifest.xml 12345678910111213&lt;activity android:name=".activity.SchameFilterActivity"&gt; &lt;!-- Schame --&gt; &lt;intent-filter&gt; &lt;data android:host="m.aliyun.com" android:scheme="arouter"/&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.BROWSABLE"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 解析URL中的参数 123456789101112131415161718192021222324252627282930313233343536373839404142// 为每一个参数声明一个字段，并使用 @Autowired 标注// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象@Route(path = "/test/activity")public class Test1Activity extends Activity &#123; @Autowired public String name; @Autowired int age; @Autowired(name = "girl") // 通过name来映射URL中的不同参数 boolean boy; @Autowired TestObj obj; // 支持解析自定义对象，URL中使用json传递 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); // ARouter会自动对字段进行赋值，无需主动获取 Log.d("param", name + age + boy); &#125;&#125;// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：@Route(path = "/yourservicegroupname/json")public class JsonServiceImpl implements SerializationService &#123; @Override public void init(Context context) &#123; &#125; @Override public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123; return JSON.parseObject(text, clazz); &#125; @Override public String object2Json(Object instance) &#123; return JSON.toJSONString(instance); &#125;&#125; 声明拦截器(拦截跳转过程，面向切面编程) 123456789101112131415161718// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行@Interceptor(priority = 8, name = "测试用拦截器")public class TestInterceptor implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; ... callback.onContinue(postcard); // 处理完成，交还控制权 // callback.onInterrupt(new RuntimeException("我觉得有点异常")); // 觉得有问题，中断路由流程 // 以上两种至少需要调用其中一种，否则不会继续路由 &#125; @Override public void init(Context context) &#123; // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次 &#125;&#125; 处理跳转结果 123456789101112// 使用两个参数的navigation方法，可以获取单次跳转的结果ARouter.getInstance().build("/test/1").navigation(this, new NavigationCallback() &#123; @Override public void onFound(Postcard postcard) &#123; ... &#125; @Override public void onLost(Postcard postcard) &#123; ... &#125;&#125;); 自定义全局降级策略 12345678910111213// 实现DegradeService接口，并加上一个Path内容任意的注解即可@Route(path = "/xxx/xxx")public class DegradeServiceImpl implements DegradeService &#123; @Override public void onLost(Context context, Postcard postcard) &#123; // do something. &#125; @Override public void init(Context context) &#123; &#125;&#125; 为目标页面声明更多信息 1234// 我们经常需要在目标页面中配置一些属性，比方说"是否需要登陆"之类的// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断@Route(path = "/test/activity", extras = Consts.XXXX) 通过依赖注入解耦:服务管理(一) 暴露服务 12345678910111213141516171819// 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; String sayHello(String name);&#125;// 实现接口@Route(path = "/yourservicegroupname/hello", name = "测试服务")public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return "hello, " + name; &#125; @Override public void init(Context context) &#123; &#125;&#125; 通过依赖注入解耦:服务管理(二) 发现服务 12345678910111213141516171819202122232425262728public class Test &#123; @Autowired HelloService helloService; @Autowired(name = "/yourservicegroupname/hello") HelloService helloService2; HelloService helloService3; HelloService helloService4; public Test() &#123; ARouter.getInstance().inject(this); &#125; public void testService() &#123; // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务) helloService.sayHello("Vergil"); helloService2.sayHello("Vergil"); // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType helloService3 = ARouter.getInstance().navigation(HelloService.class); helloService4 = (HelloService) ARouter.getInstance().build("/yourservicegroupname/hello").navigation(); helloService3.sayHello("Vergil"); helloService4.sayHello("Vergil"); &#125;&#125; 八、更多功能 初始化中的其他设置 123ARouter.openLog(); // 开启日志ARouter.openDebug(); // 使用InstantRun的时候，需要打开该开关，上线之后关闭，否则有安全风险ARouter.printStackTrace(); // 打印日志的时候打印线程堆栈 详细的API说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 构建标准的路由请求ARouter.getInstance().build("/home/main").navigation();// 构建标准的路由请求，并指定分组ARouter.getInstance().build("/home/main", "ap").navigation();// 构建标准的路由请求，通过Uri直接解析Uri uri;ARouter.getInstance().build(uri).navigation();// 构建标准的路由请求，startActivityForResult// navigation的第一个参数必须是Activity，第二个参数则是RequestCodeARouter.getInstance().build("/home/main", "ap").navigation(this, 5);// 直接传递BundleBundle params = new Bundle();ARouter.getInstance() .build("/home/main") .with(params) .navigation();// 指定FlagARouter.getInstance() .build("/home/main") .withFlags(); .navigation();// 获取FragmentFragment fragment = (Fragment) ARouter.getInstance().build("/test/fragment").navigation(); // 对象传递ARouter.getInstance() .withObject("key", new TestObj("Jack", "Rose")) .navigation();// 觉得接口不够多，可以直接拿出Bundle赋值ARouter.getInstance() .build("/home/main") .getExtra();// 转场动画(常规方式)ARouter.getInstance() .build("/test/activity2") .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom) .navigation(this);// 转场动画(API16+)ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);// ps. makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前ActivityARouter.getInstance() .build("/test/activity2") .withOptionsCompat(compat) .navigation(); // 使用绿色通道(跳过所有的拦截器)ARouter.getInstance().build("/home/main").greenChannel().navigation();// 使用自己的日志工具打印日志ARouter.setLogger();// 使用自己提供的线程池ARouter.setExecutor(); 获取原始的URI 1String uriStr = getIntent().getStringExtra(ARouter.RAW_URI); 重写跳转URL 123456789101112131415161718192021// 实现PathReplaceService接口，并加上一个Path内容任意的注解即可@Route(path = "/xxx/xxx") // 必须标明注解public class PathReplaceServiceImpl implements PathReplaceService &#123; /** * For normal path. * * @param path raw path */ String forString(String path) &#123; return path; // 按照一定的规则处理之后返回处理后的结果 &#125; /** * For uri type. * * @param uri raw uri */ Uri forUri(Uri uri) &#123; return url; // 按照一定的规则处理之后返回处理后的结果 &#125;&#125; 生成路由文档 123456789101112// 更新 build.gradle, 添加参数 AROUTER_GENERATE_DOC = enable// 生成的文档路径 : build/generated/source/apt/(debug or release)/com/alibaba/android/arouter/docs/arouter-map-of-$&#123;moduleName&#125;.jsonandroid &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: &quot;enable&quot;] &#125; &#125; &#125;&#125; 九、其他 路由中的分组概念 SDK中针对所有的路径(/test/1 /test/2)进行分组，分组只有在分组中的某一个路径第一次被访问的时候，该分组才会被初始化 可以通过 @Route 注解主动指定分组，否则使用路径中第一段字符串(/*/)作为分组 注意：一旦主动指定分组之后，应用内路由需要使用 ARouter.getInstance().build(path, group) 进行跳转，手动指定分组，否则无法找到1@Route(path = "/test/1", group = "app") 拦截器和服务的异同 拦截器和服务所需要实现的接口不同，但是结构类似，都存在 init(Context context) 方法，但是两者的调用时机不同 拦截器因为其特殊性，会被任何一次路由所触发，拦截器会在ARouter初始化的时候异步初始化，如果第一次路由的时候拦截器还没有初始化结束，路由会等待，直到初始化完成。 服务没有该限制，某一服务可能在App整个生命周期中都不会用到，所以服务只有被调用的时候才会触发初始化操作 旧版本gradle插件的配置方式 1234567891011121314151617181920212223apply plugin: &apos;com.neenbedankt.android-apt&apos;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos; &#125;&#125;apt &#123; arguments &#123; AROUTER_MODULE_NAME project.getName(); &#125;&#125;dependencies &#123; compile &apos;com.alibaba:arouter-api:x.x.x&apos; apt &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125; Kotlin项目中的配置方式 1234567891011121314// 可以参考 module-kotlin 模块中的写法apply plugin: &apos;kotlin-kapt&apos;kapt &#123; arguments &#123; arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName()) &#125;&#125;dependencies &#123; compile &apos;com.alibaba:arouter-api:x.x.x&apos; kapt &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125; 十、Q&amp;A “W/ARouter::: ARouter::No postcard![ ]” 这个Log正常的情况下也会打印出来，如果您的代码中没有实现DegradeService和PathReplaceService的话，因为ARouter本身的一些功能也依赖 自己提供的Service管理功能，ARouter在跳转的时候会尝试寻找用户实现的PathReplaceService，用于对路径进行重写(可选功能)，所以如果您没有 实现这个服务的话，也会抛出这个日志 推荐在app中实现DegradeService、PathReplaceService “W/ARouter::: ARouter::There is no route match the path [/xxx/xxx], in group [xxx][ ]” 通常来说这种情况是没有找到目标页面，目标不存在 如果这个页面是存在的，那么您可以按照下面的步骤进行排查 检查目标页面的注解是否配置正确，正确的注解形式应该是 (@Route(path=”/test/test”), 如没有特殊需求，请勿指定group字段，废弃功能) 检查目标页面所在的模块的gradle脚本中是否依赖了 arouter-compiler sdk (需要注意的是，要使用apt依赖，而不是compile关键字依赖) 检查编译打包日志，是否出现了形如 ARouter:Compiler &gt;&gt;&gt; xxxxx 的日志，日志中会打印出发现的路由目标 启动App的时候，开启debug、log(openDebug/openLog), 查看映射表是否已经被扫描出来，形如 D/ARouter::: LogisticsCenter has already been loaded, GroupIndex[4]，GroupIndex &gt; 0 开启InstantRun之后无法跳转(高版本Gradle插件下无法跳转)？​ 因为开启InstantRun之后，很多类文件不会放在原本的dex中，需要单独去加载，ARouter默认不会去加载这些文件，因为安全原因，只有在开启了openDebug之后 ARouter才回去加载InstantRun产生的文件，所以在以上的情况下，需要在init之前调用openDebug TransformException:java.util.zip.ZipException: duplicate entry …. ARouter有按组加载的机制，关于分组可以参考 6-1 部分，ARouter允许一个module中存在多个分组，但是不允许多个module中存在相同的分组，会导致映射文件冲突 Kotlin类中的字段无法注入如何解决？ 首先，Kotlin中的字段是可以自动注入的，但是注入代码为了减少反射，使用的字段赋值的方式来注入的，Kotlin默认会生成set/get方法，并把属性设置为private 所以只要保证Kotlin中字段可见性不是private即可，简单解决可以在字段上添加 @JvmField 通过URL跳转之后，在intent中拿不到参数如何解决？ 需要注意的是，如果不使用自动注入，那么可以不写 ARouter.getInstance().inject(this)，但是需要取值的字段仍然需要标上 @Autowired 注解，因为 只有标上注解之后，ARouter才能知道以哪一种数据类型提取URL中的参数并放入Intent中，这样您才能在intent中获取到对应的参数 新增页面之后，无法跳转？ ARouter加载Dex中的映射文件会有一定耗时，所以ARouter会缓存映射文件，直到新版本升级(版本号或者versionCode变化)，而如果是开发版本(ARouter.openDebug())， ARouter 每次启动都会重新加载映射文件，开发阶段一定要打开 Debug 功能]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram与VirtualView]]></title>
    <url>%2Fposts%2Fb1fd08a9.html</url>
    <content type="text"><![CDATA[VirtualViewTangram中已经实现了页面布局的动态化，我们可以通过配置json文件自由的布局；但还有一个局限性，json中使用的卡片或者组件的type，必须是注册OK的（也就是在客户端已经实现好的）才能使用；如果想要在原来的版本中新增一个type类型的组件，这是没有办法做到的，还是只能通过升级客户端来实现。 于是，VirtualView出现了。 基布局描术文件是一个xml文件，并附带一个json数据文件:描述布局文件示例：（其中的相关数据来源都可以从数据json文件中使用表达式获取） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 &lt;RatioLayout orientation="H" layoutWidth="match_parent" layoutHeight="wrap_content" background="#f8f8f8"&gt; &lt;VHLayout layoutRatio="1" orientation="V" layoutWidth="0" layoutHeight="match_parent" background="#f8f8f8"&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="120.5" scaleType="fit_xy" src="$&#123;picture_2&#125;"/&gt; &lt;VLine layoutWidth="match_parent" layoutHeight="0.5" paintWidth="0.5" orientation="H" color="#e8ecef" /&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_5&#125;"/&gt; &lt;/VHLayout&gt; &lt;VLine layoutWidth="0.5" layoutHeight="match_parent" paintWidth="0.5" orientation="V" color="#e8ecef" /&gt; &lt;VHLayout layoutRatio="1" orientation="V" layoutWidth="0" layoutHeight="match_parent" background="#f8f8f8"&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_3&#125;"/&gt; &lt;VLine layoutWidth="match_parent" layoutHeight="0.5" paintWidth="0.5" orientation="H" color="#e8ecef" /&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_4&#125;"/&gt; &lt;VLine layoutWidth="match_parent" layoutHeight="0.5" paintWidth="0.5" orientation="H" color="#e8ecef" /&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_6&#125;"/&gt; &lt;/VHLayout&gt;&lt;/RatioLayout&gt; 数据json文件示例： 1234567&#123; "picture_2": "http://xxxx/images/59afb155c769f.png", "picture_3": "http://xxxx/images/59afb303042ca.png", "picture_4": "http://xxxx/images/59afb303042cb.png", "picture_5": "http://xxxx/images/59afb36cf1eb8.png", "picture_6": "http://xxxx/images/59afb303042cd.png"&#125; xml文件需要经过编绎生成目标文件才可加载使用，如果用于项目中一般下发的都是经过编绎后的文件，也可以在客户端实时编绎。 一个xml就是一个组件，Tangram通过加载这个xml文件即可使用该xml文件所描术的组件，从而实现了动态新增组件类型的功能。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tragram Android使用指南]]></title>
    <url>%2Fposts%2F37457476.html</url>
    <content type="text"><![CDATA[具体组件可以查看官方文档：http://tangram.pingguohe.net/docs/android/access-tangram 接入Tangram代码1.引入依赖12// gradlecompile &apos;com.alibaba.android:tangram:1.0.0@aar&apos; 或者 1234567// maven&lt;dependency&gt; &lt;groupId&gt;com.alibaba.android&lt;/groupId&gt; &lt;artifactId&gt;tangram&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;type&gt;aar&lt;/type&gt;&lt;/dependency&gt; 2.初始化 Tangram 环境应用全局只需要初始化一次，提供一个通用的图片加载器，一个应用内通用的ImageView类型（通常情况下每个应用都有自定义的 ImageView，如果没有的话就提供系统的 ImageView 类）。 12345678TangramBuilder.init(context, new IInnerImageSetter() &#123; @Override public &lt;IMAGE extends ImageView&gt; void doLoadImageUrl(@NonNull IMAGE view, @Nullable String url) &#123; //假设你使用 Picasso 加载图片 Picasso.with(context).load(url).into(view); &#125;&#125;, ImageView.class); 3.初始化 TangramBuilder在 Activity 中初始化TangramBuilder，假设你的 Activity 是TangramActivity。 1TangramBuilder.InnerBuilder builder = TangramBuilder.newInnerBuilder(TangramActivity.this); 这一步 builder 对象生成的时候，内部已经注册了框架所支持的所有组件和卡片，以及默认的IAdapterBuilder（它被用来创建 绑定到 RecyclerView 的Adapter）。 4.注册自定义的卡片和组件1234567//TangramBuilder中已经预先注册了许多组件及卡片，可直接使用；此处只需要注册自定义的组件及卡片即可builder = TangramBuilder.newInnerBuilder(this);builder.registerCell("自定义名字1", 自定义组件1.class);builder.registerCell("自定义名字2", 自定义组件2.class);builder.registerCard("自定义名字3", 自定义卡片3.class);builder.registerCell(数字, 自定义组件4.class);builder.registerVirtualView("VirtualView名字");//Tangram对VirtualView的支持 一般情况下，内置卡片的类型已经满足大部分场景了，业务方主要是注册一下自定义组件。注册组件有3种方式： 注册绑定组件类型和自定义View，比如builder.registerCell(1, TestView.class);。意思是类型为1的组件渲染时会被绑定到TestView的实例上，这种方式注册的组件使用通用的组件模型BaseCell。 注册绑定组件类型、自定义 model、自定义View，比如builder.registerCell(1, TestCell.class, TestView.class);。意思是类型为1的组件使用自定义的组件模型TestCell，它应当继承于BaseCell，在渲染时会被绑定到TestView的实例上。 注册绑定组件类型、自定义model、自定义ViewHolder，比如builder.registerCell(1, TestCell.class, new ViewHolderCreator&lt;&gt;(R.layout.item_holder, TestViewHolder.class, TestView.class));。意思是类型为1的组件使用自定义的组件模型TestCell，它应当继承于BaseCell，在渲染时以R.layout.item_holder为布局创建类型为TestView的 view，并绑定到类型为TestViewHolder的 viewHolder 上，组件数据被绑定到定到TestView的实例上。 一般情况下，使用前两种方式注册组件即可。至于组件开发规范，请参考组件开发。 5.生成TangramEngine实例在上述基础上调用： 1TangramEngine engine = builder.build(); 6.绑定业务 support 类到 engineTangram 内部提供了一些常用的 support 类辅助业务开发，业务方也可以自定义所需要的功能模块注册进去。以下常用三个常用的support，分别处理点击、卡片数据加载、曝光逻辑，详情请参考文档。 123engine.register(SimpleClickSupport.class, new XXClickSupport());engine.register(CardLoadSupport.class, new XXCardLoadSupport());engine.register(ExposureSupport.class, new XXExposureSuport()); 7.绑定 recyclerView1234setContentView(R.layout.main_activity);RecyclerView recyclerView = (RecyclerView) findViewById(R.id.main_view);...engine.bindView(recyclerView); 8.监听 recyclerView 的滚动事件12345678recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); //在 scroll 事件中触发 engine 的 onScroll，内部会触发需要异步加载的卡片去提前加载数据 engine.onScrolled(); &#125;&#125;); 9.设置悬浮类型布局的偏移（可选）如果你的 recyclerView 上方还覆盖有其他 view，比如底部的 tabbar 或者顶部的 actionbar，为了防止悬浮类 view 和这些外部 view 重叠，可以设置一个偏移量。 1engine.getLayoutManager().setFixOffset(0, 40, 0, 0); 10.设置卡片预加载的偏移量（可选）在页面滚动过程中触发engine.onScrolled()方法，会去寻找屏幕外需要异步加载数据的卡片，默认往下寻找5个，让数据预加载出来，可以修改这个偏移量。 1engine.setPreLoadNumber(3) 11.加载数据并传递给 engine数据一般是调用接口加载远程数据，这里演示的是 mock 加载本地的数据： 12345678String json = new String(getAssertsFile(this, "data.json")); JSONArray data = null; try &#123; data = new JSONArray(json); engine.setData(data); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; 12.退出的时候销毁 engine1engine.destroy(); 通过主动调用 destroy 方法，可以释放内部的资源，比如清理 adapter、清理事件总线缓存的未处理消息、注销广播等。注意调用 destroy 方法之后就不需要调用 unbind 方法了。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 TAC 上使用 Tangram4 TAC SDK]]></title>
    <url>%2Fposts%2F1365aa6d.html</url>
    <content type="text"><![CDATA[背景Tangram 客户端 SDK 对后端数据格式有标准化的需求，而后端接口格式千千万万，总不会是每个接口格式都能如你所愿，Tangram4TAC 就是为了解决这种问题构建，以标准化模型来在 TAC 在构建一个 Tangram 页面。 SDK 介绍 一期 SDK 非常简单，尽量精简抽象，主要提供了 Tangram 组件模型的定义和默认的数据转换输出服务（称之为 render）。如上图所示，橘色部分为 SDK 提供的核心模型对象，Cell 是组件定义，Container 是容器定义，Style 是样式定义。浅绿色部分为 Tangram 内置的布局类型组件定义。白色部分为业务自定义组件，不集成在 SDK 内部，用户可以自己扩展任意部分来实现自己的组件 model 对象。 Cell、Container、Style 的属性定义也是按照现有 Tangram 的规范来定义，业务字段需要用户自己继承对应的类来扩展。 当我们用这些模型对象构建好 Tangram 组件树之后，就需要对外输出数据，一般情况下对外输出的不是原始的对象，可能是需要转换成 JSON 或者 Map 对象，过程中还需要对字段进行一些处理。SDK 内提供了几个辅助工具： @FieldExcluder 注解：model 内部可能会有一些用来保存状态，传递上下文信息的字段，并不需要最终输出属性，通过此注解将这些属性在转换过程中过滤掉，减少冗余数据。 @FieldNameMapper 注解：默认情况下，我们期望 model 内部的属性定义名和输出字段名一致，但也有存在不兼容的情况，比如 Style 里的背景色字段要求按照 CSS 的规范输出 background-color 属性名，而 JAVA 的变量名不支持这种规范，所以可以通过该注解提供一个别名，比如： 12@FieldNameMapper(key = &quot;background-color&quot;)protected String backgroundColor; SDK 默认的 render 类 DefaultRender 遵循上述原则，并将 Cell 对象转换成 Map 结构。用户也可以提供自定义的 render 对象给 Cell 更改转换逻辑。 举例说明上述就是 SDK 的核心功能，非常的精简，下面用一个例子说明使用流程。以天猫首页 icon 区改造为例。 1.实现一个 TmallCell 继承自 Cell，内部封装天猫客户端环境下扩展的公共业务字段。 12345678910111213141516171819202122232425262728293031323334353637abstract public class TmallCell&lt;T extends Style&gt; extends Cell&lt;T&gt; &#123; protected String action; protected String title; protected String imgUrl; public TmallCell() &#123; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getImgUrl() &#123; return imgUrl; &#125; public void setImgUrl(String imgUrl) &#123; this.imgUrl = imgUrl; &#125; public String getAction() &#123; return action; &#125; public void setAction(String action) &#123; this.action = action; &#125;&#125; 2.实现 Icon 继承自 TmallCell，封装 icon 自身的数据。 12345678910111213141516171819202122232425262728293031323334353637public class Icon extends TmallCell&lt;IconStyle&gt; &#123; private String title; private String imgUrl; private String bizId; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getImgUrl() &#123; return imgUrl; &#125; public void setImgUrl(String imgUrl) &#123; this.imgUrl = imgUrl; &#125; public String getBizId() &#123; return bizId; &#125; public void setBizId(String bizId) &#123; this.bizId = bizId; &#125; @Override public String getType() &#123; return &quot;icon&quot;; &#125;&#125; 3.实现 IconStyle 继承自 Style，封装 icon 自身的特有样式属性。 123456789101112public class IconStyle extends Style &#123; protected String titleColor; public String getTitleColor() &#123; return titleColor; &#125; public void setTitleColor(String titleColor) &#123; this.titleColor = titleColor; &#125;&#125; 4.调用接口获取业务数据后，准备构造组件树，先构造布局容器对象，设置样式，提供一个默认的 render 对象。 12345678910FiveColumnContainer fiveColumnContainer = new FiveColumnContainer();fiveColumnContainer.setId(&quot;icon&quot;);FlowStyle style = new FlowStyle();style.setBackgroundColor(&quot;#FFFFFF&quot;);style.setPadding(6, 12, 11, 12);style.setMargin(-80, 0, -26, 0);style.setCols(new float[]&#123;10.1f, 102.1f&#125;);style.sethGap(6);style.setzIndex(5);fiveColumnContainer.setStyle(style); 5.根据数据构造 Icon 组件对象，并设置样式和属性。 1234567891011121314for (int i = 0; i &lt; 5; i++) &#123; IconStyle iconStyle = new IconStyle(); iconStyle.setTitleColor(&quot;#FF0000&quot;); if (i == 1) &#123; iconStyle.setDisableReuse(true); &#125; Icon icon = new Icon(); icon.setStyle(iconStyle); icon.setId(String.valueOf(i)); icon.setTitle(&quot;icon_&quot; + i); icon.setImgUrl(&quot;https://gw.alicdn.com/tfs/TB1ISdWSFXXXXbFXXXXXXXXXXXX-146-147.png&quot;); icon.setAction(&quot;https://www.tmall.com/&quot;); fiveColumnContainer.addChild(icon);&#125; 6.调用 render 方法输出数据返回给 TAC。 12Map&lt;String, Object&gt; result = (Map&lt;String, Object&gt;) fiveColumnContainer.render();resultList.add(result); 上述流程总结起来如图：]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件的动态化方案-Tangram2.0]]></title>
    <url>%2Fposts%2F270f0900.html</url>
    <content type="text"><![CDATA[Tangram 2.0 库Android Tangram-Android Virtualview-Android iOS Tangram-iOS Virtualview-iOS 背景技术背景一直以来，无线应用都在不断寻求动态化页面的解决方案，在阿里巴巴集团内，除了风风火火地 Weex 项目外，各个团队都有大大小小的解决方案。我们猫客一直持续基于 Tangram 方案来解决页面动态化的问题，然而在面对持续升级的业务需求时，原有的开发模式也慢慢变得无法胜任，本年度以来，我们 Tangram 体系在各个层面都进行了大跨度的技术升级（可参考文章天猫APP改版之首页架构&amp;开发模式全面升级），本文再详细介绍一下页面内组件体系升级方案。 老组件体系的问题在原有的 Tangram 体系里，主要解决了页面内布局结构的动态化能力，通过 json 数据描述可以组合出常用的页面结构。然而页面内具体的坑位样式，我们称之为业务组件，是采用常规的 native 代码开发的，除非内置了足够多的逻辑，否则组件的样式调整或者新组件的开发都要发布版本，无法满足业务节奏；当然我们也尝试过使用 Weex 开发业务组件贴到页面上，但是在体验和性能上还是有较大的缺陷。 所以总结起来，就是两点问题： 业务组件无法动态更新； 现有的动态组件方案较重，影响性能和体验； 解决之道对于上述问题，解决思路其实是比较通用的，要动态更新界面视图，就需要用界面模板描述视图，模板与数据分离。将动态下发的模板和数据在端上绑定渲染。要提升性能，也有三大着力点——减少视图层级与个数，结构尽量扁平化；异步布局渲染流程，解放主线程计算量；回收与复用组件，减少内存开销。 新的组件体系就是在模板化描述视图，动态更新视图，减少视图层级几个方面做文章，至于组件的回收复用，则是在页面级别统一完成；而异步布局渲染流程，则是后续的优化方向。 新的组件方案称之为 VirtualView，简称 VV，也称为2.0组件，它的设计遵循以下几个思路： 以了一种虚拟化开发基础组件的技术，使用方只要按照指定协议实现一个基础组件的尺寸计算、绘制逻辑、布局逻辑，即能实现在宿主容器的 canvas 里实现直接绘制 UI 内容的，让最终渲染出来的视图结构呈现扁平化，提升组件渲染性能。同时为了解决虚拟化 View 带来的原生 View 的能力损失的问题，它支持加载和渲染原生基础组件，两者组合产生合力，既能减少开销，又能满足特殊场景下的业务需求。 内置实现了一系列基础组件，可以让使用方直接上手尝试；而搭建业务组件的方式采用 XML 模板来编写，配套 XML 模板更新 sdk，这使得业务组件动态更新成为了可能。XML 模板里还支持写数据绑定的表达式，在样式动态化、数据动态化的场景下能非常方便地实现业务需求。 XML 模板里涉及到的基础节点、属性、字符串资源等都被提前编译成二进制资源，客户端加载通过加载编译后的模板数据来创建视图。 设计方案整体架构先从整体上预览一下整个方案的大体结构： 自下往上，自左往右的顺序介绍各个模块： 基础模板加载器负责加载编译后的模板数据，比如从文件加载、从二进制数组加载、从网络加载，将编译后的二进制模板数据加载到内存里，通过组件加载器、字符串资源加载器、表达式资源加载器等提取出其中的资源。 框架还内置了基础组件，包括原子的基础组件如文本、图片、线条，还包括布局类型的基础组件，比如线性布局、帧布局、网格布局等；每一种类型的基础组件提供了原生 Native 版本的实现和虚拟化的实现，用户也可以自定义自己的基础组件注册到框架内部，组件构造器通过加载好的组件数据，来构造出整个业务组件树，并添加到宿主容器里，对于虚拟组件，会在渲染阶段绘制到宿主容器的 canvas 上，而原生组件会作为子 View 添加到宿主容器里。 框架内部也提供了基础的表达式能力，主要分两种，一种是简单的数据绑定表达式，一种是简单的逻辑表达式；前者用于在模板里写表达式绑定数据到基础组件的属性上，而后者提供了一种轻量级的逻辑运算能力，可以访问基础组件的属性并更新，实现一些联动效果。 事件管理，本方案聚焦于界面的动态化创建，但对业务逻辑的处理主要还是靠原生的代码实现，因此处理组件的一些常用交互事件，比如组件的点击、长按、触摸、曝光事件等。事件管理模块负责将外部的各个类型的事件处理模块注册进来，当组件发生特定的事件时，找到对应类型的处理模块来调用处理。 宿主容器管理负责对虚拟组件的宿主容器进行构建和回收复用的管理。当原有的组件滑出屏幕后，可以回收到统一的池子里，以便后续复用。 组件管理负责对基础组件进行构建和回收复用管理。当原有的组件滑出屏幕后，除了宿主容器可以回收复用，内部的基础组件对象也可以回收到统一的池子里。如果组件的池子是空的，则在需要的时候构造新的组件。 扩展模块管理则用于注册外部功能扩展模块，当内置的基础能力无法满足业务场景的时候，通过扩展模块注册特定的功能模块，然后编写自定义基础组件来实现特定功能。 模板存储、模板校验、模板更新、模板注册则分别负责模板数据的存储、安全性校验、版本校验、与更新检查与新模板下载、注册模板数据到框架，整体协同来完成业务组件的动态更新，它并不与整个渲染组件的核心框架耦合，可以作为独立模块存在。 配套的工具和服务主要包括模板编写工具、模板编译工具、模板更新服务.模板编写工具用于 XML 的模板的编辑，并调用编译模块编译模板，模板里涉及到的组件资源、字符串资源、表达式资源会分别用对应的模块处理。编译后端模板数据可以上传到模板更新服务里，客户端调用相应的接口检查是否有更新。 运行流程有了上述基础，当我们要开发新的业务组件的时候，除了有新增 Native 逻辑的需求场景（比如新增视频功能），大部分需求都可以告别原生代码的编写，转而编写组件模板。 先编写业务组件的模板。 通过工具将模板数据编译成二进制数据。 客户端加载二进制数据可以有两种路径，一是直接打包到客户端里，写代码加载，另一种是发布到模板管理后台，客户端在线更新到模板数据。 不论哪种方式加载二进制数据，客户端接下来的工作是解析二进制数据里，比如校验版本号，合法性，读取头信息等等。 等要真正创建组件的时候，根据组件名称找到二进制数据，从中解析并创建出真正的组件模型数据。 从模板里创建在组件往往不含有业务数据，因为业务数据是动态性的，用户需要获取到业务数据绑定到组件上，组件的属性里可以写表达式来指定使用哪一个数据字段。 值得注意的是，在上述架构及流程里，描述了一个完整的实践经验，但对于本方案来说，核心点在于提供了对组件从编写到展示流程的实现，其周边的配套设施，并没有内置在框架里，包括客户端上的模板管理、更新、注册模块，以及后端的模板发布服务，因为这些模块往往涉及业务逻辑，且与各个应用的基础设施相关，内置在框架里反而限制了使用方的接入。这里提供一些可供参考的经验： 模板管理后台要能对模板的进行发布、更新，并且按照客户端版本、平台、组件版本、生效优先级等几个维度来管理模板； 模板文件可以存放到 CDN 上供客户端下载，管理平台只是对比下发远信息；下载文件要做足够的校验； 客户端要内置一份打底的模板数据，这样不至于因为模板不存在而出现空窗； 客户端可提供一个统一的模板管理模块，面向全应用提供服务，在合适的时候请求管理平台检查有没有更新，比如启动、用户刷新、推送指令的到达，并且负责下载、文件校验、通知页面刷新等功能；页面刷新可以做优先级区分，比如高优先级的模板更新主动去刷新下页面，而低优先级的可以等二次进入页面或者刷新页面的时候生效； 几个核心设计组件的基础模型对于组件，我们做了如下定义，每一个基础的原子组件或者容器组件都会有以下属性，自定义的基础组件应当继承自基础定义并做扩展。 名称 类型 默认值 描述 id int 0 组件id layoutWidth int/float/enum(match_parent/wrap_content) 0 组件的布局宽度，与Android里的概念类似，写绝对值的时候表示绝对宽高，match_parent表示尽可能撑满父容器提供的宽高，wrap_content表示根据自身内容的宽高来布局 layoutHeight int/float/enum(match_parent/wrap_content) 0 组件的布局宽度，与Android里的概念类似，写绝对值的时候表示绝对宽高，match_parent表示尽可能撑满父容器提供的宽高，wrap_content表示根据自身内容的宽高来布局 layoutGravity enum(left/right/top/bottom/v_center/h_center) left|top 描述组件在容器中的对齐方式，left：靠左，right：靠右，top：靠上，bottom：靠底，v_center：垂直方向居中，h_center：水平方向居中，可用或组合描述 autoDimX int/float 1 组件宽高比计算的横向值 autoDimY int/float 1 组件宽高比计算的竖向值 autoDimDirection enum(X/Y/NONE) NONE 组件在布局中的基准方向，用于计算组件的宽高比，与autoDimX、autoDimY配合使用，设置了这三个属性时，在计算组件尺寸时具有更高的优先级。当autoDimDirection=X时，组件的宽度由layoutWidth和父容器决策决定，但高度 = width * (autoDimY / autoDimX)，当autoDimDirection=Y时，组件的高度由layoutHeight和父容器决策决定，但宽度 = height * (autoDimX / autoDimY) minWidth int/float 0 最小宽度 minHeight int/float 0 最小高度 paddingLeft int/float 0 左内边距 paddingRight int/float 0 右内边距 paddingTop int/float 0 上内边距 paddingBottom int/float 0 下内边距 layoutMarginLeft int/float 0 左外边距 layoutMarginRight int/float 0 右外边距 layoutMarginTop int/float 0 上外边距 layoutMarginBottom int/float 0 下外边距 background int 0 背景色 backgroundImage string null 背景图地址 borderWidth int 0 边框宽度 borderColor int 0 边框颜色 visibility enum(visible/invisible/gone) visible 可见性，与Android里的概念类似，visible：可见，invisible：不可见，但占位，gone：不可见也不占位 gravity enum(left/right/top/bottom/v_center/h_center) left|top 描述内容的对齐，比如文字在文本组件里的位置、原子组件在容器里的位置，left：靠左，right：靠右，top：靠上，bottom：靠底，v_center：垂直方向居中，h_center：水平方向居中，可用或组合描述 方案内内置了一系列基础组件，完整的组件列表如下： 虚拟文本组件 原生文本组件 虚拟图片组件 原生图片组件 虚拟线条组件 原生线条组件 虚拟进度条组件 虚拟图形组件 原生翻页布局容器组件 原生滚动布局容器组件 虚拟帧布局容器组件 虚拟比例布局容器组件 虚拟网格布局容器组件 原生网格布局容器组件 虚拟线性布局容器组件 原生线性布局容器组件 虚拟组件上文提到虚拟化开发的组件的技术，简称虚拟组件。很多做性能优化的方案、建议都会提到采用 Canvas 直接绘制的方式来减少 View 的个数，虚拟将这个开发流程做了抽象与规范，可以让开发人员像定义原生组件一样定义虚拟组件。 具体来讲，基础组件需要遵循一个接口的规范，这个口定义了渲染过程中需要的三个流程：计算尺寸阶段、布局阶段、绘制阶段；定义这个三个阶段是为了更好的与系统平台特别是 Android 平台对接，因为在 Android 原生平台下也会有这个三个阶段，在 iOS 平台下则也需要按照本方案里要求的规范去处理。计算尺寸阶段定义要触发一次尺寸计算，需要对其包含的子组件进行计算调用；布局阶段定义了要触发一次布局，将子元素按照计算好的位置尺寸排布，也要对包含的子组件进行布局调用；绘制阶段定义要进行视图绘制，当然也要对起包含的子组件进行绘制的调用；对于虚拟组件，就在这些接口里实现相关逻辑，而对于原生组件，在这些接口实现里调用原生组件的对应逻辑。 不论是虚拟化组件还是原生组件，都采用上述相同的模型来定义，再加上相同的尺寸计算接口、布局接口、绘制接口，这样对于宿主容器来说，包装在内部的组件就不分虚拟化还是原生，一视同仁，暴露给外面的接口也是一样的，只要将宿主容器像普通的 View 一样添加到的视图界面上，就可以在后续的渲染过程中显示出来。如果虚拟组件使用的越多，View 的个数就越少，对于系统来说层级越扁平。以下图示例的组件来说，最终呈现的 View 只有宿主容器和两个图片组件，如果将图片也用虚拟化的方式实现，最终 View 只有一个宿主容器，而界面仍然保持不变。 二进制文件的格式通过 XML 编写的业务组件，并不直接在客户端里运行使用，而是先进行一次二进制序列化操作，原始的 XML 模板文件保存成文件的时候，就是以纯文本的形式存在，会包含很多冗余信息，比如空格、换行、还有重复出现的字符串等，文件体积比较大，以xml解析器去解析的时候，也会需要大量字符串操作，效率和性能不能达到最优。而将它编译成二进制格式，会避免这些问题，比如文件重复出现的字符串只保留一份，通过字符串索引去引用它，所有的组件类型也都会被转换成一个数字索引，在客户端内通过数字索引反过来找到对应的类实例化。这样文件格式会非常紧凑，体积更小。整个设计也借鉴了 Android 系统编译模板文件的思路。它的具体格式说明如下： 按照图中从左往右、从上往下的顺序分别说明每个段的作用： 开始5个字节固定为 ALIVV；相当于我们的文件格式的一个标记。 版本号分三个，分别为主版本号，次版本号和修订版本号，均为 2 个字节；在无重大重构更新时，前两位一般不变，第三位用于组件的业务级别变更升级； 组件区的起始位置和长度，均为 4 个字节；表示这份文件里组件区数据从第几个字节开始，它总共有多少个字节，这样解析这份数据的时候能直接将文件指针定位到特定位置来读取数据。 字符串区的起始位置和长度，均为 4 个字节；表示这份文件里字符串数据从第几个字节开始，它总共有多少个字节。 表达式区的起始位置和长度，均为 4 个字节；表示这份文件里字符串数据从第几个字节开始，它总共有多少个字节。 数据区的起始位置和长度，均为 4 个字节；表示这份文件里附加数据从第几个字节开始，它总共有多少个字节。目前这一区块是作为一种保留区，实际还未使用到。 当前文件所属页编码，2 个字节，唯一标识一个页（保留使用） 当前文件依赖页的个数为 2 个字节，后面为依赖页的 Id，依赖页个数大于 0 表示该页用到了其他页的资源或者代码，在该页加载之前需要确保依赖页必须已经加载；（保留使用） 组件区开始，前 4 个字节表示文件里业务组件个数，目前一个 XML 模板编译成一个二进制文件，故其值固定为 1。每个业务组件前 2 个字节表示业务组件名称字符串的长度，后面为指定长度的字符串字节数据；紧接着是 2 个字节的编译后组件二进制流长度，后面为二进制代码； 字符串区开始，前4个字节表示字符串个数，在我们的框架里，会内置一些系统级别的字符串资源，比如上文5.2开端表格里提到的那些属性名，这些字符串不用序列化到二进制文件里，而模板文件里出现的非系统字符串才会作为资源序列化到二进制文件。每个字符串资源前 4 个字节字符串索引 Id 即它的 hashCode，后面 2 个自己为字符串的长度，再后面为对应的字符串； 逻辑表达式代码表。前 4 个字节表示逻辑表达式资源个数，每个表达式资源前4个自己表示表达式的索引，它是表达式原始字符串的hashCode，后面两个2 个字节表示表达式的长度，后面为对应的表达式内容，它是表达式按照关键字切割后的字符串结构； 扩展数据段是保留为第三方扩展使用； 绑定数据的表达式开发业务组件的时候，基础属性或者样式往往不能在模板里直接写死，而是需要从数据里获取，所以引入了用户数据绑定的表达式，语法和实现上目前比较简单，参考了很多同类的设计，尽可能符合开发人员的直觉。 访问数据属性的表达式 语法上以 ${ 开头，以 } 结束。对于Map，通过 . 操作符进行访问，对于 Array 或者 List 通过 [] 操作符进行访问。 比如： 12$&#123;benefitImgUrl&#125;$&#123;data[0].benefitImgUrl&#125; 条件表达式 用来给那些需要根据数据中某个字段来设置值的属性，语法上以 @{ 开头，以 } 结束，中间部分为表达式的具体内容。 1条件表达式 ? 结果表达式[1] : 结果表达式[2] 当条件表达式成立的时候，使用结果表达式[1]，否则使用结果表达式[2]。 其中： 条件表达式支持布尔类型、字符串类型、JSONObject、JSONArray。 以下场景均为 false： 布尔类型值为 false 字符串为 null 或者 “” 或者 “null” 字符串 “false” 或者 “FALSE” JSONObject 为空或 JSONObject.NULL JSONArray 长度为 0 字段不存在 比如： 1@&#123;$&#123;logoUrl&#125; ? visible : invisible &#125; 考虑到篇幅限制，不能将上述架构和流程中的每一细节完全展开，详情可以参考苹果核这里的文档。 效果与 Tangram 及 TAC 结合VirtualView 方案是 Tangram 的极大补充，可以解决80%场景下的动态化需求，而 Tangram 依赖的数据则通过 TAC 提供解决，三者结合可以形成一个闭环，让一个开发从端到端地解决整块业务的开发。 组件动态下发以双十一期间为例，90%的双十一业务组件都是动态下发的，且随时可根据业务节奏调整。 展望尽管在功能流程上已经逐步稳定，能承载起日常及大促的需求变更，我们的方案还是有很多不足之处的，比如我们期望更高的运行效率、更加扁平化的UI结构、更加方便的开发体验，对此也做了更进一步的规划建设： 功能 计划 提供更加完善的文档和教程、Demo，内外版本同步，建立以 github 为中心的迭代开发机制 17年12月 组件创建、布局计算、数据绑定机制优化，提升性能 18年1月 重构模板编译工具，提升编译开发体验 18年1月 提供预览服务，提升开发效率 18年3月 提供配套的后端数据服务与基础设施，即 TAC 平台开放 18年3月 附录Tangram 2.0 主要更新说明 组件模型的概念升级，从原来的『卡片』+『组件』升级成『布局』+『组件』，即原来的『卡片』认为是一种具有布局能力的组件，具备嵌套另一组件的能力； 页面结构优化，页面下可以直接挂载组件，不需要嵌套一层布局； 组件类型的语义化，从原来的 1、2、3、4…等数字枚举类型定义，升级成字符串类型的定义，兼容解析原有的数字枚举定义； 更好的嵌套布局实现，流式布局在模型描述上支持多层次的嵌套，并优化了 Android 端上的实现方式； margin 去重的实现，同一层级的容器组件或原子组件直接，支持外边距 margin 的去重，使得动态数据下控制间距更方便； 支持 zIndex，无论是容器组件还是原子组件，支持在其样式上配置 zIndex，zIndex 值越大，绘制层次越高； 升级组件开发方式，引入动态化组件开发技术，提升组件动态性，实现组件样式的高效渲染与动态更新； 其他相关的 Tangram 库Android vlayout UltraViewPager iOS LazyScrollView 工具 virtualview_tools]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram Android设计说明]]></title>
    <url>%2Fposts%2F1867f4d.html</url>
    <content type="text"><![CDATA[前言前段时间开源了团队内的vlayout项目，从 Github 上反馈来看，还是深受欢迎。 但如果仅仅是采用 vlayout 搭建页面，使用起来还不是特别灵活，在此基础之上，我们封装了一套动态化调整界面的模块，命名为 Tangram，现在同样已开源——Tangram Android和Tangram iOS。我们希望将它打造成某一特定领域的解决方案，提速业务开发。 基本模型在前面的文章《页面动态化的基础 —— Tangram》里，已经重点介绍了 Tangram 里涉及的几个主要概念和模型设计，这里简单重复一下，将页面拆分成三个层次：页面——卡片——组件。页面指的就是整体可滑动页面实体；卡片指的是页面内可按行划分的一个一个独立区块，组件指的是卡片内部一个独立的、业务级别的单元，它可以是一张图，也可以是文字 + 图的组合。因此整体整个页面可以这样描述：一个页面嵌套了多个卡片，一个卡片嵌套了多个组件。Tangram 体系就是规范了这三层的数据结构描述，将其渲染出一张页面。 架构整体的层次结构如下，我们自底向上进行说明： 整个 Tangram 框架的页面UI搭建基于 vlayout 和 UltraViewPager。vlayout 之前已经提到过了，用来构建多类型、多布局类型的 RecyclerView；UltraViewPager 是 ViewPager 的一种扩展，整合了多种特性，比如横向滑动，竖向滑动，循环滚动等，用来实现 Tangram 内部所需要的轮播滚动卡片；这两个都比较独立，因此独立成库先行开源了，即使不使用 Tangram，也可以单独使用它们。 vlayout 主要提供了一个自定义的 LayoutManager，因此 Tangram 还需要提供一个 RecyclerView 和 Adapter 来才能配合 vlayout 运行。这里的 RecyclerView 可以由外部业务方通过 TangramEngine 注入，也可以内部默认构造。GroupBasicAdapter 则封装了 vlayout 所需要的 Adapter 的逻辑，组件的创建、组件数据的绑定、组件类型的定义等都由它负责。 在 UI 基础之上的便是各种功能逻辑模块： TangramEngine 是核心类，它负责绑定 RecyclerView 到底层 vlayout，绑定页面数据，操作页面数据（包括增、删、改），还提供注册外部服务的接口。 ServiceManager 是服务管理模块，不轮是内部还是外部功能模块，都可以注册到这里，一方面能被 Tangram 内部的其他模块访问到使用，另一方面解耦了框架与业务模块。 Bus 是事件总线，它在内部也被注册到 ServieManager，内部模块和业务使用方都可以使用它进行通信，解耦业务代码。 DataParser 负责解析数据，它将原始数据解析成卡片、组件的 model 对象。框架里提供的是解析 JSON 数据的解析器，也支持扩展解析其他类型的数据。 DataResolver 负责识别卡片、组件并构建对象，解析器解析数据的时候，需要依赖这些 Resolver去识别数据中的卡片或者组件是否合法，Resolver 识别的方式就是去组件库或者卡片库里寻找这些组件是否已经注册过。 与业务相关性较大的就是组件库、卡片库以及相关业务接口。TangramBuilder 是业务方构建 TangramEngine 的入口。组件库里注册了业务方所需有的组件，Tangram 的实例是一个页面一份，因此每个业务方可以分别注册各自所需要的组件，当业务方使用 Tangram 进行业务开发的时候，主要工作可能就在组件的开发上。卡片库注册的是卡片类型，框架里已经内置了一系列卡片，如果业务方有需要可以单独再注册特殊类型的卡片。而 ClickSupport、ExposureSupport 等都是辅助业务开发的功能模块，前者定义了组件点击处理的接口，后者定义了组件曝光处理的接口。它们都被注册到 ServiceManager 里，业务方在组件或者页面内都可以使用它们。 初始化流程 初始化 Tangram 的流程其实比较简单，无非就是构造 TangramEngine 对象，注册业务组件或者卡片，注册服务模块，绑定 RecyclerView，我们在接入文档——接入Tangram代码里详细说明了步骤。这里不一一赘述，在初始化过程中，各个核心模块也都完成了初始化。 运行流程基本流程图 页面数据示例12345678910111213141516171819202122232425262728293031323334353637[ &#123; "id": "banner1", "type": 1, "style": &#123; "aspectRatio": 3.223 &#125;, "items": [ &#123; "bizId":"item1", "type": 110, "msg": "info1" &#125;, &#123; "bizId":"item2", "type": 110, "msg": "info2" &#125; ] &#125;, &#123; "type": 1, "style": &#123; "aspectRatio": 3.223 &#125;, "items": [ &#123; "type": 10, "imgUrl": "https://gw.alicdn.com/tfs/TB1pdJFQpXXXXbUXpXXXXXXXXXX-750-243.png" &#125;, &#123; "type": 10, "imgUrl": "https://gw.alicdn.com/tfs/TB1pdJFQpXXXXbUXpXXXXXXXXXX-750-243.png" &#125; ] &#125;] 整个 Tangram 对界面的动态调整是通过数据来驱动的，所以首先要将原始数据传递给 TangramEngine，由于集团体系内的接口都采用 JSON 数据，Tangram 框架的默认设计也是接收 JSON 格式的数据，不过也支持通过自定义 DataParser 提前将其他格式的数据解析好之后再传给 TangramEngine。以上述的示例的 JSON 数据为例，一个页面下挂载了一个卡片数组，每个卡片都定义了 id、type、style、items节点；items 内部的数组定义的是组件数据，组件也有type、bizId 等业务字段数据。 不论是传递原始 JSON 数据给 TangramEngine还是通过直接解析原始数据，都是通过 DataParser 来完成的，它会按照树型结构解析出对应的卡片和组件的 model 对象，解析过程依赖于相应的卡片 Resolver 和组件 Resolver 来识别卡片、组件是否已注册，关键点就是识别 type 字段。若碰到无法识别的 type，则不会解析出对应的 model 对象。 解析完成之后会得到一个卡片列表，每个列表的卡片 model 元素里持有它所包含的组件列表。 model 列表交给 GroupBasicAdapter 进行处理，首先提取卡片列表，将包含空组件列表的卡片过滤掉，因为它没有东西可以渲染展示，然后创建出 vlayout 所需要的 LayoutHelper 列表，设置它们的样式属性，这样就打通了通过 JSON 数据最终控制布局排版的流程。 同时将所有的组件 model 提取出来成为一个独立的列表，真正交给 GroupBasicAdapter 去渲染数据，组件 model 列表的大小就是 GroupBasicAdapter 的 item 的大小， RecyclerView 也就直接加载组件视图，卡片相对于只负责了布局逻辑的控制，并没有 UI 实体的承载。 数据都准备完毕之后，RecyclerView 就驱动 vlayout 里的 LayoutManager 进行渲染和布局。 LayoutManager 首先回调 RecyclerView 内部获取 ViewHolder，若复用池里存在复用的对象，就回调 GroupBasicAdapter 进行数据绑定，否则先回调 GroupBasicAdapter 进行组件 ViewHolder 的创建，然后进行数据绑定。ViewHolder 的创建也是通过 Resolver 内部创建 UI 的模块进行构造。 这就是 Tangram 渲染页面的整体流程，本身并没有特别复杂的逻辑。而整个框架里的其他模块比如事件总线、ServiceManager 等都是在组件自身绑定数据，处理业务逻辑过程中会使用到，对于这些功能模块的使用，我们也编写了相应的教程文档供参考。 相关文章本文简要地对 Tangram Android 内部的设计和工作流程进行了说明，有助于对阅读源码的理解。但是建议读者在对 Tangram 有一定了解的基础之上再阅读此文，否则可能有云里雾里的感觉，因为这里涉及到大量的知识点没法完全展开，可以参考以下文章进行了解。 《Tangram是我们对界面动态化的态度》 《页面动态化的基础 —— Tangram》 《Tangram 的基础 —— vlayout（Android）》 《Tangram Android 使用指南》]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram1.0技术架构]]></title>
    <url>%2Fposts%2F6aeb1897.html</url>
    <content type="text"><![CDATA[Tangram作为一个面向常规业务产品的解决方案由3个部分组成： Tangram SDK：目前Tangram 1.0开源了iOS和Android两个平台的SDK，负责端上的界面渲染。Tangram SDK基于两个自建的高效组件复用容器（VLayout-Android和LazyScroll-iOS），开发的界面视图生成器。 Tangram AC：Tangram App Container，是整个Tangram体系中的业务核心。负责把模板和数据按照业务逻辑进行组装，并输出给SDK。 Tangram OP：Tangram Operator，是Tangram控制台，是业务人员调整界面结构、样式和数据源的控制台。 Tangram SDK 现在我们讨论的是Tangram 1.0架构，也就是正在服务手机天猫和其他几个App的版本。Tangram 2.0将在模型设计和核心技术上都有较大升级，暂不做讨论。 视图分层Tangram以一棵深度为3的树形结构构建视图： 根节点是Tangram View。Tangram View是Tangram的最终产物，与使用者直接交互的接口，一个View实例。 第二层节点被定义为布局。布局是一个起到容器作用的View实例，被要求遵守Tangram布局接口规范。一般来说一个布局会独占Tangram View的一行，多个布局依次向下排列。此外还会有特殊布局，如：浮动布局，是漂浮在屏幕上的一个布局，可以被拖动到任何位置。（访问Tangram主页 - 内置布局支持，了解更多布局） 叶子节点是组件。组件就是要展示业务信息的View，是Tangram中的原子View。相比布局而言，开发一个组件的限制要小很多，只需要实现少数几个方法即可。把任意一个自定义的View转化为Tangram组件都非常方便，这也是Tangram所倡导的：把任意正在使用的视图组件快速转化为Tangram视图。 Tangram ViewTangram View作为整个体系的核心产物，是基于上文提到过的LazyScrollView（iOS）和VLayout（Android）开发的。其最主要的作用是在运行时处理上述三层结构中组件的回收和复用。 Tangram View的回收和复用基于一个双索引结构。在渲染准备期需要提前知晓界面中全部叶子节点的尺寸和相对根节点的相对位置，给予位置和尺寸信息构建两个索引：所有组件顶部相对位置顺序的倒排和底部相对位置的倒排。当整个界面中出现组件的增减或位置变化，都需要调用一次Reload操作重建索引，当然创建索引过程采用了效率较高的排序算法。 渲染初始状态或屏幕发生滚动后，Tangram View会拿到当前屏幕的可视范围相对根节点的坐标，并快速在上述双索引结构中找到处在可视范围内的组件集合。然后，可视组件集合与当前存活组件集合分别相减就可以得到需要构造的新组件和可以回收的旧组件。先把旧组件标记为可被回收（注意：这里除了标记，不做任何其他操作），加入复用池，再遍历新组件集合：看复用池里有没有同类型组件可以被复用，若没有则调用工厂构造一个新的。 Tangram BusTangram Bus是Tangram提供的一个事件总线，主要为了避免各个模块为了需要相互通信而造成耦合。Tangram Bus的设计思想与常规的事件总线设计大同小异，使用方法也是采用监听模式：需要响应时间的模块注册一个监听方法到总线，而其他模块产生响应事件后会通知总线，总线则会调用监听方法。这里通过两个例子来说明Tangram Bus的作用： 跳转操作：界面的跳转逻辑是有Controller层负责的，而触发点击的一定是组件。为了避免组件和C层的耦合，C注册一个跳转的监听跳转事件的方法到总线，而组件发生需要跳转的操作时，会抛一个跳转事件到总线里，并在事件中带上跳转必需的信息。 索引重建：上文提到组件位置或尺寸发生变化需要触发索引重建，所以Tangram Core会注册一个方法监听位置或尺寸变更事件，当组件或布局发生变化则抛一个响应事件到总线。 Tangram AC主要目的Tangram AC是一个后端系统，是一个App容器，主要目的是通过规范化的开发模式打破后端开发在流程和环境上的壁垒，并通过容器本身的性能和稳定性保障绕过经验壁垒，给前端工程师一个直接开发后端逻辑的机会。 在传统的开发模式里，一个功能的开发流程至少要包括：接口约定、Mock数据和数据联调，三个需要前后端协作的过程，而且每个过程都会消耗大量资源，而且在我看来这样的消耗是完全没有意义的，不产生价值的。另一方面在现在的产品形态里对动态性要求越来越高，大量逻辑后移，客户端越来越薄。作为直接接触用户的前端开发，对整个产品逻辑的控制却越来越少，给技术驱动的产品创新造成了巨大障碍。 那么问题出在哪里？就是被上述提到过的流程、环境和经验的壁垒区分开来的前端和后端。所以打破这种壁垒，让听到炮火声的前端开发有更多的逻辑控制权，同时把后端开发从无聊的结构转换，数据拼装中解放出来就显得意义非凡。Tangram AC就是基于这样的想法诞生。 流程设计TAC把每一个独立运行的逻辑称为一个服务，多个服务组成一个应用对外提供数据服务。 TAC的每一个服务有一个独立的源码仓库，开发者提交服务源码后在控制台针对特定分支提交打包请求，TAC将把制定源码打成一个可执行的服务包。开发者通过控制台把选定的服务包发布到日常或预发环境中进行测试和联调，通过TAC强制验证后，可以把这个包发布到生产环境直接对线上应用提供服务。 在TAC的运行时，有一套完整的质量监控设施，实时监控整体容器的和各个服务的状态，保证整体容器运行正常。此外，为了保障核心应用的稳定性，TAC还提供了独立部署的机制，也就是说部分核心应用所涉及到的服务允许被独立部署的一个物理集群上独占资源。如此既保证了核心服务的稳定性，不会被稳定性级别更低的应用影响，也保证了核心服务在大量占用资源时不会拖慢其他应用。 Tangram OPTangram OP是整个体系最重要的控制台，上文中提到过的布局排布方式等都可以通过OP GUI的方式配置完成，也就是说在部署了OP的体系中，可以直接通过配置生成一张页面结构。并通过OP提供的数据关联功能关联到AC的某个数据服务上，组成一个完整的产品。 关于OP的具体实现不涉及到Tangram的接入，更多是为了提升使用效率，所以在这里不做赘述，日后Tangram OP开源后将做更多介绍。 结语Tangram旨在打造一个常规产品开发新模式，传达一个以创造价值为目的的开发理念，建设一个开发生态： 不为了创新而创新，而为了创造价值而创新，工程师要在有价值的方向上追求极致，而在仅仅能娱乐自己的方向上适可而止 让前端和后端做应该做的事，做更有价值的事，不因某些壁垒而无法更好的创造价值]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vlayout使用说明（二）]]></title>
    <url>%2Fposts%2F2be51ee4.html</url>
    <content type="text"><![CDATA[前言vlayout 的设计思路请参考Tangram 的基础 —— vlayout（Android）。框架已经开源，欢迎移步到 github上指教。本文介绍 vlayout 的基本布局样式上的属性说明。 margin, paddingMargin, padding就是外边距、内边距，概念与Android系统的margin, padding一样，但也有不同的地方： 它不是整个RecyclerView页面的margin和padding，它是每一块LayoutHelper所负责的区域的margin和padding。 一个页面里可以有多个LayoutHelper，意味着不同LayoutHelper可以设置不同的margin和padding。 LayoutHelper的margin和padding与页面RecyclerView的margin和padding可以共存。 目前主要针对非fix类型的LayoutHelper实现了margin和padding，fix类型LayoutHelper内部没有相对位置关系，不处理边距。 接口对于LayoutHelper，调用 12public void setPadding(int leftPadding, int topPadding, int rightPadding, int bottomPadding)public void setMargin(int leftMargin, int topMargin, int rightMargin, int bottomMargin) bgColor, bgImg背景颜色或者背景图，这其实不是布局属性，但是由于在vlayout对视图进行了直接布局，不同区域的视图的父节点都是RecyclerView，如果想要针对某一块区域单独绘制背景，就很难做到了。vlayout框架对此做了特殊处理，对于非fix、非float类型的LayoutHelper，支持配置背景色或背景图。同样目前主要针对非fix类型的LayoutHelper实现这个特性。 接口使用背景色 1public void setBgColor(int bgColor) 使用背景图 首先为LayoutManager提供一个ImageView简单工厂 123456this.mLayoutManager.setLayoutViewFactory(new LayoutViewFactory() &#123; @Override public opinion generateLayoutView(@NonNull Context context) &#123; return new XXImageView(context); &#125; &#125;); 再为LayoutHelper提设置图片加载的Listener 1234567891011121314151617181920212223242526272829baseHelper.setLayoutViewBindListener(new BindListener(imgUrl));baseHelper.setLayoutViewUnBindListener(new UnbindListener(imgUrl));private static class BindListener implements BaseLayoutHelper.LayoutViewBindListener &#123; private String imgUrl; public BindListener(String imgUrl) &#123; this.imgUrl = imgUrl; &#125; @Override public void onBind(View layoutView, BaseLayoutHelper baseLayoutHelper) &#123; //loading image &#125; &#125; private static class UnbindListener implements BaseLayoutHelper.LayoutViewUnBindListener &#123; private String imgUrl; public UnbindListener(String imgUrl) &#123; this. imgUrl = imgUrl; &#125; @Override public void onUnbind(View layoutView, BaseLayoutHelper baseLayoutHelper) &#123; //cancel loading image &#125; &#125; aspectRatio为了保证布局过程中视图的高度一致，我们设计了aspectRatio属性，它是宽与高的比例，LayoutHelper里有aspectRatio属性，通过vlayout添加的视图的LayoutParams也有aspectRatio属性，后者的优先级比前者高，但含义不一样。 LayoutHelper定义的aspectRatio，指的是一行视图整体的宽度与高度之比，当然整体的宽度是减去了RecyclerView和对应的LayoutHelper的margin, padding。 视图的LayoutParams定义的aspectRatio，指的是在LayoutHelper计算出视图宽度之后，用来确定视图高度时使用的，它会覆盖通过LayoutHelper的aspectRatio计算出来的视图高度，因此具备更高优先级。 接口对于LayoutHelper，调用 1public void setAspectRatio(float aspectRatio) 对于LayoutParams，调用 1((VirutalLayoutManager.LayoutParams) layoutParams).mAspectRatio dividerHeightLinearLayoutHelper的属性，LinearLayoutHelper是像ListView一样的线性布局，dividerHeight就是每个组件之间的间距。 接口对于LinearLayoutHelper，调用 1public void setDividerHeight(int dividerHeight) weightsColumnLayoutHelper, GridLayoutHelper的属性，它们都是提供网格状的布局能力，建议使用GridLayoutHelper，它的能力更加强大，参考下文介绍。默认情况下，每个网格中每一列的宽度是一样的，通过weights属性，可以指定让每一列的宽度成比例分配，就像LinearLayout的weight属性一样。 weights属性是一个float数组，每一项代表某一列占父容器宽度的百分比，总和建议是100，否则布局会超出容器宽度；如果布局中有4列，那么weights的长度也应该是4；长度大于4，多出的部分不参与宽度计算；如果小于4，不足的部分默认平分剩余的空间。 接口对于ColumnLayoutHelper, GridLayoutHelper，调用 1public void setWeights(float[] weights) vGap, hGapGridLayoutHelper与StaggeredGridLayoutHelper都有这两个属性，分别控制视图之间的垂直间距和水平间距。 接口对于GridLayoutHelper, StaggeredGridLayoutHelper，调用 12public void setHGap(int hGap)public void setVGap(int vGap) spanCount, spanSizeLookupGridLayoutHelper的属性，参考于系统的GridLayoutManager，spanCount表示网格的列数，默认情况下每一个视图都占用一个网格区域，但通过提供自定义的spanSizeLookUp，可以指定某个位置的视图占用多个网格区域。 接口使用spanCount调用 1public void setSpanCount(int spanCount) 使用spanSizeLookup 1public void setSpanSizeLookup(SpanSizeLookup spanSizeLookup) autoExpandGridLayoutHelper的属性，当一行里视图的个数少于spanCount值的时候，如果autoExpand为true，视图的总宽度会填满可用区域；否则会在屏幕上留空白区域。 接口调用 1public void setAutoExpand(boolean isAutoExpand) laneStaggeredGridLayoutHelper中有这个属性，与GridLayoutHelper里的spanCount类似，控制瀑布流的列数。 接口调用 1public void setLane(int lane) fixAreaAdjusterfix类型的LayoutHelper，在可能需要设置一个相对父容器四个边的偏移量，比如整个页面里有一个固定的标题栏添加在vlayout容器上，vlayout内部的fix类型视图不希望与外部的标题有所重叠，那么就可以设置一个fixAreaAdjuster来做偏移。 接口调用 1public void setAdjuster(FixAreaAdjuster adjuster) alignType, x, yFixLayoutHelper, ScrollFixLayoutHelper, FloatLayoutHelper的属性，表示吸边时的基准位置，有四个取值，分别是TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT。x和y是相对这四个位置的偏移量，最终的偏移量还要受上述的fixAreaAdjuster影响。 TOP_LEFT：基准位置是左上角，x是视图左边相对父容器的左边距偏移量，y是视图顶边相对父容器的上边距偏移量； TOP_RIGHT：基准位置是右上角，x是视图右边相对父容器的右边距偏移量，y是视图顶边相对父容器的上边距偏移量； BOTTOM_LEFT：基准位置是左下角，x是视图左边相对父容器的左边距偏移量，y是视图底边相对父容器的下边距偏移量； BOTTOM_RIGHT：基准位置是右下角，x是视图右边相对父容器的右边距偏移量，y是视图底边相对父容器的下边距偏移量； 接口设置基准调用 1public void setAlignType(int alignType) 设置偏移量调用 12public void setX(int x)public void setY(int y) showTypeScrollFixLayoutHelper的属性，取值有SHOW_ALWAYS, SHOW_ON_ENTER, SHOW_ON_LEAVE。 SHOW_ALWAYS：与FixLayoutHelper的行为一致，固定在某个位置； SHOW_ON_ENTER：默认不显示视图，当页面滚动到这个视图的位置的时候，才显示； SHOW_ON_LEAVE：默认不显示视图，当页面滚出这个视图的位置的时候显示； 调用 1public void setShowType(int showType) stickyStart, offsetStickyLayoutHelper的属性，当视图的位置在屏幕范围内时，视图会随页面滚动而滚动；当视图的位置滑出屏幕时，StickyLayoutHelper会将视图固定在顶部（stickyStart = true）或者底部（stickyStart = false），固定的位置支持设置偏移量offset。 调用 12public void setStickyStart(boolean stickyStart)public void setOffset(int offset)]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vlayout使用说明（一）]]></title>
    <url>%2Fposts%2Fb89a9b41.html</url>
    <content type="text"><![CDATA[前言vlayout 的设计思路请参考Tangram 的基础 —— vlayout（Android）。框架已经开源，欢迎移步到 github上指教。本文介绍 vlayout 的基本使用。 默认实现 默认通用布局实现，解耦所有的View和布局之间的关系: Linear, Grid, 吸顶, 浮动, 固定位置等。 LinearLayoutHelper: 线性布局 GridLayoutHelper: Grid布局， 支持横向的colspan FixLayoutHelper: 固定布局，始终在屏幕固定位置显示 ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等 FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置 ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值 SingleLayoutHelper: 通栏布局，只会显示一个组件View OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素 StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底 StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度 上述默认实现里可以大致分为两类：一是非fix类型布局，像线性、Grid、栏格等，它们的特点是布局在整个页面流里，随页面滚动而滚动；另一类就是fix类型的布局，它们的子节点往往不随页面滚动而滚动。 所有除布局外的组件复用，VirtualLayout将用来管理大的模块布局组合，扩展了RecyclerView，使得同一RecyclerView内的组件可以复用，减少View的创建和销毁过程。 使用版本请参考mvn repository上的最新版本（目前最新版本是1.0.1），最新的 aar 都会发布到 jcenter 和 MavenCentral 上，确保配置了这两个仓库源，然后引入aar依赖： 1234// gradlecompile (&apos;com.alibaba.android:vlayout:1.0.1@aar&apos;) &#123; transitive = true&#125; 或者maven 1234567// pom.xml in maven&lt;dependency&gt; &lt;groupId&gt;com.alibaba.android&lt;/groupId&gt; &lt;artifactId&gt;vlayout&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;type&gt;aar&lt;/type&gt;&lt;/dependency&gt; 初始化LayoutManager 123final RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);final VirtualLayoutManager layoutManager = new VirtualLayoutManager(this);recyclerView.setLayoutManager(layoutManager); 设置回收复用池大小，（如果一屏内相同类型的 View 个数比较多，需要设置一个合适的大小，防止来回滚动时重新创建 View）： 123RecyclerView.RecycledViewPool viewPool = new RecyclerView.RecycledViewPool();recyclerView.setRecycledViewPool(viewPool);viewPool.setMaxRecycledViews(0, 10); 更新：看了很多人写的demo和源码解析后，需求提醒注意上述示例代码里只针对type=0的item设置了复用池的大小，如果你的页面有多种type，需要为每一种类型的分别调整复用池大小参数。 加载数据时有两种方式: 一种是使用 DelegateAdapter, 可以像平常一样写继承自DelegateAdapter.Adapter的Adapter, 只比之前的Adapter需要多重载onCreateLayoutHelper方法。 其他的和默认Adapter一样。 1234567891011121314DelegateAdapter delegateAdapter = new DelegateAdapter(layoutManager, hasConsistItemType);recycler.setAdapter(delegateAdapter);// 之后可以通过 setAdapters 或 addAdapter方法添加DelegateAdapter.AdapterdelegateAdapter.setAdapters(adapters);// orpublic class CustomAdapter extends DelegateAdapter.Adapter &#123; ......&#125;CustomAdapter adapter = new CustomAdapter(data, new GridLayoutHelper());delegateAdapter.addAdapter(adapter); 更新：hasConsistItemType这个参数有时候容易被人忽略，当hasConsistItemType=true的时候，不论是不是属于同一个子adapter，相同类型的item都能复用。表示它们共享一个类型。 当hasConsistItemType=false的时候，不同子adapter之间的类型不共享 另一种是当业务有自定义的复杂需求的时候, 可以继承自VirtualLayoutAdapter, 实现自己的Adapter 123456789101112131415161718192021public class MyAdapter extends VirtualLayoutAdapter &#123; ......&#125;MyAdapter myAdapter = new MyAdapter(layoutManager);//构造 layoutHelper 列表List&lt;LayoutHelper&gt; helpers = new LinkedList&lt;&gt;();GridLayoutHelper gridLayoutHelper = new GridLayoutHelper(4);gridLayoutHelper.setItemCount(25);helpers.add(gridLayoutHelper);GridLayoutHelper gridLayoutHelper2 = new GridLayoutHelper(2);gridLayoutHelper2.setItemCount(25);helpers.add(gridLayoutHelper2);//将 layoutHelper 列表传递给 adaptermyAdapter.setLayoutHelpers(helpers);//将 adapter 设置给 recyclerViewrecycler.setAdapter(myAdapter); 在这种情况下，需要使用者注意在当LayoutHelpers的结构或者数据数量等会影响到布局的元素变化时，需要主动调用setLayoutHelpers去更新布局模式。 Demo 详细代码参考：github 扩展布局如果默认的布局实现满足不了，你的需求，可以注册自定义的LayoutHelper来实现布局逻辑。有三种基类可以供你使用： BaseLayoutHelper：像LinearLayoutHelper、GridLayoutHelper等，内部View可以按行回收的布局，可直接继承此类，主要实现layoutViews()、computeAlignOffset()等方法。 AbstractFullFillLayoutHelper：有些布局内部的View 并不是从上至下排列的顺序，即 Adatper 里的数据顺序和物理视图顺序不一致，那么可能就不能按数据顺序布局和回收，需要一次性布局、一次性回收。主要实现layoutViews()等方法。可参考OnePlusNLayoutHelper。 FixAreaLayoutHelper：fix 类型的布局，子节点不随页面滚动而滚动。主要实现layoutViews()、beforeLayout()、afterLayout()等方法，可参考FixLayoutHelper。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram的基础 vlayout for android]]></title>
    <url>%2Fposts%2Fdf690640.html</url>
    <content type="text"><![CDATA[前言vlayout 是手机天猫 Android 版内广泛使用的一个基础 UI 框架项目 提供了一个用于RecyclerView的自定义的LayoutManger，可以实现不同布局格式的混排，目标是支撑客户端native页面的快速开发。它也是 Tangram 框架的基础模块，现已开源，欢迎移步到 github 上指教。 简介背景Android中UI性能消耗主要来自于两个方面： 布局层次嵌套导致多重measure/layout View控件的创建和销毁 除了从在实践中注意消除嵌套布局，Android官方也提供了ListView/GirdView/RecyclerView等基础空间来处理View的回收与复用。 但很多时候我们都会碰到视觉需要在一个长列表下做多种类型的布局来分配各种元素, 特别是电商业务各类首页，频道等页面，元素结构复杂多样。 这种时候实现的选择有不用复用，直接用各个组件进行拼接，但这样会损失性能；选择一个主要的复用容器, 如ListView或者RecyclerView+LinearLayoutManager等，然后在其中使用嵌套等方式对其他的布局方式进行处理，这样一个是减少了复用的能力，另一个是如果需要嵌套无法兼容的布局的时候，需要处理嵌套滑动的情况。 既然RecyclerView提供了基础的回收复用功能，也支持LayoutManager的扩展，那么能不能用一个LayoutManager就完成所有的布局类型呢？ 感觉的这是一个不错的方向，目前在 github 上也能找到类似的项目，但是这些之前也埋有不少bug, 大部分都是因为在一些特殊场景下和RecyclerView相关的其他的类一起使用时出现问题。 为了避免掉入bug大坑，我们决定基于LinearLayoutManager来做改造。 特性 自定义了一个VirtualLayoutManager，它继承自 LinearLayoutManager；引入了 LayoutHelper 的概念，它负责具体的布局逻辑；VirtualLayoutManager管理了一系列LayoutHelper，将具体的布局能力交给LayoutHelper来完成，每一种LayoutHelper提供一种布局方式，框架内置提供了几种常用的布局类型，包括：网格布局、线性布局、瀑布流布局、悬浮布局、吸边布局等。这样实现了混合布局的能力，并且支持扩展外部，注册新的LayoutHelper，实现特殊的布局方式。 每一种LayoutHelper负责布局一批组件范围内的组件，不同组件范围内的组件之间，如果类型相同，可以在滑动过程中回收复用。因此回收粒度比较细，且可以跨布局类型复用。 提供了自定义的布局样式，可以满足多样化的布局需求，比如每一个组件范围内的布局支持一个背景颜色、背景图片；网格布局里，可以支持1列、2列、3列、4列、5列共5种样式，每一列的宽度默认平均分配屏幕宽度，也可以指定按比例分配列宽。吸边布局支持吸到屏幕底部、屏幕顶部、屏幕左边、屏幕右边。这些都是系统默认的LayoutManager不支持的。 架构整体的设计方案和思路如下： RecyclerView是整个页面的主体，它的运行需要绑定一个Adapter和LayoutManager，在我们的设计里自定义了VirtualLayoutAdapter和VirtualLayoutManager来绑定到RecyclerView。 VirtualLayoutAdapter继承自系统的Adaper，它除了提供系统要求创建组件、绑定数据到组件的功能，定义了两个接口：getLayoutHelper()——用于返回某个位置组件对应的一个LayoutHelper；setLayoutHelpers()——业务方调用此方法设置整个页面所需要的一系列LayoutHelper。不过这两个方法的具体实现都委托给VirtualLayoutManager来完成。 VirtualLayoutManager继承自系统的 LinearLayoutManager，在RecyclerView加载组件或者滑动的时候，会调用VirtualLayoutManager，告诉它当前还有哪些空白区域可以用来摆放组件，也就是调用了架构图中所示的layoutChunk方法。 VirtualLayoutManager会持有一个LayoutHelperFinder，当layoutChunck被调用的时候，会传入一个位置参数，告诉LayoutManager当前要布局第几个组件，LayoutHelperFinder就通过这个位置找到当前这个位置对应的LayoutHelper，因为每个LayoutHelper都会绑定它负责的布局区域的起始位置和结束位置。 LayoutHelper负责具体的布局逻辑，它有一系列子模块，其中基类LayoutHelper定义了一系列接口，用来和VirtualLayoutManager通信，包括isOutOfRange()——告诉VirtualLayoutManager它所传递过来位置是否在当前LayoutHelper的布局区域内；setRange()——设置当前LayoutHelper负责的布局区域；beforeLayout()——在真正布局之前做一些前置工作；doLayout()——真正的布局逻辑接口；afterLayout()——在布局完成之后做一些后置工作；MarginLayoutHelper稍微扩展LayoutHelper，提供了布局常用的内边距padding、外边距margin的计算功能；BaseLayoutHelper是第一层具体实现，实现了当前LayoutHelper在屏幕范围内的具体区域，用于填充对这一区域填充背景色、背景图等逻辑。而剩下的LinearLayoutHelper、GridLayoutHelper等负责了具体的布局逻辑，它们都重点实现了beforeLayout()、doLayout()、afterLayout()方法，特别是在doLayout()方法里，会获取一个一组件，按照各自的协议对组件进行尺寸计算、界面布局。框架内置了以下几种重要的 LayoutHelper： LinearLayoutHelper，实现简单的线性布局； GridLayoutHelper，实现网格布局，支持1-5列的网格，支持配置列间距、行间距，支持不等宽的网格； StaggeredLayoutHelper，实现瀑布流式的布局； FloatLayoutHelper，负责悬浮效果，处于该布局中的组件会悬浮在整个页面上方，并且可拖拽，不随页面滚动而滚动； FixedLayoutHelper，负责固定位置的布局，它可固定在屏幕某个位置，不可拖拽，不随页面滚动而滚动； StickyLayoutHelper，它是一种吸边的布局，当它包含的组件处于屏幕可见范围内的时候，像正常的组件一样随页面滚动而滚动，当组件将要被滑出屏幕返回的时候，可以吸到屏幕的顶部或者底部，实现一种吸住的效果； 工作流程初始化 在使用vlayout的时候，首先做初始化工作，对业务使用方来说，和使用普通的 RecyclerView + LayoutManager 初始化流程基本一致。对于框架流程上来说，前前后后涉及了6个角色，基本流程如下： vlayout的业务使用方初始化RecyclerView对象。 创建一个VirtualLayoutAdapter对象，实现相关接口。 初始化一个VirtualLayoutManager对象。在初始化VirtualLayoutAdapter的时候，内部也初始化了一个RangeLayoutFinder对象，用来后续的LayoutHelper查找。 业务使用方需要将VirtualLayoutAdapter和VirtualLayoutManager都绑定到RecyclerView里。 获取数据列表，这个数据就是要显示到页面上的源数据，它可以是同步获取，也可以是异步从本地磁盘或者远程服务器获取。最关键的地方在用这个数据列表要包含一组布局和位置信息，能够用来识别数据列表中从第m个位置到第n个位置的数据它们是该用那种布局方式进行布局。这个布局和位置信息的数据结构并不做强制限制，只要能提供足够的信息，用来快速方便地完成下述第6步。 根据数据列表和源数据提供的布局位置信息，生成LayoutHelper列表，每个LayoutHelper对象会被知道它负责的源数据位置范围、源数据的个数等信息。 将生成的LayoutHelper列表传递给VirtualLayoutAdapter。 VirtualLayoutAdapter进一步将LayoutHelper列表给VirtualLayoutManager。 VirtualLayoutManager也进一步将LayoutHelper列表传递给RangeLayoutHelperFinder。 RangeLayoutHelperFinder真正开始处理这些LayoutHelper列表，它会根据每个LayoutHelper负责布局的起始位置和结束位置，对LayoutHelper做索引，这样当后续VirtualLayoutManager传入一个位置参数让RangeLayoutHelperFinder查找一个对应的LayoutHelper时，RangeLayoutHelperFinder会通过二分查找的方式返回一个LayoutHelper。 接下来还要将数据列表也传递给VirtualLayoutAdapter。 至此，整个初始化流程就完成，这里暴露给业务方的主要是VirtualLayoutAdapter，它接收数据列表和LayoutHelper列表，内部在传递给RecyclerView和VirtualLayoutManager进行后续的工作。 布局过程 当完成前面的初始化工作，将数据和LayoutHelper都绑定到vlayout内部之后，紧接着就可以开始布局流程了。这里无论是刚打开页面第一次布局，还是用户滑动页面，进行一次新的布局，流程都是一致的。 RecyclerView内部会维护一个状态，计算当前是否存在未填充满组件的区域，区域还有多大。 如果发现有空白区域，就将页面状态传给LayoutManager——在我们的框架里——就是VirtualLayoutManager，告诉它要进行组件的填充布局。VirtualLayoutManager能获取到的信息有当前可见的第一个组件的位置，当前可见的最后一个组件的位置，当前空白区域的大小，这些信息都是RecyclerView提供的，后面才开始真正vlayout发挥作用的时候。 VirtualLayoutManager先去遍历所有LayoutHelper，告诉它们当前可视范围的位置信息，不在范围之内的LayoutHelper可以做一些清理工作，比如将绑定过背景的LayoutHelper要清理背景。 VirtualLayoutManager获取到下一个要填充的组件的位置信息。 通过RangeLayoutHelperFinder找到下一个组件对应的LayoutHelper。 LayoutHelper开始真正布局一个或者多个组件， 注意一个LayoutHelper一次布局在宽度上会布局满一整行的区域，对于LinearLayoutHelper、FixedLayoutHelper等LayoutHelper，一个组件就占一整行，这个时候就布局一个组件就行了；而GridLayoutHelper、StaggeredLayoutHelper等一行可能会摆多个组件，它们一次布局会将尽可能多的组件都获取到填充满一行宽度。至于能填充多少高度，那就根据组件自己占用的高度来决定了。 LayoutHelper会从让RecyclerView返回一个组件，RecyclerView会尝试从回收池里获取一个被缓存的组件，如果存在缓存组件，就直接返回给LayoutHelper使用，如果不存在，则要调用Adapter——在vlayout框架里——就是VirtualLayoutAdapter去生成一个新的 组件实例。这个逻辑是RecyclerView的固有逻辑，也就组件复用的能力。 当RecyclerView内部不存在一个类型的组件缓存时，VirtualLayoutAdapter生成一个组件，一步一步返回给LayoutHelper。 LayoutHelper获取到了下一个要布局的组件，开始布局。 布局之前先对组件进行一次宽、高的测量计算，宽度是LayoutHelper通过布局信息、样式等条件计算得到的，限定了当前这个组件只能这么宽，而高度不由LayoutHelper决定，而是通过测量组件的高度来获取。 有了组件的宽高信息，结合一些样式，比如内边距、外边距、组件间间距等信息，LayoutHelper开始布局当前组件的位置。 当布局完一行组件之后，要再去遍历所有LayoutHelper，告诉它们当前可视范围的位置信息，做一些后置工作，比如新布局的区域是不是有背景要绑定，有的话要做背景的设置。悬浮类布局要根据位置做吸顶或者吸底的特殊处理，在可见范围内的悬浮类布局对组件做正常布局等。 通过前面布局过程中组件的高度计算，那么也就知道当前一次布局消耗了多少的空白区域。 这个空白区域进一步反馈给RecyclerView。RecyclerView会进行状态跟更新，如果空白区域都被填充满了，那么就结束一次布局了，如果还有，就要触发下一个位置的布局，在重复上述流程。 效果demo动效 实战效果 总结本文着重介绍 vlayout 的设计思路和原理，如果要进一步熟悉其细节，最好是到 github 上下载源码阅读，结合本文的说明，效果会更佳。如果想要尝试使用 vlayout 搭建页面，也可以到 github 上下载 demo，阅读使用文档和样式属性说明文档。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram七巧板实现界面动态化]]></title>
    <url>%2Fposts%2F57a68464.html</url>
    <content type="text"><![CDATA[Tangram，七巧板，几块简单的积木就能拼出大千世界。我们用Tangram来命名这套界面方案，也是希望他能像七巧板一样可以通过几块积木就搭出丰富多彩的界面。 号外：Tangram开源了！通过http://tangram.pingguohe.net可以了解更多技术细节，直接去GitHub查看iOS(https://github.com/alibaba/tangram-ios)和Android(https://github.com/alibaba/tangram-android)源码。 什么是TangramTangram不仅仅是一个Native（iOS &amp; Android）的界面开发框架，而是我们从日常工作中沉淀出的一套界面解决方案，涵盖了Native SDK，GUI操作台，后端逻辑容器，组件库机制的一整套方案。 Tangram从手机天猫 - 首页方案抽象而来，是面向组件的界面方案，是我们不断权衡性能、稳定性、开发效率、灵活性和动态性多方面表现的结果。除了手机天猫首页外，还支撑了天猫App中的天猫直播，我的天猫，猜你喜欢等多个业务，并且在阿里星球等多个阿里系App中有所应用。 就如Tangram主页所说，我们重点关注方案的多平台一致性，高性能和业务支撑能力。 Tangram怎么来的从2013年天猫在移动平台发力开始，我们一直在探索界面动态化方案。先后经历了WebView+HTML方案，动态Native方案，直至Tangram的原型——组件化方案。 最初我们看重动态性，在HTML框架和发布工具上做了大量的文章。我们可以快速开发出一张HTML页面，并推送到端上，而且通过Hybrid接口还能与Native进行交互。然而在大规模（双11）应用的过程中我们很快发现了问题——性能。当时我们认为WebView的性能是HTML页面的瓶颈，现在还不是大规模推广HTML的时候，我们需要一套替代方案。 很快我们提出了Dynative方案，框架内置基础组件（文本，图片，Button等）和函数（数学运算，字符串，网络等），以JSON为模板描述页面。Dynative方案兼具HTML方案的动态性和Native方案的高性能，看似完美。但很快在下一次的双11我们再次跌倒——效率。由于基于JSON定义的模板不具备通用性，写一张有逻辑的会场页面就需要数千行JSON，而且里边还有各种潜规则。能搞定这份模板的人，不超过5个。 痛定思痛，作为业务团队我们开始从业务的角度审视技术方案。带界面的业务基本分三种： 临时性业务——比如活动，几张页面生命周期可能2周，1周，甚至一两天。数量多，需求频繁，有可沉淀的东西，但变化更多。对极致性能不敏感。 常规业务——比如频道，生命周期长，需要长期维护。数量有限，需求稳定，沉淀性好。对极致性能相当敏感。 基础业务——跟常规业务相比需求稳定性更高，对性能和稳定性有极高的要求。 对于第1型，我们认为未来一定属于HTML，随着WebView性能的提升和Mobile开发框架与开发技能日趋成熟，现阶段HTML体现出的劣势终将荡然无存。而第2型和第3型是值得我们去思考的，结合我们团队所负责的业务形态，我们结合多年在业务上的经验制定了以粗粒度组件化+灵活布局容器为基本理念的界面解决方案。 整体上，Tangram View作为根节点，具备滚动能力；页面的子节点为布局容器，每行一个容器，向下单行排列；布局容器中按照各自的布局规则，在其内对任意组件进行排列。 至此，Tangram的基础模型已经确定，放弃了第1型和第3型，重点关注第2型。从改造手机天猫首页的实现方案开始，通过几个月的时间证明这套模型和方案在业务上完全可行。进一步对方案进行抽象，并且开始周边建设。 Tangram关注的重点正如Tangram主页上所述的，Tangram关注三个重点：面向业务、多端一致性和高性能。 面向业务正如第一部分所讲的，Tangram来源于多次试错和方向的调整，最终站在业务角度出发，权衡多项技术指标的结果。所以面向业务是出发点，是整个Tangram体系的最基本原则。 基于这个原则，在端上Tangram始终坚持粗粒度组件。粗粒度意味着通用性和灵活性的下降，某种程度上还会对动态性造成影响，但在第2型业务中通用性、灵活性和动态性的需求是有节制的，在粗粒度上完全可以满足业务需求。而且，粗粒度还会带给我们使用成本低，性能更好等优势。在端上重点精力则投入到提升组件库复用度，布局容器和组件的丰富性，从而推动业务发展。 除了端上的工作，另一部分重点工作在控制台和服务网关的建设上。作为一个面向业务的方案，控制台是业务方和产品的接口，控制台的主要目标是让业务方可以直接控制基于Tangram建设的产品——调整页面布局，切换页面数据，等。服务网关的建设目标是最大程度的降低业务创建Tangram页面的压力和成本。 多端一致性在多年的业务开发经历中，我们屡次被多端表现不一致的问题困扰。为了实现业务诉求，不得不通过复杂的网关逻辑来兼容多端逻辑不一致情况，以实现表现一致。因此我们早早的制定了两个Tangram端开发原则： 任意新功能的提出都是不区分平台，在功能设计中必须同时考虑多端功能，具体的实现方案和逻辑必须多端统一Review以保证多端表现一致。 任意一端的变更都必须在改动前把方案同步给其他端，而且变更必须多端同步发布。 高性能在面向业务的原则之下，已经给高性能打下了一个良好的基础。而在高性能的思考上我们重点基于页面渲染效率和组件回收复用两方面。 页面渲染——为了提升渲染效率，Tangram将在视图渲染之前把大量的计算工作在VM中完成，并缓存在VM组成的树形结构里。 回收和复用——Tangram在Android和iOS平台上分别开发了VLayout和LazyScroll两个基础组件，通过一个双索引可见区域组件发现算法，实现了跨父节点组件的高效回收和复用。 总结以上是对目前已经开源的Tangram 1.0的介绍，而目前我们已经完成了Tangram 2.0的讨论，开始执行2.0版本的重构工作。在Tangram 2.0中出于适应业务形态的变化，对Tangram 1.0中基于布局和组件的二维结构进行进一步的抽象，用于支撑更复杂的流式布局。并且对于控制台和服务网关也将进一步升级，大幅提升新业务开发效率。在性能层面，对组件开发模型和渲染模式进行一次较大的升级，在渲染和滚动效率上将得到巨大提升。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面动态化的基础Tangram]]></title>
    <url>%2Fposts%2F2ee0ad3d.html</url>
    <content type="text"><![CDATA[什么是Tangram 顾名思义，Tangram中文名是七巧板的意思，我们希望这个框架提供一系列基本单元，就像积木块一样，通过快速拼装就能搭建出一个页面或者调整页面的结构。重运营的业务特别是电商业务，往往讲究灵活多变，需要对线上业务做实时调整，此类页面动态化的需求便应运而生。 Tangram的设计理念 对于客户端开发来说，版本发出去之后，再要修改代码，是一件成本比较高的事情，针对线上实时调整比较多的地方，往往就采用了H5的方式上线。由于H5的体验相对Native欠缺一些，就有了后来Facebook的ReactNative(RN)，以及阿里自己的解决方案Weex，以Native的方式实现页面动态调整的能力。在如今，表面上看起来Tangram的方案会有些多余，但是通过了解它的设计与演变，那就知道它还是有存在的理由。 在历史上，大概两年前的这个时候，我们团队接手天猫首页的业务，迫切需要一套页面动态化方案。那个时候RN刚刚面世不久，特别是Android版本的RN还不稳定，更不用说后来的Weex了。而我们手里有的一套方案是自己开发过的Dynative（可以理解为初级版本的Weex）。但这些方案有个共同点就是比较重量级，它们都期望从基本的UI元素开始做一套纯动态的方案。在种种现有框架不成熟的时候，对于首页这种重量级的页面，我们还是希望以一种更加纯粹的Native开发模式来支撑业务。 在设计理念上，Tangram也有它的特殊之处，无论是H5还是Weex之类的方案，它们的动态能力在于随时可发布代码，它们是面向开发的动态化方案，发布代码意味着测试、灰度、发布等一系列流程。而Tangram是面向运营和产品的方案，它的动态能力体现在无须做代码改动，提供足够多的动态可配置的能力，通过在后台做样式的调整来达到页面调整的目的。所以简单比较如下： H5 Weex/RN Tangram 动态能力 强 较强 偏弱 面向人员 开发 开发 运营/产品 体量 完善的体系 较重量级 轻量级 体验 常规H5体验 鉴于H5和native之间 纯native体验 鉴于这样的设计目标，在这个框架里，重点着手于以下四个方面： 页面布局动态化，意思是页面的排版布局，可以通过后端数据的下发来调整。 组件业务化，这里的组件不是指基本的文本、图片、按钮等基本UI控件，而是指能承担一定业务能力的最小复用单元，因此它可能是一个文本和一个图片的组合这样子的一种形式。 动态能力粗粒度化，通过布局+组件的形式搭建整个页面，有多少种布局能力是内置在框架里的，有多少组件也是业务接入的时候注册到框架里的，后端下发的数据声明了用哪些布局、用哪些组件，通过布局嵌套组件的形式渲染整个页面。所以这个动态能力比较粗，不像H5或者Weex从基本的UI元素开始搭建整个页面。 组件的复用，为了承载那些个超长页面，需要对同类型的组件具备回收复用的能力，就像ListView、RecyclerView那样。 Tangram里重要的概念模型页面拆解 从一个实例出发，上图中展示的是一个早期的天猫首页，根据导购页面的特点，我们将页面拆分成三个层次：页面——卡片——组件，页面（第一张图）指的就是整体可滑动页面实体，并没有特殊之处；卡片指的是页面内可按行划分的一个一个独立区块（参考第二张图），组件（参考第三张图）指的是卡片内部一个独立的、业务级别的单元，它可以是一张图，也可以是文字+图的组合。因此整体整个页面可以这样描述：一个页面嵌套了多个卡片，一个卡片嵌套了多个组件。 页面结构 通过将页面拆分成三层结构，整个页面在model上就可以描述成这样一个树状结构。这里最重要的两个model是卡片和组件的model，整个页面的动态化将通过它们的动态化以及它们之间组合关系的动态化来完成。下面看这两层的具体协议描述： 卡片模型 卡片的职责是负责对组件进行布局，那么如何描述布局呢，前面说过，我们采用的是粗粒度的动态化方式，卡片的布局描述就是一种声明式的方式，因此卡片不需要布局模板，只要在model的数据里描述卡片的类型即可，至于卡片有哪些类型，则是注册在Tangram框架里的，业务方在接入框架的时候也可以注册自定义的卡片类型。这样就让Tangram省去了对布局模板的解析，简化了框架复杂度的同时，简化了开发复杂度。 卡片model描述上有四个组成：header、footer、body、style。最重要的是body部分，它包含了内嵌的组件model，如果卡片没有body，即没有组件，也就不在视觉上做渲染。卡片的布局也就是对body里包含的组件来进行布局。Tangram内置了一系列布局能力对组件进行布局，包括流式布局、瀑布流布局、吸顶布局、悬浮布局、轮播布局等等，基本上常见的布局方式都可以覆盖到。header、footer是卡片的标题和尾部，这是根据业务场景设计的可选内容，因为很多时候一块业务区域会有个标题之类的东西。在实现的时候，我们可以将他们转换到body里的组件，但在概念上，单独描述会更容易理解。style是对布局样式的描述，所有布局会有一些通用的样式属性，也有一些特有的，通过样式的描述，可以让布局能力更加丰富。画图举几个例子： 卡片样式简介 这里对卡片的样式做一些介绍，因为很多时候页面调整就是对样式的调整，结构调整也会涉及到样式调整，因此样式的动态性对页面的动态性具有重要贡献，这里举例的是几个通用的样式属性，如果卡片比较特殊，还可以自定义样式属性。 backgroundColor: 卡片的背景，在做页面氛围的时候经常会用到。 margin/padding: 卡片外边距、内边距，这是通用UI系统都会支持的属性。 gap: 卡片内的组件往往需要增加间距，如果通过组件的margin来实现，会有很多不便之处，相邻组件间左右或者上下都配置了margin，则需要考虑去重的实现，要么就在配置的时候对相邻组件的margin做精心控制。用gap的概念则很方便，它可以指定水平方向间距、垂直方向间距。 cols: 默认情况下，流式布局每一列宽度都是等分屏幕宽度的，如果需要做不等分的布局，就可以通过cols来指定每一列的占比，这样布局能力就能更加丰富了。 组件模型 组件的职责是负责业务逻辑和UI元素展示，它是尽可能小的业务单元，一般以实际设计稿出发，抽象出最小可复用单元。组件也是声明式的，需要在model的数据里描述组件的类型，至于有哪些类型，也是业务方在接入时预先注册，因为组件的业务成分比较重，Tangram一般就不内置了。除了类型描述，model数据里剩下的就是组件的数据和样式描述了。组件的数据不做具体规范，一般满足组件自身的需求即可，样式也不做强制规范，但有一些和布局相关的样式在框架层面会进行支持，这个下文介绍。 在组件的实现上，它首先是一个普通的View，并特殊之处，如果脱离Tangram框架，它也应该能正常运行使用。但在Tangram里，我们为组件设计了一个统一的ViewModel，定义了几个生命周期事件；通过ViewModel对组件的属性进行赋值，在组件初始化时会调用init，在滑入屏幕绑定数据时候调用bind，在滑出屏幕解除绑定时调用unbind。 除此之外组件的行为基本上都是业务逻辑了，不做过多介绍，这里再介绍几个和页面动态性相关的样式。 组件样式简介 backgroundColor: 组件的背景，同样也是在做页面氛围的时候经常会用到。 margin/padding: 组件外边距、内边距，同样也是UI系统都会支持的属性。 display: 参考css的设计，特别是在流式布局里，组件默认都是内联(inline)的，当布局占满屏幕宽度时，再考虑换行。如果在正常的流式卡片布局里要横插一行，则可以将组件声明为block，不然的话，就得将这个卡片打散成三个卡片才行。 colspan: 默认情况下，流式布局每一列宽度都是等分屏幕宽度的，也就是占用一个格子，组件上声明colspan可以让这个组件占用多个格子。它与卡片上的cols区别在于它占用的宽度值是离散的，而cols通过百分比可以做到宽度值的连续分布。 width/height: 其实是组件的宽高比，用来对组件进行对齐，利于界面排版。 每个组件都可以声明额外的自定义样式属性，比如字体颜色、字体大小等等，这里就不做过多介绍。通过卡片和组件的样式，基本上就可以组合出大部分场景的页面结构了，也就是Tangram的初衷——像搭积木一样拼装一个页面。 实现原理上面介绍了整个Tangram的基本概念，花了这么多篇幅讲概念模型，除了告诉大家这个东西是什么、它做什么、它是怎么设计的，最重要传递的一个信息是，作为业务系统，需要首先在概念模型上做好架构设计，在协议规范上做好统一，这样具体的平台去实现的时候，都能根据这个规范来做实现，不管谁实现的，都属于Tangram，这就好比JAVA虚拟机规范和JAVA虚拟机的关系一样。对于我们团队来说，对Tangram的实现也经历了一系列变更，但基本规范没怎么变动，这也是能大规模去支持业务的一个重要支点。下面会介绍目前实现上的思路和重要技术点。 基本结构和流程 主要有这么几个组成：核心引擎、数据解析器、卡片库、组件库、布局框架，核心引擎负责调度整个流程，在启动框架的时候要核心引擎要做一系列初始化，包括初始化卡片库和组件库，也就将内置的卡片类型注册进框架，将外部业务提供的组件也注册好，同时也要将数据解析器初始化好，布局框架也要初始化好。当页面数据传入的时候，核心引擎调用数据解析器将数据转换成卡片和组件的model对象，解析过程会根据之前注册过的卡片、组件类型来解析，不认识的数据将会被抛弃，卡片和组件的基本样式也会解析。解析完毕的卡片、组件model将会扔给布局框架进行页面渲染。布局框架根据卡片提供的布局信息进行布局，根据组件提供的组件信息进一步获取组件实例，贴到布局容器里。 布局框架实现 实现上难度最大的在于布局框架，布局框架的灵活性、性能决定了整个Tangram的灵活性和性能。在Android上，布局框架基于RecyclerView+自定义LayoutManager的方式实现；在iOS上，布局框架基于自定义的LazyScrollView来实现。这两框架基本上都能做到对页面的扁平化实现，提供了跨卡片的组件级别复用能力。先对这两块做一个介绍： 整个页面树被解析出卡片+组件的数据列表之后，会对块数据做进一步转换。首先提取所有组件model，也就是将组件都打平到同一级别的列表，这个列表会被传递给RecyclerView的Adapter，因此数据的位置其实就对应了RecyclerView看到的组件位置。而卡片model，将会拿来构建一个个LayoutHelper，这些LayoutHelper是负责具体布局的对象，一种布局类型的卡片对应于一种LayoutHelper，而且LayoutHelper还包含了它负责的组件的位置起始区域，它们会被传递给自定义的LayoutManager。当RecyclerView开始渲染页面或者滑动时，它内部维护了一个布局状态，获取当前屏幕范围内还有多少区域是空白的，下一个要加载的View的位置是多少，然后把这些信息告诉LayoutManager去加载View做布局。我们的自定义LayoutManager拿到这个位置之后，就反向查找对应的LayoutHelper，然后交给LayoutHelper去布局，这个过程还会涉及到从回收复用池或者通过Adapter获取一个组件实例。不同的LayoutHelper会按照约定的协议进行进一步布局。 对于iOS来说，也有类似的布局逻辑，但这里重点介绍iOS的页面容器LazyScrollView。这是一个自定义的滚动布局，具备回收复用能力。它的回收复用算法是这样的：在页面渲染前先计算所有组件的位置信息，根据组件在页面内位置的上边距做一个排序索引，根据下边距再做一个排序索引。页面滚动的时候通过滚动区域与上下边距的取交集，就可以获取到当前可见范围的组件是哪些，然后不可见范围内的组件实例可以回收，新进入可视区域的组件可以从回收复用池里拿到组件实例或者新创建一个组件实例贴到布局里。 扩展上面介绍的内容构建里Tangram的基本骨架，但要支撑起业务，还需要很多辅助工具，如果没有这些扩展，将很难支撑业务。这些扩展有些是内部注册在框架，也有些是外部注入。 点击处理模块，组件都需要有点击交互，点击处理模块定义了接口，业务方根据接口实现具体模块然后注入。 曝光处理模块，与点击模块类似，可提供组件曝光时的业务逻辑加载。 通用定时器模块，用来提供计时功能，满足组件内的倒计时需求、定时需求。 事件总线，用来做组件与卡片的通信，或者组件与外部通信等等。 脚本动画，将动画脚本化，提供动画的动态能力，让组件的交互更加丰富。 通用请求模块，有时候卡片数据、或者组件数据需要调用远程接口更新，同通用请求也是定义了加载接口，外部业务方自行实现注入。 纯动态组件，解决组件动态问题，因为我们的动态化是粗粒度的，行走江湖免不了内置动态能力满足不了一个临时需求的场景。动态组件集成了集团内的动态化方案，目前最主要的就是阿里的Weex方案，通过Weex的动态能力来解决组件的动态能力。 有了这些扩展功能，整个Tangram落地到业务就非常方便了，目前我们支撑了天猫首页、天猫直播首页、天猫超市首页等重要业务，还推广到了集团其他部门。 实践经验最后分享一些业务开发的经验，分客户端和后端运营两方面介绍。延伸到其他业务，这些经验应该也是有借鉴意义的。 客户端 首先是规范与协议的统一，我们这个框架支撑了多个业务，不同业务、不同平台之间，只有规范统一，才能尽可能支撑多的业务，否则不同业务接入，要做转换，是一件成本很高的事情。在不同平台之间统一规范，也可以让一份数据在多端使用。 在客户端上开发，稳定性是一个非常重要的指标，整个应用应该有自己的保护模式，对于框架来说，我们也要有防御性编程的思维，特别是是动态化方案，往往根据数据来执行代码，访问数据本身要足够小心，像空字段、类型转换、数组越界都是常见的问题，通过安全方法的使用，可以在一个地方保证数据访问的安全性。 组件库，也是一个非常重要的建设，不同业务之间可以复用相同的组件，减少组件开发。 容器化是实现页面在线拼装的一个必要的建设，客户端需要有一个容器页面，就像webview一样，给一个url，就可以加载页面，后端也也需要做数据的容器化接入，能导入业务数据，按照Tangram协议输出。再利用组件库里的现有组件，就可以完成一个页面搭建，目前有一些简单的页面（搜索专辑、推荐专辑）就是这样完成上线的。 解耦也是一个老生常谈的问题，在Tangram里实现扩展能力的时候，解耦这一方面做得就特别棒，像脚本动画、Weex都是其他团队的成果，但是可以很方便的插入到Tangram框架里，而且可以热插拔，业务方不想使用就可以不接入。 运营管理 Tangram是一个动态框架，虽然它的重点技术在客户端，但是没有后端的话是不完整的，必须要有一个完善的后端管理平台来做页面的日常运维才行。我们开发了一个专门的管理后台，可以对Tangram页面做多维度的管理。后端管理平台还承载了页面的稳定性、页面发布的效率、页面试错等能力。 Tangram页面动态调整都是配置发布，视觉调整。因此我们有独特的发布流程，首先后台变更完成之后不会直接发布，而是进入到预发布状态，在这个状态下，可以通过白名单预览提前检查变更效果，预览的方式是将变更生成一个二维码，在手机上扫码预览，检查最真实的效果。通过时间机器调整时间，不仅可以预览这次变更在当前时间的效果，还可以预览将来某个时间的效果，因为不同的时间点，生效的数据不一样，因此时间维度的预览特别有用。另外管理平台对变更人员也做了权限控制，每个业务方人员只能变更自己负责的业务，不会改动到其他业务的页面，通过对接流程平台，让每次变更都有记录可查，防止线上数据随意更改。 有了页面发布、变更的稳定性保证，发布的效率也是下一个重要考虑的问题。定时发布可以让变更在指定时间生效，比如双十一的时候很多东西要0点生效，如果0点做变更、预览、再上线，风险很大，有了定时发布，可以提前做好准备。一键下线的功能，可以做多版本里的某个共用卡片批量下线，特别是紧急情况。批量复制创建卡片和版本通配，都是为了解决新版本发布时候的效率，目前我们针对一个版本客户端就发布一份页面配置数据，有了版本通配，可以减少页面配置的数量，有了批量复制创建，可以在要创建新版本页面的时候复制页面。 快速试错，这是近年来非常热门的一个领域，当页面要进行调整的时候，我们希望看到调整的效果，这个时候abtest就派上了用场。天猫有一套自己的试错平台，Tangram前后端都对接了这条试错平台，在管理平台可以将变更做成实验变更，然后导入到试错平台下发到客户端，进入到实验分桶的用户就可以访问到实验变更，同时试验平台在端上也做了数据采集，这样可以在小范围内先试验变更的效果，根据数据来做接下来的决策。 小结本次分享整体性的介绍了Tangram的技术方案和一些开发经验，内容比较多，很多地方只能在整体思路上进行介绍，后续我们会逐步将一些细节开放出来分享。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram知识图谱]]></title>
    <url>%2Fposts%2Fa76b266e.html</url>
    <content type="text"><![CDATA[为了方便大家对 Tangram 有个全局的了解，做了一张图谱做指导。 相关开源库Android Tangram-Android Virtualview-Android vlayout UltraViewPager iOS Tangram-iOS Virtualview-iOS LazyScrollView 工具 virtualview_tools]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node升级的正确方法]]></title>
    <url>%2Fposts%2Fc2ade9d5.html</url>
    <content type="text"><![CDATA[安装方法:1.查看node版本，没安装的请先安装；12 $ brew install node $ node -vn 2.清楚node缓存；1$ sudo npm cache clean -f 3.安装node版本管理工具’n’;1$ sudo npm install n -g 4.使用版本管理工具安装指定node或者升级到最新node版本；123$ sudo n stable （安装node最新版本）$ sudo n 8.9.4 （安装node指定版本8.9.4） 5.使用node -v查看node版本，如果版本号改变为你想要的则升级成功。若版本号未改变则还需配置node环境变量1.查看通过n安装的node的位置；1$ which node (如：/usr/local/n/versions/node/6.12.3） 2.cd进入/usr/local/n/versions/node/ 你应该能看到你刚通过n安装的node版本这里如：8.9.4；编辑/etc/profile;1$ vim /etc/profile 3.将node安装的路径（这里为：/usr/local/n/versions/node/8.9.4）添加到文件末尾；12345set node pathexport NODE_HOME=/usr/local/n/versions/node/8.9.4export PATH=$NODE_HOME/bin:$PATH 4.wq退出保存文件，编译/etc/profile;1$ source /etc/profile 5.再次使用node -v查看node版本，不出意外版本号应该变为你想要的。]]></content>
      <categories>
        <category>前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式的优点与缺点概况]]></title>
    <url>%2Fposts%2Fb5467332.html</url>
    <content type="text"><![CDATA[设计模式标签（空格分隔）： 设计模式优点 应用场景 单例模式优点： 只有一个实例，减少了内存开支； 可以避免对系统资源的多重占用； 可以在系统中设置全局的访问点，优化和共享资源访问； 缺点： 没有接口，扩展困难； 对测试开发不利； 应用场景： 要求生成唯一序列号的场景； 需要一个共享访问点； 创建一个对象需要消耗过多的资源时 需要定义大量的静态常量和静态方法时（也可直接声明为static的方式）； 工厂方法模式优点： 良好的封装性，代码结构清晰； 扩展非常好； 屏蔽产品类； 应用场景： 是new一个对象的替代品； 需要灵活的，可扩展的框架时； 使用在测试驱动开发的框架下； 抽象工厂模式优点： 封装性； 产品族内部的约束为非公开状态； 缺点： 产品族扩展困难； 模板方法模式优点： 封装不变部分，扩展可变部分，把不变的算法封装到父类实现，可变的部分则通过继承来扩展； 提取公共部分代码，便于维护； 行为由父类控制，子类实现; 缺点： 子类对父类产生影响，子类执行的结果影响了父类的结果; 应用场景： 多个子类有公有的方法，且逻辑相同时； 重要，复杂的算法，可以把核心算法设计为模板方法； 重构时，把相同的代码抽取到父类，然后通过钩子函数结束其行为； 建造者模式优点： 封装性，使得客户端不必知道产品内部的组成细节，我们不用关心每一个具体的模型内部是如何实现的。 建造者独立，容易扩展 便于控制细节风险，由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响; 建造者模式的应用场景： 相同的方法，不同的执行顺序，会产生不同的结果时； 多个部件或零件，都可以装配到一个对象中，但产生的运行结果又不相同时，如Android中的AlertDialog的构造; 产品类非常复杂，或产品类的的调用顺序不同产生不同的效果； 代理模式优点： 职责清晰，其实的角色就是实现实际的业务的逻辑，不用关心其他非本职责的事务； 高扩展性，具体主题角色随时都会发生变化，但只要它实现了接口，我们的代理类就可以在完全不做任何修改的情况下使用； 原型模式（通过实现Cloneable接口）优点： 性能优良，原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好，特别是要在循环体内产生大量对象时， 避免构造函数的约束，直接是在内存中拷贝的，构造函数是不会执行的。 应用场景： 类初始化需要消化非常多的资源时 性能和安全要求的场景，通过 new产生一个对象需要非常繁琐的数据准备和访问权限时； 一个对象多个修改者的场景，一个对象需要提供给多个对象访问，而且各个调用者都可以修改其值时； 注意地方：浅拷贝与深拷贝Java的Object类提供的clone方法只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，其他的原始类型如int,char等都会被拷贝，拷贝后的对象与原生对象共享内部元素的地址（浅拷贝），如果拷贝后的对象修改了原生对象的数组，则原生对象也会看到修改。如果需要进行深拷贝，则需要在复写的clone方法里对私有的类变量（内部数组，引用对象）进行独立的拷贝。并且使用final关键字修饰的变量不能被拷贝； 中介者模式优点： 减少了类间的依赖，把原有的一对多的依赖变成了一对一的依赖； 缺点： 中介者会膨胀得很大，而且逻辑复杂；原本N个对象的依赖关系转换为中介者与对象的依赖关系； 命令模式优点： 类间解耦，调用者与接收者之间没有任何依赖关系，调用者实现功能时不需要了解到底是哪个接收者执行，只需调用Command抽象类的execute方法就可以了； 可扩展性，Command的子类可以非常容易扩展，并且调用者和高层模块不产生严重的代码耦合； 缺点： Command类膨胀厉害，如果有N个命令，则Command类的子类就为N个； 应用场景：如Android中各种事件的处理； 责任链模式优点： 请求与处理分开，请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌； 缺点： 性能问题，每个请求都是从链头遍历到链尾的，当这个责任链比较长时，遍历开销会比较大； 应用场景: 如Android事件的传递机制； 装饰器模式优点： 装饰类和被装饰类可以独立发展，而不会互相耦合； 装饰模式是继承关系的一个替代方案，不管装饰多少层，最终返回的也还是那个对象； 装饰模式可以动态地扩展一个实现类的功能； 缺点： 多层的装饰比较复杂，当使用多层装饰出现问题时，排查问题的工作量比较大 应用场景： 需要扩展一个类的功能，或给一个类增加附加功能； 需要为一批兄弟类进行改装或加装功能； 策略模式优点： 算法可以自由切换，只要实现抽象策略，它就成为策略家庭的一个成员； 避免使用多重条件判断， 扩展性良好，在现有的系统中增加一个策略太容易，只要实现接口就可以了; 缺点： 策略类数量多，每一个策略都是一个类，复用的可能性很小； 所有的策略类都需要对外暴露，上层模块必须知道有哪些策略，然后决定使用哪一个策略； 应用场景： 多个类只有在算法或行为上稍有不同的场景； 算法需要自由切换的场景； 需要屏蔽算法规则的场景； 适配器模式优点： 让两个没有任何联系的类在一起运行； 增加了类的透明性； 提高了类的复用度； 灵活性好，当不需要适配器时，只要删掉这个适配器就可以了， 应用场景： 修改一个已经投产的接口时， Android中各种Adapter， 迭代器模式 迭代器模式是为解决遍历容器中的元素而诞生的，没有人会单独写一个迭代器，使用Java提供的Itreator就可以满足要求了； 组合模式优点： 高层模块调用简单，高层模块不需要关心自己处理的是单个对象还是整个组合结构， 节点可以自由增加； 缺点： 调用时会直接使用实现类，不符合面向接口编程思想； 应用场景： 维护和展示部分-整体关系的场景，如树型菜单，文件和文件夹的管理； 只要是树型结构，就要考虑使用组合模式； 观察者模式优点： 观察者与被观察者之间是抽象耦合，不管是增加观察者还是被观察者都非常容易扩展； 建立一套触发机制； 缺点： 一个被观察者，多个观察者，开发与调度会比较复杂，在Java中消息的通知默认是顺序执行，其中一个观察者卡壳，会影响整体的执行效率，一般要考虑采用异步的方式； 应用场景： 关联行为场景，如Android中数据变化会引起UI的变化； 事件多级触发场景； 跨系统的消息交换场景； 门面模式优点： 减少系统的相互依赖，所有的依赖都是与门面对象的依赖，与子系统无关。 提高了灵活性； 提高了安全性，想让你访问子系统的哪些业务就开通哪些逻辑； 缺点： 不符合开闭原则，当出现bug后，只能通过修改门面角色的代码来修复； 应用场景： 为一个复杂的模块或子系统提供一个供外界访问的接口，如Android的Context类只是一个抽象类，所有的功能都是在ContextImpl类实现的，我们不会察觉到ContextImpl的存在，只需要调用Context就可以了； 子系统相对独立，外界对子系统的访问只要黑箱操作即可； 预防低水平开发人员带来的风险，被限定在指定的子系统开发； 备忘录模式应用场景： 需要保存和恢复数据的相关状态场景； 提供一个可回滚的操作场景； 需要监控的副本场景中； 数据库连接的事务管理就是用的备忘录模式； 注意事项： 备忘录的生命期，要主动管理它的生命周期，建立就要使用，不使用就删除； 备忘录的性能，不要在频繁建立备份的场景中使用备忘录模式；（对象的创建是需要消耗资源的） 访问者模式优点： 符合单一职责原则，具体元素角色负责数据的加载，而访问者类则负责数据的呈现； 优秀的扩展性， 灵活性非常高； 缺点： 具体元素对访问者公布细节，访问者要访问一个类就必须要求这个类公布一些方法和数据； 具体元素变更比较困难；具体元素角色的增加、删除、修改都是比较困难； 违背了依赖倒置原则，访问者依赖的是具体的元素，而不是抽象的元素； 应用场景 ： 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作； 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作”污染“这些对象的类； 业务规则要求遍历多个不同的对象； 状态模式优点： 结构清晰，避免了过多的switch...case或if...else语句的使用； 遵循设计原则，每个状态就是一个子类； 封装性非常好，将状态变换放置到类的内部来实现； 缺点： 子类会太多，也就是类膨胀，有多少个状态，就会有多少个子类； 应用场景： 行为随状态改变而改变的场景，如权限设计； 条件、分支判断语句的替代者，通过扩展子类实现条件的判断处理； 状态的个数最好不要超过5个； 解释器模式（现在使用较少）优点： 扩展性好， 缺点： 解释器模式会引起类膨胀； 采用了递归调用方法； 享元模式优点： 大大减少应用程序创建的对象，降低程序内存的占用; 缺点： 提高了系统复杂性，需要分离出内部和外部状态； 应用场景： 系统中存在大量的相似对象； 需要缓冲池的场景； 细粒度的对象都具有较接近的外部状态；且内部状态与环境无关 桥梁模式优点： 抽象与实现分离； 优秀的扩充能力； 实现细节对客户透明； 应用场景： 不希望或不适用继承的场景； 接口或抽象类不稳定的情况； 重要性要求较高的场景；]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之23种常用模式]]></title>
    <url>%2Fposts%2F8af7915a.html</url>
    <content type="text"><![CDATA[在常用的23种设计模式中，根据设计模式的功能，我们又可以把这23个设计模式分为三大类：创建类模式，结构类模式，行为类模式； 创建类模式 工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一类，使一个类的实例化 延迟到其子类； 建造者模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示； 抽象工厂模式，为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。 单例模式，确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例； 原型模式，通过对象复制来实现的模式就叫做原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 结构类模式 适配器模式,将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作； 桥梁模式，将抽象与实现解耦，使得两者可以独立地变化； 组合模式，将对象组合成树形结构以表示“部分-整体”的场次结构，使得用户对单个对象和组合对象的使用具有一致性。 装饰模式，动态地给一个对象添加一些额外的职责。就增加功能来说 ，装饰模式相比生成子类更为灵活； 门面模式，要求一个子系统的外部与其内部通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 享元模式，是池技术的重要实现方式，使得共享对象可有效地支持大量的细粒度的对象。 代理模式，为其他对象提供一种代理以控制对这个对象的访问。 行为类模式 责任链模式，使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止； 命令模式，这是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能； 解释器模式，是一种按照规定语法进行解析的方案；定义为：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示业解释语言中的句子。 迭代器模式，，它提供一种方法访问一个容器对象中各个对象，而又不需暴露该对象的内部细节。（目前已经没落）； 中介者模式，用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 备忘录模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态。通俗地讲，备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法； 观察者模式，也叫做发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 状态模式，状态模式的核心是封装，状态的变更引起了行为的变更。当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。 策略模式，定义一组算法，将每个算法封装起来，并且使它们之间可以互换； 模板方法模式，定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些框架； 访问者模式，封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之6大设计原则]]></title>
    <url>%2Fposts%2Ffbde7e42.html</url>
    <content type="text"><![CDATA[单一职责原则单一职责的定义为：应该有且仅有一个可以引起类的变更，也就是一个职责一个接口（业务逻辑的划分）；好处： 类的复杂性降低； 可读性提高； 可维护性提高； 变更引起的风险降低；一个接口修改只对相应的实现类有影响，对其他接口没有影响 里氏替换原则通俗地说，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常；但反过来就不行，有子类出现的地方，父类未必就能适应；（因此在类中调用其他类时，就务必使用父类或接口，如果不能这样做，则说明类的设计已经违背了LSP原则了） 如果子类不能完整地实现实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖，聚集，组合等关系代替继承； 方法中的输入参数称为前置条件，并且子类中的方法的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松；（父类出现的地方，子类就可以出现） 依赖倒置原则最直接的理解就是：面向接口编程，抽象定义： 高层模块不应该依赖于低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象； 在Java语言中的表现为： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的； 接口或抽象类不依赖于实现类； 实现类依赖接口或抽象类； 接口隔离原则接口的种类： 实例接口，如我们在Java中声明一个类，然后用new 关键字来产生一个实例，它是对一个类型的事物的供述，这是一个接口； 类接口，在Java中使用关键字interface定义的接口； 定义：说白了就是接口尽量细化，同时接口中的方法尽量少 迪米特法则也叫最少知识原则，简单说应该对其他对象有最少的了解，也就是说一个类应该对自己需要耦合或调用的类知道得最少；也就是类间解耦，弱耦合 开闭原则定义：软件实体应该对扩展开放，对修改关闭，也就是说软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化；如何应用到实际编程中？： 抽象约束，也就是通过接口或抽象类约束实现扩展，对扩展进行边界的限定，不允许出现在接口或抽象类中不存在的public 方法；并且参数的类型、引用对象尽量使用接口或者抽象类，最后就是抽象层尽量保持稳定，一旦确定就不允许修改； 元数据控制模块行为，也就是说用元数据来控制程序的行为，减少重复开发。元数据就是用来描述环境和数据的数据，也就是我们常说的配置参数； 制定项目章程，让团队的所有成员都遵守约定； 封装变化，将相同的变化封装到一个接口或抽象类中，不同的变化封装到不同的接口或变化；]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom_For_ReactNative]]></title>
    <url>%2Fposts%2F321ed7e5.html</url>
    <content type="text"><![CDATA[Atom下载链接https://atom.io/ Atom插件https://atom.io/packages常用插件：​ 浏览器浏览功能 open-in-browser (可以设置快捷键)​ 分页展示html页面效果 atom-html-preview (可以设置快捷键)​ 文件路径补全 autocomplete-path​ React官网https://facebook.github.io/react/]]></content>
      <categories>
        <category>Android</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ReactNative</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局弹框GlobalDialog]]></title>
    <url>%2Fposts%2F5bbd3c9c.html</url>
    <content type="text"><![CDATA[Demo地址：GlobalDialogDemo 全局弹框，比如异地登录提示。思路就是通过非 Activity 的 Context 来启动一个透明 activity， 然后使用这个 activity 来显示一个 dialog。 AndroidManifest.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.whohelp.globaldialogdemo"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".GlobalDialogActivity" android:theme="@style/Transparent" /&gt; &lt;/application&gt;&lt;/manifest&gt; styles.xml123456789101112131415161718&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="Transparent" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowAnimationStyle"&gt;@android:style/Animation&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; MainActivity.java1234567891011121314public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void showDialog(View view) &#123; GlobalDialogActivity.start(this.getApplicationContext()); &#125;&#125; GlobalDialogActivity123456789101112131415161718192021222324252627282930313233public class GlobalDialogActivity extends AppCompatActivity &#123; public static void start(Context context) &#123; Intent starter = new Intent(context, GlobalDialogActivity.class); //设置启动方式 starter.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(starter); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_global_dialog); //显示dialog new AlertDialog.Builder(this) .setTitle("全局dialog") .setMessage("这是一个全局dialog") .setNegativeButton("取消", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setCancelable(false) .show(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>GlobalDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android启动模式和应用场景]]></title>
    <url>%2Fposts%2F7bd182af.html</url>
    <content type="text"><![CDATA[在一个项目中会包括着多个Activity，系统中使用任务栈来存储创建的Activity实例，任务栈是一种“后进先出”的栈结构。举个栗子，若我们多次启动同一个Activity。系统会创建多个实例依次放入任务栈中。当按back键返回时，每按一次，一个Activity出栈，直到栈空为止。当栈中无不论什么Activity。系统就会回收此任务栈。 上面这个样例中的Activity并没有设置启动模式，你会发现多次启动同一个Activity。而系统却创建了多个实例，白白浪费内存，这样的情况Android早就替我们考虑好了。Android为Activity 的创建提供了4种启动模式，而依据实际应用场景的不同。为Activity 选择不同的启动模式，最大化降低了每次都须要在栈中创建一个新的Activity的压力，降低内存使用。 启动模式的具体说明和使用场景？以下依据这篇博文来一一解惑。 一. Android启动模式具体解释 1. Standard 标准模式说明： Android创建Activity时的默认模式，假设没有为Activity设置启动模式的话，默觉得标准模式。每次启动一个Activity都会又一次创建一个新的实例入栈，无论这个实例是否存在。 生命周期：如上所看到的，每次被创建的实例Activity 的生命周期符合典型情况，它的onCreate、onStart、onResume都会被调用。 举例：此时Activity 栈中以此有A、B、C三个Activity，此时C处于栈顶，启动模式为Standard 模式。 若在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是还有一个C Activity进入栈中，成为栈顶。 2. SingleTop 栈顶复用模式说明：分两种处理情况： 须要创建的Activity已经处于栈顶时，此时会直接复用栈顶的Activity。不会再创建新的Activity； 若须要创建的Activity不处于栈顶，此时会又一次创建一个新的Activity入栈，同Standard模式一样。 生命周期：若情况一中栈顶的Activity被直接复用时，它的onCreate、onStart不会被系统调用，由于它并没有发生改变。可是一个新的方法 onNewIntent会被回调（Activity被正常创建时不会回调此方法）。 举例：此时Activity 栈中以此有A、B、C三个Activity，此时C处于栈顶，启动模式为SingleTop 模式。情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。 结果是直接复用栈顶的C Activity。 情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。结果是创建一个新的Activity入栈。成为栈顶。 3. SingleTask 栈内复用模式说明：若须要创建的Activity已经处于栈中时，此时不会创建新的Activity，而是将存在栈中的Activity上面的其他Activity所有销毁，使它成为栈顶。 生命周期：同SingleTop 模式中的情况一同样。仅仅会又一次回调Activity中的 onNewIntent方法 举例：此时Activity 栈中以此有A、B、C三个Activity。此时C处于栈顶，启动模式为SingleTask 模式。 情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是直接用栈顶的C Activity。情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。 结果是将A Activity上面的B、C所有销毁，使A Activity成为栈顶。 4. SingleInstance 单实例模式说明： SingleInstance比較特殊，是全局单例模式，是一种加强的SingleTask模式。它除了具有它所有特性外，还加强了一点：具有此模式的Activity仅仅能单独位于一个任务栈中。 这个经常使用于系统中的应用，比如Launch、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。 举例：比方 A Activity是该模式，启动A后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁。 二.启动模式的使用方式1. 在 Manifest.xml中指定Activity启动模式一种静态的指定方法，在Manifest.xml文件里声明Activity的同一时候指定它的启动模式，这样在代码中跳转时会依照指定的模式来创建Activity。样例例如以下： 123&lt;activity android:name="..activity.MultiportActivity" android:launchMode="singleTask"/&gt; 2. 启动Activity时。在Intent中指定启动模式去创建Activity一种动态的启动模式，在new 一个Intent后，通过Intent的addFlags方法去动态指定一个启动模式。样例例如以下： 1234Intent intent = new Intent();intent.setClass(context, MainActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);context.startActivity(intent); 注意：以上两种方式都能够为Activity指定启动模式，可是二者还是有差别的。 （1）优先级：动态指定方式即另外一种比第一种优先级要高，若两者同一时候存在，以另外一种方式为准。（2）限定范围：第一种方式无法为Activity直接指定 FLAG_ACTIVITY_CLEAR_TOP 标识，另外一种方式无法为Activity指定 singleInstance 模式。 三. Activity 的 Flags标记位既能够设定Activity的启动模式，如同上面介绍的，在动态指定启动模式，比方 FLAG_ACTIVITY_NEW_TASK 和 FLAG_ACTIVITY_SINGLE_TOP 等。它还能够影响Activity 的运行状态 ，比方 FLAG_ACTIVITY_CLEAN_TOP 和 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 等。 以下介绍几个基本的标记位，切勿死记，理解几个就可以，须要时再查官方文档。 1. FLAG_ACTIVITY_NEW_TASK作用是为Activity指定 “SingleTask”启动模式。跟在AndroidMainfest.xml指定效果同样。 2. FLAG_ACTIVITY_SINGLE_TOP作用是为Activity指定 “SingleTop”启动模式，跟在AndroidMainfest.xml指定效果同样。 3. FLAG_ACTIVITY_CLEAN_TOP具有此标记位的Activity，启动时会将与该Activity在同一任务栈的其他Activity出栈。一般与SingleTask启动模式一起出现。它会完毕SingleTask的作用。但事实上SingleTask启动模式默认具有此标记位的作用 4.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有此标记位的Activity不会出如今历史Activity的列表中，使用场景：当某些情况下我们不希望用户通过历史列表回到Activity时，此标记位便体现了它的效果。它等同于在xml中指定Activity的属性： 1android:excludeFromRecents="trure" 四. 启动模式的实际应用场景这四种模式中的Standard模式是最普通的一种，没有什么特别注意。而SingleInstance模式是整个系统的单例模式，在我们的应用中一般不会应用到。所以，这里就具体解说 SingleTop 和 SingleTask模式的运用场景： 1. SingleTask模式的运用场景最常见的应用场景就是保持我们应用开启后仅仅有一个Activity的实例。最典型的样例就是应用中展示的主页（Home页）。 假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用SingleTask模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。 2. SingleTop模式的运用场景假设你在当前的Activity中又要启动同类型的Activity，此时建议将此类型Activity的启动模式指定为SingleTop，能够降低Activity的创建，节省内存！ 3. 注意：复用Activity时的生命周期回调这里还须要考虑一个Activity跳转时携带页面參数的问题。 由于当一个Activity设置了SingleTop或者SingleTask模式后，跳转此Activity出现复用原有Activity的情况时，此Activity的onCreate方法将不会再次运行。onCreate方法仅仅会在第一次创建Activity时被运行。 而一般onCreate方法中会进行该页面的数据初始化、UI初始化，假设页面的展示数据无关页面跳转传递的參数，则不必操心此问题，若页面展示的数据就是通过getInten() 方法来获取，那么问题就会出现：getInten()获取的一直都是老数据，根本无法接收跳转时传送的新数据！ 以下，通过一个样例来具体解释： 1234&lt;activity android:name=".activity.CourseDetailActivity" android:launchMode="singleTop" android:screenOrientation="portrait" /&gt; 12345678910111213141516171819202122public class CourseDetailActivity extends BaseActivity&#123; ...... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_course_detail_layout); initData(); initView(); &#125; //初始化数据 private void initData() &#123; Intent intent = getIntent(); mCourseID = intent.getStringExtra(COURSE_ID); &#125; //初始化UI private void initView() &#123; ...... &#125; ......&#125; 以上代码中的CourseDetailActivity在配置文件里设置了启动模式是SingleTop模式，依据上面启动模式的介绍可得知，当CourseDetailActivity处于栈顶时。再次跳转页面到CourseDetailActivity时会直接复用原有的Activity，并且此页面须要展示的数据是从getIntent(）方法得来，可是initData()方法不会再次被调用，此时页面就无法显示新的数据。 当然这样的情况系统早就为我们想过了，这时我们须要另外一个回调 onNewIntent（Intent intent）方法。此方法会传入最新的intent，这样我们就能够解决上述问题。这里建议的方法是又一次去setIntent。然后又一次去初始化数据和UI。代码例如以下所看到的： 12345678910/** 复用Activity时的生命周期回调*/ @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); setIntent(intent); initData(); initView(); &#125; 这样，在一个页面中能够反复跳转并显示不同的内容。 启动模式事实上是初学Android时会学到的知识点，曾经也是一知半懂，有些知识点事实上跟设计模式一样，你不去使用而仅仅是学习并不是能够掌握到精髓，仅仅有真正去使用才会将这些变成你自己的，文章部分内容參考了《Android开发艺术探索》。好书推荐。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC 进程间通信]]></title>
    <url>%2Fposts%2Fef58aead.html</url>
    <content type="text"><![CDATA[什么是IPCIPC(Inter-Process Communication) 进程间通信，是指两个不同进程之间数据交换的过程。 在明确其之前，需要先搞懂几个概念: 线程：CPU可调度的最小单位，是程序执行流的最小单元；线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。 进程： 一个执行单元，在PC 和移动设备上一般指一个程序或者应用，一个进程可以包含多个线程。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。 在Android程序中，一般情况下一个程序就是一个进程（在无特别的代码实现下），UI线程即主线程。如果有耗时操作，则会导致主线程堵死。而在Android中主线程负责UI，和用户交互，如果堵塞UI线程会影响用户体验。所以Android要求要将耗时操作放在子线程中执行。 IPC 使用场景 程序因为自身原因，需要采用多进程模式来实现。 有些模块由于特殊原因需要运行运行在单独的进程中。 为了加大一个应用可使用的内存所以需要通过多进程来获取内存空间。 当前应用需要向其他应用获取数据。由于是两个应用，即两个进程。 在Android 中，每一个应用可使用的内存大小有限制，早起的一些版本在16M左右，不同的设备有不同的大小。可以通过多进程获取多份内存空间。 Android多进程如何开启多进程Android中开启多进程只有一种方法，便是给四大组件指定android:process属性，除此之外没有其他方法。 请注意，不能指定某一个线程或者实体类指定其所运行的进程。 通过jni调用底层去开启多进程也是一种方法，但属于特殊情况，不进行考虑。 首先编写三个Activity，并在AndroidManifest.xml中注册： 12345678910111213141516&lt;activity android:name=".MainActivity" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name="com.example.ipc.SecondActivity" android:process=":remote" /&gt;&lt;activity android:name="com.example.ipc.ThirdActivity" android:process=".remote" /&gt; 对MainActivity不进行指定，则默认为当前进程。 对SecondActivity指定属性android:process=”:remote”。 对ThirdActivity指定属性android:process=”.remote”。 注意SencodActivity和ThirdActivity的进程参数不同。 把三个页面都打开，通过DDMS可以看到三个进程的开启： 那么SecondActivity和ThirdActivity ，进程名不同有什么区别吗； 如果进程名以：开始，表示是要在当前的进程名前附加上当前的包名，表示该进程是本应用的私有进程，其他应用不可以和其跑在同一个进程。如果进程名不以:开始，表示不需附加包名信息，是一个完全的命名。同时该进程是全局进程，其他应用可以通过ShareUID和其跑在同一个进程中。 开启多进程存在的问题通过如上方式，很简单的变开启了多进程，但是，如果仅仅这样的话，会有大问题。 看下面一个例子。 添加一个公有的类，添加静态字段： 12345public class PublicContant &#123; public static int m = 1;&#125; 在MainActivity中Log一下并修改字段： 12345678910@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.i("info", PublicContant.m+""); PublicContant.m++; &#125; 在SecondActivity中打印log： 1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.i("info", PublicContant.m+""); &#125; 根据上面的逻辑，Log信息应该是1，和2 。但是呢，不是这样的。 原因分析： Android 为每一个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同虚拟机中访问同一个类对象会产生多个副本。 对于当前来说，进程com.example.ipc和com.example.ipc:remote都存在一个PublicContant类，并且这两个类是相互不干扰的，一个进程中修改了该值的对象，对其他进程中的该值不会造成任何影响。 运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的。同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application的。 根据如上所述，多进程所造成的问题分为如下几个方面： 静态成员和单例模式完全失效；如上分析，创建了不同的内存，多个对象，当然单例什么的都无效了。 线程同步机制完全失效 ；不是一块内存区域，线程锁当然无效了。 SharedPreference的可靠性下降 ；sharedPreference的底层实现是通过读写XML文件，两个进程去读写，并发显然是可能出现问题的。 Application会多次创建。 序列化和反序列化在了解多进程通信之前，我们需要了解两个基础的概念，序列化和反序列化。 序列化：将对象转化为可保存的字节序列（注意是对象）； 反序列：将字节序列恢复为对象的过程。 序列化和反序列的用途： 以某种存储形式使自定义对象序列化； 将对象从一个地方传递到另一个地方； 通过序列化在进程间传递对象。 在Android中实现序列化的方式有两种，Serializable和Parcelable。 SerializableSerializable是Java提供的一个序列化接口，他是一个空接口，是类实现该接口即可实现序列化。 123456789101112131415/** * Serializable 序列化对象 */public class Book implements Serializable &#123; /** * 序列化和反序列的关键 */ private static final long serialVersionUID = 1L; public int bookId; public String bookName;&#125; 在实现Serializable时候，编译器会提示，让我们添加serialVersionUID字段，该字段是一个关键的字段，后面会说。 相应的实现好了，那么如何写入和读取呢？ 写入： 1234567891011121314public void writeSerializable() &#123; try &#123; // 构造对象 Book book = new Book(); // 构造序列化输出字节流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("xxx.txt")); // 序列化对象 oos.writeObject(book); // 关闭流 oos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 读取： 12345678910111213public void readSerializable() &#123; try &#123; // 创建序列化读取字节流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream( "xxx.txt")); // 反序列化（读取）对象 Book book = (Book) ois.readObject(); // 关闭流 ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 在序列化时，如果我们序列化对象之后，改变了我们的类结构（添加或改变字段），甚至是修改了字段的类型，修改了类名，那么我们能反序列化成功吗。 那么关键就在于serialVersionUID字段。 如果我们不指定的话。在序列化时，会计算当前类结构的hash值并将该值赋给serialVersionUID，当反序列时，会比对该值是否相同，如果不相同，则无法序列化成功。 我们也可以手动指定，手动指定的好处是在类结构发生变化时，能够最大程度的反序列，当然前提是只是删除或添加了字段，如果是变量类型发生了变化，则依然无法反序列成功。 serialVersionUID 的工作机制：序列化时系统会把当前类的serialVersionUID写入序列化文件中，当反序列化时候系统会去检测文件中的serialVersionUID,看它是否和当前类的serialVersionUID一致，如果一致说明序列化类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变化。所以，我们最好指定serialVersionUID，避免他自定生成。 ParcelableParcelable是Android中特有的一种序列化方式，在intent传值时，通常使用该方式。 该方式实现序列化，依然实现Parcelable，然后实现一些该接口的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Book implements Parcelable &#123; public int bookId; public String bookName; @Override public int describeContents() &#123; // 返回当前对象的内容描述。几乎所有情况下都是返回0 return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; // 将当前对象写入到序列化结构中 dest.writeInt(bookId); dest.writeString(bookName); &#125; public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Parcelable.Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; //从序列化后的对象中创建原始的值 Book book = new Book(); book.bookId = source.readInt(); book.bookName = source.readString(); return book; &#125; @Override public Book[] newArray(int size) &#123; //创建指定长度的原始对象数组 return new Book[size]; &#125; &#125;;&#125; Parcelable实现两个方法，创建一个字段： 实现describeContents()：返回当前对象的内容描述。几乎所有情况下都是返回0。 实现public void writeToParcel(Parcel dest, int flags)：// 将当前对象写入到序列化结构中 构造Parcelable.Creator字段，该对象需要实现两个方法： public Book createFromParcel(Parcel source)：从序列化后的对象中创建原始的值。 public Book[] newArray(int size)：创建指定长度的原始对象数组。 Serializable和Parcelable的比较 Serializable是Java中的序列化接口，其使用起来简单但是开销较大，序列化和反序列化需要大量的I/O操作。 Parcelable是Android中的序列化方式，更适用于Android的平台上，他的缺点是使用起来稍微麻烦，但是效率很高。 Parcelable适合进程间的通信，运行期。Serializable适合文件存储即网络传输。 Android 进程间通信的方式使用Bundle 传输数据Android中的四大组件中，其中有三大组件（Activity,Service,Receiver）都支持Intent中传递Bundle数据，如果看其源码，会发现其也是实现了Parcelable接口，所以其能够在不同进程中传输。 当然在传输的过程中，其所传输的数据必须支持序列化。比如基本数据类型，字符串，Parcelable的实现类，Serializable的实现类。由于该方法非常常用，不在多说。 文件共享文件共享： 将对象序列化之后保存到文件中，在通过反序列，将对象从文件中读取。 在MainActvity中写写入对象 1234567891011121314151617181920212223/** * 写入序列化对象 */ public void wirte() &#123; Book book = new Book(); book.bookId = 1; book.bookName = "si"; try &#123; // 构造序列化输出字节流 ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(PATH)); // 序列化对象 oos.writeObject(book); // 关闭流 oos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(book); &#125; 在SecondActivity中，读取文件（反序列化） 12345678910111213141516public void read() &#123; Book book = null; try &#123; // 创建序列化读取字节流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream( MainActivity.PATH)); // 反序列化（读取）对象 book = (Book) ois.readObject(); // 关闭流 ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(book); &#125; 输出结果如下： 1206-28 09:20:47.916: com.example.ipc(进程名) I/System.out(12399): Book [bookId=1, bookName=si]06-28 09:20:53.376: com.example.ipc:remote（进程名） I/System.out(12866): Book [bookId=1, bookName=si] 分属不同的进程成功的获取到了共享的数据。 通过共享文件这种方式来共享数据对文件的格式是没有具体的要求的。比如可以是文件，也可以是Xml、JSON 等。只要读写双方约定一定的格式即可。 同文件共享方式也存在着很大的局限性。即并发读/ 写的问题。读/写会造成数据不是最新。读写很明显会出现错误。 文件共享适合在对数据同步要求不高的进程之间进行通信。并且要妥善处理并发读写的问题。 SharedPreference 底层文件的方式。不适合在多进程中共享数据。 MessengerMessenger 可以翻译为信使，通过该对象，可以在不同的进程中传递Message对象。注意，两个单词不同。 下面就通过服务端（Service）和客户端(Activity)的方式进行演示。 客户端向服务端发送消息，可分为以下几步。 服务端 创建Service 构造Handler对象，实现handlerMessage方法。 通过Handler对象构造Messenger信使对象。 通过Service的onBind()返回信使中的Binder对象。 客户端 创建Actvity 绑定服务 创建ServiceConnection,监听绑定服务的回调。 通过onServiceConnected()方法的参数，构造客户端Messenger对象 通过Messenger向服务端发送消息。 实现服务端 1234567891011121314151617181920212223242526public class MessengerService extends Service &#123; /** * 构建handler 对象 */ public static Handler handler = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; // 接受客户端发送的消息 String msgClient = msg.getData().getString("msg"); Log.i("messenger","接收到客户端的消息--"+msgClient); &#125;; &#125;; // 通过handler 构建Mesenger 对象 private final Messenger messenger = new Messenger(handler); @Override public IBinder onBind(Intent intent) &#123; // 返回binder 对象 return messenger.getBinder(); &#125;&#125; 注意：MessengerService需要在AndroidManifest.xml中注册。 实现客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MessengerActivity extends AppCompatActivity &#123; /** * Messenger 对象 */ private Messenger mService; private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // IBinder 对象 // 通过服务端返回的Binder 对象 构造Messenger mService = new Messenger(service); Log.i("messenger", "客户端以获取服务端Messenger对象"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); // 启动服务 Intent intent = new Intent(this, MessengerService.class); bindService(intent, conn, BIND_AUTO_CREATE); &#125; /** * 布局文件中添加了一个按钮，点击该按钮的处理方法 * @param view */ public void send(View view) &#123; try &#123; // 向服务端发送消息 Message message = Message.obtain(); Bundle data = new Bundle(); data.putString("msg", "lalala"); message.setData(data); // 发送消息 mService.send(message); Log.i("messenger","向服务端发送了消息"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果如下： 注释很清楚，不在多说，按照流程实现即可。 其中有一点需要注意： 我们是通过Message作为媒介去携带数据的。但是，Message的obj 并没有实现序列化（实现Serializable或Parcelable）,也就是其不能保存数据。必须使用message.setData()方法去传入一个Bundle对象，Bundle中保存需要传入的数据。 传递时使用的是Messenger.send(Message)方法。 服务端向客户端发送了消息，那么服务端向客户端发送消息也类似： 关键点： 客户端向服务端发送消息是，通过msg.replyTo将客户端Messenger对象传给服务端。 客户端代码进行修改： 创建客户端Handler和Messenger对象。 修改send()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 构建handler 对象 */ public static Handler handler = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; // 接受服务端发送的消息 String msgService = msg.getData().getString("msg"); Log.i("messenger","接收到服务端的消息--"+msgService); &#125;; &#125;; // 通过handler 构建Mesenger 对象 private final Messenger messengerClient = new Messenger(handler); /** * 布局文件中添加了一个按钮，点击该按钮的处理方法 * @param view */ public void send(View view) &#123; try &#123; // 向服务端发送消息 Message message = Message.obtain(); Bundle data = new Bundle(); data.putString("msg", "lalala"); message.setData(data); // ----- 传入Messenger 对象 message.replyTo = messengerClient; // 发送消息 mService.send(message); Log.i("messenger","向服务端发送了消息"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 服务端代码修改： 123456789101112131415161718192021222324252627282930313233/** * 构建handler 对象 */ public static Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; // 接受客户端发送的消息 String msgClient = msg.getData().getString("msg"); Log.i("messenger", "接收到客户端的消息--" + msgClient); // 获取客户端Messenger 对象 Messenger messengetClient = msg.replyTo; // 向客户端发送消息 Message message = Message.obtain(); Bundle data = new Bundle(); data.putString("msg", "ccccc"); message.setData(data); try &#123; // 发送消息 messengetClient.send(message); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;; &#125;; 结果不再演示了。 AIDLAIDL是一种接口定义语言，用于约束两个进程间的通讯规则，供编译器生成代码，实现Android设备上的两个进程间通信(IPC)。 进程之间的通信信息，首先会被转换成AIDL协议消息，然后发送给对方，对方收到AIDL协议消息后再转换成相应的对象。 AIDL的关键便是Binder,关于Binder，后面的博客会分析。在这里之将如何使用它。 因为需要服务端和客户端共用aidl文件，所以最好单独建一个包，适合拷贝到客户端。 服务端： 添加如下包名：com.example.ipc.aidl 创建BookAidl.java,该对象需要作为传输。所以需要实现Parcelable。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class BookAidl implements Parcelable &#123; public int bookId; public String bookName; public BookAidl() &#123; super(); &#125; public BookAidl(int bookId, String bookName) &#123; super(); this.bookId = bookId; this.bookName = bookName; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(bookId); dest.writeString(bookName); &#125; public static final Parcelable.Creator&lt;BookAidl&gt; CREATOR = new Creator&lt;BookAidl&gt;() &#123; @Override public BookAidl[] newArray(int size) &#123; return new BookAidl[size]; &#125; @Override public BookAidl createFromParcel(Parcel source) &#123; BookAidl book = new BookAidl(); book.bookId = source.readInt(); book.bookName = source.readString(); return book; &#125; &#125;; @Override public String toString() &#123; return "BookAidl [bookId=" + bookId + ", bookName=" + bookName + "]"; &#125;&#125; 创建.aidl文件。因为需要用到BookAidl对象，所以需要先声明。 创建BookAidl.aidl文件，并手动添加。 123package com.example.ipc.aidl;Parcelable BookAidl; 创建IBookManager.aidl文件，接口文件，面向客户端调用： 12345678package com.example.ipc.aidl;import com.example.ipc.aidl.BookAidl;interface IBookManager&#123; List&lt;BookAidl&gt; getBookList(); void addBook(in BookAidl book);&#125; 写完之后clean一下工程，之后会在gen目录下生成对应的java文件。此java中的具体含义后面会解释，在此不做多述。 继续编写服务端，创建Service类。 12345678910111213141516171819202122232425262728293031323334353637383940public class BookService extends Service &#123; /** * 支持线程同步，因为其存在多个客户端同时连接的情况 */ private CopyOnWriteArrayList&lt;BookAidl&gt; list = new CopyOnWriteArrayList&lt;&gt;(); /** * 构造 aidl中声明的接口的Stub对象，并实现所声明的方法 */ private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;BookAidl&gt; getBookList() throws RemoteException &#123; return list; &#125; @Override public void addBook(BookAidl book) throws RemoteException &#123; list.add(book); Log.i("aidl", "服务端添加了一本书"+book.toString()); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); //加点书 list.add(new BookAidl(1, "java")); list.add(new BookAidl(2, "android")); &#125; @Override public IBinder onBind(Intent intent) &#123; // 返回给客户端的Binder对象 return mBinder; &#125;&#125; 在Service中，主要干了两件事情： 实现aidl文件中的接口的Stub对象。并实现方法。 将Binder对象通过onBinder返回给客户端。 为了省事，在这里不在另起一个工程了，直接将Service在另一个进程中运行。 123&lt;service android:name="com.example.ipc.BookService" android:process=":remote" /&gt; 开始编写客户端 因为在同一个工程中，不需要拷贝aidl包中的文件。如果不在同一个工程，需要拷贝。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class BookActivity extends AppCompatActivity&#123; /** * 接口对象 */ private IBookManager mService; /** * 绑定服务的回调 */ private ServiceConnection conn = new ServiceConnection()&#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 获取到书籍管理的对象 mService = IBookManager.Stub.asInterface(service); Log.i("aidl", "连接到服务端，获取IBookManager的对象"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_book); // 启动服务 Intent intent = new Intent(this,BookService.class); bindService(intent, conn, BIND_AUTO_CREATE); &#125; /** * 获取服务端书籍列表 * @param view */ public void getBookList(View view)&#123; try &#123; Log.i("aidl","客户端查询书籍"+mService.getBookList().toString()); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 添加书籍 */ public void add(View view)&#123; try &#123; // 调用服务端添加书籍 mService.addBook(new BookAidl(3,"iOS")); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 客户端的代码和之前的Messenger很类似： 绑定服务，监听回调。 将回调中的IBinder service通过IBookManager.Stub.asInterface（）转化为借口对象。 调用借口对象的方法。 效果 总结来说可分为如下几步 服务端： 服务端创建.aidl文件和声明接口 创建类，继承Service，并实现onBind方法 在Service类中定义aidl中声明接口的Stub对象，并实现aidl接口中声明的方法 在onBind方法中返回Stub对象 在AndroidManifest.xml中注册Service并声明其Action 客户端 使用服务端提供的aidl文件 在Activity定义aidl接口对象 定义ServiceConnection对象，监听绑定服务的回调 回调中通过方法获取借口对象 ContentProvider作为android 四大组件之一，虽然用的地方不是太多。但是其确实是多进程通信的一种方式。例如，获取通讯录信息，这明显跨应用了，肯定是多进程通信啊。 其底层实现和Messenger一样，都是通过Binder,后面会专门分析Binder对象。 ContentProvider很多介绍，在这不在多提。 SocketSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据报套接字，分别对应于网络传输中的传输控制层的TCP和UDP。 该方面使用的是JAVA 方面的知识。该举例只是说明一个思路。不做细致的实现。 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class SocketService extends Service &#123; /** * 连接的状态 */ private boolean isConnState = true; @Override public void onCreate() &#123; super.onCreate(); // 启动TCP 服务 new Thread(new TCPServer()).start(); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onDestroy() &#123; // 结束TCP 服务 isConnState = false; super.onDestroy(); &#125; /** * 服务端TCP 服务，相当于服务器，接受Socket 连接 * @author MH * */ class TCPServer implements Runnable&#123; @Override public void run() &#123; try &#123; // 监听本地的12345 端口 ServerSocket ss = new ServerSocket(12345); while(isConnState)&#123; // 获取客户端的Socket 对象 Socket socket = ss.accept(); // 获取输入流 --- BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 通过输入流读取客户端的消息 //String line = br.readLine(); // 输出流 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); // 通过输出流向客户端发送消息 //bw.write("...."); // 关闭连接 socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 服务启动时，在onCreate方法中启动了TCPServer，该线程时刻接受客户端的请求。 客户端 1234567891011121314151617public void conn()&#123; try &#123; // 指定ip和端口 Socket s = new Socket("localhost", 12345); // ----- 和服务端类似 BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream())); //String line = br.readLine(); // 输出流 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); //bw.write("...."); // 关闭连接 s.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 关于Socket，在此只是一个简单的示范。 Android 进程间通信不同方式的比较 Bundle:四大组件间的进程间通信方式，简单易用，但传输的数据类型受限。 文件共享： 不适合高并发场景，并且无法做到进程间的及时通信。 Messenger: 数据通过Message传输，只能传输Bundle支持的类型 ContentProvider：android 系统提供的。简单易用。但使用受限，只能根据特定规则访问数据。 AIDL:功能强大，支持实时通信，但使用稍微复杂。 Socket：网络数据交换的常用方式。不推荐使用。 Binder 的细致分析在实现多进程通信时，其中Messenger,ContentProvider,AIDL的底层实现都是Binder，很有必要对其进行继续分析。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle使用总结（二）]]></title>
    <url>%2Fposts%2F1f4ffc21.html</url>
    <content type="text"><![CDATA[一、自定义Android gradle工程1、defaultConfig默认配置 defaultConfig 是默认的配置，是一个ProductFlavour。对于多渠道打包，等情况，如果不针对自定义的是一个ProductFlavour单独配置的话，则默认使用defaultConfig的配置 （1）applicationId指定生成的app包名，对应值是 String，如：applicationId &quot;com.android.xx&quot; （2）minSdkVersionApp最低支持的Android操作系统版本，对应值是 int型（即对于sdk 的ApiLevel）如，minSdkVersion 25 （3）targetSdkVersion配置当前是基于哪个sdk版本进行开发，可选值与 minSdkVersion一样 （4）versionCode内部版本号，对应值是int型，用于配置Android App内部版本号，通常用于版本的升级 （5）versionName用于配置app的版本名称，对应值是String，如”v1.0.0”，让用户知道当前app版本。versionCode是内部使用，versionName是外部使用，一起配合完成app的版本升级控制。 （6）testApplicationId配置测试app的包名，默认是 applicationId + “.test”，一般情况下，用默认的即可。 （7）testInstrumentationRunner用于配置单元测试时使用的Runner，默认使用android.test.InstrumentationTestRunner。 （8）signingConfig配置默认的签名信息，对生成的app进行签名。对应值是SigningConfig对象。 具体使用，查看*配置签名信息*部分。 （9）proguardFile 和 proguardFiles两者都是配置混淆规则文件，区别是proguardFile接受一个文件对象，而proguardFiles可以同时接受多个。 （10）multiDexEnabled是否启动自动拆分多个Dex的功能，用于突破方法超过65535的设置，后面再具体介绍 1multiDexEnabled true 2、配置签名信息 Android Gradle 提供了signingConfigs{}配置块，用于生成多个签名配置信息，其类型是NamedDomainObjectContainer，因此，我们在signingConfigs{}中定义的都是一个SigningConfig的对象实例。 一个SigningConfig，即签名配置，可配置的元素有：storeFile: 签名文件位置；storeType：签名证书类型（可不填）；storePassword：签名证书密码；keyAlias：签名证书密钥别名；keyPassword：签名证书中的密钥的密码。如： 12345678signingConfigs&#123; release&#123; //生成了release的签名配置 storeFile file('../John.jks') storePassword '12345678' keyAlias 'key0' keyPassword '12345678' &#125; &#125; 注：debug签名文件一般位于$HOME/.android/debug.keystore 对于生成的签名配置，可以应用到 defaultConfig中的signingConfig进行默认签名配置或应用到buildTypes中针对构建类型进行签名配置。如： 1234567891011121314151617buildTypes &#123; release &#123; signingConfig signingConfigs.release //配置release类型签名 minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; defaultConfig &#123; applicationId "com.example.john.tapeview" minSdkVersion 24 targetSdkVersion 28 versionCode 1 versionName "1.0" signingConfig signingConfigs.release //配置默认签名 testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; 3、构建类型（buildTypes） buildTypes{} 和signingConfigs{}一样，都是Android 的一个方法，接收到也是域对象 NamedDomainObjectContainer，添加的每一个都是BuildType类型。 每一个BuildType都会生成一个SourceSet，默认位置是src//，因此，可以单独为其指定Java源代码和res资源等。且，新增的BuildType不能命名为 main 或 androidTest（因android默认已经生成），且相互之间不能同名。 （1）applicationIdSuffix用于配置基于applicationId的后缀，如applicationId为 com.John.gradle.sample , 在debug的buildType中指定 applicationIdSuffix &quot;.debug&quot;，则生成的debug的包名为com.John.gradle.sample.debug （2）signingConfig配置签名信息，使用同前面提到的 defaultConfig一样。 （3）启动zipAlign优化zipalign是android提供的整理优化apk的工具，能提高系统和应用的运行效率，更快读写apk资源，降低内存，所以，对于发布的apk，一般开启 zipAlignEnabled true //true为开启 （4）资源清理shrinkResources用于配置是否自动清理未使用的资源，true为开启，false为关闭。需结合混淆使用。 （5）使用混淆 minifyEnabled启用混淆可以优化代码，同时结合shrinkResources清理资源，可以缩小apk包，还可以混淆代码。一般发布的都是要混淆的。 开启混淆：minifyEnabled true //true为开启；使用proguardFile和proguardFiles设置混淆规则文件，两者区别如前面defaultConfig中说明。 注：对于多渠道打包，每个productFlavor都可以单独配置混淆规则文件（通过各自的proguardFile和proguardFiles）。 （6）multiDexEnabled是否启动自动拆分多个Dex的功能，用于突破方法超过65535的设置，后面再具体介绍 1multiDexEnabled true （7）debuggable 和 jniDebuggabledebuggable：是否生成一个可供调试的apk，对应值为boolean类型； jniDebuggable：是否生成一个可供调试Jni（C/C++）代码的apk，对应值为boolean类型； 二、Android gradle高级自定义1、批量修改生成的apk文件名Android Gradle提供了3个属性，applicationVariants（仅仅适用于Android 应用Gradle插件），和libraryVariants（仅仅适用于Android库gradle插件），testVariants（以上两种都适用） applicationVariants是一个集合，每一个元素都是一个生成的产物，即 xxxRelease 和 xxxDebug 等（即生成apk） ，它有一个outputs作为输出集合。遍历，若名字以.apk结尾，那么就是要修改的apk输出。 1234567891011//动态改变生成的apk的名字： 项目名_渠道名_v版本名_构建日期.apk applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; output -&gt; if (output.outputFile != null &amp;&amp; output.outputFile.name.endsWith('.apk') &amp;&amp;'release'==(variant.buildType.name)) &#123; def flavorName = variant.flavorName.startsWith("_") ? variant.flavorName.substring(1) : variant.flavorName def apkFileName = "Example92_$&#123;flavorName&#125;_v$&#123;variant.versionName&#125;_$&#123;buildTime()&#125;.apk" outputFileName = apkFileName &#125; &#125; &#125; 2、多方式配置 VersionCode 和 VersionName（1）通过应用脚本插件（apply from） 新建一个version.gradle（当前存放在项目路径下的gradle文件夹中），并设置自定义属性 1234ext&#123; appVersionCode = 1 appVersionName = '1.0.2'&#125; 在rootProject中应用该脚本文件 1apply from : 'gradle/version.gradle' 可在任意子工程中引用该设置： （2）直接在属性文件（xxx.properties）中定义使用 在工程目录下的gradle.properties中定义 可在任意子工程中引用该设置： （3）从 git 的 tag 上获取 VersionName 和 versionCode12345678910111213141516171819202122232425/** * 以git tag的数量作为其版本号 * @return tag的数量 */def static getAppVersionCode()&#123; def stdout = new ByteArrayOutputStream() exec &#123; commandLine 'git','tag','--list' standardOutput = stdout &#125; return stdout.toString().split("\n").size()&#125;/** * 从git tag中获取应用的版本名称 * @return git tag的名称 */def static getAppVersionName()&#123; def stdout = new ByteArrayOutputStream() exec &#123; commandLine 'git','describe','--abbrev=0','--tags' standardOutput = stdout &#125; return stdout.toString().replaceAll("\n","")&#125; 3、动态配置AndroidManifest文件 在构建过程，动态修改AndroidManifest文件中的内容 android gradle 提供了非常便捷的方法替换AndroidManifest文件中的内容，即manifestPlaceholder、Manifest占位符。 manifestPlaceholders是ProductFlavor的一个属性，Map类型，所以可以同时配置多个占位符。 定义占位符： 123456789101112...productFlavors&#123; google&#123; manifestPlaceholders.put("UMENG_CHANNEL","google") &#125; baidu&#123; manifestPlaceholders.put("UMENG_CHANNEL","baidu") &#125;&#125;... 在AndroidManifes中使用这个占位符 “UMENG_CHANNEL” 1234567...&lt;application&gt; ... &lt;meta-data android:value="$&#123;UMENG_CHANNEL&#125;" android:name = "UMENG_CHANNEL"/&gt; ...&lt;/application&gt;... 亦可以迭代修改占位符 1234567891011...productFlavors&#123; google&#123; &#125; baidu&#123; &#125; &#125;productFlavors.all&#123;flavor-&gt; manifestPlaceholders.put("UMENG_CHANNEL",flavor.name)&#125;... 4、自定义BuildConfigAndroid gradle提供了buildConfigField(Srting type,String name ,String value) 来实现添加常量到BuildConfig中。一般在productFlavors或buildTypes中使用: 注：对于value是String类型的，双引号一定得加上，这里写了什么，buildConfig会原封不动放上去 1234567891011...productFlavors&#123; google&#123; //对于value是String类型的，双引号一定得加上，这里写了什么，buildConfig会原封不动放上去 buildConfigField 'String','name','"google"' &#125; baidu&#123; buildConfigField 'String','name','"baidu"' &#125;&#125;... 5、动态添加自定义的资源Android gradle提供了resValue(String type,String name,String value)来 添加资源。只能在productFlavors或buildTypes中使用 注：这里写了什么，编译出来后也会原封不动放上去 6、Dex选项配置123456789101112android &#123; ... dexOptions &#123; incremental true //android studio3.x以上已废弃，是否开启dx增量模式 javaMaxHeapSize '4g' //提高java执行dx命令时的最大分配内存 jumboMode true //强制开启jumboMode模式，让方法超过65535也构建成功 pre &#125; ...&#125; 7、编译选项和adb操作选项123456789101112131415android &#123; ... compileOptions &#123; encoding = 'utf-8' sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; adbOptions&#123; timeOutInMs = 5000 //设置超时时间，单位 ms installOptions '-r','-s'//安装选项，一般不使用 &#125; ...&#125; 8、突破方法超过65535的限制 在defaultConfig或buildTypes或productFlavors中，开启multiDexEnabled：multiDexEnabled true 增加依赖：implementation &#39;com.android.support:multidex:1.0.3&#39; 在自定义的 Application 中设置（5.0以上天然支持）： 使自定义的Application继承MultiDexApplication 或直接在java代码中修改： 1234567...@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this);&#125;... 多渠道构建 一个构建产物（apk），即Build Variant = BuildType + ProductFlavor，其中ProductFlavor又进一步划分dimensions，即Build Variant = BuildType + ProductFlavor’s dimensions 1、多渠道构建ProductFlavor属性1234567...productFlavors&#123; google&#123; applicationId "com.john.xxx" &#125;&#125;... （1）applicationId，跟前面所述一样。（2）manifestPlaceholders，跟前面所述一样。（3）multiDexEnabled，跟前面所述一样。（4）proguardFiles，跟前面所述一样。（5）signingConfig，跟前面所述一样。（6）testApplicationId，跟前面所述一样。（7）versionCode 和 versionName，跟前面所述一样。（8）dimension 作为ProductFlavor的维度，可理解为ProductFlavor的分组 如，free 和 paid 属于version分组，而x86 和 arm属于架构分组： 1234567891011121314151617181920android&#123; ... flavorDimensions "version","abi" //定义分组 productFlavors&#123; free&#123; dimension 'version' &#125; paid&#123; dimension 'version' &#125; x86&#123; dimension 'abi' &#125; arm&#123; dimension 'abi' &#125; &#125; ...&#125; 对于以上的设置，Build Variant = BuildType + ProductFlavor’s dimensions，则生成的assemble任务， 即variant： ArmFreeDebug ArmFreeRelaese ArmPaidDebug ArmPaidRelease X86FreeDebug X86FreeRelaese X86PaidDebug X86PaidRelease 参考链接Android Developer官网]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle使用总结（一）]]></title>
    <url>%2Fposts%2F2f5910f9.html</url>
    <content type="text"><![CDATA[Gradle是一款优秀的构建系统工具，它的DSL(领域特定语言)基于Groovy实现，可以方便地通过代码控制这些DSL来达到构建的目的。 注：执行gradle命令时，默认加载当前目录下的build.gradle文件，亦可以通过-b 指定要加载的执行文件，如： gradlew -b ./app/build.gradle assemble Gradle常用基础1、记得使用帮助（1）查看所有可执行的任务（Tasks）1gradlew tasks Gradle会以分组的方式列出task列表，比如构建类的 assemable，帮助类的 help等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283------------------------------------------------------------All tasks runnable from root project------------------------------------------------------------Android tasks-------------androidDependencies - Displays the Android dependencies of the project.signingReport - Displays the signing info for each variant.sourceSets - Prints out all the source sets defined in this project.Build tasks-----------assemble - Assembles all variants of all applications and secondary packages.assembleAndroidTest - Assembles all the Test applications.assembleDebug - Assembles all Debug builds.assembleRelease - Assembles all Release builds.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.bundleDebug - Creates all Debug bundles.bundleRelease - Creates all Release bundles.clean - Deletes the build directory.cleanBuildCache - Deletes the build cache directory.compileDebugAndroidTestSourcescompileDebugSourcescompileDebugUnitTestSourcescompileReleaseSourcescompileReleaseUnitTestSourcesBuild Setup tasks-----------------init - Initializes a new Gradle build.wrapper - Generates Gradle wrapper files.Cleanup tasks-------------lintFix - Runs lint on all variants and applies any safe suggestions to the source code.Help tasks----------buildEnvironment - Displays all buildscript dependencies declared in root project 'tapeView'.components - Displays the components produced by root project 'tapeView'. [incubating]dependencies - Displays all dependencies declared in root project 'tapeView'.dependencyInsight - Displays the insight into a specific dependency in root project 'tapeView'.dependentComponents - Displays the dependent components of components in root project 'tapeView'. [incubating]help - Displays a help message.model - Displays the configuration model of root project 'tapeView'. [incubating]projects - Displays the sub-projects of root project 'tapeView'.properties - Displays the properties of root project 'tapeView'.tasks - Displays the tasks runnable from root project 'tapeView' (some of the displayed tasks may belong to subprojects).Install tasks-------------installDebug - Installs the Debug build.installDebugAndroidTest - Installs the android (on device) tests for the Debug build.installRelease - Installs the Release build.uninstallAll - Uninstall all applications.uninstallDebug - Uninstalls the Debug build.uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build.uninstallRelease - Uninstalls the Release build.Verification tasks------------------check - Runs all checks.connectedAndroidTest - Installs and runs instrumentation tests for all flavors on connected devices.connectedCheck - Runs all device checks on currently connected devices.connectedDebugAndroidTest - Installs and runs the tests for debug on connected devices.deviceAndroidTest - Installs and runs instrumentation tests using all Device Providers.deviceCheck - Runs all device checks using Device Providers and Test Servers.lint - Runs lint on all variants.lintDebug - Runs lint on the Debug build.lintRelease - Runs lint on the Release build.lintVitalRelease - Runs lint on just the fatal issues in the release build.test - Run unit tests for all variants.testDebugUnitTest - Run unit tests for the debug build.testReleaseUnitTest - Run unit tests for the release build.To see all tasks and more detail, run gradle tasks --allTo see more detail about a task, run gradle help --task &lt;task&gt;BUILD SUCCESSFUL in 18s1 actionable task: 1 executed （2）Gradle Help任务gradle内置的help任务，可以了解每一个Task的使用帮助，用法是gradlew help --task &lt;taskName&gt; 如：gradlew help --task assemable 2、强制刷新依赖1gradlew --refresh-dependencies assemable 3、多任务执行只需按顺序以空格分开即可，如gradlew clean jar，先执行clean再执行生成jar 4、自定义属性自定义属性具有更广泛的作用域，可以跨Project，跨Task访问。只要能访问这些属性所属的对象，那么这些属性就可以被访问到。 123456789101112131415161718192021222324252627282930313233343536373839apply plugin: "java"ext.age = 18 //自定义一个属性//自定义多个属性ext&#123; phone = '020' address = '' dep = [android : "androidan"] //map&#125;sourceSets.all&#123; ext.resourcesDir = null&#125;sourceSets &#123; main&#123; resourcesDir="main/res" &#125; test&#123; resourcesDir="test/res" &#125;&#125;task customProperty&#123; doLast&#123; println "age: $&#123;age&#125;" println "phone: $phone" println "address: $address" println "android: $&#123;dep.android&#125;" sourceSets.each&#123; println"$&#123;it.name&#125;'s resourcesDir is: $&#123;it.resourcesDir&#125;" &#125; &#125; &#125; 5、任务的禁用和开启任务禁用时，当执行到该任务，会skip掉 1234567task task1&#123; doLast&#123; println 'xxx' &#125;&#125;task1.enabled = false; //false:禁用，true:开启 6、任务的onlyif 断言任务有一个onlyIf方法，接收一个闭包作为参数，如果该闭包返回true，则该任务执行，否则跳过 以键值对的形式添加属性：-PK=V，中间不能有空格 ，如：gradle -Pbuild_apps=shoufa build 12345678910111213141516171819202122232425262728293031323334final String BUILD_APPS_ALL="all";final String BUILD_APPS_SHOUFA="shoufa";final String BUILD_APPS_EXCLUDE_SHOUFA="exclude_shoufa";task QQRelease&#123; doLast&#123; println "QQRelease" &#125; &#125;task BaiduRelease&#123; doLast&#123; println "BaiduRelease" &#125; &#125;task build&#123; group BasePlugin.BUILD_GROUP description '打渠道包' dependsOn QQRelease,BaiduRelease&#125;QQRelease.onlyIf&#123; if (project.hasProperty('build_apps')) &#123; Object buildApps = project.property("build_apps") if (BUILD_APPS_SHOUFA.equals(buildApps)) &#123; return false &#125; &#125; return true;&#125;//gradle -Pbuild_apps=shoufa build; //以键值对的形式添加属性：-PK=V，中间不能有空格 7、脚本即代码，代码也是脚本虽然Gradle是个脚本文件，但写的依旧是代码，Groovy是兼容Java的，能灵活实现很多功能。如，给生成的apk以当前时间命名： 12345def buildTime()&#123; def date = new Date() def formattedDate = data.format('yyyyMMdd') return formattedDate&#125; Groovy基础1、字符串单引号和双引号都能定义字符串。区别在于，单引号表示纯粹的字符串常量，而双引号具有运算能力。 如: 1234def name = "John"println '单引号$&#123;name&#125;' //输出: 单引号$&#123;name&#125;println "双引号$&#123;name&#125;" //输出: 双引号Johnprintln "双引号$name" //输出: 双引号John 一个美元符号紧接着一对花括号，花括号里放表达式，如${name}，当只有一个变量时，可以省略花括号，如$name; 2、集合（1）List12345def nums = [1,2,3,4] //定义arrayListprintln nums[1] //下标索引访问nums.each&#123; println it //forEach,其中it变量为正在迭代的元素&#125; （2）Map123456def map = ['width':1024,'height':768] //定义mapprintln map['width'] //访问println map.height //访问map.each&#123; println "Key:$&#123;it.key&#125;,Value:$it.value" //forEach,被变量的是Map.Entry&#125; （3）方法 括号是可以忽略的 12345method1(2,3) //method1 2,3 //可忽略括号，def method1(int a,int b)&#123; println a+b&#125; return 是可以不写的，最后一句代码作为其返回值 1234567def method2(int a,int b)&#123; if(a&gt;b)&#123; a //即return a; &#125;else &#123; b //即return b; &#125;&#125; 代码块/方法是可以作为参数传递的 12345678910111213141516171819202122//呆板写法nums.each(&#123;println it&#125;)//格式化一些nums.each(&#123; println it&#125;)//Groovy中，如果方法的最后一个参数是 闭包，则可以放到方法外面nums.each()&#123; println it&#125;//然后省略括号，则变成常见的样式nums.each&#123; println it&#125;//多参数调用eachMap&#123;k,v-&gt; println "$k is $v"&#125; JavaBean,可以很容易地访问和修改属性值，而不用通过getter/setter，因Groovy内部已帮我们搞定好。 12345678def Person p = new Person()println "name is $p.name" //输出nullp.name = "John" println "name is $p.name" //输出Johnclass Person &#123; private String name&#125; 闭包委托 Groovy的闭包有thisObject、owner和delegate三个属性，一般是thisObject&gt;owner&gt;delegate，但可以修改delegate。一般指定delegate为当前it，这样就可以在闭包内对该it进行配置，或调用其方法。 12345678910111213141516171819202122232425262728293031task delegate&#123; doLast&#123; person&#123; name = "cap" //在闭包内对该it进行配置 age = 20 //在闭包内对该it进行配置 dumpPersion() //在闭包内对该it调用其方法 &#125; &#125;&#125;def dumpPersion()&#123; println "project delegate"&#125;class Person&#123; private String name private int age def dumpPersion()&#123; println "name:$&#123;name&#125;;age:$&#123;age&#125;" &#125;&#125;def person(Closure&lt;Person&gt; closure)&#123; Person p = new Person() closure.delegate = p //设置委托 closure.setResolveStrategy(Closure.DELEGATE_FIRST)//设置委托优先 closure(p)&#125; Gradle 插件1、Java Gradle 的sourceSets常用属性sourceSet，即源代码集合（Android的buildTypes和这个类似），用来描述和管理源代码和资源存放等功能。提供有sourceSets{}闭包放配置和生成sourceSet，如： 123456789101112131415sourceSets&#123; main&#123; //在这里可以对main sourceSet进行配置 java&#123; srcDir 'src/java' //更改了java源代码存放目录，默认是 src/main/java &#125; resources&#123; srcDir 'src/resources' //更改了资源文件存放目录，默认是 src/main/resources &#125; &#125; vip&#123; //生成了新的 vip sourceSet &#125;&#125; SourceSet常用属性： 属性名 类型 描述 name String 只读，如，main java SourceDirectorySet 该源集的java源文件 java.srcDirs Set 该源集的java源文件所在目录 resources SourceDirectorySet 该源集的资源文件 resources.srcDirs Set 该源集的资源文件的所在目录 output.classesDir File 该源集编译后的class文件目录 output.resourcesDir File 编译后生成的资源目录 compileClassPath FileCollection 编译该源集时所需的classPath 2、Android Gradle插件分类和三个sourceSetAndroid Gradle插件的分类是根据Anroid工程的属性分类的，在Android中，有3类： App应用工程插件id: com.android.application Library库工程插件id: com.android.library Test测试工程插件id: com.android.test 注：src目录下的androidTest，main，test分别是3个sourceSet，分别对应，Android单元测试代码，Android app主代码和资源，普通单元测试代码。 在main中，特有AndroidManifest.xml和res这两个Android特有的，用于描述Android App 配置和资源文件。]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用库和插件]]></title>
    <url>%2Fposts%2Fbb30f1ae.html</url>
    <content type="text"><![CDATA[下拉刷新PullLoadMoreRecyclerView 实现RecyclerView下拉刷新和上拉加载更多以及RecyclerView线性、网格、瀑布流效果演示 https://github.com/WuXiaolong/PullLoadMoreRecyclerView start 1247 android-Ultra-Pull-To-Refresh 这是现在已经停止维护的下拉刷新项目的替代方案。继承于ViewGroup可以包含任何View。功能比SwipeRefreshLayout强大。使用起来非常简单。良好的设计，如果你想定制自己的UI样式，非常简单，就像给ListView加一个Header View那么简单。 https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh start 9322 SmartRefreshLayout 下拉刷新、上拉加载、二级刷新、淘宝二楼、RefreshLayout、OverScroll，Android智能下拉刷新框架，支持越界回弹、越界拖动，具有极强的扩展性，集成了几十种炫酷的Header和 Footer。 https://github.com/scwang90/SmartRefreshLayout start 14453 一个实用的多条件筛选菜单DropDownMenu 一个实用的多条件筛选菜单，在很多App上都能看到这个效果，如美团，爱奇艺电影票等 https://github.com/dongjunkun/DropDownMenu start 2997 强大易用的安卓工具类库AndroidUtilCode 是一个强大易用的安卓工具类库，它合理地封装了安卓开发中常用的函数，具有完善的 Demo 和单元测试，利用其封装好的 APIs 可以大大提高开发效率，如今它主要包括两部分模块，其一是主工具类模块：utilcode，其中的工具类是开发中常用到的；其二是子工具类模块：subutil，它包含的工具类并不是很常用，它的出现是为了防止主工具类的臃肿。 https://github.com/Blankj/AndroidUtilCode start 20125 SuperUtils 囊括了一大部分Android应用开发过程当中常用的工具类。工具类来源整理自网络和自己编写。 https://github.com/AllenCoder/SuperUtils start 310 Android第三方相册选择器Matisse 知乎开源相册 https://github.com/hamuamu0/Matisse start 7881 ImagePicker 完全仿微信的图片选择 https://github.com/jeasonlzy/ImagePicker start 3262 PictureSelector 一款针对android平台下的图片选择器，支持从相册或拍照选择图片或视频、音频，支持动态权限获取、裁剪(单图or多图裁剪)、压缩、主题自定义配置等功能、适配android 6.0+系统的开源图片选择框架。 https://github.com/LuckSiege/PictureSelector start 4762 ImagePicker 一款功能超强的图片选择器。支持超大图预览(比如10000*5000的图)，支持图片裁剪，可配置头像模式和普通模式，支持动态配置ImageLoader以支持多种图片加载库，以及实现流畅的跳转动画 https://github.com/martin90s/ImagePicker start 832 TakePhoto 一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 https://github.com/crazycodeboy/TakePhoto start 5553 Album https://github.com/yanzhenjie/Album start 1802 可用于动态生成验证码，常见于金融类appVerificationCodeView https://github.com/Freshman111/VerificationCodeView start 354 类似于微信侧滑返回上一级Activity的工具SwipeBackHelper https://github.com/Jude95/SwipeBackHelper/blob/master/README_ch.md start 1266 SwipeBackLayout https://github.com/ikew0ng/SwipeBackLayout start 5352 Banner轮播ViewPagerandroid-auto-scroll-view-pager https://github.com/Trinea/android-auto-scroll-view-pager start 1603 UltraViewPager UltraViewPager是一个封装多种特性的ViewPager，主要是为多页面切换场景提供统一解决方案。支持横划竖划；支持一屏内显示多页；支持循环滚动；支持定时滚动，计时器使用Handler实现 https://github.com/alibaba/UltraViewPager start 3942 ViewPagerIndicator Indicator 取代 tabhost，实现网易顶部tab，新浪微博主页底部tab，引导页，无限轮播banner等效果，高度自定义tab和特效 https://github.com/LuckyJayce/ViewPagerIndicator start 2166 RecyclerViewPager 扩形式的recyclerView，配合ViewPager实现各种效果 https://github.com/lsjwzh/RecyclerViewPager start 3149 banner Android广告图片轮播控件，支持无限循环和多种主题，可以灵活设置轮播样式、动画、轮播和切换时间、位置、图片加载框架等！ https://github.com/youth5201314/banner start 6938 XBanner 支持图片无限轮播，支持自定义指示点、显示提示文字、切换动画等 https://github.com/xiaohaibin/XBanner start 516 BGABanner-Android 引导界面滑动导航 + 大于等于1页时无限轮播 + 各种切换动画轮播效果 https://github.com/bingoogolapple/BGABanner-Android start 2914 Android图片压缩工具Luban(鲁班) 可能是最接近微信朋友圈的图片压缩算法 https://github.com/Curzibn/Luban start 8469 侧滑菜单SlidingRootNav https://github.com/yarolegovich/SlidingRootNav start 2385 选择器Android-PickerView 一款仿iOS的PickerView控件，有时间选择和选项选择，并支持一二三级联动，支持自定义样式 https://github.com/Bigkoo/Android-PickerView start 8346 android-picker 安卓选择器类库，包括日期选择器、时间选择器、单项选择器、城市选择器、颜色选择器、文件选择器、目录选择器、数字选择器、星座选择器、生肖选择器等，可自定义顶部及底部界面，可自定义窗口动画。 https://github.com/sevenli777/android-picker start 36 MultiType-FilePicker 第三方选择器，可以选择文件、图片 https://github.com/fishwjy/MultiType-FilePicker 简洁验证码输入框，能自定义输入框个数和样式VerificationCodeInput https://github.com/liuguangli/VerificationCodeInput start 257 RecyclerViewIndexRecyclerView 一款联系人选择的recyclerView列表，支持顶部悬浮和侧边滑动首字母选择 https://github.com/jiang111/IndexRecyclerView start 1114 ExpandableLayout 点击可扩大隐藏列表 https://github.com/traex/ExpandableLayout start 1499 SwipeRecyclerView 侧滑菜单，长按拖拽，滑动删除，自动加载更多，和ViewPager结合使用，和任何下拉刷新框架结合使用。 https://github.com/yanzhenjie/SwipeRecyclerView start 3446 IndexableRecyclerView 轻轻松实现：选择城市，选择联系人等需要索引的功能松实现：选择城市，选择联系人等需要索引的功能 https://github.com/YoKeyword/IndexableRecyclerView start 982 Android换肤／夜间模式的Android框架MultipleTheme https://github.com/dersoncheng/MultipleTheme start 1521 强大的RecyclerAdapter框架BaseRecyclerViewAdapterHelper https://github.com/CymChad/BaseRecyclerViewAdapterHelper start 3215 SuperAdapter https://github.com/byteam/SuperAdapter start 629 更换主题、设置状态栏的工具类StatusBarUtil (实现沉浸栏状态栏颜色状态) https://github.com/laobie/StatusBarUtil start 6211 MagicaSakura Android 多主题框架 https://github.com/Bilibili/MagicaSakura start 2915 DialogBasePopup 打造通用的popupwindow https://github.com/razerdp/BasePopup start 1618 AndroidBottomSheet 底部弹出popupwindow https://github.com/michael-rapp/AndroidBottomSheet start 300 BottomDialog 自定义的从底部弹出的dialog，仿照微博的分享弹框 https://github.com/Curzibn/BottomDialog start 375 AndroidSuperDialog 支持自定义边框圆角、背景透明度、字体大小与色值等 https://github.com/mylhyl/AndroidSuperDialog start 131 material-dialogs md风格的dialog https://github.com/afollestad/material-dialogs start 14288 Android-AlertView 仿iOS的AlertViewController 几乎完美还原iOS 的 AlertViewController ，同时支持Alert和ActionSheet模式，每一个细节都是精雕细琢，并把api封装成懒到极致模式，一行代码就可以进行弹窗. https://github.com/Bigkoo/Android-AlertView start 1212 加载LoadingLoadingLayout 项目里都会遇到几种页面，分别为加载中、无网络、无数据、出错四种情况，经常要使用，所以封成库引用了 https://github.com/weavey/LoadingLayoutDemo start 634 NumberProgressBar 带数字的进度条滚动 https://github.com/daimajia/NumberProgressBar start 5162 KProgressHUD 仿iOS加载 https://github.com/Kaopiz/KProgressHUD start 1128 GifLoadingView https://github.com/Rogero0o/GifLoadingView start 1177 音乐播放Timber MD风格的音乐播放 https://github.com/naman14/Timber start 5145 CustomLrcView-master 自定义显示歌词的控件，实现了歌词的平滑向上滚动，当高亮歌词宽度超过了view的宽的时候，水平滚动 https://github.com/android-lili/CustomLrcView-master start 109 LyricViewDemo 歌词显示 https://github.com/zhengken/LyricViewDemo start 576 数据库LitePal https://github.com/LitePalFramework/LitePal start 5343 realm-java https://github.com/realm/realm-java start 9941 greenDAO https://github.com/greenrobot/greenDAO start 10559 动画库lottie-android 支持跨平台动画库，由UI设计指定切json，将json加载出来实现动画 https://github.com/airbnb/lottie-android start 22620 TransitionHelper 一个简单的Activity转场动画 工具类 https://github.com/ImmortalZ/TransitionHelper start 1569 TranslationCompat 页面过渡动画兼容库，兼容Android5.0之后转场动画至Android4.0。 https://github.com/zhangke3016/TranslationCompat start 259 android-pathview SVG动画库 https://github.com/geftimov/android-pathview start 2485 图表类工具MPAndroidChart 股票折线图、饼状图等 https://github.com/PhilJay/MPAndroidChart start 24227 KChartView 股票k线图 https://github.com/tifezh/KChartView start 356 hellocharts-android https://github.com/lecho/hellocharts-android start 6126 波浪效果WaveView https://github.com/gelitenight/WaveView start 1328 Android开源项目及库TimLiu-Android https://github.com/Tim9Liu9/TimLiu-Android#UI start 2334 播放器PLDroidPlayer 七牛推出的一款免费的适用于 Android 平台的播放器 SDK，采用全自研的跨平台播放内核，拥有丰富的功能和优异的性能，可高度定制化和二次开发 https://github.com/pili-engineering/PLDroidPlayer start 3518 标题导航栏ByeBurger 这是一个极其简便的快速实现隐藏标题栏和导航栏的库。 https://github.com/githubwing/ByeBurger start 1061 网络加载okhttp-OkGo 全新完美支持RxJava，比Retrofit更简单易用。该库是封装了okhttp的标准RESTful风格的网络框架，支持大文件上传下载，上传进度回调，下载进度回调，表单上传（多文件和多参数一起上传），链式调用，可以自定义返回对象，支持Https和自签名证书，支持超时自动重连，支持cookie的持久化和自动管理，支持五种缓存模式缓存网络数据，支持301和302重定向，扩展了统一的上传管理和下载管理功能 https://github.com/jeasonlzy/okhttp-OkGo start 8221 NoHttp Android实现Http标准协议框架，支持多种缓存模式，底层可动态切换OkHttp、URLConnection。 https://github.com/yanzhenjie/NoHttp start 3525 OkHttpFinal OkHttp封装的一个简单易用HTTP请求 https://github.com/pengjianbo/OkHttpFinal start 770 okhttputils okhttp的辅助类 https://github.com/hongyangAndroid/okhttputils start 6402 二维码android-zxingLibrary 几行代码快速集成二维码扫描功能 https://github.com/yipianfengye/android-zxingLibrary start 3531 QRCode-Android 二维码、条形码通用扫描 https://github.com/XuDaojie/QRCode-Android start 362 QrCodeScan Android手机客户端二维码扫描 https://github.com/chentao0707/QrCodeScan start 1080 自定义键盘CustomizeKeyboard 完全自定义的Android安全键盘 https://github.com/StomHong/CustomizeKeyboard start 312 蓝牙操作库BluetoothHelper https://github.com/a-voyager/BluetoothHelper start 1111 版本更新CheckVersionLib 版本检测升级（更新）库。 https://github.com/AlexLiuSheng/CheckVersionLib start 1432 UpdateApp 开箱即用的app更新，主要负责软件下载、软件安装等 Permission和Service默认添加在aar包里面的，如果使用gradle不需要 在意下面的配置了。 https://github.com/yaming116/UpdateApp start 327 缓存ASimpleCache 一个为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来） https://github.com/yangfuhai/ASimpleCache start 3147 权限管理AndPermission https://github.com/yanzhenjie/AndPermission start 4525 FcPermissions https://github.com/lypeer/FcPermissions start 406 RxPermissions https://github.com/tbruyelle/RxPermissions start 7166 Tag标签AndroidTagGroup https://github.com/2dxgujun/AndroidTagGroup start 2168 手势密码解锁LockPattern 仿支付宝手势密码解锁 https://github.com/sym900728/LockPattern start 184 PatternLockView MD风格的手机密码解锁 https://github.com/aritraroy/PatternLockView start 2219 BlurLockView 高斯模糊锁屏界面 https://github.com/Nightonke/BlurLockView start 987 AppLock AppLock应用锁，保护你的隐私。 https://github.com/lizixian18/AppLock start 463 LolliPin Pin解锁 https://github.com/omadahealth/LolliPin start 1480 PinLockView MD风格Pin解锁 https://www.cnblogs.com/abao0/p/6726763.html start 1145]]></content>
      <categories>
        <category>Android</category>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio自定义注释模板]]></title>
    <url>%2Fposts%2Fd339abc3.html</url>
    <content type="text"><![CDATA[代码的注释是我们平时必须面对的问题，今天我们就来看看如何自定义属于自己的注释模板，提高我们的开发效率。 1.新建的类自动生成的注释； 2.自定义注释模板。 新建类自动生成的注释1.打开相应的设置：​ File–&gt;Settings–&gt;Editor–&gt;File and code Template。 选择Files中的Class 在上面添加你想要添加的注释： 下面有一些变量可以选择： {USER} ：表示你系统名字；{DATE}： 表示当前时间；{NAME}:表示类名。而且后面都有注释，相信大家也都能看得懂。 这是设置后的结果画面： 这边有许多变量可以引用，想要哪些变量，或者想自定义成什么样的注释，就看你自己的想象力了。 万能注释模板 Java篇1.打开相应位置： File–&gt;Setting–&gt;Editor–&gt;LiveTemplate： 2.新建一个Live Group: 点击右边的+号，选择Template Group,命名自己的一个注释包。我自己命名为Zm Template Group。 3.新建一个LIve Template： 在你刚刚新建的group下点击+号，新建一个Live Template: Abbraviation:是你设置的快捷键，我的快捷键是z。 Expand with :补全你的注释的快捷键，默认为TAB,我改为了Enter。 4.添加你的注释： 在下面自定义你想要的注释，这边的注释有点不同了，这边可以自定义变量名，格式和我的一样，用双$包起来。 123456/** * @author $user$ * @email zm@zhangmiao.cc * @date $date$ $time$ * @describe $desc$ */ 5.点击Edit Variables，在Expression选择你需要方法，相当于给你的变量赋值: 6.选择你要运用的地方： 你可以选择Java，C++ 等等。 点击Apply。就成功了，下面让我们来看看效果：]]></content>
      <categories>
        <category>Android</category>
        <category>注释模板</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>注释模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android编译implement、api和compile区别]]></title>
    <url>%2Fposts%2Fde9d44d2.html</url>
    <content type="text"><![CDATA[2017 年google 后，Android studio版本更新至3.0，更新中，连带着com.android.tools.build:gradle 工具也升级到了3.0.0，在3.0.0中使用了最新的Gralde 4.0 里程碑版本作为gradle的编译版本，该版本gradle编译速度有所加速，更加欣喜的是，完全支持Java8。 当然，对于Kotlin的支持，在这个版本也有所体现，Kotlin插件默认是安装的。 我们来看看新建一个项目在Moudle中的 dependencies 中的变化。 12345678dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;&#125; 下面我们来看看他们之前的差异： 首先是2.x版本的依赖方式 再来看看3.0的 可以看到在Android studio3.0中，compile依赖关系已被弃用，被implementation和api替代，provided被compile only替代，apk被runtime only替代。 我们先来看看implementation和api的区别： api：跟 2.x 版本的 compile完全相同implementation：使用了该命令编译的依赖，它仅仅对当前的Moudle提供接口。例如我们当前项目结构如下 LibraryA 中引用了 LibraryC 的库，如果对 LibraryC 的依赖用的是 implementation 关键字。 如下： 1234dependencies &#123; . . . . implementation project（path：&apos;：libraryC&apos;）&#125; 那么LibraryC 中的接口，仅仅只能给 LibraryA 使用，而我们的 App Moudle 是无法访问到 LibraryC 提供的接口的，也就是将该依赖隐藏在内部，而不对外部公开。这就是implementation关键字的作用。 api 指令 完全等同于compile指令，没区别，你将所有的compile改成api，完全没有错。 implement指令 这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。 建议在Google IO 相关话题的中提到了一个建议，就是依赖首先应该设置为implement的，如果没有错，那就用implement，如果有错，那么使用api指令，这样会使编译速度有所增快。 那为什么要这么做呢？答案是： 1. 加快编译速度。2. 隐藏对外不必要的接口。 为什么能加快编译速度呢？ 这对于大型项目含有多个Moudle模块的， 以上图为例，比如我们改动 LibraryC 接口的相关代码，这时候编译只需要单独编译LibraryA模块就行， 如果使用的是api或者旧时代的compile，由于App Moudle 也可以访问到 LibraryC,所以 App Moudle部分也需要重新编译。当然这是在全编的情况下。 还不熟悉 2.x 版本依赖的可以看看下面的说明，括号里对应的是 3.0 版本的依赖方式。 compile（api）这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。 当我们依赖一些第三方的库时，可能会遇到com.android.support冲突的问题，就是因为开发者使用的compile依赖的com.android.support包，而他所依赖的包与我们本地所依赖的com.android.support包版本不一样，所以就会报All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes这个错误。 解决办法可以看这篇博客：com.android.support冲突的解决办法 provided（compileOnly）只在编译时有效，不会参与打包 可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。 testCompile（testImplementation）testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。 debugCompile（debugImplementation）debugCompile 只在 debug 模式的编译和最终的 debug apk 打包时有效 releaseCompile（releaseImplementation）Release compile仅仅针对 Release 模式的编译和最终的 Release apk 打包。 参考链接： Android Studio3.x新的依赖方式（implementation、api、compileOnly） 还再用compile依赖？那你就落后啦 android gradle tools 3.X 中依赖，implement、api 指令]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android快速开发框架推荐10个框架]]></title>
    <url>%2Fposts%2F7a5476f9.html</url>
    <content type="text"><![CDATA[一、 Afinal官方介绍： Afinal是一个Android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。详情请通过以下网址查看。 Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用； 使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。 Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。 项目地址：https://github.com/yangfuhai/afinal 功能： 一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。 优点：功能比较全面，文档完善，代码效率比较高。 缺点：没有项目demo，框架的时间比较久，代码冗余比较多（这也是无可避免的），文档比较老跟不上代码更新进度。 （这个评价是其他高人评的，他自己也有写了框架。我个人觉得以前Afinal算是经典了 用的人多）。 二、 xUtilsGit地址：https://github.com/wyouflf/xUtils xUtils：可以说是Afinal的升级版。 xUtils 包含了很多实用的android工具。 xUtils 支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响… xUitls 最低兼容android 2.2 (api level 8) 三、 ThinkAndroid项目地址：https://github.com/white-cat/ThinkAndroid 官方介绍： ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块,具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能，在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类，如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具 优点：功能看起来比较完善。个人觉得名字起的好。 缺点：从2013年就停止维护了，没有项目文档。 四、 LoonAndroid官方介绍： 如果你想看ui方面的东西，这里没有，想要看牛逼的效果这里也没有。这只是纯实现功能的框架，它的目标是节省代码量，降低耦合，让代码层次看起来更清晰。整个框架一部分是网上的，一部分是我改的，为了适应我的编码习惯，还有一部分像orm完全是网上的组件。在此感谢那些朋友们。 整个框架式的初衷是为了偷懒，之前都是一个功能一个jar，做项目的时候拉进去，这样对于我来说依然还是比较麻烦。最后就导致我把所有的jar做成了一个工具集合包。 有很多框架都含有这个工具集合里的功能，这些不一定都好用，因为这是根据我个人使用喜欢来实现的，如果你们有自己的想法，可以自己把架包解压了以后，源码拉出来改动下。 目前很多框架都用到了注解，除了androidannotations没有入侵我们应用的代码以外，其他的基本上都有，要么是必须继承框架里面的activity,要么是必须在activity的oncreat里面调用某个方法。 整个框架式不同于androidannotations，Roboguice等ioc框架，这是一个类似spring的实现方式。在整应用的生命周期中找到切入点，然后对activity的生命周期进行拦截，然后插入自己的功能。 开源地址：https://github.com/gdpancheng/LoonAndroid 功能： 1自动注入框架（只需要继承框架内的application既可） 2图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性） 3网络请求模块（继承了基本上现在所有的http请求） 4 eventbus（集成一个开源的框架） 5验证框架（集成开源框架） 6 json解析（支持解析成集合或者对象） 7 数据库（不知道是哪位写的 忘记了） 8 多线程断点下载（自动判断是否支持多线程，判断是否是重定向） 9 自动更新模块 10 一系列工具类 有点：功能多 缺点：文档方面 五、 KJFrameForAndroid项目地址：https://github.com/kymjs/KJFrameForAndroid 官方介绍： KJFrameForAndroid 又叫KJLibrary，是一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用；KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。我们提倡用最少的代码，完成最多的操作，用最高的效率，完成最复杂的功能。 功能： 一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用； KJFrameForAndroid开发框架的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。总共分为五大模块：UILibrary，UtilsLibrary，HttpLibrary，BitmapLibrary，DBLibrary。 优点：功能比较全面，代码效率很高，文档完善，有项目demo，出来的比较晚借鉴了很多大型框架经验。 缺点：项目文档是html页面，查看起来很不方便，项目交流平台没多少人说话（难道大神都是不说话的？） （这两个评价是KJFrameForAndroid的作者对自己的评价，个人觉得作者是个天才。他的评价可能刚写完网上发布后写的。我在给他更新评价。因为现在已经过去了几个月一直在时不时更新。功能很全，项目文档也很全面，而且代码里注释最多 这方面这个很难得。交流平台人很多挺热闹，作者希望更热闹这样框架越来越完善。对于初学者希望看到Demo更完善） 六、 dhroid官方介绍： dhroid 是基于android 平台, 极速开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展.使你更快,更好的开发商业级别应用 开源地址: http://git.oschina.net/tengzhinei/dhroid 功能： 1.Ioc容器: (用过spring的都知道)视图注入,对象注入,接口注入,解决类依赖关系 2.Eventbus: android平台事件总线框架,独创延时事件,事件管理轻松 3.Dhnet: 网络http请求的解决方案,使用简单,减少代码,自带多种网络访问缓存策略 4.adapter模块: 数据绑定轻松,不用写多余的adapter,天生网络支持(一行代码搞定加载,刷新问题) 5.DhDb: android中sqlite的最轻量orm框架(增删改查轻松搞定) 6.Perference: android自带Perference 升级版,让你的Perference更强大,更方便 工具集合 JSONUtil(安全处理json),ViewUtil(数据绑定更快) ThreadWorker(异步任务工具)… 优点：功能全面，有demo，作者也是为公司开发的框架。 缺点：文档方面现在不是很好，就eoe上的那些。 七、 SmartAndroid项目地址：http://www.aplesson.com/smartAndroid/demos 官方介绍： SmartAndroid是一套给 Android开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 SmartAndroid可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。 功能： SmartAndroid 拥有全范围的类库，可以完成大多数通常需要的APP开发任务，包括： 异步网络操作相关所有功能、强大的图片处理操作、轻量级ORM数据库Sqlite库、zip操作 、动画特效、Html等解析采集、事件总线EventBus/Otto、Gson(Json)、AQuery、主流所有UI控件（例如：ActionbarSherlock，SlidingMenu，BottomView，Actionbar，DragListView等10多种UI库）等。 优点：功能非常全，超出你索要、文档完善（作者很全面，官方网站是web响应式网站，框架里功能有UI各种特效应该最全了，一直更新中） 缺点：jar包大点？（功能多不可避免，不是问题），在线文档（随响应式的手机访问也方便，但是网速慢就不好了，页面打开不是很流畅） 八、 andBase官方介绍： andbase是为Android开发者量身打造的一款开源类库产品 开源地址：https://code.jd.com/zhaoqp2010_m/andbase 功能： 1.andbase中包含了大量的开发常用手段。 如网络下载，多线程与线程池的管理，数据库ORM，图片缓存管理，图片文件下载上传，Http请求工具，常用工具类（字符串，日期，文件处理，图片处理工具类等），能够使您的应用在团队开发中减少冗余代码，很大的提高了代码的维护性与开发高效性，能很好的规避由于开发疏忽而导致常犯的错误。 2.andbase封装了大量的常用控件。 如list分页，下拉刷新，图片轮播，表格，多线程下载器，侧边栏，图片上传，轮子选择，图表，Tab滑动，日历选择器等。 3.强大的AbActivity，您没有理由不继承它。 继承它你能够获得一个简单强大可设置的操作栏，以及一系列的简单调用，如弹出框，提示框，进度框，副操作栏等。 4.提供效率较高图片缓存管理策略，使内存大幅度节省，利用率提高，效率提高。 程序中要管理大量的图片资源，andbase提供简单的方法，几步完成下载与显示，并支持缩放，裁剪，缓存功能。 5.封装了大量常见工具类。 包括日期，字符，文件，图片等各种处理函数，多而全。 6.用andbase大量减少handler的使用，而采用回调函数，代码更整洁。 handler会产生大量代码，并且不好维护，andbase对handler进行了封装。 7.简单轻量支持注解自动建表的ORM框架（支持一/多对多的关联操作）。 写sql，建表，工作量大，andbase提供更傻瓜异步增删改查工具类。 8.异步请求http框架，网络请求标准化，支持文件上传下载，get，post，进度显示。 包含了异步与http请求的工具类，实用。 9.热情的支持群体。 优点：功能很全，demo做的好 、API文档完善、接近完美 缺点：希望文档更详细些。 九、 AndroidAnnotations项目地址：https://github.com/excilys/androidannotations 功能： 完全注解框架，一切皆为注解：声明控件，绑定控件，设置监听，setcontentview，长按事件，异步线程，全部通过注解实现。 优点：完全的注解，使开发起来更加便利，程序员写的代码也更少。 缺点：文档是全英文的加上功能比较少没有具体研究，由于一切都是注解，感觉效率不高，不过根据官方介绍说并不是使用的反射加载，所以效率比一般注解高很多。 十、 volley项目地址： https://github.com/smanikandan14/Volley-demo 功能： Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮异步加载网络图片、网络数据 优点：Google官方推荐，请看去年的开发者大会介绍。 缺点：功能比较少，只有网络数据加载和网络图片加载 十一、 android-async-http 项目地址：https://github.com/loopj/android-async-http文档介绍：http://loopj.com/android-async-http/ (1) 在匿名回调中处理请求结果 (2) 在UI线程外进行http请求 (3) 文件断点上传 (4) 智能重试 (5) 默认gzip压缩 (6) 支持解析成Json格式 (7) 可将Cookies持久化到SharedPreferences 有点：很简单很实用 缺点：功能比较少， （只是针对的功能不是什么缺点） 最后来个总结吧： ​ 以上的开发框架网上都可以下载源码，也有demo实例的。当然我没分析和对比框架的效率性能，但是都非常实用，其作者大部分是个人，都是些牛人或天才。你可以直接使用，也可以把有用跳出来用，至少有很多使用工具。如果有发现Bug，作者希望把bug交给他。 ​ Afinal 和 xUtils简单实用但是demo和更新的问题。 KJFrameForAndroid 算是新出的，功能也多，效率也应该好，代码也注释多 用起来也很方便。 Dhroid 作者自己公司的框架，也可以直接请教。 SmartAndroid 强劲的框架功能俱全。 andBase 出来早各个方面算是完整的吧。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 项目最新架构]]></title>
    <url>%2Fposts%2Fb043c117.html</url>
    <content type="text"><![CDATA[前言为了帮助开发着打造一款优秀的APP，Google可谓费尽心力，推出了各种诸如MVP,MVVM等等项目架构的思路，帮助开发者更加高效的开发，尽管这样，Google还是接着推出了一个新的项目架构，以便给予开发者更多的选择，至于这种架构思路和MVP等框架的优劣，各位看完文章或许自有定论。 1.生命周期在移动操作系统上开发软件其实是十分复杂的一件事情，因为我们随时需要面对系统和用户的各种不可预料的操作，很多时候，事情并不向着我们预设的方向方向进展。因此系统向我们提供了核心组件的生命周期这种东西，告知我们的APP正处在什么样的状况中，以便于我们做出相应的处理。 如上图。虽然Google给出了Activity非常详尽的生命周期结构，因此我们对根据生命周期做出相应的合理的安排，比如添加和移除实时GPS位置监听： 可是随着业务的逐渐复杂，我们可能在添加监听之间需要向服务器验证某些用户信息，等返回信息正确才去监听定位。那么在网络异步回调的时候，我们就很难知道当前的activity的生命周期状态。 如果发生上图的情况，那么我们的占用的相关资源就可能永远无法移除了。这还只是冰山一角，大家尽可以想想，当我们的异步调用面对无法预知的用户操作和系统处理的时候，什么问题都可能发生。 总而言之，由于我们对于UI实时的状态做不到了如指掌，以至于对数据和逻辑的处理就无法尽善尽美。这是类似隐患得不到很好的解决根本原因。 2. Google大礼包这次Google推出了一套新的项目架构组件和架构思路，从UI到Data,帮助我们更加精准的开发自己的APP。 2.1 核心：Lifecycle Components这套架构最核心的就是生命周期组件，：Lifecycle Components用于管理UI控制器（Activity/Freagment）的生命周期，方便查询当前组件生命周期的状态。 可查询的状态如下： 具体的使用方式有两种： 继承LifecycleActivity/LifecycleFragment即可 自己实现LifecycleRegistryOwner接口 java 1234// 通过继承，就已经将自己的生命周期的交给了Lifecycle Components管理了。public class MainActivity extends LifecycleActivity &#123;&#125; 那我们如何使用呢？ 12345678910111213141516171819202122232425262728293031323334353637// 通过继承LifecycleObserver，保证我们可以通过注解或者接口查询UI的生命周期public class MyTest implements LifecycleObserver &#123; private Lifecycle lifecycle; // Lifecycle包含了当前组件的生命周期 public MyTest(Lifecycle lifecycle)&#123; lifecycle.addObserver(this); this.lifecycle=lifecycle; &#125;// 当onResume发生的时候，该方法被调用 @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void resume()&#123; Log.i(&quot;TAG&quot;,&quot;it called when resume &quot;); &#125; public void doTest(String s)&#123; // 随时可以查询当前的UI状态 if(lifecycle.getCurrentState().equals(Lifecycle.State.RESUMED))&#123; Log.i(&quot;TAG&quot;,&quot;resume&quot;); &#125;else&#123; Log.i(&quot;TAG&quot;,&quot;is not resume !! &quot;); &#125; &#125;&#125;public class MainActivity extends LifecycleActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //将当前Activity的生命周期传递到MyTest中即可 MyTest myTest=new MyTest(this.getLifecycle()); &#125;&#125; 看到这里，你一定心头一喜，如果有这个组件，那么我们就完全有能力将Activity作为一个UI的控制器，仅仅用来显示UI和相应用户操作，把Activity的大小缩小至最小。不用着急，大礼包远不止这些。 3.ViewModel和LiveData ViewModel 是一个UI相关数据的暂存器，当所有相关的UI都finish掉的时候，它才会清除自己的数据。 LiveData则是一个持有具体数据并且可被观察，能感知生命周期的组件（它就像RxJava中一个能遵循组件生命周期的Observable） 他俩的关系，就是，ViewModel负责管理着不同的LiveData,并把它提供给UI。 3.1 LiveData我们可以先来说说LiveData。由于它已经能够感知生命周期，也就意味着我们并不需要在去查询当前UI的生命周期，由于可被观察，也就意味着当它持有的数据发生改变，观察者可以立即受到信息。livedata最重要的方法是一下几个： 12345678 onActive() // 当前LiveData有超过一个的活跃的观察者时，被调用onInactive() // 当前没有任何活跃的观察时，着被调用setValue() // 勇于改变当前数据，这样观察者可以受到改变后的数据。// 观察数据变化，并感知当前UI的生命周期observe(LifecycleOwner owner, Observer&lt;T&gt; observer) 这里有一个活跃的观察者的概念，我们不妨把它放在后面来看。LiveData的用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LocationLiveData extends LiveData&lt;Location&gt; &#123; private LocationManager locationManager; private SimpleLocationListener listener = new SimpleLocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; setValue(location); &#125; &#125;; public LocationLiveData(Context context) &#123; locationManager = (LocationManager) context.getSystemService( Context.LOCATION_SERVICE); &#125; @Override protected void onActive() &#123; locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); &#125; @Override protected void onInactive() &#123; locationManager.removeUpdates(listener); &#125;&#125;public class MainActivity extends LifecycleActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); LiveData&lt;Location&gt; myLocationListener = new LocationLiveData(); /* * observe(LifecycleOwner owner, Observer&lt;T&gt; observer) * 这个方法就是向LiveData中添加观察者， * LiveData则可以通过LifecycleOwner来判断 * 当前传入的观察者是否是活跃的（也就是UI是否可见了） */ myLocationListener.observe(this, new Observer&lt;Location&gt;() &#123; @Override public void onChanged(@Nullable Location location) &#123; // update //当LiveData中通过setValue()修改了数据时， //这里将会受到修改后的数据 &#125; &#125;); &#125;&#125; 好了，LiveData基本的用法讲完了，由于有了LiveData，我们的data更加“智能”了。当UI不可见的时候，改变的数据将不会被更新到UI上。 而且如果数据在不同的UI界面都会被用到的时候，我们还可以一个单例的LiveData，为不同的UI提供统一的数据。这些操作就不去细讲了。 现在回头看LiveData，我们发现它至少有以下几个优点： 可以避免内存泄露：由于 Observer 和 Lifecycle 绑定，当 Lifecycle 被销毁后，Observer 自动被清理。 避免在 Activity 被销毁后更新数据导致的崩溃情况 数据可共享 数据更新更智能：当数据在UI不可见的时候更新了，在恢复可见的时候，最新的数据会及时更新到UI上。 不需要在Activity中额外处理生命周期事件 一颗赛艇！ 3.2 ViewModelViewModel则相对简单些，因为他的作用是暂存UI相关的数据，保证即使Activity配置更改，重新创建时，数据依然能够被保存好。 基本用法如下： 1234567891011121314151617181920212223242526public class MyViewModel extends ViewModel &#123; // MyViewModel用于管理不同的LiveData private MutableLiveData&lt;List&lt;User&gt;&gt; users; public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123; if (users == null) &#123; users = new MutableLiveData&lt;List&lt;Users&gt;&gt;(); loadUsers(); &#125; return users; &#125; private void loadUsers() &#123; // do async operation to fetch users &#125;&#125;public class MyActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; // 通过了ViewModelProviders来获取ViewModel // 用户获取和Activity绑定的ViewModel MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class); model.getUsers().observe(this, users -&gt; &#123; // update UI &#125;); &#125;&#125; 这是ViewModel的最基本的用法，它负责从各个地方获取数据，然后把数据装到LiveData中，提供给UI；当然ViewModel也可以在不同的Fragment中共享，在这里就不多讲了。 由于ViewModel的本身和activity/fragment的生命周期绑定，当与之绑定的最后一个UI 销毁时，ViewModel才会clean自身的数据。 如图所示 4.数据持久化：RoomRoom是Google提供的SQLite的ORM的解决方案，其实本质上和其他的ORM框架没什么特别大的差别，没有太多新意，因此只给出大体的架构图，有兴趣的同学可以自行去学习 5.总结我们现在回头看整个架构 其实最有有趣的就是UI-ViewModel这个部分，这套架构至少可以帮助我们做到一下几点： UI与Data真正分离 异步调用和逻辑控制可以更加精细（因为对生命周期感知更多） 实现Model驱动UI 6.勘误暂无 附录android官网： https://developer.android.com/topic/libraries/architecture/index.html]]></content>
      <categories>
        <category>Android</category>
        <category>设计架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Glide4.x的使用]]></title>
    <url>%2Fposts%2F6944411e.html</url>
    <content type="text"><![CDATA[最近从Glidev3升级到了Glide4.x，我用的是最新的Glide4.1.1哈，由于3.x到4.x的变化还是很大的，在此记录一下，也和需要的朋友分享一下。 Glide官方学习地址 使用1、在app的build.gradle中添加如下配置 12345dependencies &#123;//Glide框架引入 compile 'com.github.bumptech.glide:glide:4.1.1' annotationProcessor 'com.github.bumptech.glide:compiler:4.1.1'&#125; 2、在project的build.gradle中添加如下仓库地址** 1234repositories &#123; mavenCentral() maven &#123; url 'https://maven.google.com' &#125;&#125; 3、自定义AppGlideModule： 为运用程序定义一个带有@GlideModule注解的AppGlideModule，运用程序会使用和AppGlideMoudle同一个包下的GlideApp类。通过GlideApp.with()方式使用Glide的Generated API。具体操作，就是新建一个类，继承与AppGlideModule，还必须带有@GlideModule注解， 1234@GlideModulepublic final class MyAppGlideModule extends AppGlideModule &#123; &#125; 注意： 必需带有@GlideModule注解。 官方文档明确说明，这个类，你可以让它保留空白，不用实现任何方法，就可以使用Glide的Generated API。当然你也可以实现一些方法，具体参考官方文档。 4、Glide加载圆形图片，和Glide3.x差异不大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455** * Glide圆形图片 */public class GlideCircleTransform extends BitmapTransformation &#123; public GlideCircleTransform() &#123; super(); &#125; @Override public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; // TODO this could be acquired from the pool too Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125;&#125;//调用/** * 加载圆形图片 */public static void loadCircleImg(Context context, String url, final ImageView imageView) &#123; GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .transform(new GlideCircleTransform()) .into(imageView); &#125; 5、Glide加载圆角图片 说道这个我不得不吐槽一下网上的各路大神了，4.x和3.x加载圆角真不一样了，下面举个网上的例子，和3.x差不多 12public class GlideRoundTransform extends BitmapTransformation &#123;&#125; 尼玛，根本显示不了圆角啊，后来查资料才发现原来是Glide圆角和centerCrop的冲突，不过也得到了解决，感谢这位作者 Glide .centerCrop() 和transform圆角图片不能同时存在解决方法 下面贴出我的加载圆角的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 圆角图片 */public class GlideRoundTransform extends CenterCrop &#123; private static float radius = 0f; public GlideRoundTransform() &#123; this(4); &#125; public GlideRoundTransform(int dp) &#123; super(); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; Bitmap transform = super.transform(pool, toTransform, outWidth, outHeight); return roundCrop(pool, transform);// return roundCrop(pool, toTransform); &#125; private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125;&#125;//调用/** * 加载圆角图片 * * @param context * @param url * @param imageView */ public static void loadRoundImg(Context context, String url, final ImageView imageView) &#123; GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .transform(new GlideRoundTransform(8)) .into(imageView); &#125; 6、Glide加载图片进度的监听 12345678910111213141516171819GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object o, Target&lt;Drawable&gt; target, boolean b) &#123; Log.i(TAG, "图片加载失败 "); return false; &#125; @Override public boolean onResourceReady(Drawable drawable, Object o, Target&lt;Drawable&gt; target, DataSource dataSource, boolean b) &#123; Log.i(TAG, "图片加载完成: "); return false; &#125; &#125;) .into(imageView);]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 图片处理之Glide4.0版本]]></title>
    <url>%2Fposts%2Faf2ff32e.html</url>
    <content type="text"><![CDATA[前言一般项目我都会使用Glide作为我的图片加载框架，他和Picasso ,真的很像，郭大神早就分析过了，很详细，这里也就简单做个记录。小白白一枚，学习路上 Android图片加载框架最全解析（一），Glide的基本用法 Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 Android图片加载框架最全解析（三），深入探究Glide的缓存机制 Android图片加载框架最全解析（四），玩转Glide的回调与监听 Android图片加载框架最全解析（五），Glide强大的图片变换功能 Android图片加载框架最全解析（六），探究Glide的自定义模块功能 Android图片加载框架最全解析（七），实现带进度的Glide图片加载功能 Android图片加载框架最全解析（八），带你全面了解Glide 4的用法 一：GitHubbumptech/glide二：下载使用点击，跳转到官网，介绍很详细 1. Gradle1234repositories &#123; mavenCentral() maven &#123; url 'https://maven.google.com' &#125;&#125; 1234dependencies &#123; compile 'com.github.bumptech.glide:glide:4.4.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'&#125; 2. Android SDK 要求 Min Sdk Version - 使用 Glide 需要 min SDK 版本 API 14 (Ice Cream Sandwich) 或更高。 Compile Sdk Version - Glide 必须使用 API 26 (Oreo) 或更高版本的 SDK 来编译。 Support Library Version - Glide 使用的支持库版本为 27。 否则会出现异常 解决方案12345dependencies &#123; implementation 'com.android.support:appcompat-v7:27.0.2' //这个版本的就可以了 implementation 'com.github.bumptech.glide:glide:4.4.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'&#125; 3.权限1234&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 二：apply &amp;&amp; RequestOptions4.0之前最常用的方式，当然现在也是哈 123Glide.with(this) .load(url) .into(img); 4.0之后，有一个新的东西 1234 Glide.with(this) .load(url)// .apply(RequestOptions options) .into(img); 比如 我们加载占位图和错误图 1234567RequestOptions options = new RequestOptions() .error(R.drawable.error) .placeholder(R.drawable.loading);Glide.with(this) .load(url) .apply(options) .into(imageView); 小伙伴们没看错，这样的方式，摆脱了，以前链式写法中，Glide很长很长，现在的话，我们可以传入一个RequestOptions，对象，就有小伙伴问了，有啥用，我觉得，比较容易封装， 例如 123456789101112public class GlideUtil &#123; public static void load(Context context, String url, ImageView imageView, RequestOptions options) &#123; Glide.with(context) .load(url) .apply(options) .into(imageView); &#125;&#125; 三：API 介绍 API 介绍 占位符(Placeholder) 当请求正在执行时被展示的 Drawable 错误符(Error) 请求永久性失败时展示 后备回调符(Fallback) 在请求的url/model为 null 时展示 override 指定了一个图片的尺寸,Target.SIZE_ORIGINAL加载图片的原始尺寸 skipMemoryCache(true) 禁用内存缓存功能 diskCacheStrategy(DiskCacheStrategy.NONE) 禁用硬盘缓存功能,参数列表如下 四（1） asBitmap() 只允许加载静态图片,。如果传入的是GIF图,会展示GIF图的第一帧 asFile() 指定文件格式 注意事项 如下 四（2） asDrawable() 指定Drawable格式 submit() 使用如下四（3） transforms 图片变换，Glide 默认有3个，如下四（4） 四： 补充说明1. diskCacheStrategy参数补充 参数 说明 DiskCacheStrategy.NONE 表示不缓存任何内容。 DiskCacheStrategy.DATA 表示只缓存原始图片。 DiskCacheStrategy.RESOURCE 表示只缓存转换过后的图片。 DiskCacheStrategy.ALL 表示既缓存原始图片，也缓存转换过后的图片。 DiskCacheStrategy.AUTOMATIC 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。 2. asBitmap()注意坑熟悉Glide 3的朋友对asBitmap()方法肯定不会陌生对吧？但是千万不要觉得这里就没有陷阱了，在Glide 3中的语法是先load()再asBitmap()的，而在Glide 4中是先asBitmap()再load()的。乍一看可能分辨不出来有什么区别，但如果你写错了顺序就肯定会报错了 3. submit()通过如下代码，可以获取到，下载好的图片放在哪，可以看到 都在cache下 1234567891011121314151617181920 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; File file = Glide.with(MainActivity.this) .asFile() .load(url) .submit() .get(); Log.e("Tag", "path--&gt;" + file.getPath()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();E/Tag: path--&gt;/data/user/0/com.allens.glidedemo/cache/image_manager_disk_cache/309df01e6362ddc8939a4e3c549e8276dffb0446a89f2facee371909301fe76a.0 4. transforms内置有这3个 12345678RequestOptions options = new RequestOptions() .centerCrop();RequestOptions options = new RequestOptions() .fitCenter();RequestOptions options = new RequestOptions() .circleCrop();//圆形 一般我们还会自己去定义，以下是常用的3种转换 使用起来也很简单 1234567891011RequestOptions options = new RequestOptions() .skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.NONE); //圆形 .transforms(new CircleTransform(mContext,2, Color.DKGRAY))//外圈宽度，外圈颜色 //黑白 .transforms(new BlackWhiteTransformation()); //高斯模糊 范围在 0 -- 25 越大模糊程度越高 .transforms(new BlurTransformation(mContext, 25)); // (0 &lt; r &lt;= 25) //可以使用多种 .transforms(new BlurTransformation(mContext, 25),new CircleTransform(mContext,2, Color.DKGRAY)) （1） 转成黑白123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.allens.lib_glide.Transformation;import android.graphics.Bitmap;import android.media.ThumbnailUtils;import android.support.annotation.NonNull;import android.view.animation.Transformation;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 黑白 * Created by allens on 2018/1/8. */public class BlackWhiteTransformation extends BitmapTransformation &#123; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return convertToBlackWhite(toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap convertToBlackWhite(Bitmap bmp) &#123; int width = bmp.getWidth(); // 获取位图的宽 int height = bmp.getHeight(); // 获取位图的高 int[] pixels = new int[width * height]; // 通过位图的大小创建像素点数组 bmp.getPixels(pixels, 0, width, 0, 0, width, height); int alpha = 0xFF &lt;&lt; 24; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; int grey = pixels[width * i + j]; //分离三原色 int red = ((grey &amp; 0x00FF0000) &gt;&gt; 16); int green = ((grey &amp; 0x0000FF00) &gt;&gt; 8); int blue = (grey &amp; 0x000000FF); //转化成灰度像素 grey = (int) (red * 0.3 + green * 0.59 + blue * 0.11); grey = alpha | (grey &lt;&lt; 16) | (grey &lt;&lt; 8) | grey; pixels[width * i + j] = grey; &#125; &#125; //新建图片 Bitmap newBmp = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); //设置图片数据 newBmp.setPixels(pixels, 0, width, 0, 0, width, height); Bitmap resizeBmp = ThumbnailUtils.extractThumbnail(newBmp, 380, 460); return resizeBmp; &#125;&#125; （2）高斯模糊1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.allens.lib_glide.Transformation;import android.annotation.TargetApi;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.os.Build;import android.renderscript.Allocation;import android.renderscript.Element;import android.renderscript.RSRuntimeException;import android.renderscript.RenderScript;import android.renderscript.ScriptIntrinsicBlur;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: 高斯模糊 * &lt;p&gt; * Created by allens on 2018/1/8. */public class BlurTransformation extends BitmapTransformation &#123; private Context context; private float blurRadius; public BlurTransformation(Context context, float blurRadius) &#123; this.context = context; this.blurRadius = blurRadius; &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return blurBitmap(context, toTransform, blurRadius, outWidth, outHeight); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; /** * @param context 上下文对象 * @param image 需要模糊的图片 * @param outWidth 输入出的宽度 * @param outHeight 输出的高度 * @return 模糊处理后的Bitmap */ @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public Bitmap blurBitmap(Context context, Bitmap image, float blurRadius, int outWidth, int outHeight) &#123; // 将缩小后的图片做为预渲染的图片 Bitmap inputBitmap = Bitmap.createScaledBitmap(image, outWidth, outHeight, false); // 创建一张渲染后的输出图片 Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap); // 创建RenderScript内核对象 RenderScript rs = RenderScript.create(context); // 创建一个模糊效果的RenderScript的工具对象 ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间 // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去 Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap); Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap); // 设置渲染的模糊程度, 25f是最大模糊度 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; blurScript.setRadius(blurRadius); &#125; // 设置blurScript对象的输入内存 blurScript.setInput(tmpIn); // 将输出数据保存到输出内存中 blurScript.forEach(tmpOut); // 将数据填充到Allocation中 tmpOut.copyTo(outputBitmap); return outputBitmap; &#125;&#125; （3） 圆形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.allens.lib_glide.Transformation;import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 圆形 * Created by allens on 2018/1/8. */public class CircleTransform extends BitmapTransformation &#123; private Paint mBorderPaint; private float mBorderWidth; public CircleTransform(Context context) &#123; super(context); &#125; public CircleTransform(Context context, int borderWidth, int borderColor) &#123; super(context); mBorderWidth = Resources.getSystem().getDisplayMetrics().density * borderWidth; mBorderPaint = new Paint(); mBorderPaint.setDither(true); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(borderColor); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setStrokeWidth(mBorderWidth); &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) &#123; return null; &#125; int size = (int) (Math.min(source.getWidth(), source.getHeight()) - (mBorderWidth / 2)); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); if (mBorderPaint != null) &#123; float borderRadius = r - mBorderWidth / 2; canvas.drawCircle(r, r, borderRadius, mBorderPaint); &#125; return result; &#125;&#125; 4.0 圆角123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.starot.spark.transformation;import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 圆形 * * @author allens * @date 2018/1/8 */public class CircleTransform extends BitmapTransformation &#123; private Paint mBorderPaint; private float mBorderWidth; public CircleTransform(Context context) &#123; super(context); &#125; public CircleTransform(Context context, int borderWidth, int borderColor) &#123; super(context); mBorderWidth = Resources.getSystem().getDisplayMetrics().density * borderWidth; mBorderPaint = new Paint(); mBorderPaint.setDither(true); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(borderColor); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setStrokeWidth(mBorderWidth); &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) &#123; return null; &#125; int size = (int) (Math.min(source.getWidth(), source.getHeight()) - (mBorderWidth / 2)); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); if (mBorderPaint != null) &#123; float borderRadius = r - mBorderWidth / 2; canvas.drawCircle(r, r, borderRadius, mBorderPaint); &#125; return result; &#125;&#125; 5.Generated API如果4.0用的不爽，就想使用3.0版本的那种链式写法,将Glide 关键字改成 GlideApp即可 123456789GlideApp.with(this) .load(url) .placeholder(R.drawable.loading) .error(R.drawable.error) .skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.NONE) .override(Target.SIZE_ORIGINAL) .circleCrop() .into(imageView);]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android：时间工具类 -- 时间戳转换成日期，日期转换成时间戳]]></title>
    <url>%2Fposts%2F29c9b34b.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486 public class DateUtils &#123; public static String getTodayDateTime() &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()); return format.format(new Date()); &#125; /** * 掉此方法输入所要转换的时间输入例如（"2014年06月14日16时09分00秒"）返回时间戳 * * @param time * @return */ public String data(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒", Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; public static String getTodayDateTimes() &#123; SimpleDateFormat format = new SimpleDateFormat("MM月dd日", Locale.getDefault()); return format.format(new Date()); &#125; /** * 获取当前时间 * * @return */ public static String getCurrentTime_Today() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); return sdf.format(new java.util.Date()); &#125; /** * 调此方法输入所要转换的时间输入例如（"2014-06-14-16-09-00"）返回时间戳 * * @param time * @return */ public static String dataOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss", Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; public static String getTimestamp(String time, String type) &#123; SimpleDateFormat sdr = new SimpleDateFormat(type, Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014年06月14日16时09分00秒"） * * @param time * @return */ public static String times(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014-06-14 16:09:00"） * * @param time * @return */ public static String timedate(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014年06月14日16:09"） * * @param time * @return */ public static String timet(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日 HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeslash(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy/MM/dd,HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeslashData(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy/MM/dd"); @SuppressWarnings("unused") long lcc = Long.valueOf(time);// int i = Integer.parseInt(time); String times = sdr.format(new Date(lcc * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeMinute(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String tim(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyyMMdd HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String time(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; // 调用此方法输入所要转换的时间戳例如（1402733340）输出（"2014年06月14日16时09分00秒"） public static String times(long timeStamp) &#123; SimpleDateFormat sdr = new SimpleDateFormat("MM月dd日 # HH:mm"); return sdr.format(new Date(timeStamp)).replaceAll("#", getWeek(timeStamp)); &#125; private static String getWeek(long timeStamp) &#123; int mydate = 0; String week = null; Calendar cd = Calendar.getInstance(); cd.setTime(new Date(timeStamp)); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 if (mydate == 1) &#123; week = "周日"; &#125; else if (mydate == 2) &#123; week = "周一"; &#125; else if (mydate == 3) &#123; week = "周二"; &#125; else if (mydate == 4) &#123; week = "周三"; &#125; else if (mydate == 5) &#123; week = "周四"; &#125; else if (mydate == 6) &#123; week = "周五"; &#125; else if (mydate == 7) &#123; week = "周六"; &#125; return week; &#125; // 并用分割符把时间分成时间数组 /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014-06-14-16-09-00"） * * @param time * @return */ public String timesOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String timesTwo(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 并用分割符把时间分成时间数组 * * @param time * @return */ public static String[] timestamp(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); String[] fenge = times.split("[年月日时分秒]"); return fenge; &#125; /** * 根据传递的类型格式化时间 * * @param str * @param type * 例如：yy-MM-dd * @return */ public static String getDateTimeByMillisecond(String str, String type) &#123; Date date = new Date(Long.valueOf(str)); SimpleDateFormat format = new SimpleDateFormat(type); String time = format.format(date); return time; &#125; /** * 分割符把时间分成时间数组 * * @param time * @return */ public String[] division(String time) &#123; String[] fenge = time.split("[年月日时分秒]"); return fenge; &#125; /** * 输入时间戳变星期 * * @param time * @return */ public static String changeweek(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); Date date = null; int mydate = 0; String week = null; try &#123; date = sdr.parse(times); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 获取日期和星期 例如：２０１４－１１－１３ １１:００ 星期一 * * @param time * @param type * @return */ public static String getDateAndWeek(String time, String type) &#123; return getDateTimeByMillisecond(time + "000", type) + " " + changeweekOne(time); &#125; /** * 输入时间戳变星期 * * @param time * @return */ public static String changeweekOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); Date date = null; int mydate = 0; String week = null; try &#123; date = sdr.parse(times); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 获取当前时间 * * @return */ public static String getCurrentTime() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm"); return sdf.format(new java.util.Date()); &#125; /** * 输入日期如（2014年06月14日16时09分00秒）返回（星期数） * * @param time * @return */ public String week(String time) &#123; Date date = null; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); int mydate = 0; String week = null; try &#123; date = sdr.parse(time); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 输入日期如（2014-06-14-16-09-00）返回（星期数） * * @param time * @return */ public String weekOne(String time) &#123; Date date = null; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); int mydate = 0; String week = null; try &#123; date = sdr.parse(time); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 音频amr文件时长]]></title>
    <url>%2Fposts%2F45412865.html</url>
    <content type="text"><![CDATA[一、文件时长获取 1234567891011public int getDurations()&#123; String curAudioFile = “XXX.amr”; MediaPlayer mediaPlayer = new MediaPlayer(); mediaPlayer.setDataSource(curAudioFile); mediaPlayer.prepare(); return mediaPlayer.getDuration();// 单位毫秒&#125; 二、文件时长转换** 1234567891011121314151617181920212223242526272829303132333435private static String getAudioDuration(int nDuration0) &#123; DecimalFormat df = new DecimalFormat("#.00"); String fileSizeString = ""; String wrongSize = "0ms"; if (nDuration0 == 0) &#123; return wrongSize; &#125; if (nDuration0 &lt; 1000) &#123; fileSizeString = df.format((double) nDuration0) + "ms"; &#125; else if (nDuration0 &lt; 60000) &#123; fileSizeString = df.format((double) nDuration0 / 1000) + "s"; &#125; else if (nDuration0 &lt; 3600000) &#123; fileSizeString = df.format((double) nDuration0 / 60000) + "min"; &#125; else &#123; fileSizeString = df.format((double) nDuration0 / 3600000) + "h"; &#125; return fileSizeString;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中实现延时执行操作的几种方法]]></title>
    <url>%2Fposts%2Ffdc60895.html</url>
    <content type="text"><![CDATA[在Android开发中我们可能会有延时执行某个操作的需求，例如我们启动应用的时候，一开始呈现的是一个引导页面，过了两三秒后，会自动跳转到主界面。这就是一个延时操作。下面是实现延时执行操作的几种方法： 使用线程的休眠实现延时操作12345678910new Thread() &#123; @Override public void run() &#123; super.run(); Thread.sleep(3000);//休眠3秒 /** * 要执行的操作 */ &#125; &#125;.start(); 使用TimerTask实现延时操作**12345678910TimerTask task = new TimerTask() &#123; @Override public void run() &#123; /** *要执行的操作 */ &#125; &#125;; Timer timer = new Timer(); timer.schedule(task, 3000);//3秒后执行TimeTask的run方法 使用Handler的postDelayed方法实现延时操作123456789Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /** *要执行的操作 */ &#125; &#125;, 3000);//3秒后执行Runnable中的run方法]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android判断文件是否存在,新建、删除]]></title>
    <url>%2Fposts%2F547382f.html</url>
    <content type="text"><![CDATA[123456public static boolean fileIsExists(String fileName) &#123; File folder = new File(fileName); if (!folder.exists()) &#123; folder.mkdir(); &#125; &#125; 1234567891011121314//判断文件是否存在 public boolean fileIsExists(String strFile) &#123; try &#123; File f = new File(strFile); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true;&#125; 123456789101112131415 /** * 要删除的文件夹的所在位置 */ public static void deleteFile(File file) &#123; if (file.isDirectory()) &#123; File[] files = file.listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; File f = files[i]; deleteFile(f); &#125;// file.delete();//如要保留文件夹，只删除文件，请注释这行 &#125; else if (file.exists()) &#123; file.delete(); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点归纳总结提纲]]></title>
    <url>%2Fposts%2F9a278d8c.html</url>
    <content type="text"><![CDATA[Android部分 一、Android四大组件 二、Fragment相关 三、动画相关 四、布局相关 五、数据存储 六、线程、进程 七、网络 八、WebView 九、图片 十、Camera相关 十一、音视频相关 十二、ViewPager相关 十三、RecyclerView相关 十四、Canvas相关 十五、传感器相关 十六、性能优化 十七、UI适配 十八、Android中的Context 十九、序列化与反序列化 二十、JSON解析 二十一、二维码 二十二、Permission权限 二十三、Activity工作原理 二十四、View事件分发机制 二十五、View的绘制流程 二十六、自定义view基本流程 二十七、Apk的打包/安装过程 二十八、App混淆 二十九、App冷启动优化 三十、子线程不能更新UI 三十一、Android Studio Gradle 三十二、adb相关 三十三、逆向安全 三十四、NDK开发 三十五、设计模式 三十六、架构模式 RxJava Kotlin Dagger 2 Flutter Weex Hybrid 混合开发 OpenGL 测试工具其他冷门知识其他补充：Java部分 一、Java基础 二、Java数据结构和算法 Android部分 一、Android四大组件1：Activity相关， Activity生命周期理解，Activity启动另一个Activity返回的完整生命周期， Activity四种启动模式，Activity任务栈理解（先进后出），Activity的显示隐式启动，Activity的隐式启动（理解Scheme跳转协议），Activity之间的跳转与回调，Activity之间的intent数据传递，理解Activity工作原理Activity与Window之间的关系，Activity和dectorView等2：Service相关， Service生命周期方法，Service的两种启动方式的使用，start与bind的区别，何时需要停止Service, Service的使用场景理解, 后台Service与前台Service，如何提高后台服务的存活率，如何保证一个后台服务不被kill, IntentService的使用等3：BroadcastReceiver相关，广播的两种注册方式（隐式/显示广播），广播的注册/反注册注意事项，有序广播、本地广播，接收到广播Action后的处理方法等4：ContentProvider相关，ContentProvider的使用，如何使用ContentProvider实现应用间的数据共享，ContentProvider使用的content URI形式的理解等 二、Fragment相关虽然Fragment不属于Android四大组件（也有人说它是第五大组件），但是作为Android日常开发使用的高频组件之一，必须要了解Fragment的使用方法和注意事项 1：Fragment的生命周期，以及Fragment生命周期与其宿主Activity生命周期的对应关系2：如何通过FragmentTransaction实现Fragment的添加、移除、替换、显示、隐藏等3：Fragment之间的跳转，Fragment如何与Activity交互4：如何管理Fragment回退栈5：没有视图的Fragment的用处6：FragmentManager可提供使用的方法7：v4包与app包提供的Fragment使用的区别注意项8：Fragment使用的其他坑 三、动画相关1：帧动画（FrameAnimation），帧动画的使用方式，xml和代码两种实现方式，帧动画使用注意事项，利弊等2：补间动画（TweenAnimation）, 四种常用的补间动画：alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）的使用方式，xml和代码两种实现方式，相关属性的理解与注意事项，动画的监听设置，使用AnimatorSet播放多个组合动画等3：属性动画（PropertyAnimation）, 属性动画的使用方法，ValueAnimator与ObjectAnimator的使用，相关属性的理解，AnimatorSet同时播放多个动画，Interpolator（动画差值器）的理解与使用，AnimatorListener的设置，属性动画的工作原理等4：如何利用Canvas绘制动画5：了解Android 矢量动画实现6：转场动画，触摸反馈动画，其他自定义动画 四、布局相关1：常用布局LinearLayout、RelativeLayout、FrameLayout, xml与代码两种使用方式，相关属性的理解，会在代码中动态的设置与改变LayoutParams的相关属性控制view2：非常用布局AbsoluteLayout、TableLayout、GridLayout的使用3：百分比布局，PercentRelativeLayout、PercentLinearLayout、PercentFrameLayout的了解与使用4：ConstraintLayout（约束布局）的使用，相关属性的理解5：FlexboxLayout（流动布局）的使用，相关属性的理解6：CoordinatorLayout的使用，会使用support.design库提供的CoordinatorLayout布局来实现常见的滑动折叠/展开浸入式联动特效，理解Behavior解决嵌套滑动冲突与事件拦截处理的原理，理解NestedScroll机制7：界面布局类型的选择和性能优化 五、数据存储1：SharedPreferences，sp的使用场景，sp的常用方法，sp能保存的数据类型，sp的保存位置，注意事项等文件存储，常规文件操作（I/O读写操作、文件的创建/删除/复制）、外置sdcard卡的文件存储，读写权限， 如何使用FileProvider适配Android 7.0 (file uri exposed问题)，应用目录下文件的创建存取（应用私有文件），压缩文件（zip/rar）的压缩与解压缩2：SQLite数据库存储，SQLiteOpenHelper的使用，数据库需要升级时的注意事项（新老数据的保留），数据库表的创建/删除/清空，SQL语句语法（增删改查、排序、多表联查），利用execSql和系统提供的增删改查api两种方式操作，多线程操作数据库安全问题（加锁同步），大量频繁数据库操作使用事务，第三方的基于数据库的开源库方案3：ContentProvider，自定义ContentProvider的使用，ContentProvider的抽象方法增删改查的实现，ContentProvider如何在应用间共享数据，ContentProvider涉及的Uri概念理解，有哪些系统的ContentUrl，什么是ContentResolver，如何用ContentResolver查询手机的存储信息（如联系人、多媒体图片、音视频等）4：网络存储，如何读取文件流上传文件（表单方式），如何下载文件并保存，如何提交json格式的数据，如何解析服务器返回的json数据，网络传输数据的加密解密，常规的数据提交方式（GET/POST）以及 Content-type的几种常见方式的理解（具体参考网络部分总结） 六、线程、进程1：什么是进程，什么是线程，理解进程和线程的区别和联系（默认一个android应用是系统的一个进程，线程共享进程的所有资源，app的默认工作线程是主线程UI线程）2：如何在app创建多进程/子进程，子进程与主进程的关系，进程间通信方式IPC（文件共享/Messenger/AIDL/ContentProvider/饿了么HermesEventBus等），app开启多进程有哪些好处/坏处，Android进程的优先级（前台/可见/服务/后台/空），如何提升app自身的进程优先级，进程保活方案，多进程情况下Application创建的区别（onCreate）3：如何在app创建子线程，子线程与主线程的通信方式（共享内存变量/Handler/runOnUiThread/EventBus等），线程池的使用，如何手动创建线程池，线程池各个参数的合理设置，系统提供的四种线程池的使用，Thread和Runnable的区别，如何安全的取消/终止一个线程的运行（有几种方式），Thread类的wait() sleep() notify()，线程/线程池有上限吗4：线程同步，多线程访问共享资源会带来的安全问题，线程死锁，线程同步的几种方式（同步方法/同步代码块/volatile/ThreadLocal/阻塞队列/原子变量）5：AsyncTask的使用，AsyncTask三个方法的解析，AsyncTask源码实现原理解析，什么情况下AsyncTask的doInBackground会不被执行，为什么new AsyncTask只能执行一次，如何避免AsyncTask导致内存泄露、销毁Activity后它内部的AsyncTask一定会终止运行吗，如何取消AsyncTask6：Handler, Handler发消息的所有使用方式及区别，为什么不能直接在子线程中直接new Handler ，如何Handler实现主线程给子线程发消息，Handler的消息队列实现原理，Handler与Looper、Message的关系，如何避免Handler内存泄漏，HandlerThread的使用7：AIDL的实现使用，AIDL的原理分析（Binder机制）8：EventBus实现原理分析 七、网络1：七层网络结构OSI，每层的含义理解2：域名解析的过程，一次网络请求的完整流程3：HTTP协议，什么是HTTP协议，HTTP1.0与2.0的区别，http完整报文的格式（请求头、请求正文、响应头、响应正文），请求头和响应头中常用字段的含义解析，GET/POST，上传文件、上传json格式与普通文本数据的get/post方式的区别（报文角度解析），HTTP响应头各个状态码的含义, 常见网络框架是如何解析响应头/响应正文的，可以自定义响应头中的ResponseCode吗, Cookie和Session, 长连接和短连接4：TCP三次握手, TCP与UDP的区别，Android代码实现TCP和UDP通信（Socket api实现），Socket，如何使用Socket自定义协议（如可以用Socket api实现http协议，或任何双方约定好的自定义协议），使用Websocket实现收发消息等5：常见网络请求库（OkHttp3/Volley/Retrofit）及实现原理解析，原生的网络请求使用，理解异步请求和同步请求6：Https安全通信，与Http的区别，TSL/SSL加密协议，CA证书，防止运营商劫持7：如何自己实现一个网络请求框架 八、WebView1：WebView的基本使用和设置方法2：WebView JS与原生代码交互的几种方式（方法互调、传参、返回值），优缺点/安全性，JSBridge, 如何自定义协议实现一个JSBridge3：WebView的各种坑，避免WebView内存泄漏4：WebView安全漏洞，不同Android版本的差异，如何避免WebView安全漏洞5：Hybrid App混合开发的原理，Hybrid与原生开发有哪些优势与不足，H5/CSS/JS语法了解 九、图片1：主流图片格式（png jpg gif bmp wbmp ）的区别，ARGB_8888，RGB_888，RGB_565, RGB_444等色彩格式的区别2：如何计算一张图片（Bitmap）在Android中占用的内存大小分析（加载网络/sdcard图片与加载drawable下的图片两种），3：图片的压缩，从图片尺寸（节约内存），图片大小（节约流量），图片格式（色彩像素大小）三方面考虑4：加载大图注意事项，OOM5：图片缓存，三级缓存，LRU Cache原理，缓存大小是如何调整的，Android提供的LRUCache解析6：图片加载库（Glide/Picasso/Fresco）的使用方法，实现原理（如何做到保证跟Activity/Fragment生命周期一致的），使用的缓存策略，内存策略，如何自己实现一个图片加载库7：如何从图片文件/资源图片文件加载Bitmap. Bitmap压缩存储到文件8：图片剪裁、旋转、缩放9：圆角图片的实现（几种方式）以及其他各种形状图片10：图片选择库，第三方开源的与调用系统的 十、Camera相关1：利用系统Camera api自定义一个Camera的流程，如何配合Surfaceview/TextureView使用，Camera参数的设置，Camera预览，预览大小拍照大小的选择，预览画面旋转角度问题的处理，闪光灯，前置摄像头与后置摄像头切换，自动对焦问题，Camera坐标系，如何捕获Camera预览数据保存为图片（拍照功能的实现），保存图片时旋转角度问题的处理，何时需要释放Camera资源（不释放会导致什么问题），如何打开系统相机进行拍照/录视频（需要注意什么），Camera录制视频（配置MediaRecorder使用）2：Camera2，Camera2与Camera的区别，Camera2中常用的类，如何利用Camera2实现预览、拍照等功能 十一、音视频相关1：使用MediaRecorder录制音频2：使用MediaRecorder录制视频（配合Camera使用）3：使用AudioRecord录制音频，特殊格式如Mp3格式的录制，Android常见哪些音频格式, 哪些是同时可以兼容IOS平台的4：使用MediaPlayer播放视频/音频5：使用AudioTrack播放音频6：音视频编解码，常见的音视频的编码格式，硬解与软解/硬编与软编的区别及常用解决方案（目前硬件编解码主要是用Android的MediaCodec，软解编解码一般是采用开源库FFMpeg）7：视频的特效实现（如滤镜、合成、转场、涂鸦、水印、美颜、叠加等），美拍、抖音、直播等视频特效，市场主流的短视频SDK8：Android视频直播的实现（推流、播放），流媒体，主要的流媒体协议（RTMP、RTSP等），跟HTTP区别是什么，市场主流的直播SDK9：视频播放器，自定义实现播放功能（MediaPlayer或VideoView）, 播放本地视频/在线视频，常见开源播放器引擎（如bilibili的ijkPlayer的，Google的ExoPlayer）的学习使用源码解析，如何实现常见视频app软件的弹幕、音量调节、亮度调节、 倍速调节、 清晰度切换等功能（可以参考主流开源库GSYVideoPlayer、JiaoZiVideoPlayer等的实现）10：录屏（视频/Gif），截屏 十二、ViewPager相关1：ViewPager + PagerAdapter+View的使用方式2：ViewPager + FragmentPagerAdapter + Fragment的使用方式3：ViewPager的页面预加载特性，如何防止/进行数据预加载（View和Fragment两种），PagerAdapter/FragmentPagerAdapter 的缺陷，ViewPager刷新问题（PagerAdapter/FragmentPagerAdapter）, POSITION_NONE问题4：ViewPager的常见特效实现，如无限循环滑动的Banner广告条，单页显示3个Item的ViewPager炫酷切换效果，ViewPager换页滑动特效（PageTransformer应用动画效果）5：ViewPager的左右滑动监听，PageChangeListener中的几个方法解析，ViewPager指示器，自定义实现，常见开源库（ViewPagerIndicator、MagicIndicator） 十三、RecyclerView相关1：RecyclerView的基本使用方式，如何使用RecyclerView的三种布局管理器LinearLayoutManager、GridLayoutManager、StaggeredGridLayoutManager实现以前ListView、GridView以及瀑布流的效果，RecyclerViewAdapter的使用，多类型布局的、分组布局的Adapter使用（可以参考RecyclerViewAdapter简化使用开源库BRVAH），RecyclerView设置header/footer, RecyclerView上拉刷新、下拉刷新（配合SwipeRefreshLayout），RecyclerView设置分割线（ItemDecoration），RecyclerView点击事件2：RecyclerView的源码解析，与ListView相比的差异， ViewHolder3：RecyclerView的局部刷新，如何只刷新某一项，只刷新某一项中的某个控件，与ListView的局部刷新比较 十四、Canvas相关1：Canvas基本使用方法，画笔Paint的使用，Canvas绘制各种形状、文字、图片、曲线，Canvas画笔设置，Canvas剪裁，Canvas的现场保存/恢复，Canvas的变换、平移、缩放、旋转等2：Canvas在自定义View当中的使用 十五、传感器相关1：GPS, 如何使用Android原始代码实现GPS定位的获取（LocationManager），权限，注意事项（耗电量高，不能一直开着），拓展：LBS基站定位（国内常用的地图SDK高德/百度等定位都是以上两种方式的组合）2：其他手机支持的常见传感器，如加速度传感器、方向传感器、陀螺仪传感器、重力传感器、加速度传感器、距离传感器、计步传感器、光线传感器等，如何代码中设置监听器实时监听这些传感器的变化参数值，SensorManager，注册/反注册监听 十六、性能优化1：ANR, 什么是ANR, Activity/BroadcastReceiver/Service对ANR的响应时间，ANR产生的根本原因是什么，如何避免ANR, 如何避免在UI线程执行耗时任务，哪些日常操作任务是耗时任务（文件I/O、数据库、网络、解析等等）、有哪些方式可以异步处理耗时任务（线程、Aynctask等），区分UI线程和子线程，哪些日常场景是在UI线程中运行的（如四大组件都是在UI线程执行的），在不确定是UI还是非UI线程的运行环境中如何判断当前是否是主线程？（有几种方法）2：OOM，什么是OOM, 哪些情况容易产生OOM，如何避免OOM3：ListView优化，理解ListView的重用item机制原理，利用ViewHolder缓存view减少getView的执行时间，减少ItemView的布局层次，减少getView方法中的判断/计算/耗时逻辑，item中的图片避免每次都重新加载，做好图片缓存（使用图片加载库），快速滑动时不加载图片, 数据分页加载，图片错乱问题4：UI 卡顿，UI 卡顿的原因，帧率，16ms, 过渡绘制，耗时任务，如何布局优化，减少布局嵌套5：内存泄漏，GC垃圾回收机制，可能造成Android内存泄漏的几种情况，如何避免内存泄漏，Java内存分配管理的机制，堆内存和栈内存的区别，Android系统会为一个应用分配多大内存，如何提高应用内存，内存泄漏的排查方法/工具6：内存优化，弱引用与软引用（Weakreference、Softreference）, 避免对Activity作为Context的长时间引用或静态引用(如创建Handler AsyncTask的正确姿势)，SparseArray, 为什么Android推荐使用SparseArray来替代1：HashMap? 优越在哪里7：Crash崩溃异常，ForceClose，各种运行时异常（如空指针），如何避免，发生Crash时如何在app中捕获并保存本地或上传服务器8：广播和Service中可以进行网络请求吗，可以执行耗时任务吗9：AS哪些工具可以用来排查性能问题10：电池优化，网络优化 （缓存/离线） 十七、UI适配1：px、dp、sp、像素密度density和屏幕分辨率以及屏幕尺寸之间的关系，res/drawable-xxx各个文件夹与屏幕像素密度之间的关系2：保证不同屏幕展示的效果最好用Android系统提供的布局属性，不要写死固定大小，图片按照比例放在不同密度的drawable文件下或只用一套3：使用百分比布局（PercentxxxLayout）4：使用约束布局（ConstraintLayout）5：目前主流适配方案，今日头条屏幕适配方案和smallestWidth限定符适配方案分析6：目前市面上流行的刘海屏幕适配方法目前市面上流行的刘海屏幕适配方法 十八、Android中的Context1：理解Context的含义，Activity、Context、Application的区别和使用场景， ContextWrapper解析，getActivity()/getContext()/getApplication()/getApplicationContext()的区别2：避免Context静态持有，避免内存泄漏 十九、序列化与反序列化1：Serializable实现，实现方法，Intent传递与获取Serializable的方法2：Parcelable实现，实现方法，，Intent传递与获取Parcelable的方法3：Serializable和Parcelable区别，适合的使用场景（存储在内存中，推荐使用parcelable，存储在硬盘上，推荐使用Serializable） 二十、JSON解析1：理解json格式的定义，什么是合法/不合法的json格式，什么样的json格式利于/不利于客户端开发的解析2：Json的解析，使用原生代码解析，使用第三方库解析（Gson、FastJson、Jackson），Java类与Json字符串互转，注意事项，同一个字段多类型的json解析 二十一、二维码1：二维码扫描，基于ZXing或Zbar开源库的开发（如开源库BGAQRCode-Android），如何提高二维码扫描的识别率，生成二维码 二十二、Permission权限1：Android 6.0以后的权限适配，动态检查是否有某项权限，动态申请权限，申请权限的回调处理（有哪些第三方库可简化处理）、明确哪些行为是危险权限需要动态申请的，6.0以前的权限处理方式对比 二十三、Activity工作原理1：从手指点击桌面的app开始到界面呈现发生了哪些过程，第一个Activity对象是如何被创建的，Application对象是如何被创建的，默认的工作线程（UI线程）是如何创建的，主线程Looper的如何创建的，Activity与Window的关系，WindowManager解析，Android系统是如何通过WindowManager管理窗口的 二十四、View事件分发机制1：Touch事件的各个Action含义，何时会被触发2：Touch事件在View之间的传递过程（View、ViewGroup、Activity）,分发与处理的流程，何时会被消费，何时会被拦截，如何解决滑动冲突, onTouch 和 onTouchEvent区别，onClick与onTouch的关系3：Android手势处理，双指缩放、双击、单击，多点触控 二十五、View的绘制流程1：Activity的setContentView()做了什么，Window&amp;PhoneWindow&amp;DectorView&amp;ViewRoot&amp;contentView之间的关系2：View绘制的三个阶段measure，layout, draw的解析3：requestLayout，onLayout, onDraw, drawChild的区别与联系4：invalidate与postInvalidate的区别与联系 二十六、自定义view基本流程1：自定义属性，onMesure()，onLayout(ViewGroup) , onDraw(), TouchEvent的处理2：组合控件的自定义方式 二十七、Apk的打包/安装过程1：apk的打包过程，经过哪些步骤，每个步骤做了什么，AS的打包过程执行哪些task，每个task干了什么，apk签名（签名文件生成，AS打包apk时v1与v2选项的区别），apk对齐，apk加固（第三方都是如何实现的）2：apk的安装过程，系统在安装之前会做哪些工作？校验哪些信息？（不同Android版本之间的差异），安装apk的过程做了什么，会生成哪些文件，apk会被安装到系统哪个路径，app的私有数据（sp/数据库/私有文件）存储在哪个路径，哪些情况下安装apk会不成功，覆盖安装时（app升级）与app的包名、签名、版本号versionCode之间的关系, 什么是ART, Android 5.0以后ART替代之前的Dalvik虚拟机有哪些优点，AOT，为啥5.0以后安装的时候时间特别长但是运行速度比以前快3：app的卸载过程发生了什么，系统会删除哪些与apk相关的东西 二十八、App混淆1：混淆常用基本语法，混淆类、成员、方法，哪些类需要混淆，哪些类不能被混淆的，混淆文件的配置2：如何根据混淆之后的错误日志定位混淆之前的代码 二十九、App冷启动优化1：冷启动与热启动的区别，从点击桌面app图标到app的第一个Activity页面呈现经历了什么，优化哪个地方能加快页面的呈现2：如何实现app冷启动秒开，如何避免冷启动白屏/黑屏/缓慢，有哪些优化方案 三十、子线程不能更新UI1：正常情况下子线程不能更新UI，“子线程不能更新UI”这句话是一定的吗？什么情况下子线程可以更新UI？（如这个UI控件是由这个线程创建时，SurfaceView也可以在单独线程中刷新，OpenGL可以在渲染线程中绘制）2：view.postDelay(Runnable r)方法是运行在子线程中的吗？区分哪些场景是在主线程中的 三十一、Android Studio Gradle1：build.gradle常用配置，minSdkVersion、targetSdkVersion、compileSdkVersion三者的关系区别，这三个值对app代码开发/安装运行/版本更新时的影响，包名/签名/混淆/源码路径的配置、如何利用BuildConfig添加自定义的属性配置，从gradle中加载properties配置文件，如何在gradle中开启/关闭混淆/调试/Log输出，如何使用gradle任务打包，如何在dependence中添加依赖(本地jar包、aar包、so库依赖，远程依赖)，3.0以后的implementation、api、compileOnly与3.0以前的compile provided的区别，如何配置product falvor实现Build Variant变体打包，简单的Gradle task定义，指定task依赖任务，Android Studio的Gradle任务分析，Gradle插件，Gradle版本/仓库配置，groovy语法了解 三十二、adb相关1：掌握常用的adb命令，如使用adb pull/push从手机中拉取/推送文件，adb 截屏，使用adb 抓取log日志, 使用adb 安装/卸载应用，adb命令下调试应用等等 三十三、逆向安全1：app敏感数据的存储，如账户密码，请求的秘钥等，银行类交易类自定义输入键盘（避免拦截），设备唯一标识（Android目前有哪几种方式）2：反编译 apk, 反编译so等, 混淆3：app加固4：如何防止app网络请求被第三方抓包（socket/https）5：WebView开发JS交互避免远程执行漏洞6：加密算法（DES,AES,RSA,MD5,SHA1,Base64）,对称加密与非对称加密7：视频加密 三十四、NDK开发1：JNI基本数据类型，jni函数签名，jni注册native函数的两种方式（静态、动态）2：java与jni互调，java如何调用jni层，jni层如何调用java代码, JNI各种层数据类型与Java/C层各种数据类型互转调用3：Android.mk文件编写，如何连接源文件、.a .so库文件，如何编译生成动态链接库so文件，编译不同平台的so, 编译生成arm64位平台so时注意什么（指针要long型存）, Application.mk, build过程解析4：Android Studio环境下如何使用CMake方式进行NDK开发 三十五、设计模式1：UML类图、时序图2：OO六大设计原则，面向对象的三个基本特征3：23种设计模式，了解常用常见的设计模式并在项目中实践，Android源码中的设计模式4：如何优化代码，如何重构代码，去除重复代码，代码规范 三十六、架构模式1：MVP模式， MVP、 MVC、MVVM（数据绑定式的MVP）的区别, MVP + Clean模式2：模块化（从功能/业务上区分）3：组件化的开发架构，组件化带来的问题，模块之间的跳转，路由，ARouter4：插件化的开发架构，插件化的核心原理，虚拟机(内存管理，类加载，双亲委派), 主流插件化框架原理分析5：热修复核心原理，主流热修复框架原理分析 RxJava 实现原理，什么是响应式编程，观察者/订阅模式，RxJava是如何实现线程自由切换的, RxJava在空间和时间维度上重新组织事件的能力 Kotlin Kotlin学习了解，与Java的区别，哪个更好用 Dagger 2 依赖注入框架，使用与原理解析 Flutter Flutter学习了解，跨平台，同时支持iOS和Android Weex Weex学习了解，跨平台，同时支持iOS和Android Hybrid 混合开发 除H5以外，有哪些混合开发方式（weex，小程序，React Native等了解） OpenGL OpenGL了解，了解OpenGL 的渲染流程（顶点着色器、片元着色器、光栅化、顶点坐标系、法向量、光照、投影、剪裁等等） 学习Android系统中OpenGL ES 2.0/3.0的Api，使用OpenGL配合GLSurfaceView、Render等绘制点、线、面、纹理贴图等等 测试工具 内存分析:MAT,DDMS,Leakcanary(Square) 静态分析:Find Bugs,Lint 压力测试:Monkey 自动化测试: UiAutomator,MonkeyRunner,Rubotium,Athrun(淘宝) 其他冷门知识 Android近场通信NFC、Wifi、蓝牙、USB串口通信等开发 Android内核移植、嵌入式终端开发(非手机，如定制的平板、TV，定制的点餐平台，显示器等), 或基于终端系统之上的应用开发 手机开发(非app开发，这里指手机厂商，如华为，小米，需要精通framework层以及Android系统底层源码)，手机操作系统定制 Android游戏开发（这个不算冷门，只是平时接触比较少） 其他补充： Notification Dialog Bitmap对象的理解 AndroidManifest的作用与理解 App中唤醒其他进程/应用的实现方式 ButterKnife实现原理 Dagger依赖注入 Android 多进程和Application关系 Android页面恢复 如何监听Home键和back键点击 apk多入口 第三方消息推送SDK 地图 硬件加速 Emoji 多国语言适配（不单单指语言strings.xml适配 布局也可能要支持RTL） 正则表达式 armeabi/armeabi-v7a/arm64-v8a等so库兼容问题 类的加载机制 Android 65K问题，分包，引入第三方包冲突解决方案 计时器/定时任务（Android有哪几种实现方式） Theme 和 Styles 多点触控 闹钟 音乐播放器 输入法软键盘相关 分屏 夜间模式 待续… Java部分一、Java基础1：Java基础数据类型，各占用多少字节，数据类型之间的相互转换，数据类型之间的比较==和equals的区别2：String、StringBuffer、StringBuilder区别，哪个是线程安全的，何时需要使用后面两个（有什么区别），String属于Java的基础数据类型吗，字符串操作（分隔、拼接、替换、查找），字符串比较，String与其他基础数据类型的包装类型之间的互转，String与char或byte Array之间的互转，创建字符串变量有几种方式有什么区别，什么是字符串池，为什么说Java字符串是不可变对象3：Java集合相关，集合的排序/遍历/复制， HashMap原理，HashMap 和 HashTable 区别，LinkedHashMap源码分析， HashCode 作用，如何重载hashCode方法，ArrayList与LinkList区别与联系, List与数组[]相互转换，List,Set,Map的区别，ConcurrentHashMap的实现原理，要存储一个数据元素不重复的集合该使用哪种集合，要存储一个数据元素是有序的集合该使用哪种集合，ArrayList和HashMap 等集合是如何扩容的4：Java反射相关，方法、成员变量5：Java注解相关6：Java线程同步相关，Java死锁产生的原因及避免，方法锁、对象锁、类锁的意义和区别，线程同步的方法：Synchronized、lock、reentrantLock分析，Synchronized原理，Volatile实现原理，ThreadLocal的原理和用法，ThreadPool的用法和示例，wait()和sleep()的区别，wait/notify关键字的理解7：Java枚举相关8：Java内存管理，虚拟机 ，GC机制，Java引用类型，循环引用，Java内存泄漏，Java内存模型（堆内存 栈内存 常量池），Java中new 一个对象是存在哪里的9：JVM类加载机制，ClassLoader(类加载器)的理解，Android中的区别10：什么是多态，Java封装、继承和多态的理解11：什么是内部类？内部类的作用，静态内部类的作用12：什么是抽象类，抽象类和接口区别，抽象类是否可以没有方法和属性，接口的意义13：Java泛型相关，如何通过泛型传递Java类作为参数14：序列化的方式 Serializable 和Parcelable 的区别15：静态属性和静态方法是否可以被继承？重写？以及原因？16：final，finally，finalize的区别17：utf-8编码中的中文占几个字节；int型几个字节？，java unicode编码，中文与unicode互转18：什么是深拷贝和浅拷贝19：如何实现多线程断点续传20：Class.forName()和ClassLoader的区别21：待续… 二、Java数据结构和算法1：栈和队列，栈和队列的概念理解，Java代码实现栈LIFO（后进先出）和队列FIFO（先进先出），实现思路，入栈/出栈，栈顶/栈底，入队/出队，队头/队尾，栈/队的遍历，循环队列，判断栈/队列是否为空2：数组和链表，数组和链表的特点和区别，Java代码实现链表结构，数组和链表分别实现查找、插入，删除等操作以及各自的时间复杂度和空间复杂度，链表的反序，两个有序链表的合并，双向链表结构的实现，双向链表的插入、删除等，自定义一个动态数组，Java 类中哪些结构属于数组/链表3：排序算法，Java八大排序算法的实现思路（选择排序，快速排序，冒泡排序，堆排序，希尔排序，归并排序，直接插入排序，基数排序）以及各自的时间复杂度和空间复杂度，最快的排序算法是哪个？ 哪些是稳定/不稳定的排序算法，快排的优化，手写冒泡、快排代码4：查找算法，Java代码实现顺序查找和二分查找，实现思路5：二叉树，二叉树排序，二叉树遍历、查找、删除，哈夫曼树、红黑树6：Hash表，及Hash冲突的解决7：Java有向图的遍历，BFS遍历和DFS遍历（深度优先搜索算法和广度优先搜索算法）、Prim、Dijkstra算法8：经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题）9：两个不重复的数组集合中，两个集合都是海量数据，内存中放不下，求共同元素10：烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？11：时针走一圈，时针分针重合几次12：N*N的方格纸,里面有多少个正方形13：待续…]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView中添加的HeadView隐藏时仍然占用空间的解决方法]]></title>
    <url>%2Fposts%2Fdf7e47f7.html</url>
    <content type="text"><![CDATA[今天在开发的时候遇到了一个ListView中添加的HeadView隐藏时仍然占用空间的解决方法； 具体问题如下：listView.addHeadView(headView); 但是在执行headView.setVisibility(View.GONE);后headView虽然隐藏了，但是仍然占用了空间； 解决方法： 在添加HeadView之前首先创建一个父布局parentView,即： 12345LinearLayout parentView=new LinearLayout (Context context);parentView.addView(headView);listView.addHeadView(parentView); 之后再进行隐藏： 12//就可以实现以上所说的效果了。headView.setVisibility(View.GONE);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android APP分享微信小程序]]></title>
    <url>%2Fposts%2F83fb494f.html</url>
    <content type="text"><![CDATA[需求：APP端 将公司的微信小程序 分享至微信好友 最近，微信小程序比较火热，公司也在做这一块，目前公司的小程序都是由H5端开发的，我们Android端也接到一个任务，那就是Android端应支持微信小程序的分享，并且通过分享出去的小程序可以启动我们的APP； 今天我们先来完成：Android端应支持微信小程序的分享！！！ 分析： 微信开放平台SDK支持小程序类型分享，详见官方文档： https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317340&amp;token=&amp;lang=zh_CN a) 要求发起分享的App与小程序属于同一微信开放平台帐号； b) 支持分享小程序类型消息至好友会话，不支持“分享至朋友圈” “收藏”； c) 微信客户端版本要求：6.5.6及以上微信客户端版本，若客户端版本低于6.5.6，小程序类型分享将自动转成网页类型分享。开发者必须填写网页链接字段，确保低版本客户端能正常打开网页链接； d) 支持分享大图卡片样式，自定义图片建议长宽比是 5:4。6.5.9及以上版本微信客户端小程序类型分享使用大图卡片样式。 e)支持分享开发版/体验版小程序，为支持开发者调试，开发者工具包支持分享开发版/体验版小程序至微信，开发者可控制分享的小程序版本。 把文档看了一遍，发现限制是比较多的，但是功能实现还是很简单的，下面让我们开始吧！！！ 开发： 前期准备 小程序与APP主体账号绑定开发人员希望通过APP分享小程序，需要先将小程序与APP主体账号（即APP的微信开放平台账号）绑定，APP才具有分享对应小程序的能力。如果没有与主体账号绑定，分享时是报错的，如下图：​ 登录APP所在的微信开放平台：https://open.weixin.qq.com/绑定小程序 由上图可以看到，绑定小程序的数量是有限制的。我们点击【绑定小程序】按钮，打开的新页面 输入小程序开发的主账号和密码，输入验证码提交就可以了，然后再通过手机微信扫码验证一下。 绑定成功后，直接就能在绑定列表中看到已绑定的小程序！！！ 代码实现小程序端提供参数：12miniProgram.userName="xxx"; //小程序IDminiProgram.path="pages/xxx/xxx"; //小程序路径 配置gradle123dependencies &#123; compile 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'&#125; 分享小程序的核心代码12345678910111213141516171819202122232425262728293031323334public void shareMinP(ShareMiniPModel shareModel)&#123; if (shareModel == null) return; WXMiniProgramObject miniProgramObj = new WXMiniProgramObject(); miniProgramObj.webpageUrl = shareModel.getWebPageUrl(); // 兼容低版本的网页链接 miniProgramObj.miniprogramType = shareModel.getMiniProgramType(); // 分享小程序版 正式版:0，测试版:1，体验版:2 miniProgramObj.userName = shareModel.getMiniId(); // 小程序原始id miniProgramObj.path = shareModel.getMiniPath(); // 小程序页面路径 localWXMediaMessage = new WXMediaMessage(miniProgramObj); localWXMediaMessage.title = shareModel.getTitle(); // 小程序消息title localWXMediaMessage.description = shareModel.getDescription(); // 详细描述 if (!TextUtils.isEmpty(shareModel.getImageUrl()))&#123; inflateImage(shareModel.getImageUrl(), new Callback() &#123; // 小程序图片 @Override public void onLoadingComplete(String s, View view, Bitmap bitmap) &#123; thumbBmp = bitmap; localWXMediaMessage.thumbData = bmpToByteArray(thumbBmp, true); if (localWXMediaMessage.thumbData.length &lt; 131072)&#123; WXsendReq(SendMessageToWX.Req.WXSceneSession, localWXMediaMessage); &#125; else &#123; LogUtils.e("分享小程序，缩略图不得超过128kb"); &#125; &#125; &#125;); &#125; else if (shareModel.getImageBitmap() != null)&#123; thumbBmp = shareModel.getImageBitmap(); localWXMediaMessage.thumbData = bmpToByteArray(thumbBmp, true); if (localWXMediaMessage.thumbData.length &lt; 131072)&#123; WXsendReq(SendMessageToWX.Req.WXSceneSession, localWXMediaMessage); &#125; else &#123; LogUtils.e("分享小程序，缩略图不得超过128kb"); &#125; &#125;&#125; Demo演示为了避免麻烦，我们直接下载使用官方Demo，在其源代码上直接修改，修改的内容主要如下： a. 包名（必须修改，使用你项目APP的实际包名） b. 配置gradle（微信sdk包、签名文件） c. 增加分享小程序的按钮和事件下载微信开放平台官方Demo https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_Android.zip 修改包名 使用Androidstudio打开demo，目录结构如下图，修改其包名 如上图，取消compact empty middle packages的默认选中在对应包名的文件夹上，直接右键修改名称，改成包名对应的名称，并全部应用可参考：https://www.jianshu.com/p/557e1906db1a修改后的包名，必须是你项目APP的实际包名，且已通过微信开放平台审核的APP包名； 配置gradle（修改依赖、修改签名） 签名必须使用你项目APP对应的签名文件，即你申请微信开放平台时APP对应的签名文件； 修改APP_ID12345678910public class Constants &#123; // APP_ID 替换为你的应用从官方网站申请到的合法appId public static final String APP_ID = "wxf666676666636666"; public static class ShowMsgActivity &#123; public static final String STitle = "showmsg_title"; public static final String SMessage = "showmsg_message"; public static final String BAThumbData = "showmsg_thumb_data"; &#125;&#125; 增加分享小程序的按钮和事件 测试 选择分享的人员 收到分享的小程序卡片]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android判断当前应用是否开启消息通知]]></title>
    <url>%2Fposts%2F7299f542.html</url>
    <content type="text"><![CDATA[当APP有推送功能时，需要判断当前app在手机中是否开启了允许消息推送，否则即使添加了推送代码仍然收不到通知 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 判断通知权限是否打开 */public static boolean isNotificationEnable(Context context) &#123; String CHECK_OP_NO_THROW = "checkOpNoThrow"; String OP_POST_NOTIFICATION = "OP_POST_NOTIFICATION"; AppOpsManager mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; Class appOpsClass = null; /* Context.APP_OPS_MANAGER */ try &#123; appOpsClass = Class.forName(AppOpsManager.class.getName()); Method checkOpNoThrowMethod = appOpsClass.getMethod(CHECK_OP_NO_THROW, Integer.TYPE, Integer.TYPE, String.class); Field opPostNotificationValue = appOpsClass.getDeclaredField(OP_POST_NOTIFICATION); int value = (Integer) opPostNotificationValue.get(Integer.class); return ((Integer) checkOpNoThrowMethod.invoke(mAppOps, value, uid, pkg) == AppOpsManager.MODE_ALLOWED); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false;&#125;/** * 设置消息通知 * @param context */public static void gotoSetNotification(Context context) &#123; Intent intent = new Intent(); if (Build.VERSION.SDK_INT &gt;= 26) &#123; // android 8.0引导 intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("android.provider.extra.APP_PACKAGE", context.getPackageName()); &#125; else if (Build.VERSION.SDK_INT &gt;= 21) &#123; // android 5.0-7.0 intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("app_package", context.getPackageName()); intent.putExtra("app_uid", context.getApplicationInfo().uid); &#125; else &#123; // 其他 intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); intent.setData(Uri.fromParts("package", context.getPackageName(), null)); &#125; intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent);&#125; Activity的onCreate中进行判断： 123456//判断该app是否打开了通知，如果没有的话就打开手机设置页面 if (!isNotificationEnabled()) &#123; gotoSetNotification(); &#125; else &#123; //当前app允许消息通知 &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Snackbar的使用]]></title>
    <url>%2Fposts%2F30a2bcae.html</url>
    <content type="text"><![CDATA[Snackbar是design support library中的组件的其中之一，它的使用效果与Toast类似，但更加灵活Snackbar拥有的特性： 显示一段时间或当用户与之进行交互后，会自动消失 通过CoordinatorLayout可以实现向右滑动消除Snackbar的效果 同一时间只能显示一个Snackbar 与Toast类似地使用LENGTH_LONG 和 LENGTH_SHORT设置显示时间 提供Action属性供添加点击事件监听 提供回调函数可以对Snackbar进行监听 想要使用Snackbar，首先需要添加com.android.support:design依赖项 一、 Snackbar的最简单用法是和Toast一样声明1Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT).show(); 大部分属性与Toast相同，不过第一个参数传入的不是Context，而应该是一个View，因为Snackbar需要一个控件容器用来容纳自身，这里使用一个TextView所以，主布局文件可修改为 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="Snackbar" /&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="点击按钮" /&gt;&lt;/LinearLayout&gt; MainActivity 修改为如下所示，当点击了Button后弹出Snackbar 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.text); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 二、 此外，Snackbar可以通过Action来与之进行交互1234567891011121314button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .show(); &#125; &#125;); 三、 官方推荐使用CoordinatorLayout作为Snackbar的容纳容器，这样就可以实现向右滑动消除Snackbar的效果将主布局文件修改为 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id="@+id/layoutRoot" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="按钮" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/LinearLayout&gt; MainActivity 文件修改为 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; private CoordinatorLayout layout; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); layout = (CoordinatorLayout) findViewById(R.id.layoutRoot); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .show(); &#125; &#125;); &#125;&#125; 四、 可以设置Snackbar的出现消失监听函数在Snackbar出现和消失时分别弹出一个Toast进行提示 123456789101112131415161718192021222324252627button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this, "消失了", Toast.LENGTH_SHORT).show(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Toast.makeText(MainActivity.this, "出现了", Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(); &#125; &#125;); 五、改变Snackbar的背景色想要设置Snackbar的背景色，就要通过getView()方法了，这里Snackbar需要换一种声明方式 123456789button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar snackbar = Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT); //设置背景色 snackbar.getView().setBackgroundColor(Color.parseColor("#375ED1")); snackbar.show(); &#125; &#125;); 六、Snackbar不一定只能从屏幕底端出现Snackbar会沿着View 的树状路径，找到第一个合适的布局或窗口视图，作为父 View因此，我们可以改变Snackbar的父View位置，从而改变Snackbar的出现位置修改主布局文件，将屏幕平均分为上下两个空间 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id="@+id/layoutRoot" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="按钮" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="#adc"&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View坐标详解]]></title>
    <url>%2Fposts%2Fbc32efd9.html</url>
    <content type="text"><![CDATA[转：https://blog.csdn.net/yanbober/article/details/50419117 背景学习自定义控件以此为基础，先总结一下自定义控件的一个核心知识点——坐标系。 很多人可能不屑一顾Android的坐标系，但是如果你想彻底学会自定义控件，我想说了解Android各种坐标系及一些API的坐标含义绝对算一个小而不可忽视的技能；所谓Android自定义View那几大主要onXXX()方法的重写实质其实大多数都是在处理坐标逻辑运算，所以我们就先来就题重谈一下Android坐标系。 android坐标系说到Android坐标系其实就是一个三维坐标，Z轴向上，X轴向右，Y轴向下。这三维坐标的点处理就能构成Android丰富的界面或者动画等效果，所以Android坐标系在整个Android界面中算是盖楼房的尺寸草图，下面我们就来看看这些相关的概念。 android屏幕区域划分我们先看一副图来了解一下Android屏幕的区域划分 通过上图我们可以很直观的看到Android对于屏幕的划分定义。下面我们就给出这些区域里常用区域的一些坐标或者度量方式。如下： 12345//获取屏幕区域的宽高等尺寸获取DisplayMetrics metrics = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(metrics);int widthPixels = metrics.widthPixels;int heightPixels = metrics.heightPixels; 123//应用程序App区域宽高等尺寸获取Rect rect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect); 1234//获取状态栏高度Rect rect= new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);int statusBarHeight = rectangle.top; 123//View布局区域宽高等尺寸获取Rect rect = new Rect(); getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect); 特别注意：上面这些方法最好在Activity的onWindowFocusChanged ()方法或者之后调运，因为只有这时候才是真正的显示OK，不懂的可以看我之前关于setContentView相关的博客。 android view绝对相对坐标系上面我们分析了Android屏幕的划分，可以发现我们平时开发的重点其实都在关注View布局区域，那么下面我们就来细说一下View区域相关的各种坐标系。先看下面这幅图： 通过上图我们可以很直观的给出View一些坐标相关的方法解释，不过必须要明确的是上面这些方法必须要在layout之后才有效，如下： View的静态坐标方法 解释 getLeft() 返回View自身左边到父布局左边的距离 getTop() 返回View自身顶边到父布局顶边的距离 getRight() 返回View自身右边到父布局左边的距离 getBottom() 返回View自身底边到父布局顶边的距离 getX() 返回值为getLeft()+getTranslationX()，当setTranslationX()时getLeft()不变，getX()变。 getY() 返回值为getTop()+getTranslationY()，当setTranslationY()时getTop()不变，getY()变。 同时也可以看见上图中给出了手指触摸屏幕时MotionEvent提供的一些方法解释，如下： MotionEvent坐标方法 解释 getX() 当前触摸事件距离当前View左边的距离 getY() 当前触摸事件距离当前View顶边的距离 getRawX() 当前触摸事件距离整个屏幕左边的距离 getRawY() 当前触摸事件距离整个屏幕顶边的距离 上面就解释了你在很多代码中看见各种getXXX方法进行数学逻辑运算判断的含义。不过上面只是说了一些相对静止的Android坐标点关系，下面我们来看看几个和上面方法紧密相关的View方法。如下： View宽高方法 解释 getWidth() layout后有效，返回值是mRight-mLeft，一般会参考measure的宽度（measure可能没用），但不是必须的。 getHeight() layout后有效，返回值是mBottom-mTop，一般会参考measure的高度（measure可能没用），但不是必须的。 getMeasuredWidth() 返回measure过程得到的mMeasuredWidth值，供layout参考，或许没用。 getMeasuredHeight() 返回measure过程得到的mMeasuredHeight值，供layout参考，或许没用。 上面解释了自定义View时各种获取宽高的一些含义，下面我们再来看看关于View获取屏幕中位置的一些方法，不过这些方法需要在Activity的onWindowFocusChanged ()方法之后才能使用。如下图： 下面我们就给出上面这幅图涉及的View的一些坐标方法的结果（结果采用使用方法返回的实际坐标，不依赖上面实际绝对坐标转换，上面绝对坐标只是为了说明例子中的位置而已），如下： View的方法 上图View1结果 上图View2结果 结论描述 getLocalVisibleRect() (0, 0 - 410, 100) (0, 0 - 410, 470) 获取View自身可见的坐标区域，坐标以自己的左上角为原点(0,0)，另一点为可见区域右下角相对自己(0,0)点的坐标，其实View2当前height为550，可见height为470。 getGlobalVisibleRect() (30, 100 - 440, 200) (30, 250 - 440, 720) 获取View在屏幕绝对坐标系中的可视区域，坐标以屏幕左上角为原点(0,0)，另一个点为可见区域右下角相对屏幕原点(0,0)点的坐标。 getLocationOnScreen() (30, 100) (30, 250) 坐标是相对整个屏幕而言，Y坐标为View左上角到屏幕顶部的距离。 getLocationInWindow() (30, 100) (30, 250) 如果为普通Activity则Y坐标为View左上角到屏幕顶部（此时Window与屏幕一样大）；如果为对话框式的Activity则Y坐标为当前Dialog模式Activity的标题栏顶部到View左上角的距离。 到此常用的相关View的静态坐标获取处理的方法和含义都已经叙述完了，下面我们看看动态的一些解释（所谓动静只是我个人称呼而已）。 Android View动画相关坐标系其实在我们使用动画时，尤其是补间动画时，你会发现其中涉及很多坐标参数，一会儿为相对的，一会儿为绝对的，你可能会各种蒙圈。那么不妨看下《Android应用开发之所有动画使用详解 》这篇博客，这里面详细介绍了关于Android动画相关的坐标系统，这里不再累赘叙述。 Android View滑动相关坐标系关于View提供的与坐标息息相关的另一组常用的重要方法就是滚动或者滑动相关的，下面我们给出相关的解释（特别注意：View的scrollTo()和scrollBy()是用于滑动View中的内容，而不是改变View的位置；改变View在屏幕中的位置可以使用offsetLeftAndRight()和offsetTopAndBottom()方法，他会导致getLeft()等值改变。），如下： View的滑动方法 效果及描述 offsetLeftAndRight(int offset) 水平方向挪动View，offset为正则x轴正向移动，移动的是整个View，getLeft()会变的，自定义View很有用。 offsetTopAndBottom(int offset) 垂直方向挪动View，offset为正则y轴正向移动，移动的是整个View，getTop()会变的，自定义View很有用。 scrollTo(int x, int y) 将View中内容（不是整个View）滑动到相应的位置，参考坐标原点为ParentView左上角，x，y为正则向xy轴反方向移动，反之同理。 scrollBy(int x, int y) 在scrollTo()的基础上继续滑动xy。 setScrollX(int value) 实质为scrollTo()，只是只改变Y轴滑动。 setScrollY(int value) 实质为scrollTo()，只是只改变X轴滑动。 getScrollX()/getScrollY() 获取当前滑动位置偏移量。 关于Android View的scrollBy()和scrollTo()参数传递正数却向坐标系负方向移动的特性可能很多人都有疑惑，甚至是死记结论，这里我们简单给出产生这种特性的真实原因—-源码分析，如下： 12345678910111213public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; View的该方法注释里明确说明了调运他会触发onScrollChanged()和invalidated()方法，那我们就将矛头转向invalidated()方法触发的draw()过程，draw()过程中最终其实会触发下面的invalidate()方法，如下： 123456public void invalidate(int l, int t, int r, int b) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; //scroller时为何参数和坐标反向的真实原因 invalidateInternal(l - scrollX, t - scrollY, r - scrollX, b - scrollY, true, false);&#125; 核心就在这里，相信不用我解释大家也知道咋回事了，自行脑补。 scrollTo()和scrollBy()方法特别注意：如果你给一个ViewGroup调用scrollTo()方法滚动的是ViewGroup里面的内容，如果想滚动一个ViewGroup则再给他嵌套一个外层，滚动外层即可。 总结可以发现，上面只是说明了一些View里常用的与坐标相关的概念，关于自定义控件了解学习这些坐标概念只是一个基础，也是一个后续内容的铺垫，所以有必要先完全吃透此部分内容才能继续拓展学习新的东东。 View中还有一些其他与坐标获取相关的方法，但是一般都比较不常用，所以用到时可以现查API或者Debug看现象进行学习即可，这里篇幅和时间有限就不一一道来了。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 控件 RecyclerView]]></title>
    <url>%2Fposts%2F4fcbe74a.html</url>
    <content type="text"><![CDATA[转自：https://www.jianshu.com/p/4f9591291365 概述RecyclerView是什么从Android 5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecylerView，可以用来代替传统的ListView，更加强大和灵活。RecyclerView的官方定义如下： A flexible view for providing a limited window into a large data set. 从定义可以看出，flexible（可扩展性）是RecyclerView的特点。 RecyclerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字Recyclerview即回收view也可以看出。 RecyclerView的优点RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如横向滚动的ListView, 横向滚动的GridView, 瀑布流控件，因为RecyclerView能够实现所有这些功能。 比如：有一个需求是屏幕竖着的时候的显示形式是ListView，屏幕横着的时候的显示形式是2列的GridView，此时如果用RecyclerView，则通过设置LayoutManager一行代码实现替换。 RecylerView相对于ListView的优点罗列如下： RecyclerView封装了viewholder的回收复用，也就是说RecyclerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。 直接省去了listview中convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。 提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。 设置布局管理器以控制Item的布局方式，横向、竖向以及瀑布流方式 例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还StaggeredGridLayoutManager等)。也就是说RecyclerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。 可设置Item的间隔样式（可绘制） 通过继承RecyclerView的ItemDecoration这个类，然后针对自己的业务需求去书写代码。 可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。 但是关于Item的点击和长按事件，需要用户自己去实现。 基本使用123456789101112recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this ); //设置布局管理器 recyclerView.setLayoutManager(layoutManager); //设置为垂直布局，这也是默认的 layoutManager.setOrientation(OrientationHelper. VERTICAL); //设置Adapter recyclerView.setAdapter(recycleAdapter); //设置分隔线 recyclerView.addItemDecoration( new DividerGridItemDecoration(this )); //设置增加或删除条目的动画 recyclerView.setItemAnimator( new DefaultItemAnimator()); 在使用RecyclerView时候，必须指定一个适配器Adapter和一个布局管理器LayoutManager。适配器继承RecyclerView.Adapter类，具体实现类似ListView的适配器，取决于数据信息以及展示的UI。布局管理器用于确定RecyclerView中Item的展示方式以及决定何时复用已经不可见的Item，避免重复创建以及执行高成本的findViewById()方法。 可以看见RecyclerView相比ListView会多出许多操作，这也是RecyclerView灵活的地方，它将许多动能暴露出来，用户可以选择性的自定义属性以满足需求。 基本使用引用在build.gradle文件中引入该类。 1compile &apos;com.android.support:recyclerview-v7:23.4.0&apos; 布局Activity布局文件activity_rv.xml … Item的布局文件item_1.xml … 创建适配器标准实现步骤如下： ① 创建Adapter：创建一个继承RecyclerView.Adapter的Adapter类（VH是ViewHolder的类名） ② 创建ViewHolder：在Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，记为VH。ViewHolder的实现和ListView的ViewHolder实现几乎一样。 ③ 在Adapter中实现3个方法： onCreateViewHolder()这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。 需要注意的是在onCreateViewHolder()中，映射Layout必须为 1View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false); 而不能是： 1View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, null); onBindViewHolder()这个方法主要用于适配渲染数据到View中。方法提供给你了一viewHolder而不是原来的convertView。 getItemCount()这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。 可以看出，RecyclerView将ListView中getView()的功能拆分成了onCreateViewHolder()和onBindViewHolder()。 基本的Adapter实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940// ① 创建Adapterpublic class NormalAdapter extends RecyclerView.Adapter&lt;NormalAdapter.VH&gt;&#123; //② 创建ViewHolder public static class VH extends RecyclerView.ViewHolder&#123; public final TextView title; public VH(View v) &#123; super(v); title = (TextView) v.findViewById(R.id.title); &#125; &#125; private List&lt;String&gt; mDatas; public NormalAdapter(List&lt;String&gt; data) &#123; this.mDatas = data; &#125; //③ 在Adapter中实现3个方法 @Override public void onBindViewHolder(VH holder, int position) &#123; holder.title.setText(mDatas.get(position)); holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //item 点击事件 &#125; &#125;); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; @Override public VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; //LayoutInflater.from指定写法 View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false); return new VH(v); &#125;&#125; 设置RecyclerView创建完Adapter，接着对RecyclerView进行设置，一般来说，需要为RecyclerView进行四大设置，也就是后文说的四大组成： Layout Manager(必选) Adapter(必选) Item Decoration(可选，默认为空) Item Animator(可选，默认为DefaultItemAnimator) 如果要实现ListView的效果，只需要设置Adapter和Layout Manager，如下： 1234List&lt;String&gt; data = initData();RecyclerView rv = (RecyclerView) findViewById(R.id.rv);rv.setLayoutManager(new LinearLayoutManager(this));rv.setAdapter(new NormalAdapter(data)); 四大组成RecyclerView的四大组成是： Layout Manager：Item的布局。 Adapter：为Item提供数据。 Item Decoration：Item之间的Divider。 Item Animator：添加、删除Item动画。 Layout Manager布局管理器在最开始就提到，RecyclerView 能够支持各种各样的布局效果，这是 ListView 所不具有的功能，那么这个功能如何实现的呢？其核心关键在于 RecyclerView.LayoutManager 类中。从前面的基础使用可以看到，RecyclerView 在使用过程中要比 ListView 多一个 setLayoutManager 步骤，这个 LayoutManager 就是用于控制我们 RecyclerView 最终的展示效果的。 LayoutManager负责RecyclerView的布局，其中包含了Item View的获取与回收。 RecyclerView提供了三种布局管理器： LinerLayoutManager 以垂直或者水平列表方式展示Item GridLayoutManager 以网格方式展示Item StaggeredGridLayoutManager 以瀑布流方式展示Item 如果你想用 RecyclerView 来实现自己自定义效果，则应该去继承实现自己的 LayoutManager，并重写相应的方法，而不应该想着去改写 RecyclerView。 LayoutManager 常见 API关于 LayoutManager 的使用有下面一些常见的 API（有些在 LayoutManager 实现的子类中） 123456789101112canScrollHorizontally();//能否横向滚动canScrollVertically();//能否纵向滚动scrollToPosition(int position);//滚动到指定位置setOrientation(int orientation);//设置滚动的方向getOrientation();//获取滚动方向findViewByPosition(int position);//获取指定位置的Item ViewfindFirstCompletelyVisibleItemPosition();//获取第一个完全可见的Item位置findFirstVisibleItemPosition();//获取第一个可见Item的位置findLastCompletelyVisibleItemPosition();//获取最后一个完全可见的Item位置findLastVisibleItemPosition();//获取最后一个可见Item的位置 上面仅仅是列出一些常用的 API 而已，更多的 API 可以查看官方文档，通常你想用 RecyclerView 实现某种效果，例如指定滚动到某个 Item 位置，但是你在 RecyclerView 中又找不到可以调用的 API 时，就可以跑到 LayoutManager 的文档去看看，基本都在那里。 另外还有一点关于瀑布流布局效果 StaggeredGridLayoutManager 想说的，看到网上有些文章写的示例代码，在设置了 StaggeredGridLayoutManager 后仍要去 Adapter 中动态设置 View 的高度，才能实现瀑布流，这种做法是完全错误的，之所以 StaggeredGridLayoutManager 的瀑布流效果出不来，基本是 item 布局的 xml 问题以及数据问题导致。如果要在 Adapter 中设置 View 的高度，则完全违背了 LayoutManager 的设计理念了。 LinearLayoutManager源码分析 这里我们简单分析LinearLayoutManager的实现。 对于LinearLayoutManager来说，比较重要的几个方法有： onLayoutChildren(): 对RecyclerView进行布局的入口方法。 fill(): 负责填充RecyclerView。 scrollVerticallyBy():根据手指的移动滑动一定距离，并调用fill()填充。 canScrollVertically()或canScrollHorizontally(): 判断是否支持纵向滑动或横向滑动。 onLayoutChildren()的核心实现如下： 1234public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; detachAndScrapAttachedViews(recycler); //将原来所有的Item View全部放到Recycler的Scrap Heap或Recycle Pool fill(recycler, mLayoutState, state, false); //填充现在所有的Item View&#125; RecyclerView的回收机制有个重要的概念，即将回收站分为Scrap Heap和Recycle Pool，其中Scrap Heap的元素可以被直接复用，而不需要调用onBindViewHolder()。detachAndScrapAttachedViews()会根据情况，将原来的Item View放入Scrap Heap或Recycle Pool，从而在复用时提升效率。 fill()是对剩余空间不断地调用layoutChunk()，直到填充完为止。layoutChunk()的核心实现如下： 123456public void layoutChunk() &#123; View view = layoutState.next(recycler); //调用了getViewForPosition() addView(view); //加入View measureChildWithMargins(view, 0, 0); //计算View的大小 layoutDecoratedWithMargins(view, left, top, right, bottom); //布局View&#125; 其中next()调用了getViewForPosition(currentPosition)，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，在后文的回收机制中会介绍该方法的具体实现。 如果要自定义LayoutManager，可以参考： 创建一个 RecyclerView LayoutManager – Part 1 创建一个 RecyclerView LayoutManager – Part 2 创建一个 RecyclerView LayoutManager – Part 3 Adapter适配器Adapter的使用方式前面已经介绍了，功能就是为RecyclerView提供数据，这里主要介绍万能适配器的实现。其实万能适配器的概念在ListView就已经存在了，即base-adapter-helper。 这里我们只针对RecyclerView，聊聊万能适配器出现的原因。为了创建一个RecyclerView的Adapter，每次我们都需要去做重复劳动，包括重写onCreateViewHolder(),getItemCount()、创建ViewHolder，并且实现过程大同小异，因此万能适配器出现了。 万能适配器这里讲解下万能适配器的实现思路。 我们通过public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;定义万能适配器QuickAdapter类，T是列表数据中每个元素的类型，QuickAdapter.VH是QuickAdapter的ViewHolder实现类，称为万能ViewHolder。 首先介绍QuickAdapter.VH的实现： 1234567891011121314151617181920212223242526272829static class VH extends RecyclerView.ViewHolder&#123; private SparseArray&lt;View&gt; mViews; private View mConvertView; private VH(View v)&#123; super(v); mConvertView = v; mViews = new SparseArray&lt;&gt;(); &#125; public static VH get(ViewGroup parent, int layoutId)&#123; View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false); return new VH(convertView); &#125; public &lt;T extends View&gt; T getView(int id)&#123; View v = mViews.get(id); if(v == null)&#123; v = mConvertView.findViewById(id); mViews.put(id, v); &#125; return (T)v; &#125; public void setText(int id, String value)&#123; TextView view = getView(id); view.setText(value); &#125;&#125; 其中的关键点在于通过SparseArray&lt;View&gt;存储item view的控件，getView(int id)的功能就是通过id获得对应的View（首先在mViews中查询是否存在，如果没有，那么findViewById()并放入mViews中，避免下次再执行findViewById()）。 QuickAdapter的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;&#123; private List&lt;T&gt; mDatas; public QuickAdapter(List&lt;T&gt; datas)&#123; this.mDatas = datas; &#125; public abstract int getLayoutId(int viewType); @Override public VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; return VH.get(parent,getLayoutId(viewType)); &#125; @Override public void onBindViewHolder(VH holder, int position) &#123; convert(holder, mDatas.get(position), position); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; public abstract void convert(VH holder, T data, int position); static class VH extends RecyclerView.ViewHolder&#123; private SparseArray&lt;View&gt; mViews; private View mConvertView; private VH(View v)&#123; super(v); mConvertView = v; mViews = new SparseArray&lt;&gt;(); &#125; public static VH get(ViewGroup parent, int layoutId)&#123; View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false); return new VH(convertView); &#125; public &lt;T extends View&gt; T getView(int id)&#123; View v = mViews.get(id); if(v == null)&#123; v = mConvertView.findViewById(id); mViews.put(id, v); &#125; return (T)v; &#125; public void setText(int id, String value)&#123; TextView view = getView(id); view.setText(value); &#125; &#125;&#125; 其中： getLayoutId(int viewType)是根据viewType返回布局ID。 convert()做具体的bind操作。 就这样，万能适配器实现完成了。 通过万能适配器能通过以下方式快捷地创建一个Adapter： 123456789101112mAdapter = new QuickAdapter&lt;String&gt;(data) &#123; @Override public int getLayoutId(int viewType) &#123; return R.layout.item; &#125; @Override public void convert(VH holder, String data, int position) &#123; holder.setText(R.id.text, data); //holder.itemView.setOnClickListener(); 此处还可以添加点击事件 &#125;&#125;; 是不是很方便。当然复杂情况也可以轻松解决。 123456789101112131415161718192021222324252627282930313233mAdapter = new QuickAdapter&lt;Model&gt;(data) &#123; @Override public int getLayoutId(int viewType) &#123; switch(viewType)&#123; case TYPE_1: return R.layout.item_1; case TYPE_2: return R.layout.item_2; &#125; &#125; @Override public int getItemViewType(int position) &#123; if(position % 2 == 0)&#123; return TYPE_1; &#125; else&#123; return TYPE_2; &#125; &#125; @Override public void convert(VH holder, Model data, int position) &#123; int type = getItemViewType(position); switch(type)&#123; case TYPE_1: holder.setText(R.id.text, data.text); break; case TYPE_2: holder.setImage(R.id.image, data.image); break; &#125; &#125;&#125;; 结论 在一些场景下，如界面初始化，滑动等，ListView和RecyclerView都能很好地工作，两者并没有很大的差异： 数据源频繁更新的场景，如弹幕：http://www.jianshu.com/p/2232a63442d6等RecyclerView的优势会非常明显； 进一步来讲，结论是： 列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。 扩展阅读 Google I/O 2016: RecyclerView Ins and Outs RecyclerView优秀文章集 引用： ★★★★RecyclerView 必知必会 ★★★★Android ListView 与 RecyclerView 对比浅析–缓存机制 ★★★RecyclerView使用完全指南，是时候体验新控件了（一） ★★★RecyclerView使用完全指南，是时候体验新控件了（二） 一篇博客理解Recyclerview的使用 RecyclerView使用全解析 Demo地址： RecyclerView基本用法 RecyclerViewDemo Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。 Demo2: ListView实现局部刷新。 Demo3: RecyclerView实现拖拽、侧滑删除。 Demo4: RecyclerView闪屏问题。 Demo5: RecyclerView实现setEmptyView()。 Demo6: RecyclerView实现万能适配器，瀑布流布局，嵌套滑动机制。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向忙碌开发者的Android]]></title>
    <url>%2Fposts%2F793c26e.html</url>
    <content type="text"><![CDATA[面向忙碌开发者的 Android 视频教程（Tuts+） Android 开发资源列表（Sharif Ahmed） 我如何在23天内开发了一款 Android 游戏？（Bigosaur） Android 学习教程 Android Bootstrap [PDF] Android 性能小贴士（Romain Guy &amp; Chet Haase） [PDF] Android 应用中使用 Dagger（Jake Wharton） Android 应用性能优化 《Android 测试与调试实战》参考资料（@施懿民） [视频] Android 入门教程（@多贝公开课） Android 测试入门（Corey Scott） Android 事件传递机制（@唐韧_Ryan） [PDF] Android 开发技巧新整理（@51CTO技术社区） AndroidQuery - 一个处理异步任务的开源项目（Peter Liu） Android 开发者必备的42个链接（Mikail） 一些有用的 Android adb 命令（Daniel Imms） Android 布局优化（@唐韧_Ryan） 系列文章：前端之 Android 入门 (ct) Android 设计指南非官方简体中文版 系列教程：开发你的第一个 Android 应用 (Matt Luedke) 写给 iOS 开发者的 Android 教程 (Stuart Hall) [slide] Android 函数响应式编程 (Yaroslav Heriatovych) 面向 iOS 开发者的 Android 系列教程 [译] Android 通知中心（@唯木念） 使用 Android API 最佳实践 (MeetMe) 《50 Android Hacks》读书笔记 (Vector_Yi) [译] 响应式 Android 应用 (Daisyyaya) Android 开源项目分类汇总 (@Trinea) 系列文章：Android 开发小贴士 (Dan Lew) Android Arsenal - 一个 Android 学习资源网站 [译] Android 开发者必知的 5 个开源库（刘璐璐） SEAndroid 安全机制简要介绍和学习计划（@罗升阳） Material Design 中文版 Android 学习之路 (@googdev) SEAndroid 安全机制对 Binder IPC 的保护分析（罗升阳） 最流行的 Android 组件大全 (@colobu) [译] 2014 年 Android 碎片化报告 (boxi) 系列文章：Android UI 开发（@张兴业TBOW） Android 插件化 (@Trinea) [代码] 模仿 QQ 讨论组头像（@网易孔楠） Android 中 Java 和 JavaScript 交互 (androidyue) [视频合辑] 3 个月系统学习 Android 开发（极客学院） 正确使用 Android 性能分析工具——TraceView (@白瓦力) [译] 理解 Android 中垃圾回收日志信息 (@Android月) 放弃 WebView，使用 Crosswalk 做富文本编辑器 (GavinCT) 教你用 Visual Studio 2015 做 Android 应用 十大 Material Design 开源项目 (唐小引) Android Studio 系列教程 (@googdev) 创新、严肃、好玩的 Android 应用程序开发 Android 批量打包提速 (@GavinCT) 学 Android 开发仅用 3 个月，就是这么任性！ 代码规范和 Android 项目中的一些可用工具 (刘聪) 学 Android 开发仅用 3 个月，就是这么任性！ [译] Android 性能优化课程（一）：渲染性能 (@刘智勇同学) Java for Android Android 性能优化典范 (@胡凯me) Context-Menu.Android - Android 动画上下文菜单 (Yalantis) 大量 Material Design 学习资源 (@light_sky) 系列文章：50 个 Android 开发技巧 (fwy19930618) Android 开发教程大全（视频 + 源码） Android 开源项目源码解析 (android-cn) 深聊 Material Design 复杂响应式设计 Navigation drawer - 一个 Material Design 的抽屉式导航库 (Rudson Lima) Android 开发最佳实践 使用 Chrome 调试 Android App (@googdev) [译] 一次 Material Design 的设计探索 (郭楠) 系列文章：全面理解 Android 安全机制 (@stackvoid) [译] 关于 Material Design 你需要知道的一切 (DATS设计翻译组) Android 源码设计模式分析 (@MrSimp1e) [译] Android xUtils 源码解析 (@code-KK) [译] Android 性能优化后续 (@高建武_Gracker) 开源 Android 应用集锦 (Joker) Fresco - 一个强大的 Android 应用图片管理库 (Facebook) Euclid - 一个用户 Profile 界面动画的 Android 实现 (Yalantis) [译] 使用 Kotlin 创建一个 Android 应用 (Lollypo) 系列文章：Android 内存优化 (@高建武_Gracker) 深入理解 Android 中的自定义属性 (鸿洋_) Android 性能优化之内存篇 (@胡凯me) 一堆 Android 开发资源链接 (Anirudh S) 《Android 开发学习路径图》2.0 版 [译] Android Lollipop 5.1.1 面世 (@MrSimp1e) [译] Instagram 是如何提升 TextView 渲染性能的？ (@archieyang) Android 应用内社区 SDK 技术架构浅析 (liubin) Android 性能优化典范（第 2 季） (@胡凯me) 系列译文：Android 的 MVP 模式开发 (shadev) 一个 Mac 上的 Android 工具 (mortenjust) SquiDB - 一个用于 Android 的 SQLite 数据库框架 系列译文：Android 研发工程师高级进阶 (asce1885) Android 加载不同 DPI 资源与内存消耗之间的关系 (Will) MaterialViewPager - 一个易于使用的 Material Design ViewPager 库 (florent37) Android RecyclerView 使用完全解析 (鸿洋_) Android 中的 MVP (@鄭曉鵬-Rocko) Material 适配（二）：高级篇 (@GavinCT) Anko - 一个让 Android 应用开发更快、更简单的库 Android 开发中，可能会导致内存泄露的问题 (@给立乐) Android 布局优化之 ViewStub、include、merge 使用与源码分析 (@MrSimp1e) 腾讯手机管家 Android 版实战分析：内存突增是为神马？ (腾讯Bugly) 大量 Material Design 学习资源 (@light_sky) Google I/O 2015 为 Android 开发者带来了哪些福利？ (代码家) 系列文章：Android 内核开发之系统编译输出的镜像文件 (@卢_俊) [译] MVP 框架 Ted Mosby 的软件架构（Android） (@MrSimp1e) FlyRefresh：超赞的刷新动画（Android） (@谢权1991) Android 系统架构之微服务架构 (MrSimple) Android 异步指南 (@alexhilton) Gradle Android Plugin 使用手册（中文版） (@ChaosLeong) Android 开发教程大全（视频 + 源码） [译] Material Design 开发利器：Android Design Support Library 介绍 Android UITestRunner - 一个非常简单的用于测试 UI 的单元测试框架 (chengkai) FlyRefresh：让人眼前一亮的下拉刷新 (Android笔记) 浅谈 MVP 实现 Android 应用层开发 (工匠若水) 教你写 Android 网络框架之基本架构 (@MrSimp1e) Android 实现速度仪，仪表盘效果 (谢权1991) Android Studio 新手完全指引 (ASCE1885) 教你写 Android 网络框架之 HTTP 请求的分发与执行 (@MrSimp1e) 美团 Android DEX 自动拆包及动态加载简介 (xijianshuai &amp; lixiaoyang) 短信验证码助手：一款新的开源轻 App（Android） (Dracut) SublimePicker：Android Material 风格时间选择器 (vikramkakkar) 使用 Kotlin 进行 Android 开发 (@RagnarokStack) Android 应用程序 UI 硬件加速渲染的动画执行过程分析 (@罗升阳) [译] Android 开发最佳实践 (andyiac) [译] Android Design Support Library 的代码实验 (MrFu) Android 开源项目源码解析（第二期） (@code-KK) [译] Android 中的帧动画 (jianghejie) 推荐几个有用的 Android Studio 插件和工具 (@googdev) Dexposed：阿里巴巴开源的无侵入运行期 AOP 框架（Android） 小米开源的内核源代码 很棒的下拉刷新项目 Android Ultra Pull To Refresh 源码解析 (grumoon) Android 应用使用自定义字体的一些探究 (@码农明明桑) 一个 Demo 学会用 Android 兼容包新控件 (@安卓猴) Android 常用开发工具以及 Mac 常用软件 (肥肥鱼) DynamicLoadApk 源码解析 (code-KK) InstalMaterial 学习笔记之 Reveal 效果 (程序亦非猿) 快速提高 Android 开发效率的 Web 工具 (@技术小黑屋) [译] Android UI 自动化测试 (DorisMinmin) 系列译文：使用 Kotlin 开发 Android 应用 (ASCE1885) 使用 Gradle 管理你的 Android Studio 工程 (飞雪无情) [译] 学习 Android 开发的二十套免费理想资源 (核子可乐) HTTPDNSLib - 一个支持 DNSPod D+ 和自定义 HttpDNS 服务的 HttpDNS SDK（Android） (SinaMSRE) 一个优秀的 Android 应用从建项目开始 (Jude95) [译] 检测和解决 Android 应用的性能问题 (@MrSimp1e) Android 中 TextView 预渲染研究 (RagnarokStack) Android 开发者的浏览器书签 (鄭曉鵬-Rocko) Android 代码内存优化建议：OnTrimMemory 优化 (Android Performance) Android APK 加固技术方案调研 (ASCE1885) 使用 Android lint 发现并解决高版本 API 问题 (技术小黑屋) Smalidea 无源码调试 Android 应用 (瘦蛟舞) 如果让我重新设计一款 Android App (aspook) 探究 android:largeHeap (技术小黑屋) 跟我一起写 EventBus（一） (mcxiaoke) 一步一步教你 150 行代码实现简书滑动返回效果 (程序亦非猿) Android Material Design 动画实现 (阳春面) Android Gradle 插件中文指南 (飞雪无情) Android 多渠道打包工具 Gradle 插件 (mcxiaoke) AWebDB 可以在浏览器操作 Android 数据库啦 (Bai) 一个上传 APK 到 fir 的 Gradle 插件 (码农明明桑) Cool Android Apis 整理（一） (@Oak_Zmm) Android 应用开发之所有动画使用详解 (@工匠若水) Android 视频录制 App 解决方案汇总 (老牛) 5 种优化你的 Android 5.0 Lollipop 代码的方法 Android 项目中如何用好构建神器 Gradle？ (寒江不钓) 通过蓝牙* LE (BLE) 从 Android 连接到英特尔 EDISON Android 平台免 Root 无侵入 AOP 框架 Dexposed 使用详解 (ASCE1885) BatchPackApk：Apk 批量快速打包工具 (MasonLiuChn) SlideBottomPanel：底部划出视图，轻松实现“知乎日报 β 版”效果 (NeXT___) CNode 社区第三方 Android 客户端 (TakWolf) 开源中国 Maven 库 一个超赞超全的 Android Library (Huqiu Liao) Android 性能优化典范（第 3 季） (@胡凯me) 最美应用：从 Android 研发工程师的角度之“厨房故事” (ASCE1885) [译] 深入讲解 Android 中 Activity launchMode (技术小黑屋) [译] Android 中的 AOP 编程 (byronwind) 面向 Android* 目标的英特尔 INDE OpenCV 入门 Android 技术文档翻译：工具属性 (飞雪无情) Jenkin + Git + Gradle 为 Android 项目搭建 CI 环境 (离星运动) Google Places for Android 入门指南 (@汤奇V) [英] Parse 开源其所有 SDK（Android &amp; iOS） (Nikita Lutsenko) xBus 使用指南 (mcxiaoke) LayoutCast：把代码和资源文件的改动直接同步到手机上，应用不需要重启 (mmin18) Android 6.0 中新的新技术 (@Android笔记) Android 诀窍：Layouts 与 Views (llitfk@DockOne) Android NestedScrolling 实战 (Android笔记) Android 反编译的工具和方法 (@杨剑同學) Next 库使用指南之 Core 模块（Android） (mcxiaoke) [译] CoordinatorLayout 与快速返回的实现（Android） (hejie) SimpleCropView - 一个简单的图片剪裁库（Android） (IsseiAoki) TransitionPlayer - 一个 Android 引导动画库 (XMFE-TEAM) 微信 Android 客户端：会话速度提升 70% 的背后 (charven) [译] 使用 TDD 的方式开发一个 Hacker News Android 客户端 (Anthonyeef) 改变 support 中 AlertDialog 的样式（Android） (码农明明桑) 为什么 Android 中不建议使用 Enums (Lusfold) Android 逆向工程工具集 (J.D.Song) DroidPlugin：360 手机助手在 Android 系统上实现的一种新的插件机制 (Qihoo360) Android Log 最佳实践 (@天之界线2010) 剖析 Android 中进程与线程调度之 nice (技术小黑屋) Android OkHttp 文件上传与下载的进度监听扩展 (lizhangqu) 基于英特尔架构使用 Linderdaum* 引擎开发 C++ 安卓* NDK 游戏 (英特尔开发人员专区) 全平台反编译工具 Jadx (程序亦非猿) 积木：帮助你快速搭建属于自己的应用 (汤奇V) Android Tips：填坑必备 (汤奇V) React Native for Android on GitHub (Facebook) Android 图标资源生成器 (JuneLegency) XLog：Android 调试神器 (promeG) DecompileApk：一键反编译 APK，输出所有反编译后的代码、资源 (MasonLiuChn) Colorful：基于 Theme 的 Android 动态换肤库 (@MrSimp1e) Otto 事件总线框架的使用 (Sunzxyong) React Native For Android 初体验 (ASCE1885) Android 进程线程调度之 cgroups (技术小黑屋) Gradle 多渠道打包 (安卓猴) Android 项目收集 (snowdream) Android 性能优化视频、文档和工具收集 (J.D.Song) [译] Retrofit 2.0：有史以来最大的改进 (hejie) 深入讲解 WebView（上） (张涛) [译] Android 6.0 新特性详解（运行时权限、存储、电源管理） (黑山龘) Android 开发最佳实践 (@胡凯me) AndroidCat：Android 开发相关的网址导航 (大花猫) Android 仿搜狗浏览器加载动画 (@_邓士伟) StatusBarColor：Android 4.4+ 设置状态栏、导航栏颜色、侧滑菜单沉浸 (MasonLiuChn) KJBitmap 与 KJHttp 的深度用法 (张涛) App 启动加速，以及使用 FSA 来处理状态转换避免 Activity State Loss (Piasy) RecyclerView 的通用适配器，和滚动时不加载图片的封装 (张涛) Android GC 那点事 Android 性能优化学习小结 Android 6.0 Runtime Permission 测试 一步一步带你仿各大主流 App 地图定位移动选址功能（Android） KJFrameForAndroid 2.25 发布，支持 6.0 网络请求 很少有人会告诉你的 Android 开发基本常识 Android Handler 消息机制的理解 Android UI：机智的远程动态更新策略 Android 快速开发框架 FastDev4Android 介绍（一） [译] Android 架构演化之路 Android 项目重构之路（架构篇） Android 开发中，有哪些坑需要注意？ [译] 通过 Hardware Layer 提升 Android 动画性能 关于 Android Log 的一些思考 Android Support Library 23.1 的变化 AVLoadingIndicatorView：Android 加载动画合集 移植 C 程序到 Android MVVM_Android-CleanArchitecture Android 打包的那些事 Android 6.0 运行时权限处理 TextViewForFullHtml：对原生 TextView 解析 HTML 格式文本的增强 DynamicAPK：携程 App 的插件化和动态加载框架 #Kotlin# 你好怪兽 TraceView 自动化抓取方案实践 InteractiveCanvas：炫酷的跨屏幕 Canvas 动画 Android 快捷方式解密 Android 微信上的 Wear 的开发总结 Android 分辨率相关知识 Android 热更新实现原理 如何姿势正确地做一个充满果味的 Android 应用 再议携程 Android 动态加载框架 DynamicAPK Treasure - 一个 Android 平台上基于 SharePreferences 的偏好存储库 Nuwa：热修复你的 Android 应用 EasyImage：Android 图片选择控件 [译] 掌握 Coordinator Layout BlurImageView：实现类 Medium 的图片加载 天猫 Android App 线上热修复方案 Andriod 性能优化之列表卡顿：以“简书” APP 为例 AndroidAutoLayout：Android 屏幕适配方案 WXTabBarController：实现 Android 版微信 TabBar 的滑动切换功能（OC） EZScalpel：Android 视图层级查看利器 实践自定义 UI：RLF Backboard - 一个基于 Facebook Rebound 的动效框架 加快 Android 编译速度 如何开发一个 Android App dex 分包变形记 面向对象六大原则 1000 个 Android 开源项目集合 Gradle 脚本基础全攻略 stetho-js-rhino：Facebook Stetho 插件，为 Android 提供 JavaScript 调试窗口 记一次 ListView 性能优化过程 XhsParallaxWelcome：小红书欢迎引导页实现（第二版） 微信抢红包插件源码解析（Android） [译] 每个 Android 开发者都应该了解的资源列表 Android 图片选择器 OverscrollScale：仿小米列表拉伸效果（Android） [译] 使用 Systrace 分析 UI 性能 [译] 开发安全的 Android 应用 说说 Android 的 MVP 模式 面试时，问哪些问题能试出一个 Android 应用开发者真正的水平？ 动态 Android 编程 EventBus 源码研读（上） 使用 Picasso 加载图片的内存优化实践 高仿微信 JustWeEngine：Android 轻量级游戏框架 Android 下拉刷新开源库对比 Android View 总结 关于 Android 中工作者线程的思考 Android 6.0 系统学习之 JNI Android Studio 你不知道的调试技巧 Android 开发者站点资源 [PDF] 深入理解 Android 之 Dalvik Android 代码质量检查利器 用黑客思维做测试：神器 Xposed 框架介绍 Android 单元测试研究与实践 构建更高质量的 Android 应用：2015 Playtime 之 Build Better 2015 年十大热门 Android 开源新项目 Android 软键盘和 emoji 表情切换方案 PeriscopeLayout - 一个类似 Android Periscope 点赞效果的 Layout HTextView：Android TextView 动画效果 值得推荐的 Android 应用性能检测工具列表 Android 生态的破与立 AndResGuard：微信的 Android 资源混淆方案 GalleryFinal：史上最强的图片选择器（Android） Android 性能优化典范 Android targetSdkVersion 原理 Android Linker 学习笔记 Android 应用开发架构概述 [译] Android UI 性能优化详解 Android 平台的崩溃捕获机制及实现 Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？ BasePedo - 一个稳定的 Android 计步源代码 一个非官方版的干净的 “ONE • 一个” BrokenView：玻璃破碎的效果（Android） Small：强大的轻量级 Android 插件框架 Binder 学习指南]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xBus-简洁的EventBus实现]]></title>
    <url>%2Fposts%2F9105b80c.html</url>
    <content type="text"><![CDATA[Demo地址：MyXBus 基于发布订阅(Pub/Sub)模式的一个事件消息库，使用通用的 register(target), unregister(target), post(event) 消息通信接口，能有效的减少甚至消除Android应用中异步任务逻辑和界面更新之间的耦合，实现模块化，提高开发效率。 2015.09.15 1.0.2 - 修复多线程发送事件的同步问题 2015.08.18 1.0.1 - 修复 unresiger() 的空指针问题 2015.08.08 1.0.0 - 基本功能全部完成，发布1.0.0正式版 使用指南Gradle集成1compile &apos;com.mcxiaoke.xbus:bus:1.0.+&apos; 接收事件123456789101112131415161718192021222324252627282930313233343536public class SimpleActivity extends Activity &#123; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 注册 Bus.getDefault().register(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消注册 Bus.getDefault().unregister(this); &#125; @BusReceiver public void onStringEvent(String event) &#123; // handle your event // 这里处理事件 &#125; @BusReceiver public void onSomeEvent(SomeEventClass event) &#123; // SomeEventClass表示任意的自定义类 // handle your event // 这里处理事件 &#125; @BusReceiver public void onObjectEvent(Object event) &#123; // 不建议使用Object，会收到所有类型的事件 // handle your event // 这里处理事件 &#125;&#125; 发送事件然后在需要的地方调用 post(event) 发送事件通知，如 Service 或某个线程里，可以在任何地方发送事件： 123456789101112131415// 比如在IntentService里public class SimpleService extends IntentService &#123; public SimpleService() &#123; super("SimpleService"); &#125; @Override protected void onHandleIntent(final Intent intent) &#123; // 这里是举例，可以在任何地方发送事件 Bus.getDefault().post("String Event"); Bus.getDefault().post(new SomeEventClass()); Bus.getDefault().post(new Object()); &#125;&#125; 高级用法任何地方注册你还可以选择在 onStart() 里注册，在 onStop() 里取消注册。你完全可以在任何地方注册和取消注册，没有任何限制。但是建议你在生命周期事件方法里注册和取消注册，如 Activity/Fragment/Service 的 onCreate/onDestroy 方法里， register() 和 unregister() 建议配对使用，避免内存泄露。 12345678910111213@Overrideprotected void onStart() &#123; super.onStart(); // you can also register here Bus.getDefault().register(this);&#125;@Overrideprotected void onStop() &#123; super.onStop(); // you can also unregister here Bus.getDefault().unregister(this);&#125; 自定义 Bus你也可以不使用默认的 Bus.getDefault()，改用自己创建的 Bus 对象： 12345678910111213public class MainApp extends Application &#123; private Bus mBus = new Bus(); @Override public void onCreate() &#123; super.onCreate(); &#125; public Bus getBus() &#123; return mBus; &#125;&#125; Debug默认不输出任何LOG信息，可以这样启用调试模式： 1public Bus setDebug(final boolean debug) MethodFinder默认使用注解(@BusReceiver)识别事件接收器方法，可以这样修改 ： 1public Bus setMethodFinder(final MethodFinder finder) 默认使用的是 AnnotationMethodFinder，只有使用了 @BusReceiver 的方法才可以接受事件。 可选使用 NamedMethodFinder ，NamedMethodFinder 使用方法名识别，默认方法名是 onEvent ，你可以指定其它的方法名。 使用 NamedMethodFinder 会比使用 AnnotationMethodFinder 效率高一点，因为它忽略注解，直接使用方法名字符串匹配。一般使用，两者差别不大。 你还可以实现 MethodFinder 接口，自定义其它的事件接收器方法匹配模式： 1234interface MethodFinder &#123; Set&lt;MethodInfo&gt; find(final Bus bus, final Class&lt;?&gt; targetClass);&#125; StrictMode宽泛匹配模式默认情况下， Bus 使用宽泛的事件类型匹配模式，事件参数会匹配它的父类和接口，如果你调用 post(String)，那么这几个方法都会收到举例： 123456789101112// 如果你调用这个方法，发送一个StringBuilder类型的事件Bus.getDefault().post(new StringBuilder("Event"));// 这几个方法会收到事件public void onEvent1(StringBuilder event) // 匹配，类型相符public void onEvent2(Object event) // 匹配，StringBuilder是Object的子类public void onEvent3(CharSequence event) // 匹配，StringBuilder是CharSequence的实现类public void onEvent4(Serializable event) // 匹配，StringBuilder实现了Serializable接口// 这几个方法不会收到事件public void onEvent5(Exception event) 不匹配，Exception与String完全无关public void onEvent6(String event) // 不匹配，StringBuilder不能转换成String类型 对于 post(event) 和 onEvent(EventType) ，匹配规则是：如果 event.getClass() 可以强制转换成 EventType，那么匹配成功，能收到事件。 严格匹配模式可以使用下面的方法更改默认行为，使用严格的事件类型匹配模式： 1public Bus setStrictMode(final boolean strictMode) 启用严格匹配模式后，发送和接受方法的参数类型必须严格匹配才能收到事件，举例： 123456789// setStrictMode(true) 启用严格模式后：Bus.getDefault().post(new StringBuilder("Event"));// 只有 onEvent1 能收到事件public void onEvent1(StringBuilder event)public void onEvent2(Object event)public void onEvent3(CharSequence event)public void onEvent4(Serializable event)public void onEvent5(Exception event)public void onEvent6(String event) 对于 post(event) 和 onEvent(EventType) ，严格模式的匹配规则是当且仅当 event.getClass().equals(EventType) 时才能收到事件。 说明：启用严格模式效率会稍微高一点，因为不会递归查找 event 的父类和实现的接口，但是由于 Bus 内部使用了缓存，对于同一个事件类型，并不会重复查找，所以实际使用几乎没有差别。 StickyEvent可以使用下面的方法发送 Sticky 事件，这种事件会保留在内存中，当下一个注册者注册时，会立即收到上一次发送的该类型事件，每种类型的事件只会保留一个， Sticky 事件使用严格匹配模式。 1public &lt;E&gt; void postSticky(E event) 一般不需要使用 Sticky 事件，但在某些场景下可以用到，比如一个网络状态监听服务，会不断的发送网络状态信息，接受者一旦注册就可以立即收到一个事件，可以知道当前的网络状态。 @BusEvent还有一个注解 @BusEvent 可用于标注某个类是事件类，这个像 @Override 注解一样，纯标注用，没有其它用途，没有运行时消耗。 实现教程 跟我一起写EventBus（一） 跟我一起写EventBus（二） 跟我一起写EventBus（三） 跟我一起写EventBus（四） xBus使用教程]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>EventBus</tag>
        <tag>XBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android框架之路——EventBus的使用]]></title>
    <url>%2Fposts%2F6037db63.html</url>
    <content type="text"><![CDATA[一、简介EventBus是由greenrobot 组织贡献的一个Android事件发布/订阅轻量级框架。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。 官网地址：http://greenrobot.org/eventbus/翻译：http://blog.csdn.net/poorkick/article/details/55099311 二、添加依赖1compile &apos;org.greenrobot:eventbus:3.0.0&apos; 三、解锁技能 EventBus的三要素 Event：事件，可以是任意类型的对象。 Subscriber：事件订阅者，在EventBus3.0之前消息处理的方法只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，他们分别代表四种线程模型。而在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING）。 Publisher：事件发布者，可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法。可以自己实例化EventBus对象，但一般使用EventBus.getDefault()就好了，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。 EventBus的四种线程模型（ThreadMode） POSTING（默认）：如果使用事件处理函数指定了线程模型为POSTING，那么该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在线程模型为POSTING的事件处理函数中尽量避免执行耗时操作，因为它会阻塞事件的传递，甚至有可能会引起应用程序无响应（ANR）。 MAIN：事件的处理会在UI线程中执行。事件处理时间不能太长，长了会ANR的。 BACKGROUND：如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。在此事件处理函数中禁止进行UI更新操作。 ASYNC：无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行，同样，此事件处理函数中禁止进行UI更新操作。 使用步骤 注册：EventBus.getDefault().register(this); 解注册（为防止内存泄漏）：EventBus.getDefault().unregister(this); 构造发送消息类： 123456789public class MessageEvent &#123; public String name; public String password; public MessageEvent(String name, String password) &#123; this.name = name; this.password = password; &#125;&#125; 发布消息：EventBus.getDefault().post(new MessageEvent(“name”,”password”)); 接收消息：可以有四种线程模型选择 1234@Subscribe(threadMode = ThreadMode.MAIN)public void messageEventBus(MessageEvent event)&#123; tv_result.setText("name:"+event.name+" passwrod:"+event.password);&#125; 粘性事件​ 之前说的使用方法，都是需要先注册(register)，再post,才能接受到事件；如果你使用postSticky发送事件，那么可以不需要先注册，也能接受到事件，也就是一个延迟注册的过程。​ 普通的事件我们通过post发送给EventBus，发送过后之后当前已经订阅过的方法可以收到。但是如果有些事件需要所有订阅了该事件的方法都能执行呢？例如一个Activity，要求它管理的所有Fragment都能执行某一个事件，但是当前我只初始化了3个Fragment，如果这时候通过post发送了事件，那么当前的3个Fragment当然能收到。但是这个时候又初始化了2个Fragment，那么我必须重新发送事件，这两个Fragment才能执行到订阅方法。​ 粘性事件就是为了解决这个问题，通过 postSticky 发送粘性事件，这个事件不会只被消费一次就消失，而是一直存在系统中，知道被 removeStickyEvent 删除掉。那么只要订阅了该粘性事件的所有方法，只要被register 的时候，就会被检测到，并且执行。订阅的方法需要添加 sticky = true 属性。 构造发送信息类： 1234567public class StickyEvent &#123; public String msg; public StickyEvent(String msg) &#123; this.msg = msg; &#125;&#125; 发布消息：EventBus.getDefault().postSticky(new StickyEvent(“我是粘性事件”)); 接收消息：和之前的方法一样，只是多了一个 sticky = true 的属性。 1234@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)public void onEvent(StickyEvent event)&#123; tv_c_result.setText(event.msg);&#125; 注册： 1EventBus.getDefault().register(CActivity.this); 解注册： 12EventBus.getDefault().removeAllStickyEvents();EventBus.getDefault().unregister(CActivity.class); ### 四、举个栗子 主线程发送事件： 自定义事件（类似定义JavaBean），包含用户的姓名和密码； 123456789101112131415161718192021222324252627282930313233343536public class UserEvent &#123; private String name; private String password; public UserEvent() &#123; &#125; public UserEvent(String name, String password) &#123; this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "UserEvent&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 在onCreate方法中注册订阅者，在onDestroy中解注册。 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.jump) Button mJump; @BindView(R.id.send) Button mSend; @BindView(R.id.tv_result) TextView mTvResult; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //注册订阅者 EventBus.getDefault().register(this); &#125; @OnClick(&#123;R.id.jump, R.id.send&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.jump: startActivity(new Intent(MainActivity.this, SecActivity.class)); break; case R.id.send: break; &#125; &#125; //定义处理接收的方法 @Subscribe(threadMode = ThreadMode.MAIN) public void userEventBus(UserEvent userEvent)&#123; mTvResult.setText(userEvent.toString()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //注销注册 EventBus.getDefault().unregister(this); &#125;&#125; 在另一个activity中发送事件，让订阅者能够接收； 123456789101112@OnClick(&#123;R.id.sendData, R.id.receive&#125;)public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.sendData: //发送事件 EventBus.getDefault().post(new UserEvent("Mr.sorrow", "123456")); finish(); break; case R.id.receive: break; &#125;&#125; 实现结果： 发送粘性事件： MainActivity中发送粘性事件； 1234case R.id.send: EventBus.getDefault().postSticky(new MessageEvent("粘性事件", "urgent")); startActivity(new Intent(MainActivity.this, SecActivity.class)); break; SecActivity中接受注册并处理； 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SecActivity extends AppCompatActivity &#123; @BindView(R.id.sendData) Button mSendData; @BindView(R.id.receive) Button mReceive; @BindView(R.id.tv_receive) TextView mTvReceive; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sec); ButterKnife.bind(this); &#125; @OnClick(&#123;R.id.sendData, R.id.receive&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.sendData: //发送事件 EventBus.getDefault().post(new UserEvent("Mr.sorrow", "123456")); finish(); break; case R.id.receive: //要接收时开始注册 EventBus.getDefault().register(SecActivity.this); break; &#125; &#125; //处理事件逻辑 @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) public void receiveEventBus(MessageEvent messageEvent) &#123; mTvReceive.setText(messageEvent.toString()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //解注册 EventBus.getDefault().removeAllStickyEvents(); EventBus.getDefault().unregister(SecActivity.this); &#125;&#125; 实现效果]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用三方框架]]></title>
    <url>%2Fposts%2F4514f8cf.html</url>
    <content type="text"><![CDATA[1.下拉刷新Android-Ptr-Comparison-Android 下拉刷新开源库对比，非常nice！！ Android-PullToRefresh- 最经典、最多人用的下拉刷新、加载更多。 PullDownListView- 一个下拉刷新的控件，实现了仿微信下拉中眼睛动画的效果。 DragTopLayout- 实现整个layout下拉刷新。 ZrcListView- 一个顺滑又漂亮的Android下拉刷新与加载更多列表组件，增加下拉刷新及滚动到底部自动加载的功能；增加越界回弹效果；增加自定义列表项动画的功能。 TwitterCover-Android- Twitter Android客户端的下拉封面模糊效果。 android-Ultra-Pull-To-Refresh- 实现整个layout下拉刷新，没有加载更过，Demo，源码分析。 StikkyHeader- 【Android控件源码：头部固定的控件列表效果】这是一个可以支持头部固定的控件列表功能，源码StikkyHeader，StikkyHeader是一个可以在滚动的时候将头部固定的控件，还可以将动画效果和StikkyHeader一起使用，api非常简单， 支持ListView,RecyclerView,ScrollView。支持2.3一下设备使用的StikkyHeader PullDownListView- 实现了模仿微信眼睛下拉效果，源码PullDownListView，下拉刷新，上拉加载，模仿微信眼睛。 CircleRefreshLayout- 又一个下拉刷新的实现，水滴效果。 BGARefreshLayout-Android- 多种下拉刷新效果、上拉加载更多、可配置自定义头部广告位，目前已经实现了四种下拉刷新效果:新浪微博下拉刷新风格、慕课网下拉刷新风格、美团下拉刷新风格、类似qq好友列表黏性下拉刷新风格。 Pull-to-Refresh.Rentals-Android- 提供一个简单可以自定义的下拉刷新实现。 Pull-to-Refresh.Tours- Taurus，很精美的下拉刷新。 ParallaxListView- 模仿Path的下拉刷新，Head头部图片下拉放大。 WaveRefreshForAndroid- 下拉刷新水波纹动画。 CoordinatorLayoutDemos- 收集了不少资源写了一个基于CoordinatorLayout实现的下拉刷新效果。 Android_PullToRefreshLibrary_Collection- 下拉刷新开源库集锦 。 HitBlockRefresh- 下拉刷新：打砖块和打坦克。 jd_tmall_refresh_demo- 仿写京东、天猫下拉刷新。 android-Ultra-Pull-To-Refresh- 下拉刷新框架，非常强大，可扩展性非常强，兼容各种view的下拉刷新事件。 2.卫星菜单android-satellite-menu- 点击主按钮，会弹出多个围绕着主按钮排列的子按钮，从而形成一个弹出式菜单。子按钮弹出和消失的动画效果都很棒。这种弹出式菜单按钮应用在Path app中。 ArcMenu- 实现弹出式按钮群（菜单）。点击主按钮，会在住按钮旁边弹出多个按钮（菜单）。弹出的按钮有两种排列形式，一种是围绕着主按钮成圆弧形排列，一种是和主按钮并排成一字型排列， 仿Path 2.0 (for iOS)。 Radial Menu Widget- 实现各种圆形或者半圆形菜单，以及圆形进度条。 android-circlebutton- 圆形按钮，有动画点击效果 CircularFloatingActionMenu- 卫星菜单。 ElasticDownload- 挺酷的下载进度条。 android-snake-menu- 仿 Tumblr 的 Android 可拖拽蛇形动画菜单。 3.节选器SegmentView- 类似iOS的Segment Control控件，第一种方式是使用 RadioGroup 实现，O网页链接。 SHSegmentControl- 类似iOS的Segment Control控件，此种方式的可定制化更好。 android-segmentedradiobutton- 在Android中实现类似iOS的分段单选按钮（segmented control），本人以前项目一直使用，值得拥有。 android-segmented-control- RadioGroup实现类似ios的分段选择(UISegmentedControl)控件。 4.模糊效果BlurNavigationDrawer- 背景模糊的Navigation Drawer。 5.HUD与Toastandroid-UCToast- 在不申请任何权限的情况下在 Android 应用中弹出悬浮窗,实现文档。 sweet-alert-dialog- sweet-alert-dialog是一款清新文艺的 Android 弹窗, 灵感来自于 JS 版的 SweetAlert。 6.进度条easyloadingbtn- 模仿了一个Dribbble上的Material Design效果，环形loading， 进度条、进度圈。 android-square-progressbar- 一个不错的方形进度条。 Radial Menu Widget- 实现各种圆形或者半圆形菜单，以及圆形进度条。 AnimatedCircleLoadingView- 一个有限／无限加载动画效果。基于Nils Banner的android-watch-loading-animation设计图。该设计本来是针对智能手表的。 circular-progress-button- 带动态效果的Button(按钮)可要比静态的按钮炫酷的多了，大家看到效果图就知道了 CircularBarPager- Android实现的动态效果，一个数字圆圈进度效果，源码CircularBarPager，material 风格的数字圆圈进度显示库（api10 +）。 dotted-progress-bar- 一个小清新的进度条。 WhorlView- 一个炫酷的漩涡加载效果自定义View。 AVLoadingIndicatorView- AVLoadingIndicatorView整合了一些漂亮的 Android 动画加载效果。 MagicProgressWidget- 渐变的圆形进度条与轻量横向进度条。 GBSlideBar- GBSlideBar类似uber/滴滴等app的滑动选择工具条。 GifLoadingView- 一些好看的 loadingview。 HouseLoading- 一个有趣的android加载loading动画。实现原理 7.UI其他MixtureTextView- 富文本，支持Android图文混排、文字环绕图片等效果。 android-ActionQueue- Action Queue 用于执行有次序的队列操作，比如按次序弹出对话框，这在 Android 中尤其有用。 WheelView-Android- WheelView-Android 是一款开源的 Android 滚动选择控件, 适用于不少应用场景。 Android Wheel- 带有刻度的旋转器：日历、三级联动。 CharacterPickerView- 可实现三级联动的选择器，高仿iOS的滚轮控件,可实现单项选择，并支持一二三级联动效果。 Highlight- Highlight一款可应用于 Android 应用上的指向性功能高亮的库, 可以快速的给应用添加上应用引导的效果。 HeaderAndFooterRecyclerView- 支持addHeaderView、 addFooterView、分页加载的RecyclerView解决方案 。 CleverRecyclerView- 是一个基于RecyclerView的扩展库，提供了与ViewPager类似的滑动效果并且添加了一些有用的特性。 drag-select-recyclerview- 实现了类似 Google Photos 风格的图片多选效果。 FlycoTabLayout- 一个Android TabLayout库,目前有两个TabLayout:SlidingTabLayout、CommonTabLayout。 AndroidChangeSkin- 一种完全无侵入的 Android 应用换肤方式，支持插件式和应用内换肤，无需重启 Activity。 Lobsterpicker- Lobsterpicker 为 Android 开发者提供了满足 Material Design 风格的颜色选择器。 FlycoRoundView- 一个扩展原生控件支持圆角矩形框背景的库,可以减少相关shape资源文件使用。 FlowingDrawer- FlowingDrawer 一个弹性效果的抽屉菜单，图片是概念图，实际效果实现了70%（侧滑菜单）。 TextSurface-是用 Java 写的一款借助酷炫的动画效果来完成消息展示的微型动画框架。 android-animate-RichEditor-android-animate-RichEditor是一款支持图片插入动画效果的 Android 富文本编辑器。 FlycoPageIndicator- android-animate-RichEditor是一款支持图片插入动画效果的 Android 富文本编辑器。 AndroidMosaicLayout- 马赛克效果 Layout,磁片风格View 自适应大小。 DropDownMenu- 一个实用的多条件筛选菜单，在很多App上都能看到这个效果，如美团，爱奇艺电影票等。 Swipe-Deck- 仿 Tinder 的可以左右滑动消除卡片效果的自定义控件。 IntlPhoneInput- 一个支持国际化的电话号码输入的自定义控件。 AndroidUI4Web- AndroidUI4Web是一个高性能的WebApp框架, 在移动浏览器上有与原生App一致的体验。 SmoothCheckBox- SmoothCheckBox带有切换动画的CheckBox。 AndroidTimelineViewx- AndroidTimelineViewx仿微信朋友圈 时间轴。 CityPicker- CityPicker仿美团等选择城市列表。 material-intro- Material Design 风格的引导页。 EmphasisTextView- 支持部分文字高亮的 TextView。 greedo-layout-for-android- 深度定制的 LayoutManager，在显示网格布局的时候会考虑屏幕宽高比。 Rosie- 可以让你创建遵循 Clean Architecture 的应用的框架。 CreditCardView- 一个交互很赞的信用卡自定义 View。 android-md-core- Material风格bootstrap的框架。 SwipeCardView- 一个带渐变层叠动画的左右滑动效果（类似于探探左右刷脸）。 SwipeSelector- 可以左右滑动切换 item 的 Selector。 ForegroundViews- 类似于 FrameLayout 的支持的前景自定义 View。 android-material-chips- Material Design 的 Chips 控件实现。 XhsEmoticonsKeyboard- 表情键盘解决方案。 JKeyboardPanelSwitch- 一套 Android 键盘面板冲突, 布局闪动的处理方案。 GestureLibray- 九宫格解锁。 RecyclerItemDecoration- RecyclerView相关的ItemDecorstion仍然保持高度定制性，易用性。 materiallogindemo- 一个炫酷的Material Design 风格的登录和注册页面 。教程 ScrollablePanel- 一个二维可拖动的面板控件，交互像一个二维的RecyclerView，用法也非常简单和RecyclerView的用法基本一样，横向竖向滑动也都实现了View的复用。 如果你想做房态、计划表、待办事项、课程表等需要一个二维的面板的话，这个控件应该是比较适合的。 VerificationCodeView- 可用于动态生成验证码，常见于金融类app。 ShimmerRecyclerView- 类似 Facebook 加载时，条目的闪烁效果，酷酷的。 StatusView- 简洁优雅的网络状态提示。 8.动画Android应用开发之所有动画使用详解- Android应用开发之所有动画使用详解。 动画特效大全- Android 动画特效大全。 SwitchLayout- 国内开发者， Android的Activity切换动画特效库SwitchLayout，视图切换动画库，媲美IOS。 ActivityOptionsICS- 一个低版本activity动画兼容库——ActivityOptionsICS，可以很好的实现MD的动画效果。 SwipeBack- 一个可以通过手势返回到上一个Activity的开源库，支持上下左右四个方向返回，支持多个View为Child。 SpringIndicator- 模仿Morning Routine的引导页效果SpringIndicator；基于模仿红点拖拽的Demo实现：BezierDemo；sample中使用到 快速创建ViewPager和ListView等的第三方库：MultipleModel。 XhsWelcomeAnim- 国内开发者， 华丽酷炫欢迎引导界面 动画没有之一。 Material-Animations- Material风格动画，可以定义两个Activity之间的动画。 android-shapeLoadingView- android-shapeLoadingView实现高仿新版58 加载动画，loading。 一个绚丽的loading- 一个绚丽的loading动效分析与实现。 TransitionPlayer- 一个 Transition 动画控制控制库，可以让你很轻松的创建一个可交互的动画。 loading-balls- loading-balls 一款支持高度配置的 Android 加载进度球。 SogoLoading- 仿搜狗浏览器加载动画，实现说明。 ExplosionField- Android中View 炸裂特效的实现分析。 AZExplosion- AZExplosion：模仿ExplosionField的粒子破碎效果。 BrokenView-玻璃碎裂动画效果。 SwipeCardView- SwipeCardView一个带渐变层叠动画的左右滑动效果（类似于探探左右刷脸）。类似SwipeCard CRAudioVisualizationView- 水波纹效果的声音可视化自定义 View。 LoadingDrawable- 一些酷炫的加载动画， 可以与任何View配合使用，作为加载动画或者Progressbar, 此外很适合与RecyclerRefreshLayout 配合使用作为刷新的loading 动画。 Depth-LIB-Android-- 一款酷炫的 Android 界面过渡动画效果。 SwipeCaptcha- 自定义View，仿一个斗鱼web端滑动验证码。博文 AndroidAHRSView- 显示飞行器姿态的Android控件。 Material-Animations- 炫酷的Activity切换效果，共享元素。 BGASwipeBackLayout-Android- 修改 v4 包中 SlidingPaneLayout 的源码来实现滑动返回布局。 android-snowfall- 漂亮的下雪效果。 ViewSpreadTranslationController- 两行代码搞定Android视图扩散切换效果。 9.网络相关9.1网络连接​ ion- 一个异步网络请求和图片加载的库，一个库能搞定几乎所有的网络请求。 ​ 多线程下载- Android 实现多线程下载 完美代码。 ​ opandroid- android p2p的开源实现。 ​ okio- square出的Okio这个库，尤其擅长处理二进制数据。如果觉得Java的输入输出流实在太复杂啰嗦，不妨试试Okio。 ​ okhttp- square出的okhttp库。 ​ okhttp-OkGo- 全新完美支持RxJava，比Retrofit更简单易用。该库是封装了okhttp的标准RESTful风格的网络框架。 ​ OkHttpPlus- OkHttp 的一个工具类开源项目OkHttpPlus——支持GET、POST、UI线程回调、JSON格式解析、链式调 用、文件上传下载 ，OkHttpPlus介绍。https://github.com/jeasonlzy/okhttp-OkGo ​ Android-Download-Manager-Pro- 一个下载管理库，如果你的 App 有大量的下载工作，这个库能帮到你。 ​ FileDownloader- 文件下载引擎，稳定、高效、简单易用。 ​ jchat-android- 一个聊天 App,具有完备的即时通讯功能,JChat 的功能基于极光 JMessage SDK 来开发。 ​ RxDownload- 基于RxJava和Retrofit打造的下载工具, 支持多线程下载和断点续传, 智能判断是否支持断点续传等功能。 9.2网络测试​ augmented-traffic-control- Facebook宣布开源移动网络测试工具ATC，该工具支持利用Wi-Fi网络模拟2G、2.5G、3G以 及LTE 4G移动网络环境，让测试工程师们能够快速对智能手机和App在不同国家地区和应用环境下的性能表现进行测 试。 10.图像获取glide- glide google出品，使用教程、GlidePalette。5 个顶级 Android 开源库 Universal Image Loader- Universal Image Loader 是一个强大的、可高度定制的图片缓存，简称：UIL，可以高度配置的网络图片缓存库，非常灵活，用户量最多 。 picasso- picasso 功能单一，没有缓存过期，同androidQuery一样链式调用，载入本地文件速度慢（没有生成thumbnails） ,Picasso and Android-Universal-Image-Loader,另外的一些诸如裁剪图片：Picasso.with(context) .load(url) .resize(50, 50) .centerCrop() .into(imageView)。 fresco- Facebook 又放出的一个新项目，一个类似 Picasso, Glide 的库，不过比他们做的更好。 强烈推荐！［Fresco集成示例］（https://github.com/liaohuqiu/fresco-demo-for-gradle）。 tape- 类似于图片加载库（例如UIL、Picasso等）实现异步加载，但是加载的不一定是图片。！ ImageLoader- ImageLoader 。 Volley- Volley 综合框架,包含图片部分，Volley与Picasso的对比 enif- enif 。 wqgallery- wqgallery实现类似微信选择照片功能，可以通过相机或相册选择，支持单张裁剪，支持单选模式、支持多选模式。 httplite- A android http library。Android网络框架httplite使用指南 PanoramaImageView- 通过监听手腕旋转进行交互，自动滚动图片。 11.响应式编程RxAndroid- RxAndroid：函数响应式编程 ，RxJava- Rx和RxJava文档中文翻译项目,RxJava 详解，RxJava资料汇总。Rxjava+Retrofit 实现全局过期 Token 自动刷新 12.地图百度地图- Android百度地图 线路规划，模拟运动轨迹，及全景效果。 AirMapView- 支持多个本地地图提供者包括谷歌地图V2和亚马逊地图V2。如果设备没有任何受支持的本地地图提供者,AirMapView会回退到基于web的地图提供者(目前谷歌地图)。 13.数据库ORMLite- ORMLite做的最棒但是学习成本有点儿高，ORMLite的文档有点儿烂。 SugarORM- SugarORM比较轻便， 支持Has a 和 Has many映射，但无法保存集合，没有映射关系。 GreenDAO- GreenDAO要先建立一个java项目来生成对应的表，一变动又要生成，很不方便。 ActiveDriod- ActiveDriod也不错官网。 ORMDroid- ormdroid 。 sqlbrite- 良心企业Square的又一开源项目，当你不想给用ContentProvider，只想简单监听SQLite表增删改的数据变更时可以试试它。 sqlbrite- DBExecutor android ORM数据库 1.使用了读写锁，支持多线程操作数据。 2.支持操作多个数据库 3.支持事务 4.缓存Sql，缓存表结构。 Iron- 一个快速和易用的 NoSQL 数据存储框架。 hawk- 一个快速和易用的键值对数据存储框架，支持AES加密，支持SharedPreferences或Sqlite存储，支持Gson解析。 AndroidKeyValueStore- 一个基于 SQLite 的 Key/Value 存储框架。 DBFlow- 一个速度极快，功能强大，而且非常简单的 Android 数据库 ORM 库，为你编写数据库代码,DBFlow 已被证明是最好的解决方案。5 个顶级 Android 开源库 14.图像浏览及处理MPAndroidChart- MPAndroidChart是一个功能强大的图表开源类库：曲线图、柱形图、环形图。 XCL-Charts- (国人开发)基于Android Canvas来绘制各种图表,使用简便,定制灵活。 WilliamChart- 绘制图表的库，支持LineChartView、BarChartView和StackBarChartView三中图表类型，并且支持 Android 2.2及以上的系统。 CropImageView- 原生ImageView只支持centerCrop，这里有支持9个方向裁剪的ImageView。 SimpleCropView- 一个Android的图片裁剪库，使用简单，易于定制。 DrawableView- DrawableView实现画板功能，可以改变画笔粗细，颜色，支持撤销功能。 ImageCoverFlow- ImageCoverFlow效果不错的画廊控件 可以设置画廊一次可见图片的张数，和其他第三方Gallery控件不同的是，该控件直接继承自View，而不是sdk中的Gallery控件。 FancyCoverFlow- 支持Item切换动画效果的类似Gallery View。改进版本可以无限轮播，可以选择自动轮播或者 手动滑动。 BGABanner-Android- demo中演示了引导页、以及通过fresco、android-async-http、gson实现广告条的自动轮播效果（splash 、 ViewPager切换动画） 。 RecyclerViewPager- 重写后的 RecyclerViewPager 完全继承自RecyclerView，可以自定义触发翻页的距离，可自定义翻页速度，支持VerticalViewPager，支持Fragment。 StickerCamera- 可以说是一个完整的相机、图片编辑的 APP，集成了大部分市面上有的同类 APP 的功能，裁剪、滤镜、贴纸应有尽有。 demo6_PhotoRiver- 图片流动显示的demo，可以点击流动中的图片放大显示，双击空白处图片以九宫格排列。 glide-transformations- 一个基于Glide的transformation库，拥有裁剪，着色，模糊，滤镜等多种转换效果。 ColoringLoading- 一个用纯代码实现自动绘画效果动画的项目。 SmartDrawing- 一个轻量级的手绘板，加入了一点截图功能。这只是一个Demo。并不能作为类库，也不是完整的项目工程，仅供学习或参考使用。 SlidingCard- 漂亮的卡片滑动翻页特效。 LargeImage- 加载大图 可以高清显示10000*10000像素的图片。 GalleryFinal- 自定义相册，实现了拍照、图片选择（单选/多选）、 裁剪（单/多裁剪）、旋转、ImageLoader无绑定任由开发者选 择、功能可配置、主题样式可配置。GalleryFinal为你定制相册。 AndroidAlbum- AndroidAlbum图片选择器：1、MVP结构设计；2、工厂模式对载图框架进行封装抽象，方便替换其他载图框架；3、闪退日志的搜集，方便揪BUG。 uCrop- uCrop 是 Yalantis 推出的又一款力作, 用于裁剪 Android 系统上的图片, 致力于打造最佳的图片裁剪体验。 crop-image-layout- crop-image-layout：图片裁切布局。 RenderscriptHistogramEqualization-RenderScript :简单而快速的图像处理 15.视频音频处理ijkplayer- B站开源的视频播放器，支持Android和iOS。 DanmakuFlameMaster- 这里是Android上最好的开源弹幕引擎·烈焰弹幕使。 YouTubePlayerActivity- 一个可以播放YouTube视频的Activity，支持屏幕旋转、声音控制、播放失败处理、可以自定义Activity关闭动画以及在横屏播放的时候自动隐藏status bar。 AndroidVideoPlayer- 开源的 Android 视频播放器，支持 DLNA。 Hide-Music-Player- Hide音乐播放器。 JamsMusicPlayer- 是一个功能强大的 Android 开源播放器, 作者将原本收费的项目拿出来开源, 实在令人敬佩。 RxAndroidAudior- RxAndroidAudior目前最鲁棒的Android声音录制和播放封装库了,说明。 Timber- 一款遵循了Material Design并且设计精美的播放器 Timber Music Player，已经在google play上架。 LandscapeVideoCamera- 一款功能强大的 Android 视频录制库, 仅允许横屏录制, 提供细粒度控制视频的质量与文件大小。 MovieHub- 非常漂亮的一款 Android Movie 工具。 LyricViewDemo- 歌词显示控件，支持多行显示、拖曳播放、自动识别歌词文件的编码。 16.测试及调试DevelopQuickSetting- 快速开启关闭开发者设置的工具，提供了app界面和桌面widget，能快速打开关闭overdraw，layout border，gpu rendering，adb wifi，不保存activity实例等功能。 decompileandroid- 在线反编译apk文件。 jadx- 一个Android反编译神器，不同于常见的dex2jar，这个反编译器生成代码的try/catch次数更少，View也不再是数字id了，可读性更高。 Androguard- Androguard使用Python写的一系列逆向工具集，功能很强大哦，对逆向工程感兴趣的小伙伴可以这个系列，教程。 logger- 一个简单、漂亮、功能强大的Android日志程序。 stf- WEB 端批量移动设备管理控制工具 STF 的环境搭建和运行，使用说明。 DecompileApk- 一键反编译 APK，输出所有反编译后的代码、资源，使用方便。 AppCrashTracker- 一个异常追踪器，可以生成一个 JSON 格式的日志并可以上传到服务器。 preferator- 开发辅助工具，帮助你快速的在 Android 端修改 SharedPreference，以达到测试的目的。 17.动态更新热更新dexposed- 淘宝 支付宝的Android底层技术团队即将为Dexposed开源项目贡献一个重要的扩展能力 —— 方法粒度的完整替换，大幅度降低基于AOP方式替换大型方法的开发成本，使用教程，Android平台免Root无侵入AOP框架Dexposed使用详解。Android Hotpatch系列之-项目介绍-客户端例子实现,服务器简易实现。热更新。 Xposed- Xposed是一款可以在不修改APK的情况下影响程序运行的框架服务,Android Hook神器：XPosed入门与登陆劫持演示。热更新。 code-push-大微软推出的一套可以为用 React Native 和 Cordova 开发的 App 提供代码热更新的方案。 DynamicAPK- 实现Android App多apk插件化和动态加载，支持资源分包和热修复。 AndFixDemo- AndFix是alibaba出品的开源热更新技术。 gradle_plugin_android_aspectjx- 通过Gradle Transform和aspectj来实现代码动态修改，业务逻辑数据埋点、性能数据统计等侵入性修改从此不再需要修改业务代码，完美解决Dexposed兼容性问题，实现代码自动插桩。AspectJX-Demo RoboAspectJ- 美团出品的开源热更新技术。 18.消息推送与即时通讯即时通讯和sns开源项目汇总- 源码提供！Android即时通讯和sns开源项目汇总，github地址。 19.完整项目SuesNews新闻客户端- 腾飞新闻，一个符合 Google Material Design 的 Android 校园新闻客户端 ，新闻客户端说明。 新闻客户端- Android应用源码比较不错的新闻客户端，本项目启动引导登录注册用户中心列表显示文章分页下拉刷新文章收藏更新反馈等新闻客户端常见的功能都有，项目分层合理，代码质量较高。 materialistic- Material Desgin风格的Hacker News客户端。 Telegram- Telegram 是一款专注于速度、安全的短信息应用，快速、简单、免费。Telegram 支持群组聊天，最高200人，最高支持分享1GB的视频，其它图片等等更是不在话下。而且所有信息全部支持同步。由于频发的隐私问题，所以 Telegram 也很注重通信安全。 SuZhouTong-client-for-android- 苏州通android客户端，非常多的UI效果。 ele_demo- 仿【饿了么】订餐软件的一个demo。 MD-BiliBili- Material Design 版 BiliBili Android 客户端。 AisenWeiBo- Aisen微博是新浪微博的第三方客户端，UI遵循Material Design：遵循Material Design、发布多图、离线下载、私信（触屏版、颜色主题切换、手势返回，4.4、5.0状态栏变色、离线编辑，定时发布多图、gif、长微博预览。FrescoDemo。 快递查询- 使用了爱查快递www.ickd.cn的api接口，可以查询申通、EMS、顺风、圆通、中通、韵达、天天、汇通、全锋、德邦、宅急送等11种快递的单号信息，支持手动输入单号和扫描单号(红米测试的时候扫描单号有点问题)，可以保存单号查询记录方便下次查询，，另外还包括了网络状态判断、快递自动更新、软件更新等功能，项目完美运行，有很详细的中文注释和逻辑分层。 SmartCall- SmartCall Android 企业通讯录。 Android-高仿大众点评客户端源码- Android-高仿大众点评客户端源码。 八个Android项目源码- 八个Android项目源码，大部分功能相信可以在实战项目中直接使用，供大家下载学习，大部分项目是基于Android Studio开发，IDE为Eclipse的童鞋可通过网上教程自行转换，这里就不多说了。大家可以下载下来学习看看！百度云盘下载地址。 minicat- 一个简洁的饭否App，支持Android 4.0以上版本。 SimplifyReader- 一款基于Google Material Design设计开发的Android客户端，包括新闻简读，图片浏览，视频爽看 ，音乐轻听以及二维码扫描五个子模块。 GithubTrends- 是一个用来看查看 GitHub 热门项目的 Android App, 遵循 Material Design, 支持订阅 50 多种编程语言, 9 种颜色主题切换, 可在上面收藏喜欢的项目。 jianshi- jianshi简诗是国人开发的一个用于记录文字信息的 Android 完整应用, 作者仅用了一天便将其开发出来, 并将开发的流程记录成文放到了简书上。 BuildingBlocks- 积木： 一个以知乎日报作为数据展现内容；以抽屉菜单作为功能扩展入口；依循 Material Design 作为主导设计 UI 的应用。 Douya- 开源的 Material Design 豆瓣客户端。 TranslateApp- 一个实现『划词翻译』功能的 Android 开源应用。 likequanmintvp- 基于MVP的Retrofit2(okhttp3)+rxjava+dagger2+greendao+glide+rtmp直播。该项目系仿全民TV。 20.插件Android Studio 插件和工具- 5个 推荐几个有用的 Android Studio 插件和工具（ButterKnife、selectorChapek、GsonFormat、ParcelableGenerator、LeakCanary）。 8 个最优秀的 Android Studio 插件- 8 个最优秀的 Android Studio 插件（H.A.X.M（硬件加速执行管理器）、Genymotion、Android Drawable Importer、Android ButterKnife Zelezny、Android Holo Colors Generator、Robotium Recorder、jimu Mirror、Strings-xml-tools）。 smalidea- 一款 IntelliJ IDEA/Android Studio 的 smali 插件～ ，Smalidea 无源码调试 Android 应用。 gradle-fir-plugin- 一个上传apk到fir的gradle插件，使用说明。 android-butterknife-zelezny- 一个ButterKnife的Android Studio插件, 该插件可以让你手动生成上述注入代码。 GradleDependenciesHelperPlugin- Gradle 依赖自动补全插件。 android-selector-intellij-plugin- 可以根据指定颜色生成Selector Drawable的插件。 7个最佳的Android模拟器- 7个最佳的Android模拟器。 gradle-android-javadoc-plugin- 可以生成 java doc 的 Gradle 插件。 gradle-android-junit-jacoco-plugin- 可以生成代码单元测试覆盖率报告的 Gradle 插件。 gradle-android-apk-size-plugin- 可以将 Apk 大小记录到 CSV 文件的 Gradle 插件。 几款实用的Android Studio 插件- 几款实用的Android Studio 插件：1、android-butterknife-zelezny；2、Gsonformat：可根据json数据快速生成java实体类；3、Android Postfix Completion；4、AndroidAccessors；5、Lifecycle Sorter：根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K；6、JsonOnlineViewer；7、CodeGlance；8、findBugs-IDEA：帮你一起找bug的；9、ADB WIFI：使用wifi无线调试你的app，无需root权限。 Leisure- 闲暇(Leisure)是一款集”知乎日报”、“果壳科学人”、“新华网新闻”以及“豆瓣图书”于一体的阅读类Android应用。 果壳、知乎和豆瓣在国内拥有大量用户，这些社区的用户每天都产生很多高质量内容。闲暇以其简介的风格将这几大社区 的优质内容整合于一体，使得用户能有效地获取这些内容，大大节省了用户的时间。酷安下载地址. LayoutFormatter插件- 可自动将乱序的布局文件进行重新属性排序并格式化，比如 style 和 android:id 必须排在前面，紧接着 layout、padding，而值设定如 text 只能排在最后。 21.著名框架xUtils- xUtils 包含了很多实用的android工具。支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响。最低兼容android 2.2 (api level 8)。目前xUtils主要有四大模块：DbUtils模块、ViewUtils模块、HttpUtils模块、BitmapUtils模块。 afinal- Afinal是一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。 ButterKnife- ButterKnife是一个专注于Android系统的View注入框架，让你从此从这些烦人臃肿的代码中解脱出来，ButterKnife–View注入框架。5 个顶级 Android 开源库 EventBus- EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。xBus- xBus - 简洁的EventBus实现。 Small- 做最轻巧的跨平台插件化框架，目前已支持Android、iOS以及html5插件。并且三者之间可以通过同一套javascript接口进行通信。 LayoutCast- LayoutCast可以在应用不重启的情况下，将res文件夹下的改动直接同步到手机上。使用LayoutCast，可以节约Android开发者的大量编译等待时间，非常适合真机调试界面的时候使用，推荐每一位开发者安装该利器。BUCK很快，但入侵性强，项目改动大，LayoutCast对项目改动小。 retrofit- retrofit将 REST API 转换为 Java 接口。5 个顶级 Android 开源库 Dagger2- Dagger 2 是著名的依赖注入库Dagger的继承者，我们强烈推荐它。文档，5 个顶级 Android 开源库 22.其他java-zhconverter- java-zhconverter是一个简繁体中文互换的Java开源类库。 joda-time-android- 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。java版本 AssistiveTouch- 配合Android手机沉浸式隐藏虚拟按键后快捷操作 (Nexus5屏幕变大了)。 S-Tools- S-Tools一个可以实时查看的CPU状态和手机各类传感器数据，还有一些例如颜色选择、指南针和设备信息等功能。 JsBridge- 模仿微信webview的JsBridge，安全方便的实现js和Java的互相调用，主要通过loadUrl和shouldOverrideUrl实现。 Sample Of All Samples- 提供大部分Android5.0组件的示例应用。 Android-Package-Channel- 美团网做的把Android多渠道打包工具，打包时间缩短到一分钟，python脚本。 fast-apk-packaging- Android不需要重新编译打渠道包。 android_gradle_script- gradle批量打包脚本，用txt配置一下，就可以支持多个渠道打包，适合国内这种动不动上百个渠道包的环境。目前有个问题，一次打包脚本超过80个就会GC问题。 BatchPackApk- 免签名直接打包工具。 Android多渠道打包工具Gradle插件- Android多渠道打包工具Gradle插件。 Android批量打包极速版- 用python实现的在META-INF目录内添加空文件的方式，实现批量快速打包Android应用。 Gradle-Plugin-User-Guide-Chinese-Verision- Gradle插件使用指南中文版。 gradle-guide.books- Android Gradle 插件中文指南（GitBook）。 Android-package_tool- 该工程用于编译多渠道Android应用，替换相应的标签，然后重新打包，用perl脚本实现。 兰贝壳儿- Android多渠道打包解决方案(兰贝壳儿)，eclipse插件。 Algorithms- 常见算法问题的Java实现。 java-design-patterns- 一个常见设计模式的java实现。 PreferenceInjector- SharedPreference注入开源库，SharedPreference key与某个变量绑定、监听key变化、初始化key都可以通过注解完成。 prettytime- 一个实用的人性化的时间显示，比如：几分钟前，几天前。 Material-Movies- Material Design 下的Movie App（电影展示），可供学习，或者直接二次开发。 Clean-Contacts- 充满技术含量的一个 Contact App（联系人）。 RedEnvelopeAssistant- 完全免费开源的抢红包软件、做这个软件纯粹是发现Android的模拟点击十分好玩，然后顺道写了一个，有此基础，可以再扩展其他的很多模拟点击程序 。 superCleanMaster- 一键清理开源版，包括内存加速，缓存清理，自启管理，软件管理等。 LoadViewHelper- 切换加载中，加载失败，加载成功布局，定义一个LoadViewHelper所有界面通用。 android-best-practices- android最佳实践 Android最佳实践- 安卓最佳实践（1）：安卓开发–中文。 Android最佳实践- 从Futurice公司Android开发者中学到的经验。 遵循以下准则，避免重复发明轮子。若您对开发iOS或Windows Phone 有兴趣， 请看iOS Good Practices 和 Windows client Good Practices 这两篇文章。 如何安装ACRA- 如何安装ACRA-一个Android应用Crash跟踪系统—在自己的服务器上。 Android ocr识别文字介绍- Android ocr识别文字介绍 。 DaVinci- DaVinci是一个适用于Android Wear平台的图片下载和缓存library。 Point-of-Android- Android 一些重要知识点解析整理 。 AppStoreLibrary- 检测是否在appstore安装了应用，搜索应用。 LeakCanary- 利用此类库，排查内存泄露变得非常简单，LeakCanary 中文使用说明，LeakCanary: 让内存泄露无所遁形。 anko- 快速开发框架。 CommonAdapter- 通过对于原生Adapter的封装，产生了支持ListView，GridView，RecyclerView的简单通用的Adapter。这种方式将item变成独立的“视图”对象，方便操作，又增加了可扩展性。 MVPAndroidBootstrap- 一个Android MVP 模式实例项目。 json2notification- 一个多功能方便好用的notification通知栏通知开源库。 barcodescanner- 一个封装好的基于zxing二维码扫描库。 BGAQRCode-Android- 一个可高度定制二维码扫描界面、生成二维码、识别图片二维码库。 mqtt- MQTT 协议 3.1.1 中文翻译版。 Droid Plugin- DroidPlugin 是360手机助手在Android系统上实现了一种新的插件机制:它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。 JsonAnnotation- 利用注解自动生成Gson‘s Model的库。 WeChatLuckyMoney- 微信抢红包插件。 android-support-23.2-sample- support 库在 23.2 版本新增内容示例项目。 Sunoath- 基于MVP+Retrofit+Material Design的Demo。 ActivityRouter- 一个url打开activity的Router库，支持指定参数类型，支持参数transfer，支持callback。 AnalysisApp- 一个快速分析 Android App 使用了哪些 SDK 的工具。 AndroidLuaExample- 封装了最新Lua代码的Android库。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cannot resolve method getSupportFragmentManager();]]></title>
    <url>%2Fposts%2F2ed74455.html</url>
    <content type="text"><![CDATA[在使用Fragment的时候，我们尝尝会用到Fragment管理器，那么初始化Fragment管理器的时候我们会遇到getSupportFragmentManager();方法找不到的情况，这里主要有两个原因： import android.support.v4.app.FragmentManager; 没有导入v4包下的Fragmanager. Activity没有继承FragmentActivity。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager轮播图（文字&图片）]]></title>
    <url>%2Fposts%2F3bedd12e.html</url>
    <content type="text"><![CDATA[Demo地址：MyViewPager ViewPager常用来实现图片的轮播，比如淘宝首页，会把一些促销的商品的图片和描述信息来回的播放，这就是典型的使用ViewPager实现的。 ViewPager属于布局管理器，允许用户通过页面翻转查看左右的数据，下面通过一个实例来讲解ViewPager实现图片轮播和手势滑动。 效果图 布局文件 activity_main.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="180dp"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/vp" android:layout_width="match_parent" android:layout_height="180dp"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:background="#6000" android:gravity="center_horizontal" android:orientation="vertical" android:padding="5dp"&gt; &lt;TextView android:id="@+id/tv_desc" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="#fff"/&gt; &lt;LinearLayout android:id="@+id/ll_point" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="5dp" android:orientation="horizontal"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 小圆点选择器point_enable.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;corners android:radius="8dp"/&gt; &lt;solid android:color="#fff"/&gt;&lt;/shape&gt; point_disable.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;corners android:radius="8dp"/&gt; &lt;solid android:color="@android:color/darker_gray"/&gt;&lt;/shape&gt; point_selector.xml 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_enabled="true" android:drawable="@drawable/point_enable"/&gt; &lt;item android:state_enabled="false" android:drawable="@drawable/point_disable"/&gt;&lt;/selector&gt; MainActivityMianActivity的代码如下，下面的代码主要是实现图片轮播和手势滑动，同时也提供里一个解决图片轮播到最后一个或滑动到最后一个（或第一个时）停了下来的问题，这个问题对用户体验来说是很糟糕的，所以要解决。同时提供了温习了一下MVC开发模型，这种模型能够让代码显得结构清晰。为了保证代码的连贯性，把代码写在了一个类中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package com.zm.myviewpager;import android.os.Bundle;import android.support.v4.view.PagerAdapter;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import java.util.ArrayList;public class MainActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener &#123; private ViewPager vp; private LinearLayout ll_point; private TextView tv_desc; private int[] imageResIds; //存放图片资源id的数组 private ArrayList&lt;ImageView&gt; imageViews; //存放图片的集合 private String[] contentDescs; //图片内容描述 private int lastPosition; private boolean isRunning = false; //viewpager是否在自动轮询 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //使用M-V-C模型 //V--view视图 initViews(); //M--model数据 initData(); //C--control控制器(即适配器) initAdapter(); //开启图片的自动轮询 new Thread() &#123; @Override public void run() &#123; isRunning = true; while (isRunning) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //在子线程中开启子线程 //往下翻一页（setCurrentItem方法用来设置ViewPager的当前页） vp.setCurrentItem(vp.getCurrentItem() + 1); &#125; &#125;); &#125; &#125; &#125;.start(); &#125; /* 初始化视图 */ private void initViews() &#123; //初始化放小圆点的控件 ll_point = (LinearLayout) findViewById(R.id.ll_point); //初始化ViewPager控件 vp = (ViewPager) findViewById(R.id.vp); //设置ViewPager的滚动监听 vp.setOnPageChangeListener(this); //显示图片描述信息的控件 tv_desc = (TextView) findViewById(R.id.tv_desc); &#125; /* 初始化数据 */ private void initData() &#123; //初始化填充ViewPager的图片资源 imageResIds = new int[]&#123;R.mipmap.aa, R.mipmap.bb, R.mipmap.cc, R.mipmap.dd, R.mipmap.ee&#125;; //图片的描述信息 contentDescs = new String[]&#123; "忙碌的生活疏于彼此联系，但却无法冲淡对你的思念。相信我们的心电感应，会把我每一次祈祷和祝福悄悄传送。", "你会因为一首歌喜欢上一个人，因为一个人喜欢一个城市，因为一个城市喜欢上一种生活，然后成为一首歌，想念某个人。", "我们对亲人的思念是永不会停止的，而思念却是多种的，阿婆的伤痛，妈妈的文字，我的小女儿情绪，不管怎样，已故的亲人永远活在我们的心里。", "每一天醒来，你的清影就在我眼前转。不管手里干什么事，一会儿，准走神儿了，呆呆的只想你，算着你什么时候回来。", "在一年的每个日子，在一天每个小时，在一小时的每一分钟，在一分钟的每一秒，我都在想你。" &#125;; //保存图片资源的集合 imageViews = new ArrayList&lt;&gt;(); ImageView imageView; View pointView; //循环遍历图片资源，然后保存到集合中 for (int i = 0; i &lt; imageResIds.length; i++) &#123; //添加图片到集合中 imageView = new ImageView(this); imageView.setBackgroundResource(imageResIds[i]); imageViews.add(imageView); //加小白点，指示器（这里的小圆点定义在了drawable下的选择器中了，也可以用小图片代替） pointView = new View(this); pointView.setBackgroundResource(R.drawable.point_selector); //使用选择器设置背景 LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(8, 8); if (i != 0) &#123; //如果不是第一个点，则设置点的左边距 layoutParams.leftMargin = 10; &#125; pointView.setEnabled(false); //默认都是暗色的 ll_point.addView(pointView, layoutParams); &#125; &#125; /* 初始化适配器 */ private void initAdapter() &#123; ll_point.getChildAt(0).setEnabled(true); //初始化控件时，设置第一个小圆点为亮色 tv_desc.setText(contentDescs[0]); //设置第一个图片对应的文字 lastPosition = 0; //设置之前的位置为第一个 vp.setAdapter(new MyPagerAdapter()); //设置默认显示中间的某个位置（这样可以左右滑动），这个数只有在整数范围内，可以随便设置 vp.setCurrentItem(5000000); //显示5000000这个位置的图片 &#125; //界面销毁时，停止viewpager的轮询 @Override protected void onDestroy() &#123; super.onDestroy(); isRunning = false; &#125; //--------------以下是设置ViewPager的滚动监听所需实现的方法-------- //页面滑动 @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; //新的页面被选中 @Override public void onPageSelected(int position) &#123; //当前的位置可能很大，为了防止下标越界，对要显示的图片的总数进行取余 int newPosition = position % 5; //设置描述信息 tv_desc.setText(contentDescs[newPosition]); //设置小圆点为高亮或暗色 ll_point.getChildAt(lastPosition).setEnabled(false); ll_point.getChildAt(newPosition).setEnabled(true); lastPosition = newPosition; //记录之前的点 &#125; //页面滑动状态发生改变 @Override public void onPageScrollStateChanged(int state) &#123; &#125; /** * 自定义适配器，继承自PagerAdapter */ class MyPagerAdapter extends PagerAdapter &#123; //返回显示数据的总条数，为了实现无限循环，把返回的值设置为最大整数 @Override public int getCount() &#123; return Integer.MAX_VALUE; &#125; //指定复用的判断逻辑，固定写法：view == object @Override public boolean isViewFromObject(View view, Object object) &#123; //当创建新的条目，又反回来，判断view是否可以被复用(即是否存在) return view == object; &#125; //返回要显示的条目内容 @Override public Object instantiateItem(ViewGroup container, int position) &#123; //container 容器 相当于用来存放imageView //从集合中获得图片 int newPosition = position % 5; //数组中总共有5张图片，超过数组长度时，取摸，防止下标越界 ImageView imageView = imageViews.get(newPosition); //把图片添加到container中 container.addView(imageView); //把图片返回给框架，用来缓存 return imageView; &#125; //销毁条目 @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; //object:刚才创建的对象，即要销毁的对象 container.removeView((View) object); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之uri、file、path相互转化]]></title>
    <url>%2Fposts%2F6f91fcbd.html</url>
    <content type="text"><![CDATA[uri &amp; file 互转1File file = new File(new URI(uri.toString())); 1URI uri = file.toURI(); uri &amp; path 互转1234567private String getPath(Uri uri) &#123; String[] projection = &#123;MediaStore.Video.Media.DATA&#125;; Cursor cursor = managedQuery(uri, projection, null, null, null); int column_index = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA); cursor.moveToFirst(); return cursor.getString(column_index); &#125; 1Uri uri = Uri.parse(path); file &amp; path 互转1String path = file.getPath() 1File file = new File(path)]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丰宁坝上草原2日游线路行程]]></title>
    <url>%2Fposts%2Fabebff90.html</url>
    <content type="text"><![CDATA[丰宁坝上草原2日游线路行程第一天07：00 北京约定地点集合 12：00 到达目的地，20人以上团队我们安排马队欢迎仪式，鞭炮欢迎！！！但晚上无法进行此活动 12：10 分房，午餐 14：00 骑马出发前往影视基地情人谷（草原上的另一番景色望不到边际的白桦林），影视村（原汁原味草原上的老村庄）情人谷北影厂的外景地（章子怡主演的《我的父亲母亲》；黄宏主演的《25个孩子一个爹》；电视剧《暖春》等多部影视剧的拍摄外景地）。 草原的落日也是值得一看的美景，你会感受到离开喧嚣世界，真正回归自然的那份自由自在，怡然自得。观赏草原夕阳，然后准备共进草原晚餐。 19：00 晚餐吃烤全羊、篝火聚会、观赏烟花、篝火跳舞，KTV。大家一起喝酒聊天，唱起我们喜欢的歌曲，在欢快的歌声中让我们舞动身体，度过美好的草原之夜。 第二天06：00 晨观日出 07：30 早餐后，前往草原娱乐场（价值180元已含），进入蒙古人家，感受蒙族风情，喝马奶酒，参加蒙古仪式祭祀敖包；可玩滑草、射箭、滑索、飞斧、野战搏击、弹跳飞人、喷火神枪、海盗船、激情转马、流星炮车、疯狂斗牛、蒙古人家、杂技表演等娱乐项目。 10：00前往美丽的草原滦河源头【闪电湖】拍照、看草原。滦河上游最大的湖，因入湖前的河流为闪电河而得名。在天苍苍、野茫茫的草原上闪现出这样敞亮清澈美丽的湖水，当地人叫它闪电湖。 或10:00开始团建活动，免费团建装备：拔河、背夹球、草地足球、袋鼠跳跳袋、多人跳绳、巨人脚步、摸石过河砖、珠行千里、撕名牌、指压板等活动。 12：00 午餐后返程北京，沿途一路美景相伴，也不会觉得枯燥，从海拔2000米到平原地带，各路美景让您充分领略。 住宿吃餐 标准型方案 128元/人3正餐+1早餐+1晚住宿（草原风农家院 两星标准,双人/三人标间,独立卫浴,热水,有线电视,WiFi）+免费篝火专业音响 超值型方案 168元/人3正餐+1早餐+1晚住宿（草原风农家院 两星标准,双人/三人标间,独立卫浴,热水,有线电视,WiFi）+免费篝火专业音响+15项娱乐场套票 特惠型方案 268元/人3正餐+1早餐+1晚住宿（远山.别院 准四星酒店标准,双人/三人标间,独立卫浴淋浴房,观景房,热水,有线电视,WiFi）+免费篝火专业音响+15项娱乐场套票 15项娱乐套票入场门票10元；高山滑草20元；缆车40元；弹跳飞人30元；射箭20元； 真人CS30元；竹林迷宫20元；蒙古人家20元；敖包祈福20元；欢乐转马20元；登月飞车20元；桑巴汽球20元；小海盗船20元；草原飞斧(6把/人)20元；高尔夫球20元；价值330元 费用包含 住宿费：酒店双人或三人标间； 餐费：三正餐一早餐； 活动费：拔河、放风筝、草地足球、趣味运动会等； 篝火晚会费：满20人即可组织篝火晚会； 全程司机、领队食宿费等； 医用装备：医药箱、急救包等（领队医药箱中包含药品种类：云南、白药喷雾剂、云南白药粉、风油精、绿药膏、烫伤膏、体温计、创可贴、绷带、纱布块、酒精、棉签、医用胶布、小剪刀）如需特殊药物请提前自备； 赠送娱乐套票：15项娱乐场套票（滑草、射箭、滑索、飞斧、野战搏击、弹跳飞人、喷火神枪、海盗船、激情转马、流星炮车、疯狂斗牛、蒙古人家、杂技表演等），此票不退不换；坝上独家帐篷营地、野餐基地、野外烧烤基地，可根据您的需要安排。 费用不含 骑马：骑马50元/小时，牵马费20元/小时； 烤全羊：30元/斤，活羊称重； 租车费用：6-55座各型旅游车，正规车，手续齐全； 景点门票：情人谷 免费、柳树沟70元/人、千松坝森林公园100元/人、大汗行宫90元/人、闪电湖30元/人、老掌沟20元/人、草原天路 免费；以上门票住宿咱家都有折扣票。 发票：不含发票，开发票需要另外加6%税点； 坝上草原旅游注意事项1、坝上风大，早晚温差大，建议多带些衣物。2、草原阳光较晒，应戴太阳镜、帽子并涂抹防晒霜。3、草原常有雷雨天气，雨具应必备。4、坝上草原有很多的村庄，虽然已经多年接待游客，但是山村人质朴、单纯的性格还是给游客带来很多的温馨，你敬他一尺，他敬你一丈，反之也是一样。所以处事要以和为贵，能饶人处且饶人，千万不可感情用事，有事多和您所住的酒店旅馆、农家小院的负责人商量，求其帮助解决。来坝上草原，尽量避免周末人多的的时候，根据以往的经验，周一到周四号人相对少些，各方面的价格也相对低一些。5、开心之时要特别注意管理好自己的东西。由于旅游区人员较多、比较杂，要特别小心。骑马是很多人喜好的娱乐和健身活动。外出骑马是一定要放好自己的东西，尽量不要带手机和钱包，如果带一定要放在妥善的、不易丢掉的地方。因为骑马会上下颠簸，口袋里的东西很容易掉出来，所以，骑马丢手机、钱包、眼镜、照相机、手表、钥匙、打火机、香烟等的人不少。6、放鞭炮、开越野车、四驱、摩托车等都要注意安全，安全第一。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[录音SoundRecording]]></title>
    <url>%2Fposts%2F58d30177.html</url>
    <content type="text"><![CDATA[效果图 首页 录音 播放 实现录音的 Service这个类可以说是这个包的核心了，如果理解了这个 Service，录音这一块基本就没什么问题了。 录音主要是利用 MediaRecoder 这个类，进行声音的记录，接下来我们一起来看看具体的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class RecordingService extends Service &#123; private static final String LOG_TAG = "RecordingService"; private String mFileName = null; private String mFilePath = null; private MediaRecorder mRecorder = null; private long mStartingTimeMillis = 0; private long mElapsedMillis = 0; private TimerTask mIncrementTimerTask = null; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; startRecording(); return START_STICKY; &#125; @Override public void onDestroy() &#123; if (mRecorder != null) &#123; stopRecording(); &#125; super.onDestroy(); &#125; public void startRecording() &#123; setFileNameAndPath(); mRecorder = new MediaRecorder(); mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mRecorder.setOutputFile(mFilePath); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC); mRecorder.setAudioChannels(1); mRecorder.setAudioSamplingRate(44100); mRecorder.setAudioEncodingBitRate(192000); try &#123; mRecorder.prepare(); mRecorder.start(); mStartingTimeMillis = System.currentTimeMillis(); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125; &#125; public void setFileNameAndPath() &#123; int count = 0; File f; do &#123; count++; mFileName = getString(R.string.default_file_name) + "_" + (System.currentTimeMillis()) + ".mp4"; mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath(); mFilePath += "/SoundRecorder/" + mFileName; f = new File(mFilePath); &#125; while (f.exists() &amp;&amp; !f.isDirectory()); &#125; public void stopRecording() &#123; mRecorder.stop(); mElapsedMillis = (System.currentTimeMillis() - mStartingTimeMillis); mRecorder.release(); getSharedPreferences("sp_name_audio", MODE_PRIVATE) .edit() .putString("audio_path", mFilePath) .putLong("elpased", mElapsedMillis) .apply(); if (mIncrementTimerTask != null) &#123; mIncrementTimerTask.cancel(); mIncrementTimerTask = null; &#125; mRecorder = null; &#125;&#125; 可以看到在 onStartCommand() 里面有一个 startRecording() 方法，在外部启动这个 RecordingService 的时候，便会调用这个 startRecording() 方法开始录音。 在 startRecording() 方法中先调用了 setFileNameAndPath 方法，初始化了录音文件的名字和保存的路径，为了让每个录音文件都有唯一的名字，我调用 System.currentMillis() 拼接到录音文件的名字里面。 12345678910111213public void setFileNameAndPath() &#123; int count = 0; File f; do &#123; count++; mFileName = getString(R.string.default_file_name) + "_" + (System.currentTimeMillis()) + ".mp4"; mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath(); mFilePath += "/SoundRecorder/" + mFileName; f = new File(mFilePath); &#125; while (f.exists() &amp;&amp; !f.isDirectory());&#125; 设置好了文件的名字和保存路径之后，对 mRecorder 进行一系列参数的设置，这个mRecorder 是 MediaRecorder 的一个实例，专门用于录音的存储。 1234567891011121314151617181920public void startRecording() &#123; setFileNameAndPath(); mRecorder = new MediaRecorder(); mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mRecorder.setOutputFile(mFilePath); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC); mRecorder.setAudioChannels(1); mRecorder.setAudioSamplingRate(44100); mRecorder.setAudioEncodingBitRate(192000); try &#123; mRecorder.prepare(); mRecorder.start(); mStartingTimeMillis = System.currentTimeMillis(); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125;&#125; 设置好参数之后，启动 mRecorder 开始录音，可以看到启动 mRecorder 开始录音后，我还将当前的时间赋值给 mStartingTimeMills，这里主要是为了记录录音的时长，等到录音结束后再获取一次当前的时间，然后将两个时间进行相减，就能得到录音的具体时长了。 等到录音结束，停止服务后，便会回调 RecordingService 的 onDestroy() 方法，这时候便会调用 stopRecording() 方法，关闭 mRecorder，并用 SharedPreferences 保存录音文件的信息，最后将 mRecorder 置空，防止内存泄露。 1234567891011121314151617public void stopRecording() &#123; mRecorder.stop(); mElapsedMillis = (System.currentTimeMillis() - mStartingTimeMillis); mRecorder.release(); getSharedPreferences("sp_name_audio", MODE_PRIVATE) .edit() .putString("audio_path", mFilePath) .putLong("elpased", mElapsedMillis) .apply(); if (mIncrementTimerTask != null) &#123; mIncrementTimerTask.cancel(); mIncrementTimerTask = null; &#125; mRecorder = null;&#125; 显示录音界面的 RecordAudioDialogFragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class RecordAudioDialogFragment extends DialogFragment &#123; private static final String TAG = "RecordAudioDialogFragme"; private int mRecordPromptCount = 0; private boolean mStartRecording = true; private boolean mPauseRecording = true; long timeWhenPaused = 0; private FloatingActionButton mFabRecord; private Chronometer mChronometerTime; private ImageView mIvClose; private OnAudioCancelListener mListener; public static RecordAudioDialogFragment newInstance() &#123; RecordAudioDialogFragment dialogFragment = new RecordAudioDialogFragment(); Bundle bundle = new Bundle(); dialogFragment.setArguments(bundle); return dialogFragment; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); &#125; @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_record_audio, null); initView(view); mFabRecord.setColorNormal(getResources().getColor(R.color.colorAccent)); mFabRecord.setColorPressed(getResources().getColor(R.color.colorAccent)); mFabRecord.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(getActivity() , new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO&#125;, 1); &#125; else &#123; onRecord(mStartRecording); mStartRecording = !mStartRecording; &#125; &#125; &#125;); mIvClose.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onCancel(); &#125; &#125;); builder.setCancelable(false); builder.setView(view); return builder.create(); &#125; private void initView(View view) &#123; mChronometerTime = (Chronometer) view.findViewById(R.id.record_audio_chronometer_time); mFabRecord = (FloatingActionButton) view.findViewById(R.id.record_audio_fab_record); mIvClose = (ImageView) view.findViewById(R.id.record_audio_iv_close); &#125; Intent intent; private void onRecord(boolean start) &#123; intent = new Intent(getActivity(), RecordingService.class); if (start) &#123; // start recording mFabRecord.setImageResource(R.drawable.ic_media_stop); //mPauseButton.setVisibility(View.VISIBLE); Toast.makeText(getActivity(), "开始录音...", Toast.LENGTH_SHORT).show(); File folder = new File(Environment.getExternalStorageDirectory() + "/SoundRecorder"); if (!folder.exists()) &#123; //folder /SoundRecorder doesn't exist, create the folder folder.mkdir(); &#125; //start Chronometer mChronometerTime.setBase(SystemClock.elapsedRealtime()); mChronometerTime.start(); //start RecordingService getActivity().startService(intent); //keep screen on while recording// getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125; @Override public void onDestroyView() &#123; if (!mStartRecording) &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; super.onDestroyView(); &#125; public void setOnCancelListener(OnAudioCancelListener listener) &#123; this.mListener = listener; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED) &#123; onRecord(mStartRecording); &#125; break; &#125; &#125; public interface OnAudioCancelListener &#123; void onCancel(); &#125;&#125; 可以看到在 RecordAudioDialogFragment 有一个 newInstance(int maxTime) 的静态方法供外部调用，如果想设置录音的最大时长，直接传参数进去就行了。 这个对话框的重点部分就是在 onCreateDialog()中，我们先加载了我们自定义的对话框的布局，当点击录音的按钮的时候，先进行相关权限的申请，录音权限 android.permission.RECORD_AUDIO 1234567891011121314151617181920212223242526272829303132333435public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_record_audio, null); initView(view); mFabRecord.setColorNormal(getResources().getColor(R.color.colorAccent)); mFabRecord.setColorPressed(getResources().getColor(R.color.colorAccent)); mFabRecord.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(getActivity() , new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO&#125;, 1); &#125; else &#123; onRecord(mStartRecording); mStartRecording = !mStartRecording; &#125; &#125; &#125;); mIvClose.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onCancel(); &#125; &#125;); builder.setCancelable(false); builder.setView(view); return builder.create();&#125; 申请好权限之后便会调用 onRecord() 这个方法，然后将 boolean mStartRecording 进行反转，这样就不用写难看的 if else 了，直接改变 mStartRecording 的值，然后在 onRecord() 里面进行处理。 1234567891011121314151617181920212223242526272829303132333435363738private void onRecord(boolean start) &#123; intent = new Intent(getActivity(), RecordingService.class); if (start) &#123; // start recording mFabRecord.setImageResource(R.drawable.ic_media_stop); //mPauseButton.setVisibility(View.VISIBLE); Toast.makeText(getActivity(), "开始录音...", Toast.LENGTH_SHORT).show(); File folder = new File(Environment.getExternalStorageDirectory() + "/SoundRecorder"); if (!folder.exists()) &#123; //folder /SoundRecorder doesn't exist, create the folder folder.mkdir(); &#125; //start Chronometer mChronometerTime.setBase(SystemClock.elapsedRealtime()); mChronometerTime.start(); //start RecordingService getActivity().startService(intent); //keep screen on while recording// getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125; 创建了保存录音文件的文件夹，然后根据 mStartRecording 的值进行 RecordingService 的启动和关闭罢了。在启动时还顺便开始了 mChronometer 的计时显示，这是一个 Android 原生的显示计时的一个控件。 播放录音的 PlaybackDialogFragment外部调用这个对话框的时候，只需要传入一个包含录音文件信息的 RecordingItem，因为包含的信息比较多，所以最好将 RecordingItem 进行序列化。 1234567public static PlaybackDialogFragment newInstance(RecordingItem item) &#123; PlaybackDialogFragment f = new PlaybackDialogFragment(); Bundle b = new Bundle(); b.putParcelable(ARG_ITEM, item); f.setArguments(b); return f;&#125; 来看看 onCreateDialog() 方法，在加载了布局之后，给 mSeekBar 设置监听，mSeekBar 是一个显示进度条的控件，当开始播放录音时候，将录音文件的时长，设置进 mSeekBar 里面，播放录音的同时，运行 mSeekBar，通过监听 mSeekBar 的进度，刷新显示的播放进度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_media_playback, null); mFileNameTextView = (TextView) view.findViewById(R.id.file_name_text_view); mFileLengthTextView = (TextView) view.findViewById(R.id.file_length_text_view); mCurrentProgressTextView = (TextView) view.findViewById(R.id.current_progress_text_view); mSeekBar = (SeekBar) view.findViewById(R.id.seekbar); ColorFilter filter = new LightingColorFilter (getResources().getColor(R.color.green), getResources().getColor(R.color.green)); mSeekBar.getProgressDrawable().setColorFilter(filter); mSeekBar.getThumb().setColorFilter(filter); mFileLengthTextView.setText(String.valueOf(mFileLength)); mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; if(mMediaPlayer != null &amp;&amp; fromUser) &#123; mMediaPlayer.seekTo(progress); mHandler.removeCallbacks(mRunnable); long minutes = TimeUnit.MILLISECONDS.toMinutes(mMediaPlayer.getCurrentPosition()); long seconds = TimeUnit.MILLISECONDS.toSeconds(mMediaPlayer.getCurrentPosition()) - TimeUnit.MINUTES.toSeconds(minutes); mCurrentProgressTextView.setText(String.format("%02d:%02d", minutes,seconds)); updateSeekBar(); &#125; else if (mMediaPlayer == null &amp;&amp; fromUser) &#123; prepareMediaPlayerFromPoint(progress); updateSeekBar(); &#125; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; if(mMediaPlayer != null) &#123; // remove message Handler from updating progress bar mHandler.removeCallbacks(mRunnable); &#125; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; if (mMediaPlayer != null) &#123; mHandler.removeCallbacks(mRunnable); mMediaPlayer.seekTo(seekBar.getProgress()); long minutes = TimeUnit.MILLISECONDS.toMinutes(mMediaPlayer.getCurrentPosition()); long seconds = TimeUnit.MILLISECONDS.toSeconds(mMediaPlayer.getCurrentPosition()) - TimeUnit.MINUTES.toSeconds(minutes); mCurrentProgressTextView.setText(String.format("%02d:%02d", minutes,seconds)); updateSeekBar(); &#125; &#125; &#125;); mPlayButton = (FloatingActionButton) view.findViewById(R.id.fab_play); mPlayButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onPlay(isPlaying); isPlaying = !isPlaying; &#125; &#125;); mFileNameTextView.setText(item.getName()); mFileLengthTextView.setText(String.format("%02d:%02d", minutes,seconds)); builder.setView(view); // request a window without the title dialog.getWindow().requestFeature(Window.FEATURE_NO_TITLE); return builder.create();&#125; 当点击播放录音的按钮之后，会调用 onPlay() 方法，然后根据 isPlaying（标识当前是否播放录音）的值，来调用不同的方法。 12345678910111213private void onPlay(boolean isPlaying)&#123; if (!isPlaying) &#123; //currently MediaPlayer is not playing audio if(mMediaPlayer == null) &#123; startPlaying(); //start from beginning &#125; else &#123; resumePlaying(); //resume the currently paused MediaPlayer &#125; &#125; else &#123; pausePlaying(); &#125;&#125; 我们最关心的，莫过于 startPlaying() 这个方法，这个方法便是来开启播放录音的，我们首先将外部传入的有关的录音信息，设置给 MediaPlayer，然后开始调用 mMediaPlayer.start() 进行录音的播放，然后调用 updateSeekbar() 实时更新进度条的内容。当 MediaPlayer 的内容播放完成后，调用 stopPlaying() 方法，关闭 mMediaPlayer。 12345678910111213141516171819202122232425262728293031private void startPlaying() &#123; mPlayButton.setImageResource(R.drawable.ic_media_pause); mMediaPlayer = new MediaPlayer(); try &#123; mMediaPlayer.setDataSource(item.getFilePath()); mMediaPlayer.prepare(); mSeekBar.setMax(mMediaPlayer.getDuration()); mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; mMediaPlayer.start(); &#125; &#125;); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125; mMediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; stopPlaying(); &#125; &#125;); updateSeekBar(); //keep screen on while playing audio getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);&#125; 以上便是本文的全部内容，有关的代码我已经上传到 Github 上了，需要的 点击这里，喜欢的话，欢迎来波 star 和 fork。]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>录音</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[婚礼筹备]]></title>
    <url>%2Fposts%2F95cd02d2.html</url>
    <content type="text"><![CDATA[即将步入人生的第一件大事，在此记录下点滴事件：]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android Utils工具类方法大集合]]></title>
    <url>%2Fposts%2F1cc851d3.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460/** * 提供精确的小数位四舍五入处理，保留几位小数。 * * @param v 需要四舍五入的数字 * @param scale 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException("The scale must be a positive integer or zero"); &#125; BigDecimal b = new BigDecimal(Double.toString(v)); BigDecimal one = new BigDecimal("1"); double bb = b.divide(one, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); return bb; &#125; /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 定精度，以后的数字四舍五入。 * * @param v1 被除数 * @param v2 除数 * @param scale 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double div(double v1, double v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException("The scale must be a positive integer or zero"); &#125; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /** * 提供精确的乘法运算。 * * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static double mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; /** * 检查手机上是否安装了指定的软件 * * @param context * @param packageName ：应用包名 * @return */ public static boolean isAvilible(Context context, String packageName) &#123; // 获取packagemanager PackageManager packageManager = context.getPackageManager(); // 获取所有已安装程序的包信息 List&lt;PackageInfo&gt; packageInfos = packageManager.getInstalledPackages(0); // 用于存储所有已安装程序的包名 List&lt;String&gt; packageNames = new ArrayList&lt;String&gt;(); // 从pinfo中将包名字逐一取出，压入pName list中 if (packageInfos != null) &#123; for (int i = 0; i &lt; packageInfos.size(); i++) &#123; String packName = packageInfos.get(i).packageName; packageNames.add(packName); &#125; &#125; // 判断packageNames中是否有目标程序的包名，有TRUE，没有FALSE return packageNames.contains(packageName); &#125; /** * 根据一个网络连接(String)获取bitmap图像 * * @param imageUri * @return */ public static Bitmap getbitmap(String imageUri) &#123; Log.v("", "getbitmap:" + imageUri); // 显示网络上的图片 Bitmap bitmap = null; try &#123; URL myFileUrl = new URL(imageUri); HttpURLConnection conn = (HttpURLConnection) myFileUrl .openConnection(); conn.setDoInput(true); conn.connect(); InputStream is = conn.getInputStream(); bitmap = BitmapFactory.decodeStream(is); is.close(); Log.v("", "image download finished." + imageUri); &#125; catch (OutOfMemoryError e) &#123; e.printStackTrace(); bitmap = null; &#125; catch (IOException e) &#123; e.printStackTrace(); Log.v("", "getbitmap bmp fail---"); bitmap = null; &#125; return bitmap; &#125; /** * 将字符串转换成Bitmap类型 * * @param * @return */ public static Bitmap stringtoBitmap(String string) &#123; Bitmap bitmap = null; try &#123; byte[] bitmapArray; bitmapArray = Base64.decode(string, Base64.DEFAULT); bitmap = BitmapFactory.decodeByteArray(bitmapArray, 0, bitmapArray.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125; /** * 将Bitmap转换成字符串 * * @param bitmap * @return */ public static String bitmaptoString(Bitmap bitmap) &#123; String string = null; ByteArrayOutputStream bStream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 100, bStream); byte[] bytes = bStream.toByteArray(); string = Base64.encodeToString(bytes, Base64.DEFAULT); return string; &#125; /** * 返回当前程序版本名-V2 三段修改---ex 5.2---5.21 * support 7.8.8.1, 7.18.8.1, 17.18.8.1 modified by chenhong, 2018-5-25 */ public static String getAppVersionNameV2(Context context) &#123; String versionCode = ""; try &#123; PackageInfo pi = MyApp.getAppContext().getPackageManager().getPackageInfo(MyApp.getAppContext().getPackageName(), 0); versionCode = pi.versionName; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (!TextUtils.isEmpty(versionCode)) &#123; int firstDotIndex = versionCode.indexOf("."); if (firstDotIndex &gt; -1) &#123; String mainVersion = versionCode.substring(0, firstDotIndex); String subVersion = ""; if (versionCode.length() &gt; firstDotIndex + 1) &#123; subVersion = versionCode.substring(firstDotIndex + 1); subVersion = subVersion.replace(".", ""); &#125; versionCode = mainVersion + "." + subVersion; int length = versionCode.length(); int dotIndex = versionCode.indexOf("."); if (dotIndex == length - 1) &#123; versionCode += "00"; &#125; else if (dotIndex == length - 2) &#123; versionCode += "0"; &#125; &#125; else &#123; versionCode += ".00"; &#125; &#125; return versionCode; &#125; /** * 获取IP地址 * * @param context * @return */ public static String getIPAddress(Context context) &#123; NetworkInfo info = ((ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo(); if (info != null &amp;&amp; info.isConnected()) &#123; if (info.getType() == ConnectivityManager.TYPE_MOBILE) &#123;//当前使用2G/3G/4G网络 try &#123; //Enumeration&lt;NetworkInterface&gt; en=NetworkInterface.getNetworkInterfaces(); for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) &#123; return inetAddress.getHostAddress(); &#125; &#125; &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; else if (info.getType() == ConnectivityManager.TYPE_WIFI) &#123;//当前使用无线网络 WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); String ipAddress = intIP2StringIP(wifiInfo.getIpAddress());//得到IPV4地址 return ipAddress; &#125; &#125; else &#123; //当前无网络连接,请在设置中打开网络 &#125; return null; &#125; /** * 将得到的int类型的IP转换为String类型 * * @param ip * @return */ public static String intIP2StringIP(int ip) &#123; return (ip &amp; 0xFF) + "." + ((ip &gt;&gt; 8) &amp; 0xFF) + "." + ((ip &gt;&gt; 16) &amp; 0xFF) + "." + (ip &gt;&gt; 24 &amp; 0xFF); &#125; /** * 获取屏幕高度 * * @param context * @return */ public static int getWindowHeight(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); int windowHeight = wm.getDefaultDisplay().getHeight(); return windowHeight; &#125; /** * 获取屏幕宽度 * * @param context * @return */ public static int getWindowWidth(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); int windowWidth = wm.getDefaultDisplay().getWidth(); return windowWidth; &#125; /** * json字符串转map * * @param jsonString * @return */ public static Map transStringToMap(String jsonString) &#123; Gson gson = new Gson(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map = gson.fromJson(jsonString, map.getClass()); return map; &#125; /** * 计算两个时间相隔多少天 * * @return */ public static String getDayNumberStr(String nowDate, String createDate) &#123; String str = ""; int strDay = 0; DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); try &#123; Date d1 = df.parse(nowDate); Date d2 = df.parse(createDate); long diff = d1.getTime() - d2.getTime();//这样得到的差值是微秒级别 long days = diff / (1000 * 60 * 60 * 24); long hours = (diff - days * (1000 * 60 * 60 * 24)) / (1000 * 60 * 60); long minutes = (diff - days * (1000 * 60 * 60 * 24) - hours * (1000 * 60 * 60)) / (1000 * 60);// System.out.println("" + days + "天" + hours + "小时" + minutes + "分"); str = days + ""; strDay = Integer.parseInt(str) + 1; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return strDay + ""; &#125; /** * 获得当天0点时间 */ public static int getTimesmorning() &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.MILLISECOND, 0); return (int) (cal.getTimeInMillis() / 1000); &#125; /** * 获得当天24点时间 */ public static int getTimesnight() &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, 24); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.MILLISECOND, 0); return (int) (cal.getTimeInMillis() / 1000); &#125; /** * 获得当天时间 */ public static String getTodayDate() &#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");//设置日期格式 String date = df.format(new Date());// new Date()为获取当前系统时间 return date; &#125; /** * 判断当前时间是否在时间date之前 date1 7点 date2 8点 * 时间格式 2005-4-21 16:16:34 "yyyy-MM-dd HH:mm:ss" * * @param date * @return * @throws ParseException */ public static boolean isDateBefore(String date) throws ParseException &#123; Date date1 = new Date();//当前时间 DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return date1.before(df.parse(date)); &#125; /** * 判断当前时间是否在时间date之后 date1 8点 date2 5点 * * @param date * @return * @throws ParseException */ public static boolean isDateAfter(String date) throws ParseException &#123; Date date1 = new Date();//当前时间 DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return (df.parse(date)).before(date1); &#125; /** * 大小写转换 * * @param UpperCasestr * @return * @throws Exception */ public static String toUpperCase(String UpperCasestr) throws Exception &#123; return UpperCasestr.toUpperCase().toString(); &#125; /** * 去除字符串空格 * * @return */ public static String removeAllSpace(String str) &#123; String tmpstr = str.replace(" ", ""); return tmpstr; &#125; /** * 获取当前网络类型 * * @return */ public static String getNetworkTypeAll() &#123; String strNetworkType = ""; ConnectivityManager cm = (ConnectivityManager) MyApp.mContext.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = cm.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isConnected()) &#123; if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) &#123; strNetworkType = "WIFI"; &#125; else if (networkInfo.getType() == ConnectivityManager.TYPE_MOBILE) &#123; String _strSubTypeName = networkInfo.getSubtypeName(); // TD-SCDMA networkType is 17 int networkType = networkInfo.getSubtype(); switch (networkType) &#123; case TelephonyManager.NETWORK_TYPE_GPRS: case TelephonyManager.NETWORK_TYPE_EDGE: case TelephonyManager.NETWORK_TYPE_CDMA: case TelephonyManager.NETWORK_TYPE_1xRTT: case TelephonyManager.NETWORK_TYPE_IDEN: //api&lt;8 : replace by 11 strNetworkType = "2G"; break; case TelephonyManager.NETWORK_TYPE_UMTS: case TelephonyManager.NETWORK_TYPE_EVDO_0: case TelephonyManager.NETWORK_TYPE_EVDO_A: case TelephonyManager.NETWORK_TYPE_HSDPA: case TelephonyManager.NETWORK_TYPE_HSUPA: case TelephonyManager.NETWORK_TYPE_HSPA: case TelephonyManager.NETWORK_TYPE_EVDO_B: //api&lt;9 : replace by 14 case TelephonyManager.NETWORK_TYPE_EHRPD: //api&lt;11 : replace by 12 case TelephonyManager.NETWORK_TYPE_HSPAP: //api&lt;13 : replace by 15 strNetworkType = "3G"; break; case TelephonyManager.NETWORK_TYPE_LTE: //api&lt;11 : replace by 13 strNetworkType = "4G"; break; default: if (_strSubTypeName.equalsIgnoreCase("TD-SCDMA") || _strSubTypeName.equalsIgnoreCase("WCDMA") || _strSubTypeName.equalsIgnoreCase("CDMA2000")) &#123; strNetworkType = "3G"; &#125; else &#123; strNetworkType = _strSubTypeName; &#125; break; &#125; &#125; &#125; return strNetworkType; &#125; /** * 获取sim卡运营商信息 */ public static String getSimOperator() &#123; String operator = ""; try &#123; TelephonyManager telManager = (TelephonyManager) MyApp.mContext.getSystemService(Context.TELEPHONY_SERVICE); operator = telManager.getSimOperator(); if (operator != null) &#123; if (operator.equals("46000") || operator.equals("46002") || operator.equals("46007")) &#123; operator = "中国移动"; &#125; else if (operator.equals("46001")) &#123; operator = "中国联通"; &#125; else if (operator.equals("46003")) &#123; operator = "中国电信"; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return operator; &#125; return operator; &#125; /** * 强制隐藏输入法键盘 * * @param context Context * @param view EditText */ public void hideInput(Context context, View view) &#123; InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), 0); &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android get请求和post请求区别]]></title>
    <url>%2Fposts%2Fcec09649.html</url>
    <content type="text"><![CDATA[Get请求与Post请求的区别Get是向服务器发索取数据的一种请求 Get是获取信息，而不是修改信息，类似数据库查询功能一样，数据不会被修改 Get请求的参数会跟在url后进行传递，请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连,％XX中的XX为该符号以16进制表示的ASCII，如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。 Get传输的数据有大小限制，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了，不同的浏览器对URL的长度的限制是不同的。 GET请求的数据会被浏览器缓存起来，用户名和密码将明文出现在URL上，其他人可以查到历史浏览记录，数据不太安全。在服务器端，用Request.QueryString来获取Get方式提交来的数据 Post是向服务器提交数据的一种请求 Post请求则作为http消息的实际内容发送给web服务器，数据放置在HTML Header内提交，Post没有限制提交的数据。Post比Get安全，当数据是中文或者不敏感的数据，则用get，因为使用get，参数会显示在地址，对于敏感数据和不是中文字符的数据，则用post POST表示可能修改变服务器上的资源的请求，在服务器端，用Post方式提交的数据只能用Request.Form来获取]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 切换账户]]></title>
    <url>%2Fposts%2F7f469116.html</url>
    <content type="text"><![CDATA[问题 提交代码，但github上的绿格子没有变绿 新老账户切换 如果你不知道现在本地Git用的帐号是什么，你可以输入 Step 1 查看用户名1git config user.name Step 2 查看用户邮箱1git config user.email Step 3 修改用户名和邮箱的命令12git config --global user.name "Your_username"git config --global user.email "Your_email" 注意user.name，user.email 后面千万记得加空格，否则你就是提交了，Git也不会提醒你配置出错]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Webview里设置Cookie]]></title>
    <url>%2Fposts%2F3defa4a1.html</url>
    <content type="text"><![CDATA[Android中WebView加载网页，有时候需要通过cookie想网页传递信息，这时候这样操作。 Step 1 设置接收cookie123CookieManager.setAcceptFileSchemeCookies(true);CookieManager.getInstance().setAcceptCookie(true);CookieManager.setAcceptFileSchemeCookies(true); Step 2 设置cookie的值，通过setcookie方法123List&lt;String&gt; cookies = new ArrayList&lt;&gt;();cookies.add("app_key=" + App.getAppKey());cookies.add("os=" + "Android" + Build.VERSION.SDK_INT); Step 3 通过sync方法，将cookie同步12345678910111213141516171819if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context);&#125;CookieManager cookieManager = CookieManager.getInstance();cookieManager.setAcceptCookie(true);if (cookies != null) &#123; for (String cookie : cookies) &#123; cookieManager.setCookie(url, cookie); &#125;&#125;String s = "Domain=.***.com";String s1 = "Path=/";cookieManager.setCookie(url, s);cookieManager.setCookie(url, s1);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123; CookieManager.getInstance().flush();&#125; else &#123; CookieSyncManager.getInstance().sync();&#125; &quot;;Domain=.xxxx.xxx.com&quot;+//作用域（在哪个域名下cookie起作用）&quot;;Path=/&quot;;//Domain这个作用域下的哪个文件夹，“/”代表所有文件夹 注意 在调用设置Cookie之后不能再设置这类属性，否则设置Cookie无效。 123&gt; webView.getSettings().setBuiltInZoomControls(true); &gt; webView.getSettings().setJavaScriptEnabled(true); &gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#### 完整代码​```javapublic class WebviewUtil &#123; public static void setWebCookie(Context context) &#123; CookieManager.setAcceptFileSchemeCookies(true); CookieManager.getInstance().setAcceptCookie(true); CookieManager.setAcceptFileSchemeCookies(true); setCookie(context); &#125; private static void setCookie(Context context) &#123; List&lt;String&gt; cookies = new ArrayList&lt;&gt;(); cookies.add(&quot;app_key=&quot; + App.getAppKey()); cookies.add(&quot;plat=&quot; + &quot;2&quot;); cookies.add(&quot;os=&quot; + &quot;Android&quot; + Build.VERSION.SDK_INT); cookies.add(&quot;channel=&quot; + AndroidUtil.getChannel()); cookies.add(&quot;cver=&quot; + String.valueOf(App.getVersionCode())); cookies.add(&quot;ctype=&quot; + 2); cookies.add(&quot;cspec=&quot; + &quot;&quot;); if (AccountManager.hasLogin()) &#123; cookies.add(&quot;user_id=&quot; + getUserId()); cookies.add(&quot;gz_id=&quot; + getUserId()); &#125; syncCookie(context, &quot;.7gz.com/&quot;, cookies); &#125; private static void syncCookie(Context context, String url, List&lt;String&gt; cookies) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); if (cookies != null) &#123; for (String cookie : cookies) &#123; cookieManager.setCookie(url, cookie); &#125; &#125; String s = &quot;Domain=.7gz.com&quot;; String s1 = &quot;Path=/&quot;; cookieManager.setCookie(url, s); cookieManager.setCookie(url, s1); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123; CookieManager.getInstance().flush(); &#125; else &#123; CookieSyncManager.getInstance().sync(); &#125; &#125; private static String getUserId() &#123; return AccountManager.getInstance().getAccount().id; &#125; //清空所有Cookie public static void removeAllCookie(Context context) &#123; CookieSyncManager.createInstance(context); //Create a singleton CookieSyncManager within a context CookieManager cookieManager = CookieManager.getInstance(); // the singleton CookieManager instance cookieManager.removeAllCookie();// Removes all cookies. CookieSyncManager.getInstance().sync(); // forces sync manager to sync now &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 圆角圆形ImageView]]></title>
    <url>%2Fposts%2F494f41c5.html</url>
    <content type="text"><![CDATA[效果预览 特点 基于AppCompatImageView扩展 支持圆角、圆形显示 可绘制边框，圆形时可绘制内外两层边框 支持边框不覆盖图片 可绘制遮罩 …… 支持的属性、方法 属性名 含义 默认值 对应方法 is_circle 是否显示为圆形（默认为矩形） false isCircle() corner_top_left_radius 左上角圆角半径 0dp setCornerTopLeftRadius() corner_top_right_radius 右上角圆角半径 0dp setCornerTopRightRadius() corner_bottom_left_radius 左下角圆角半径 0dp setCornerBottomLeftRadius() corner_bottom_right_radius 右下角圆角半径 0dp setCornerBottomRightRadius() corner_radius 统一设置四个角的圆角半径 0dp setCornerRadius() border_width 边框宽度 0dp setBorderWidth() border_color 边框颜色 #ffffff setBorderColor() inner_border_width 相当于内层边框（is_circle为true时支持） 0dp setInnerBorderWidth() inner_border_color 内边框颜色 #ffffff setInnerBorderColor() is_cover_src border、inner_border是否覆盖图片内容 false isCoverSrc() mask_color 图片上绘制的遮罩颜色 不设置颜色则不绘制 setMaskColor() 基本用法Step 1. 添加JitPack仓库 在项目根目录下的 build.gradle 中添加仓库: 123456allprojects &#123; repositories &#123; ... maven &#123; url "https://jitpack.io" &#125; &#125;&#125; Step 2. 添加项目依赖 123dependencies &#123; implementation 'com.github.zhangmiaocc:CircularImageView:1.0.0'&#125; **Step 3. 在布局文件中添加 CornerLabelView 1234567891011&lt;com.zm.library.CircularImageView android:layout_width="100dp" android:layout_height="100dp" android:src="@drawable/rabbit" app:border_color="#008B45" app:border_width="2dp" app:corner_radius="20dp" app:inner_border_color="#FF7F24" app:inner_border_width="4dp" app:is_circle="true" /&gt; 源码：CircularImageView]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>CircleImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnimationDrawable使用简介]]></title>
    <url>%2Fposts%2Fd6df4d7b.html</url>
    <content type="text"><![CDATA[Drawable animation可以加载Drawable资源实现帧动画。AnimationDrawable是实现Drawable animations的基本类。推荐用XML文件的方法实现Drawable动画，不推荐在代码中实现。这种XML文件存放在工程中res/drawable/目录下。XML文件的指令(即属性)为动画播放的顺序和时间间隔。 ​ 在XML文件中元素为根节点，节点定义了每一帧，表示一个drawable资源的帧和帧间隔。下面是一个XML文件的实例: 123456789101112131415161718192021222324&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/loading1" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading2" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading3" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading4" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading5" android:duration="100" /&gt;&lt;/animation-list&gt; 设置Android:oneshot属性为true,表示此次动画只执行一次，最后停留在最后一帧。设置为false则动画循环播放。文件可以添加为Image背景，触发的时候播放。 下面简单通过一个例子，来给ImageView设置次动画效果，具体实现方法为 通过View. setBackgroundResource(resID). animation.start(). 12345private AnimationDrawable animationDrawable; img = (ImageView) findViewById(R.id.img); img.setImageResource(R.drawable.anim_loading); animationDrawable = ((AnimationDrawable) img.getDrawable()); animationDrawable.start(); Demo地址：https://github.com/zhangmiaocc/AnimationDrawable Blog地址：https://zhangmiao.cc/]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android加载PDF文件的使用]]></title>
    <url>%2Fposts%2F44884a58.html</url>
    <content type="text"><![CDATA[Android PdfViewerAndroidPdfViewer 1.x可在AndroidPdfViewerV1 repo上获得，可以独立开发。版本1.x使用不同的引擎在画布上绘制文档，因此如果您不喜欢2.x版本，请尝试1.x. 图书馆在Android上显示的PDF文档，用animations，gestures，zoom和double tap支持。它基于PdfiumAndroid来解码PDF文件。适用于API 11（Android 3.0）及更高版本。在Apache License 2.0下获得许可。 3.1.0-beta.1有什么新功能？ 合并拉取请求＃557用于捕捉页面（逐页滚动） 合并拉出请求＃618用于夜间模式 合并拉取请求＃566 OnLongTapListener 将PdfiumAndroid更新为1.9.0，而c++_shared不是使用gnustl_static 更新Gradle插件 将编译SDK和支持库更新到26 将最低SDK更改为14 3.0 API的变化 换成Contants.PRELOAD_COUNT了PRELOAD_OFFSET 删除PDFView#fitToWidth()（没有参数的变体） 删除Configurator#invalidPageColor(int)方法，因为无法呈现无效页面 从OnRenderListener#onInitiallyRendered(int)方法中删除了页面大小参数，因为文档可能具有不同的页面大小 删除PDFView#setSwipeVertical()方法 安装添加到build.gradle： compile &#39;com.github.barteksc:android-pdf-viewer:3.1.0-beta.1&#39; 或者如果你想使用更稳定的版本： compile &#39;com.github.barteksc:android-pdf-viewer:2.8.2&#39; 库在jcenter存储库中可用，可能它很快就会在Maven Central中。 ProGuard的如果您使用的是ProGuard，请将以下规则添加到proguard配置文件中： 1-keep class com.shockwave.** 在布局中包含PDFView1234&lt;com.github.barteksc.pdfviewer.PDFView android:id=&quot;@+id/pdfView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 加载PDF文件所有可用选项都带有默认值： 123456789101112131415161718192021222324252627282930313233343536373839404142pdfView.fromUri(Uri)orpdfView.fromFile(File)orpdfView.fromBytes(byte[])orpdfView.fromStream(InputStream) // stream is written to bytearray - native code cannot use Java StreamsorpdfView.fromSource(DocumentSource)orpdfView.fromAsset(String) .pages(0, 2, 1, 3, 3, 3) // all pages are displayed by default .enableSwipe(true) // allows to block changing pages using swipe .swipeHorizontal(false) .enableDoubletap(true) .defaultPage(0) // allows to draw something on the current page, usually visible in the middle of the screen .onDraw(onDrawListener) // allows to draw something on all pages, separately for every page. Called only for visible pages .onDrawAll(onDrawListener) .onLoad(onLoadCompleteListener) // called after document is loaded and starts to be rendered .onPageChange(onPageChangeListener) .onPageScroll(onPageScrollListener) .onError(onErrorListener) .onPageError(onPageErrorListener) .onRender(onRenderListener) // called after document is rendered for the first time // called on single tap, return true if handled, false to toggle scroll handle visibility .onTap(onTapListener) .onLongPress(onLongPressListener) .enableAnnotationRendering(false) // render annotations (such as comments, colors or forms) .password(null) .scrollHandle(null) .enableAntialiasing(true) // improve rendering a little bit on low-res screens // spacing between pages in dp. To define spacing color, set view background .spacing(0) .autoSpacing(false) // add dynamic spacing to fit each page on its own on the screen .linkHandler(DefaultLinkHandler) .pageFitPolicy(FitPolicy.WIDTH) .pageSnap(true) // snap pages to screen boundaries .pageFling(false) // make a fling change only a single page like ViewPager .nightMode(false) // toggle night mode .load(); 注意pages 是可选的，它允许您根据需要过滤和排序PDF页面 滚动手柄Scroll handle是从1.x分支替换ScrollBar。 从版本2.1.0将PDFView放在RelativeLayout中以使用ScrollHandle不是必需的，您可以使用任何布局。 要使用滚动手柄，只需使用方法注册它Configurator#scrollHandle()。此方法接受ScrollHandle接口的实现。 AndroidPdfViewer附带默认实现，您可以使用它 .scrollHandle(new DefaultScrollHandle(this))。 DefaultScrollHandle位于右侧（垂直滚动时）或底部（水平滚动时）。通过使用带有第二个参数（new DefaultScrollHandle(this, true)）的构造函数，可以将句柄放在左侧或顶部。 您还可以创建自定义滚动句柄，只需实现ScrollHandle界面。所有方法都记录为接口源上的Javadoc注释。 文件来源2.3.0版引入了文档源，它们只是PDF文档的提供者。每个提供程序都实现DocumentSource接口。预定义的提供程序可以在com.github.barteksc.pdfviewer.source包中找到，可以用作创建自定义提供程序的示例。 预定义的提供程序可以与速记方法一起使用： 12345pdfView.fromUri(Uri)pdfView.fromFile(File)pdfView.fromBytes(byte[])pdfView.fromStream(InputStream)pdfView.fromAsset(String) 自定义提供程序可与pdfView.fromSource(DocumentSource)方法一起使用。 链接3.0.0版引入了对PDF文档中链接的支持。默认情况下，使用DefaultLinkHandler 并单击引用同一文档中的页面的链接会导致跳转到目标页面并单击以某个URI为目标的链接导致在默认应用程序中打开它。 您还可以创建自定义链接处理程序，只需实现LinkHandler接口并使用Configurator#linkHandler(LinkHandler)方法进行设置 。查看DefaultLinkHandler 源以实现自定义行为。 页面符合政策从版本3.0.0开始，库支持以3种模式将页面装入屏幕： 宽度 - 最宽页面的宽度等于屏幕宽度 高度 - 最高页面的高度等于屏幕高度 BOTH - 基于最宽和最高的页面，每个页面都缩放为在屏幕上完全可见 除了选定的策略之外，每个页面都会缩放到相对于其他页面的大小。 可以使用适合的策略进行设置Configurator#pageFitPolicy(FitPolicy)。默认策略是WIDTH。 其他选项位图质量默认情况下，生成的位图使用格式压缩RGB_565以减少内存消耗。ARGB_8888可以使用pdfView.useBestQuality(true)方法强制渲染。 双击缩放有三种缩放级别：分钟（默认1），中间（默认1.75）和最大（默认3）。在第一次双击时，视图缩放到中等水平，在第二个到最大水平，第三个返回到最低水平。如果您处于中级和最高级别之间，则双击会导致缩放到最大值，依此类推。 可以使用以下方法更改缩放级别： 123void setMinZoom(float zoom);void setMidZoom(float zoom);void setMaxZoom(float zoom); 可能的问题为什么导致apk太大了？Android PdfViewer依赖于PdfiumAndroid，它是许多架构的本机库集（大约16 MB）。Apk必须包含所有这些库，以便在市场上的每个设备上运行。幸运的是，Google Play允许我们上传多个apks，例如每个架构一个。有一篇关于自动将您的应用程序拆分为多个apks的文章，可在此处获得。最重要的部分是使用APK Splits改进多个APK创建和版本代码处理，但整篇文章值得一读。您只需要在您的应用程序中执行此操作，无需分支PdfiumAndroid等。 为什么我无法从URL打开PDF？下载文件是一个长时间运行的过程，必须知道Activity生命周期，必须支持一些配置，数据清理和缓存，因此创建这样的模块可能最终会成为新的库。 如何在配置更改后显示上次打开的页面？您必须存储当前页码然后进行设置pdfView.defaultPage(page)，请参阅示例应用程序 如何将文档放入屏幕宽度（例如，方向更改）？FitPolicy.WIDTH如果要在具有不同页面大小的文档中放置所需页面，请使用策略或添加以下代码段： 123456Configurator.onRender(new OnRenderListener() &#123; @Override public void onInitiallyRendered(int pages, float pageWidth, float pageHeight) &#123; pdfView.fitToWidth(pageIndex); &#125;&#125;); 如何像ViewPager一样滚动浏览单个页面？您可以使用以下设置的组合来获得类似于ViewPager的滚动和拖动行为： 1234.swipeHorizontal(true).pageSnap(true).autoSpacing(true).pageFling(true) Demo地址：https://github.com/zhangmiaocc/AndroidPDFView 参考：https://github.com/barteksc/AndroidPdfViewer]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android日志框架Logger的详细使用（目前最新版2.1.1）]]></title>
    <url>%2Fposts%2Fe28061de.html</url>
    <content type="text"><![CDATA[前言在开发过程中，log日志是每个人多会用上的。平时在开发大项目的时候，几乎每个类多需要加log，然而在发布之前，要求全部删除，真是累。因为系统log暂时没有统一管理的方法。还有就是，特别是在调试的时候，对于线程并发或者子线程的调试，还是加log调试比较精确，用debug工具调试经常和实际不符合。那么，如果使用系统log，调试完又得找出来删除，累++。 作为程序猿，这种笨方法肯定是会鄙视的。对于这种需求，我们自己封装一个简单的工具包。当然这里介绍的是，github上很多人用log框架：logger。 相信很多人多用过，这里给还没有尝试过的人简单介绍下，使用也超级简单。 logger作为调试框架，可以支持多种格式： 线程的信息 类、方法的信息 格式化将 json、xml 输出 支持字符串格式参数 各种集合输出，list、map、array、set等，（只支持debug输出） 支持从日志跳转到源码 …… 如下图（引用原作者）： 可以看出，和系统对比，它最大的亮点是优雅的输出log信息，当然同时提供很多其他信息，一目了然，更清晰！ 如果你每天被log折磨的生不如死，那么让logger来拯救你吧~ 作者：Orhan Obut github：https://github.com/orhanobut/logger 目前，将近7.5k个star让他位列调试框架第二名，屈居facebook的stetho之后,8.5k个star。但这2个调试工具应用场景不用，所以简单的调试，logger是最佳选择了。这里简单介绍下stetho，它是一款提供在Chrome开发者工具上调试Android app的开源框架，可以在Chrome查看数据库，不用想以前那样把数据库导出，然后在用工具查看；配合网络框架可以直接打印查看网络请求的数据，而不需要一个一个添加打印出来，省去很多繁琐的事情。有兴趣的可以了解： 作者：FaceBook 官网地址： http://facebook.github.io/stetho/ github https://github.com/facebook/stetho 使用Logger使用框架，是比较简单的，如果可以看英文版，可以直接到https://github.com/orhanobut/logger了解。 logger目前的最新版本是2.1.1，网上也很多人使用1.15的版本，如果使用最新版，单独修改配置文件，是有报错的。因为，最新版在初始化这块和原来有了较大的改动。 主要是初始化、和控制Log打印这2方面。这里介绍2.11的版本使用，所以想升级的也可以往下看看哦。 3步，只要3步，你就学会使用Logger，请： 1.导入依赖 1compile 'com.orhanobut:logger:2.1.1' 1Logger.addLogAdapter(new AndroidLogAdapter()); 注：如果在Application中初始化，记得修改 AndroidManifest.xml 中 application 标签属性，添加 android:name=”.MyApplication” ，不然不会打印。 3.使用 1Logger.d("hello"); 如图： 当然，如果还有追求，继续往下看看它的其他功能。 支持的数据类型普通类型12345public void testNormal()&#123; Logger.d("DEBUG日志"); Logger.i("INFO日志"); Logger.e("ERROR日志");&#125; Format类型123public void testFormat()&#123; Logger.d("hello %s, luck number is %d", "world", 5); &#125; 集合类型首先看看List： 1234List list = new ArrayList();list.add("hello");list.add("world");Logger.d(list); 1Log.d(TAG, list.toString()); 首先是调用： 123@Override public void d(Object object) &#123; log(DEBUG, null, Utils.toString(object)); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static String toString(Object object) &#123; if (object == null) &#123; return "null"; &#125; if (!object.getClass().isArray()) &#123; return object.toString(); &#125; if (object instanceof boolean[]) &#123; return Arrays.toString((boolean[]) object); &#125; if (object instanceof byte[]) &#123; return Arrays.toString((byte[]) object); &#125; if (object instanceof char[]) &#123; return Arrays.toString((char[]) object); &#125; if (object instanceof short[]) &#123; return Arrays.toString((short[]) object); &#125; if (object instanceof int[]) &#123; return Arrays.toString((int[]) object); &#125; if (object instanceof long[]) &#123; return Arrays.toString((long[]) object); &#125; if (object instanceof float[]) &#123; return Arrays.toString((float[]) object); &#125; if (object instanceof double[]) &#123; return Arrays.toString((double[]) object); &#125; if (object instanceof Object[]) &#123; return Arrays.deepToString((Object[]) object); &#125; return "Couldn't find a correct type for the object"; &#125; 这样就不需要我们自己调用toString()，直接可以打印了。 其他的数据结构也是一样的，看图就可以了： 123456789101112131415161718192021222324public void testCollections()&#123; /** * Map */ Map map = new HashMap(); map.put("map1","hello"); map.put("map2","world"); Logger.d(map); /** * Set */ Set set = new HashSet(); set.add("hello"); set.add("world"); Logger.d(set); /** * Array */ String [] strs = &#123;"hello", "world"&#125;; Logger.d(strs); &#125; *注：打印集合的时候，特别是数组时，前面不要添加其他字符，如：Logger.d(“数组集合”+strs);这样会把整体当做一个参数，导致判断错误，不能正常输出数组类型。其次是，作者提示，打印集合时，使用DEBUG等级。* JSON数据123456public void testJson()&#123; String jsonDate = "&#123;\"id\":859,\"channelnumber\":681,\"bilingual\":0,\"name\":\"beIN Sports 2 English 600K H265\",\n" +" \"language\":\"EN\",\n" +" \"videotype\":\"MPEG2\",\"audiotype\":\"MPEP1\",\"callsign\":\"beIN Sports 2 English 600K H265\",\"country\":\"cn\"&#125;;"; Logger.json(jsonDate); Log.d(TAG, jsonDate); &#125; XML数据1234567891011121314public void testXml() &#123; String xmlDate = "&lt;province id=\"01\" name=\"北京\"&gt; \n" + " &lt;city id=\"0101\" name=\"北京\"&gt; \n" + " &lt;county id=\"010101\" name=\"北京\" weatherCode=\"101010100\"/&gt; \n" + " &lt;county id=\"010102\" name=\"海淀\" weatherCode=\"101010200\"/&gt; \n" + " &lt;county id=\"010103\" name=\"朝阳\" weatherCode=\"101010300\"/&gt; \n" + " &lt;county id=\"010110\" name=\"石景山\" weatherCode=\"101011000\"/&gt; \n" + " &lt;/city&gt; \n" + " &lt;/province&gt; "; Logger.xml(xmlDate); Log.d(TAG, xmlDate); &#125; 修改默认配置最新版修改配置，和旧版也是有不同，如下： 12345678FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .showThreadInfo(false) //（可选）是否显示线程信息。 默认值为true .methodCount(2) // （可选）要显示的方法行数。 默认2 .methodOffset(7) // （可选）设置调用堆栈的函数偏移值，0的话则从打印该Log的函数开始输出堆栈信息，默认是0 .logStrategy(customLog) //（可选）更改要打印的日志策略。 默认LogCat .tag("MyTAG") //（可选）每个日志的全局标记。 默认PRETTY_LOGGER（如上图） .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy)); 具体配置大家可以自行去实践下。一般默认就可以了，这里说下，修改全局的TAG，和局部的TAG。 1.修改全局的TAG，在初始化的application中修改，如： 1234FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .tag("MyTAG") .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy)); 2.修改局部的TAG，哪里打印就在哪里修改，只对当前打印有效，如： 1234public void testNormal()&#123; Logger.t("hello").d("DEBUG日志"); Logger.i("INFO日志"); &#125; *注：如果尝试用局部的方法，在application初始化时修改。当然，这是有效果的，但只能用一次，其他打印还是会用全局的，可自行测试。* 控制打印开关这个功能是最喜欢的了，当我们发布软件，或者太多的log影响性能，那么就可以关闭logger打印，在application初始化的地方： 1234567Logger.addLogAdapter(new AndroidLogAdapter() &#123; @Override public boolean isLoggable(int priority, String tag) &#123; return BuildConfig.DEBUG; &#125;&#125;); 通过适配器控制打印，只要覆盖isLoggable()方法，返回BuildConfig.DEBUG即可。这样子，log就不再打印出来了。 *注：返回值导入的包是：import com.orhanobut.logger.BuildConfig; 有时顺手导入：com.gotechcn.frameworks，那就没有效果。* 保存log到文件1Logger.addLogAdapter(new DiskLogAdapter()); 通过打印，找到保存的路径： /storage/emulated/0 但手机里面就是没有这个文件夹，不知道什么原因，真机和模拟机多没有，知道可以留言噢，感谢！ 工作流程原理图logg框架的整体流程如图（作者原图）： 其他对Log信息的设置与过滤： Filter：编辑默认或者自定义的标签，过滤标签以外的信息； Disable：设置user soft wraps，即设置换行 Setting：设置log头部的信息，比如时间、线程PID、包名、TAG等开关设置 好了，对于Logger框架的介绍就到这里了。有时会更新，记得使用时看看GitHub升级了没有，同时在使用是否和以前兼容。对于一些其他的方法，可以直接看源码，具体是干什么用的。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Log</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lottie Android For Animation]]></title>
    <url>%2Fposts%2F1444979e.html</url>
    <content type="text"><![CDATA[Lottie是一个支持Android、iOS、React Native，并由 Adobe After Effects制作aep格式的动画，然后经由bodymovin插件转化渲染为json格式可被移动端本地识别解析的Airbnb开源库。Lottie实时呈现After Effects动画效果，让应用程序可以像使用静态图片一样轻松地使用动画。Lottie支持API 14及以上。 一、预览 二 、基本使用 在自己项目module的build.gradle文件中添加如下代码： 123dependencies &#123; compile 'com.airbnb.android:lottie:2.0.0-beta4'&#125; LottieAnimationView使用最简单的方法是: 1234567&lt;com.airbnb.lottie.LottieAnimationView android:id="@+id/animation_view" android:layout_width="wrap_content" android:layout_height="wrap_content" app:lottie_fileName="hello-world.json" app:lottie_loop="true" app:lottie_autoPlay="true" /&gt; 其中lottie_loop属性为是否重复无限期动画，当为true时，动画无限次数播放，为false时，播放一次。 或者把json资源放在app/src/main/assets下，也可以这样使用它: 1234LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view);animationView.setAnimation(&quot;hello-world.json&quot;);animationView.loop(true);animationView.playAnimation(); 该方法将加载文件并在后台解析动画，在完成后异步开始呈现。 如果您希望重用一个动画，例如在列表的每个项目中，或者从一个网络请求JSONObject中加载它: 123456789LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view);...Cancellable compositionCancellable = LottieComposition.Factory.fromJson(getResources(), jsonObject, (composition) -&gt; &#123; animationView.setComposition(composition); animationView.playAnimation();&#125;);// 取消异步加载// compositionCancellable.cancel(); 你也可以控制动画添加监听： 1234567891011121314151617181920animationView.addAnimatorUpdateListener((animation) -&gt; &#123; // Do something.&#125;);animationView.playAnimation();...if (animationView.isAnimating()) &#123; // Do something.&#125;...animationView.setProgress(0.5f);...// 自定义动画速度和时长ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f) .setDuration(500);animator.addUpdateListener(animation -&gt; &#123; animationView.setProgress(animation.getAnimatedValue());&#125;);animator.start();...animationView.cancelAnimation(); 你可以给整个动画，一个特定的图层，或者一个图层的特定内容添加一个颜色过滤器。 1234567891011121314// 任何符合颜色过滤界面的类final PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.LIGHTEN);// 在整个视图中添加一个颜色过滤器animationView.addColorFilter(colorFilter);//在特定的图层中添加一个颜色滤镜animationView.addColorFilterToLayer("hello_layer", colorFilter);// 添加一个彩色过滤器特效“hello_layer”上的内容animationView.addColorFilterToContent("hello_layer", "hello", colorFilter);// 清除所有的颜色滤镜animationView.clearColorFilters(); 注意:颜色过滤器只适用于图层，如图像层和实层，以及包含填充、描边或组内容的内容。 在引擎盖下,LottieAnimationView使用LottieDrawable呈现其动画。如果需要，您可以直接使用可绘制的表单: 1234LottieDrawable drawable = new LottieDrawable();LottieComposition.Factory.fromAssetFileName(getContext(), "hello-world.json", (composition) -&gt; &#123; drawable.setComposition(composition);&#125;); 如果你的动画会经常重用,LottieAnimationView内置了一个可选的缓存策略。使用LottieAnimationView .setAnimation(String,CacheStrategy)。CacheStrategy可以Strong, Weak, 或者None。LottieAnimationView对加载和解析的动画持有强或弱的参考。弱或强表示缓存中组合的GC参考强度。 三、Image 支持如果您的动画是从assets中加载的，并且您的图像文件位于assets 的子目录中，那么您可以对图像进行动画。你可以用LottieAnimationView或者LottieDrawable对象调用setImageAssetsFolder(String)方法，明确assets相对文件夹内的路径,确保图像bodymovin出口与他们的名字不变,文件夹应该img_ 开头。如果直接使用LottieDrawable,当你完成时您必须调用recycleBitmaps。 如果你需要提供你自己的位图，如果你从网络或其他地方下载，你可以提供一个委托来做这个: 12345animationView.setImageAssetDelegate(new ImageAssetDelegate() &#123; @Override public Bitmap fetchBitmap(LottieImageAsset asset) &#123; getBitmap(asset); &#125; &#125;); 四、性能和内存如果该组合没有遮罩或mattes，那么性能和内存开销应该相当不错。没有创建任何位图，大多数操作都是简单的画布绘制操作。如果这个组合有遮罩或mattes，就会使用屏幕外的缓冲区，并且会有一个性能打击。 如果在你的动画列表中使用,推荐使用CacheStrategy，在调用LottieAnimationView.setAnimation(String, CacheStrategy)的时候，所以动画不需要每次都反序列化。 五、Lottie官方Demo下载https://fir.im/lottiedemo 六、参考资料http://airbnb.design/lottie/ http://www.lottiefiles.com/ https://github.com/airbnb/lottie-android http://www.adobe.com/cn/products/aftereffects.html https://github.com/bodymovin/bodymovin https://github.com/airbnb/lottie-react-native https://github.com/airbnb/lottie-ios https://github.com/airbnb]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android App的设计架构：MVC,MVP,MVVM与架构经验谈]]></title>
    <url>%2Fposts%2Faf73114b.html</url>
    <content type="text"><![CDATA[和MVC框架模式一样，Model模型处理数据代码不变在Android的App开发中，很多人经常会头疼于App的架构如何设计： 我的App需要应用这些设计架构吗？ MVC,MVP等架构讲的是什么？区别是什么？ 本文就来带你分析一下这几个架构的特性，优缺点，以及App架构设计中应该注意的问题。 1.架构设计的目的通过设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，并且更容易进行后续的测试以及定位问题。但设计不能违背目的，对于不同量级的工程，具体架构的实现方式必然是不同的，切忌犯为了设计而设计，为了架构而架构的毛病。 举个简单的例子： 一个Android App如果只有3个Java文件，那只需要做点模块和层次的划分就可以，引入框架或者架构反而提高了工作量，降低了生产力； 但如果当前开发的App最终代码量在10W行以上，本地需要进行复杂操作，同时也需要考虑到与其余的Android开发者以及后台开发人员之间的同步配合，那就需要在架构上进行一些思考！ 2.MVC设计架构 MVC简介MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。 Android中的MVCAndroid中界面部分也采用了当前比较流行的MVC框架，在Android中： 视图层(View) 一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。 控制层(Controller) Android的控制层的重任通常落在了众多的Activity的肩上。这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Actiivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 模型层(Model) 我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的（感谢@Xander的讲解）。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。就是应用程序中二进制的数据。 MVC代码实例我们来看看MVC在Android开发中是怎么应用的吧！ 先上界面图 Controller控制器&amp;View 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends ActionBarActivity implements OnWeatherListener, View.OnClickListener &#123; private WeatherModel weatherModel; private EditText cityNOInput; private TextView city; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); weatherModel = new WeatherModelImpl(); initView(); &#125; //初始化View private void initView() &#123; cityNOInput = findView(R.id.et_city_no); city = findView(R.id.tv_city); ... findView(R.id.btn_go).setOnClickListener(this); &#125; //显示结果 public void displayResult(Weather weather) &#123; WeatherInfo weatherInfo = weather.getWeatherinfo(); city.setText(weatherInfo.getCity()); ... &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_go: weatherModel.getWeather(cityNOInput.getText().toString().trim(), this); break; &#125; &#125; @Override public void onSuccess(Weather weather) &#123; displayResult(weather); &#125; @Override public void onError() &#123; Toast.makeText(this, 获取天气信息失败, Toast.LENGTH_SHORT).show(); &#125; private T findView(int id) &#123; return (T) findViewById(id); &#125;&#125; 从上面代码可以看到，Activity持有了WeatherModel模型的对象，当用户有点击Button交互的时候，Activity作为Controller控制层读取View视图层EditTextView的数据，然后向Model模型发起数据请求，也就是调用WeatherModel对象的方法 getWeather（）方法。当Model模型处理数据结束后，通过接口OnWeatherListener通知View视图层数据处理完毕，View视图层该更新界面UI了。然后View视图层调用displayResult（）方法更新UI。至此，整个MVC框架流程就在Activity中体现出来了。 Model模型 来看看WeatherModelImpl代码实现 123456789101112131415161718192021222324252627282930public interface WeatherModel &#123; void getWeather(String cityNumber, OnWeatherListener listener);&#125;................public class WeatherModelImpl implements WeatherModel &#123; /*这部分代码范例有问题，网络访问不应该在Model中，应该把网络访问换成从数据库读取*/ @Override public void getWeather(String cityNumber, final OnWeatherListener listener) &#123; /*数据层操作*/ VolleyRequest.newInstance().newGsonRequest(http://www.weather.com.cn/data/sk/ + cityNumber + .html, Weather.class, new Response.Listener&lt;weather&gt;() &#123; @Override public void onResponse(Weather weather) &#123; if (weather != null) &#123; listener.onSuccess(weather); &#125; else &#123; listener.onError(); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; listener.onError(); &#125; &#125;); &#125;&#125; 以上代码看出，这里设计了一个WeatherModel模型接口，然后实现了接口WeatherModelImpl类。controller控制器activity调用WeatherModelImpl类中的方法发起网络请求，然后通过实现OnWeatherListener接口来获得网络请求的结果通知View视图层更新UI 。至此，Activity就将View视图显示和Model模型数据处理隔离开了。activity担当contronller完成了model和view之间的协调作用。 至于这里为什么不直接设计成类里面的一个getWeather（）方法直接请求网络数据？你考虑下这种情况：现在代码中的网络请求是使用Volley框架来实现的，如果哪天老板非要你使用Afinal框架实现网络请求，你怎么解决问题？难道是修改 getWeather（）方法的实现？ no no no，这样修改不仅破坏了以前的代码，而且还不利于维护， 考虑到以后代码的扩展和维护性，我们选择设计接口的方式来解决着一个问题，我们实现另外一个WeatherModelWithAfinalImpl类，继承自WeatherModel，重写里面的方法，这样不仅保留了以前的WeatherModelImpl类请求网络方式，还增加了WeatherModelWithAfinalImpl类的请求方式。Activity调用代码无需要任何修改。 3.MVP设计架构在App开发过程中，经常出现的问题就是某一部分的代码量过大，虽然做了模块划分和接口隔离，但也很难完全避免。从实践中看到，这更多的出现在UI部分，也就是Activity里。想象一下，一个2000+行以上基本不带注释的Activity，我的第一反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负与用户之间的操作交互，界面的展示，不是单纯的Controller或View。而且现在大部分的Activity还对整个App起到类似IOS中的【ViewController】的作用，这又带入了大量的逻辑代码，造成Activity的臃肿。为了解决这个问题，让我们引入MVP框架。 MVC的缺点在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户 界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。 什么是MVP?MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。 MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）： View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity) Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合) Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。 *View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试 Tips：*View interface的必要性 回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用 户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。 MVC → MVP当我们将Activity复杂的逻辑处理移至另外的一个类（Presenter）中时，Activity其实就是MVP模式中的View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由 Presenter处理）。 MVP的Presenter是框架的控制者，承担了大量的逻辑操作，而MVC的Controller更多时候承担一种转发的作用。因此在App中引入MVP的原因，是为了将此前在Activty中包含的大量逻辑操作放到控制层中，避免Activity的臃肿。 两种模式的主要区别： （最主要区别）View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。 因此我们可以发现MVP的优点如下： 1、模型与视图完全分离，我们可以修改视图而不影响模型； 2、可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部； 3、我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁； 4、如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。 具体到Android App中，一般可以将App根据程序的结构进行纵向划分，根据MVP可以将App分别为模型层(M)，UI层(V)和逻辑层(P)。 UI层一般包括Activity，Fragment，Adapter等直接和UI相关的类，UI层的Activity在启动之后实例化相应的Presenter，App的控制权后移，由UI转移到Presenter，两者之间的通信通过BroadCast、Handler或者接口完成，只传递事件和结果。 举个简单的例子，UI层通知逻辑层（Presenter）用户点击了一个Button，逻辑层（Presenter）自己决定应该用什么行为进行响应，该找哪个模型（Model）去做这件事，最后逻辑层（Presenter）将完成的结果更新到UI层。 MVP的变种：Passive ViewMVP的变种有很多，其中使用最广泛的是Passive View模式，即被动视图。在这种模式下，View和Model之间不能直接交互，View通过Presenter与Model打交道。Presenter接受View的UI请求，完成简单的UI处理逻辑，并调用Model进行业务处理，并调用View将相应的结果反映出来。View直接依赖Presenter，但是Presenter间接依赖View，它直接依赖的是View实现的接口。 相对于View的被动，那Presenter就是主动的一方。对于Presenter的主动，有如下的理解： Presenter是整个MVP体系的控制中心，而不是单纯的处理View请求的人； View仅仅是用户交互请求的汇报者，对于响应用户交互相关的逻辑和流程，View不参与决策，真正的决策者是Presenter； View向Presenter发送用户交互请求应该采用这样的口吻：“我现在将用户交互请求发送给你，你看着办，需要我的时候我会协助你”，不应该是这样：“我现在处理用户交互请求了，我知道该怎么办，但是我需要你的支持，因为实现业务逻辑的Model只信任你”； 对于绑定到View上的数据，不应该是View从Presenter上“拉”回来的，应该是Presenter主动“推”给View的； View尽可能不维护数据状态，因为其本身仅仅实现单纯的、独立的UI操作；Presenter才是整个体系的协调者，它根据处理用于交互的逻辑给View和Model安排工作。 MVP架构存在的问题与解决办法 加入模板方法（Template Method） 转移逻辑操作之后可能部分较为复杂的Activity内代码量还是不少，于是需要在分层的基础上再加入模板方法（Template Method）。 具体做法是在Activity内部分层。其中最顶层为BaseActivity，不做具体显示，而是提供一些基础样式，Dialog，ActionBar在内的内容，展现给用户的Activity继承BaseActivity，重写BaseActivity预留的方法。如有必要再进行二次继承，App中Activity之间的继承次数最多不超过3次。 Model内部分层 模型层（Model）中的整体代码量是最大的，一般由大量的Package组成，针对这部分需要做的就是在程序设计的过程中，做好模块的划分，进行接口隔离，在内部进行分层。 强化Presenter 强化Presenter的作用，将所有逻辑操作都放在Presenter内也容易造成Presenter内的代码量过大，对于这点，有一个方法是在UI层和Presenter之间设置中介者Mediator，将例如数据校验、组装在内的轻量级逻辑操作放在Mediator中；在Presenter和Model之间使用代理Proxy；通过上述两者分担一部分Presenter的逻辑操作，但整体框架的控制权还是在Presenter手中。Mediator和Proxy不是必须的，只在Presenter负担过大时才建议使用。 最终的架构如下图所示： MVP代码实例我们来看看MVP在Android开发中是怎么应用的吧！！ 我们用另一个例子来解释。 先来看包结构图 建立Bean 1234567891011121314public class UserBean &#123; private String mFirstName; private String mLastName; public UserBean(String firstName, String lastName) &#123; this. mFirstName = firstName; this. mLastName = lastName; &#125; public String getFirstName() &#123; return mFirstName; &#125; public String getLastName() &#123; return mLastName; &#125;&#125; 建立Model （处理业务逻辑，这里指数据读写），先写接口，后写实现 1234567891011public interface IUserModel &#123; void setID(int id); void setFirstName(String firstName); void setLastName(String lastName); int getID(); UserBean load(int id);// 通过id读取user信息,返回一个UserBean&#125; 实现不在这里写了 Presenter控制器 建立presenter（主导器，通过iView和iModel接口操作model和view），activity可以把所有逻辑给presenter处理，这样java逻辑就从手机的activity中分离出来。 123456789101112131415161718192021public class UserPresenter &#123; private IUserView mUserView; private IUserModel mUserModel; public UserPresenter(IUserView view) &#123; mUserView = view; mUserModel = new UserModel(); &#125; public void saveUser( int id, String firstName, String lastName) &#123; mUserModel.setID(id); mUserModel.setFirstName(firstName); mUserModel.setLastName(lastName); &#125; public void loadUser( int id) &#123; UserBean user = mUserModel.load(id); mUserView.setFirstName(user.getFirstName()); // 通过调用IUserView的方法来更新显示 mUserView.setLastName(user.getLastName()); &#125;&#125; View视图 建立view（更新ui中的view状态），这里列出需要操作当前view的方法，也是接口 1234567891011public interface IUserView &#123; int getID(); String getFristName(); String getLastName(); void setFirstName(String firstName); void setLastName(String lastName);&#125; activity中实现iview接口，在其中操作view，实例化一个presenter变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends Activity implements OnClickListener,IUserView &#123; UserPresenter presenter; EditText id,first,last; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout. activity_main); findViewById(R.id. save).setOnClickListener( this); findViewById(R.id. load).setOnClickListener( this); id = (EditText) findViewById(R.id. id); first = (EditText) findViewById(R.id. first); last = (EditText) findViewById(R.id. last); presenter = new UserPresenter( this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id. save: presenter.saveUser(getID(), getFristName(), getLastName()); break; case R.id. load: presenter.loadUser(getID()); break; default: break; &#125; &#125; @Override public int getID() &#123; return new Integer( id.getText().toString()); &#125; @Override public String getFristName() &#123; return first.getText().toString(); &#125; @Override public String getLastName() &#123; return last.getText().toString(); &#125; @Override public void setFirstName(String firstName) &#123; first.setText(firstName); &#125; @Override public void setLastName(String lastName) &#123; last.setText(lastName); &#125;&#125; 因此，Activity及从MVC中的Controller中解放出来了，这会Activity主要做显示View的作用和用户交互。每个Activity可以根据自己显示View的不同实现View视图接口IUserView。 通过对比同一实例的MVC与MVP的代码，可以证实MVP模式的一些优点： 在MVP中，Activity的代码不臃肿； 在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会； 在MVP中，IUserView这个接口可以实现方便地对Presenter的测试； 在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。 4.MVC、MVP与MVVM的关系首先介绍下MVVM。 MVVMMVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。 在比较之前，先从图上看看三者的异同。 刚开始理解这些概念的时候认为这几种模式虽然都是要将view和model解耦，但是非此即彼，没有关系，一个应用只会用一种模式。后来慢慢发现世界绝对不是只有黑白两面，中间最大的一块其实是灰色地带，同样，这几种模式的边界并非那么明显，可能你在自己的应用中都会用到。实际上也根本没必要去纠结自己到底用的是MVC、MVP还是MVVP，不管黑猫白猫，捉住老鼠就是好猫。 MVC-&gt;MVP-&gt;MVVM演进过程MVC -&gt; MVP -&gt; MVVM 这几个软件设计模式是一步步演化发展的，MVVM 是从 MVP 的进一步发展与规范，MVP 隔离了MVC中的 M 与 V 的直接联系后，靠 Presenter 来中转，所以使用 MVP 时 P 是直接调用 View 的接口来实现对视图的操作的，这个 View 接口的东西一般来说是 showData、showLoading等等。M 与 V已经隔离了，方便测试了，但代码还不够优雅简洁，所以 MVVM 就弥补了这些缺陷。在 MVVM 中就出现的 Data Binding 这个概念，意思就是 View 接口的 showData 这些实现方法可以不写了，通过 Binding 来实现。 同如果把这三者放在一起比较，先说一下三者的共同点，也就是Model和View： Model：数据对象，同时，提供本应用外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。 View：UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。 异三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知 Controller Controller接收View的操作事件，根据事件不同，或者调用Model的接口进行数据操作，或者进行View的跳转，从而也意味着一个Controller可以对应多个View。Controller对View的实现不太关心，只会被动地接收，Model的数据变更不通过Controller直接通知View，通常View采用观察者模式监听Model的变化。 Presenter Presenter与Controller一样，接收View的命令，对Model进行操作；与Controller不同的是Presenter会反作用于View，Model的变更通知首先被Presenter获得，然后Presenter再去更新View。一个Presenter只对应于一个View。根据Presenter和View对逻辑代码分担的程度不同，这种模式又有两种情况：Passive View和Supervisor Controller。 ViewModel 注意这里的“Model”指的是View的Model，跟MVVM中的一个Model不是一回事。所谓View的Model就是包含View的一些数据属性和操作的这么一个东东，这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。 一点心得MVP和MVVM完全隔离了Model和View，但是在有些情况下，数据从Model到ViewModel或者Presenter的拷贝开销很大，可能也会结合MVC的方式，Model直接通知View进行变更。在实际的应用中很有可能你已经在不知不觉中将几种模式融合在一起，但是为了代码的可扩展、可测试性，必须做到模块的解耦，不相关的代码不要放在一起。网上有一个故事讲，一个人在一家公司做一个新产品时，一名外包公司的新员工直接在View中做了数据库持久化操作，而且一个hibernate代码展开后发现竟然有几百行的SQL语句，搞得他们惊讶不已，一时成为笑谈。 个人理解，在广义地谈论MVC架构时，并非指本文中严格定义的MVC，而是指的MV*，也就是视图和模型的分离，只要一个框架提供了视图和模型分离的功能，我们就可以认为它是一个MVC框架。在开发深入之后，可以再体会用到的框架到底是MVC、MVP还是MVVM。 5. 基于AOP的框架设计AOP(Aspect-Oriented Programming, 面向切面编程)，诞生于上个世纪90年代，是对OOP(Object-Oriented Programming, 面向对象编程)的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（Cross-Cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。 5.1 AOP在Android中的使用AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。在Android App中，哪些是我们需要的横切关注点？个人认为主要包括以下几个方面：Http, SharedPreferences, Json, Xml, File, Device, System, Log, 格式转换等。Android App的需求差别很大，不同的需求横切关注点必然是不一样的。一般的App工程中应该有一个Util Package来存放相关的切面操作，在项目多了之后可以将其中使用较多的Util封装为一个Jar包供工程调用。 在使用MVP和AOP对App进行纵向和横向的切割之后，能够使得App整体的结构更清晰合理，避免局部的代码臃肿，方便开发、测试以及后续的维护。 6. 干货：AndroidApp架构的设计经验首先是作者最最喜欢的一句话，也是对创业公司特别适用的一句话，也是对不要过度设计的一种诠释： 先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了（重要的事情说三遍) 6.1 整体架构代码和文档规范，根据需求进行模块划分，确定交互方式，形成接口文档，这些较为通用的内容不再细说。做Android App时，一般将App进行纵向和横向的划分。纵向的App由UI层，逻辑层和模型层构成，整体结构基于MVP思想(图片来自网络)。 UI层内部多用模板方法，以Activity为例一般有BaseActivity，提供包括一些基础样式，Dialog，ActionBar在内的内容，展现的Activity都会继承BaseActivity并实现预留的接口，Activity之间的继承不超过3次；为避免Activity内代码过多，将App的整体控制权后移，也借鉴了IOC做法，大量的逻辑操作放在逻辑层中，逻辑层和UI层通过接口或者Broadcast等实现通信，只传递结果。一般Activity里的代码量都很大，通过这两种方式一般我写的单个Activity内代码量不超过400行。 逻辑层实现的是绝大部分的逻辑操作，由UI层启动，在内部通过接口调用模型层的方法，在逻辑层内大量使用了代理。打个比方，UI层告诉逻辑层我需要做的事，逻辑层去找相应的人(模型层)去做，最后只告诉UI这件事做的结果。 模型层没什么好说的，这部分一般由大量的Package组成，代码量是三层中最大的，需要在内部进行分层。 横向的分割依据AOP面向切面的思想，主要是提取出共用方法作为一个单独的Util，这些Util会在App整体中穿插使用。很多人的App都会引入自己封装的Jar包，封装了包括文件、JSON、SharedPreference等在内的常用操作，自己写的用起来顺手，也大幅度降低了重复作业。 这样纵，横两次对于App代码的分割已经能使得程序不会过多堆积在一个Java文件里，但靠一次开发过程就写出高质量的代码是很困难的，趁着项目的间歇期，对代码进行重构很有必要。 6.2 类库的使用现在有很多帮助快速开发的类库，活用这些类库也是避免代码臃肿和混乱的好方法，下面给题主推荐几个常用类库。 减少Activity代码量的依赖注入框架ButterKnife: https://github.com/JakeWharton/butterknife 简化对于SQlite操作的对象关系映射框架OrmLite: https://github.com/j256/ormlite-android 图片缓存类库Fresco(by facebook): https://github.com/facebook/fresco 能用第三方库就用第三方库。别管是否稳定，是否被持续维护，因为，任何第三方库的作者，都能碾压刚入门的菜鸟，你绝对写不出比别人更好的代码了。 最后附上知乎上面点赞次数很高的一段话： 如果“从零开始”，用什么设计架构的问题属于想得太多做得太少的问题。 从零开始意味着一个项目的主要技术难点是基本功能实现。当每一个功能都需要考虑如何做到的时候，我觉得一般人都没办法考虑如何做好。 因为，所有的优化都是站在最上层进行统筹规划。在这之前，你必须对下层的每一个模块都非常熟悉，进而提炼可复用的代码、规划逻辑流程。 所以，如果真的是从零开始，别想太多了 参考文献： 1、http://blog.csdn.net/luyi325xyz/article/details/43085409 2、http://blog.csdn.net/napolunyishi/article/details/22722345 3、https://www.zhihu.com/question/27645587/answer/37579829 4、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0202/2397.html 5、http://www.tuicool.com/articles/VJZrYb 6、https://www.zhihu.com/question/27645587 7、http://blog.csdn.net/luyi325xyz/article/details/43482123 8、https://www.zhihu.com/question/30976423 9、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0313/2599.html 10、http://www.2cto.com/kf/201506/405766.html 11、https://www.zhihu.com/question/19766132 12、http://www.cnblogs.com/artech/archive/2010/03/25/1696205.html 13、https://segmentfault.com/a/1190000003927200 14、http://blog.csdn.net/knxw0001/article/details/39637273 版权声明 周鸿博]]></content>
      <categories>
        <category>Android</category>
        <category>设计架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发总结(思维导图)]]></title>
    <url>%2Fposts%2F737b202d.html</url>
    <content type="text"><![CDATA[概述结合自己的理解，用 xmind（思维导图工具） 总结了 Android 应用开发的一些知识点，方便快速梳理整体的知识体系。]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制详解攻略，您值得拥有]]></title>
    <url>%2Fposts%2F92ff150b.html</url>
    <content type="text"><![CDATA[前言转自：https://blog.csdn.net/carson_ho/article/details/54136311 Android事件分发机制是Android开发者必须了解的基础 网上有大量关于Android事件分发机制的文章，但存在一些问题：内容不全、思路不清晰、无源码分析、简单问题复杂化等等 今天，我将全面总结Android的事件分发机制，我能保证这是市面上的最全面、最清晰、最易懂的 本文秉着“结论先行、详细分析在后”的原则，即先让大家感性认识，再通过理性分析从而理解问题； 所以，请各位读者先记住结论，再往下继续看分析； 文章较长，阅读需要较长时间，建议收藏等充足时间再进行阅读 目录 1. 基础认知1.1 事件分发的对象是谁？答：点击事件（Touch事件） 定义当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件） Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象 事件类型（4种） 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下View（所有事件的开始） MotionEvent.ACTION_UP 抬起View（与DOWN对应） MotionEvent.ACTION_MOVE 滑动View MotionEvent.ACTION_CANCEL 结束事件（非人为原因） 特别说明：事件列 从手指接触屏幕 至 手指离开屏幕，这个过程产生的一系列事件 注：一般情况下，事件列都是以DOWN事件开始、UP事件结束，中间有无数的MOVE事件，如下图： 即当一个点击事件（MotionEvent ）产生后，系统需把这个事件传递给一个具体的 View 去处理。 1.2 事件分发的本质答：将点击事件（MotionEvent）传递到某个具体的View &amp; 处理的整个过程 即 事件传递的过程 = 分发过程。 1.3 事件在哪些对象之间进行传递？答：Activity、ViewGroup、View Android的UI界面由Activity、ViewGroup、View 及其派生类组成 1.4 事件分发的顺序即 事件传递的顺序：Activity -&gt; ViewGroup -&gt; View 即：1个点击事件发生后，事件先传到Activity、再传到ViewGroup、最终再传到 View 1.5 事件分发过程由哪些方法协作完成？答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 下文会对这3个方法进行详细介绍 1.6 总结 至此，相信大家已经对 Android的事件分发有了感性的认知 下面，我将详细介绍Android事件分发机制 2. 事件分发机制 源码分析 请谨记：Android事件分发流程 = Activity -&gt; ViewGroup -&gt; View 即：1个点击事件发生后，事件先传到Activity、再传到ViewGroup、最终再传到 View 从上可知，要想充分理解Android分发机制，本质上是要理解： Activity对点击事件的分发机制 ViewGroup对点击事件的分发机制 View对点击事件的分发机制 下面，我将通过源码，全面解析 事件分发机制 即按顺序讲解：Activity事件分发机制、ViewGroup事件分发机制、View事件分发机制 2.1 Activity的事件分发机制当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发 2.1.1 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 源码分析：Activity.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); // -&gt;&gt;分析1 &#125; // -&gt;&gt;分析2 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent &#125; // -&gt;&gt;分析4 return onTouchEvent(ev); &#125;/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */ public void onUserInteraction() &#123; &#125; // 回到最初的调用原处/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 // -&gt;&gt; 分析3 &#125;/** * 分析3：mDecor.superDispatchTouchEvent(event) * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); // 调用父类的方法 = ViewGroup的dispatchTouchEvent() // 即 将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制 &#125; // 回到最初的调用原处/** * 分析4：Activity.onTouchEvent（） * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean onTouchEvent(MotionEvent event) &#123; // 当一个点击事件未被Activity下任何一个View接收 / 处理时 // 应用场景：处理发生在Window边界外的触摸事件 // -&gt;&gt; 分析5 if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false; // 即 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕 &#125;/** * 分析5：mWindow.shouldCloseOnTouch(this, event) */ public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; // 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等 if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) &#123; return true; &#125; return false; // 返回true：说明事件在边界外，即 消费事件 // 返回false：未消费（默认）&#125;// 回到分析4调用原处 2.1.2 总结 当一个点击事件发生时，从Activity的事件分发开始（Activity.dispatchTouchEvent()） 方法总结 那么，ViewGroup的dispatchTouchEvent()什么时候返回true / false？请继续往下看ViewGroup事件的分发机制 2.2 ViewGroup事件的分发机制从上面Activity事件分发机制可知，ViewGroup事件分发机制从dispatchTouchEvent()开始 2.2.1 源码分析 Android 5.0后，ViewGroup.dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同； 本文为了让读者容易理解，故采用Android 5.0前的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 源码分析：ViewGroup.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... // 仅贴出关键代码 // 重点分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件 if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; // 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改 // 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反 // a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部 // b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断 // c. 关于onInterceptTouchEvent() -&gt;&gt;分析1 ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; // 重点分析2 // 通过for循环，遍历了当前ViewGroup下的所有子View for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); // 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View // 若是，则进入条件判断内部 if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; // 条件判断的内部调用了该View的dispatchTouchEvent() // 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制） if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; // 调用子View的dispatchTouchEvent后是有返回值的 // 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立 // 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出 // 即把ViewGroup的点击事件拦截掉 &#125; &#125; &#125; &#125; &#125; &#125; boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; // 重点分析3 // 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true） if (target == null) &#123; ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; return super.dispatchTouchEvent(ev); // 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent() // 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（）） // 此处需与上面区别：子View的dispatchTouchEvent（） &#125; ... &#125;/** * 分析1：ViewGroup.onInterceptTouchEvent() * 作用：是否拦截事件 * 说明： * a. 返回true = 拦截，即事件停止往下传递（需手动设置，即复写onInterceptTouchEvent（），从而让其返回true） * b. 返回false = 不拦截（默认） */ public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; // 回到调用原处 2.2.2 总结 结论：Android事件分发总是先传递到ViewGroup、再传递到View 过程：当点击了某个控件时 核心方法总结 2.2.3 Demo讲解 布局如下 测试代码 布局文件：activity_main.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/my_layout" android:layout_width="match_parent" android:layout_height="match_parent" xmlns:app="http://schemas.android.com/apk/res-auto" android:focusableInTouchMode="true" android:orientation="vertical"&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮1" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮2" /&gt;&lt;/LinearLayout&gt; 核心代码：MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * ViewGroup布局（myLayout）中有2个子View = 2个按钮 */ public class MainActivity extends AppCompatActivity &#123; Button button1,button2; ViewGroup myLayout; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1 = (Button)findViewById(R.id.button1); button2 = (Button)findViewById(R.id.button2); myLayout = (LinearLayout)findViewById(R.id.my_layout); // 1.为ViewGroup布局设置监听事件 myLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了ViewGroup"); &#125; &#125;); // 2. 为按钮1设置监听事件 button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了button1"); &#125; &#125;); // 3. 为按钮2设置监听事件 button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了button2"); &#125; &#125;); &#125;&#125; 结果测试 从上面的测试结果发现： 点击Button时，执行Button.onClick()，但ViewGroupLayout注册的onTouch（）不会执行 只有点击空白区域时，才会执行ViewGroupLayout的onTouch（） 结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。 2.3 View事件的分发机制从上面ViewGroup事件分发机制知道，View事件分发机制从dispatchTouchEvent()开始 2.3.1 源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 源码分析：View.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; // 说明：只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent() // 1. mOnTouchListener != null // 2. (mViewFlags &amp; ENABLED_MASK) == ENABLED // 3. mOnTouchListener.onTouch(this, event) // 下面对这3个条件逐个分析/** * 条件1：mOnTouchListener != null * 说明：mOnTouchListener变量在View.setOnTouchListener（）方法里赋值 */ public void setOnTouchListener(OnTouchListener l) &#123; mOnTouchListener = l; // 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）&#125; /** * 条件2：(mViewFlags &amp; ENABLED_MASK) == ENABLED * 说明： * a. 该条件是判断当前点击的控件是否enable * b. 由于很多View默认enable，故该条件恒定为true *//** * 条件3：mOnTouchListener.onTouch(this, event) * 说明：即 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例） */ button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; return false; &#125; &#125;); // 若在onTouch（）返回true，就会让上述三个条件全部成立，从而使得View.dispatchTouchEvent（）直接返回true，事件分发结束 // 若在onTouch（）返回false，就会使得上述三个条件不全部成立，从而使得View.dispatchTouchEvent（）中跳出If，执行onTouchEvent(event) 接下来，我们继续看：onTouchEvent(event)的源码分析 详情请看注释 Android 5.0后 View.onTouchEvent()源码发生了变化（更加复杂），但原理相同； 本文为了让读者更好理解，所以采用Android 5.0前的版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * 源码分析：View.onTouchEvent（） */ public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 若该控件可点击，则进入switch判断中 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; // a. 若当前的事件 = 抬起View（主要分析） case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; ...// 经过种种判断，此处省略 // 执行performClick() -&gt;&gt;分析1 performClick(); break; // b. 若当前的事件 = 按下View case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; // c. 若当前的事件 = 结束事件（非人为原因） case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; // d. 若当前的事件 = 滑动View case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; // 若该控件可点击，就一定返回true return true; &#125; // 若该控件不可点击，就一定返回false return false; &#125;/** * 分析1：performClick（） */ public boolean performClick() &#123; if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; // 只要我们通过setOnClickListener（）为控件View注册1个点击事件 // 那么就会给mOnClickListener变量赋值（即不为空） // 则会往下回调onClick（） &amp; performClick（）返回true &#125; return false; &#125; 2.3.2 总结 每当控件被点击时： 注：onTouch（）的执行 先于 onClick（） 核心方法总结 2.3.3 Demo讲解下面我将用Demo验证上述的结论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 结论验证1：在回调onTouch()里返回false */ // 1. 通过OnTouchListener()复写onTouch()，从而手动设置返回false button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return false; &#125; &#125;); // 2. 通过 OnClickListener（）为控件设置点击事件，为mOnClickListener变量赋值（即不为空），从而往下回调onClick（） button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;);/** * 结论验证2：在回调onTouch()里返回true */ // 1. 通过OnTouchListener()复写onTouch()，从而手动设置返回true button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return true; &#125; &#125;); // 2. 通过 OnClickListener（）为控件设置点击事件，为mOnClickListener变量赋值（即不为空） // 但由于dispatchTouchEvent（）返回true，即事件不再向下传递，故不调用onClick()） button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;); 测试结果 2.4 总结 若您已经看到此处，那么恭喜你，你已经能非常熟悉掌握Android的事件分发机制了 即：Activity、ViewGroup、View 的事件分发机制 3. 工作流程 总结 在本节中，我将结合源码，梳理出1个事件分发的工作流程总结，具体如下： 左侧虚线：具备相关性 &amp; 逐层返回 以角色为核心的图解说明 以方法为核心的图解说明 4. 核心方法总结 已知事件分发过程的核心方法为：dispatchTouchEvent()、onInterceptTouchEvent() 和 onTouchEvent() 下面，我将结合总结的工作流程，再次详细讲解该3个方法 4.1 dispatchTouchEvent() 简介 返回情况说明 情况1：默认 情况2：返回true 情况3：返回false 4.2 onInterceptTouchEvent() 简介 注：Activity、View都无该方法 返回情况说明 情况1：true 情况2：false（默认） 4.3 onTouchEvent() 简介 返回情况说明 情况1：返回true 情况2：返回false（default） 4.4 三者关系下面，我用一段伪代码来阐述上述3个方法的关系 &amp; 事件传递规则 1234567891011121314151617181920212223242526/** * 点击事件产生后 */ // 步骤1：调用dispatchTouchEvent（） public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; //代表 是否会消费事件 // 步骤2：判断是否拦截事件 if (onInterceptTouchEvent(ev)) &#123; // a. 若拦截，则将该事件交给当前View进行处理 // 即调用onTouchEvent (）方法去处理点击事件 consume = onTouchEvent (ev) ; &#125; else &#123; // b. 若不拦截，则将该事件传递到下层 // 即 下层元素的dispatchTouchEvent（）就会被调用，重复上述过程 // 直到点击事件被最终处理为止 consume = child.dispatchTouchEvent (ev) ; &#125; // 步骤3：最终返回通知 该事件是否被消费（接收 &amp; 处理） return consume; &#125; 5. 常见的事件分发场景下面，我将通过实例说明常见的事件传递情况 &amp; 流程 5.1 背景描述 讨论的布局如下： 情景 用户先触摸到屏幕上View C上的某个点（图中黄区） Action_DOWN事件在此处产生 用户移动手指 最后离开屏幕 5.2 一般的事件传递情况一般的事件传递场景有： 默认情况 处理事件 拦截DOWN事件 拦截后续事件（MOVE、UP） 场景1：默认 即不对控件里的方法（dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent()）进行重写 或 更改返回值 那么调用的是这3个方法的默认实现：调用下层的方法 &amp; 逐层返回 事件传递情况：（呈U型） 1.从上往下调用dispatchTouchEvent() Activity A -&gt;&gt; ViewGroup B -&gt;&gt; View C2.从下往上调用onTouchEvent() View C -&gt;&gt; ViewGroup B -&gt;&gt; Activity A 注：虽然ViewGroup B的onInterceptTouchEvent（）对DOWN事件返回了false，但后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent() 这一点与onTouchEvent（）的行为是不一样的：不再传递 &amp; 接收该事件列的其他事件 场景2：处理事件设View C希望处理该点击事件，即：设置View C为可点击的（Clickable） 或 复写其onTouchEvent（）返回true 最常见的：设置Button按钮来响应点击事件 事件传递情况：（如下图） DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理该事件 因为View C正在处理该事件，那么DOWN事件将不再往上传递给ViewGroup B 和 Activity A的onTouchEvent()； 该事件列的其他事件（Move、Up）也将传递给View C的onTouchEvent() 会逐层往dispatchTouchEvent() 返回，最终事件分发结束 场景3：拦截DOWN事件假设ViewGroup B希望处理该点击事件，即ViewGroup B复写了onInterceptTouchEvent()返回true、onTouchEvent()返回true事件传递情况：（如下图） DOWN事件被传递给ViewGroup B的onInterceptTouchEvent()，该方法返回true，表示拦截该事件，即自己处理该事件（事件不再往下传递） 调用自身的onTouchEvent()处理事件（DOWN事件将不再往上传递给Activity A的onTouchEvent()） 该事件列的其他事件（Move、Up）将直接传递给ViewGroup B的onTouchEvent() 注： 该事件列的其他事件（Move、Up）将不会再传递给ViewGroup B的onInterceptTouchEvent（）；因：该方法一旦返回一次true，就再也不会被调用 逐层往dispatchTouchEvent() 返回，最终事件分发结束 场景4：拦截DOWN的后续事件结论 若 ViewGroup 拦截了一个半路的事件（如MOVE），该事件将会被系统变成一个CANCEL事件 &amp; 传递给之前处理该事件的子View； 该事件不会再传递给ViewGroup 的onTouchEvent() 只有再到来的事件才会传递到ViewGroup的onTouchEvent() 场景描述ViewGroup B 无拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件 即 DOWN事件传递到View C的onTouchEvent（），返回了true 实例讲解 在后续到来的MOVE事件，ViewGroup B 的onInterceptTouchEvent（）返回true拦截该MOVE事件，但该事件并没有传递给ViewGroup B ；这个MOVE事件将会被系统变成一个CANCEL事件传递给View C的onTouchEvent（） 后续又来了一个MOVE事件，该MOVE事件才会直接传递给ViewGroup B 的onTouchEvent() 后续事件将直接传递给ViewGroup B 的onTouchEvent()处理，而不会再传递给ViewGroup B 的onInterceptTouchEvent（），因该方法一旦返回一次true，就再也不会被调用了。 View C再也不会收到该事件列产生的后续事件 至此，关于Android常见的事件传递情况 &amp; 流程已经讲解完毕。 6. 额外知识6.1 Touch事件的后续事件（MOVE、UP）层级传递 6.1 Touch事件的后续事件（MOVE、UP）层级传递 若给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等） 当dispatchTouchEvent（）事件分发时，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP） 即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE、ACTION_UP事件都不会执行从上面对事件分发机制分析知： dispatchTouchEvent()、 onTouchEvent() 消费事件、终结事件传递（返回true） 而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用 请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP）这里给出ACTION_MOVE和ACTION_UP事件的传递结论： 结论1若对象（Activity、ViewGroup、View）的dispatchTouchEvent()分发事件后消费了事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE 、 ACTION_UP事件传递方向 结论2若对象（Activity、ViewGroup、View）的onTouchEvent()处理了事件（返回true），那么ACTION_MOVE、ACTION_UP的事件从上往下传到该View后就不再往下传递，而是直接传给自己的onTouchEvent()&amp; 结束本次事件传递过程。 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE、ACTION_UP事件传递方向 6.2 onTouch()和onTouchEvent()的区别 该2个方法都是在View.dispatchTouchEvent（）中调用 但onTouch（）优先于onTouchEvent执行；若手动复写在onTouch（）中返回true（即 将事件消费掉），将不会再执行onTouchEvent（） 注：若1个控件不可点击（即非enable），那么给它注册onTouch事件将永远得不到执行，具体原因看如下代码 12345678// &amp;&amp;为短路与，即如果前面条件为false，将不再往下执行// 故：onTouch（）能够得到执行需2个前提条件： // 1. mOnTouchListener的值不能为空 // 2. 当前点击的控件必须是enable的mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)// 对于该类控件，若需监听它的touch事件，就必须通过在该控件中重写onTouchEvent（）来实现12345678 7. 总结 通过阅读本文，相信您已经可以全面了解Android事件分发机制 与Android事件分发最相关的知识：自定义View系列文章自定义View基础 - 最易懂的自定义View原理系列（1）自定义View Measure过程 - 最易懂的自定义View原理系列（2）自定义View Layout过程 - 最易懂的自定义View原理系列（3）自定义View Draw过程- 最易懂的自定义View原理系列（4） 接下来我将继续介绍与Android事件分发最相关的知识：自定义View，有兴趣可以继续关注Carson_Ho的安卓开发笔记]]></content>
      <categories>
        <category>Android</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwitchHosts!]]></title>
    <url>%2Fposts%2F1bc98c52.html</url>
    <content type="text"><![CDATA[SwitchHosts! 英文 主页：https://oldj.github.io/SwitchHosts/ 这是一个用于快速切换 hosts 文件的小程序，基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。 截图 功能特性 快速切换 hosts hosts 文件语法高亮 在线 hosts 方案 系统托盘图标快速切换 macOS: 支持 Alfred workflow 快速切换 安装下载安装你可以直接下载源码到本地运行或编辑，或者在下面下载可执行版本： SwitchHosts! 下载地址1（GitHub release） SwitchHosts! 下载地址2（百度网盘） brew在 macOS 上，也可以使用 brew cast 安装，命令如下： 1brew cask install switchhosts 感谢 @gobinathm、@iamybj 更新 brew cask 版本。 文件备份SwitchHosts! 的数据文件在 ~/.SwitchHosts 目录下（Windows 用户为个人主目录下的 .SwitchHosts 目录下），其中 ~/.SwitchHosts/data.json 是 hosts 数据文件，~/.SwitchHosts/prefereces.json 是配置信息。 运行/打包方法环境配置 安装 Node.js 环境； 在根目录 ./ 下，运行 npm install 命令，安装开发依赖库； 在 ./app 目录下，运行 npm install 命令，安装 App 运行依赖库； 12npm installcd app &amp;&amp; npm install &amp;&amp; cd .. 构建及运行 在 ./ 目录下，运行 npm run dll 命令，构建公共文件（仅需在第一次构建或公共库发生改变时执行）； 在 ./ 目录下，运行 npm run build 命令，构建所需文件； 在 ./ 目录下，运行 npm start 命令，即可运行程序。 1234567891011# create dll filenpm run dll# buildnpm run build# startnpm start# or start in developer modenpm run dev 打包发布 建议使用 electron-packager 进行打包 12# install electron-packager for use from clinpm install electron-packager -g 在 ./ 目录下，运行 npm run pack 命令，打包后的文件位于 ./dist 目录； 首次执行此命令可能需要花费较多时间（需要下载对应的构建文件），也可先手动下载对应的发布版本（淘宝镜像），手动保存到 ~/.electron 目录下。更多信息请参考 Electron 文档。 123456# packnpm run pack # the packed files will be in ./dist# 也可以只打包特定平台的版本，如npm run pack-mac # pack for macOS, the packed files will be in ./distnpm run pack-win # pack for Windows, the packed files will be in ./dist 打包完成后，可运行以下命令将生成的程序压缩为 zip 文件。 12# zipnpm run zip # the zipped files will be in ./dist 更新历史v3.3 2017-05-30 引入 Ant Design 重写部分 UI 组件 2017-04-03 支持通过 Alfred 快速切换（下载 workflow） 2017-04-01 代码重构，增加「分组」功能 v3.2 2016-09-06 使用 Electron 打包，增加 Windows 版下载。 v3.1 2016-04-29 更新自动清除 DNS 缓存功能 #90。 2016-01-15 搜索时增加模糊搜索支持（eg. go*le matches google）及正则支持（eg. /go.*le matches google）。 2016-01-10 远程方案可以设置自动更新时间。 2015-12-26 实现 Tray 菜单切换、Dock 图标隐藏、方案导入导出等功能。 2015-12-20 从 Electron 切换至 MacGap 。 v3.0 2015-11-30 完成 3.0 版基本功能。 v2.0 2013-02-06 解决 Linux/Mac 下没有修改系统 hosts 文件权限的问题。 2012-12-27 启动时检查是否为单一实例，禁止同时运行多个实例。 2012-11-16 接受 @charlestang 网友的 pull request，同时参考了 @allenm 的修改，实现了 Common Hosts 功能。 2012-11-09 简单优化：Common Hosts 不允许删除，不允许“切换到”，将右键菜单相关条目禁用，允许更换图标颜色。修复新增在线方案时，url 框默认禁用的小 bug。 2012-10-09 增加 hosts 方案拖拽排序功能。 2012-10-05 修复在中文目录下程序无法正常启动的问题。 2012-09-30 初步完成 0.2.0 版。 v1.0 2011-12-14 允许输入超长的 hosts 方案。 2011-10-09 发布 0.1.6 版，修复若干 bug，增加自动检查最新版本的功能。 2011-09-29 发布 0.1.5 版，新增 hosts 内容语法高亮。 2011-09-28 发布 0.1.4 版，新增“添加”、“删除”按钮；hosts 内容修改后自动保存；修复若干 bug。 2011-09-19 发布 0.1.3 版，修复若干 bug。 2011-09-15 发布 0.1.2 版，添加主面板，可以在主面板上对 hosts 进行增加、删除、编辑、重命名等操作。 2011-09-02 发布 0.1.0 版，完成基本功能。 版权本程序完全免费，并基于 MIT 协议开源。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout完全解析,快来优化你的布局吧]]></title>
    <url>%2Fposts%2Fa495ccb1.html</url>
    <content type="text"><![CDATA[Demo地址：ConstraintLayout 一、概述ConstraintLayout出现有一段时间了，不过一直没有特别去关注，也多多少少看了一些文字介绍，多数都是对使用可视化布局拖拽，个人对拖拽一直不看好，直到前段时间看到该文： 解析ConstraintLayout的性能优势 非常详尽的介绍了ConstraintLayout的性能优势，于是乎开始学习了一下ConstraintLayout。 本文的重点不在与可视化界面的学习，而在于如何手写各类约束布局属性。对于可视化界面学习推荐： Android新特性介绍，ConstraintLayout完全解析 下面开始进入正题，大家都知道，当布局嵌套深入比较深的时候，往往会伴随着一些性能问题。所以很多时候我们建议使用RelativeLayout或者GridLayout来简化掉布局的深度。 而对于简化布局深度，ConstraintLayout几乎可以做到极致，接下来我们通过实例来尽可能将所有常见的属性一步步的介绍清楚。 首先需要引入我们的ConstraintLayout，在build.gradle中加入： 1compile 'com.android.support.constraint:constraint-layout:1.0.2' 二、来编写一个Feed Item我们先看一个简单的新闻列表中常见的feed item。 看到这样的布局，大家条件反射应该就是使用RelativeLayout来做，当然了，本案例我们使用ConstraintLayout来写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#11ff0000" tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:id="@+id/tv1" android:layout_width="140dp" android:layout_height="86dp" android:layout_marginLeft="12dp" android:layout_marginTop="12dp" android:background="#fd3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/tv2" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginRight="12dp" android:text="马云:一年交税170多亿马云:一年交税170多亿马云:一年交税170多亿" android:textColor="#000000" android:textSize="16dp" app:layout_constraintLeft_toRightOf="@id/tv1" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="@id/tv1" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginTop="12dp" android:text="8分钟前" android:textColor="#333" android:textSize="12dp" app:layout_constraintLeft_toRightOf="@id/tv1" app:layout_constraintBottom_toBottomOf="@id/tv1" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 看上面的布局，我们好像看到了几个模式的属性： 首先是tv1，有两个没见过的属性： app:layout_constraintLeft_toLeftOf=&quot;parent&quot; 从字面上看，指的是让该控件的左侧与父布局对齐，当我们希望控件A与控件B左侧对齐时，就可以使用该属性。 1app:layout_constraintLeft_toLeftOf="@id/viewB" 类似的还有个相似的属性为： app:layout_constraintLeft_toRightOf 很好理解，即当前属性的左侧在谁的右侧，当我们希望控件A在控件B的右侧时，可以设置： 1app:layout_constraintLeft_toRightOf="@id/viewB" 与之类似的还有几个属性： layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf 类推就可以了。 现在在头看刚才的布局： 123456789101112131415tv1设置了：app:layout_constraintLeft_toLeftOf="parent"app:layout_constraintTop_toTopOf="parent"tv2设置了：app:layout_constraintLeft_toRightOf="@id/tv1"app:layout_constraintRight_toRightOf="parent"app:layout_constraintTop_toTopOf="@id/tv1"tv3设置了：app:layout_constraintLeft_toRightOf="@id/tv1"app:layout_constraintBottom_toBottomOf="@id/tv1" 按照我们刚才的理解，再次的解读下： tv1应该是在父布局的左上角； tv2在tv1的右侧，tv2的右侧和父布局对其，tv2和tv1顶部对齐； tv3在tv1的右侧，tv3和tv1底部对其。 到这里，大家可以看到，目前我们已经可以控制任何一个控件与其他控件间的相对位置了，以及与parent间的相对位置。 和RL的差异大家是不是觉得目前来看和RelativeLayout特别像？ 其实还是有很明显的区别的，我们通过一个例子来看一下： 123456789101112131415161718&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/id_btn01" android:layout_width="100dp" android:text="Btn01" android:layout_height="wrap_content" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_toRightOf="@id/id_btn01" android:text="Btn02" android:layout_alignParentRight="true" /&gt;&lt;/RelativeLayout&gt; 那么经过我们刚才的学习，把： layout_toRightOf=&quot;@id/id_btn01&quot;，layout_alignParentRight=&quot;true&quot; 分别替换为： app:layout_constraintLeft_toRightOf=&quot;@id/id_btn01&quot;，app:layout_constraintRight_toRightOf=&quot;parent&quot; 是不是觉得so easy ，但是我们看一下效果图： 是不是和预期有一定的区别，假设你将Btn02的宽度设置的非常大，你会发现更加诡异的事情： 你会发现Btn02，好像疯了一样，我们设置的在btn01右侧，和与parent右侧对齐完全失效了！！！ 别怕，接下来就让你认识到为什么这个控件叫做“Constraint”Layout。 在当控件有自己设置的宽度，例如warp_content、固定值时，我们为控件添加的都是约束“Constraint”，这个约束有点像橡皮筋一样会拉这个控件，但是并不会改变控件的尺寸（RL很明显不是这样的）。 例如上例，当btn02的宽度较小时，我们为其左侧设置了一个约束（btn01右侧），右侧设置了一个约束（parent右侧对其），当两个约束同时生效的时候（你可以认为两边都是相同的一个拉力），btn02会居中。 当btn02特别大的时候，依然是这两个力，那么会发生什么？会造成左侧和右侧超出的距离一样大。 那么现在大家肯定有些疑问： 怎么样才能和上面的RL一样，宽度刚好占据剩下的距离呢（btn01右侧到屏幕右侧的距离）？ 这个问题，问得很好，我们刚才所有的尝试都是在控件自身拥有特定的宽度情况下执行的；那么如果希望控件的宽度根据由约束来控件，不妨去掉这个特定的宽度，即设置为0试试？ 对！当我们将btn02的宽度设置为0时，一切又变得很完美。 那么这里，你可能会问0值是什么含义，其实在ConstraintLayout中0代表：MATCH_CONSTRAINT，看到这个常量，是不是瞬间觉得好理解了一点。 最后一个问题，MATCH_PARENT哪去了? 看官网的解释： Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”.` 所以你可以认为：在ConstraintLayout中已经不支持MATCH_PARENT这个值了，你可以通过MATCH_CONSTRAINT配合约束实现类似的效果。 好了，到这里，目前我们已经看到其已经和RelativeLayout势均力敌了，接下来我们看一下RL做不到的特性。 三、增加一个banner我们现在以往在这个feed item顶部添加一个banner，宽度为占据整个屏幕，宽高比为16：6。 这里尴尬了，在之前的做法，很难在布局中设置宽高比，一般我们都需要在代码中显示的去操作，那么如果你用了ConstraintLayout，它就支持。 看一眼如何支持： 12345678910111213141516171819202122&lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:id="@+id/banner" android:layout_width="0dp" android:layout_height="0dp" android:background="#765" android:gravity="center" android:text="Banner" app:layout_constraintDimensionRatio="H,16:6" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; &lt;TextView android:id="@+id/tv1" app:layout_constraintTop_toBottomOf="@id/banner" &gt;&lt;/TextView&gt; ...&lt;/...&gt; 我们添加了一个banner，还记得我们刚才所说的么，不要使用match_parent了，而是设置match_contraint，即0，让约束来控制布局宽高。 所以我们设置了宽、高都是match_contraint，然后这两个属性： 12app:layout_constraintLeft_toLeftOf="parent"app:layout_constraintRight_toRightOf="parent" 让我们的宽度充满整个父布局，在添加一个： 1app:layout_constraintDimensionRatio="16:6" 该属性指的是宽高比，所以16：6就可以完成我们的需求。 好了看下效果图： 这个宽高比属性，还支持这样的写法： 12app:layout_constraintDimensionRatio="W,16:6"app:layout_constraintDimensionRatio="H,16:6" 可以自己试验下。 好了，到这里，我们又新增了一个属性，还是个非常实用的属性。 那么，我们继续，再看一个似曾相识的功能。 四、增加几个Tab现在我们希望在底部增加3个tab，均分。是不是想到了LinearLayout和weight。 没错！ConstraintLayout也支持类似的属性。 虽然我知道，但是写到这我还是有点小惊喜~~ 看下如何实现： 12345678910111213141516171819202122232425262728293031323334&lt;TextView android:id="@+id/tab1" android:layout_width="0dp" android:layout_height="30dp" android:background="#f67" android:gravity="center" android:text="Tab1" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@+id/tab2" /&gt;&lt;TextView android:id="@+id/tab2" android:layout_width="0dp" android:layout_height="30dp" android:background="#A67" android:gravity="center" android:text="Tab2" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/tab1" app:layout_constraintRight_toLeftOf="@+id/tab3" /&gt;&lt;TextView android:id="@+id/tab3" android:layout_width="0dp" android:layout_height="30dp" android:background="#767" android:gravity="center" android:text="Tab3" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/tab2" app:layout_constraintRight_toRightOf="parent" /&gt; 我们增加3个textview来冒充tab。我们看横向的依赖，3个tab两两设置了约束（即你在我们的左边，我在你的右边），最外层的设置了parent约束；再加上我们把宽度都设置为了match_constraint，so，这样我们就完成了3个tab等分。 看一眼效果图： 你可能会说，LL配合weight更加灵活，可以单个设置占据的比例。 对，没错，我们也支持，我不是还没说完么。 现在我们可以给每个tab设置一个属性： 1app:layout_constraintHorizontal_weight 看到这个名字，应该就明白了吧，假设我们分别设置值为2，1，1。 效果图为： 是不是很惊喜，别急，刚才你说我不如LL，现在我要让你再看一些LL配合weight做不到的。 这里需要借助几张官网上的图了： 刚才我们说了，3个tab两两设置了依赖，即类似下图： 横向的相当于组成了一个链(Chains)。在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果： 该属性为： 1layout_constraintHorizontal_chainStyle 我们已经见过一种效果了，即按照weight等分，可以成为weighted chain。设置条件为： chainStyle=”spread”，所有控件宽度设置为match_constraint，因为默认就是spread，所以我们没有显示设置。 其取值还可以为： packed spread_inside 我还是分别显示一下吧： spread + 宽度非0 spread + 宽度为0，且可以通过weight控制分配比例（上例） spread_inside + 宽度非0 packed + 宽度非0 好了，差不多了，我们可以在横向或者纵向组成一个Chain，然后在Chain head设置chainStyle来搞一些事情。 官网有个图： 前四个我们都演示了，最后一个设计到一个新的bias属性，别急，咱们慢慢说~~ 好了，到这里，我们再次见证了ConstraintLayout的强大。 我们最后再看一个例子。 五、增加浮动按钮一个很常见的功能，我们现在希望在右下角增加一个浮动按钮。 看下如何实现： 12345678910111213141516&lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:layout_width="60dp" android:layout_height="60dp" android:background="#612" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.9" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintVertical_bias="0.9" /&gt;&lt;/....&gt; 我们在最后追加一个TextView冒充我们的浮动按钮。可以看到我们设置了固定值，被设置约束为右下角。 正常情况我们可以通过margin来设置与右侧与底部的距离。 但是这里我们尝试使用量个新的属性： 12layout_constraintHorizontal_biaslayout_constraintVertical_bias 即设置上下两侧间隙比例分别为90%与10%。这个很好理解，我们之前说了，再没有bias这个属性的时候，这两侧的拉力大小是一样的，但是你可以通过bias来控制哪一侧的力要大一些明白了么 所以，该属性可以用于约束之前，控制两侧的“拉力”。 我们看一下效果图： 那么到这里，ConstraintLayout的属性我们基本上介绍完了： 我们看一下： 1234567891011121314151617181920212223242526272829303132333435layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOflayout_constraintRight_toLeftOflayout_constraintRight_toRightOflayout_constraintTop_toTopOflayout_constraintTop_toBottomOflayout_constraintBottom_toTopOflayout_constraintBottom_toBottomOf# 即文章的baseline对齐layout_constraintBaseline_toBaselineOf# 与left,right类似layout_constraintStart_toEndOf layout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf# margin不需要解释android:layout_marginStartandroid:layout_marginEndandroid:layout_marginLeftandroid:layout_marginTopandroid:layout_marginRightandroid:layout_marginBottomlayout_constraintHorizontal_bias layout_constraintVertical_bias layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStylelayout_constraintVertical_weightGuideline 好像，还有个比较特殊的，叫Guideline。 好吧，继续~ 六、尝试使用Guidelineandroid.support.constraint.Guideline该类比较简单，主要用于辅助布局，即类似为辅助线，横向的、纵向的。该布局是不会显示到界面上的。 所以其有个属性为： android:orientation取值为”vertical”和”horizontal”. 除此以外，还差个属性，决定该辅助线的位置： layout_constraintGuide_begin layout_constraintGuide_end layout_constraintGuide_percent 可以通过上面3个属性其中之一来确定属性值位置。 begin=30dp，即可认为距离顶部30dp的地方有个辅助线，根据orientation来决定是横向还是纵向。 end=30dp，即为距离底部。percent=0.8即为距离顶部80%。 好了，下面看一个例子，刚才我们的浮点按钮，我决定通过两根辅助线来定位，一根横向距离底部80%，一个纵向距离顶部80%，浮点按钮就定位在他们交叉的地方。 123456789101112131415161718192021222324252627&lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline_h" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" app:layout_constraintGuide_percent="0.8" /&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline_w" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_percent="0.8" /&gt; &lt;TextView android:layout_width="60dp" android:layout_height="60dp" android:background="#612" app:layout_constraintLeft_toRightOf="@id/guideline_w" app:layout_constraintTop_toBottomOf="@id/guideline_h" /&gt;&lt;/....&gt; 我感觉都不用解释了~~看眼效果图吧： 到此，属性基本上讲完啦~ 可以看到，上述相当复杂的一个布局，在ConstraintLayout中完全没有嵌套！ 六、总结本文通过实际的按钮，基本上介绍了ConstraintLayout所支持的所有的属性，全文没有提及拖拽，因为当界面复杂之后，想要完美的拖拽实在是太难了，而且谁也不期望，看不懂拖拽完成后的布局属性吧~ 所以，我建议还是尽可能手写，通过本文这样一个流程，虽然支持的属性有20多个，但是分类后并不难记，难记也可以拿出本文翻一翻~ 好了，思考了半天，如何通过一个案例介绍完所有的属性，总体来说还是完成了，给自己点个赞。 转载于：张鸿洋的博客]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑马灯MarqueeView（支持任何View）]]></title>
    <url>%2Fposts%2F553b92de.html</url>
    <content type="text"><![CDATA[类似TextView的android:ellipsize=”marquee”的跑马灯效果 任意View都可实现 源码：MarqueeView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.zm.marqueeview;import android.content.Context;import android.util.AttributeSet;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.WindowManager;import android.widget.HorizontalScrollView;import android.widget.LinearLayout;/** * 跑马灯MarqueeView */public class MarqueeView extends HorizontalScrollView implements Runnable &#123; private Context context; private LinearLayout mainLayout;//跑马灯滚动部分 private int scrollSpeed = 5;//滚动速度 private int scrollDirection = LEFT_TO_RIGHT;//滚动方向 private int currentX;//当前x坐标 private int viewMargin = 100;//View间距 private int viewWidth;//View总宽度 private int screenWidth;//屏幕宽度 public static final int LEFT_TO_RIGHT = 1; public static final int RIGHT_TO_LEFT = 2; public MarqueeView(Context context) &#123; this(context, null); &#125; public MarqueeView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MarqueeView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); this.context = context; initView(); &#125; void initView() &#123; WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE); screenWidth = wm.getDefaultDisplay().getWidth(); mainLayout = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.scroll_content, null); this.addView(mainLayout); &#125; public void addViewInQueue(View view) &#123; LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(viewMargin, 0, 0, 0); view.setLayoutParams(lp); mainLayout.addView(view); view.measure(0, 0);//测量view viewWidth = viewWidth + view.getMeasuredWidth() + viewMargin; &#125; //开始滚动 public void startScroll() &#123; removeCallbacks(this); currentX = (scrollDirection == LEFT_TO_RIGHT ? viewWidth : -screenWidth); post(this); &#125; //停止滚动 public void stopScroll() &#123; removeCallbacks(this); &#125; //设置View间距 public void setViewMargin(int viewMargin) &#123; this.viewMargin = viewMargin; &#125; //设置滚动速度 public void setScrollSpeed(int scrollSpeed) &#123; this.scrollSpeed = scrollSpeed; &#125; //设置滚动方向 默认从左向右 public void setScrollDirection(int scrollDirection) &#123; this.scrollDirection = scrollDirection; &#125; @Override public void run() &#123; switch (scrollDirection) &#123; case LEFT_TO_RIGHT: mainLayout.scrollTo(currentX, 0); currentX--; if (-currentX &gt;= screenWidth) &#123; mainLayout.scrollTo(viewWidth, 0); currentX = viewWidth; &#125; break; case RIGHT_TO_LEFT: mainLayout.scrollTo(currentX, 0); currentX++; if (currentX &gt;= viewWidth) &#123; mainLayout.scrollTo(-screenWidth, 0); currentX = -screenWidth; &#125; break; default: break; &#125; postDelayed(this, 50 / scrollSpeed); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google推荐的图片加载库Glide介绍]]></title>
    <url>%2Fposts%2F6abab605.html</url>
    <content type="text"><![CDATA[英文原文 Introduction to Glide, Image Loader Library for Android, recommended by Google 在泰国举行的谷歌开发者论坛上，谷歌为我们介绍了一个名叫 Glide 的图片加载库，作者是bumptech。这个库被广泛的运用在google的开源项目中，包括2014年google I/O大会上发布的官方app。它的成功让我非常感兴趣。我花了一整晚的时间把玩，决定分享一些自己的经验。在开始之前我想说， Glide 和 Picasso 有90%的相似度，准确的说，就是Picasso的克隆版本。但是在细节上还是有不少区别的。 导入库 Glide 和 Picasso 都在jcenter上。在项目中添加依赖非常简单： Glide1234dependencies &#123; compile 'com.github.bumptech.glide:glide:3.5.2' compile 'com.android.support:support-v4:22.0.0'&#125; Picasso123dependencies &#123; compile 'com.squareup.picasso:picasso:2.5.1'&#125; 虽然两者看起来一样，但是Glide更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。 同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。 默认Bitmap格式是RGB_565下面是加载图片时和Picasso的比较（1920x1080 像素的图片加载到768x432的ImageView中） 可以看到Glide加载的图片质量要差于Picasso（ps：我看不出来哈），为什么？这是因为Glide默认的Bitmap格式是RGB_565 ，比ARGB_8888格式的内存开销要小一半。下面是Picasso在ARGB8888下与Glide在RGB565下的内存开销图（应用自身占用了8m，因此以8为基准线比较）： 如果你对默认的RGB_565效果还比较满意，可以不做任何事，但是如果你觉得难以接受，可以创建一个新的GlideModule将Bitmap格式转换到ARGB_8888： 12345678910111213public class GlideConfiguration implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; // Apply options to the builder here. builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; // register ModelLoaders here. &#125; &#125; 同时在AndroidManifest.xml中将GlideModule定义为meta-data 1&lt;meta-data android:name="com.inthecheesefactory.lab.glidepicasso.GlideConfiguration" android:value="GlideModule"/&gt; 这样看起来就会好很多。我们再来看看内存开销图，这次貌似Glide花费了两倍于上次的内存，但是Picasso的内存开销仍然远大于Glide。 原因在于Picasso是加载了全尺寸的图片到内存，然后让GPU来实时重绘大小。而Glide加载的大小和ImageView的大小是一致的，因此更小。当然，Picasso也可以指定加载的图片大小的： 1234Picasso.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .resize(768, 432) .into(ivImgPicasso); 但是问题在于你需要主动计算ImageView的大小，或者说你的ImageView大小是具体的值（而不是wrap_content），你也可以这样： 12345Picasso.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .fit() .centerCrop() .into(ivImgPicasso); 现在Picasso的内存开销就和Glide差不多了。 虽然内存开销差距不到，但是在这个问题上Glide完胜Picasso。因为Glide可以自动计算出任意情况下的ImageView大小。 Image质量的细节这是将ImageView还原到真实大小时的比较。 你可以看到，Glide加载的图片没有Picasso那么平滑，我还没有找到一个可以直观改变图片大小调整算法的方法。但是这并不算什么坏事，因为很难察觉。 磁盘缓存Picasso和Glide在磁盘缓存策略上有很大的不同。Picasso缓存的是全尺寸的，而Glide缓存的是跟ImageView尺寸相同的。 上面提到的平滑度的问题依然存在，而且如果加载的是RGB565图片，那么缓存中的图片也是RGB565。我尝试将ImageView调整成不同大小，但不管大小如何Picasso只缓存一个全尺寸的。Glide则不同，它会为每种大小的ImageView缓存一次。尽管一张图片已经缓存了一次，但是假如你要在另外一个地方再次以不同尺寸显示，需要重新下载，调整成新尺寸的大小，然后将这个尺寸的也缓存起来。具体说来就是：假如在第一个页面有一个200x200的ImageView，在第二个页面有一个100x100的ImageView，这两个ImageView本来是要显示同一张图片，却需要下载两次。不过，你可以改变这种行为，让Glide既缓存全尺寸又缓存其他尺寸： 1234Glide.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .diskCacheStrategy(DiskCacheStrategy.ALL) .into(ivImgGlide); 下次在任何ImageView中加载图片的时候，全尺寸的图片将从缓存中取出，重新调整大小，然后缓存。Glide的这种方式优点是加载显示非常快。而Picasso的方式则因为需要在显示之前重新调整大小而导致一些延迟，即便你添加了这段代码来让其立即显示： 12// Picasso.noFade(); Picasso和Glide各有所长，你根据自己的需求选择合适的。对我而言，我更喜欢Glide，因为它远比Picasso快，虽然需要更大的空间来缓存。（从上图也可以看出，Glide加载速度远快于Picasso） 特性你可以做到几乎和Picasso一样多的事情，代码也几乎一样。 Image Resizing12345// Picasso.resize(300, 200); //Glide.override(300, 200); Center Cropping12345// Picasso.centerCrop(); // Glide.centerCrop(); Transforming12345// Picasso.transform(new CircleTransform()) // Glide.transform(new CircleTransform(context)) 设置占位图或者加载错误图1234567// Picasso.placeholder(R.drawable.placeholder).error(R.drawable.imagenotfound) // Glide.placeholder(R.drawable.placeholder).error(R.drawable.imagenotfound) 几乎和Picasso一样，从Picasso转换到Glide对你来说就是小菜一碟。 有什么Glide可以做而Picasso做不到Glide可以加载GIF动态图，而Picasso不能。 同时因为Glide和Activity/Fragment的生命周期是一致的，因此gif的动画也会自动的随着Activity/Fragment的状态暂停、重放。Glide 的缓存在gif这里也是一样，调整大小然后缓存。但是从我的一次测试结果来看Glide 动画会消费太多的内存，因此谨慎使用。除了gif动画之外，Glide还可以将任何的本地视频解码成一张静态图片。还有一个特性是你可以配置图片显示的动画，而Picasso只有一种动画：fading in。最后一个是可以使用thumbnail()产生一个你所加载图片的thumbnail。其实还有一些特性，不过不是非常重要，比如将图像转换成字节数组等。 配置有许多可以配置的选项，比如大小，缓存的磁盘位置，最大缓存空间，位图格式等等。可以在这个页面查看这些配置Configuration 。 库的大小Picasso (v2.5.1)的大小约118kb，而Glide (v3.5.2)的大小约430kb。 Anyway 312KB difference might not be that significant.不过312kb的差距并不是很重要。Picasso和Glide的方法个数分别是840和2678个。 必须指出，对于DEX文件65535个方法的限制来说，2678是一个相当大的数字了。建议在使用Glide的时候开启ProGuard。 总结Glide和Picasso都是非常完美的库。Glide加载图像以及磁盘缓存的方式都要优于Picasso，速度更快，并且Glide更有利于减少OutOfMemoryError的发生，GIF动画是Glide的杀手锏。不过Picasso的图片质量更高。你更喜欢哪个呢？虽然我使用了很长时间的Picasso，但是我得承认现在我更喜欢Glide。我的建议是使用Glide，但是将Bitmap格式换成 ARGB_8888、让Glide缓存同时缓存全尺寸和改变尺寸两种。]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 完美修改应用包名]]></title>
    <url>%2Fposts%2F9b574dca.html</url>
    <content type="text"><![CDATA[我们平时新建项目有些朋友可能当时就是随意写的一个包名，然后在项目过程中， 又感觉这个包名不太好，所以就要对包名进行修改。 修改最外层包名 修改中间层包名 看到没有，我们只需要在setting里面，把 compact empty middle packages 这个选项去掉，这样，我们的包的层次结构就分开了，这个时候我们就可以根据自己的需要去做相应的修改了。 新增：Studio 3.0 之后，setting 中的选项名字该成了 Hide empty middle packages 另外说明一点，在 Studio 里面我们的 getPackageName 对应的是 applicationId , 而manifest 的那个package，在这里的作用其实是为了引用内部资源文件，以及保证 Activity 等源文件的路径正确而已，所以，在 Studio 中修改发布程序包名，则只需要在 build 文件中修改 applicationId 就可以了。 补充在 Studio 3.0 还有一种可直接通过 Androidmenifest 修改部分包名的方法（亲测过）。这里就不上图了。语言给大家描述一下，有什么问题可以博客下方留言。 修改流程如下：进入 Androidmanifest.xml 文件，找到 package 名称，选中需要修改的部分。比如原包名为com.zm.android如果需要修改中间的 zm ，那么我们就选中 zm ,依次进行 右键 - &gt; Refactor -&gt; Rename , (Mac 快捷键为 fn + shift+F6)然后选择 Rename package , 输入要修改目标的名称 ，直接点击 Refactor , 左下方继续点击 Do Refactor , 等待修改成功~！]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿支付宝首页应用管理(拖拽排序，添加删除)]]></title>
    <url>%2Fposts%2Fed9fc033.html</url>
    <content type="text"><![CDATA[MenuManage-Imitate-Alipay仿支付宝首页应用管理(拖拽排序，添加删除) 效果图 Download Demo]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug.keystore的SHA1和MD5]]></title>
    <url>%2Fposts%2F1a48ee1.html</url>
    <content type="text"><![CDATA[切换到debug.keystore目录1cd ~/.android/ 查看debug.keystore的SHA1和MD5接着输入如下命令 1keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android 结果如下图]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidStudio</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android解决qq分享后返回程序出现的Bug]]></title>
    <url>%2Fposts%2Fa03cc66a.html</url>
    <content type="text"><![CDATA[问题：当我们使用qq分享时，分享成功后选择留在qq,这个时候按home键，回到手机主界面，在点击回到我的app,这个时候会出现界面显示出来了，但是任何事件都不响应，即按钮没反应。 分析：这个时候回到我们的app时，会发现activity的生命周期只走了 onRestart()—onStart(),走到这里就结束了，onResume()并没有执行，所以界面不响应 这个时候我们又会发现qq分享用到的的一个AssistActivity 它的生命周期：.: –onActivityResult()—onStart()—onResume() 结论：至此，我们发现了原因，是这个AssistActivity的问题。 解决：我们可以在我们程序的onStart()方法判断一下，如果这个AssistActivity处在栈顶就把它清除掉。 123456789101112131415161718192021222324252627@Overrideprotected void onStart() &#123; super.onStart(); Log.i("---share----", "-----start"); if(isNeedRestart())&#123; Intent intent = new Intent(context, this.getClass()); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //清除栈顶的activity intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);//不显示多余的动画，假装没有重新启动 //记得带需要的参数 startActivity(intent); &#125;&#125;private boolean isNeedRestart()&#123; ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; tasks = am.getRunningTasks(1); if (!tasks.isEmpty()) &#123; ComponentName topActivity = tasks.get(0).topActivity; ActivityManager.RunningTaskInfo taskInfo = tasks.get(0); if (topActivity.getPackageName().equals(context.getPackageName())) &#123; // 若当前栈顶界面是AssistActivity，则需要手动关闭 if (topActivity.getClassName().equals("com.tencent.connect.common.AssistActivity")) return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-仪表盘控件仿芝麻信用]]></title>
    <url>%2Fposts%2F8a91974c.html</url>
    <content type="text"><![CDATA[前言由于项目需要使用到仪表盘图表，所以就本着一贯的操作流程就来github上面找，结果发现很多图表或者不是我需要的或者扩展性不强，所以就自己动手写了一个扩展性较强的，希望能帮助到有需要的人。（不过本人能力有限，有不足的地方还请见谅） 效果来源：Github传送门 先定个小目标由于每个公司的UI肯定都有不同的想法，设计出来的效果图也千奇百怪。所以我一开始的想法是能写一个基类的仪表盘图表，不需要懂得太多的自定义View知识也能做出UI所需要的效果。 我就想尝试着能不能自己写一个，万一能帮助到其他人呢。（梦想还是要有的） 所以我就抽取了一个BaseDashboardView类，并实现了三个Style的仪表盘图表。而这三个仪表盘除去一些画笔的初始化和参数的设置，绘制的代码都在70行内。下面就来看一下如何定义一个自己的仪表盘图表吧。 然后去做吧创建一个View然后去继承 BaseDashboardView 这时需要实现以下方法： 123456789protected abstract void initView();protected abstract void initArcRect(float left, float top, float right, float bottom);protected abstract void drawArc(Canvas canvas, float arcStartAngle, float arcSweepAngle);protected abstract void drawProgressArc(Canvas canvas, float arcStartAngle, float progressSweepAngle);protected abstract void drawText(Canvas canvas, int value, String valueLevel, String currentTime); 然后让我们来看看每个方法都是什么用的。 initView() 就是初始化设置，如创建画笔等。 initArcRect(float left, float top, float right, float bottom) 在我们绘制圆弧的时候可以传入Rect对象来确定圆弧的绘制范围，需要这里就是给我们初始化圆弧的区域的。 如:mRectArc = new RectF(left, top, right, bottom); drawArc(Canvas canvas, float arcStartAngle, float arcSweepAngle)这是就是开始正式的绘制背景圆弧了，arcStartAngle表示圆弧的起始角度，arcSweepAngle表示圆环一共多少度。我们通过刚才的Rect就可以绘制出一个圆弧如：canvas.drawArc(mRectOuterArc, arcStartAngle, arcSweepAngle, false, mPaintArc);但是要主要画笔的样式要设置为Paint.Style.STROKE drawProgressArc(Canvas canvas, float arcStartAngle, float progressSweepAngle)而这里是绘制进度圆弧的地方，progressSweepAngle进度的幅度已经在BaseDashboardView中计算好，只需要通过drawArc中的一样绘制个圆弧就行。 drawText(Canvas canvas, int value, String valueLevel, String currentTime)在这里可以把文字绘制到你想要他出现的地方就OK拉。数据已经在BaseDashboardView中处理过，直接绘制就可以。 由于很多逻辑的计算和动画都是在BaseDashboardView中去实现，所以我们只需要实现这几个方法，然后实现一些绘制的逻辑就可以咯。如果在绘制方面有什么问题的可以查看一下3个样式的DashboardView，如果是对底层的计算有兴趣的可以看一下BaseDashboardView。 接下来就去扩展这里主要说一个方法setCalibration(int[] calibrationNumberText, String[] calibrationBetweenText,int largeCalibrationBetweenNumber) 然后主要说一下calibrationNumberText和calibrationBetweenText参数，他们的初始默认值是 int[]{350, 550, 600, 650, 700, 950}和String[]{&quot;较差&quot;, &quot;中等&quot;, &quot;良好&quot;, &quot;优秀&quot;, &quot;极好&quot;} 那这样其实组成了一个区间 350 较差 550 中等 600 良好 650 优秀 700 极好 950 他的意思为350-550的为较差，其他依次类推，但是每个区间的大小是不一样的，较差的区间为550-350=200，而中等区间为650-550=50。但是每个区间在图表上显示的区域大小确实相同的。那么在计算进度幅度的时候需要区别计算。 而我的实现方式是首先判断当前value在第几个区间中，如当前value=575。那么通过循环的方式可以知道当前value处在550和600之间。然后通过 (575 - 550) / (600 - 550)公式计算出当前值在这个区间内占的百分比。然后通过每个区间的角度算出当前进度条的幅度。 而除了刻度的扩展其实还有很多其他的可配置项，可以通过github进行查看。 公共方法介绍12345678910111213141516171819202122232425262728293031323334353637//设置当前数值 value:数值 isAnim:是否开启东湖 reset:是否从头开始进行动画setValue(int value, boolean isAnim, boolean reset)//设置动画时长 (默认为2.5秒)setProgressAnimTime(long time)//设置圆弧角度 //arcStartAngle:起始角度 (默认值: 165)//arcSweepAngle:圆弧度数 (默认值: 210)setArcAngle(float arcStartAngle,float arcSweepAngle)&#123;//设置刻度属性//calibrationNumberText 每个大刻度对应的数值 (默认值: int[]&#123;350, 550, 600, 650, 700, 950&#125;)//calibrationBetweenText 每个大刻度中间的文字 (默认值: String[]&#123;"较差", "中等", "良好", "优秀", "极好"&#125;)//largeCalibrationBetweenNumber 两个大刻度中间有多少个小刻度 (默认值: 3)setCalibration(int[] calibrationNumberText, String[] calibrationBetweenText,int largeCalibrationBetweenNumber)//设置日期格式化的格式 (默认值: yyyy-MM-dd)setDatePattern(String pattern)//设置时间的显示格式 格式(如: 评估时间：&#123;date&#125;) &#123;date&#125;为占位符setDateStrPattern(String pattern)//设置数值等级的模板 格式(如: 信用&#123;level&#125;) &#123;level&#125;为占位符setValueLevelPattern(String pattern)//设置数值的画笔属性 (默认值: 60sp white)setValuePaint(float spSize, @ColorInt int color)//设置数值等级的画笔属性 (默认值: 25sp white)setValueLevelPaint(float spSize, @ColorInt int color)//设置日期对应的画笔属性 (默认值: 10sp white)setDatePaint(float spSize, @ColorInt int color)//设置中间文字中间的间距 (默认值: 7dp)setTextSpacing(int spacingDp) Style 1 1234567891011121314151617181920212223242526//设置圆环之间的距离 (默认值: 15dp)setArcSpacing(float dpSize)//设置外环的画笔属性 (默认值: 3dp Color.argb(80, 255, 255, 255))setOuterArcPaint(float dpSize, @ColorInt int color)//设置内环的画笔属性(默认值: 10dp Color.argb(80, 255, 255, 255))setInnerArcPaint(float dpSize, @ColorInt int color)//设置进度条的颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressArcColor(@ColorInt int color)//设置进度条的点的画笔属性 (默认值: 3dp white)setProgressPointPaint(float dpRadiusSize,@ColorInt int color)//设置大刻度的画笔属性 (默认值: 2dp Color.argb(200, 255, 255, 255))setLargeCalibrationPaint(float dpSize, @ColorInt int color)//设置小刻度的画笔属性 (默认值: 0.5dp Color.argb(100, 255, 255, 255))setSmallCalibrationPaint(float dpSize, @ColorInt int color)//设置刻度文字的画笔属性 (默认值: 10sp white)setCalibrationTextPaint(float spSize, @ColorInt int color)//设置大刻度中间的数值等级的画笔属性 (默认值: 10sp white)setCalibrationBetweenTextPaint(float spSize, @ColorInt int color) Style 2 12345678//设置圆环颜色 (默认值: Color.argb(120, 255, 255, 255))setArcColor(@ColorInt int color)//设置进度圆环的颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressColor(@ColorInt int color)//设置圆环的刻度大小 (默认值: 2.5dp)setArcCalibrationSize(int dpSize) Style 3 1234567891011121314151617181920212223//设置圆环之间的距离 (默认值: 10dp)setArcSpacing(float dpSize)//设置外环的画笔属性 (默认值: 1.5dp Color.argb(80, 255, 255, 255))setOuterArcPaint(float dpSize, @ColorInt int color)//设置外环的进度颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressOuterArcColor(@ColorInt int color)//设置内环的画笔属性 (默认值: 1.5dp Color.argb(50, 255, 255, 255))setInnerArcPaint(float dpSize, @ColorInt int color)//设置内环的进度颜色 (默认值: Color.argb(170, 255, 255, 255))setProgressInnerArcPaint(@ColorInt int color)//设置内环实线和虚线状态 (默认值: float[] &#123; 10, 10 &#125;)setInnerArcPathEffect(float[] intervals)//设置进度点的画笔属性 (默认值: 3dp white)setProgressPointPaint(float dpRadiusSize,@ColorInt int color)//设置指示器颜色 (默认值: Color.argb(200, 255, 255, 255))setIndicatorPaint(@ColorInt int color)]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中多线程切换的几种方法]]></title>
    <url>%2Fposts%2Ffbda19a9.html</url>
    <content type="text"><![CDATA[我们知道，多线程是Android开发中必现的场景，很多原生API和开源项目都有多线程的内容，这里简单总结和探讨一下常见的多线程切换方式。我们先回顾一下Java多线程的几个基础内容，然后再分析总结一些经典代码中对于线程切换的实现方式。 几点基础多线程切换，大概可以切分为这样几个内容：如何开启多个线程，如何定义每个线程的任务，如何在线程之间互相通信。 ThreadThread可以解决开启多个线程的问题。Thread是Java中实现多线程的线程类，每个Thread对象都可以启动一个新的线程，注意是可以启动，也可以不启动新线程： 12thread.run();//不启动新线程，在当前线程执行thread.start();//启动新线程。 另外就是Thread存在线程优先级问题，如果为Thread设置较高的线程优先级，就有机会获得更多的CPU资源，注意这里也是有机会，优先级高的Thread不是必然会先于其他Thread执行，只是系统会倾向于给它分配更多的CPU。默认情况下，新建的Thread和当前Thread的线程优先级一致。设置线程优先级有两种方式： 12thread.setPriority(Thread.MAX_PRIORITY);//1~10，通过线程设置Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);//-20~19，通过进程设置 这两种设置方式是相对独立的，在Android中，一般建议通过Process进程设置优先级。 ThreadPoolThread本身是需要占用内存的，开启/销毁过量的工作线程会造成过量的资源损耗，这种场景我们一般会通过对资源的复用来进行优化，针对IO资源我们会做IO复用（例如Http的KeepAlive），针对内存我们会做内存池复用（例如Fresco的内存池），针对CPU资源，我们一般会做线程复用，也就是线程池。所以，在Android开发中，一般不会直接开启大量的Thread，而是会使用ThreadPool来复用线程。 RunnableRunnable主要解决如何定义每个线程的工作任务的问题。Runnable是Java中实现多线程的接口，相对Thread而言，Runnable接口更容易扩展（不需要单继承），而且，Thread本身也是一种Runnable： 1public class Thread implements Runnable &#123; 相比Thread而言，Runnable不关注如何调度线程，只关心如何定义要执行的工作任务，所以在实际开发中，多使用Runnable接口完成多线程开发。 CallableCallable和Runnable基本类似，但是Callable可以返回执行结果。 线程间通信Thread和Runnable能实现切换到另一个线程工作（Runnable需要额外指派工作线程），但它们完成任务后就会退出，并不注重如何在线程间实现通信，所以切换线程时，还需要在线程间通信，这就需要一些线程间通信机制。 Future一般来说，如果要做简单的通信，我们最常用的是通过接口回调来实现。Future就是这样一种接口，它可以部分地解决线程通信的问题，Future接口定义了done、canceled等回调函数，当工作线程的任务完成时，它会（在工作线程中）通过回调告知我们，我们再采用其他手段通知其他线程。 123456mFuture = new FutureTask&lt;MyBizClass&gt;(runnable) &#123; @Override protected void done() &#123; ...//还是在工作线程里 &#125;&#125;; ConditionCondition其实是和Lock一起使用的，但如果把它视为一种线程间通信的工具，也说的通。因为，Condition本身定位就是一种多线程间协调通信的工具，Condition可以在某些条件下，唤醒等待线程。 1234567 Lock lock = new ReentrantLock(); Condition notFull = lock.newCondition(); //定义Lock的Condition... while (count == items.length) notFull.await();//等待condition的状态... notFull.signal();//达到condition的状态 Handler其实，最完整的线程间通信机制，也是我们最熟悉的线程间通信机制，莫过于Handler通信机制，Handler利用线程封闭的ThreadLocal维持一个消息队列，Handler的核心是通过这个消息队列来传递Message，从而实现线程间通信。 AsyncTask的多线程切换回顾完多线程的几个基础概念，先来看看简单的多线程切换，Android自带的AsyncTask。AsyncTask主要在doInBackground函数中定义工作线程的工作内容，在其他函数中定义主线程的工作内容，例如onPostExecute，这里面必然涉及两个问题：1.如何实现把doInBackground抛给工作线程2.如何实现把onPostExecute抛给主线程其实非常简单，我们先看第一个 1.如何实现把doInBackground抛给工作线程在使用AsyncTask时，我们一般会创建一个基于AsyncTask的扩展类或匿名类，在其中实现几个抽象函数，例如： 1234567891011private class MyTask extends AsyncTask&lt;String, Object, Long&gt; &#123; @Override protected void onPreExecute() &#123;... &#125; @Override protected Long doInBackground(String... params) &#123;... &#125; @Override protected void onProgressUpdate(Object... values) &#123;... &#125; @Override protected void onPostExecute(Long aLong) &#123;... &#125; @Override protected void onCancelled() &#123;... &#125; 然后，我们会实例化这个AsyncTask： 1MyTask mTask = new MyTask(); 在AsyncTask源码中，我们看到，构造函数里会创建一个WorkerRunnable： 123456public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;//这是一个Callable public Result call() throws Exception &#123; ... result = doInBackground(mParams);//在工作线程中执行 ... WorkerRunnable实际上是一个Callable对象，所以，doInBackground是被包在一个Callable对象中了，这个Callable还会被继续包装，最终被交给一个线程池去执行： 12345Runnable mActive;...if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive);//交给线程池执行&#125; 梳理一下，大致过程为：定义doInBackground–&gt;被一个Callable调用–&gt;层层包为一个Runnable–&gt;交给线程池执行。这样就解决了第一个问题，如何实现把doInBackground抛给工作线程。我们再来看第二个问题。 2.如何实现把onPostExecute抛给主线程首先，我们要知道工作任务何时执行完毕，就需要在工作完成时触发一个接口回调，也就是前面说过的Future，还是看AsyncTask源码： 123456789101112131415public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; ... &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123;//Future的回调 try &#123; postResultIfNotInvoked(get());//get()是FutureTask接口函数 ... &#125; &#125;; &#125; 这样，我们就知道可以处理onPostExecute函数了，但是，我们还需要把它抛给主线程，主要源码如下： 1234567891011121314151617181920212223242526272829303132//mWorker、mFuture和都会指向postResult函数private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125;//getHandler()会指向InternalHandlerprivate static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper());//指向MainLooper &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]);//通过handler机制，回到主线程，调用finish函数 ...&#125;//在Handler中，最终会在主线程中调用finishprivate void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result);//调用onPostExecute接口函数 &#125; mStatus = Status.FINISHED;&#125; 从源码可以看到，其实AsyncTask还是通过Handler机制，把任务抛给了主线程。 总体来说，AsyncTask的多线程任务是通过线程池实现的工作线程，在完成任务后利用Future的done回调来通知任务完成，并通过handler机制通知主线程去执行onPostExecute等回调函数。 EventBus的多线程切换EventBus会为每个订阅事件注册一个目标线程，所以需要从发布事件的线程中，根据注册信息，实时切换到目标线程中，所以，这是个很典型的多线程切换场景。根据EventBus源码，多线程切换的主要判断代码如下： 123456789101112131415161718192021222324switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event);//直接在当前线程执行 break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event);//在当前主线程执行 &#125; else &#123; mainThreadPoster.enqueue(subscription, event);//当然不是主线程，交给主线程执行 &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event);//当前线程为主线程，交给工作线程 &#125; else &#123; invokeSubscriber(subscription, event);//直接在当前工作线程执行 &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event);//异步执行 break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);&#125; 所以，在EventBus里，如果需要做线程间切换，主要是抛给不同的任务队列，实现线程间切换。从任务队列判断，切换目标包括主线程Poster、backgroundPoster和asyncPoster这样三种。我们先看任务队列的设计： 任务队列因为EventBus不能判断有哪些任务会并行，所以它采用了队列的设计，多线程任务（EventBus的事件）会先进入队列，然后再处理队列中的工作任务，这是典型的生产–消费场景。主线程Poster、backgroundPoster和asyncPoster都是任务队列的不同实现。 主线程Poster负责处理主线程的mainThreadPoster是Handler的子类： 1234567891011121314final class HandlerPoster extends Handler &#123;... void enqueue(Subscription subscription, Object event) &#123; ... synchronized (this) &#123;//因为主线程只有一个，需要线程安全 queue.enqueue(pendingPost); ... if (!sendMessage(obtainMessage())) &#123;//作为handler发送消息 ... //在主线程中处理消息 @Override public void handleMessage(Message msg) &#123; ...&#125; 从源码可以看出，这个Poster其实是一个Handler，它采用了哪个线程的消息队列，就决定了它能和哪个线程通信，我们确认一下： 123EventBus(EventBusBuilder builder) &#123; ... mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);//获取主线程的MainLooper 所以，EventBus是扩展了一个Handler，作为主线程的Handler，通过Handler消息机制实现的多线程切换。当然，这个Handler本事，又多了一层queue。 backgroundPoster和asyncPosterbackgroundPoster和asyncPoster其实都是使用了EventBus的线程池，默认是个缓存线程池： 1private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); 所以，backgroundPoster和asyncPoster都是把任务交给线程池处理，这样实现的多线程切换。不过，backgroundPoster和asyncPoster也有一些不同，我们知道，在newCachedThreadPool中，最大线程数就是Integer的最大值，相当于不设上限，所以可以尽可能多的启动线程，asyncPoster就是这样做的，enqueu和run都没做同步，为每个事件单独开启新线程处理。而在backgroundPoster中，可以尽量复用线程，主要方法是在run的时候，做个1秒的等待： 1234@Overridepublic void run() &#123; ... PendingPost pendingPost = queue.poll(1000);//允许等待1秒 因为做了这一秒的挂起等待，在enqueue和run时，都需要用synchronized (this) 来确保线程安全。 另外，其实这里面还有个很重要的用法，就是Executors.newCachedThreadPool()中的SynchronousQueue： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());//用于辅助线程切换的阻塞队列&#125; 这个SynchronousQueue，在OkHttp中也使用了： 12345678//okhttp3.Dispatcher源码public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false));//用于辅助线程切换的阻塞队列 &#125; return executorService;&#125; SynchronousQueue与普通队列不同，不是数据等线程，而是线程等数据，这样每次向SynchronousQueue里传入数据时，都会立即交给一个线程执行，这样可以提高数据得到处理的速度。 总的来看，EventBus还是采用线程池实现工作线程，采用handler机制通知到主线程。不同在于，它采用的queue的队列方式来管理所有的跨线程请求，而且它利用了SynchronousQueue阻塞队列来辅助实现线程切换。 RxJava的多线程切换其实在多线程管理这方面，RxJava的线程管理能力是非常令人赞叹的。RxJava的主要概念是工作流，它可以把一序列工作流定义在一个线程类型上： 123myWorkFlow.getActResponse(myParam) .subscribeOn(Schedulers.io())//指定线程 .xxx//其他操作 这个构建工作流的过程其实挺复杂的，不过如果我们只看线程操作这部分，其实流程非常清晰，我们追踪一下subscribeOn的源码（RxJava2）： 12345678910//进入subscribeOnpublic final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return subscribeOn(scheduler, !(this instanceof FlowableCreate));&#125;//继续进入subscribeOnpublic final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler, boolean requestOn) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new FlowableSubscribeOn&lt;T&gt;(this, scheduler, requestOn));&#125; 然后，进入FlowableSubscribeOn类 1234567891011121314//进入FlowableSubscribeOn类 public FlowableSubscribeOn(Flowable&lt;T&gt; source, Scheduler scheduler, boolean nonScheduledRequests) &#123; ... this.scheduler = scheduler; ...&#125;@Overridepublic void subscribeActual(final Subscriber&lt;? super T&gt; s) &#123; Scheduler.Worker w = scheduler.createWorker();//根据参数值，如Schedulers.io()创建worker final SubscribeOnSubscriber&lt;T&gt; sos = new SubscribeOnSubscriber&lt;T&gt;(s, w, source, nonScheduledRequests);//根据worker创建SubscribeOnSubscriber s.onSubscribe(sos); w.schedule(sos);&#125; 这个SubscribeOnSubscriber是个内部类： 1234567891011 SubscribeOnSubscriber(Subscriber&lt;? super T&gt; actual, Scheduler.Worker worker, Publisher&lt;T&gt; source, boolean requestOn) &#123; ... this.worker = worker; ... &#125;... void requestUpstream(final long n, final Subscription s) &#123; ... worker.schedule(new Request(s, n));//worker会安排如何执行runnable（Request是一个runnable） ... &#125; 而这个worker，其实就是我们输入的线程参数，如Schedulers.io()，这个io是这样定义的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//io.reactivex.schedulers.Schedulers源码 static &#123; SINGLE = RxJavaPlugins.initSingleScheduler(new SingleTask()); COMPUTATION = RxJavaPlugins.initComputationScheduler(new ComputationTask()); IO = RxJavaPlugins.initIoScheduler(new IOTask()); TRAMPOLINE = TrampolineScheduler.instance(); NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask()); &#125;... static final class IOTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return IoHolder.DEFAULT; &#125; &#125; static final class NewThreadTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return NewThreadHolder.DEFAULT; &#125; &#125; static final class SingleTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return SingleHolder.DEFAULT; &#125; &#125; static final class ComputationTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return ComputationHolder.DEFAULT; &#125; &#125;... static final class SingleHolder &#123; static final Scheduler DEFAULT = new SingleScheduler(); &#125; static final class ComputationHolder &#123; static final Scheduler DEFAULT = new ComputationScheduler(); &#125; static final class IoHolder &#123; static final Scheduler DEFAULT = new IoScheduler(); &#125; static final class NewThreadHolder &#123; static final Scheduler DEFAULT = new NewThreadScheduler(); &#125; 这里的IO，最终会指向一个Scheduler，如IoScheduler： 1234567891011121314//io.reactivex.internal.schedulers.IoScheduler源码... static final class EventLoopWorker extends Scheduler.Worker &#123;//Scheduler.Worker的实现类 ... @NonNull @Override public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; if (tasks.isDisposed()) &#123; // don't schedule, we are unsubscribed return EmptyDisposable.INSTANCE; &#125; return threadWorker.scheduleActual(action, delayTime, unit, tasks);//交给线程池 &#125; 这样，Scheculer中的具体任务就交给了某个线程池来处理。 需要特别说明的是，RxJava中调用Android主线程(AndroidSchedulers.mainThread)，其实还是使用了Handler机制： 123public final class AndroidSchedulers &#123; ... static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper())); 这个HandlerScheduler其实就是实现了Scheduler和Scheduler.Worker内部类。 123456789101112final class HandlerScheduler extends Scheduler &#123;private final Handler handler;HandlerScheduler(Handler handler) &#123; this.handler = handler;&#125;private static final class HandlerWorker extends Worker &#123; ... @Override public Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; ... handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); 总的来看，RxJava的多线程切换其实是利用了Scheculer.Worker这个内部类，把任务交给Scheculer的Worker去做，而这个Scheculer的Worker是根据定义的线程来实现了不同的线程池，其实还是交给线程池去处理了。至于主线程，RxJava也是使用了Handler机制。 总结小小总结一下，基本上来说，Android中的多线程切换，主要使用Runnable和Callable来定义工作内容，使用线程池来实现异步并行，使用Handler机制来通知主线程，有些场景下会视情况需要，使用Future的接口回调，使用SynchronousQueue阻塞队列等。 原文链接：mp.weixin.qq.com]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android珍藏】推荐10个炫酷的开源库]]></title>
    <url>%2Fposts%2F78b41fa0.html</url>
    <content type="text"><![CDATA[前言技术群里面经常有人问到一些炫酷的UI效果实现方法，有时候我都是给一个相同或者相似效果的Github链接，有同学私信给我说，大佬，怎么这些效果你都能找到？你是怎么搜索的，或者有其他什么秘方？会利用Google、百度等搜索工具搜索是一方面，另一个重要的方面是：记录搜藏，当看到一个炫酷的效果的时候，记得收藏起来，记录到自己云笔记或者收藏夹里，看得多了，印象就比较深刻，当遇到类似效果的时候，到自己记录收藏的地方找就是了。今天为大家推荐我所收藏的一些炫酷实用的效果的开源库（选择其中10个）。 1、 DiscreteScrollView简介： DiscreteScrollView是基于RecyclerView 实现的一个横向滑动列表，当前Item显示在屏幕中央并且可以左右滑动，有点像ViewPager,但是可以快速滑动。提供了简单的API来实现炫酷的动画效果。 效果展示： 2、MaterialViewPager简介： 和名字一样，Material Design 效果的ViewPager, 效果很nice,请看gif 效果展示(有多重模式)： Titlebar Logo Fading Logo Hide Logo and Toolbar Sticky Toolbar Transparent Toolbar Standard 3、BoomMenu简介： 传统的菜单是不是看得有些厌倦了，boom ….爆炸效果的菜单了解一下？功能强大、效果炫酷，有很多种模式。 效果展示： 4、LayoutManagerGroup简介： 自定义RecyclerView 的LayoutManager实现几种炫酷的效果。 效果展示： EchelonLayoutManager SkidRightLayoutManager SlideLayoutManager 5、Android-SpinKit简介： Android 自定义View 的方式实现的各种炫酷的动画，特别精致和优美，以前专门写文章介绍过。 效果展示： 6、Matisse简介： Matisse是知乎开源的一个本地选择照片和视频的库，UI设计得非常精美。有如特性： 可以在Fragment/Activity 中使用 选择照片的格式包括：PNG、JPEG 、GIF.视频格式包括：MPEG, MP4 支持不同的主题并且可以自定义主题 支持不同的图片加载方式（Picasso、Glide等） 自定义过滤规则 效果展示： Zhihu Style Dracula Style Preview 7、CosmoCalendar简介： 一个高度自定义的日历库，UI精美，支持多种模式。 效果展示： 单个日期选择 多个日期选择 选择一个范围日期 自定义 8、CardStackView简介： 三种炫酷的列表卡片滑动动画，分别为：alldown, updown, updownstack 效果展示： 9、CalendarExaple简介： 这是一个高仿钉钉和小米的日历控件，支持快速滑动，界面缓存。想要定制化UI，使用起来非常简单，就像使用ListView一样 一些特点： 可以自定义日历控件UI 支持快速滑动 支持农历和阳历 界面UI缓存和日历数据缓存 扩展view支持listView的滑动 效果展示： 10、MZBannerView简介： 仿魅族BannerView,图片轮播控件,支持多种模式切换：普通ViewPager使用，普通Banner使用，仿魅族Banner使用。 效果展示： 结尾在我们平时的工作、学习中，要养成记笔记的好习惯、好记性不如烂笔头。平时自己遇到一些炫酷的效果，我都喜欢记录到笔记中，遇到相似的需求就好找了。本文这些炫酷的效果有兴趣的可以去对应的Github 查看使用方式，试试效果，都挺赞的。 来源：掘金-依然范特稀西]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易严选App感受Weex开发]]></title>
    <url>%2Fposts%2F926ca595.html</url>
    <content type="text"><![CDATA[此处是 demo 源码：https://github.com/zwwill/yanxuan-weex-demo 不得不说，使用 Weex 开发 app 对于我们纯前端人员来说，是件「很爽」的事情，只要你熟悉了他的语法，基本可以做到一周上手写 app。极其适合交互要求不高，时间紧迫，人手不足的同构开发需求。 但是，当然有但是，如果你想写出一个完美的 app，你就需要在性能优化上下很大的功夫，包括动画的优化，过场的优化，图片的优化，细节的打磨等等，再者，就是你需要掌握或者「能写」一些原生的代码，不然有些功能你是实现不了的，比如 status bar 的属性更改，开场动画的制作，内存的回收，webview 的监听等等。 下面我们具体讲讲入门知识 Weex 提供了多端一致的技术方案。 首先，Weex 的开发和 web 开发体验可以说是几乎一样。包括语法设计和工程链路等。 其次，Weex 的组件、模块设计都是 iOS、Android、Web 的开发者共同讨论出来的，有一定的通用性和普遍性。 Weex 开发同一份代码，可以在不同的端上分别执行，避免了多端的重复研发成本。 在同构这条路上，Weex 比 React Native做得更彻底，他「几乎」做到了，「你来使用 vue 写一个webapp，我顺便给你编译成了 ios 和 android 的原生 app」 至于为什么要造这个轮子，官方给了以下说法 1、今天在技术社区有大量的 web 开发者，Weex 可以赋能更多的 web 开发者构建高性能和高体验的移动应用。2、Web 开发本身具有非常强的高效率和灵活性，这和 Weex 想解决的移动端动态性问题不谋而合。3、Web 标准和开发体验是很多顶尖而优秀的科技公司共同讨论和建设的结果，本身的设计和理念都有极高的品质保障4、同时 Weex 也希望可以借此机会努力为标准贡献一点自己的微薄之力。5、Web 是一种标准化的技术，标准本身就是一种力量，基于标准、尊重标准、贴近标准都意味着拥有更多的可能性。6、Web 今天的生态和社区是非常繁荣的，有很多成熟的工具、库、工程体系、最佳实践可以使用、引入和借鉴。 在我看来，Weex 其实是 Alibaba 团队提高生产效率的产物，在淘宝这类要求多端统一迭代快速的部门，三端约定一种便于统一的规范，在加上时间的发酵，渐渐的就有了此类脚手架的雏形，同时在脸书 React Native 开源带来的极大轰动后，自己也坐不住了吧^_^ 好了，闲话就说到这，下面就来让我们解剖一下WEEX的优劣良莠。 预科入门 Weex 前需要了解以下知识，这样能帮助你更快的掌握Node：《Node.js 教程》Vue：《Vue.js官方教程》ES6：《ECMAScript 6 入门》再者就是 ios 和 android 开发语法的入门和编辑器的使用 环境系统环境要求IOS : MacOS, 黑苹果Android :MacOS, Linux, Windows 配置环境你可以参考官方文档安装必须的依赖环境 http://weex.apache.org/cn/guide/set-up-env.html，也可以直接安装以下环境 node npm weex-toolkit Xcode 安装 Xcode IDE 和 Xcode 的命令行工具（IOS 开发依赖） Android Studio 下载必须的插件： a) JDK1.8+b) Show Package Detailsc) Android SDK Build Toolsd) Android Support Repository 配置基础环境：a) ANDROID_HOME （如运行是遇到问题可参考此文 http://www.jianshu.com/p/a77396301b22）b) JAVA_HOME Hello Weex官方文档上的入门 Hello world 是 web 端的，紧接着介绍了如何「集成 Weex 到已有应用」 但是，身为一个 web 前端开发者，如果你不懂原生语音的话，介绍这些并不能起到很好的引导作用，因为web前端开发者都有「一统前端界」的野心（Web+Android+IOS），「寄人篱下」只能是暂时的。 快速创建并运行一个纯 Weex App 对于「纯」前端同学来说，才是有意思的事儿。但： 为什么文档要这么设计也是跟Weex的定位有关的，读完下文后续你就慢慢懂了，后面我将做总结解释 如果你在官方教程里没有找到创建工程的教程，可以阅读此文《Weex 快速创建工程 Hello World》 Vue NativeWeex 在迭代的过程中选择了于 Vue 2.0 握手，因为该版本的 Vue 加入了 Virtual-DOM 和预编译器的设计，使得该框架在运行时能够脱离 HTML 和 CSS 解析，只依赖 JavaScript，如此，Vue 在和 Weex 合作后，便获得了使用 JS 预编译原生的组件 UI 的能力。 同 React Native 一样，有人也将 Weex 叫做 Vue Native。 如果你对 Vue 还不了解，可以先学习【预科】部分推荐的《Vue.js 官方教程》。 那么接下来我们讲讲，Vue 在 Weex 中的不同 Vue 在 Weex 中的不同虽说 Weex 使用 Vue 语言写的，但毕竟是需要在不同平台间运行的，虽然大部分语法都有支持，但是依然有部分语法是不同的 语法差异1、“html标签”目前 Weex 支持了基本的容器 (div)、文本 (text)、图片 (image)、视频 (video) 等组件，注意是组件，而不是标签，虽然使用起来跟 html 标签很像，至于其他标签基本可以使用以上组件组合而成。 2、Weex 环境中没有 DOM因为 Weex 解析 vue 得到的并不是 dom，而是原生布局树 3、支持有限的事件并不支持 Web 中所有的事件类型，详情请参考《通用事件》 4、没有 BOM 但可以调用原生 API在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。《clipboard 剪切板》《navigator 导航控制》《storage 本地存储 》为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。 样式差异Weex 中的样式是由原生渲染器解析的，出于性能和功能复杂度的考虑，Weex 对 CSS 的特性做了一些取舍1、Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。2、组件级别的作用域，为了保持 web 和 Native 的一致性，需要&lt;style scoped&gt;写法3、支持了基本的盒模型和 flexbox 布局，详情可参考Weex 通用样式文档。但是需要注意的是， 不支持display: none;可用opacity: 0;代替，（opacity&lt;=0.01时，元素可点透） 样式属性暂不支持简写（提高解析效率） flex 布局需要注意 web 的兼容性 css 不支持 3D 变换 Weex 开发&amp;调试Vue 语法举个栗子，以下是严选App Demo首页的简化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;text class=&quot;iconfont&quot;&gt;&lt;/text&gt; &lt;home-header&gt;&lt;/home-header&gt; &lt;scroller class=&quot;main-list&quot; offset-accuracy=&quot;300px&quot;&gt; &lt;refresher&gt;&lt;/refresher&gt; &lt;div class=&quot;cell-button&quot; @click=&quot;jumpWeb(&apos;https://m.you.163.com&apos;)&quot;&gt; &lt;yx-slider :imageList=&quot;YXBanners&quot; &gt;&lt;/yx-slider&gt; &lt;/div&gt; &lt;div class=&quot;cell-button&quot;&gt; &lt;block-1 :title=&quot;block1.title&quot; :items=&quot;block1.items&quot;&gt;&lt;/block-1&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .iconfont &#123; font-family:iconfont; &#125; .main-list&#123; position: fixed; top: 168px; bottom: 90px; left: 0; right: 0; &#125;&lt;/style&gt;&lt;script&gt; var navigator = weex.requireModule(&apos;navigator&apos;); import util from &apos;../../src/assets/util&apos;; import Header from &apos;../components/Header.vue&apos;; import refresher from &apos;../components/refresh.vue&apos;; import YXSlider from &apos;../components/YXSlider.vue&apos;; import Block1 from &apos;../components/Block1.vue&apos;; export default &#123; components: &#123; &apos;home-header&apos;: Header, &apos;refresher&apos;: refresher, &apos;yx-slider&apos;: YXSlider, &apos;block-1&apos;: Block1 &#125;, data () &#123; return &#123; YXBanners: [ &#123; title: &apos;&apos;, src: &apos;http://doc.zwwill.com/yanxuan/imgs/banner-1.jpg&apos;&#125;, &#123; title: &apos;&apos;, src: &apos;http://doc.zwwill.com/yanxuan/imgs/banner-2.jpg&apos;&#125;, &#123; title: &apos;&apos;, src: &apos;http://doc.zwwill.com/yanxuan/imgs/banner-3.jpg&apos;&#125; ] &#125; &#125;, methods: &#123; jumpWeb (_url) &#123; const url = this.$getConfig().bundleUrl; navigator.push(&#123; url: util.setBundleUrl(url, &apos;page/web.js?weburl=&apos;+_url) , animated: &quot;true&quot; &#125;); &#125; &#125; &#125;&lt;/script&gt; 如果以上代码脱离工程单独出现，基本上是无法得知他是 Weex 工程。此处可切实感受到 Weex 的 web 开发体验 名存实亡的&lt;标签/&gt;1234567&lt;template&gt; &lt;div&gt; &lt;text v-for=&quot;(v, i) in list&quot; class=&quot;text&quot;&gt;&#123;&#123;v&#125;&#125;&lt;/text&gt; &lt;image style=&quot;&quot; src=&quot;&quot;&gt;&lt;/image&gt; &lt;video class=&quot;video&quot; :src=&quot;src&quot; autoplay controls @start=&quot;onstart&quot; @pause=&quot;onpause&quot; @finish=&quot;onfinish&quot; @fail=&quot;onfail&quot;&gt;&lt;/video&gt; &lt;/div&gt;&lt;/template&gt; Weex 工程中常用的标签有&lt;div /&gt;，&lt;text /&gt;，&lt;image /&gt;，&lt;video /&gt;（组件另算），由此四种标签基本可以满足绝大多数场景的需求，虽说此标签同 web 工程下的标签用法一致，但此处的标签已不再是我们前端口中常提的 html 标签，而且名存实亡的 Weex 标签，确切讲是 Weex 组件。 通过weex-loader、vue-loader、weex-vue-render的解析最终转换输出的便是实际的组件，有此设计只是为了完成「web开发体验」的目标。但是我们身为上层的开发人员要清楚自己每天「把玩」的到底是个什么「鬼」。 阉割版 CSS其实用阉割版来形容 Weex 的 css 支持度并不合适，但如果从「web开发体验」的角度来衡量，那么这个形容词也是可以理解的。（此处对 Weex 寄有厚望^_^） 单位Weex 中的所有 css 属性值的单位均为 px，也可省略不写，系统会默认为 px 单位。 选择器Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。 123456789101112/* 支持单个类名选择器 */.one-class &#123; font-size: 36px;&#125;/* 不支持关系选择器 */.parent &gt; .child &#123; padding-top: 10px;&#125;/* 不支持属性选择器，不支持 `v-cloak` 指令 */[v-cloak] &#123; color: #FF6600;&#125; 这个只是对样式定义的限制，不影响样式类名的使用，在标签中可以添加多个样式类名，如： 123&lt;template&gt; &lt;div class=&quot;one two three&quot;&gt;&lt;div&gt;&lt;/template&gt; 盒模型weex支持css基本的盒模型结构，但需要注意的是 box-sizing 属性值默认为 border-box margin，padding，border等属性暂不支持合并简写 FlexBoxWeex 中对 flexbox 布局支持度很高，但依然有部分属性并不支持，如 align-items:baseline;、align-content:space-around;、align-self:wrap_reverse;等。 具体 Weex 对 flexbox 的支持和布局算法，可通过此文进行了解由 FlexBox 算法强力驱动的 Weex 布局引擎，此处便不再赘述。 显隐性在 Weex 的 ios 和 android 端，并不支持 display 属性。 因此，不能使用 display:none; 来控制元素的显隐性，所以 vue 语法中的 v-show 条件渲染是不生效的。 我们可以使用 v-if 代替，或者用 opacity:0; 来模拟。 需要注意的是，ios和android端并不能使用 opacity:0; 来完全模拟 visibility: hidden;，因为，当opacity 的只小于等于 0.01 时，native 控件便会消失，占位空间还在，但用户无法进行交互操作，点击时会发生点透效果。 CSS 3Weex 支持 css3 属性，虽然支持并不够，但相较 React Native 的「不能用」已经是强大很多了。 以下几种属性我们在开发前需要知道她的支持度 transform：目前只支持 2D 转换 transition：v0.16.0+ 的 SDK 版本支持css过度动画，可根据情况配合内建组件 animation 实现动画交互 linear-gradient：目前只支持双色渐变色 font-family：Weex 目前只支持 ttf 和 woff 字体格式的自定义字体 第三方工具库由于使用了增强版的 webpak 打包工具 weexpack，支持第三方框架也是件自然而然的事情。 常用的有 vuex、vue-router 等，可根据项目实际情况引入需要的第三方工具库 npm 包管理npm 包管理是前端开发朋友们再熟悉不过的包管理方式了。这也是为什么 React Native 和 Weex 都选择这种管理方式的原因。 以下是本工程的 package.json 文件，这里就不做讲解了，不熟悉的朋友点这里-&gt;NPM 使用介绍 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;name&quot;: &quot;yanxuan-weex&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a weex project&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;build_plugin&quot;: &quot;webpack --config ./tools/webpack.config.plugin.js --color&quot;, &quot;dev&quot;: &quot;weex-builder src dist -w&quot;, &quot;serve&quot;: &quot;webpack-dev-server --config webpack.dev.js -p --open&quot; &#125;, &quot;keywords&quot;: [&quot;weex&quot;], &quot;author&quot;: &quot;zwwill&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.4.2&quot;, &quot;vue-router&quot;: &quot;^2.7.0&quot;, &quot;vuex&quot;: &quot;^2.1.1&quot;, &quot;vuex-router-sync&quot;: &quot;^4.3.0&quot;, &quot;weex-html5&quot;: &quot;^0.4.1&quot;, &quot;weex-vue-render&quot;: &quot;^0.11.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.21.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.4&quot;, &quot;babel-plugin-add-module-exports&quot;: &quot;^0.2.1&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.9.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot;, &quot;babel-runtime&quot;: &quot;^6.9.2&quot;, &quot;css-loader&quot;: &quot;^0.26.1&quot;, &quot;history&quot;: &quot;^4.7.2&quot;, &quot;quick-local-ip&quot;: &quot;^1.0.7&quot;, &quot;vue-loader&quot;: &quot;^13.0.4&quot;, &quot;vue-template-compiler&quot;: &quot;^2.4.2&quot;, &quot;webpack&quot;: &quot;^2.7.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.4.2&quot;, &quot;weex-builder&quot;: &quot;^0.2.7&quot;, &quot;weex-loader&quot;: &quot;^0.4.5&quot;, &quot;weex-router&quot;: &quot;0.0.1&quot; &#125;&#125; UI 尺寸适配Weex 容器默认的显示宽度 (viewport) 是 750px，页面中的所有组件都会以 750px 作为满屏宽度。 这很像移动设备的逻辑像，比如 iPhone 6 的物理像素宽为 750，逻辑像素 Type iPhone 3G iPhone 4 iPhone 6 iPhone 6Plus 物理像素 320x480 640x960 750x1134 1080x1920 逻辑像素 320x480 320x480 375x667 414x736 像素比 @1x @2x @2x @3x 类比在 Weex 中，如果所有的显示宽度都是用默认值 750，那么显示出来的实际像素信息为 Type iPhone 3G iPhone 4 iPhone 6 iPhone 6Plus 物理像素 320x480 640x960 750x1134 1080x1920 显示像素 750x1125 750x1125 750x1134 750x1333 像素比 @0.427x @0.85x @1x @1.44x 所以我们在使用 Weex 做 UI 适配时就没有所谓的 @2x 图和 @3x 图，所有的尺寸都是Weex帮我们根据750 作为基数宽做的缩放。 当然，Weex 提供了改变此显示宽度的 API，setViewport，通过此方法可以改变页面的显示宽度，可以实现每个页面根据自己的需求改变基数逻辑尺寸 因此对于一些固定的 icon，不建议使用普通的静态图片或者雪碧图，这里建议使用矢量的字体图片，有以下优点： 适量图不会变糊 使用方便，通过 css 的字号控制大小，不用适配机型和屏幕尺寸 引用 ttf 文件，体积小，且容易更新 本地调试Weex 的调试方式有多种，如果说RN的调试模式是解放了原生开发的调试，那么 Weex 的调试方式可以说是赋予了 web 模式调试原生应用的能力。 方法一此方法多用于解决 bug，检测控件的布局问题 1234# 调试单个页面$ weex debug your_weex.vue# 调试整个工程$weex debug your/path -e App.vue 执行调试命令后，会将指定的文件打包成 JSBundle，并启动一个 weex Devtool 服务（http://localhost:8088可访问，如下图），同时将 JSBundle 文件传递至该服务跟路径下的weex文件夹内（http://localhost:8088/weex/App.js，实际是下图右边二维码的的内容）。 使用 Weex Playground App 扫下左二维码进入调试模，见下图 再次扫码右方二维码，点击【inspector】即可进入调试模式。 每一个控件都是相同的数据结构 1&lt;view class=&quot;WXText&quot; frame=&quot;&#123;&#123;0,0&#125;,&#123;414,736&#125;&#125;&quot; hidden=&quot;NO&quot; alpha=&quot;1&quot; opaque=&quot;YES&quot;&gt;&lt;/view&gt; class：代表原声空间类型 frame：表示空间的坐标和大小 hidden：代表显隐性，css中visibility设置的值 alpha：不透明度，css中opacity设置的值 opaque：默认为YES，打开绘图系统性能优化的开关，即不去计算多透明块重合后的真正颜色，从而减小GPU的压力，weex中具体有没有地方可以设置这个开关暂时不清楚，有猎奇心的朋友可以研究下。 方法二此方法多用于开发调试，试试观察结果 1$ weex your_weex.vue 如果出现 access 权限报错，使用管理员指令 1$ sudo weex your_weex.vue 此时本地同时启动一个watch的服务器用于检查代码变更，自动重新构建 JSBundle，视觉同步刷新。 上图看到的效果即为H5页面的效果，我们一般在整个单页编写完成后在使用 Weex Playground App 扫码查看真机效果，或者你也可以在编写的同时使用真机观察代码的运行效果，每次重新构建包到重绘的速度还是很快的。 但前提是你要保证，你的手机和电脑的连在同一个局域网下，并且使用IP访问。 Weex 的原理 虽然说，Weex 可以抹平三端开发的差异，但是知其然也应知其所以然使用起来才能游刃有余。 打包熟悉 React Native 的人都知道， React Native 的发布实际上就是发布一个 JSBundle，Weex 也是这样，但不同的是，Weex 将工程进行分包，发布多个 JSBundle。因为 Weex 是单页独立开发的，每个页面都将通过 Weex 打包器将 vue/we 页面打包成一个单独的 JSBundle，这样的好处在于减少单个 bundle 包的大小，使其变的足够小巧轻量，提高增量更新的效率。 123456# 仅打包$ npm run build# 打包+构建$ weex build ios# 打包+构建+安装执行$ weex run ios 以上三种均会触发 Weex 对工程进行打包。在我们执行了以上打包命令后，所有的工程文件将被单独打成一个独立的 JSBundle，如下： 打包后的 JSBundle 有两种格式 12345678910# 由.vue文件打包出来的包格式（简写），使用 vue 2.0 语法编写// &#123; &quot;framework&quot;: &quot;Vue&quot;&#125; /******/ (function(modules) &#123; ......./******/ &#125;)# 由.we文件打包出来的包格式（简写），使用 weex 语法编写// &#123; &quot;framework&quot;: &quot;Weex&quot; &#125;/******/ (function(modules) &#123; ......./******/ &#125;) 不同的头部是要告诉使用什么语法解析此JSBundle。 至此，我们准备「热更新的包」就已经准备完毕了，接下就是发包执行了。 发包打包后的 JSBundle 一般发布到发包服务器上，客户端从服务器更新包后即可在下次启动执行新的版本，而无需重新下载 app，因为运行依赖的 WeexSDK 已经存在于客户端了，除非新包依赖于新的 SDK，这也是热更新的基本原理。 【WeexSDK】包括 【JS Framework】JSBundle 的执行环境 【JS-Native Bridge】中间件或者叫通讯桥梁，也叫【Weex Runtime】 【Native Render Engine】解析 js 端发出的指令做原生控件布局渲染 执行Weex 的 iOS 和 Android 客户端的【JSFramework】中都会运行一个 JavaScript 引擎，来执行 JS bundle，同时向各端的渲染层发送规范化的指令，调度客户端的渲染和其它各种能力。iOS 下选择了 JavaScriptCore 内核，而在 Android 下选择了 UC 提供的 v8 内核（RN两端都是JavaScriptCore 内核）。 JSBundle 被 push 到客户端后就会在 JSFramework 中执行，最终输出三端可读性的 VNode 节点，数据结构简化如下： 1234567891011121314151617181920212223242526&#123; tag: &apos;div&apos;, data: &#123; staticStyle: &#123; justifyContent: &apos;center&apos; &#125; &#125;, children: [&#123; tag: &apos;text&apos;, data: &#123; staticClass: &apos;txt&apos; &#125;, context: &#123; $options: &#123; style: &#123; freestyle: &#123; textAlign: &apos;center&apos;, fontSize: 200 &#125; &#125; &#125; &#125;, children: [&#123; tag: &apos;&apos;, text: &apos;文字&apos; &#125;] &#125;]&#125; 有了统一的 VNode 节点，各端即可根据自己的方法解析渲染原生UI了，之前的所有操作都是一致的，包括文件格式、打包编译过程、模板指令、组件的生命周期、数据绑定等。 然而由于目标执行环境不同（浏览器和 Weex 容器），在渲染真实原生 UI 的时候调用的接口也不同。 此过程发生在【Weex SDK】的【Weex Runtime】中。 最总【Weex Runtime】发起渲染指令callNative({...})有RenderEngine完成渲染 总结一下 Weex 文件分包打包成单个 JSBundle 文件 发布到发包服务器上，通过热更新 push 到用户的客户端，交由【Weex SDK】执行解析 SDK 中的【JS Framework】执行 Bundle 脚本生成 Virtual DOM Virtual DOM 经由各端执行环境【Weex Runtime】解析翻译成执行指令 【Native RenderEngine】接收到指令后执行渲染操作，作出渲染出完整的界面 官方配图： 扩充配图： Weex 的工作模式1. 全页模式目前支持单页使用或整个 App 使用 Weex 开发（还不完善，需要开发 Router 和生命周期管理）。 本文先行的严选 demo 便是使用第二种全屏模式，使用 Weex 开发整个 App，期间触碰到 Weex 的在此模式下诸多不足，如 StatusBar 控制、Tab 切换、开场动画自定义、3DTouch、 Widget 等等原生的特色功能没有现成的 API，需要我们自己扩展，甚至扩展不了。因此并不能完全“灭掉”原生。 所以，目前在阿里内部使用较多的是此模式中的单页模式，这也是为什么官方文档在介绍原理后就直接奔入集成到原生应用的主题上去了。 2. Native Component 模式把 Weex 当作一个 iOS/Android 组件来使用，类比 ImageView。这类需求遍布手淘主链路，如首页、主搜结果、交易组件化等，这类 Native 页面主体已经很稳定，但是局部动态化需求旺盛导致频繁发版，解决这类问题也是 Weex 的重点。 3. H5 Component 模式在 H5 种使用 Weex，类比 WVC。一些较复杂或特殊的 H5 页面短期内无法完全转为 Weex 全页模式（或RN），比如互动类页面、一些复杂频道页等。这个痛点的解决办法是：在现有的H5页面上做微调，引入Native 解决长列表内存暴增、滚动不流畅、动画/手势体验差等问题。 另外，WVC 将会融入到 Weex 中，成为 Weex 的 H5 Components 模式。 严选 App Demo 实现过程中的感想Vue-Router &amp; Tab 由于 Weex 没有封装 Tab 的组件，因此笔者使用了很多方法来实现Tab切换的功能。 1、vue-router：router 思想方便管理，但是每次切换都是新的实例，没有tab模式2、opacity、visablity：此处需要注意，Weex的渲染机制和web是有区别的，对夫层设置 opacity 或者visiablity隐藏是无法同时隐藏定位为position:fixed; 的子元素。3、position、transform：改变 tab 层的位置，此方法在定位为 position:fixed; 的子元素上依然无效。 image &amp; iconfontWeex 中所有的静态资源基本都是网络资源，包括图片、字体图片等，所以使用 iconfont 图标是再合适不过的了。 此 demo 中所有的 icon 均使用 的iconfont。 此处强烈推荐一个站点 www.iconfont.cn。 在此平台你可以找到几乎所有你需要的 icon，你也可以上传自己的 icon 到自己创建的项目中。同时该系统还提供生成ttf、woff 资源，并且做了 cdn 加速和 gzip 压缩，是不是跟 Weex很配呢？ 不过也有风险，就是，如果哪天阿里不在维护并回收该平台的资源了，你的 app 可能就会变成这样，全是方框，或者 padding 掉你 H5 的页面 当然，这种及情况出现的几率很小，如果你是一个大公司，你手上有更好的资源急速方案，那就自己保存吧。 webview UIWebView是我们开发App常用的一个控件，不过Weex帮我们封装好的API明显时不够用的，目前只有pagestart、pagefinish、error，并没有封装像RN那样的onShouldStartLoadWithRequest拦截地址请求的API，在我看来，这有些不合理，并不清楚轮子的制造者是什么意图。 性能性能是一个大课题，在此就不做展开了，只稍微提及一些我们开发需要注意的几点 性能影响点：UI更新&gt;UI事件响应&gt;后台运算 合理优化过场&amp;动画，过场和 console 容易引起 app crash 需要注意 降低 js &lt;-&gt; native 的通信频率 优化list结构，降低重排重绘压力 把优先级低且耗时较长的工作推后处理 Weex 的现状Weex 解决了的我的发布我做主（热更新）脚本语言天生自带“热更新”，Weex 针对 React Native 的热更新策略做了优化，将 WeexSDK 事先绑到了客户端上，并且对 JSBundle 进行分包增量更新，大大提高了热更新的效率。 但优点也是缺点，如果新包依赖于心的 SDK，此情况下，我们需要发布还有新 SDK 的 app 到应用市场，用户也须从市场更新此 app。不够随着 WeexSDK 版本的稳定后，相信此策略的优势就会凸显出来。 性能问题Weex 是一种轻量级、可扩展、高性能框架。集成也很方便，可以直接在 HTML5 页面嵌入，也可嵌在原生UI中。由于和 React Native 一样，都会调用 Native 端的原生控件，所以在性能上比 Hybrid 高出一个层次。 统一三端虽说这是一个大胆的实践，但对于大前端社区的统一有着推动作用，显然阿里在这一方面已经迈出了第一步。基本解决了三端同等需求导致资源浪费的痛点。 但后期可能会出现这种现象，开发一个三端的 App 会从原来的个人变成四个人，多出来的那一个人负责开发 Weex 单页。 意思就是，三端统一的不够彻底，但就目前的环境下，这一句是最优方案了，却是提高了开发效率。大前端将来将如何一统三国我们且行且观望吧。 做游戏对于一些交互视觉统一且没有很大的性能需求的游戏，Weex 还是可以胜任的。 近期笔者将尝试发布一款纯Weex构建的益智小游戏，敬请期待。 朋友们可以用这个demo体验下 Weex 版扫雷游戏开发 Weex “暂时”放弃的虽然说大一统事件百利的事，但并非无一害。 差异化对于一些有差异化完美体验追求的项目就只能收敛或者放弃了。 独立的 bug 修复对于三端同时上线，一端存在 bug 的情况，Weex 并不能保证做到牵一发而不动全身。 个性化功能比如安卓的波纹按钮、3DTouch、 Widget、iWatch版本等，目前这些功能还是没有的，不知道以后 Weex是否将其加入到官方文档中。 声明以上均为个人见解，不代表官方。如有不当之处还望指正。 参考[ 1 ] Weex官方文档 - http://weex.apache.org/cn/references/[ 2 ] 场景研读 - Native 性能稳定性极致优化 - https://yq.aliyun.com/articles/69005[ 3 ] 门柳 - 详解 Weex JS Framework 的编译过程 - https://yq.aliyun.com/articles/59935?spm=5176.8067842.tagmain.66.1QA1fL[ 4 ] 阿里百川 - 深度揭秘阿里移动端高性能动态化方案Weex - https://segmentfault.com/a/1190000005031818[ 5 ] 一缕殇流化隐半边冰霜 - Weex 是如何在 iOS 客户端上跑起来的 - http://www.jianshu.com/p/41cde2c62b81 转载请标明出处作者：木羽 zwwill首发地址：https://github.com/zwwill/blo…]]></content>
      <categories>
        <category>前端</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 在Android端的实践]]></title>
    <url>%2Fposts%2F31c875b0.html</url>
    <content type="text"><![CDATA[ShowPage ShowPage ShowPage 什么是weex Write Once, Run Everywhere Weex能够完美兼顾性能与动态性，让移动开发者通过简捷的前端语法写出Native级别的性能体验，并支持iOS、安卓、YunOS及Web等多端部署。真正实现一次撰写，多平台运行。 Weex 提供了多端一致的技术方案。 首先 web 开发体验在各端当中是相同的。包括语法设计和工程链路。 其次，Weex 的组件、模块设计都是 iOS、Android、Web 的开发者共同讨论出来的，有一定的通用性和普遍性。 Weex 开发同一份代码，可以在不同的端上分别执行，避免了多端的重复研发成本。 在同构这条路上，WEEX比ReactNative做得更彻底，他“几乎”做到了，“你来使用vue写一个webapp，我顺便给你编译成了ios和android的原生app” 为什么要用weex东西是好东西，对于电商这类经常需要变动 APP 界面的尤其适用。看看天猫、淘宝首页你就知道了。但一定不会适用于所有人，需求千变万化，总有框架照顾不到的地方。我在下面也列几张我们用weex后的首页。 用原生如何实现？当我没用weex的时候，我想：这还非得用weex，我用native也能实现。我接不同的type展现不同的UI不就行了。这当然可以了，我始终相信一点，需求通过不同的技术手段都可以实现，只是实现方式的简易程度和灵活度的差别。 用weex的优势？首先，weex是组件化的。什么是组件化？很好理解，他的每一块儿都是独立，我们只需根据不同的类型，将不同的组件组合在一起就行了，耦合度很低，当一个组件出问题不会影响其他组件渲染。但如果我用原生写，肯定是一页，然后根据不同的数据，展现出来，可能一个数据出错，我这一整页都是空白的。其次，weex还有一个好处，可以热更新这个页面，假如：线上时突然又想新增一种组件样式（例如banner吧），这个时候原生界面肯定说：等下个版本迭代给你新加。但weex就可以直接新增一种组件，然后发一个热更新文件，让原生加载新的js文件即可。 Android 嵌入weex集成weex有两种模式，一种是源码集成，另一种sdk依赖。这里没有坑，就按照接入文档接入就行，有一点注意一下，用源码依赖可以拿到最新版本，但通过源码依赖拿的版本就会落后一些，但比较稳定。 12345678910111213141516171819dependencies &#123; implementation fileTree(dir: &apos;../module_common/libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:27.1.1&apos; //router implementation &apos;com.alibaba:arouter-api:1.3.1&apos; annotationProcessor &apos;com.alibaba:arouter-compiler:1.1.4&apos; implementation &apos;com.alibaba:fastjson:1.2.31&apos; implementation &apos;com.google.code.gson:gson:2.8.5&apos; implementation &apos;com.github.bumptech.glide:glide:4.8.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.3.0&apos; implementation &apos;com.taobao.android:weex_sdk:0.20.3.0-beta@aar&apos; // 接入 weex inspector implementation &apos;com.taobao.android:weex_inspector:0.20.3.0-beta@aar&apos; implementation &apos;com.squareup.okhttp3:okhttp:3.10.0&apos; implementation &apos;com.squareup.okhttp:okhttp:2.3.0&apos; implementation &apos;com.squareup.okhttp:okhttp-ws:2.3.0&apos;&#125; 实现一个ImageAdapter接入weex后需要自己实现一个ImageAdapter，用于展示图片，我是基于glide框架的，当然也可以选择基于fresco，picasso等等。 12345678910111213141516171819202122232425262728293031323334353637383940414243import android.text.TextUtils;import android.widget.ImageView;import com.bumptech.glide.Glide;import com.taobao.weex.WXSDKManager;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现自己的图片下载。 WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (view == null || view.getLayoutParams() == null) &#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith("//")) &#123; temp = "http:" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; if (view != null &amp;&amp; view.getContext() != null) &#123; try &#123; Glide.with(view.getContext()).load(temp).into(view); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, 0); &#125;&#125; weex加载方式文档说只说了通过file的形式加载js文件，其实我们也可以通过URL的方式渲染，当我们调试的时候就需要连接服务器进行修改，也就是通过URL方式加载。 1234//根据URL渲染mInstance.renderByUrl(getPageName(), url, options, jsonInitData, WXRenderStrategy.APPEND_ONCE);//根据文件渲染mWXSDKInstance.render(name, WXFileUtils.loadAsset(name+".js", this), null, null, WXRenderStrategy.APPEND_ASYNC); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/** * weex 基础容器类 */public abstract class BaseWeexContainerActivity extends AppCompatActivity implements IWXRenderListener, IWeexPageRefresh &#123; private static final String TAG = BaseWeexContainerActivity.class.getSimpleName(); protected String mBundleUrl; private FrameLayout mContainer; protected WXSDKInstance mWXSDKInstance; /** 网络异常页面 */ private View mEmptyView; /** Loading页面 */ private View mLoadingView; private Handler mHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.weex_activity_container); mContainer = findViewById(R.id.container); mLoadingView = findViewById(R.id.loading_view); mEmptyView = findViewById(R.id.empty_view); initListeners(); &#125; private void initListeners() &#123; mEmptyView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (!WeexBaseUtil.isInternetConnected(BaseWeexContainerActivity.this)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.net_error); &#125; else &#123; mLoadingView.setVisibility(View.VISIBLE); mEmptyView.setVisibility(View.GONE); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; loadWeexPage(TAG, mBundleUrl); &#125; &#125;, 100); &#125; &#125; &#125;); &#125; protected void loadWeexPage(String pageName, String bundleUrl) &#123; if (!TextUtils.isEmpty(bundleUrl)) &#123; mBundleUrl = bundleUrl; createWeexInstance(); /** * pageName:自定义，一个标示符号。 * url:远程bundle JS的下载地址 * options:初始化时传入WEEX的参数，比如 bundle JS地址 * flag:渲染策略。WXRenderStrategy.APPEND_ASYNC:异步策略先返回外层View，其他View渲染完成后调用onRenderSuccess。 * WXRenderStrategy.APPEND_ONCE 所有控件渲染完后后一次性返回。 */ Map&lt;String, Object&gt; options = new HashMap&lt;&gt;(); options.put(WXSDKInstance.BUNDLE_URL, mBundleUrl); String jsonData = WeexBaseUtil.convertHttpRequestParamData(mBundleUrl); // 获取缓存文件名 final String filename = JsCacheTool.getCacheFilename(mBundleUrl); // 检测缓存文件是否存在 if (JsCacheTool.checkCacheExist(mBundleUrl)) &#123; // 存在，读取缓存 String template = JsCacheTool.loadLocalCacheData(filename); mWXSDKInstance.render(pageName, template, options, jsonData, WXRenderStrategy.APPEND_ASYNC); &#125; else &#123; // 缓存不存在，异步从服务器拉取并缓存到本地 mWXSDKInstance.renderByUrl(pageName, mBundleUrl, options, jsonData, WXRenderStrategy.APPEND_ASYNC); JsCacheTool.downloadCacheToFileAsync(mBundleUrl, filename, null); &#125; &#125; &#125; protected void refreshPage() &#123; if (!TextUtils.isEmpty(mBundleUrl)) &#123; createWeexInstance(); Map&lt;String, Object&gt; options = new HashMap&lt;&gt;(); options.put(WXSDKInstance.BUNDLE_URL, mBundleUrl); String jsonData = WeexBaseUtil.convertHttpRequestParamData(mBundleUrl); mWXSDKInstance.renderByUrl(mWXSDKInstance.getWXPerformance().pageName, mBundleUrl, options, jsonData, WXRenderStrategy.APPEND_ASYNC); &#125; &#125; @Override public void onStart() &#123; super.onStart(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityStart(); &#125; &#125; @Override public void onResume() &#123; super.onResume(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override public void onPause() &#123; super.onPause(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override public void onStop() &#123; super.onStop(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityDestroy(); &#125; destoryWeexInstance(); &#125; private void createWeexInstance() &#123; destoryWeexInstance(); if (mWXSDKInstance == null) &#123; mWXSDKInstance = new WXSDKInstance(BaseWeexContainerActivity.this); mWXSDKInstance.registerRenderListener(this); &#125; &#125; private void destoryWeexInstance() &#123; if (mWXSDKInstance != null) &#123; mWXSDKInstance.registerRenderListener(null); mWXSDKInstance.destroy(); mWXSDKInstance = null; &#125; &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.GONE); if (mContainer != null) &#123; mContainer.removeAllViews(); mContainer.addView(view); &#125; &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.GONE); &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.GONE); &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.VISIBLE); if (WXErrorCode.WX_ERR_JS_FRAMEWORK.getErrorCode().equalsIgnoreCase(errCode)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.weex_create_instance_error); &#125; else if (WXErrorCode.WX_DEGRAD_ERR_NETWORK_CHECK_CONTENT_LENGTH_FAILED.getErrorCode().equalsIgnoreCase(errCode)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.weex_network_error); &#125; else if (WXErrorCode.WX_DEGRAD_ERR_BUNDLE_CONTENTTYPE_ERROR.getErrorCode().equalsIgnoreCase(errCode)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.weex_user_intercept_error); &#125; &#125;&#125; Android 嵌入weex devtools调试工具1：先通过npm install 安装项目依赖。之后运行npm run dev和npm run serve2：运行weex debug，就会开启一个chrome 的 inspect/debug 工具3：完成上面两个步骤，服务端就相当于配置成功了，之后我们只需要在我们的代码中配好相应的库，完善代码就可以了 Android 实现热调试功能Android调试功能很简单就可以实现，但是热调试功能却花我一些时间。什么是热调试功能呢？当我修改服务器的代码，通过刷新浏览器，APP端数据也会跟着改变，这就是热调试。热调试功能是如何工作的呢？其实当我刷新时，会在APP的广播接收器接到相应的指令，此时我们重新reload相应的js文件即可。 1234567891011121314151617181920212223242526272829public void registerBroadcastReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; mBroadcastReceiver = receiver != null ? receiver : new DefaultBroadcastReceiver(); if (filter == null) &#123; filter = new IntentFilter(); &#125; filter.addAction(IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH); filter.addAction(WXSDKEngine.JS_FRAMEWORK_RELOAD); LocalBroadcastManager.getInstance(getApplicationContext()) .registerReceiver(mBroadcastReceiver, filter); if (mReloadListener == null) &#123; setReloadListener(new WxReloadListener() &#123; @Override public void onReload() &#123; createWeexInstance(); renderPage(); &#125; &#125;); &#125; if (mRefreshListener == null) &#123; setRefreshListener(new WxRefreshListener() &#123; @Override public void onRefresh() &#123; createWeexInstance(); renderPage(); &#125; &#125;); &#125; &#125; weex上手还是比较容易的，希望每个人都有一直学习的热情与能力~]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 中使用Vue.js]]></title>
    <url>%2Fposts%2F937a42e9.html</url>
    <content type="text"><![CDATA[只含有运行时的构建版本 平台的差异 执行环境 DOM 样式 事件 Web 渲染器 单文件组件 编译目标 使用weex-loader 支持的功能 全局配置 全局 API 选项 生命周期钩子 实例属性 实例方法 模板指令 特殊属性 内置组件 在 WeexSDK v0.10.0 （发布于 2016 年 2 月 17 日）以及后续的版本中，集成了 v2 版本的 Vue.js。Vue 是一套构建用户界面的渐进式框架，详情请参阅其官方网站。 如果没有特别指示，文章中的 “Vue.js” 或者 “Vue” 都指的是 v2 版本的 Vue。 只含有运行时的构建版本如果你熟悉 Vue.js，你应该知道 Vue.js 有两种构建版本: 运行时 + 编译器 与 只包含运行时。它们之间的区别在于编译器是否需要能够在运行时编译 template 选项。由于运行时构建版本比完整版本的构建版本轻约 30%（Vue 官方估算），为了更好的性能和更小的代码体积，Weex 集成的是运行时版本的 Vue。 具体来说，差异如下： 定义组件时不支持 template 选项。 不支持使用 x-templates。 不支持使用 Vue.compile。 平台的差异Vue.js 最初是为 Web 平台设计的。虽然可以基于Weex开发原生应用程序，但是仍然存在许多Weex 与 Web 平台的差异。 与 Web 平台的主要差异是: 执行环境、DOM、样式和事件。 执行环境Weex 主要用于编写多页的应用程序，每个页面都对应了原生开发中的 View 或者 Activity，并且保持自己的上下文。即使 Weex 的所有页面都使用的都是同一个 Javascript 引擎的实例(virtual machine)，每个页面是执行环境也是互相隔离的（基于 Sandbox 技术）。 使用 BroadcastChannel 可以实现跨页通信。 具体来讲，每个页面的 Vue 变量都是不同的实例，即使是写在 Vue 上的“全局”配置（Vue.config.xxx）也只会影响 Weex 上的单个页面。 在此基础上，一些 Vue 的 SPA （单页面应用）技术，如 Vuex 和 vue-router 也将单页内生效。更通俗地说，“页面”概念在 SPA 技术中是虚拟的，但在 Weex 上却是真实的。即便如此，Vuex 和 vue-router 都是独立的库，都有自己的概念和使用场景，仍然可以在 Weex 里使用 Vuex 和 vue-router。 DOM因为在 Android 和 iOS 上没有 DOM（Document Object Model），如果你要手动操作和生成 DOM 元素的话可能会遇到一些兼容性问题。在你使用现代前端框架的情况下，操作数据与组件而不是生成的元素是一个比较好的做法。 一些与 DOM 相关的特性，比如 v-html，vm.$el，template 选项，在不同的平台上可能无法获得相同的反应。 准确来说，vm.$el属性类型在web环境下是HTMLElement，但是在移动端并没有这个类型。实际上，它是一个由 Weex 文档对象模型 定义的特殊数据结构。 样式样式表和 CSS 规则是由 Weex js 框架和原生渲染引擎管理的。要实现完整的 CSS 对象模型（CSSOM：CSS Object Model）并支持所有的 CSS 规则是非常困难的，而且没有这个必要。 出现性能考虑，Weex 目前只支持单个类选择器，并且只支持 CSS 规则的子集。详情请参阅 通用样式 与 文本样式。 在 Weex 里， 每一个 Vue 组件的样式都是 scoped。 事件目前在 Weex 里不支持事件冒泡和捕获，因此 Weex 原生组件不支持事件修饰符，例如.prevent，.capture，.stop，.self 。 此外，按键修饰符以及系统修饰键 例如 .enter，.tab，.ctrl，.shift 在移动端基本没有意义，在 Weex 中也不支持。 Web 渲染器如果你想在网络上呈现你的页面，你需要 weex-vue-render 来实现它。 weex-vue-render是 Vue DSL 的 Web 渲染器， 它在 Web 上实现了 Weex 的内置组件和内置模块。详情请参阅这里。 单文件组件Vue 中的单文件组件（即*.vue文件）是一种特殊的文件格式，扩展名为.vue。这个模板会在构建时便于到render函数里。 此外，所有的编辑器里都支持一个好的语法高亮插件。 在 Weex 中使用单个文件组件语法是一种很好的做法。 TIP 在 Weex 中使用 Vue 的单个文件组件语法是一种最佳实践。 因为针对 Weex 的 Web 平台的编译工具并不一样，如果你直接写的 render 函数，则绕过了 weex-loader 编译模板的过程，这样的话你需要自行处理平台差异的细节。 编译目标因为平台的差异以及为了提高网络性能，*.vue文件需要用两种不同的方式来编译： 对于 Web 平台来说，你可以用任何正式的方式来编译源文件，例如 使用 Webpack + vue-loader 或者 Browserify + vueify 来编译*.vue文件。 对于安卓与 iOS 平台来说， 你需要使用 weex-loader 来编译*.vue文件。 不同的平台使用不同的bundles，可以充分利用平台原有的特性，减少构建时的兼容性代码。但是源代码仍然是一样的，唯一的区别是编译它的方法。 使用weex-loaderweex-loader 是一个 webpack 的 loader，它能把*.vue文件转化为简单的javascript 模块用于安卓以及 iOS 平台。所有的特性和配置都是跟 vue-loader 一样的。 需要注意的是，如果 Webpack 的 entry 配置项是一个 *.vue 文件的话，你仍需要传递一个额外的 entry 参数作为标记。 1234567891011121314const webpackConfig = &#123; // Add the entry parameter for the .vue file entry: './path/to/App.vue?entry=true' /* ... */ use: &#123; loaders: [&#123; // matches the .vue file path which contains the entry parameter test: /\.vue(\?^^]+)?$/, loaders: ['weex-loader'] &#125;] &#125;&#125; 如果你现在用的是.js文件做入口文件，你不需要写那些额外的参数。 推荐 webpack 配置的入口文件使用 javascript 文件。 123&#123; entry: './path/to/entry.js'&#125; TIP 无论什么情况下都使用 javascript 文件作为入口文件。 支持的功能全局配置 Vue “全局”配置只会影响 Weex 上的单一页面，配置不会在不同的 Weex 页面之间共享。 Vue 全局配置 是否支持 说明 Vue.config.silent 支持 - Vue.config.optionMergeStrategies 支持 - Vue.config.devtools 不支持 只在 Web 环境下支持 Vue.config.errorHandler 支持 - Vue.config.warnHandler 支持 - Vue.config.ignoredElements 支持 不推荐 Vue.config.keyCodes 不支持 在移动端无用 Vue.config.performance 不支持 与 devtools 一样 Vue.config.productionTip 支持 - 全局 API Vue 全局 API 是否支持 说明 Vue.extend 支持 - Vue.nextTick 支持 - Vue.set 支持 - Vue.delete 支持 - Vue.directive 支持 - Vue.filter 支持 - Vue.component 支持 - Vue.use 支持 - Vue.mixin 支持 - Vue.version 支持 - Vue.compile 不支持 Weex 用的是 只包含运行时构建 选项 Vue 选项 是否支持 说明 data 支持 - props 支持 - propsData 支持 - computed 支持 - methods 支持 - watch 支持 - el 支持 在移动端el的值是无意义的 template 不支持 Weex 用的是 只包含运行时构建 render 支持 不推荐 renderError 支持 - directives 支持 - filters 支持 - components 支持 - parent 支持 不推荐 mixins 支持 - extends 支持 - provide/inject 支持 不推荐 name 支持 - delimiters 支持 不推荐 functional 支持 - model 支持 - inheritAttrs 支持 - comments 不支持 - 生命周期钩子Vue 组件的实例生命周期钩子将在特定的阶段发出，详情请参考 Vue 组件的生命周期图示。 Vue 生命周期钩子 是否支持 说明 beforeCreate 支持 - created 支持 - beforeMount 支持 - mounted 支持 和 Web 端不完全一样（下文有详解） beforeUpdate 支持 - updated 支持 - activated 不支持 不支持&lt;keep-alive&gt; deactivated 不支持 不支持&lt;keep-alive&gt; beforeDestroy 支持 - destroyed 支持 - errorCaptured 支持 在 Vue 2.5.0+， Weex SDK 0.18+ 中新增 关于 “mounted” 生命周期 和浏览不同的是，Weex 的渲染流程是异步的，而且渲染出来的结果都是原生系统中的 View，这些数据都无法被 javascript 直接获取到。因此在 Weex 上，Vue 的 mounted 生命周期在当前组件的 virtual-dom (Vue 里的 VNode) 构建完成后就会触发，此时相应的原生视图未必已经渲染完成。 实例属性 Vue 实例属性 是否支持 说明 vm.$data 支持 - vm.$props 支持 - vm.$el 支持 移动端没有HTMLElement vm.$options 支持 - vm.$parent 支持 - vm.$root 支持 - vm.$children 支持 - vm.$slots 支持 - vm.$scopedSlots 支持 - vm.$refs 支持 - vm.$isServer 支持 永远是false vm.$attrs 支持 - vm.$listeners 支持 - 实例方法 Vue 实例方法 是否支持 说明 vm.$watch() 支持 - vm.$set() 支持 - vm.$delete() 支持 - vm.$on() 支持 - vm.$once() 支持 - vm.$off() 支持 - vm.$emit() 支持 - vm.$mount() 不支持 你不需要手动安装 Vue 实例 vm.$forceUpdate() 支持 - vm.$nextTick() 支持 - vm.$destroy() 支持 - 模板指令 Vue 指令 是否支持 说明 v-text 支持 - v-html 不支持 Weex 中没有 HTML 解析器，这不是很好的实现 v-show 不支持 不支持 display: none; v-if 支持 - v-else 支持 - v-else-if 支持 - v-for 支持 - v-on 支持 不支持事件修饰符 v-bind 支持 - v-model 支持 - v-pre 支持 - v-cloak 不支持 只支持单类名选择器 v-once 支持 - 特殊属性 Vue 特殊属性 是否支持 说明 key 支持 - ref 支持 - slot 支持 - slot-scope 支持 在 Vue 2.5.0+， Weex SDK 0.18+ 中新增 scope 支持 不推荐 is 支持 - 内置组件 Vue 内置组件 是否支持 说明 component 支持 - transition 不支持 在移动端 enter 与 leave 的概念可能有点不同， 并且 Weex 不支持display: none; transition-group 不支持 跟 transition 一样 keep-alive 不支持 移动端的原生组件不能被前端缓存 slot 支持 -]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 和 Web 的平台差异]]></title>
    <url>%2Fposts%2Fb78de55a.html</url>
    <content type="text"><![CDATA[Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。 Weex 环境中没有 DOMDOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。 不支持 DOM 操作原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。 有限的事件类型Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。 支持 Web 中的事件类型，详情请参考《通用事件》。 不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。 Weex 环境中没有 BOMBOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端并不基于浏览器运行，不支持浏览器提供的 BOM 接口。 没有 window 、screen 对象Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。 1WXEnvironment weexVersion: WeexSDK 的版本。 appName: 应用的名称。 appVersion: 应用的版本。 platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。 osName: 系统的名称。 osVersion: 系统版本。 deviceWidth: 设备宽度。 deviceHeight: 设备高度。 没有 document 对象在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。 没有 history 、location 、navigator 对象 history 保存了当前页面的历史记录，并且提供了前进后退操作。 location 记录了当前页面 URL 相关的信息。 navigator 记录了当前浏览器中的信息。 这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。 此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。 能够调用移动设备原生 API在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。 《clipboard 剪切板》 《navigator 导航控制》 《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块。 有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 集成到Android应用]]></title>
    <url>%2Fposts%2F10965f08.html</url>
    <content type="text"><![CDATA[在执行以下步骤之前，请先确认您的Android开发环境是ok的。 JAVA环境, jdk7+ Android Studio NDK r16、Cmake 3.9.0+ (可选项：如果需要编译WEEX源码，需要NDK环境支持) 1. 设置gradle依赖1234567891011dependencies &#123; ... // weex sdk and fastjson compile &apos;com.taobao.android:weex_sdk:0.20.0.2@aar&apos; compile &apos;com.alibaba:fastjson:1.1.46.android&apos; //support library dependencies compile &apos;com.android.support:recyclerview-v7:23.1.1&apos; compile &apos;com.android.support:support-v4:23.1.1&apos; compile &apos;com.android.support:appcompat-v7:23.1.1&apos;&#125; 2. 配置混淆规则混淆规则如下，建议参考最新的源码配置 12345-keep class com.taobao.weex.bridge.** &#123; *; &#125;-keep class com.taobao.weex.layout.** &#123; *; &#125;-keep class com.taobao.weex.WXSDKEngine &#123; *; &#125;-keep class com.taobao.weex.base.SystemMessageHandler &#123; *; &#125;-dontwarn com.taobao.weex.bridge.** 3. 声明权限在AndroidManifest.xml中声明权限 1234567//网络&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;//sd卡读写&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 4. 初始化sdk1234567InitConfig config = new InitConfig.Builder() //图片库接口 .setImgAdapter(new FrescoImageAdapter()) //网络库接口 .setHttpAdapter(new InterceptWXHttpAdapter()) .build();WXSDKEngine.initialize(applicationContext,config); demo初始化源码 其它扩展配置看这里 5. 创建WXSDKInstanceWXSDKInstance是weex渲染页面的基本单元， 通过instance.render(url)拉取bundle， 在回调IWXRenderListener的onViewCreated返回创建的view， 将返回的view 添加到Activity的view上（rootView） 参见源码: WXPageActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * bundleUrl source http://dotwe.org/vue/38e202c16bdfefbdb88a8754f975454c */ String pageName = "WXSample"; String bundleUrl = "http://dotwe.org/raw/dist/38e202c16bdfefbdb88a8754f975454c.bundle.wx"; mWXSDKInstance.renderByUrl(pageName, bundleUrl, null, null,WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 6. 运行app运行app，您将会看到一个 hello world 页面。 Hello World Demo 源码 提示: 点击二维码, 可以看到最终编译的代码产物。 7. 扩展Android能力Weex 提供了能力扩展机制，可以根据自己的业务进行定制自己的功能。 主要分为： Module 扩展， 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展， 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展， Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 创建一个app]]></title>
    <url>%2Fposts%2Ffccf4639.html</url>
    <content type="text"><![CDATA[以下步骤假设您已经了解了 Node.js 和 npm 的基本知识。如果对它们不熟悉，可以访问 https://docs.npmjs.com/ 来了解更多关于 npm 的用法。 Weex 提供了一个命令行工具 weex-toolkit 来帮助开发者使用 Weex。它可以用来快速创建一个空项目、初始化 iOS 和 Android 开发环境、调试、安装插件等操作。 目前 weex-toolkit 只支持创建 Vue.js 的项目。创建 Rax 的项目可以使用 rax-cli，参考 Rax 的官方网站 了解其用法。 初始化请确保你已经安装了 Node.js，然后全局安装 weex-toolkit。 1npm install weex-toolkit -g 这条命令会向你命令行环境中注册一个 weex 命令。你可以用 weex create 命令来创建一个空的模板项目： 1weex create awesome-app 命令执行完以后，在当前目录的 awesome-app 文件夹里就有了一个空的 Weex + Vue.js 项目。 开发下一步就是进入刚刚创建的文件夹，并且安装依赖，然后执行 npm start： 123cd awesome-appnpm installnpm start 然后工具会启动一个本地的 web 服务，监听 8081 端口。你可以打开 http://localhost:8081 查看页面在 Web 下的渲染效果。 源代码在 src/ 目录中，你可以像一个普通的 Vue.js 项目一样来开发. 除此之外，你还可以打开 http://localhost:8081/preview.html 开启一个预览页面，它会把 web 端的页面放在一个 iframe 中渲染，而且在右侧生成一个二维码。用 Weex playground app 扫描这个二维码可以看到页面在手机上渲染的真实效果。 编译和运行默认情况下 weex create 命令并不初始化 iOS 和 Android 项目，你可以通过执行 weex platform add 来添加特定平台的项目。 12weex platform add iosweex platform add android 由于网络环境的不同，安装过程可能需要一些时间，请耐心等待。如果安装失败，请确保自己的网络环境畅通。 为了能在本地机器上打开 Android 和 iOS 项目，你应该配置好客户端的开发环境。对于 iOS，你应该安装并且配置好 Xcode。对于 Android，你应该安装并且配置好 Android Studio。当开发环境准备就绪后，运行下面的命令，可以在模拟器或真实设备上启动应用： 123weex run iosweex run androidweex run web 调试weex-toolkit 还提供了强大的调试功能，只需要执行： 1weex debug 这条命令会启动一个调试服务，并且在 Chrome （目前只支持基于 V8 引擎的桌面浏览器） 中打开调试页面。详细用法请参考 weex-toolkit 的文档。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 设置开发环境]]></title>
    <url>%2Fposts%2F55bbc4a4.html</url>
    <content type="text"><![CDATA[使用 Weex Online Editor 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex，下面教你如何搭建本地开发环境进行 Weex 开发。 安装依赖Weex 官方提供了weex-toolkit 的脚手架工具来辅助开发和调试。 首先，你需要 Node.js 和 Weex CLi。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 更多安装方式可参考 Node.js 官方信息 ::: Tip 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit, 你也可以通过 yarn 来进行安装。 国内的开发者推荐将npm镜像切换至 Taobao NPM 镜像。 ::: 运行下面的命令安装最新的beta版本工具： 12$ npm install -g weex-toolkit@beta$ weex -v // 查看当前weex工具版本 安装结束后你可以直接使用 weex help 命令验证是否安装成功，它会显示 weex 支持的所有指令，同时，你也可以通过 weex doctor 命令检查你的本地开发环境。 初始化项目然后初始化 Weex 项目： 1$ weex create awesome-project 执行完命令后，在 awesome-project 目录中已经为我们生成了标准项目结构。 开发进入项目所在路径，如果你在生成项目的时候选择了自动安装依赖，在进入项目后只需直接运行 npm start 就可以将项目完整跑起来，否则，你需要预先在项目中运行一下 npm install 安装项目所需依赖。 关于 Weex 语法部分，你可以直接参考 Vue Guide]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 Weex ？]]></title>
    <url>%2Fposts%2F96214312.html</url>
    <content type="text"><![CDATA[Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架。“Weex” 的发音是 /wiːks/, 和 “Weeks“ 同音。 Write Once, Run EverywhereWeex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成了 WeexSDK 之后，你可以使用 JavaScript 语言和前端开发经验来开发移动应用。 Weex 渲染引擎与 DSL 语法层是分开的，Weex 并不强依赖任何特定的前端框架。目前 Vue.js 和 Rax 这两个前端框架被广泛应用于 Weex 页面开发，同时 Weex 也对这两个前端框架提供了最完善的支持。Weex 的另一个主要目标是跟进流行的 Web 开发技术并将其和原生开发的技术结合，实现开发效率和运行性能的高度统一。在开发阶段，一个 Weex 页面就像开发普通网页一样；在运行时，Weex 页面又充分利用了各种操作系统的原生组件和能力。 概述想初步了解 Weex 其实非常简单。 安装 WeexPlayground. 在 Playground 里，你可以打开各种示例。 访问 Weex online playground. 在这个网站上，你可以浏览、修改、新建各种基于 Vue.js 的单页面例子，并用 WeexPlayground 应用扫码查看实时效果。 这里有一个使用 Weex 和 Vue.js 开发的最简单的例子。你可以大致了解 Weex 是如何工作的。 在 &lt;template&gt; 部分，包含了 &lt;div&gt; 元素，这个被广泛应用于 Web 页面中，在 Weex 里它也是一个通用的容器。&lt;text&gt;元素就和普通的 HTML 不太一样了，它提供了显示文本的能力，在 Weex 上，所有文本必须放在 &lt;text&gt; 标签中。 在 &lt;style&gt; 部分，你可以定义各种 CSS 样式。需要注意的是，这些样式在 Weex 里只能作用于当前组件，scoped。 原生组件在上面的例子中，&lt;div&gt; 和 &lt;text&gt; 在移动端上渲染出来的都是原生组件，充分利用了操作系统组件的能力与渲染速度。 Weex 提供了一套基础的内置组件。你可以对这些基础组件进行封装、组合形成自己的组件；也可以创建自己的全新组件来包装操作系统提供的地图、视频等功能。可以访问 扩展 iOS 能力 和 扩展 Android 能力来了解如何去实现自定义组件。 在框架内部，Weex 使用原生组件来渲染，并尽可能保持多平台一致性。但在不同平台上，或多或少会有一些渲染、行为上的差异。比如对于 `` 组件，在不同平台上的视觉效果是不一致的。 原生模块对于那些不依赖于 UI 组件的功能，Weex 将它们包装成多个 模块，比如 动画模块。在前端代码中，使用 weex.requireModule(&#39;xxx&#39;) 引入一个模块，之后就可以调用它提供的各种方法。Weex 模块包装了网络、存储、剪切板、导航等各种功能供前端调用。比如你可以使用 stream 模块来获取 Vue.js 的 Star 数量。 Weex 已经提供了不少内置模块，同时也支持将 App 特有的功能包装成自定义模块提供给前端调用。如果想了解怎么做，可以浏览以下文档。 扩展 Web 组件 扩展 Android 能力 扩展 iOS 能力 一次编写，处处运行Weex 的目标就是使用开发者基于一份代码，编写出可以运行在 iOS，Android 和 Web 上的应用，并最大化地提高开发效率和简化测试、构建、发布流程。 有一些场景，你可能仍然需要写一些平台相关的代码。Weex 提供 WXEnvironment 用来获取 Weex 运行的环境变量，浏览 Weex 环境变量，了解更多。 使用前端框架Weex 应用需要依赖前端框架来编写，但 Weex 并没有绑定、限制在特定的框架上。目前 Vue.js 和 Rax 是最广泛应用于 Weex 开发的前端框架，也是目前功能最全、最稳定的方案。 Vue.js 是一个不断进化中的前端框架。 Rax 是提供类 React 语法和兼容性的前端框架。 Vue.js 和 Rax 都已经集成到 Weex 中，并默认提供。 将自己喜欢的前端框架和 Weex 进行结合是可以的，但并不是那么容易。我们也在不断开发和简化这种接入工作，如果想了解如何做，或有任何想法可以和我们联系。你也可以先阅读一下 使用前端框架 这篇文档了解它是做什么的。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通讯录获取/添加信息 AddressBook]]></title>
    <url>%2Fposts%2Fe1546149.html</url>
    <content type="text"><![CDATA[源码：AddressBook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.example.zm.addressbook;import android.content.ContentResolver;import android.content.ContentUris;import android.content.Context;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.provider.ContactsContract;import android.text.TextUtils;import android.util.Log;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.InputStream;import java.util.ArrayList;import java.util.List;public class ContactUtil &#123; /** * 获取联系人信息，并把数据转换成json数据 * * @return * @throws JSONException */ public static String getContactInfo(Context context) throws JSONException &#123; JSONObject contactData = null; JSONObject jsonObject = null; JSONArray jsonArray = null; JSONObject jsonObject2 = null; JSONArray jsonArray2 = null; contactData = new JSONObject(); jsonArray = new JSONArray(); String mimetype = ""; int oldrid = -1; int contactId = -1; // 1.查询通讯录所有联系人信息，通过id排序，我们看下android联系人的表就知道，所有的联系人的数据是由RAW_CONTACT_ID来索引开的 // 所以，先获取所有的人的RAW_CONTACT_ID Cursor cursor = context.getContentResolver().query(ContactsContract.Data.CONTENT_URI, null, null, null, ContactsContract.Data.RAW_CONTACT_ID); contactData.put("userId", "11111"); while (cursor.moveToNext()) &#123; contactId = cursor.getInt(cursor.getColumnIndex(ContactsContract.Data.RAW_CONTACT_ID)); if (oldrid != contactId) &#123; jsonObject = new JSONObject(); jsonArray2 = new JSONArray(); jsonArray.put(jsonObject); oldrid = contactId; &#125; mimetype = cursor.getString(cursor.getColumnIndex(ContactsContract.Data.MIMETYPE)); // 取得mimetype类型,扩展的数据都在这个类型里面 Bitmap headPhoto = getHighPhoto(contactId + "", context.getContentResolver()); if (null == headPhoto) &#123; jsonObject.put("headImageUrl", ""); &#125; else &#123; jsonObject.put("headImageUrl", headPhoto); &#125; // 名字 if (ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME)); String firstName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.FAMILY_NAME)); String lastname = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.GIVEN_NAME)); String trueName = firstName + lastname; if (TextUtils.isEmpty(trueName)) &#123; jsonObject.put("trueName", ""); &#125; else &#123; jsonObject.put("trueName", trueName); &#125; &#125; // 昵称 if (ContactsContract.CommonDataKinds.Nickname.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Nickname.DISPLAY_NAME)); String nickName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Nickname.NAME)); if (TextUtils.isEmpty(nickName)) &#123; jsonObject.put("nickName", ""); &#125; else &#123; jsonObject.put("nickName", nickName); &#125; &#125; List&lt;AddressBookMoudle.ContactBook&gt; contactList = new ArrayList&lt;AddressBookMoudle.ContactBook&gt;(); // 1.2 获取各种电话信息 if (ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; int phoneType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE)); // 手机 // 个人电话 if (phoneType == ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE) &#123; String mobile = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); AddressBookMoudle.ContactBook contactBook = new AddressBookMoudle.ContactBook(); contactBook.setContact(mobile); contactBook.setContactType("0"); contactList.add(contactBook); &#125; &#125; // Email if (ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; String mobileEmail = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Email.DATA)); AddressBookMoudle.ContactBook contactBook = new AddressBookMoudle.ContactBook(); contactBook.setContact(mobileEmail); contactBook.setContactType("1"); contactList.add(contactBook); &#125; if (contactList.size() &gt; 0) &#123; for (int i = 0; i &lt; contactList.size(); i++) &#123; jsonObject2 = new JSONObject(); jsonObject2.put("contact", contactList.get(i).getContact()); jsonObject2.put("contactType", contactList.get(i).getContactType()); jsonArray2.put(jsonObject2); &#125; jsonObject.put("contactList", jsonArray2); &#125; // 查找event地址 if (ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; // 取出时间类型 int eventType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Event.TYPE)); // 生日 if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY) &#123; String birthday = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Event.START_DATE)); if (TextUtils.isEmpty(birthday)) &#123; jsonObject.put("birthDay", ""); &#125; else &#123; jsonObject.put("birthDay", birthday); &#125; &#125; &#125; // 获取组织信息 if (ContactsContract.CommonDataKinds.Organization.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; // 取出组织类型 int orgType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.TYPE)); // 单位 if (orgType == ContactsContract.CommonDataKinds.Organization.TYPE_CUSTOM) &#123; // if (orgType == // Organization.TYPE_WORK) // &#123; String company = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.COMPANY)); if (TextUtils.isEmpty(company)) &#123; jsonObject.put("company", ""); &#125; else &#123; jsonObject.put("company", company); &#125; String jobTitle = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.TITLE)); if (TextUtils.isEmpty(jobTitle)) &#123; jsonObject.put("jobtitle", ""); &#125; else &#123; jsonObject.put("jobtitle", jobTitle); &#125; String department = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.DEPARTMENT)); if (TextUtils.isEmpty(department)) &#123; jsonObject.put("department", ""); &#125; else &#123; jsonObject.put("department", department); &#125; &#125; &#125; &#125; cursor.close(); contactData.put("addressBookList", jsonArray); Log.i("contactData", contactData.toString()); return contactData.toString(); &#125; /** * 获取联系人高清头像 * * @param people_id 联系人ID * @param cr 调用容器 * @return 联系人的高清头像 */ public static Bitmap getHighPhoto(String people_id, ContentResolver cr) &#123; Uri uri = ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, Long.parseLong(people_id)); InputStream input = ContactsContract.Contacts.openContactPhotoInputStream(cr, uri, true); if (input == null) &#123; return null; &#125; return BitmapFactory.decodeStream(input); &#125;&#125; 123456789101112131415161718&#123; "userId": "11111", "addressBookList": [&#123; "headImageUrl": "", "trueName": "张三", "company": "北京xxx有限公司", "jobtitle": "研发工程师", "department": "", "contactList": [&#123; "contact": "185 0000 1234", "contactType": "0" &#125;, &#123; "contact": "zhangsan@163.com", "contactType": "1" &#125;], "birthDay": "2018-03-25" &#125;]&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_VSCode快捷键]]></title>
    <url>%2Fposts%2F550c573.html</url>
    <content type="text"><![CDATA[官方快捷键 全局 快捷键 描述 Command + Shift + P / F1 显示命令面板 Command + P 快速打开 Command + Shift + N 打开新窗口 Command + W 关闭窗口 基本 快捷键 描述 Command + X 剪切（未选中文本的情况下，剪切光标所在行） Command + C 复制（未选中文本的情况下，复制光标所在行） Option + Shift + F 格式化 Option + Up 向上移动行 Option + Down 向下移动行 Option + Shift + Up 向上复制行 Option + Shift + Down 向下复制行 Command + Shift + K 删除行 Command + Enter 下一行插入 Command + Shift + Enter 上一行插入 Command + Shift + \ 跳转到匹配的括号 Command + [ 减少缩进 Command + ] 增加缩进 Home 跳转至行首 End 跳转到行尾 Command + Up 跳转至文件开头 Command + Down 跳转至文件结尾 Ctrl + PgUp 按行向上滚动 Ctrl + PgDown 按行向下滚动 Command + PgUp 按屏向上滚动 Command + PgDown 按屏向下滚动 Command + Shift + [ 折叠代码块 Command + Shift + ] 展开代码块 Command + K Command + [ 折叠全部子代码块 Command + K Command + ] 展开全部子代码块 Command + K Command + 0 折叠全部代码块 Command + K Command + J 展开全部代码块 Command + K Command + C 添加行注释 Command + K Command + U 移除行注释 Command + / 添加、移除行注释 Option + Shift + A 添加、移除块注释 Option + Z 自动换行、取消自动换行 查找替换 快捷键 描述 Command + F 查找 Command + Option + F 替换 Command + G 查找下一个 Command + Shift + G 查找上一个 Option + Enter 选中所有匹配项 Command + D 向下选中相同内容 Command + K Command + D 移除前一个向下选中相同内容 多光标与选择 快捷键 描述 Option + 点击 插入多个光标 Command + Option + Up 向上插入光标 Command + Option + Down 向下插入光标 Command + U 撤销上一个光标操作 Option + Shift + I 在所选行的行尾插入光标 Command + I 选中当前行 Command + Shift + L 选中所有与当前选中内容相同部分 Command + F2 选中所有与当前选中单词相同的单词 Command + Ctrl + Shift + Left 折叠选中 Command + Ctrl + Shift + Right 展开选中 Alt + Shift + 拖动鼠标 选中代码块 Command + Shift + Option + Up 列选择 向上 Command + Shift + Option + Down 列选择 向下 Command + Shift + Option + Left 列选择 向左 Command + Shift + Option + Right 列选择 向右 Command + Shift + Option + PgUp 列选择 向上翻页 Command + Shift + Option + PgDown 列选择 向下翻页 进阶 快捷键 描述 Ctrl + Space 打开建议 Command + Shift + Space 参数提示 Tab Emmet 插件缩写补全 Option + Shift + F 格式化 Command + K Command + F 格式化选中内容 F12 跳转到声明位置 Option + F12 查看具体声明内容 Command + K F12 分屏查看具体声明内容 Command + . 快速修复 Shift + F12 显示引用 F2 重命名符号 Command + Shift + . 替换为上一个值 Command + Shift + , 替换为下一个值 Command + K Command + X 删除行尾多余空格 Command + K M 更改文件语言 导航 快捷键 描述 Command + T 显示所有符号 Ctrl + G 跳转至某行 Command + P 跳转到某个文件 Command + Shift + O 跳转到某个符号 Command + Shift + M 打开问题面板 F8 下一个错误或警告位置 Shift + F8 上一个错误或警告位置 Ctrl + Shift + Tab 编辑器历史记录 Ctrl + - 后退 Ctrl + Shift + - 前进 Ctrl + Shift + M Tab 切换焦点 编辑器管理 快捷键 描述 Command + W 关闭编辑器 Command + K F 关闭文件夹 Command + \ 编辑器分屏 Command + 1 切换到第一分组 Command + 2 切换到第二分组 Command + 3 切换到第三分组 Command + K Command + Left 切换到上一分组 Command + K Command + Right 切换到下一分组 Command + K Command + Shift + Left 左移编辑器 Command + K Command + Shift + Right 右移编辑器 Command + K Left 激活左侧编辑组 Command + K Right 激活右侧编辑组 文件管理 快捷键 描述 Command + N 新建文件 Command + O 打开文件 Command + S 保存文件 Command + Shift + S 另存为 Command + Option + S 全部保存 Command + W 关闭 Command + K Command + W 全部关闭 Command + Shift + T 重新打开被关闭的编辑器 Command + K Enter 保持打开 Ctrl + Tab 打开下一个 Ctrl + Shift + Tab 打开上一个 Command + K P 复制当前文件路径 Command + K R 在资源管理器中查看当前文件 Command + K O 新窗口打开当前文件 显示 快捷键 描述 Command + Ctrl + F 全屏、退出全屏 Command + Option + 1 切换编辑器分屏方式（横、竖） Command + + 放大 Command + - 缩小 Command + B 显示、隐藏侧边栏 Command + Shift + E 显示资源管理器 或 切换焦点 Command + Shift + F 显示搜索框 Ctrl + Shift + G 显示Git面板 Command + Shift + D 显示调试面板 Command + Shift + X 显示插件面板 Command + Shift + H 全局搜索替换 Command + Shift + J 显示、隐藏高级搜索 Command + Shift + C 打开新终端 Command + Shift + U 显示输出面板 Command + Shift + V Markdown预览窗口 Command + K V 分屏显示 Markdown预览窗口 调试 快捷键 描述 F9 设置 或 取消断点 F5 开始 或 继续 F11 进入 Shift + F11 跳出 F10 跳过 Command + K Command + I 显示悬停信息 集成终端 快捷键 描述 Ctrl + ` 显示终端 Ctrl + Shift + ` 新建终端 Command + Up 向上滚动 Command + Down 向下滚动 PgUp 向上翻页 PgDown 向下翻页 Command + Home 滚动到顶部 Command + End 滚动到底部]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ANR问题总结]]></title>
    <url>%2Fposts%2Fe812f6c7.html</url>
    <content type="text"><![CDATA[在实际情况中，当Android项目的用户量特别大时候，一些细小的问题也会被放大，ANR问题就是一个典型的例子。 一些ANR问题只会发生在用户实际使用的情景，当系统资源比较紧张等一些特殊情况下才会遇到，而这些ANR问题有很大一部分是因为我们的代码不合理导致，这就需要我们定位问题，修复问题，并且在以后的代码设计中尽量避免这些不合理。 最近工作中集中分析了项目的大量的用户自动上报的ANR问题日志，虽然网上ANR相关的文章已经很多了，在这里还是做一个总结。 提纲一. 什么情况下会出现ANR 二. ANR机制的原理 三. 如何分析ANR问题 四. 如何避免ANR问题 一.什么情况下会出现ANR问题：ANR(Application Not responding)。Android中，主线程(UI线程)如果在规定时内没有处理完相应工作，就会出现ANR。 具体来说，ANR会在以下几种情况中出现： 输入事件(按键和触摸事件)5s内没被处理: Input event dispatching timed out BroadcastReceiver的事件(onRecieve方法)在规定时间内没处理完(前台广播为10s，后台广播为60s)：Timeout of broadcast BroadcastRecord 07-27 19:18:47.448 1707 1766 W BroadcastQueue: Receiver during timeout: ResolveInfo{ccd831e com.example.qintong.myapplication/.MyBroadCastReciever m=0x108000} 07-27 19:18:47.502 3513 3728 I WtEventController: ANR com.example.qintong.myapplication 7573 service 前台20s后台200s未完成启动 Timeout executing service ContentProvider的publish在10s内没进行完：timeout publishing content providers 在android文档(https://developer.android.com/training/articles/perf-anr.html)中，只写了第一种和第二种情况，而根据源码和实际的实验，我们能发现service的启动和provider的publish同样会造成anr问题。 这里需要注意的是，在后三种情况，以BroadcastReviever为例，在onRecieve()方法执行10秒内没发生第一种ANR(也就是在这个过程中没有输入事件或输入事件还没到5s)才会发生Receiver timeout，否则将先发生事件无相应ANR，所以onRecieve()是有可能执行不到10s就发生ANR的，所以不要在onRecieve()方法里面干活，service的onCreate()和ContentProvider的onCreate()也一样，他们都是主线程的，不要在这些方法里干活，这个会在本文最后再细说。 二.ANR机制的实现原理：文章：http://gityuan.com/2016/07/02/android-anr/从源码角度详细的分析了ANR机制实现的原理。对于上一章讲到的1-4中情况，分别找到了其源码中是如何实现的，对于每一种大概原理如下：1.在进行相关操作调用hander.sendMessageAtTime()发送一个ANR的消息，延时时间为ANR发生的时间(如前台Service是当前时间20s之后)。2.进行相关的操作3.操作结束后向remove掉该条message。如果相关的操作在规定时间没有执行完成，该条message将被handler取出并执行，就发生了ANR。 下面以BroadcastReceiver为例详细介绍： BroadcastQueue.processNextBroadcast() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 final void processNextBroadcast(boolean fromMsg) &#123; ... synchronized (mService) &#123; ... do &#123; if (mOrderedBroadcasts.size() == 0) &#123; ... if (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123; long now = SystemClock.uptimeMillis(); if ((numReceivers &gt; 0) &amp;&amp; (now &gt; r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) &#123; //1.发送延时消息 broadcastTimeoutLocked(false); // forcibly finish this broadcast forceReceive = true; r.state = BroadcastRecord.IDLE; &#125; &#125; if (r.state != BroadcastRecord.IDLE) &#123; if (DEBUG_BROADCAST) Slog.d(TAG, "processNextBroadcast(" + mQueueName + ") called when not idle (state=" + r.state + ")"); return; &#125; if (r.receivers == null || r.nextReceiver &gt;= numReceivers || r.resultAbort || forceReceive) &#123; // No more receivers for this broadcast! Send the final // result if requested... if (r.resultTo != null) &#123; try &#123; //2. 处理广播消息 performReceiveLocked(r.callerApp, r.resultTo, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, false, false, r.userId); // Set this to null so that the reference // (local and remote) isn't kept in the mBroadcastHistory. r.resultTo = null; &#125; catch (RemoteException e) &#123; ... &#125; &#125; //3.取消延时消息 cancelBroadcastTimeoutLocked(); ... &#125; &#125; while (r == null) ; ... &#125; &#125;&#125; 1.发送延时消息：broadcastTimeoutLocked(false)： 123456789101112131415161718192021final void broadcastTimeoutLocked(boolean fromMsg) &#123;... long now = SystemClock.uptimeMillis(); if (fromMsg) &#123; if (mService.mDidDexOpt) &#123; // Delay timeouts until dexopt finishes. mService.mDidDexOpt = false; long timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod; setBroadcastTimeoutLocked(timeoutTime); return; &#125; if (!mService.mProcessesReady) &#123; return; &#125; long timeoutTime = r.receiverTime + mTimeoutPeriod; if (timeoutTime &gt; now) &#123; setBroadcastTimeoutLocked(timeoutTime); return; &#125; &#125; 他调用了setBroadcastTimeoutLocked(long timeoutTime): 1234567final void setBroadcastTimeoutLocked(long timeoutTime) &#123; if (! mPendingBroadcastTimeoutMessage) &#123; Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this); mHandler.sendMessageAtTime(msg, timeoutTime); mPendingBroadcastTimeoutMessage = true; &#125;&#125; 传入setBroadcastTimeoutLocked(long timeoutTime)的时间xxx + mTimeoutPeriod，mTimeoutPeriod就是onRecieve()可以执行的时间，在BroadcastQueue初始化时候被赋值，前台队列为10s后台队列为60s： ActivityManagerService.java: 1234567891011public ActivityManagerService(Context systemContext) &#123; ... static final int BROADCAST_FG_TIMEOUT = 10 * 1000; static final int BROADCAST_BG_TIMEOUT = 60 * 1000; ... mFgBroadcastQueue = new BroadcastQueue(this, mHandler, "foreground", BROADCAST_FG_TIMEOUT, false); mBgBroadcastQueue = new BroadcastQueue(this, mHandler, "background", BROADCAST_BG_TIMEOUT, true); ...&#125; performReceiveLocked()为广播的实际处理，就不展开了 cancelBroadcastTimeoutLocked() ： 该方法的主要工作是当service启动完成，则移除服务超时消息SERVICE_TIMEOUT_MSG。 123456final void cancelBroadcastTimeoutLocked() &#123; if (mPendingBroadcastTimeoutMessage) &#123; mHandler.removeMessages(BROADCAST_TIMEOUT_MSG, this); mPendingBroadcastTimeoutMessage = false; &#125;&#125; 三.如何分析ANR问题：从前文可以明确，ANR问题是由于主线程的任务在规定时间内没处理完任务，而造成这种情况的原因大致会有一下几点： 主线程在做一些耗时的工作 主线程被其他线程锁 cpu被其他进程占用，该进程没被分配到足够的cpu资源。 判断一个ANR属于哪种情况便是分析ANR问题的关键。那么拿到一个anr的日志，应该如何分析呢？ 在发生ANR的时候，系统会收集ANR相关的信息提供给开发者：首先在Log中有ANR相关的信息，其次会收集ANR时的CPU使用情况，还会收集trace信息，也就是当时各个线程的执行情况。trace文件保存到了/data/anr/traces.txt中，此外，ANR前后该进程打印出的log也有一定价值。一般来说可以按一下思路来分析： 从log中找到ANR反生的信息：可以从log中搜索“ANR in”或“am_anr”，会找到ANR发生的log，该行会包含了ANR的时间、进程、是何种ANR等信息，如果是BroadcastReceiver的ANR可以怀疑BroadCastReceiver.onRecieve()的问题，如果的Service或Provider就怀疑是否其onCreate()的问题。 在该条log之后会有CPU usage的信息，表明了CPU在ANR前后的用量（log会表明截取ANR的时间），从各种CPU Usage信息中大概可以分析如下几点： (1). 如果某些进程的CPU占用百分比较高，几乎占用了所有CPU资源，而发生ANR的进程CPU占用为0%或非常低，则认为CPU资源被占用，进程没有被分配足够的资源，从而发生了ANR。这种情况多数可以认为是系统状态的问题，并不是由本应用造成的。 (2). 如果发生ANR的进程CPU占用较高，如到了80%或90%以上，则可以怀疑应用内一些代码不合理消耗掉了CPU资源，如出现了死循环或者后台有许多线程执行任务等等原因，这就要结合trace和ANR前后的log进一步分析了。 (3). 如果CPU总用量不高，该进程和其他进程的占用过高，这有一定概率是由于某些主线程的操作就是耗时过长，或者是由于主进程被锁造成的。 除了上述的情况(1)以外，分析CPU usage之后，确定问题需要我们进一步分析trace文件。trace文件记录了发生ANR前后该进程的各个线程的stack。对我们分析ANR问题最有价值的就是其中主线程的stack，一般主线程的trace可能有如下几种情况： (1). 主线程是running或者native而对应的栈对应了我们应用中的函数，则很有可能就是执行该函数时候发生了超时。 (2). 主线程被block:非常明显的线程被锁，这时候可以看是被哪个线程锁了，可以考虑优化代码。如果是死锁问题，就更需要及时解决了。 (3). 由于抓trace的时刻很有可能耗时操作已经执行完了（ANR -&gt; 耗时操作执行完毕 -&gt;系统抓trace），这时候的trace就没有什么用了，主线程的stack就是这样的： 123456789101112131415161718192021"main" prio=5 tid=1 Native | group="main" sCount=1 dsCount=0 obj=0x757855c8 self=0xb4d76500 | sysTid=3276 nice=0 cgrp=default sched=0/0 handle=0xb6ff5b34 | state=S schedstat=( 50540218363 186568972172 209049 ) utm=3290 stm=1764 core=3 HZ=100 | stack=0xbe307000-0xbe309000 stackSize=8MB | held mutexes= kernel: (couldn't read /proc/self/task/3276/stack) native: #00 pc 0004099c /system/lib/libc.so (__epoll_pwait+20) native: #01 pc 00019f63 /system/lib/libc.so (epoll_pwait+26) native: #02 pc 00019f71 /system/lib/libc.so (epoll_wait+6) native: #03 pc 00012ce7 /system/lib/libutils.so (_ZN7android6Looper9pollInnerEi+102) native: #04 pc 00012f63 /system/lib/libutils.so (_ZN7android6Looper8pollOnceEiPiS1_PPv+130) native: #05 pc 00086abd /system/lib/libandroid_runtime.so (_ZN7android18NativeMessageQueue8pollOnceEP7_JNIEnvP8_jobjecti+22) native: #06 pc 0000055d /data/dalvik-cache/arm/system@framework@boot.oat (Java_android_os_MessageQueue_nativePollOnce__JI+96) at android.os.MessageQueue.nativePollOnce(Native method) at android.os.MessageQueue.next(MessageQueue.java:323) at android.os.Looper.loop(Looper.java:138) at android.app.ActivityThread.main(ActivityThread.java:5528) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:740) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:630) 当然这种情况很有可能是由于该进程的其他线程消耗掉了CPU资源，这就需要分析其他线程的trace以及ANR前后该进程自己输出的log了。 四.如何降低ANR的概率：有一些操作是很危险的，非常容易发生ANR，在写代码时候一定要避免： 主线程读取数据：在Android中主线程去读取数据是非常不好的，Android是不允许主线程从网络读数据的，但系统允许主线程从数据库或者其他地方获取数据，但这种操作ANR风险很大，也会造成掉帧等，影响用户体验。 （1）. 避免在主线程query provider，首先这会比较耗时，另外这个操作provider那一方的进程如果挂掉了或者正在启动，我们应用的query就会很长时间不会返回，我们应该在其他线程中执行数据库query、provider的query等获取数据的操作。 （2）. sharePreference的调用：针对sharePreference的优化点有很多，文章http://weishu.me/2016/10/13/sharedpreference-advices/ 详细介绍了几点sharepreference使用时候的注意事项。首先sharePreference的commit()方法是同步的，apply()方法一般是异步执行的。所以在主线程不要用其commit()，用apply()替换。其次sharePreference的写是全量写而非增量写，所以尽量都修改完同一apply，避免改一点apply一次(apply()方法在Activity stop的时候主线程会等待写入完成，提交多次就很容易卡)。并且存储文本也不宜过大，这样会很慢。另外，如果写入的是json或者xml，由于需要加和删转义符号，速度会比较慢。 不要在broadcastReciever的onRecieve()方法中干活，这一点很容易被忽略，尤其应用在后台的时候。为避免这种情况，一种解决方案是直接开的异步线程执行，但此时应用可能在后台，系统优先级较低，进程很容易被系统杀死，所以可以选择开个IntentService去执行相应操作，即使是后台Service也会提高进程优先级，降低被杀可能性。 各个组件的生命周期函数都不应该有太耗时的操作，即使对于后台Service或者ContentProvider来讲，应用在后台运行时候其onCreate()时候不会有用户输入引起事件无响应ANR，但其执行时间过长也会引起Service的ANR和ContentProvider的ANR。 尽量避免主线程的被锁的情况，在一些同步的操作主线程有可能被锁，需要等待其他线程释放相应锁才能继续执行，这样会有一定的ANR风险，对于这种情况有时也可以用异步线程来执行相应的逻辑。另外， 我们要避免死锁的发生(主线程被死锁基本就等于要发生ANR了)。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_SDK版本号与APILevel的对应关系]]></title>
    <url>%2Fposts%2F46f6283e.html</url>
    <content type="text"><![CDATA[一、Android各版本对应的SDK版本 平台版本 API VERSION_CODE 备注 Android 9.0 28 Android P Preview（9.0） 平台亮点 Android 8.1 27 Oreo（8.1） 平台亮点 Android 8.0 26 Oreo（8.0） 平台亮点 Android 7.1 25 Nougat（牛轧糖） 平台亮点 Android 7.0 24 N（牛轧糖） 平台亮点 Android 6.0 23 M（棉花糖） 平台亮点 Android 5.1 22 LOLLIPOP_MR1（棒棒糖） 平台亮点 Android 5.0 21 LOLLIPOP （棒棒糖） Android 4.4W 20 KITKAT_WATCH（奇巧巧克力） 仅限 KitKat for Wearables Android 4.4 19 KITKAT （奇巧巧克力） 平台亮点 Android 4.3 18 JELLY_BEAN_MR2（果冻豆） 平台亮点 Android 4.2、4.2.2 17 JELLY_BEAN_MR1（果冻豆） 平台亮点 Android 4.1、4.1.1 16 JELLY_BEAN （果冻豆） 平台亮点 Android 4.0.3、4.0.4 15 ICE_CREAM_SANDWICH_MR1（冰激凌三明治） 平台亮点 Android 4.0、4.0.1、4.0.2 14 ICE_CREAM_SANDWICH（冰激凌三明治） Android 3.2 13 HONEYCOMB_MR2 （蜂巢） Android 3.1.x 12 HONEYCOMB_MR1（蜂巢） 平台亮点 Android 3.0.x 11 HONEYCOMB （蜂巢） 平台亮点 Android 2.3.4 Android 2.3.3 10 GINGERBREAD_MR1（姜饼） 平台亮点 Android 2.3.2 Android 2.3.1 Android 2.3 9 GINGERBREAD（姜饼） Android 2.2.x 8 FROYO（冻酸奶） 平台亮点 Android 2.1.x 7 ECLAIR_MR1 （埃克拉） 平台亮点 Android 2.0.1 6 ECLAIR_0_1（埃克拉） Android 2.0 5 ECLAIR（埃克拉） Android 1.6 4 DONUT（甜甜圈） 平台亮点 Android 1.5 3 CUPCAKE（纸杯蛋糕） 平台亮点 Android 1.1 2 BASE_1_1 Android 1.0 1 BASE 二、Android各版本的市场占有率和对应JDK版本 Version Codename API Distribution 2.3.3 - 2.3.7 Gingerbread 10 0.3% 4.0.3 - 4.0.4 Ice Cream Sandwich 15 0.4% 4.1.x Jelly Bean 16 1.5% 4.2.x Jelly Bean 17 2.2% 4.3 Jelly Bean 18 0.6% 4.4 KitKat 19 10.3% 5.0 Lollipop 21 4.8% 5.1 Lollipop 22 17.6% 6.0 Marshmallow 23 25.5% 7.0 Nougat 24 22.9% 7.1 Nougat 25 8.2% 8.0 Oreo 26 4.9% 8.1 Oreo 27 0.8% 以 7 天为周期收集的数据（截止于 2018 年 1 月 8 日）。 未显示任何分布份额不足 0.1% 的版本。 三、屏幕尺寸和密度 ldpi mdpi tvdpi hdpi xhdpi xxhdpi Total Small 0.4% 0.1% 0.5% Normal 0.9% 0.3% 27.3% 39.3% 23.3% 91.1% Large 2.4% 1.5% 0.4% 0.7% 0.5% 5.5% Xlarge 1.8% 0.6% 0.5% 2.9% Total 0.4% 5.1% 1.8% 28.3% 40.5% 23.9% 以 7 天为周期收集的数据（截止于 2018 年 1 月 8 日）。 未显示任何分布份额不足 0.1% 的屏幕配置。 数据来源：Android信息中心]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>SDK</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fposts%2F423abe9e.html</url>
    <content type="text"><![CDATA[常用git命令切换到git路径 1$ cd &lt;folder&gt; git命令 描述 git branch 查看本地分支 git branch -r 查看远程分支 git branch zm-develop 建立本地分支 git push origin zm-develop:zm-develop 将本地新的分支推送到git远程分支 git fetch origin zm-develop:zm-develop 拉取远程分支并创建本地分支 git fetch origin zm-develop:zm-develop 拉取远程分支并创建本地分支 git checkout zm-develop 切换到本地分支 git remote -v 查看当前在哪一个远程仓库 git branch -d zm-develop 删除分支zm-develop git config –list 查看配置信息 git status 查看项目状态信息 git log 查看提交日志 git reset –hard commit_id 完成撤销,同时将代码恢复到前一commit_id 对应的版本 git reset commit_id 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本号比较versionCompare]]></title>
    <url>%2Fposts%2Fd2f8db9f.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 版本号比较versionCompare方法，java实现 * if v1 &gt; v2 , return 1; * if v1 &lt; v2 , return 2; * if equal , return 0; * input error ,return -1; */public class Test &#123; public static void main(String[] versions) &#123; int result1 = versionCompare("0.1.5", "0.1.5"); System.out.print("resultCode1:" + result1); int result2 = versionCompare("0.2.5", "0.1.5"); System.out.print("resultCode1:" + result2); int result3 = versionCompare("0.1.4", "0.1.5"); System.out.print("resultCode1:" + result3); int result4 = versionCompare("0.1.5c测试", "0.1.5"); System.out.print("resultCode1:" + result4); &#125; public static int versionCompare(String v1, String v2) &#123; Pattern pattern = Pattern.compile("\\d+(\\.\\d+)*"); if (!pattern.matcher(v1).matches() || !pattern.matcher(v2).matches()) &#123; return -1; &#125; String[] str1 = v1.split("\\."); String[] str2 = v2.split("\\."); int length = str1.length &lt; str2.length ? str1.length : str2.length; for (int i = 0; i &lt; length; i++) &#123; int diff = Integer.valueOf(str1[i]) - Integer.valueOf(str2[i]); if (diff == 0) &#123; continue; &#125; else &#123; return diff &gt; 0 ? 1 : 2; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android颜色透明度设置]]></title>
    <url>%2Fposts%2F54d6d461.html</url>
    <content type="text"><![CDATA[颜色简介Android中的颜色值通常遵循RGB/ARGB标准，使用时通常以“#”字符开头，以16进制表示。常用的颜色值格式为： #RGB #ARGB #RRGGBB #AARRGGBB其中，ARGB 依次代表透明度（alpha）、红色(red)、绿色(green)、蓝色(blue)。以颜色值 #FF99CC00 为例，FF 是透明度，99 是红色值， CC 是绿色值， 00 是蓝色值。透明度 透明度分为256阶（0-255），计算机上用16进制表示为（00-ff）。透明就是0阶，不透明就是255阶,如果50%透明就是127阶（256的一半当然是128，但因为是从0开始，所以实际上是127）。 透明度 和 不透明度 是两个概念， 它们加起来是1，或者100%. ARGB 中的透明度alpha，表示的是不透明度。 如何换算 UI给出的颜色是#FFFFFF，透明度为40%。 换算过程： 将透明度转换成不透明度(转换方式参考“透明度”，第2条) 。不透明度为60% 不透明度乘以255。 我们得到结果：153 将计算结果转换成16进制。得到最终的不透明度：99 将不透明度和颜色值拼接成ARGB格式。得到最终的颜色值： #99FFFFFF 干货 说明：半透明颜色值不同于平时使用的颜色，半透明颜色值共8位，前2位是透明度，后6位是颜色。 参数 透明度 16进制表示 不透明 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 半透明 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 全透明 0% 00 举例： 全透明：#00000000 半透明：#80000000 不透明：#FF000000 白色半透明：#80FFFFFF 红色30%透明：#4Dca0d0d]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_iTerm2命令行工具]]></title>
    <url>%2Fposts%2Fc16bcf6c.html</url>
    <content type="text"><![CDATA[下载地址item 实用命令 多窗口切换 command + T 同个窗口横向分屏 command + d 同个窗口，竖向分屏 command + shift + d 搜索 command + f 直接打开文件 按住command键并点击文件名 自动复制 直接双击需要复制的文字，即可自动复制]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
        <tag>iTem2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_OSX快捷键以及命令行]]></title>
    <url>%2Fposts%2F81828d81.html</url>
    <content type="text"><![CDATA[Mac OSX 快捷键 快捷键 描述 ctrl+shift 快速放大dock的图标会暂时放大，而如果你开启了dock放大 Command+Option+W 将所有窗口关闭 Command+W 将当前窗口关闭(可以关闭Safari标签栏,很实用) Command+Option+M 将所有窗口最小化 Command+Q 关闭当前应用程序(相当于Dock鼠标右键推出.很实用) Command+M 将目前使用的窗口最小化 Command+H 隐藏当前窗口或者软件 Command＋tab 为切换当前工作任务 Control＋Command＋S 切换控制条的显示和隐藏 Command＋i 常规信息（显示及设置图标属性） Command＋delete 移到废纸篓（删除） Optionion+鼠标 拖图像或文件夹可以将图像或文件夹拷贝到其它文件夹中，而不是移动 Command+Shift+backspace 清空废纸篓(再加上option一起按能跳过确认对话框) Command+N 键可以建立新文件夹 “return”或“enter”或“O”键可以打开所选项目 Command+Option+esc 键可以强行退出死机程序 Command+Shift+3 截图(当前屏幕) Command+Shift+4 截图(自由选取范围) Option＋F12 关机窗口(能选择关机、重起、睡眠) Command+1 以图标方式显示 Command+2 以分栏方式显示 Command+3 以列表方式显示 Command+4 以Cover Flow方式显示 return或enter 键可以编辑所选图像或文件夹的名称 Mac OSX 命令行目录操作命令名 |功能描述 |使用举例—|:–: |mkdir | 创建一个目录 | mkdir dirnamermdir | 删除一个目录 | rmdir dirnamemvdir | 移动或重命名一个目录 | mvdir dir1 dir2cd | 改变当前目录 | cd dirnamepwd | 显示当前目录的路径名 | pwdls | 显示当前目录的内容 | ls -la 文件操作命令名 |功能描述 |使用举例—|:–: |cat | 显示或连接文件 | cat filenameod | 显示非文本文件的内容 | od -c filenamecp | 复制文件或目录 | cp file1 file2rm | 删除文件或目录 | rm filenamemv | 改变文件名或所在目录 | mv file1 file2find | 使用匹配表达式查找文件 | find . -name “*.c” -printfile | 显示文件类型 | file filename 选择操作命令名 |功能描述 |使用举例—|:–: |head | 显示文件的最初几行 | head -20 filenametail | 显示文件的最后几行 | tail -15 filenamecut | 显示文件每行中的某些域 | cut -f1,7 -d: /etc/passwdcolrm | 从标准输入中删除若干列 | colrm 8 20 file2diff | 比较并显示两个文件的差异 | diff file1 file2sort | 排序或归并文件 | sort -d -f -u file1uniq | 去掉文件中的重复行 | uniq file1 file2comm | 显示两有序文件的公共和非公共行 | comm file1 file2wc | 统计文件的字符数、词数和行数 | wc filenamenl | 给文件加上行号 | nl file1 &gt;file2 进程操作命令名 |功能描述 |使用举例—|:–: |ps | 显示进程当前状态 | ps ukill | 终止进程 | kill -9 30142 时间操作命令名 |功能描述 |使用举例—|:–: |date | 显示系统的当前日期和时间 | datecal | 显示日历 | cal 8 1996time | 统计程序的执行时间 | time a.out 网络与通信操作命令名 |功能描述 |使用举例—|:–: |telnet | 远程登录 | telnet hpc.sp.net.edu.cnrlogin | 远程登录 | rlogin hostname -l usernamersh | 在远程主机执行指定命令 | rsh f01n03 dateftp | 在本地主机与远程主机之间传输文件 | ftpftp.sp.net.edu.cnrcp | 在本地主机与远程主机 之间复制文件 | rcp file1 host1:file2ping | 给一个网络主机发送 回应请求 | ping hpc.sp.net.edu.cnmail | 阅读和发送电子邮件 | mailwrite | 给另一用户发送报文 | write username pts/1mesg | 允许或拒绝接收报文 | mesg n Korn Shell 命令命令名 |功能描述 |使用举例—|:–: |history | 列出最近执行过的 几条命令及编号 | historyr | 重复执行最近执行过的 某条命令 | r -2alias | 给某个命令定义别名 | alias del=rm -iunalias | 取消对某个别名的定义 | unalias del 其它命令命令名 |功能描述 |使用举例—|:–: |uname | 显示操作系统的有关信息 | uname -aclear | 清除屏幕或窗口内容 | clearenv | 显示当前所有设置过的环境变量 | envwho | 列出当前登录的所有用户 | whowhoami | 显示当前正进行操作的用户名 | whoamitty | 显示终端或伪终端的名称 | ttystty | 显示或重置控制键定义 | stty -adu | 查询磁盘使用情况 | du -k subdirdf /tmp | 显示文件系统的总空间和可用空间w | 显示当前系统活动的总信息]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端快捷键]]></title>
    <url>%2Fposts%2Fc7dcd830.html</url>
    <content type="text"><![CDATA[常用的快捷键 快捷键 描述 Ctrl + a 跳到行首 Ctrl + e 跳到行尾 Ctrl + b 光标往回(Backward)移动一个字符位置 Ctrl + c 取消当前行输入的命令 Ctrl + d 删除一个字符，相当于通常的Delete键 Ctrl + f 光标向前(Forward)移动一个字符位置 Ctrl + h 退格删除一个字符，相当于通常的Backspace键 Ctrl + k 删除光标之前到行尾的字符 Ctrl + l 清屏，相当于执行clear命令 Ctrl + u 删除光标之前到行首的字符 Ctrl + p 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 Ctrl + n 调出命令历史中的下一条（Next）命令，相当于通常的上箭头 Ctrl + r 显示：号提示，根据用户输入查找相关历史命令 Ctrl + w 删除从光标位置前到当前所处单词（Word）的开头 Ctrl + y 粘贴最后一次被删除的单词 Alt + d 删除从光标位置到当前所处单词的末尾 Command + K 清屏 Command + T 新建标签 Command +W 关闭当前标签页 Command + S 保存终端输出 Command + D 垂直分水平分隔当前标签页 Command + shift + {或} 向左/向右切换标签]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改NexT_Pisces主题内容区宽度]]></title>
    <url>%2Fposts%2F88baa841.html</url>
    <content type="text"><![CDATA[默认的宽度觉得有点窄，想改宽一点，手动修改样式在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码。 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125;]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建博客]]></title>
    <url>%2Fposts%2Feb656981.html</url>
    <content type="text"><![CDATA[准备工作 Hexo：快速、简洁且高效的博客框架,官网有中文文档 NexT：Hexo适用的主题 LeanCloud：数据库(可不用) GitHub：博客就发布在GitPage 安装&amp;配置 Hexo安装 Hexo全局安装 Hexo 官方的脚手架 1$ npm install -g hexo-cli 然后初始化博客，并安装依赖包 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install &lt;folder&gt; 就是博客的本地文件夹 配置 Hexo网站配置： /_config.yml 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区(默认为电脑时区) avatar(此参数需自己添加) 网站头像地址 ##### 网址 参数 描述 — :–: url 网址 root 网站根目录 permalink 文章的链接格式 &gt; #### 网站存放在子目录 &gt; 如果您的网站存放在子目录中，例如http://yoursite.com/blog，则请将您的 url 设为http://yoursite.com/blog 并把root 设为 /blog/。 ##### 目录 参数 描述 — :–: source_dir 资源文件夹，这个文件夹用来存放内容。 public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 _posts_dir 默认文件夹，这个文件夹用于存放生成的站点文件。 tag_dir 标签文件夹 category_dir 分类文件夹 archive_dir 归档文件夹 about_dir 关于我们文件夹 CNAME 域名文件(zhangmiao.cc) code_dir Include code 文件夹 i18n_dir 国际化（i18n）文件夹 skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 &gt; #### 提示 &gt; 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 #### 分页 参数 描述 — :–: per_page 每页显示的文章量 (0 = 关闭分页功能) pagination_dir 分页目录 ##### 扩展 参数 描述 - :-: theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 &gt; 更多网站参数参考：https://hexo.io/zh-cn/docs/configuration.html 添加站内搜索安装 hexo-generator-searchdb 1$ npm install hexo-generator-searchdb --save 网站配置： /_config.yml 新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 测试 Hexo新建文章运行命令新建一篇文章 1$ hexo new [layout] &lt;title&gt; 启动服务123$ hexo server 或$ hexo s 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 启动服务器。默认情况下，访问网址为：http://localhost:4000/。 ##### 部署网站 123$ hexo deploy 或$ $ hexo d 选项 描述 -g, –generate 部署之前预先生成静态文件 #### 清除 1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 更多命令参考：https://hexo.io/zh-cn/docs/commands.html 安装&amp;配置 NexT 主题安装 NexT 主题使用git克隆最新版本 12$ cd &lt;folder&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 或者直接将 hexo-theme-next 下载下来放到 Hexo 站点目录下的 [themes/next] 目录中 启用 NexT 主题网站配置： /_config.yml搜索theme关键字，并将其值更改为 next 1theme: next 验证 NexT 主题 最好先使用 hexo clean 清除 Hexo 的缓存。 运行 hexo server 启动本地站点。此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行。 主题设定主题配置： /theme/next/_config.yml搜索scheme 关键字，选择使用的主题样式，将你需用启用的 scheme 前面注释 # 去掉并将其他两个 scheme 加上注释即可。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 菜单主题配置： /theme/next/_config.yml 搜索 menu 关键字 设置 头像主题配置： /theme/next/_config.yml 新增字段avatar,值设置成头像的链接地址 设置 作者名称主题配置： /theme/next/_config.yml 搜索 author 关键字 设置 描述主题配置： /theme/next/_config.yml 搜索 description 关键字 设置 首页列表是否显示 阅读更多主题配置： /theme/next/_config.yml 搜索auto_excerpt 关键字 将 enable 设置为true length 设置为期望截取保留的文章长度 集成第三方服务主题配置： /theme/next/_config.yml 参考：http://theme-next.iissnan.com/third-party-services.html 创建GitHub创建好账号之后，先创建一个仓库New repository进入 Settings ，找到下方的 GitHub Pages ，点击Choose a theme选择主题（这个无所谓，最后都会被替换），Source指向的就是GitPage站点所在的分支。 GitHub会给分配一个二级域名，GitHub昵称+github.io 部署网站安装hexo-deployer-git 1$ npm install hexo-deployer-git --save 配置网站配置： /_config.yml 搜索 deploy 关键字 type：git repo：github提交地址 branch：提交分支 部署123$ hexo deploy 或$ hexo d 如果想在部署之前预先生成下静态文件，可以使用： 123$ hexo deploy -g 或$ hexo d --generate $ hexo deploy -g与$ hexo generate -d的效果其实是相同的 本地站点不要放在Git上，否则执行deploy的时候会把本地站点提交上去]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
