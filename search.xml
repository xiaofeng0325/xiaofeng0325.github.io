<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FlutterPlugin开发流程]]></title>
    <url>%2Fposts%2Fb7213cdb.html</url>
    <content type="text"><![CDATA[这篇文章主要介绍了Flutter Plugin开发流程，包括如何利用Android Studio开发以及发布等。 今天这篇文章，给大家介绍如何开发Flutter Plugin中Android的部分。有关Flutter以及Flutter Plugin的概念，感兴趣的可以从官网查看相关资料。 简介笔者的环境是Mac下Android Studio进行的开发，AS也是谷歌官推的，安装flutter插件后，开发起来相对于其他IDE来说，方便很多，自带了三种模板： Flutter Application： Flutter应用 Flutter Plugin：Flutter插件 Flutter Package：纯Dart组件 Plugin其实就是一个特殊的Package。Flutter Plugin提供Android或者iOS的底层封装，在Flutter层提供组件功能，使Flutter可以较方便的调取Native的模块。很多平台相关性或者对于Flutter实现起来比较复杂的部分，都可以封装成Plugin。其原理如下 消息在client和host之间通过平台通道（platform channels）来进行的，之间的通讯都是异步的。 创建组件直接在Android Studio中新建一个Flutter Plugin的工程，当然也可以使用命令行来进行，例如创建一个flutter_text_plugin。 flutter create –org com.example –plugin flutter_text_plugin 如果想支持swift或者kotlin，可以用如下命令进行创建: flutter create –org com.example –plugin -i swift -a kotlin flutter_text_plugin 更多的参数选项，大家可以 查看帮助文档，当然还是比较推荐直接用AS进行创建，简单直观。用AS打开项目，可以看到项目的组织结构 root android example ios lib ... android以及ios文件夹是我们将要编写插件的native层的地方，lib文件夹是编写与native层映射的地方，native与flutter之间不能直接通信，必须通过MethodChannel来间接调用。example文件夹则是例子工程，编写的插件可以直接在这个项目中进行验证。在本文中，我们主要在android目录下进行，也就是android部分。 编写Android部分用AS打开flutter_text_plugin/android项目，这样子开发起来比较方便。但是打开过后，会发现出现了很多错误，提示找不到flutter相关的东西，我们仔细看这个项目，会发现跟我们平时用AS建的Android项目有所不同，少了很多部分，目录也有所不同。这是因为这个android项目不需要能够直接去运行，因此减少了很多东西。但是对于初次接触的人来说，可能是一头懵逼，例如该如何添加第三方库，如何添加proguard rule等等。 引入flutter库android插件工程是没有引入flutter库的，所以才会出现错误提示，我们在项目根目录建立一个libs文件夹，用来存放flutter库。 flutter库就在我们的flutter sdk中，路径如下 /bin/cache/artifacts/engine engine下面包含了各种平台的flutter库，我们随便拷贝一个Android平台的库到libs文件夹下，右键flutter.jar，弹出菜单选择Add As Library...。 经过这一步，项目中不会再报错了，但是，由于整个flutter plugin包含了flutter库，因此不能只是简单的添加就了事了，点击菜单Project Structure...，找到flutter_text_plugin的Dependencies中，将flutter库的Scope从Implementation改成Compile Only。至此，引入flutter库的工作完成了，可以进行插件的编写操作了。 添加第三方库添加第三方库有两种，一种是jar包引入，另一种通过gradle的方式进行。由于进行了第一步flutter库的引入，这一步就简单多了。查看build.gradle文件，可以看到最下面出现了如下的信息。 dependencies &#123; compileOnly files('libs/flutter.jar')&#125; 看到这个，是不是就明朗多了，添加静态库以及添加在线库都可以在这个地方进行。例如我添加一个bugly静态库以及okhttp3库： dependencies &#123; compileOnly files('libs/flutter.jar') implementation 'com.squareup.okhttp3:okhttp:3.10.0' implementation files('libs/bugly_crash_release.jar')&#125; 添加proguard rule由于了bugly以及okhttp3库，因此需要添加progurad rule。我们发现项目中没有proguard-rules.pro文件，因此这一步也需要我们自己去创建，在根目录下，建立proguard-rules.pro文件，将混淆规则添加进去，然后修改build.gradle文件，添加如下信息，跟普通Android项目差不多： buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; debug &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; Android权限添加了bugly以及okhttp3库，需要对应的权限申明，才能正常运行。直接在manifest文件下，添加对应的权限 &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.READ_LOGS"/&gt; 插件开发至此，准备工作都已就绪，你可以把这个项目当做一个独立的Android项目，在上面进行各种封装操作，然后在FlutterTestPlugin文件下，将接口暴露出来。通过platform channels与flutter层关联起来。 发布当插件开发完毕，可以将插件发布让其他人使用，在发布之前，确保pubspec.yaml,、README.md以及CHANGELOG.md文件的内容都正确填写完毕。可以通过dry-run命令来看准备是否就绪。 flutter packages pub publish –dry-run 检查无误后，可以执行下面的命令，发布到Pub上。 flutter packages pub publish 如何引用对插件的引用有两种，已经发布的和未发布的。 引用发布的库flutter项目的很多资源管理都在根目录的pubspec.yaml下面，类似于js中的一些包管理一样，在dependencies加上我们需要引入的库，例如引入url_launcher库： dependencies: url_launcher: ^0.4.2 如果这个库包含了一些平台相关的东西，例如需要在native层进行使用的话，则需要在对应的native项目单独做引用。 Android修改android/build.gradle的dependencies处做引用： dependencies &#123; provided rootProject.findProject(":url_launcher") &#125; iOS修改ios/hello.podspec文件 Pod::Spec.new do |s| # lines skipped s.dependency &apos;url_launcher&apos; 引用冲突引用不同的库可能会导致一些冲突，例如A和B两个插件，都包含了C插件，但是所需的版本不同。因此我们可以采取以下措施避免这种问题： 尽量使用范围版本而不是指定一个特定的版本。 强制统一冲突的插件版本 对于native层，android可以通过force命令强制指定版本，而iOS这边，Cocoapods则不支持引用的override功能。 引用未发布的库引用未发布的库有两种方式，通过本地路径和git地址的方式： 基于Path的引用方式：这种方式主要针对本地的未发布的库，引用的路径可以是相对或者绝对路径。 dependencies: plugin1: path: ../plugin1/ 基于Git的引用方式：这种方式针对存放在git上的库，其中path是可选的，可以定位到某个子目录 dependencies: package1: git: url: git://github.com/flutter/packages.git path: packages/package1 后话笔者新建了一个flutter学习相关的项目，github地址，里面包含了笔者写的关于flutter学习相关的一些文章，后期也会定期更新，也会上传一些学习demo，欢迎大家关注。 参考 Flutter进阶—平台插件 Flutter - Creating a Plugin Flutter for Android Developers Writing custom platform-specific code with platform channels Developing Packages &amp; Plugins Using Packages]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter与Android的交互]]></title>
    <url>%2Fposts%2F5ae94dfd.html</url>
    <content type="text"><![CDATA[Flutter 说到底只是一个 UI 框架，很多功能都需要通过原生的 Api 来实现，那么就会涉及到 Flutter 和 Native 的交互，因为本人不懂 iOS 开发，所以只能讲下 Flutter 同 Android 的交互。 Android 项目配置 Flutter 依赖既然是互相交互，那么需要准备一个 Android 项目。接着就需要创建 flutter module，让 Android 项目依赖，创建的方法可以参考官网 Flutter Wiki，虽然是官网提供的方法，但是完全按照这个步骤来，还是会有坑的，这边就慢慢一步步解决坑。 如果你用的是 Android Studio 进行开发的话，直接打开底部的 Terminal，直接创建 flutter module 依赖 flutter create -t module flutter_native_contact 至于 module 名可以随意填写，module 创建完后结构大概是这样的 接着切换到 module 下的 .android 文件夹，接着有坑来了，官网提供的方法是 ./gradlew flutter:assembleDebug 可能会提示命令不存在，那么直接通过 gradlew flutter:assembleDebug 来运行，等它自动跑完后，打开根目录下的 settings.gradle 文件，加入官网提供的 gradle 代码 setBinding(new Binding([gradle: this])) // newevaluate(new File( // new settingsDir.parentFile, // new 'flutter_native_contact/.android/include_flutter.groovy' // new)) // new 你以为这里没坑，真是图样图森破，没坑是不可能的，编译器大爷可能会给你甩这么个错误 很明显可以看出是找不到我们的文件，所以把文件名路径给补全 evaluate(new File( // new settingsDir.parentFile, // new 'FlutterNativeContactDemo/flutter_native_contact/.android/include_flutter.groovy' // 这里补全路径)) 接着打开原有项目下，原有项目下，原有项目下的 app 中的 build.gradle 文件，在 android 下加上如下代码 compileOptions &#123; sourceCompatibility 1.8 targetCompatibility 1.8&#125; 这个必须要加，不要问为什么，我也不知道为什么，最后在项目下添加 flutter module 的依赖就完成了。这个过程告诉我们一个什么道理呢？*不要以为官网的都对，官网讲的也不是完全可信的，时不时给你来个坑就能卡你老半天。 原生界面加载 Flutter 页面那么如何在原生界面显示 Flutter 界面呢，这个就需要通过 FlutterView 来实现了，Flutter 这个类提供了 createView 和 createFragment 两个方法，分别用于返回 FlutterView 和 FlutterFragment 实例，FlutterFragment 的实现原理也是通过 FlutterView 来实现的，可以简单看下 FlutterFragment 的源码 /** * A &#123;@link Fragment&#125; managing a &#123;@link FlutterView&#125;. * * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This file is auto-generated by Flutter tooling. * DO NOT EDIT.&lt;/p&gt; */public class FlutterFragment extends Fragment &#123; public static final String ARG_ROUTE = "route"; private String mRoute = "/"; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 获取传入的路由值，默认为 '/' if (getArguments() != null) &#123; mRoute = getArguments().getString(ARG_ROUTE); &#125; &#125; @Override public FlutterView onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // 最后还是挺过 createView 方法来生成页面，只不过直接放在 fragment， // 放在 fragment 会比直接 使用 FlutterView 更方便管理，例如实现 ViewPager 等 return Flutter.createView(getActivity(), getLifecycle(), mRoute); &#125;&#125; createFragment 方式加载在原生页面显示 Flutter 界面的第一种方式就是加载 FlutterFragment，看个比较简单的例子吧 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;!-- 这个布局用于加载 fragment --&gt; &lt;FrameLayout android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/flutter_fragment" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginEnd="20dp" android:layout_marginBottom="50dp" android:src="@drawable/ic_add_white_36dp" app:fabSize="auto" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 在 Activity 可以直接通过返回 FlutterFragment 加载到 FrameLayout 即可 class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) supportFragmentManager.beginTransaction() .add(R.id.fragment_container, Flutter.createFragment("route_flutter")) .commit() &#125;&#125; 这样就把 Flutter 页面加载到原生界面了，会通过传递的路由值在 dart 层进行查找，所以接着就需要编写 Flutter 界面 /// runApp 内部值也可以直接传入 _buildWidgetForNativeRoute 方法/// 这边在外层嵌套一层 MaterialApp 主要是防止一些不必要的麻烦，/// 例如 MediaQuery 这方面的使用等void main() =&gt; runApp(FlutterApp());class FlutterApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: _buildWidgetForNativeRoute(window.defaultRouteName), debugShowCheckedModeBanner: false, theme: ThemeData( primaryColor: Color(0XFF008577), accentColor: Color(0xFFD81B60), primaryColorDark: Color(0xFF00574B), iconTheme: IconThemeData(color: Color(0xFFD81B60)), ), ); &#125;&#125;/// 该方法用于判断原生界面传递过来的路由值，加载不同的页面Widget _buildWidgetForNativeRoute(String route) &#123; switch (route) &#123; case 'route_flutter': return GreetFlutterPage(); // 默认的路由值为 '/'，所以在 default 情况也需要返回页面，否则 dart 会报错，这里默认返回空页面 default: return Scaffold(); &#125;&#125;class GreetFlutterPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('NativeMessageContactPage'), ), body: Center( child: Text( 'This is a flutter fragment page', style: TextStyle(fontSize: 20.0, color: Colors.black), ), ), ); &#125;&#125; 运行后可以看到页面加载出来了，不过会有一段时间的空白，这个在正式打包后就不会出现，所以不必担心。最后的页面应该是这样的 createView 方式加载接着看下 createView 方法，说白了，第一种方法最后还是会通过该方式实现 @NonNullpublic static FlutterView createView(@NonNull final Activity activity, @NonNull final Lifecycle lifecycle, final String initialRoute) &#123; // 交互前的一些初始化工作，需要完成才可以继续下一步，同时需要保证当前线程为主线程 // Looper.myLooper() == Looper.getMainLooper()，否则会甩你一脸的 IllegalStateException FlutterMain.startInitialization(activity.getApplicationContext()); FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), null); final FlutterNativeView nativeView = new FlutterNativeView(activity); // 将 flutter 页面绑定到相应的 activity final FlutterView flutterView = new FlutterView(activity, null, nativeView) &#123; // ...... &#125;; // 将路由值传到 flutter 层，并加载相应的页面， if (initialRoute != null) &#123; flutterView.setInitialRoute(initialRoute); &#125; // 绑定 lifecycle，方便生命周期管理，同 activity 绑定 // 不熟悉 LifeCycle 的同学可以自行网上查找资料 lifecycle.addObserver(new LifecycleObserver() &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) public void onCreate() &#123; // 配置一些参数，传递到 flutter 层 final FlutterRunArguments arguments = new FlutterRunArguments(); arguments.bundlePath = FlutterMain.findAppBundlePath(activity.getApplicationContext()); arguments.entrypoint = "main"; // 最终会调用方法 nativeRunBundleAndSnapshotFromLibrary，这是一个 native 方法，进行交互 flutterView.runFromBundle(arguments); // 进行注册 GeneratedPluginRegistrant.registerWith(flutterView.getPluginRegistry()); &#125; // ...... &#125;); return flutterView;&#125; 通过 createView 方法返回的 FlutterView，通过设置 Layoutparams 参数就可以添加到相应的布局上，还有一种直接通过 addContentView 方式进行加载，这里直接修改原有代码， override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // setContentView(R.layout.activity_main) 不需要这一步了 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_flutter") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) // 直接加载到 activity 页面 &#125; 但是通过这样加载的话，那么整个页面都是 flutter 的页面。那么之前的效果的 FAB 则不会被加载出来了，即使没有省略 setContentView(R.layout.activity_main) 方法，这个页面的 xml 布局也会被覆盖。 PlantformChannel那么能够在原生界面显示 flutter 页面了，如何互相交互呢，这就需要通过 PlantformChannel 来执行了，PlantformChannel 主要有三种类型，BasicMessageChannel，MethodChannel，EventChannel。通过查看源码可以发现，三个 Channel 的实现机制类似，都是通过 BinaryMessenger 进行信息交流，每个 Channel 通过传入的 channel name 进行区分，所以在注册 Channel 的时候必须要保证 channel name 是唯一的，同时需要传入一个 BinaryMessageHandler 实例，用于传递信息的处理，当 Handler 处理完信息后，会返回一个 result，然后通过 BinaryMessenger 将 result 返回到 Flutter 层。如果需要深入理解这边推荐一篇文章深入理解Flutter PlatformChannel 接下来直接看例子吧，在创建 PlatformChannel 的时候需要传入一个 BinaryMessenger 实例，通过查看 FlutterView 的源码可以发现，FlutterView 就是一个 BinaryMessenger 在 Android 端的实现，所以呢，可以直接通过前面介绍的 Flutter.createView 方法获取注册 Channel 时的 BinaryMessenger 实例了，真是得来全部费工夫~因为通信的方法可能在多个界面会使用，所以还是封装一个通用类来处理会比较合理 BasicMessageChannel BasicMessageChannel 用于传递字符串和半结构化的信息。 class FlutterPlugin(private val flutterView: FlutterView) :BasicMessageChannel.MessageHandler&lt;Any&gt;&#123; companion object &#123; private const val TAG = "FlutterPlugin" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; // channel name 需要保持两侧一致 val messageChannel = BasicMessageChannel(flutterView, Constant.MESSAGE_CHANNEL_NAME, StandardMessageCodec.INSTANCE) // MessageCodec 有多种实现方式，可以参考推荐的文章 val instance = FlutterPlugin(flutterView) messageChannel.setMessageHandler(instance) // 注册处理的 Hnadler return instance &#125; &#125; override fun onMessage(`object`: Any?, reply: BasicMessageChannel.Reply&lt;Any&gt;?) &#123; // 简单的将从 Flutter 传过来的消息进行吐司，同时返回自己的交互信息 // `object` 中包含的就是 Flutter 层传递过来的信息，reply 实例用于传递信息到 Flutter 层 Toast.makeText(flutterView.context, `object`.toString(), Toast.LENGTH_LONG).show() reply?.reply("\"Hello Flutter\"--- an message from Android") &#125;&#125; 接着就需要有个 FlutterView 用来注册，新建一个 Activity，用于加载 Flutter 页面 class ContactActivity : AppCompatActivity() &#123; private lateinit var plugin: FlutterPlugin override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // 传入路由值，需要在 flutter 层生成相应的界面 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_contact") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) plugin = FlutterPlugin.registerPlugin(flutterView) &#125; override fun onDestroy() &#123; super.onDestroy() &#125;&#125; 那么我们就要在 Flutter 界面的 _buildWidgetForNativeRoute 方法加入新路由值对应的界面 Widget _buildWidgetForNativeRoute(String route) &#123; switch (route) &#123; // ... case 'route_contact': return FlutterContactPage(); default: return Scaffold(); &#125;&#125;class FlutterContactPage extends StatelessWidget &#123; // 注册对应的 channel，要保证 channel name 和原生层是一致的 final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Flutter Page'), ), // 简单放一个按钮，通过 channel 传输消息过去，同时将原生层返回的消息打印出来 body: RaisedButton( onPressed: () &#123; _messageChannel .send('"Hello Native" --- an message from flutter') .then((str) &#123; print('Receive message: $str'); &#125;); &#125;, child: Text('Send Message to Native'), ), ); &#125;&#125; 最后的效果小伙伴可以自行执行，点击按钮后会弹出吐司，吐司内容就是 Flutter 传递的信息，同时在控制台可以看到从原生层返回的信息。 MethodChannel MethodChannel 用于传递方法调用（method invocation） 直接在上述例子中进行修改，例如在 Flutter 页面中实现 Activity 的 finish 方法，并传递参数到前一个界面，先做 Flutter 页面的修改，在 AppBar 上增加一个返回按钮，用于返回上层页面 class FlutterContactPage extends StatelessWidget &#123; // 注册对应的 channel，要保证 channel name 和原生层是一致的 final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); final MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: InkWell( child: Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Icon(Icons.arrow_back), ), onTap: () &#123; _methodChannel // invokeMethod 第一个值用于传递方法名，第二个值用于传递参数， // 这边简单的传递一个字符串，当然也可以传递别的类型，map，list 等等 .invokeMethod&lt;bool&gt;('finishActivity', 'Finish Activity') .then((result) &#123; // 这边会返回一个结果值，通过判断是否成功来打印不同的信息 print('$&#123;result ? 'has finish' : 'not finish'&#125;'); &#125;); &#125;, ), title: Text('Flutter Page'), ), body: // ... ); &#125;&#125; 同时，我们需要在 FlutterPlugin 这个类中，做些必要的修改，首先需要实现 MethodCallHandler 接口，该接口中需要实现 onMethodCall 方法，通过获取调用的方法名和参数值，进行相应的处理 class FlutterPlugin(private val flutterView: FlutterView) : MethodChannel.MethodCallHandler, BasicMessageChannel.MessageHandler&lt;Any&gt; &#123; companion object &#123; private const val TAG = "FlutterPlugin" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; val instance = FlutterPlugin(flutterView) val methodChannel = MethodChannel(flutterView, Constant.METHOD_CHANNEL_NAME) // ... messageChannel.setMessageHandler(instance) return instance &#125; &#125; // .... // call 中携带了 Flutter 层传递过来的方法名和参数信息 // 可以分别通过 call.method 和 call.arguments 来获取 override fun onMethodCall(call: MethodCall?, result: MethodChannel.Result?) &#123; when (call?.method) &#123; "finishActivity" -&gt; &#123; val activity = flutterView.context as Activity val info = call.arguments.toString() val intent = Intent().apply &#123; putExtra("info", info) &#125; activity.setResult(Activity.RESULT_OK, intent) activity.finish() // 成功时候通过 result.success 返回值， // 如果发生异常，通过 result.error 返回异常信息 // Flutter 通过 invokeMethod().then() 来处理正常结束的逻辑 // 通过 catchError 来处理发生异常的逻辑 result?.success(true) &#125; // 如果未找到对应的方法名，则通过 result.notImplemented 来返回异常 else -&gt; result?.notImplemented() &#125; &#125; 最终的效果，当点击返回按钮的时候，会将 Flutter 层通过 invokeMethod 传递的 arguments 属性吐司出来，同时，控制台会打印出 “has finish” 的信息 EventChannel EventChannel 用于数据流（event streams）的通信 EventChannel 的实现方式也类似，EventChannel 可以持续返回多个信息到 Flutter 层，在 Flutter 层的表现就是一个 stream，原生层通过 sink 不断的添加数据，Flutter 层接收到数据的变化就会作出新相应的处理。在 Android 端实现状态的监听可以通过广播来实现。直接看例子，还是修改上述代码 class FlutterPlugin(private val flutterView: FlutterView) : MethodChannel.MethodCallHandler, EventChannel.StreamHandler, BasicMessageChannel.MessageHandler&lt;Any&gt; &#123; private var mStateChangeReceiver: BroadcastReceiver? = null companion object &#123; private const val TAG = "FlutterPlugin" const val STATE_CHANGE_ACTION = "com.demo.plugins.action.StateChangeAction" const val STATE_VALUE = "com.demo.plugins.value.StateValue" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; // ... val streamChannel = EventChannel(flutterView, Constant.STREAM_CHANNEL_NAME) val instance = FlutterPlugin(flutterView) methodChannel.setMethodCallHandler(instance) streamChannel.setStreamHandler(instance) messageChannel.setMessageHandler(instance) return instance &#125; &#125; // 实现 StreamHandler 需要重写 onListen 和 onCancel 方法 // onListen 不会每次数据改变就会调用，只在 Flutter 层，eventChannel 订阅广播 // 的时候调用，当取消订阅的时候则会调用 onCancel， // 所以当开始订阅数据的时候，注册接收数据变化的关闭， // 在取消订阅的时候，将注册的广播注销，防止内存泄漏 override fun onListen(argument: Any?, sink: EventChannel.EventSink?) &#123; mStateChangeReceiver = createEventListener(sink) flutterView.context.registerReceiver(mStateChangeReceiver, IntentFilter(STATE_CHANGE_ACTION)) &#125; override fun onCancel(argument: Any?) &#123; unregisterListener() &#125; // 在 activity 被销毁的时候，FlutterView 不一定会调用销毁生命周期，或者会延时调用 // 这就需要手动去注销一开始注册的广播了 fun unregisterListener() &#123; if (mStateChangeReceiver != null) &#123; flutterView.context.unregisterReceiver(mStateChangeReceiver) mStateChangeReceiver = null &#125; &#125; private fun createEventListener(sink: EventChannel.EventSink?): BroadcastReceiver = object : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; if (TextUtils.equals(intent?.action, STATE_CHANGE_ACTION)) &#123; // 这边广播只做简单的接收一个整数，然后通过 sink 传递到 Flutter 层 // 当然，sink 还有 error 方法，用于传递发生的错误信息， // 以及 endOfStream 方法，用于结束接收 // 在 Flutter 层分别有 onData 对应 success 方法，onError 对应 error 方法 // onDone 对应 endOfStream 方法，根据不同的回调处理不同的逻辑 sink?.success(intent?.getIntExtra(STATE_VALUE, -1)) &#125; &#125; &#125;&#125; 在 Flutter 层，通过对 stream 的监听，对返回的数据进行处理，为了体现出变化，这边修改成 SatefulWidget 来存储状态 class FlutterContactPage extends StatefulWidget &#123; @override _FlutterContactPageState createState() =&gt; _FlutterContactPageState();&#125;class _FlutterContactPageState extends State&lt;FlutterContactPage&gt; &#123; final MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME); final EventChannel _eventChannel = EventChannel(STREAM_CHANNEL_NAME); final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); StreamSubscription _subscription; var _receiverMessage = 'Start receive state'; // 初始的状态值 @override void initState() &#123; super.initState(); // 当页面生成的时候就开始监听数据的变化 _subscription = _eventChannel.receiveBroadcastStream().listen((data) &#123; setState(() &#123; _receiverMessage = 'receive state value: $data'; // 数据变化了，则修改数据 &#125;); &#125;, onError: (e) &#123; _receiverMessage = 'process error: $e'; // 发生错误则显示错误信息 &#125;, onDone: () &#123; _receiverMessage = 'receive data done'; // 发送完毕则直接显示完毕 &#125;, cancelOnError: true); &#125; @override void dispose() &#123; super.dispose(); _subscription.cancel(); // 当页面销毁的时候需要将订阅取消，防止内存泄漏 &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: InkWell( child: Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Icon(Icons.arrow_back), ), onTap: () &#123; // MethodChannel demo _methodChannel .invokeMethod&lt;bool&gt;('finishActivity', _receiverMessage) .then((result) &#123; print('$&#123;result ? 'has finish' : 'not finish'&#125;'); &#125;).catchError((e) &#123; print('error happend: $e'); &#125;); &#125;, ), title: Text('Flutter Page'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(8.0), // EventChannel demo，页面直接显示信息的变化 child: Text( _receiverMessage, style: TextStyle(fontSize: 20.0, color: Colors.black), ), ), // BasicMessageChannel demo RaisedButton( onPressed: () &#123; _messageChannel .send('"Hello Native" --- an message from flutter') .then((str) &#123; print('Receive message: $str'); &#125;); &#125;, child: Text('Send Message to Native'), ), ], ), ), ); &#125;&#125; 同时，需要在 Activity 层调用一个定时任务不断的发送广播 class ContactActivity : AppCompatActivity() &#123; private var timer: Timer? = null private var task: TimerTask? = null private lateinit var random: Random private lateinit var plugin: FlutterPlugin override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) random = Random() // 生成随机整数 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_contact") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) plugin = FlutterPlugin.registerPlugin(flutterView) timer = Timer() // 定时器 task = timerTask &#123; // 定时任务 sendBroadcast(Intent(FlutterPlugin.STATE_CHANGE_ACTION).apply &#123; putExtra(FlutterPlugin.STATE_VALUE, random.nextInt(1000)) &#125;) &#125; timer?.schedule(task, 3000, 2000) // 延时 3s 开启定时器，并 2s 发送一次广播 &#125; override fun onDestroy() &#123; super.onDestroy() // 页面销毁的时候需要将定时器，定时任务销毁 // 同时注销 Plugin 中注册的广播，防止内存泄漏 timer?.cancel() timer = null task?.cancel() task = null plugin.unregisterListener() &#125;&#125; 最后的实现效果大概是这样的 Flutter 同 Android 端的交互到这讲的差不多了，和 iOS 的交互其实也类似，只不过在 Android 端通过 FlutterNativeView 来作为 Binarymessenger 的实现，在 iOS 端通过 FlutterBinaryMessenger 协议实现，原理是一致的。至于 Flutter 插件，其实现也是通过以上三种交互方式来实现的，可能我们目前通过 FlutterView 来作为 BinaryMessenger 实例，插件会通过 PluginRegistry.Registrar 实例的 messenger() 方法来获取 BinaryMessenger 实例。 最后贴上 demo 的地址：ContactDemo 需要了解插件的写法也可以直接查看官方提供的检测电量插件：Flutter Battery Plugin]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十四)之实战]]></title>
    <url>%2Fposts%2Fb447830c.html</url>
    <content type="text"><![CDATA[讲完了常用的部件和网络请求后，差不多该进入整体实战了，这里我们将写一个比较熟悉的项目，郭神的 cool weather。项目将使用 fluro 实现路由管理，dio 实现网络请求，rxdart 实现 BLoC 进行状态管理和逻辑分离，使用文件，shared_preferences，sqflite 实现本地的数据持久化。这边先给出项目的地址：flutter_weather，以及最后实现的效果图： 首页 录音 播放 除了 fluro 别的基本上前面都讲了，所以在开始正式的实战前，先讲下 fluro Flurofluro 是对 Navigator 的一个封装，方便更好的管理路由跳转，当然还存在一些缺陷，例如目前只支持传递字符串，不能传递中文等，但是这些问题都算不上是大问题。 fluro 的使用很简单，大概分如下的步骤： 在全局定义一个 Router 实例 final router = Router(); 使用 Router 实例定义路径和其对应的 Handler 对象 // 例如定义一个 CityPage 的路径和 HandlerHandler cityHandler = Handler(handlerFunc: (_, params) &#123; // 传递的参数都在 params 中，params 是一个 Map&lt;String, List&lt;String&gt;&gt; 类型参数 String cityId = params['city_id']?.first; return BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());&#125;);// 定义路由的路径和参数// 需要注意的是，第一个页面的路径必须为 "/"，别的可为 "/" + 任意拼接router.define('/city', handler: cityHandler);// 或者官方提供的另一种方式router.define('/city/:city_id', handler: cityHandler); 将 router 注册到 MaterialApp 的 onGenerateRoute 中 MaterialApp(onGenerateRoute: router); 最后通过 Router 实例进行跳转，如果有参数传递则会在新的页面收到 router.navigateTo(context, '/city?city_id=CN13579');// 或者官方的方式router.navigateTo(context, '/city/CN13579'); 在 fluro 中提供了多种路由动画，包括 fadeIn，inFromRight 等。讲完了使用，就进入实战了。 flutter_weather 实战导入插件在开始的时候，已经提到了整体功能的实现需求，所以这边需要导入的插件以及存放图片的文件夹如下： dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2 fluro: ^1.4.0 dio: ^2.1.0 shared_preferences: ^0.5.1+2 sqflite: ^1.1.3 fluttertoast: ^3.0.3 rxdart: ^0.21.0 path_provider: 0.5.0+1dev_dependencies: flutter_test: sdk: flutter flutter: uses-material-design: true assets: - images/ 顶层静态实例的实现有许多实例需要在顶层注册，然后在全局使用，包括但不限于 fluro 的 router，http，database 等等。在这个项目中，需要用到的就是这三个实例，会在全局调用，所以在开始前进行初始化，当然 http 和 database 在使用的时候创建也可以，完全看个人习惯，但是 fluro 的管理类必须在一开始就注册完成。首先需要定义一个 Application 类用来存放这些静态实例 class Application &#123; static HttpUtils http; // 全局网络 static Router router; // 全局路由 static DatabaseUtils db; // 全局数据库&#125; 接着就是对相应方法类的编写，其中 HttpUtil 和 DatabaseUtils 在前面有讲过，这边不重复讲，会讲下数据库如何建立。 Fluro 路由管理类首先，需要知道，该项目的界面大概分如下的界面(当然可先只定义首页，剩下用到了再定义，该项目相对简单，所以先列出来)：省选择页，市选择页，区选择页，天气展示页，设置页。所以 fluro 的管理类可按如下定义： // 查看 `routers/routers.dart` 文件class Routers &#123; /// 各个页面对应的路径 static const root = '/'; static const weather = '/weather'; static const provinces = '/provinces'; static const cities = '/cities'; static const districts = '/districts'; static const settings = '/settings'; /// 该方法用于放到 `main` 方法中定义所有的路由， /// 对应的 handler 可放同一个文件，也可放另一个文件，看个人喜好 static configureRouters(Router router) &#123; router.notFoundHandler = notFoundHandler; router.define(root, handler: rootHandler); // 首页 router.define(weather, handler: weatherHandler); // 天气展示页 router.define(provinces, handler: provincesHandler); // 省列表页 router.define(cities, handler: citiesHandler); // 省下市列表页 router.define(districts, handler: districtsHandler); // 市下区列表页 router.define(settings, handler: settingsHandler); // 设置页 &#125; /// 生成天气显示页面路径，需要用到城市 id static generateWeatherRouterPath(String cityId) =&gt; '$weather?city_id=$cityId'; /// 生成省下的市列表页相应路径 需要用到省 id 及省名 static generateProvinceRouterPath(int provinceId, String name) =&gt; '$cities?province_id=$provinceId&amp;name=$name'; /// 生成市下的区列表页相应路径，需用到市 id 及市名 static generateCityRouterPath(int provinceId, int cityId, String name) =&gt; '$districts?province_id=$provinceId&amp;city_id=$cityId&amp;name=$name';&#125;/// 查看 `routers/handler.dart` 文件Handler notFoundHandler = Handler(handlerFunc: (_, params) &#123; Logger('RouterHandler:').log('Not Found Router'); // 当找不到相应的路由时，打印信息处理&#125;);Handler rootHandler = Handler(handlerFunc: (_, params) =&gt; SplashPage());Handler weatherHandler = Handler(handlerFunc: (_, params) &#123; String cityId = params['city_id']?.first; // 获取相应的参数 return WeatherPage(city: cityId);&#125;);Handler provincesHandler = Handler(handlerFunc: (_, params) =&gt; ProvinceListPage());Handler citiesHandler = Handler(handlerFunc: (_, params) &#123; String provinceId = params['province_id']?.first; String name = params['name']?.first; return CityListPage(provinceId: provinceId, name: FluroConvertUtils.fluroCnParamsDecode(name));&#125;);Handler districtsHandler = Handler(handlerFunc: (_, params) &#123; String provinceId = params['province_id']?.first; String cityId = params['city_id']?.first; String name = params['name']?.first; return DistrictListPage(provinceId: provinceId, cityId: cityId, name: FluroConvertUtils.fluroCnParamsDecode(name));&#125;);Handler settingsHandler = Handler(handlerFunc: (_, params) =&gt; SettingsPage()); 那么界面的路由到这就编写好了，但是前面提到了 fluro 目前不支持中文的传递，所以在传递中文时候，需要先进行转码，这边提供一个自己写的方法，小伙伴有更好的方法也可以直接在项目提 issue /// 查看 `utils/fluro_convert_util.dart` 文件class FluroConvertUtils &#123; /// fluro 传递中文参数前，先转换，fluro 不支持中文传递 static String fluroCnParamsEncode(String originalCn) &#123; StringBuffer sb = StringBuffer(); var encoded = Utf8Encoder().convert(originalCn); // utf8 编码，会生成一个 int 列表 encoded.forEach((val) =&gt; sb.write('$val,')); // 将 int 列表重新转换成字符串 return sb.toString().substring(0, sb.length - 1).toString(); &#125; /// fluro 传递后取出参数，解析 static String fluroCnParamsDecode(String encodedCn) &#123; var decoded = encodedCn.split('[').last.split(']').first.split(','); // 对参数字符串分割 var list = &lt;int&gt;[]; decoded.forEach((s) =&gt; list.add(int.parse(s.trim()))); // 转回 int 列表 return Utf8Decoder().convert(list); // 解码 &#125;&#125; Database 管理类编写因为数据库的开启是一个很耗资源的过程，所以这边通过单例并提取到顶层。在该项目中，数据库主要用于存储城市信息，因为城市之间的关联比较复杂，如果通过 shared_preferences 或者文件存储会很复杂。 /// 查看 `utils/db_utils.dart` 文件class DatabaseUtils &#123; final String _dbName = 'weather.db'; // 数据表名 final String _tableProvinces = 'provinces'; // 省表 final String _tableCities = 'cities'; // 市表 final String _tableDistricts = 'districts'; // 区表 static Database _db; static DatabaseUtils _instance; static DatabaseUtils get instance =&gt; DatabaseUtils(); /// 将数据库的初始化放到私有构造中，值允许通过单例访问 DatabaseUtils._internal() &#123; getDatabasesPath().then((path) async &#123; _db = await openDatabase(join(path, _dbName), version: 1, onCreate: (db, version) &#123; db.execute('create table $_tableProvinces(' 'id integer primary key autoincrement,' 'province_id integer not null unique,' // 省 id，id 唯一 'province_name text not null' // 省名 ')'); db.execute('create table $_tableCities(' 'id integer primary key autoincrement,' 'city_id integer not null unique,' // 市 id，id 唯一 'city_name text not null,' // 市名 'province_id integer not null,' // 对应的省的 id，作为外键同省表关联 'foreign key(province_id) references $_tableProvinces(province_id)' ')'); db.execute('create table $_tableDistricts(' 'id integer primary key autoincrement,' 'district_id integer not null unique,' // 区 id 'district_name text not null,' // 区名 'weather_id text not null unique,' // 查询天气用的 id，例如 CN13579826，id 唯一 'city_id integer not null,' // 对应市的 id，作为外键同市表关联 'foreign key(city_id) references $_tableCities(city_id)' ')'); &#125;, onUpgrade: (db, oldVersion, newVersion) &#123;&#125;); &#125;); &#125; /// 构建单例 factory DatabaseUtils() &#123; if (_instance == null) &#123; _instance = DatabaseUtils._internal(); &#125; return _instance; &#125; /// 查询所有的省，`ProvinceModel` 为省市接口返回数据生成的 model 类 /// 查看 `model/province_model.dart` 文件 Future&lt;List&lt;ProvinceModel&gt;&gt; queryAllProvinces() async =&gt; ProvinceModel.fromProvinceTableList(await _db.rawQuery('select province_id, province_name from $_tableProvinces')); /// 查询某个省内的所有市 Future&lt;List&lt;ProvinceModel&gt;&gt; queryAllCitiesInProvince(String proid) async =&gt; ProvinceModel.fromCityTableList(await _db.rawQuery( 'select city_id, city_name from $_tableCities where province_id = ?', [proid], )); /// 查询某个市内的所有区，`DistrictModel` 为区接口返回数据生成的 model 类 /// 查看 `model/district_model.dart` 文件 Future&lt;List&lt;DistrictModel&gt;&gt; queryAllDistrictsInCity(String cityid) async =&gt; DistrictModel.fromDistrictTableList(await _db.rawQuery( 'select district_id, district_name, weather_id from $_tableDistricts where city_id = ?', [cityid], )); /// 将所有的省插入数据库 Future&lt;void&gt; insertProvinces(List&lt;ProvinceModel&gt; provinces) async &#123; var batch = _db.batch(); provinces.forEach((p) =&gt; batch.rawInsert( 'insert or ignore into $_tableProvinces (province_id, province_name) values (?, ?)', [p.id, p.name], )); batch.commit(); &#125; /// 将省对应下的所有市插入数据库 Future&lt;void&gt; insertCitiesInProvince(List&lt;ProvinceModel&gt; cities, String proid) async &#123; var batch = _db.batch(); cities.forEach((c) =&gt; batch.rawInsert( 'insert or ignore into $_tableCities (city_id, city_name, province_id) values (?, ?, ?)', [c.id, c.name, proid], )); batch.commit(); &#125; /// 将市下的所有区插入数据库 Future&lt;void&gt; insertDistrictsInCity(List&lt;DistrictModel&gt; districts, String cityid) async &#123; var batch = _db.batch(); districts.forEach((d) =&gt; batch.rawInsert( 'insert or ignore into $_tableDistricts (district_id, district_name, weather_id, city_id) values (?, ?, ?, ?)', [d.id, d.name, d.weatherId, cityid], )); batch.commit(); &#125;&#125; 定义完全局使用的方法，就可以在 main 函数中进行相关的初始化了 /// 查看 `main.dart` 文件void main() &#123; // 初始化 fluro router Router router = Router(); Routers.configureRouters(router); Application.router = router; // 初始化 http Application.http = HttpUtils(baseUrl: WeatherApi.WEATHER_HOST); // 初始化 db Application.db = DatabaseUtils.instance; // 强制竖屏，因为设置竖屏为 `Future` 方法，防止设置无效可等返回值后再启动 App SystemChrome.setPreferredOrientations([DeviceOrientation.portraitDown, DeviceOrientation.portraitUp]).then((_) &#123; runApp(WeatherApp()); // App 类可放在同个文件，个人习惯单独一个文件存放 if (Platform.isAndroid) &#123; SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent)); &#125; &#125;);&#125;class WeatherApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Weather App', onGenerateRoute: Application.router.generator, // 将 fluro 的路由进行注册 debugShowCheckedModeBanner: false, ); &#125;&#125; 初始化完毕，接着就可以进行页面的编写了。 首页编写首页主要是为了对 App 的一个大概展示，或者是一些广告的展示，同时也给一些数据初始化提供时间，当用户进入后有更好的体验效果。我们在这里就做一个图标的展示(图标可自行到项目中 images 文件夹查找)，延时 5s 后跳转下个页面。 /// 查看 `splash_page.dart` 文件class SplashPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; /// 因为已经引入了 rxdart，这里通过 rxdart.timer 进行倒计时 /// 当然也可以使用 Futuer.delayed 进行倒计时 /// 5s 计时，如果已经选择城市，跳转天气界面，否则进入城市选择 Observable.timer(0, Duration(milliseconds: 5000)).listen((_) &#123; PreferenceUtils.instance.getString(PreferencesKey.WEATHER_CITY_ID) .then((city) &#123; // 如果当前还未选择城市，则进入城市选择页，否则跳转天气详情页 // replace: true 即为 Navigator.pushReplacement 方法 Application.router.navigateTo(context, city.isEmpty ? Routers.provinces : Routers.generateWeatherRouterPath(city), replace: true); &#125;); &#125;); return Scaffold( body: Container( alignment: Alignment.center, color: Colors.white, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 展示图标 Image.asset(Resource.pngSplash, width: 200.0, height: 200.0), // 展示文字提醒，用 SizedBox 设置区域大小 SizedBox( width: MediaQuery.of(context).size.width * 0.7, child: Text( '所有天气数据均为模拟数据，仅用作学习目的使用，请勿当作真实的天气预报软件来使用', textAlign: TextAlign.center, softWrap: true, style: TextStyle(color: Colors.red[700], fontSize: 16.0), )) ], ), ), ); &#125;&#125; 城市选择页面当首次进入的时候，用户肯定没有选择城市，所以先编写城市选择列表页面，因为整体的项目使用 BLoC 分离业务逻辑和页面，所以先编写数据管理类吧，把数据请求和改变的业务逻辑放到这块，BLoC 的实现在前面讲过了，这边就不重复提了。 /// 查看 `provinces_bloc.dart` 文件class ProvincesBloc extends BaseBloc &#123; final _logger = Logger('ProvincesBloc'); List&lt;ProvinceModel&gt; _provinces = []; // 全国省 List&lt;ProvinceModel&gt; _cities = []; // 省内市 List&lt;DistrictModel&gt; _districts = []; // 市内区 List&lt;ProvinceModel&gt; get provinces =&gt; _provinces; List&lt;ProvinceModel&gt; get cities =&gt; _cities; List&lt;DistrictModel&gt; get districts =&gt; _districts; BehaviorSubject&lt;List&lt;ProvinceModel&gt;&gt; _provinceController = BehaviorSubject(); BehaviorSubject&lt;List&lt;ProvinceModel&gt;&gt; _citiesController = BehaviorSubject(); BehaviorSubject&lt;List&lt;DistrictModel&gt;&gt; _districtController = BehaviorSubject(); /// stream，用于 StreamBuilder 的 stream 参数 Observable&lt;List&lt;ProvinceModel&gt;&gt; get provinceStream =&gt; Observable(_provinceController.stream); Observable&lt;List&lt;ProvinceModel&gt;&gt; get cityStream =&gt; Observable(_citiesController.stream); Observable&lt;List&lt;DistrictModel&gt;&gt; get districtStream =&gt; Observable(_districtController.stream); /// 通知刷新省份列表 changeProvinces(List&lt;ProvinceModel&gt; provinces) &#123; _provinces.clear(); _provinces.addAll(provinces); _provinceController.add(_provinces); &#125; /// 通知刷新城市列表 changeCities(List&lt;ProvinceModel&gt; cities) &#123; _cities.clear(); _cities.addAll(cities); _citiesController.add(_cities); &#125; /// 通知刷新区列表 changeDistricts(List&lt;DistrictModel&gt; districts) &#123; _districts.clear(); _districts.addAll(districts); _districtController.add(_districts); &#125; /// 请求全国省 Future&lt;List&lt;ProvinceModel&gt;&gt; requestAllProvinces() async &#123; var resp = await Application.http.getRequest(WeatherApi.WEATHER_PROVINCE, error: (msg) =&gt; _logger.log(msg, 'province')); return resp == null || resp.data == null ? [] : ProvinceModel.fromMapList(resp.data); &#125; /// 请求省内城市 Future&lt;List&lt;ProvinceModel&gt;&gt; requestAllCitiesInProvince(String proid) async &#123; var resp = await Application.http .getRequest('$&#123;WeatherApi.WEATHER_PROVINCE&#125;/$proid', error: (msg) =&gt; _logger.log(msg, 'city')); return resp == null || resp.data == null ? [] : ProvinceModel.fromMapList(resp.data); &#125; /// 请求市内的区 Future&lt;List&lt;DistrictModel&gt;&gt; requestAllDistricts(String proid, String cityid) async &#123; var resp = await Application.http .getRequest('$&#123;WeatherApi.WEATHER_PROVINCE&#125;/$proid/$cityid', error: (msg) =&gt; _logger.log(msg, 'district')); return resp == null || resp.data == null ? [] : DistrictModel.fromMapList(resp.data); &#125; @override void dispose() &#123; // 及时销毁 _provinceController?.close(); _citiesController?.close(); _districtController?.close(); &#125;&#125; 写完 BLoC 需要对其进行注册，因为城市选择相对还是比较频繁的，所以可以放最顶层进行注册 return BlocProvider( bloc: ProvincesBloc(), // 城市切换 BLoC child: MaterialApp( title: 'Weather App', onGenerateRoute: Application.router.generator, debugShowCheckedModeBanner: false, ), ); 城市选择就是一个列表，直接通过 ListView 生成即可，前面讲 ListView 的时候提到，尽可能固定 item 的高度，会提高绘制效率 /// 查看 `provinces_page.dart` 文件class ProvinceListPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;ProvincesBloc&gt;(context); // 进入的时候先使用数据库的数据填充界面 Application.db.queryAllProvinces().then((ps) =&gt; _bloc.changeProvinces(ps)); // 网络数据更新列表并刷新数据库数据 _bloc.requestAllProvinces().then((provinces) &#123; _bloc.changeProvinces(provinces); Application.db.insertProvinces(provinces); &#125;); return Scaffold( appBar: AppBar( title: Text('请选择省份'), ), body: Container( color: Colors.black12, alignment: Alignment.center, // 省列表选择 child: StreamBuilder( stream: _bloc.provinceStream, initialData: _bloc.provinces, builder: (_, AsyncSnapshot&lt;List&lt;ProvinceModel&gt;&gt; snapshot) =&gt; !snapshot.hasData || snapshot.data.isEmpty // 如果当前的数据未加载则给一个加载，否则显示列表加载 ? CupertinoActivityIndicator(radius: 12.0) : ListView.builder( physics: BouncingScrollPhysics(), padding: const EdgeInsets.symmetric(horizontal: 12.0), itemBuilder: (_, index) =&gt; InkWell( child: Container( alignment: Alignment.centerLeft, child: Text(snapshot.data[index].name, style: TextStyle(fontSize: 18.0, color: Colors.black)), ), onTap: () =&gt; Application.router.navigateTo( context, // 跳转下层省内城市选择，需要将当前的省 id 以及省名传入 Routers. generateProvinceRouterPath(snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)), transition: TransitionType.fadeIn), ), itemExtent: 50.0, itemCount: snapshot.data.length), ), ), ); &#125;&#125; 对于市和区的列表选择也类似，除了最后的点击会有些区别页面的布局几乎一致，这边只提下点击事件 /// 查看 `cities_page.dart` 文件Application.router.navigateTo( context, // 跳转下层省内城市选择 Routers.generateProvinceRouterPath( snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)), transition: TransitionType.fadeIn), )// 设置为当前区，并清理路由 stack，并将天气界面设置到最上层onTap: () &#123; PreferenceUtils.instance .saveString(PreferencesKey.WEATHER_CITY_ID, snapshot.data[index].weatherId); Application.router.navigateTo(context, Routers.generateWeatherRouterPath(snapshot.data[index].weatherId), transition: TransitionType.inFromRight, clearStack: true); &#125;) 天气详情页面天气详情页面相对部件会多点，为了看着舒服一点，这里拆成多个部分来编写，在这之前还是先编写数据的管理类，因为天气详情接口返回的数据嵌套层次比较多，关系比较复杂，不适合用 database 来做持久化，所以这里采用文件持久化方式。当然有些小伙伴会问干嘛不使用 shared_preferences 来存储，理论上应该没有太大的问题，但是个人建议相对复杂的数据使用文件存储会相对比较好点，一定要说个为什么，我也说不出来。 /// 查看 `weather_bloc.dart` 文件class WeatherBloc extends BaseBloc &#123; final _logger = Logger('WeatherBloc'); WeatherModel _weather; // 天气情况 String _background = WeatherApi.DEFAULT_BACKGROUND; // 背景 WeatherModel get weather =&gt; _weather; String get background =&gt; _background; BehaviorSubject&lt;WeatherModel&gt; _weatherController = BehaviorSubject(); BehaviorSubject&lt;String&gt; _backgroundController = BehaviorSubject(); Observable&lt;WeatherModel&gt; get weatherStream =&gt; Observable(_weatherController.stream); Observable&lt;String&gt; get backgroundStream =&gt; Observable(_backgroundController.stream); /// 更新天气情况 updateWeather(WeatherModel weather) &#123; _weather = weather; _weatherController.add(_weather); &#125; /// 更新天气背景 updateBackground(String background) &#123; _background = background; _backgroundController.add(_background); &#125; // 请求天气情况 Future&lt;WeatherModel&gt; requestWeather(String id) async &#123; var resp = await Application.http .getRequest(WeatherApi.WEATHER_STATUS, params: &#123;'cityid': id, 'key': WeatherApi.WEATHER_KEY&#125;, error: (msg) =&gt; _logger.log(msg, 'weather')); // 请求数据成功则写入到文件中 if (resp != null &amp;&amp; resp.data != null) &#123; _writeIntoFile(json.encode(resp.data)); &#125; return WeatherModel.fromMap(resp.data); &#125; Future&lt;String&gt; requestBackground() async &#123; var resp = await Application.http .getRequest&lt;String&gt;(WeatherApi.WEATHER_BACKGROUND, error: (msg) =&gt; _logger.log(msg, 'background')); return resp == null || resp.data == null ? WeatherApi.DEFAULT_BACKGROUND : resp.data; &#125; // 获取存储文件路径 Future&lt;String&gt; _getPath() async =&gt; '$&#123;(await getApplicationDocumentsDirectory()).path&#125;/weather.txt'; // 写入到文件 _writeIntoFile(String contents) async &#123; File file = File(await _getPath()); if (await file.exists()) file.deleteSync(); file.createSync(); file.writeAsString(contents); &#125; // 文件读取存储信息，如果不存在文件则返回空字符串 ''，不推荐返回 null Future&lt;String&gt; readWeatherFromFile() async &#123; File file = File(await _getPath()); return (await file.exists()) ? file.readAsString() : ''; &#125; @override void dispose() &#123; _weatherController?.close(); _backgroundController?.close(); &#125;&#125; 天气详情的刷新只有当个页面，所以 BLoC 的注册值需要在路由上注册即可，在 fluro 对应 handler 中加入注册 Handler weatherHandler = Handler(handlerFunc: (_, params) &#123; String cityId = params['city_id']?.first; // 这个 id 可以通过 BLoC 获取也可以 return BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());&#125;); 那么接下来就可以编写界面了，先实现最外层的背景图变化 /// 查看 `weather_page.dart` 文件class WeatherPage extends StatelessWidget &#123; final String city; WeatherPage(&#123;Key key, this.city&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;WeatherBloc&gt;(context); // 请求背景并更新 _bloc.requestBackground().then((b) =&gt; _bloc.updateBackground(b)); // 先读取本地文件缓存进行页面填充 _bloc.readWeatherFromFile().then((s) &#123; if (s.isNotEmpty) &#123; _bloc.updateWeather(WeatherModel.fromMap(json.decode(s))); &#125; &#125;); // 再请求网络更新数据 _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w)); return Scaffold( body: StreamBuilder( stream: _bloc.backgroundStream, initialData: _bloc.background, builder: (_, AsyncSnapshot&lt;String&gt; themeSnapshot) =&gt; Container( padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 20.0), alignment: Alignment.center, decoration: BoxDecoration( color: Colors.black12, image: DecorationImage( image: NetworkImage(themeSnapshot.data), fit: BoxFit.cover), ), child: // 具体内部布局通过拆分小部件实现 )), ); &#125;&#125; 页面最顶部是显示两个按钮，一个跳转城市选择，一个跳转设置页面，显示当前的城市 class FollowedHeader extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; // snapshot 通过上层传入 FollowedHeader(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ // 城市选择页面跳转按钮 IconButton( icon: Icon(Icons.home, color: Colors.white, size: 32.0), onPressed: () =&gt; Application.router. navigateTo(context, Routers.provinces, transition: TransitionType.inFromLeft)), // 当前城市 Text('$&#123;snapshot.data.heWeather[0].basic.location&#125;', style: TextStyle(fontSize: 28.0, color: Colors.white)), // 设置页面跳转按钮 IconButton( icon: Icon(Icons.settings, color: Colors.white, size: 32.0), onPressed: () =&gt; Application.router .navigateTo(context, Routers.settings, transition: TransitionType.inFromRight)) ], ); &#125;&#125; 接着是当前的天气详情部分 class CurrentWeatherState extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; CurrentWeatherState(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _now = snapshot.data.heWeather[0].now; var _update = snapshot.data.heWeather[0].update.loc.split(' ').last; return Column( crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ // 当前的温度 Text('$&#123;_now.tmp&#125;℃', style: TextStyle(fontSize: 50.0, color: Colors.white)), // 当前的天气状况 Text('$&#123;_now.condTxt&#125;', style: TextStyle(fontSize: 24.0, color: Colors.white)), Row( // 刷新的时间 mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ Icon(Icons.refresh, size: 16.0, color: Colors.white), Padding(padding: const EdgeInsets.only(left: 4.0)), Text(_update, style: TextStyle(fontSize: 12.0, color: Colors.white)) ], ) ], ); &#125;&#125; 接下来是一个天气预报的列表块，以为是一个列表，当然可以通过 Cloumn 来实现，但是前面有提到过一个列表「粘合剂」—- CustomScrollView，所以这里的整体连接最后会通过 CustomScrollView 来实现，那么你可以放心在最上层容器的 child 属性加上 CustomScrollView 了。接着来实现这块预报模块 class WeatherForecast extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; WeatherForecast(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _forecastList = snapshot.data.heWeather[0].dailyForecasts; // 获取天气预报 return SliverFixedExtentList( delegate: SliverChildBuilderDelegate( (_, index) =&gt; Container( color: Colors.black54, // 外层设置背景色，防止被最外层图片背景遮挡文字 padding: const EdgeInsets.all(12.0), alignment: Alignment.centerLeft, child: index == 0 // 当第一个 item 情况，显示 ‘预报’ ? Text('预报', style: TextStyle(fontSize: 24.0, color: Colors.white)) : Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Text(_forecastList[index - 1].date, // 预报的日期 style: TextStyle(fontSize: 16.0, color: Colors.white)), Expanded( // 天气情况，这边通过 expanded 进行占位，并居中显示 child: Center(child: Text(_forecastList[index - 1].cond.txtD, style: TextStyle(fontSize: 16.0, color: Colors.white))), flex: 2), Expanded( child: Row( // 最高温度，最低温度 mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Text(_forecastList[index - 1].tmp.max, style: TextStyle(fontSize: 16.0, color: Colors.white)), Text(_forecastList[index - 1].tmp.min, style: TextStyle(fontSize: 16.0, color: Colors.white)), ], ), flex: 1) ], )), childCount: _forecastList.length + 1, // 这个数量需要 +1，因为有个标题需要一个数量 ), itemExtent: 50.0); &#125;&#125; 接着是空气质量报告，一个标题，下面由两个布局进行平分 class AirQuality extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; AirQuality(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var quality = snapshot.data.heWeather[0].aqi.city; return Container( padding: const EdgeInsets.all(12.0), color: Colors.black54, alignment: Alignment.centerLeft, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 标题 Padding(padding: const EdgeInsets.only(bottom: 20.0), child: Text('空气质量', style: TextStyle(fontSize: 24.0, color: Colors.white))), Row( children: &lt;Widget&gt;[ // 通过 expanded 进行平分横向距离 Expanded( child: Center( // 内部居中显示 child: Column( children: &lt;Widget&gt;[ Text('$&#123;quality.aqi&#125;', style: TextStyle(fontSize: 40.0, color: Colors.white)), Text('AQI 指数', style: TextStyle(fontSize: 20.0, color: Colors.white)), ], ), )), Expanded( child: Center( child: Column( children: &lt;Widget&gt;[ Text('$&#123;quality.pm25&#125;', style: TextStyle(fontSize: 40.0, color: Colors.white)), Text('PM2.5 指数', style: TextStyle(fontSize: 20.0, color: Colors.white)), ], ), )), ], ) ], )); &#125;&#125; 接下来是生活质量模块，看着也是个列表，但是后台返回的不是列表，而是根据不同字段获取不同质量指数，因为布局类似，所以可以对其进行封装再整体调用 class LifeSuggestions extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; LifeSuggestions(&#123;Key key, this.snapshot&#125;) : super(key: key); // 生活指数封装 Widget _suggestionWidget(String content) =&gt; Padding(padding: const EdgeInsets.only(top: 20.0), child: Text(content, style: TextStyle(color: Colors.white, fontSize: 16.0))); @override Widget build(BuildContext context) &#123; var _suggestion = snapshot.data.heWeather[0].suggestion; return Container( padding: const EdgeInsets.all(12.0), color: Colors.black54, alignment: Alignment.centerLeft, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('生活建议', style: TextStyle(fontSize: 24.0, color: Colors.white)), _suggestionWidget('舒适度：$&#123;_suggestion.comf.brf&#125;\n$&#123;_suggestion.comf.txt&#125;'), _suggestionWidget('洗车指数：$&#123;_suggestion.cw.brf&#125;\n$&#123;_suggestion.cw.txt&#125;'), _suggestionWidget('运动指数： $&#123;_suggestion.sport.brf&#125;\n$&#123;_suggestion.sport.txt&#125;'), ], ), ); &#125;&#125; 所有的分模块都已经编写完成，剩下就是通过粘合剂进行组装了 child: StreamBuilder( initialData: _bloc.weather, stream: _bloc.weatherStream, builder: (_, AsyncSnapshot&lt;WeatherModel&gt; snapshot) =&gt; !snapshot.hasData ? CupertinoActivityIndicator(radius: 12.0) : SafeArea( child: RefreshIndicator( child: CustomScrollView( physics: BouncingScrollPhysics(), slivers: &lt;Widget&gt;[ SliverToBoxAdapter(child: FollowedHeader(snapshot: snapshot)), // 实时天气 SliverPadding( padding: const EdgeInsets.symmetric(vertical: 30.0), sliver: SliverToBoxAdapter( child: CurrentWeatherState(snapshot: snapshot, city: city), ), ), // 天气预报 WeatherForecast(snapshot: snapshot), // 空气质量 SliverPadding( padding: const EdgeInsets.symmetric(vertical: 30.0), sliver: SliverToBoxAdapter(child: AirQuality(snapshot: snapshot)), ), // 生活建议 SliverToBoxAdapter(child: LifeSuggestions(snapshot: snapshot)) ], ), onRefresh: () async &#123; _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w)); return null; &#125;), )), 最后就剩下设置页的全局主题切换了 设置页全局主题切换既然提到了数据的切换，那肯定就涉及 BLoC 毫无疑问了，还是照常编写管理类 /// 查看 `setting_bloc.dart` 文件class SettingBloc extends BaseBloc &#123; /// 所有主题色列表 static const themeColors = [Colors.blue, Colors.red, Colors.green, Colors.deepOrange, Colors.pink, Colors.purple]; Color _color = themeColors[0]; Color get color =&gt; _color; BehaviorSubject&lt;Color&gt; _colorController = BehaviorSubject(); Observable&lt;Color&gt; get colorStream =&gt; Observable(_colorController.stream); /// 切换主题通知刷新 switchTheme(int themeIndex) &#123; _color = themeColors[themeIndex]; _colorController.add(_color); &#125; @override void dispose() &#123; _colorController?.close(); &#125;&#125; 因为是全局的切换，那么这个 BLoC 肯定需要在最顶层进行注册，这边就不贴代码了，同 ProvinceBloc 一致。接着编写界面，设置界面因为有 GridView 和其他部件，所以也需要用 CustomScrollView 作为粘合剂，当然，你也可以用 Wrap 代替 GridView 来实现网格，就不需要用 CustomScrollView，使用 Column 即可。 class SettingsPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;SettingBloc&gt;(context); return StreamBuilder( stream: _bloc.colorStream, initialData: _bloc.color, // Theme 是 Flutter 自带的一个设置主题的部件，里面可以设置多种颜色， // 通过接收到 color 的变化，改变主题色，其他页面也如此设置，小伙伴可以自己添加 builder: (_, AsyncSnapshot&lt;Color&gt; snapshot) =&gt; Theme( // IconThemeData 用于设置按钮的主题色 data: ThemeData(primarySwatch: snapshot.data, iconTheme: IconThemeData(color: snapshot.data)), child: Scaffold( appBar: AppBar( title: Text('设置'), ), body: Container( color: Colors.black12, padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 20.0), child: CustomScrollView( slivers: &lt;Widget&gt;[ SliverPadding( padding: const EdgeInsets.only(right: 12.0), sliver: SliverToBoxAdapter( child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Text('当前主题色：', style: TextStyle(fontSize: 16.0, color: snapshot.data)), Container(width: 20.0, height: 20.0, color: snapshot.data) ], )), ), SliverPadding(padding: const EdgeInsets.symmetric(vertical: 15.0)), SliverGrid( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Container(color: SettingBloc.themeColors[index]), onTap: () &#123; // 选择后进行保存，当下次进入的时候直接使用该主题色 // 同时切换主题色 _bloc.switchTheme(index); PreferenceUtils.instance.saveInteger(PreferencesKey.THEME_COLOR_INDEX, index); &#125;, ), childCount: SettingBloc.themeColors.length), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3, mainAxisSpacing: 20.0, crossAxisSpacing: 20.0)), ], ), ), ), )); &#125;&#125; 最终全局的主题切换也实现了。 编写完代码，需要打包啊，Android 下的打包大家肯定没问题，这里讲下 flutter 下如何打包 apk，ipa 因为没有 mac 所以你们懂的。 apk 文件打包 创建 jks 文件，如果已经存在可忽略这步从第二步开始。打开终端并输入 keytool -genkey -v -keystore [你的签名文件路径].jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 然后输入密码以及一些基本信息就可以创建成功了 在项目的 android 目录下创建一个 key.properties 文件，里面进行如下配置 storePassword=&lt;password from previous step&gt;keyPassword=&lt;password from previous step&gt;keyAlias=keystoreFile=&lt;[你的签名文件路径].jks&gt; 在 android/app 下的 build.gradle 中进行如下修改 apply from: "$flutterRoot/packages/flutter_tools/gradle/flutter.gradle" // 增加如下部分代码def keystorePropertiesFile = rootProject.file("key.properties")def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile))android &#123; // ... defaultConfigs&#123; // ... &#125; // 增加如下代码 signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125; &#125; buildTypes&#123; // ... &#125;&#125; 再次打开终端运行 flutter build apk 会自动生成一个 apk 文件，文件路径为 [你的项目地址]\build\app\outputs\apk\release 通过 flutter install 就可以将正式包运行到手机上]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十三)之网络]]></title>
    <url>%2Fposts%2Fd9e32c9b.html</url>
    <content type="text"><![CDATA[前面讲完了常用的部件，BLoC 模式，数据持久化等常用的，今天再介绍个重头戏 —— 网络请求 HttpClientHttpClient 是 dart 自带的网络请求方式，在 dart:io 包下。使用 HttpClient 作为请求分以下几个步骤 创建 HttpClient 实例 HttpClient client = HttpClient(); 打开连接，并设置一些头参数，请求参数等 // 如果 url 中没有查询参数可直接创建Uri uri = Uri.parse('https://www.xxx.com');// 如果存在查询参数则在 Uri 中添加Uri uri = Uri(scheme: 'https', host: 'www.xxx.com', queryParameters: &#123;'a': 'AAA'&#125;);// 打开连接HttpClientRequest request = await client.getUrl(uri);request.headers.add('token', 'Bear $&#123;'x' * 20&#125;'); // 添加头部 token 信息// 如果是 post 或者 put 请求，通过 `add` 添加请求体// 因为 `add` 方法需要传入 `List&lt;int&gt;` 参数，可以通过 utf8.encode 进行编码request.add(utf8.encode('&#123;"a": "aaa"&#125;'));// 也可以通过添加流的方式进行添加request.addStream(input); 连接服务器 // 设置 request 后通过 request.close() 获取一个响应对象 HttpClientResponse，// 包括响应头，响应内容等HttpClientResponse response = await request.close(); 读取服务器响应内容 String responseBody = await response.transform(utf8.decoder).join(); 关闭实例 client.close(); 例如我们要去请求 Bird.so 的首页并显示，我们可以这么实现 _httpClientRequest() async &#123; HttpClient client; // try catch finally 用于捕获请求过程中发生的异常，在 finally 中设置保证 client 能够关闭 try &#123; client = HttpClient(); HttpClientRequest request = await client.getUrl(Uri.parse(_BIRD_SO_URL)); HttpClientResponse response = await request.close(); String strResponse = await response.transform(utf8.decoder).join(); setState(() =&gt; _netBack = strResponse); &#125; catch (e) &#123; print('$&#123;e.toString()&#125;'); setState(() =&gt; _netBack = 'Fail'); &#125; finally &#123; client.close(); &#125; &#125; 最后实现的效果 很显然，用 HttpClient 请求相对来说是个非常麻烦的过程，如果要涉及到文本上传之类的，那么就会更麻烦了，所以这边引入一个网络请求的插件 dio，写本文的时候版本为 2.1.0 Diodio 是个非常强大的网络请求库，他的方式类似 OkHttp，我们可以直接查看官方文档，使用方式非常简单，创建一个 Dio 实例，然后就可以通过 get，post 等方式发起请求，返回 Future&lt;Response&gt;，而且支持多个并发请求，可以设置返回响应的类型，监听上传下载进度等等，看着就很给力。对于简单的方式，这边就不做太多介绍，主要讲下拦截器，也是非常给力的一部分。比如我们需要请求这么个接口 https://randomuser.me/api/ 这个接口通过 get 请求，可以加入任意的查询参数。比如我们需要实现一个请求加解密的过程，如果每次都在上传参数或者返回请求的时候去加密，解密的话，就做了非常多无用功了，那么这时候拦截器就派上用场了。先定义下加解密的规则，上传的参数统一转为小写，不存在大写，请求回的数据，不能含有 info 字段。看下如何实现 _dioRequest() async &#123; BaseOptions options = BaseOptions(connectTimeout: 5000, receiveTimeout: 60000); Dio dio = Dio(options); dio.interceptors.add(InterceptorsWrapper(onRequest: (opt) &#123; // 获取查询的参数 Map params = opt.queryParameters; // 将所有的参数转为小写，因为查询参数通过 map 形式上传 params.forEach((key, value) =&gt; opt.queryParameters[key] = '$value'.toLowerCase()); // 这边还可以做些别的操作，例如需要 token 进行用户身份验证，则通过头部进行添加 // opt.headers['authorization'] = 'token'; // 在官网中，提供了 lock 和 unlock 的写法，被 lock 后，接下来的请求会进入队列等待， // 直到 unlock 后才能继续，可以用于几个请求，后续的需要用到前面的返回值的情况使用 // 返回修改后的 RequestOptions return opt; &#125;, onResponse: (resp) &#123; // 返回响应体后，将 info 字段的内容切除，并将 json 拼接完成 resp.data = '$&#123;'$&#123;resp.data&#125;'.split(', info').first&#125;&#125;'; return resp; &#125;, onError: (error) &#123; // 发生错误时的回调 return error; &#125;)); // 发送一个请求，可以查看下打印的结果 Response response = await dio.get(_USER_ME_URL, queryParameters: &#123;'a': 'AAA', 'b': 'BbBbBb'&#125;); print(response.data); print(response.request.headers); print(response.request.queryParameters); setState(() =&gt; _netBack = response.data.toString()); // 界面显示 response.data &#125; 看下最后的显示信息 请求体的头部成功加上了 authorization 参数，请求的参数全部变为小写，返回的信息也把 info 字段值去除。在很多时候，请求接口后，需要将 json 转换成 pojo 类来处理，可以通过 json_serializable 这个三方插件实现，这边提供文章 Flutter Json自动反序列化，当然这种方式比较麻烦，这里推荐个 Android Studio 下的插件 dart_json_format 直接搜索就可以，如果用的是 Vitual Code 或者别的不是 JetBrains 系列的，这里有个转换的网址 JsonToDart。 以上代码查看 http_main.dart 文件 实践一下下不知道小伙还记得前面讲的 BLoC 没有，忘了可以查看 Flutter 状态管理及 BLoC，这里结合 BLoC 和 Dio 实现界面和逻辑分离的小例子，接口使用前面提到的 https://randomuser.me/api/ 接口。网络应该是比较常用的，所以对其进行一些封装还是很有必要的，这边提供下我自己封装的方法 import 'package:dio/dio.dart';// 用于错误信息回调typedef ErrorCallback = void Function(String msg);class HttpUtils &#123; static const GET = 'get'; static const POST = 'post'; static Dio _dio; static HttpUtils _instance; Dio get hp =&gt; _dio; // dio 可以在 BaseOptions 中指定域名 baseUrl， // 后续接口就不需要再添加域名了 // 如果请求的接口域名发生了变化，只要把全部 url 写全，就会自动使用新的域名 HttpUtils._internal(String base) &#123; // 生成一个单例，防止多次打开关闭造成开销 _dio = Dio(BaseOptions(baseUrl: base, connectTimeout: 10000, receiveTimeout: 10000)); &#125; factory HttpUtils(String base) &#123; if (_instance == null) _instance = HttpUtils._internal(base); return _instance; &#125; // 添加拦截器 addInterceptor(List&lt;InterceptorsWrapper&gt; interceptors) &#123; _dio.interceptors.clear(); _dio.interceptors.addAll(interceptors); &#125; Future&lt;Response&lt;T&gt;&gt; getRequest&lt;T&gt;(url, &#123;Map params, ErrorCallback callback&#125;) =&gt; _request(url, GET, params: params, callback: callback); Future&lt;Response&lt;T&gt;&gt; postRequest&lt;T&gt;(url, &#123;Map params, ErrorCallback callback&#125;) =&gt; _request(url, POST, params: params, callback: callback); Future&lt;Response&gt; download(url, path, &#123;ProgressCallback receive, CancelToken token&#125;) =&gt; _dio.download(url, path, onReceiveProgress: receive, cancelToken: token); // T 可以指定返回的类型，String 或者 Map&lt;String, dynamic&gt; Future&lt;Response&lt;T&gt;&gt; _request&lt;T&gt;( url, String method, &#123; Map params, // 上传的参数 Options opt, ErrorCallback callback, // 错误回调 ProgressCallback send, // 上传进度监听 ProgressCallback receive, // 下载监听 CancelToken token, // 用于取消的 token，可以多个请求绑定一个 token &#125;) async &#123; try &#123; Response&lt;T&gt; rep; if (method == GET) &#123; // 如果不是重新创建 Dio 实例，get 方法使用 queryParams 会出错，不懂原因，使用拼接没有问题 if (params != null &amp;&amp; params.isNotEmpty) &#123; var sb = StringBuffer('?'); params.forEach((key, value) &#123; sb.write('$key=$value&amp;'); &#125;); // get 请求下拼接路径 url += sb.toString().substring(0, sb.length - 1); &#125; rep = await _dio.get(url, options: opt, onReceiveProgress: receive, cancelToken: token); &#125; else if (method == POST) &#123; // post 参数放请求体 rep = params == null ? await _dio.post(url, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive) : await _dio.post(url, data: params, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive); &#125; // 如果 statusCode 不是 200 则错误回调，返回空的 Response if (rep.statusCode != 200 &amp;&amp; callback != null) &#123; callback('network error, and code is $&#123;rep.statusCode&#125;'); return null; &#125; return rep; &#125; catch (e) &#123; if (callback != null) &#123; callback('network error, catch error: $&#123;e.toString()&#125;'); &#125; return null; &#125; &#125;&#125; 封装后就可以愉快的调用了，如果有别的请求方式后期可以继续扩展。继续看代码，创建一个 application.dart 文件，用于存放全局参数 class Application &#123; static HttpUtils http;&#125; 并在 main() 方法中进行初始化，接下来就可以直接使用 void main() &#123; Application.http = HttpUtils('https://randomuser.me'); runApp(DemoApp()); // 透明状态栏 if (Platform.isAndroid) &#123; SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent)); &#125;&#125; 看下最后的实现效果吧，刚进入没有数据则通过转圈圈提示，加载完数据后，点击头像更换下个 实现 BLoC 需要有一个管理类 class UserBloc extends BaseBloc &#123; RandomUserModel _user; RandomUserModel get user =&gt; _user; BehaviorSubject&lt;RandomUserModel&gt; _controller = BehaviorSubject(); Observable&lt;RandomUserModel&gt; get stream =&gt; Observable(_controller.stream); // 网络请求获取新的数据，并更新 updateUserInfo() &#123; Application.http.getRequest('/api').then((response) &#123; // RandomUserModel 就是接口返回的 json 转成的 model 类 RandomUserModel model = RandomUserModel.fromMap(response.data); _user = model; // add 到 controller 通知修改 _controller.add(model); &#125;); &#125; @override void dispose() &#123; _controller?.close(); // 及时销毁 &#125;&#125; 设置好管理类后，就可以来编写界面了，界面也比较简单 class UserPageDemo extends StatelessWidget &#123; // 将首字母大写 String _upperFirst(String content) &#123; assert(content != null &amp;&amp; content.isNotEmpty); return '$&#123;content.substring(0, 1).toUpperCase()&#125;$&#123;content.substring(1)&#125;'; &#125; // 地址信息通用部件 Widget _userLocation(String info) =&gt; Padding( padding: const EdgeInsets.only(top: 4.0), child: Text(info, style: TextStyle(color: Colors.white, fontSize: 16.0))); @override Widget build(BuildContext context) &#123; UserBloc _bloc = BlocProvider.of&lt;UserBloc&gt;(context); _bloc.updateUserInfo(); return Scaffold( // StreamBuilder 接受更新数据的 stream body: StreamBuilder( builder: (_, AsyncSnapshot&lt;RandomUserModel&gt; snapshot) =&gt; Container( alignment: Alignment.center, decoration: BoxDecoration( gradient: LinearGradient( begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [Colors.blue[600], Colors.blue[400]])), child: !snapshot.hasData ? CupertinoActivityIndicator(radius: 12.0) : Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ InkWell( // 用于切换数据 child: ClipOval( // 圆形头像 child: FadeInImage.assetNetwork( placeholder: 'images/ava_default.png', image: snapshot.data.results[0].picture.large), ), onTap: () =&gt; _bloc.updateUserInfo()), // 更新数据 Padding( padding: const EdgeInsets.only(top: 20.0), child: Text( '$&#123;_upperFirst(snapshot.data.results[0].name.first)&#125; $&#123;_upperFirst(snapshot.data.results[0].name.last)&#125;', style: TextStyle(color: Colors.white, fontSize: 24.0)), ), Text('$&#123;snapshot.data.results[0].email&#125;', style: TextStyle(color: Colors.white, fontSize: 18.0)), _userLocation('$&#123;snapshot.data.results[0].location.street&#125;'), _userLocation('$&#123;_upperFirst(snapshot.data.results[0].location.city)&#125;'), _userLocation('$&#123;_upperFirst(snapshot.data.results[0].location.state)&#125;'), ]), ), initialData: _bloc.user, // 注入初始值 stream: _bloc.stream), // 注入更新 stream ); &#125;&#125; 以上代码查看 bloc_network 包下的所有文件]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十二)之数据持久化]]></title>
    <url>%2Fposts%2F6358b348.html</url>
    <content type="text"><![CDATA[上节讲了状态管理，但是当 App 重启后，数据就都丢失了，这样就比较尴尬了，什么都要重来，所以这节我们来讲下数据持久化。数据持久化主要有如下方式 文件读写 shared_preferences 存储 数据库存储 持久化的实现都需要通过三方插件来实现，接着会慢慢介绍三种实现方式 文件读写/ IO 操作文件读写需要 path_provider 插件，写这篇文章的时候，最新版本是 0.5.0+1，小伙伴们可以根据官网最新的版本进行替换，导入后我们就可以来看下如何实现文件的读写了。path_provider 的源码比较简单，这边就不单独拎出来说了，可以自行查看。path_provider 用于获取手机的存储文件位置，一共有三个方法 getTemporaryDirectory 临时目录，在 Android 中对应的方法为 getCacheDir，而在 iOS 中对应为 NSCachesDirectory，可以通过系统检测并清除 getApplicationDocumentsDirectory 缓存目录，在 Android 中对应为 AppData 文件夹，在 iOS 中对应为 NSDocumentsDirectory，只有当 App 被删除才能被删除 getExternalStorageDirectory 外部存储目录，只有在 Android 中有效，在 iOS 调用会抛出 UnsupportedError 异常，不过 Android 在写入前记得先申请权限哟，否则也是不行滴。 读写文件操作需要通过 Dart 的 IO 操作完成，这边小伙伴们可以自己看文档 File class，接着我们就直接通过例子来看文件实现数据持久化。先看下效果吧，最终重启 App 后，数据也能正常读取显示，说明数据被保存下来了 看下实现的代码，因为会涉及到多种方式，所以这边我把视图抽取出来实现 Widget _fileIoPart() &#123; return Card( margin: const EdgeInsets.all(8.0), shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(8.0))), child: Column(children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(12.0), child: Text('File IO', style: TextStyle(fontSize: 20.0, color: Theme.of(context).primaryColor)), ), // RadioList 是单选按钮部件，通过选择不同的情况，创建不同目录的文件 RadioListTile( value: _radioText[0], title: Text(_radioText[0]), subtitle: Text(_radioDescriptions[0]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), RadioListTile( value: _radioText[1], title: Text(_radioText[1]), subtitle: Text(_radioDescriptions[1]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), RadioListTile( value: _radioText[2], title: Text(_radioText[2]), subtitle: Text(_radioDescriptions[2]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), Padding( padding: const EdgeInsets.all(12.0), // 用于写入文本信息 child: TextField( controller: _editController, decoration: InputDecoration(labelText: '输入存储的文本内容', icon: Icon(Icons.text_fields)), ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _writeTextIntoFile, child: Text('写入文件信息'), ), ), Padding( padding: const EdgeInsets.all(12.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Text('文件内容：'), Expanded(child: Text(_fileContent, softWrap: true))], ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _readTextFromFile, child: Text('读取文件信息'), ), ), ]), ); &#125; 关键的部分在于 _writeTextIntoFile 和 _readTextFromFile 两个方法的实现。看下实现的代码 // 如果写入外部内存需要读写权限，这边使用了第三方插件 `permission_handler` void _writeTextIntoFile() async &#123; if (_currentValue == _radioText[2]) &#123; PermissionStatus status = await PermissionHandler().checkPermissionStatus(PermissionGroup.storage); if (status == PermissionStatus.granted) // 如果是写入外部存储，则检测权限状态，同意则写入 _writeContent(); else if (status == PermissionStatus.disabled) // 拒绝了提示手动打开 Fluttertoast.showToast(msg: '未打开相关权限'); else // 未同意则主动申请权限 PermissionHandler().requestPermissions([PermissionGroup.storage]); &#125; else // 不是写入外部存储直接写入文件 _writeContent(); &#125;// 文本写入文件 void _writeContent() async &#123; // 写入文本操作 var text = _editController.value.text; // 获取文本框的内容 File file = File(await _getFilePath()); // 获取相应的文件 if (text == null || text.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入内容'); // 内容为空，则不写入并提醒 &#125; else &#123; // 内容不空，则判断是否已经存在，存在先删除，重新创建后写入信息 if (await file.exists()) file.deleteSync(); file.createSync(); // createSync 是一个同步的创建过程 file.writeAsStringSync(text); // writeAsStringSync 是同步写入的过程 _editController.clear(); // 写入文件后清空输入框信息 &#125; &#125; // 读取文本操作 void _readTextFromFile() async &#123; File file = File(await _getFilePath()); if (await file.exists()) &#123; setState(() =&gt; _fileContent = file.readAsStringSync()); // 文件存在则直接显示文本信息 &#125; else &#123; setState(() =&gt; _fileContent = ''); // 文件不存在则清空显示文本信息，并提示 Fluttertoast.showToast(msg: '文件还未创建，请先通过写入信息来创建文件'); &#125; &#125; 因为外部存储的文件需要涉及到权限问题，而且 iOS 也不支持，所以如果需要使用文件来持久化数据的话，尽量使用另外两种。因为在例子中，我们保存的数据相对比较简单，所以这边就不得不说另外一种更方便的持久化方式了 shared_preferences SharedPreferences写 Android 的小伙伴对这个应该不陌生了，但是 Flutter 并没有自带的 shared_preferences 功能，需要第三方插件来实现，引入 shared_preferences 插件，写文章的时候最新版本是 ^0.5.1+2，还是先看下最后的效果 代码的实现相对比较简单 Widget _sharedPart() &#123; return Card( margin: const EdgeInsets.all(8.0), shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(8.0))), child: Column( children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(12.0), child: Text('Shared Preferences', style: TextStyle(fontSize: 20.0, color: Theme.of(context).primaryColor)), ), Padding( padding: const EdgeInsets.fromLTRB(12.0, 0, 12.0, 12.0), // 用于设置 key 信息 child: TextField( controller: _shareKeyController, decoration: InputDecoration(labelText: '输入 share 存储的 key', icon: Icon(Icons.lock_outline)), ), ), Padding( padding: const EdgeInsets.fromLTRB(12.0, 0, 12.0, 12.0), // 用于写入文本信息 child: TextField( controller: _shareValueController, decoration: InputDecoration(labelText: '输入 share 存储的 value', icon: Icon(Icons.text_fields)), ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _writeIntoShare, child: Text('写入 share'), ), ), Padding( padding: const EdgeInsets.all(12.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Text('share 存储内容：'), Expanded(child: Text(_shareContent, softWrap: true))], ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _readFromShare, child: Text('读取 share'), ), ), ], )); &#125; 实现的关键部分就是方法 _writeIntoShare 和 _readFromShare void _writeIntoShare() async &#123; var shareKey = _shareKeyController.value.text; var shareContent = _shareValueController.value.text; if (shareKey == null || shareKey.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入 key'); &#125; else if (shareContent == null || shareContent.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入保存的内容'); &#125; else &#123; // 通过 `getInstance` 获取 `shared_preferences` 单例 var sp = await SharedPreferences.getInstance(); // sp 能保存的数据类型包括 `int`, `String`, `bool`, `double`, `StringList` sp.setString(shareKey, shareContent); &#125; &#125; void _readFromShare() async &#123; var shareKey = _shareKeyController.value.text; if (shareKey == null || shareKey.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入 key'); &#125; else &#123; var sp = await SharedPreferences.getInstance(); // 数据读取的类型同写入类型，如果传入的 key 不存在则返回 null var value = sp.getString(shareKey); if (value == null) &#123; Fluttertoast.showToast(msg: '未找到该 key'); setState(() =&gt; _shareContent = ''); &#125; else &#123; setState(() =&gt; _shareContent = value); &#125; &#125; &#125; 这两种数据持久化的方式主要用于存储相对简单，关系不复杂的数据，如果涉及到大量的，且字段之间有关系的情况就需要通过数据库来实现了，Android 和 iOS 都自带 sqlite 数据库。 以上代码查看 data_persistence_main.dart 文件 SqfliteFlutter 实现数据库存储需要通过插件 sqflite 来实现，写文章的时候最新的版本是 sqflite 1.1.3，但是该版本需要 flutter 1.2 以上才行，所以我选择的是 sqflite 1.1.0，小伙伴可以根据自己的 flutter 版本选择相应的 sqflite 版本 sqflite 的基本操作语句，在文档中已经写得非常明白了，所以就不搬运了，这边直接讲下对于数据库的一些封装处理吧，因为打开数据库是一个很消耗资源的一个过程，所以呢，推荐实现单例会比较好。例如我们要实现一个 student 存储表 class DatabaseUtils &#123; final String _tableStudent = 'student'; static Database _database; // 创建单例，防止重复打开消耗内存 static DatabaseUtils _instance; static DatabaseUtils get instance =&gt; _instance; DatabaseUtils._internal() &#123; getDatabasesPath().then((path) async &#123; _database = await openDatabase(join(path, 'demo.db'), version: 2, onCreate: (db, version) &#123; // 创建数据库的时候在这边调用 db.execute('create table $_tableStudent ' 'id integer primary key autoincrement,' 'name text not null,' 'age integer not null default 0,' 'gender integer not null default 0'); // 更新升级增加的字段 db.execute('alter table $_tableStudent add column birthday text'); &#125;, onUpgrade: (db, oldVersion, newVersion) &#123; // 更新升级数据库的时候在这操作 if (oldVersion == 1) db.execute('alter table $_tableStudent add column birthday text'); &#125;, onOpen: (db) &#123; // 打开数据库时候的回调 print('$&#123;db.path&#125;'); &#125;); &#125;); &#125; factory DatabaseUtils() &#123; // 如果当前的单例已经存在，则不再创建，否则重新创建，factory 关键词看第一章 if (_instance == null) _instance = DatabaseUtils._internal(); return _instance; &#125;&#125; 那么对数据库的操作就完全考验你的 SQL 的掌握程度了，但是千万记住，sqlite 中的类型只有，整型 integer ，字符类型 text，浮点类型 real，二进制 blob。数据库的具体例子会等到最后的实际项目中展示，原谅我不懂如何展示一个界面给你操作，实现数据库的各种功能。 该部分代码查看 db_util.dart 文件，里面有一些基本的操作写法，小伙伴可自行查看。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十一)之状态管理，BLoC]]></title>
    <url>%2Fposts%2Fd121323a.html</url>
    <content type="text"><![CDATA[Stream在 dart 部分记得分享过 Stream 的文章链接，但是我知道你们肯定没几个愿意看的，所以这里再提下。还是得从源码开始…因为源码的注释比较长，就不贴注释了，可以自己看，我这边就提取一些关键信息。 Stream 是 Dart 提供的一种数据流订阅管理的”工具”，感觉有点像 Android 中的 EventBus 或者 RxBus，Stream 可以接收任何对象，包括是另外一个 Stream，接收的对象通过 StreamController 的 sink 进行添加，然后通过 StreamController 发送给 Stream，通过 listen 进行监听，listen 会返回一个 StreamSubscription 对象，StreamSubscription 可以操作对数据流的监听，例如 pause，resume，cancel 等。 Stream 分两种类型： Single-subscription Stream：单订阅 stream，整个生命周期只允许有一个监听，如果该监听 cancel 了，也不能再添加另一个监听，而且只有当有监听了，才会发送数据，主要用于文件 IO 流的读取等。 Broadcast Stream：广播订阅 stream，允许有多个监听，当添加了监听后，如果流中有数据存在就可以监听到数据，这种类型，不管是否有监听，只要有数据就会发送，用于需要多个监听的情况。 还是看下例子会比较直观 class _StreamHomeState extends State&lt;StreamHome&gt; &#123; StreamController _controller = StreamController(); // 创建单订阅类型 `StreamController` Sink _sink; StreamSubscription _subscription; @override void initState() &#123; super.initState(); _sink = _controller.sink; // _sink 用于添加数据 // _controller.stream 会返回一个单订阅 stream， // 通过 listen 返回 StreamSubscription，用于操作流的监听操作 _subscription = _controller.stream.listen((data) =&gt; print('Listener: $data')); // 添加数据，stream 会通过 `listen` 方法打印 _sink.add('A'); _sink.add(11); _sink.add(11.16); _sink.add([1, 2, 3]); _sink.add(&#123;'a': 1, 'b': 2&#125;); &#125; @override void dispose() &#123; super.dispose(); // 最后要释放资源... _sink.close(); _controller.close(); _subscription.cancel(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: Container(), ); &#125;&#125; 看下控制台的输出： 果然把所有的数据都打印出来了，前面有说过，单订阅的 stream 只有当 listen 后才会发送数据，不试试我还是不相信的，我们把 _sink.add 放到 listen 前面去执行，再看控制台的打印结果。居然真的是一样的，Google 粑粑果然诚不欺我。接着试下 pause，resume 方法，看下数据如何监听，修改代码 _sink = _controller.sink;_subscription = _controller.stream.listen((data) =&gt; print('Listener: $data'));_sink.add('A');_subscription.pause(); // 暂停监听_sink.add(11);_sink.add(11.16);_subscription.resume(); // 恢复监听_sink.add([1, 2, 3]);_sink.add(&#123;'a': 1, 'b': 2&#125;); 再看控制台的打印，你们可以先猜下是什么结果，我猜大部分人都会觉得应该是不会有 11 和 11.16 打印出来了。然鹅事实并非这样，打印的结果并未发生变化，也就是说，调用 pause 方法后，stream 被堵住了，数据不继续发送了。 接下来看下广播订阅 stream，对代码做下修改 StreamController _controller = StreamController.broadcast(); Sink _sink; StreamSubscription _subscription; @override void initState() &#123; super.initState(); _sink = _controller.sink; _sink.add('A'); _subscription = _controller.stream.listen((data) =&gt; print('Listener: $data')); _sink.add(11); _subscription.pause(); _sink.add(11.16); _subscription.resume(); _sink.add([1, 2, 3]); _sink.add(&#123;'a': 1, 'b': 2&#125;); &#125;// ...&#125; 我们再看下控制台的打印： 你猜对答案了吗，这边做下小总结： 单订阅 Stream 只有当存在监听的时候，才发送数据，广播订阅 Stream 则不考虑这点，有数据就发送；当监听调用 pause 以后，不管哪种类型的 stream 都会停止发送数据，当 resume 之后，把前面存着的数据都发送出去。 sink 可以接受任何类型的数据，也可以通过泛型对传入的数据进行限制，比如我们对 StreamController 进行类型指定 StreamController&lt;int&gt; _controller = StreamController.broadcast(); 因为没有对 Sink 的类型进行限制，还是可以添加除了 int 外的类型参数，但是运行的时候就会报错，_controller 对你传入的参数做了类型判定，拒绝进入。 Stream 中还提供了很多 StremTransformer，用于对监听到的数据进行处理，比如我们发送 0~19 的 20 个数据，只接受大于 10 的前 5 个数据，那么可以对 stream 如下操作 _subscription = _controller.stream .where((value) =&gt; value &gt; 10) .take(5) .listen((data) =&gt; print('Listen: $data'));List.generate(20, (index) =&gt; _sink.add(index)); 那么打印出来的数据如下图 除了 where，take 还有很多 Transformer， 例如 map，skip 等等，小伙伴们可以自行研究。了解了 Stream 的基本属性后，就可以继续往下了~ StreamBuilder前面提到了 stream 通过 listen 进行监听数据的变化，Flutter 就为我们提供了这么个部件 StreamBuilder 专门用于监听 stream 的变化，然后自动刷新重建。接着来看下源码 const StreamBuilder(&#123; Key key, this.initialData, // 初始数据，不传入则为 null Stream&lt;T&gt; stream, @required this.builder &#125;) : assert(builder != null), super(key: key, stream: stream);@overrideAsyncSnapshot&lt;T&gt; initial() =&gt; AsyncSnapshot&lt;T&gt;.withData(ConnectionState.none, initialData); StreamBuilder 必须传入一个 AsyncWidgetBuilder 参数，初始值 initialData 可为空， stream 用于监听数据变化，initial 方法的调用在其父类 StremBuilderBase 中，接着看下 StreamBuilderBaseState 的源码，这里我删除一些不必要的源码，方便查看，完整的源码可自行查看 class _StreamBuilderBaseState&lt;T, S&gt; extends State&lt;StreamBuilderBase&lt;T, S&gt;&gt; &#123; // ... @override void initState() &#123; super.initState(); _summary = widget.initial(); // 通过传入的初始值生成默认值，如果没有传入则会是 null _subscribe(); // 注册传入的 stream，用于监听变化 &#125; // _summary 为监听到的数据 @override Widget build(BuildContext context) =&gt; widget.build(context, _summary); // ... void _subscribe() &#123; if (widget.stream != null) &#123; // stream 通过外部传入，对数据的变化进行监听， // 在不同回调中，通过 setState 进行更新 _summary // 当 _summary 更新后，由于调用了 setState，重新调用 build 方法，将最新的 _summary 传递出去 _subscription = widget.stream.listen((T data) &#123; setState(() &#123; _summary = widget.afterData(_summary, data); &#125;); &#125;, onError: (Object error) &#123; setState(() &#123; _summary = widget.afterError(_summary, error); &#125;); &#125;, onDone: () &#123; setState(() &#123; _summary = widget.afterDone(_summary); &#125;); &#125;); _summary = widget.afterConnected(_summary); // &#125; &#125;&#125; 在之前更新数据都需要通过 setState 进行更新，这里了解完了 stream，我们就不使用 setState 更新，使用 Stream 来更新 class _StreamHomeState extends State&lt;StreamHome&gt; &#123; // 定义一个全局的 `StreamController` StreamController&lt;int&gt; _controller = StreamController.broadcast(); // `sink` 用于传入新的数据 Sink&lt;int&gt; _sink; int _counter = 0; @override void initState() &#123; super.initState(); _sink = _controller.sink; &#125; @override void dispose() &#123; super.dispose(); // 需要销毁资源 _sink.close(); _controller.close(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, child: StreamBuilder( builder: (_, snapshot) =&gt; Text('$&#123;snapshot.data&#125;', style: TextStyle(fontSize: 24.0)), stream: _controller.stream, // stream 在 StreamBuilder 销毁的时候会自动销毁 initialData: _counter, ), )), // 通过 `sink` 传入新的数据，去通知 `stream` 更新到 builder 中 floatingActionButton: FloatingActionButton( onPressed: () =&gt; _sink.add(_counter++), child: Icon(Icons.add), ), ); &#125;&#125; 那么当点击按钮的时候，就会刷新界面上的值，通过上面的源码分析，StreamBuilder 也是通过 setState 方法进行刷新，那么两种方法孰优孰劣呢，当然是通过 Stream 啦，这不是废话吗。因为通过调用 setState 刷新的话，会把整个界面都进行重构，但是通过 StreamBuilder 的话，只刷新其 builder，这样效率就更高了，最后看小效果吧，所谓有图有真相嘛 这一步，我们摒弃了 setState 方法，那么下一步，我们试试把 StatefulWidget 替换成 StatelessWidget 吧，而且官方也推荐使用 StatelessWidget 替换 StatefulWidget，这里就需要提下 BLoC 模式了。 BLoC说实话，现在 Google 下 「flutter bloc」能搜到很多文章，基本上都是通过 InheritedWidget 来实现的，例如这篇Flutter | 状态管理探索篇——BLoC(三)，但是 InheritedWidget 没有提供 dispose 方法，那么就会存在 StreamController 不能及时销毁等问题，所以，参考了一篇国外的文章，Reactive Programming - Streams - BLoC 这里通过使用 StatefulWidget 来实现，当该部件销毁的时候，可以在其 dispose 方法中及时销毁 StreamController，这里我还是先当个搬运工，搬下大佬为我们实现好的基类 abstract class BaseBloc &#123; void dispose(); // 该方法用于及时销毁资源&#125;class BlocProvider&lt;T extends BaseBloc&gt; extends StatefulWidget &#123; final Widget child; // 这个 `widget` 在 stream 接收到通知的时候刷新 final T bloc; BlocProvider(&#123;Key key, @required this.child, @required this.bloc&#125;) : super(key: key); @override _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;(); // 该方法用于返回 Bloc 实例 static T of&lt;T extends BaseBloc&gt;(BuildContext context) &#123; final type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;(); // 获取当前 Bloc 的类型 // 通过类型获取相应的 Provider，再通过 Provider 获取 bloc 实例 BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type); return provider.bloc; &#125; static Type _typeOf&lt;T&gt;() =&gt; T;&#125;class _BlocProviderState&lt;T&gt; extends State&lt;BlocProvider&lt;BaseBloc&gt;&gt; &#123; @override void dispose() &#123; widget.bloc.dispose(); // 及时销毁资源 super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return widget.child; &#125;&#125; 接着我们对前面的例子使用 BLoC 进行修改。 首先，我们需要创建一个 Bloc 类，用于修改 count 的值 class CounterBloc extends BaseBloc &#123; int _count = 0; int get count =&gt; _count; // stream StreamController&lt;int&gt; _countController = StreamController.broadcast(); Stream&lt;int&gt; get countStream =&gt; _countController.stream; // 用于 StreamBuilder 的 stream void dispatch(int value) &#123; _count = value; _countController.sink.add(_count); // 用于通知修改值 &#125; @override void dispose() &#123; _countController.close(); // 注销资源 &#125;&#125; 在使用 Bloc 前，需要在最上层的容器中进行注册，也就是 MaterialApp 中 void main() =&gt; runApp(StreamApp());class StreamApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 这里对创建的 bloc 类进行注册，如果说有多个 bloc 类的话，可以通过 child 进行嵌套注册即可 // 放在最顶层，可以全局调用，当 App 关闭后，销毁所有的 Bloc 资源， // 也可以在路由跳转的时候进行注册，至于在哪里注册，完全看需求 // 例如实现主题色的切换，则需要在全局定义，当切换主题色的时候全局切换 // 又比如只有某个或者某几个特殊界面调用，那么完全可以通过在路由跳转的时候注册 return BlocProvider( child: MaterialApp( debugShowCheckedModeBanner: false, home: StreamHome(), ), bloc: CounterBloc()); &#125;&#125;class StreamHome extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 获取注册的 bloc，必须先注册，再去查找 final CounterBloc _bloc = BlocProvider.of&lt;CounterBloc&gt;(context); return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, child: StreamBuilder( initialData: _bloc.count, stream: _bloc.countStream, builder: (_, snapshot) =&gt; Text('$&#123;snapshot.data&#125;', style: TextStyle(fontSize: 20.0)), ), )), floatingActionButton: // 通过 bloc 中的 dispatch 方法进行值的修改，通知 stream 刷新界面 FloatingActionButton(onPressed: () =&gt; _bloc.dispatch(_bloc.count + 1), child: Icon(Icons.add)), ); &#125;&#125; 重新运行后，查看效果还是一样的。所以我们成功的对 StatefulWidget 进行了替换 再继续讲之前，先总结下 Bloc ​ 1. 成功的把页面和逻辑分离开了，页面只展示数据，逻辑通过 BLoC 进行处理 ​ 2. 减少了 setState 方法的使用，提高了性能 ​ 3. 实现了状态管理 RxDart因为上面的参考文章中提到了 RxDart，个人觉得有必要了解下，当然目前也有很多文章介绍 RxDart，所以我就讲下和 BLoC 有点关系的部分吧。RxDart 需要通过引入插件的方式引入(rxdart: ^0.21.0) 如果需要查看详细的内容，我这里提供几篇文章链接 RxDart 文档 RxDart: Magical transformations of Streams 其实 RxDart 就是对 Stream 的进一步分装，RxDart 提供了三种 Subject，其功能类似 Stream 中的单订阅 stream 和 广播 stream。 PublishSubject /// PublishSubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. 通过注释可以发现 PuslishSubject 不可被多次订阅，尽管实现是通过 StreamController&lt;T&gt;.broadcast 方式实现，其实三种都是通过 broadcast 方式实现的，所以实现的功能就是类似 Single-subscription Stream 的功能。 BehaviorSubject /// BehaviorSubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. BehaviorSubject 可以被多次订阅，那么这个就是实现了 Broadcast Stream 功能。 ReplaySubject /// ReplaySubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. ReplaySubject 其实也是实现 Broadcast Stream 功能，那么它和 BehaviorSubject 的区别在哪呢，别急，等我慢慢讲。 /// As items are added to the subject, the ReplaySubject will store them./// When the stream is listened to, those recorded items will be emitted to/// the listener. 当有数据添加了，但是还没有监听的时候，它会将数据存储下来，等到有监听了，再发送出去，也就是说，ReplaySubject 实现了 Brodacast Stream 的多订阅功能，同时也实现了 Single-subscription Stream 的存储数据的功能，每次添加了新的监听，都能够获取到全部的数据。当然，这还不是它的全部功能，它还可以设置最大的监听数量，会只监听最新的几个数据，在注释中，提供了这么两个例子，可以看下 /// ### Example ////// final subject = new ReplaySubject&lt;int&gt;();////// subject.add(1);/// subject.add(2);/// subject.add(3);////// subject.stream.listen(print); // prints 1, 2, 3/// subject.stream.listen(print); // prints 1, 2, 3/// subject.stream.listen(print); // prints 1, 2, 3////// ### Example with maxSize////// final subject = new ReplaySubject&lt;int&gt;(maxSize: 2); // 实现监听数量限制////// subject.add(1);/// subject.add(2);/// subject.add(3);////// subject.stream.listen(print); // prints 2, 3/// subject.stream.listen(print); // prints 2, 3/// subject.stream.listen(print); // prints 2, 3 那么我们可以使用 RxDart 对前面使用 Stream 实现的例子进行替换，最简单的其实只需要使用 BehaviorSubject 替换 StreamController.broadcast() 就可以了，别的都不需要变化。但是 RxDart 有自己的变量，还是按照 RxDart 的方式来 // 继承自 StreamController，所以 StreamController 拥有的属性都有BehaviorSubject&lt;int&gt; _countController = BehaviorSubject();// StreamController&lt;int&gt; _countController = StreamController.broadcast();// 继承自 Stream，所以这里直接用之前 stream 的写法也没问题，但是这样就有点不 RxDart 了Observable&lt;int&gt; get countStream =&gt; Observable(_countController.stream);// Stream&lt;int&gt; get countStream =&gt; _countController.stream;void dispatch(int value) &#123; _count = value; // 直接提供了 add 方法，不需要通过 sink 来添加 _countController.add(_count);// _countController.sink.add(_count);&#125; 再次运行还是能过实现相同的效果。如果说要在 RxDart 和 Stream 两种实现方式中选择一种，个人更偏向于 RxDart，因为它对 Stream 进行了进一步的封装，提供了更多更方便的数据转换方法，而且链式的写法真的很舒服，用过了就停不下来，具体的方法介绍可以参考上面提供的链接。 Provide说实话自己封装 BLoC 来实现分离逻辑和界面，相对还是有点难度的，这边可以通过第三方来实现，这边推荐 Google 粑粑的库，flutter_provide，看下官方对关键部件和静态方法的介绍 Provide&lt;T&gt; - Widget used to obtain values from a ProviderNode higher up in the widget tree and rebuild on change. The Provide&lt;T&gt;widget should only be used with Streams or Listenables. Equivalent to ScopedModelDescendant in ScopedModel Provide.value&lt;T&gt; - Static method used to get a value from a ProviderNode using the BuildContext. This will not rebuild on change. Similar to manually writing a static .of() method for an InheritedWidget. Provide.stream&lt;T&gt; - Static method used to get a Stream from a ProviderNode. Only works if either T is listenable, or if the Providercomes from a Stream. Provider&lt;T&gt; - A class that returns a typed value on demand. Stored in a ProviderNode to allow retrieval using Provide. ProviderNode - The equivalent of the ScopedModel widget. Contains Providers which can be found as an InheritedWidget. Provide 这个部件主要用于从上层的 ProvideNode 中获取值，当变化的时候刷新重建，只能同 Stream 和 Listenable 一同使用，类似于 ScopeMode 中的 ScopedModelDescendant。(这个部件放在需要状态管理的部件的上层，例如有个 Text 需要修改状态，那么就需要在外层提供一个 Provide 部件，通过内部 builder 参数返回 Text 部件) Provide.value 是个静态方法，用于从 ProvideNode 获取值，但是当接收的值改变的时候不会重建。类似于 InheritedWidget 的静态方法 of。(这个方法用于获取指定类型的 provide，每个 provide 都需要提供一个数据类，该类 with ChangeNotifier，当数据变化的时候通过 notifyListeners 通知 provide 变化，进行刷新重建) Provide.stream 是个静态方法，用于从 ProvideNode 获取一个 stream，仅在 T 可被监听，或者 Provide 来自 stream 的情况下有效。(这个通常结合 StreamBuilder 使用，StreamBuilder 在上面已经提到，就不多说了) Provider 按需要的类型返回相关值的类，存储在 ProviderNode 中方便 Provide 进行检索。(这个类主要是将我们自己创建的数据类通过 function 等方法转换成 Provider，并在 Providers 中进行注册) ProvideNode 类似于 ScopedModel 的一个部件，包含所有能被查找的 Providers。(这个需要放在顶层，方便下面的容器进行查找 provider，刷新相应的部件，一般放在 MaterialApp 上层) 这边再补充一个个人觉得关键的类 Providers，这个类主要用于存储定义的 Provider，主要是在建立 MaterialApp 的时候将需要用到的 Provider 通过 provide 方法添加进去存储起来，然后在 ProvideNode 中注册所有的 provider 方便下层容器获取值，并调用。 说那么多，还不如直接看个例子直接，代码来了~，首先需要建立一个类似 BLoC 中监听数据变化的 counter_bloc 类的数据管理类，我们这边定义为 count_provider 需要混入 ChangeNotifier 类 class CountProvider with ChangeNotifier &#123; int _value = 0; // 存储的数据，也是我们需要管理的状态值 int get value =&gt; _value; // 获取状态值 void changeValue(int value) &#123; _value = value; notifyListeners(); // 当状态值发生变化的时候，通过该方法刷新重建部件 &#125;&#125; 然后需要将定义的类注册到全局的 Providers 中 void main() &#123; final providers = Providers() // 将我们创建的数据管理类，通过 Provider.function 方法转换成 Provider， // 然后添加到 Providers 中 ..provide(Provider.function((_) =&gt; CountProvider())); // 在 App 上层，通过包裹一层 ProvideNode，并将我们生成的 Providers 实例 // 注册到 ProvideNode 中去，这样整个 App 都可以通过 Provide.value 查找相关的 Provider // 找到 Provider 后就可以找到我们的数据管理类 runApp(ProviderNode(child: StreamApp(), providers: providers));&#125; 接着就是替换我们的界面实现了，前面通过 BLoC 实现，这里替换成 Provide 来实现 class StreamHome extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, // 通过指定类型，获取特定的 Provide，这个 Provide 会返回我们的数据管理类 provider // 通过内部定义的方法，获取到需要展示的值 child: Provide&lt;CountProvider&gt;(builder: (_, widget, provider) =&gt; Text('$&#123;provider.value&#125;')), )), floatingActionButton: FloatingActionButton( onPressed: () =&gt; // 通过 value 方法获取到我们的数据管理类 provider， // 通过调用改变值的方法，修改内部的值，并通知界面刷新重建 Provide.value&lt;CountProvider&gt;(context).changeValue( Provide.value&lt;CountProvider&gt;(context).value + 1), child: Icon(Icons.add)) ); &#125;&#125; 本文代码查看 bloc 包名下的所有文件，需要单独运行 stream_main.dart 文件 最后运行后还是一样的效果，也摒弃了 StatefulWidget 部件和 SetState 方法，实现了逻辑和界面分离。但是 Provide 最终还是通过 InheritedWidget 来实现，当然在资源方面 Google 的大佬们做了一些相关的处理，至于如何处理，这边就不多说了。目前 provide 的这个库还存在一点争议的地方，具体查看 issue#3，但是目前来看并没有太大的影响。当然你不放心的话，可以使用 Scoped_model 或者上面的 Bloc 模式，Google 在文档也有相关的注明 If you must choose a package today, it’s safer to go with package:scoped_model than with this package. 这篇概念性的比较多，但是等理解了以后，对于以后的开发还是非常有利的。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十)之手势处理和动画]]></title>
    <url>%2Fposts%2Fd4756fd3.html</url>
    <content type="text"><![CDATA[在 Flutter 中，自带手势监听的目前为止好像只有按钮部件和一些 chip 部件，例如 Text 等部件需要实现手势监听，就需要借助带有监听事件的部件来实现了，这节我们会讲下 InkWell 和 GestureDetector 来实现手势的监听。 InkWell在前面的一些例子中，小伙伴应该看到了好几次 InkWell 这个部件，通过它我们可以实现对一些手势的监听，并实现 MD 的水波纹效果，举个简单的一个例子 InkWell( child: Text('点我...点我...我能响应点击手势'), onTap: () =&gt; print('啊...我被点击了...')), 那么当点击 Text 的时候就会响应点击事件，控制台输出日志 我们还是老套路，分析下源码。Ctrl 点击 InkWell 来查看源码(Android Studio 的操作，别的我不懂喔…)，然后，「嗯…除了构造函数怎么什么都没有？？？」那只能看它的父类 InkResponse 了，在那之前，我们看下 InkWell 的说明 &gt; /// A rectangular area of a [Material] that responds to touch.&gt; InkWell 是在 MaterialDesign 风格下的一个用来响应触摸的矩形区域（注意加粗的文字，1.如果不是 MD 风格的部件下，你是不能用这个来做点击响应的；2.InkWell 是一块矩形区域，如果你要的是圆形区域，8 好意思，不行！） &gt; /// The [InkWell] widget must have a [Material] widget as an ancestor. The&gt; /// [Material] widget is where the ink reactions are actually painted. This&gt; /// matches the material design premise wherein the [Material] is what is&gt; /// actually reacting to touches by spreading ink. `InkWell` 必须要有一个 `Material` 风格的部件作为锚点，巴拉巴拉巴拉....再次强调必须要在 `MD` 风格下使用。接下来看下 `InkResponse` 吧#### InkResponse```dartconst InkResponse(&#123; Key key, this.child, // 需要监听的子部件 // 一个 `GestureTapCallback` 类型参数，看下 `GestureTapCallback` 的定义, // `typedef GestureTapCallback = void Function();` 就是简单的无参无返回类型参数 // 监听手指点击事件 this.onTap, // 一个 `GestureTapDownCallback` 类型参数，需要 `TapDownDetails` 类型参数， // `TapDownDetails` 里面有个 `Offset` 参数用于记录点击的位置，监听手指点击屏幕的事件 this.onTapDown, // 同 `onTap` 表示点击事件取消监听 this.onTapCancel, // 同 `onTap` 表示双击事件监听 this.onDoubleTap, // 一个 `GestureLongPressCallback` 类型参数，也是无参无返回值，表示长按的监听 this.onLongPress, // 监听高亮的变化，返回 `true` 表示往高亮变化，`false` 相反 this.onHighlightChanged, // 是否需要裁剪区域，`InkWell` 该值为 `true`，会根据 `highlightShape` 裁剪 this.containedInkWell = false, // 高亮的外形，`InkWell` 该值设置成 `BoxShape.rectangle`，所以是个矩形区域 this.highlightShape = BoxShape.circle, this.radius, // 手指点下去的时候，出现水波纹的半径 this.borderRadius, // 点击时候外圈阴影的圆角半径 this.customBorder, this.highlightColor, // 高亮颜色 this.splashColor, // 手指点下生成的水波颜色 this.splashFactory, // 两个值 `InkRipple.splashFactory` 和 `InkSplash.splashFactory` this.enableFeedback = true, // 检测到手势是否有反馈 this.excludeFromSemantics = false, &#125;) 所以一些简单的触摸事件直接通过 InkWell 或者 InkResponse 就能够实现，但是面临一些比较复杂的手势，就有点不太够用了，我们需要通过 GestureDector 来进行处理 GestureDectorGestureDetector 也是一个部件，主要实现对各种手势动作的监听，其监听事件查看下面的表格 回调方法 回调描述 onTapDown 点击屏幕的手势触碰到屏幕时候触发 onTapUp 点击屏幕抬手后触发，点击结束 onTap 点击事件已经完成的时候触发，和 onTapUp 几乎同时 onTapCancel 点击未完成，被其它手势取代的时候触发 onDoubleTap 双击屏幕的时候触发 onLongPress 长按屏幕的时候触发 onLongPressUp 长按屏幕后抬手触发 onVerticalDragDown 触碰到屏幕，可能发生垂直方向移动触发，onVerticalDrag 系列事件不会同 onHorizontalDrag 系列事件同时发生 ，如果发生了 onVerticalDrag 则接下来如何变化移动，都不会触发 onHorizontalDrag 事件，除非取消后重新触发。判断两者的关键是准备滑动的意图，先发生横向滑动则触发 onHorizontalDrag 事件，否则 onVerticalDrag 事件。 onVerticalDragStart 触碰到屏幕，并开始发生垂直方向的移动触发 onVerticalDragUpdate 垂直方向移动的距离变化触发 onVerticalDragEnd 抬手取消垂直方向移动的时候触发 onVerticalDragCancel 触发 onVerticalDragDown 但是没有完成整个 onVerticalDrag 事件触发 onHorizontalDrag 系列介绍省略同上… onPanDown 触碰到屏幕，准备滑动的时候触发，onPan 系列回调不可和 onVerticalDrag 或者 onHorizontalDrag 系列回调同时设置 onPanStart 触碰到屏幕，并开始滑动时候触发 onPanUpdate 滑动位置发生改变的时候触发 onPanEnd 滑动完成并抬手的时候触发 onPanCancel 触发 onPanDown 但是没有完成整个 onPan 事件触发 onScaleStart 两个手指之间建立联络点触发，初始缩放比例为 1.0 onScaleUpdate 手指距离发生变化，缩放比例也跟随变化触发 onScaleEnd 手指抬起，至间的联络断开时候触发 还有 onForcePress 系列事件，这个是根据对屏幕的挤压力度进行触发，需要达到某些定值才能触发。GestureDetector 有个 behavior 属性用于设置手势监听过程中的表现形式 deferToChild 默认值，触摸到 child 的范围才会触发手势，空白处不会触发 opaque 不透明模式，防止 background widget 接收到手势 translucent 半透明模式，刚好同 opaque 相反，允许 background widget 接收到手势 介绍完了手势，那就可以实际操练起来了，比如，实现一个跟随手指运动的小方块，先看下效果图 简单的分析下，通过 Positioned 来设置小方块的位置，根据 GestureDetector 的 onPanUpdate 修改 Positioned 的 left 和 top 值，当 onPanEnd 或者 onPanCancel 的时候设置为原点，那么就可以有如图的效果了 class GestureDemoPage extends StatefulWidget &#123; @override _GestureDemoPageState createState() =&gt; _GestureDemoPageState();&#125;class _GestureDemoPageState extends State&lt;GestureDemoPage&gt; &#123; double left = 0.0; double top = 0.0; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Gesture Demo'), ), body: Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ Positioned(child: Container(width: 50.0, height: 50.0, color: Colors.red), left: left, top: top), GestureDetector( behavior: HitTestBehavior.translucent, child: Container( color: Colors.transparent, width: MediaQuery.of(context).size.width - 10, height: MediaQuery.of(context).size.height), onPanDown: (details) &#123; setState(() &#123; left = details.globalPosition.dx; top = details.globalPosition.dy; &#125;); &#125;, onPanUpdate: (details) &#123; setState(() &#123; left = details.globalPosition.dx; top = details.globalPosition.dy; &#125;); &#125;, onPanCancel: () &#123; setState(() &#123; left = 0.0; top = 0.0; &#125;); &#125;, onPanEnd: (details) &#123; setState(() &#123; left = 0.0; top = 0.0; &#125;); &#125;, ) ], )); &#125;&#125; 如果说要实现一个放大缩小的方块，就可以通过 onScaleUpdate 中获取到的 details.scale 来设置方块的宽高即可。这个比较简单就留给小伙伴们自己实现效果了。 该部分代码查看 gesture_main.dart 文件 Animation 动画Flutter 的 Animation 是个抽象类，具体的实现需要看其子类 AnimationController，在这之前，先了解下 Animation 的一些方法和介绍。 addListener / removeListener 添加的监听用于监听值的变化，remove 用于停止监听 addStatusListener / removeStatusListener 添加动画状态变化的监听，remove 停止监听，Animation 的状态有 4 种：dismissed 动画初始状态，反向运动结束状态，forward 动画正向运动状态，reverse 动画反向运动状态，completed 动画正向运动结束状态。 drive 方法用于连接动画，例如官方举的例子，因为 AnimationController 是其子类，所以也拥有该方法 Animation&lt;Alignment&gt; _alignment1 = _controller.drive( AlignmentTween( begin: Alignment.topLeft, end: Alignment.topRight, ), ); 上面的例子将 AnimationController 和 AlignmentTween 结合成一个 Animation&lt;Alignment&gt; 动画，当然 drive 可以结合多个动画，例如 Animation&lt;Alignment&gt; _alignment3 = _controller .drive(CurveTween(curve: Curves.easeIn)) .drive(AlignmentTween( begin: Alignment.topLeft, end: Alignment.topRight, )); 因为 Animation 是抽象类，所以具体的还是需要通过 AnimationController 来实现。 AnimationControllerAnimationController(&#123; double value, // 设置初始的值 this.duration, // 动画的时长 this.debugLabel, // 主要是用于 `toString` 方法中输出信息 this.lowerBound = 0.0, // 最小范围 this.upperBound = 1.0, // 最大范围 // AnimationController 结束时候的行为，有 `normal` 和 `preserve` 两个值可选 this.animationBehavior = AnimationBehavior.normal, // 这个属性可以通过 with `SingleTickerProviderStateMixin` // 或者 `TickerProviderStateMixin` 引入到 `State`，通过 `this` 指定 @required TickerProvider vsync, &#125;) AnimationController 控制动画的方法有这么几个 forward 启动动画，和上面提到的 forward 状态不一样 reverse 方向启动动画 repeat 重复使动画运行 stop 停止动画 reset 重置动画 大概了解了 AnimationController ，接下来通过一个实际的小例子来加深下印象，例如实现如下效果，点击开始动画，结束后再点击反向动画 class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; @override void initState() &#123; super.initState(); _animationController = AnimationController( vsync: this, duration: Duration(milliseconds: 1000), lowerBound: 28.0, upperBound: 50.0); // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); &#125; @override void dispose() &#123; // 一定要释放资源 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Center( child: IconButton( icon: Icon(Icons.android, color: Colors.green[500], size: _animationController.value), onPressed: () &#123; // 根据状态执行不同动画运动方式 if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;), ), ); &#125;&#125; 那么如果要实现无限动画呢，那就可以通过 addStatusListener 监听动画的状态来执行，修改代码，在 initState 增加如下代码 _animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); // 正向结束后开始反向 else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); // 反向结束后开始正向 &#125;); _animationController.forward(); // 启动动画 把 Center 的 child 替换成一个 Icon，因为上面已经启动了动画，所以不需要再用点击去启动了，运行后就会无限放大缩小循环跑了。 在这个例子中，通过设置 AnimationController 的 lowerBound 和 upperBound 实现了动画的变化范围，接下来，将通过 Tween 来实现动画的变化范围。先看下 Tween 的一些介绍。 Tween &gt; /// A linear interpolation between a beginning and ending value.&gt; ///&gt; /// [Tween] is useful if you want to interpolate across a range.&gt; ///&gt; /// To use a [Tween] object with an animation, call the [Tween] object's&gt; /// [animate] method and pass it the [Animation] object that you want to&gt; /// modify.&gt; ///&gt; /// You can chain [Tween] objects together using the [chain] method, so that a&gt; /// single [Animation] object is configured by multiple [Tween] objects called&gt; /// in succession. This is different than calling the [animate] method twice,&gt; /// which results in two separate [Animation] objects, each configured with a&gt; /// single [Tween].&gt; Tween 是一个线性插值(如果要修改运动的插值，可以通过 CurveTween 来修改)，所以在线性变化的时候很有用 通过调用 Tween 的 animate 方法生成一个 Animation(animate 一般传入 AnimationController) 还可以通过 chain 方法将多个 Tween 结合到一起，这样就不需要多次去调用 Tween 的 animate 方法来生成动画了，多次调用 animate 相当于使用了两个分开的动画来完成效果，但是 chain 结合到一起就是一个动画过程 那么对前面的动画进行一些修改，通过 Tween 来控制值的变化 class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; Animation _scaleAnimation; // 动画实例，用于修改值的大小 @override void initState() &#123; super.initState(); _animationController = AnimationController(vsync: this, duration: Duration(milliseconds: 1000)); // 不通过 `lowerBound` 和 `upperBound` 设置范围，改用 `Tween` // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); _animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;); // 通过 `Tween` 的 `animate` 生成一个 Animation // 再通过 Animation.value 进行值的修改 _scaleAnimation = Tween(begin: 28.0, end: 50.0).animate(_animationController); _animationController.forward(); &#125; @override void dispose() &#123; // 一定要释放资源 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Center( // 通过动画返回的值，修改图标的大小 child: Icon(Icons.favorite, color: Colors.red, size: _scaleAnimation.value), ), ); &#125;&#125; 再次运行，还是能过达到之前的效果，那么很多小伙伴肯定会问了，「**，加了那么多代码，效果还是和以前的一样，还不如不加…」好吧，我无法反驳，但是如果要实现多个动画呢，那么使用 Tween 就有优势了，比如我们让图标大小变化的同时，颜色和位置也发生变化，只通过 AnimationController 要怎么实现? 又比如说，运动的方式要先加速后减速，那只通过 AnimationController 要如何实现？这些问题通过 Tween 就会非常方便解决，直接上代码 class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; Animation _scaleAnimation; // 用于控制图标大小 Animation&lt;Color&gt; _colorAnimation; // 控制图标颜色 Animation&lt;Offset&gt; _positionAnimation; // 控制图标位置 @override void initState() &#123; super.initState(); _animationController = AnimationController(vsync: this, duration: Duration(milliseconds: 2000)); // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); _animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;); // 通过 `chain` 结合 `CurveTween` 修改动画的运动方式，曲线类型可自行替换 _scaleAnimation = Tween(begin: 28.0, end: 50.0).chain(CurveTween(curve: Curves.decelerate)).animate(_animationController); _colorAnimation = ColorTween(begin: Colors.red[200], end: Colors.red[900]) .chain(CurveTween(curve: Curves.easeIn)) .animate(_animationController); _positionAnimation = Tween(begin: Offset(100, 100), end: Offset(300, 300)) .chain(CurveTween(curve: Curves.bounceInOut)) .animate(_animationController); _animationController.forward(); // 启动动画 &#125; @override void dispose() &#123; _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Stack( children: &lt;Widget&gt;[ Positioned( child: Icon(Icons.favorite, color: _colorAnimation.value, size: _scaleAnimation.value), left: _positionAnimation.value.dx, top: _positionAnimation.value.dy, ) ], ), ); &#125;&#125; 那么最后的效果图 当然，Flutter 中已经实现的 Tween 还有很多，包括 BorderTween、TextStyleTween、ThemeDataTween ..等等，实现的方式都是类似的，小伙伴们可以自己慢慢看。 AnimationWidget在上面的例子中，都是通过 addListener 监听动画值变化，然后通过 setState 方法来实现刷新效果。那么 Flutter 也提供了一个部件 AnimationWidget 来实现动画部件，就不需要一直监听了，还是实现上面的例子 class RunningHeart extends AnimatedWidget &#123; final List&lt;Animation&gt; animations; // 传入动画列表 final AnimationController animationController; // 控制动画 RunningHeart(&#123;this.animations, this.animationController&#125;) // 对传入的参数进行限制(当然你也可以不做限制) : assert(animations.length == 3), assert(animations[0] is Animation&lt;Color&gt;), assert(animations[1] is Animation&lt;double&gt;), assert(animations[2] is Animation&lt;Offset&gt;), super(listenable: animationController); @override Widget build(BuildContext context) &#123; return Stack( children: &lt;Widget&gt;[ Positioned( // 之前的 animation 都通过 animations 参数传入到 `AnimationWidget` child: Icon(Icons.favorite, color: animations[0].value, size: animations[1].value), left: animations[2].value.dx, top: animations[2].value.dy, ) ], ); &#125;&#125; 其实内部返回的部件和前面的是一样的 接着对 _AnimationDemoPageState 类进行修改，注释 initState 中的 _animationController.addListener 所有内容，然后将 body 属性替换成新建的 RunningHeart 部件，记得传入的动画列表的顺序 body: RunningHeart( animations: [_colorAnimation, _scaleAnimation, _positionAnimation], animationController: _animationController, ) 这样就实现了刚才一样的效果，并且没有一直调用 setState 来刷新。 该部分代码查看 animation_main.dart 文件 StaggeredAnimationsFlutter 还提供了交错动画，听名字就可以知道，是按照时间轴，进行不同的动画，并且由同个AnimationController 进行控制。因为没有找到好的例子，原谅我直接搬官方的例子来讲，官方交错动画 demo 在继续看之前，先了解下 Interval &gt; /// An [Interval] can be used to delay an animation. For example, a six second&gt; /// animation that uses an [Interval] with its [begin] set to 0.5 and its [end]&gt; /// set to 1.0 will essentially become a three-second animation that starts&gt; /// three seconds later.&gt; Interval 用来延迟动画，例如一个时长 6s 的动画，通过 Interval 设置其 begin 参数为 0.5，end 参数设置为 1.0，那么这个动画就会变成 3s 的动画，并且开始的时间延迟了 3s。 了解 Interval 功能后，就可以看下实例了，当然我们不和官方的 demo 一样，中间加个旋转动画 class StaggeredAnim extends StatelessWidget &#123; final AnimationController controller; final Animation&lt;double&gt; opacity; final Animation&lt;double&gt; width; final Animation&lt;double&gt; height; final Animation&lt;EdgeInsets&gt; padding; final Animation&lt;BorderRadius&gt; border; final Animation&lt;Color&gt; color; final Animation&lt;double&gt; rotate; StaggeredAnim(&#123;Key key, this.controller&#125;): // widget 透明度 opacity = Tween(begin: 0.0, end: 1.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.0, 0.1, curve: Curves.ease))), // widget 宽 width = Tween(begin: 50.0, end: 150.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.1, 0.250, curve: Curves.ease))), // widget 高 height = Tween(begin: 50.0, end: 150.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.25, 0.375, curve: Curves.ease))), // widget 底部距离 padding = EdgeInsetsTween(begin: const EdgeInsets.only(top: 150.0), end: const EdgeInsets.only(top: .0)) .animate(CurvedAnimation(parent: controller, curve: Interval(0.25, 0.375, curve: Curves.ease))), // widget 旋转 rotate = Tween(begin: 0.0, end: 0.25) .animate(CurvedAnimation(parent: controller, curve: Interval(0.375, 0.5, curve: Curves.ease))), // widget 外形 border = BorderRadiusTween(begin: BorderRadius.circular(5.0), end: BorderRadius.circular(75.0)) .animate(CurvedAnimation(parent: controller, curve: Interval(0.5, 0.75, curve: Curves.ease))), // widget 颜色 color = ColorTween(begin: Colors.blue, end: Colors.orange) .animate(CurvedAnimation(parent: controller, curve: Interval(0.75, 1.0, curve: Curves.ease))), super(key: key); Widget _buildAnimWidget(BuildContext context, Widget child) &#123; return Container( padding: padding.value, alignment: Alignment.center, // 旋转变化 child: RotationTransition( turns: rotate, // turns 表示当前动画的值 * 360° 角度 child: Opacity( opacity: opacity.value, // 透明度变化 child: Container( width: width.value, // 宽度变化 height: height.value, // 高度变化 decoration: BoxDecoration( color: color.value, // 颜色变化 border: Border.all(color: Colors.indigo[300], width: 3.0), borderRadius: border.value), // 外形变化 ), ), ), ); &#125; @override Widget build(BuildContext context) &#123; // AnimatedBuilder 继承 AnimationWidget，用来快速构建动画部件 return AnimatedBuilder(animation: controller, builder: _buildAnimWidget); &#125;&#125; 然后修改 body 的参数，设置成我们的动画，当点击的时候就会启动动画 GestureDetector( behavior: HitTestBehavior.opaque, onTap: _playAnim, child: Center( // 定义一个外层圈，能够使动画显眼点 child: Container( width: 300, height: 300, decoration: BoxDecoration( color: Colors.black.withOpacity(0.1), border: Border.all(color: Colors.black.withOpacity(0.5))), child: StaggeredAnim(controller: _controller), ), ), ) 看下最后的效果吧 该部分代码查看 staggered_animation_main.dart 文件 结束前，我们再讲一种比较简单的 Hreo 动画，用来过渡用。 Hero通过指定 Hero 中的 tag，在切换的时候 Hero 会寻找相同的 tag，并实现动画，具体的实现逻辑，这里可以推荐一篇文章 谈一谈Flutter中的共享元素动画Hero，里面写的很详细，就不造车轮了。当然这边还是得提供个简单的 demo 的，替换前面的 body 参数 body: Container( alignment: Alignment.center, child: InkWell( child: Hero( tag: 'hero_tag', // 这里指定 tag child: Image.asset('images/ali.jpg', width: 100.0, height: 100.0), ), onTap: () =&gt; Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; HeroPage())), ), ) 然后创建 HeroPage 界面，当然也可以是个 Dialog，只要通过路由实现即可 class HeroPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Container( alignment: Alignment.center, child: InkWell( child: Hero(tag: 'hero_tag', child: Image.asset('images/ali.jpg', width: 200.0, height: 200.0)), onTap: () =&gt; Navigator.pop(context), ), ), ); &#125;&#125; 看下最后的效果图： 该部分代码查看 animation_main.dart 文件 这一部分讲的比较多，小伙伴可以慢慢消化，下节我会尽量填下之前留下的状态管理的坑。 最后代码的地址还是要的： 文章中涉及的代码：demos 基于郭神 cool weather 接口的一个项目，实现 BLoC 模式，实现状态管理：flutter_weather 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：flutter_shop]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(九)之弹窗和提示(SnackBar、BottomSheet、Dialog)]]></title>
    <url>%2Fposts%2F5da6faeb.html</url>
    <content type="text"><![CDATA[前面的小节把常用的一些部件都介绍了，这节介绍下 Flutter 中的一些操作提示。Flutter 中的操作提示主要有这么几种 SnackBar、BottomSheet、Dialog，因为 Dialog 样式比较多，放最后讲好了 SnackBarSnackBar 的源码相对简单 const SnackBar(&#123; Key key, @required this.content, // 提示信息 this.backgroundColor, // 背景色 this.action, // SnackBar 尾部的按钮，用于一些回退操作等 this.duration = _kSnackBarDisplayDuration, // 停留的时长，默认 4000ms this.animation, // 进出动画 &#125;) 例如我们需要实现一个功能，修改某个值，修改后给用户一个提示，同时给用户一个撤销该操作的按钮，那么就可以通过 SnackBar 来简单实现。还有就是 SnackBar 可以和 floatingActionButton 完美的配合，弹出的时候不会遮挡住 fab class _PromptDemoPageState extends State&lt;PromptDemoPage&gt; &#123; var count = 0; @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; super.dispose(); &#125; // 自增操作 increase() &#123; setState(() =&gt; count++); &#125; // 自减操作 decrease() &#123; setState(() =&gt; count--); &#125; _changeValue(BuildContext context) &#123; increase(); Scaffold.of(context).showSnackBar(SnackBar( content: Text('当前值已修改'), action: SnackBarAction(label: '撤销', onPressed: decrease), duration: Duration(milliseconds: 2000))); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Prompt Demo'), ), body: Column(children: &lt;Widget&gt;[ Text('当前值：$count', style: TextStyle(fontSize: 20.0)), Expanded( // 为了方便拓展，我这边提取了 `snackBar` 的方法，并把按钮放在列表 child: ListView(padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ // SnackBar 需要提供一个包含 context，但是 context 不能是 Scaffold 节点下的 context，所以需要通过 Builder 包裹一层 Builder(builder: (context) =&gt; RaisedButton(onPressed: () =&gt; _changeValue(context), child: Text('修改当前值'))), ])) ]), // 当 SnackBar 弹出时，fab 会上移一段距离 floatingActionButton: Builder( builder: (context) =&gt; FloatingActionButton(onPressed: () =&gt; _changeValue(context), child: Icon(Icons.send))), ); &#125;&#125; 可以看下最后的效果图，请注意看 fab 和值的变化： BottomSheetBottomSheet 看命名就知道是从底部弹出的菜单，展示 BottomSheet 有两种方式，分别是 showBottomSheet 和 showModalBottomSheet，两种方式只有在展示类型上的差别，方法调用无差，而且 showBottomSheet 和 fab 有组合动画，showModalBottomSheet 则没有，看下实际的例子吧。在 ListView 中增加一个 BottomSheet 的按钮，因为 BottomSheet 需要的 context 也不能是 Scaffold 下的 context，所以需要通过 Builder 进行包裹一层，然后增加 _showBottomSheet 的方法 _showBottomSheet(BuildContext context) &#123; showBottomSheet( context: context, builder: (context) =&gt; ListView( // 生成一个列表选择器 children: List.generate( 20, (index) =&gt; InkWell( child: Container(alignment: Alignment.center, height: 60.0, child: Text('Item $&#123;index + 1&#125;')), onTap: () &#123; print('tapped item $&#123;index + 1&#125;'); Navigator.pop(context); &#125;), )), ); &#125; 把 showBottomSheet 替换成 showModalBottomSheet 就是另外一种展示方式了，内部不需要做任何改变，我们看下两种的运行效果： 可以看到 showBottomSheet 会充满整个屏幕，然后 fab 会跟随一起到 AppBar 的底部位置，而 showModalBottomSheet 展示的高度不会超过半个屏幕的高度，但是 fab 被其遮挡了。假如我们只需要展示 2-3 个 item，但是按照刚才的方式 showModalBottomSheet 的高度太高了，那我们可以在 ListView 外层包裹一层 Container，然后指定 height 即可 _showModalBottomSheet(BuildContext context) &#123; showModalBottomSheet( context: context, builder: (context) =&gt; Container( child: ListView( children: List.generate( 2, (index) =&gt; InkWell( child: Container(alignment: Alignment.center, height: 60.0, child: Text('Item $&#123;index + 1&#125;')), onTap: () &#123; print('tapped item $&#123;index + 1&#125;'); Navigator.pop(context); &#125;), )), height: 120, ), ); &#125; 修改高度后的效果： Dialog相对于 SnackBar 和 BottomSheet，Dialog 的使用场景相对会更多，在 MaterialDesign 下，Dialog 主要有 3 种：AlertDialog，SimpleDialog 和 AboutDialog，当然在 Cupertino 风格下也有相应的 Dialog，因为这个系列以 MaterialDesign 风格为主，所以 Cupertiono 等下次有时间再写吧。 AlertDialog在 ListView 中增加一个 AlertDialog 的按钮，用于点击显示 AlertDialog 用，然后加入显示 AlertDilaog 的方法，并将按钮的 onPressed 指向该方法，Dialog 的 context 可以是 Scaffold 下的 context，所以不需要用 Builder 来包裹一层。 _showAlertDialog() &#123; showDialog( // 设置点击 dialog 外部不取消 dialog，默认能够取消 barrierDismissible: false, context: context, builder: (context) =&gt; AlertDialog( title: Text('我是个标题...嗯，标题..'), titleTextStyle: TextStyle(color: Colors.purple), // 标题文字样式 content: Text(r'我是内容\(^o^)/~, 我是内容\(^o^)/~, 我是内容\(^o^)/~'), contentTextStyle: TextStyle(color: Colors.green), // 内容文字样式 backgroundColor: CupertinoColors.white, elevation: 8.0, // 投影的阴影高度 semanticLabel: 'Label', // 这个用于无障碍下弹出 dialog 的提示 shape: Border.all(), // dialog 的操作按钮，actions 的个数尽量控制不要过多，否则会溢出 `Overflow` actions: &lt;Widget&gt;[ // 点击增加显示的值 FlatButton(onPressed: increase, child: Text('点我增加')), // 点击减少显示的值 FlatButton(onPressed: decrease, child: Text('点我减少')), // 点击关闭 dialog，需要通过 Navigator 进行操作 FlatButton(onPressed: () =&gt; Navigator.pop(context), child: Text('你点我试试.')), ], )); &#125; 最后看下效果： SimpleDialogSimpleDialog 相比于 AlertDialog 少了 content 和 action 参数，多了 children 属性，需要传入 Widget 列表，那就可以自定义全部内容了。那我们这里就实现一个性别选择的 Dialog，选择后通过 Taost 提示选择的内容，Taost 就是之前导入的第三方插件，先看下效果图吧 只要实现 children 是个列表选择器就可以了，比较简单，直接上代码 _showSimpleDialog() &#123; showDialog( barrierDismissible: false, context: context, builder: (context) =&gt; SimpleDialog( title: Text('我是个比较正经的标题...\n选择你的性别'), // 这里传入一个选择器列表即可 children: _genders .map((gender) =&gt; InkWell( child: Container(height: 40.0, child: Text(gender), alignment: Alignment.center), onTap: () &#123; Navigator.pop(context); Fluttertoast.showToast(msg: '你选择的性别是 $gender'); &#125;, )) .toList(), )); &#125; AboutDialogAboutDialog 主要是用于展示你的 App 或者别的相关东西的内容信息的，平时用的比较少，显示 AboutDialog 有两种方式可以展示，一种是前面一样的 showDialog 方法，传入一个 AboutDialog 实例，还有中方法是直接调用 showAboutDialog 方法。我们还是一样在列表加个按钮，并指向显示 AboutDialog 的事件。 _showAboutDialog() &#123; showDialog( barrierDismissible: false, context: context, builder: (context) =&gt; AboutDialog( // App 的名字 applicationName: 'Flutter 入门指北', // App 的版本号 applicationVersion: '0.1.1', // App 基本信息下面会显示一行小字，主要用来显示版权信息 applicationLegalese: 'Copyright: this is a copyright notice topically', // App 的图标 applicationIcon: Icon(Icons.android, size: 28.0, color: CupertinoColors.activeBlue), // 任何你想展示的 children: &lt;Widget&gt;[Text('我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)')], )); &#125; 也可以通过 showAboutDialog 实现同样的效果 _showAboutDialog() &#123; showAboutDialog( context: context, applicationName: 'Flutter 入门指北', applicationVersion: '0.1.1', applicationLegalese: 'Copyright: this is a copyright notice topically', applicationIcon: Image.asset('images/app_icon.png', width: 40.0, height: 40.0), children: &lt;Widget&gt;[Text('我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)')], );&#125; 最后的效果： AboutDialog 会自带两个按钮 VIEW LICENSES 和 CLOSE，VIEW LICENSES 会跳转一个 Flutter Licenses 的网页，CLOSE 会关闭，至于为什么是英文的，是因为我们没有设置语言的原因，这个涉及到多语言，这边推荐几篇之前看过的文章，如果下次有时间的话会单独拿出来讲下 英文原版多语言设置，介绍两种方式实现 国人翻译版，未持续更新第二种方式 使用插件 in18 版 这边为了支持中文，我们做下如下的修改，首先打开 pubspec.ymal 文件加入如下支持 get package 后给 MaterialApp 加入如下属性，这样就会支持中文了，这里需要导入包 package:flutter_localizations/flutter_localizations.dart，再次运行，就会发现之前的英文变成中文了，当然你也可以设置成别的语言。 Dialog 状态保持假如有个需求，需要在弹出的 Dialog 显示当前被改变的值，然后通过按钮可以修改这个值 ，该如何实现。相信很多小伙伴都会这么认为，通过 setState 来修改不就行了吗，没错，我一开始的确这么去实现的，我们先看下代码好了，增加一个 DialogState 按钮，然后指向对应的点击事件 _showStateDialog() &#123; showDialog( context: context, barrierDismissible: false, builder: (context) =&gt; SimpleDialog( title: Text(&apos;我这边能实时修改状态值&apos;), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ Text(&apos;当前的值是： $_count&apos;, style: TextStyle(fontSize: 18.0)), Padding( padding: const EdgeInsets.symmetric(vertical: 12.0), child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( onPressed: increase, child: Text(&apos;点我自增&apos;), ), RaisedButton( onPressed: decrease, child: Text(&apos;点我自减&apos;), ), RaisedButton( onPressed: () =&gt; Navigator.pop(context), child: Text(&apos;点我关闭&apos;), ) ]), ) ], )); &#125; 然后我们运行看下 诶诶诶，怎么 Dialog 的值不改变呢，明明界面上的已经修改了啊。所以说图样图森破咯，看下官方对 showDialog 方法的解释吧 // This function takes a `builder` which typically builds a [Dialog] widget.// Content below the dialog is dimmed with a [ModalBarrier]. The widget// returned by the `builder` does not share a context with the location that// `showDialog` is originally called from. Use a [StatefulBuilder] or a// custom [StatefulWidget] if the dialog needs to update dynamically. 糟糕透的翻译又来了：该方法通过 builder 参数来传入一个 Dialog 部件，dialog 下的内容被一个「模态障碍」阻隔，builder 的 context 和调用 showDialog 时候的 context 不是共享的，如果需要动态修改 dialog 的状态值，需要通过 StatefulBuilder 或者自定义 dialog 继承于 StatefulWidget 来实现 所以解决的方法很明确，对上面的代码进行修改，在外层嵌套一个 StatefulBuilder 部件 _showStateDialog() &#123; showDialog( context: context, barrierDismissible: false, // 通过 StatefulBuilder 来保存 dialog 状态 // builder 需要传入一个 BuildContext 和 StateSetter 类型参数 // StateSetter 有一个 VoidCallback，修改状态的方法在这写 builder: (context) =&gt; StatefulBuilder( builder: (context, dialogStateState) =&gt; SimpleDialog( title: Text('我这边能实时修改状态值'), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ Text('当前的值是： $_count', style: TextStyle(fontSize: 18.0)), Padding( padding: const EdgeInsets.symmetric(vertical: 12.0), child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( // 通过 StatefulBuilder 的 StateSetter 来修改值 onPressed: () =&gt; dialogStateState(() =&gt; increase()), child: Text('点我自增'), ), RaisedButton( onPressed: () =&gt; dialogStateState(() =&gt; decrease()), child: Text('点我自减'), ), RaisedButton( onPressed: () =&gt; Navigator.pop(context), child: Text('点我关闭'), ) ]), ) ], ))); &#125; 然后再运行下，可以看到 dialog 和界面的值保持一致了 以上部分代码查看 prompt_main.dart 文件 差不多常用弹窗和操作提示就在这了，好好消化吧~]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(八)之Sliver组件及NestedScrollView]]></title>
    <url>%2Fposts%2Ff600e8a7.html</url>
    <content type="text"><![CDATA[上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去 在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。 SliverAppBar相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性 const SliverAppBar(&#123;Key key,this.leading,this.automaticallyImplyLeading = true,this.title,this.actions,this.flexibleSpace, // 通过这个来设置背景this.bottom,this.elevation,this.forceElevated = false, // 是否显示层次感this.backgroundColor,this.brightness,this.iconTheme,this.textTheme,this.primary = true,this.centerTitle,this.titleSpacing = NavigationToolbar.kMiddleSpacing,this.expandedHeight, // 展开的高度// 以下三个等例子再讲this.floating = false,this.pinned = false,this.snap = false,&#125;) 别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件 class SliverDemoPage extends StatelessWidget &#123;@overrideWidget build(BuildContext context) &#123;return Scaffold(body: CustomScrollView(slivers: &lt;Widget&gt;[SliverAppBar(title: Text('Sliver Demo'),centerTitle: true,// 展开的高度expandedHeight: 300.0,// 强制显示阴影forceElevated: true,// 设置该属性，当有下滑手势的时候，就会显示 AppBar// floating: true,// 该属性只有在 floating 为 true 的情况下使用，不然会报错// 当上滑到一定的比例，会自动把 AppBar 收缩（不知道是不是 bug，当 AppBar 下面的部件没有被 AppBar 覆盖的时候，不会自动收缩）// 当下滑到一定比例，会自动把 AppBar 展开// snap: true,// 设置该属性使 Appbar 折叠后不消失// pinned: true,// 通过这个属性设置 AppBar 的背景flexibleSpace: FlexibleSpaceBar(// title: Text('Expanded Title'),// 背景折叠动画collapseMode: CollapseMode.parallax,background: Image.asset('images/timg.jpg', fit: BoxFit.cover),),),// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，// 可以在 child 属性加入需要展示的部件SliverFillRemaining(child: Center(child: Text('FillRemaining', style: TextStyle(fontSize: 30.0))),),]));&#125;&#125; 这里分别给出不同的动图来查看三个属性的影响 如果设置了 floating 属性，当有下拉动作时，会显示 AppBar 如果设置了 snap 属性，滑动距离达到一定值后，会根据滑动方向收缩或者展开 如果设置了 pinned 属性，那么 AppBar 就会在界面上不会消失 以上的效果图把 SliverFillRemaining 换成列表 SliverFixedExtentList 效果可能会更加明显，这边给小伙伴自己替换测试吧。 SliverFillViewport这边提到了 SliverFillRemaining 用来填充视图，那么顺带提下 SliverFillViewport 这个部件 const SliverFillViewport(&#123;Key key,@required SliverChildDelegate delegate, // 这个 delegate 同 SliverGridthis.viewportFraction = 1.0, // 同屏幕的比例值，1.0 为一个屏幕大小&#125;) 如果一个滑动列表，每个 item 需要占满一个屏幕或者更大，可以使用该部件生成列表，但是如果 item 的高度小于一个屏幕高度，那就不太推荐了，在首尾会用空白 item 来把未填满的补上，就是首尾都会留空白。我们使用 SliverFillViewport 对 SliverFillRemaning 进行替换 SliverFillViewport(viewportFraction: 1.0,delegate: SliverChildBuilderDelegate((_, index) =&gt; Container(child: Text('Item $index'), alignment: Alignment.center, color: colors[index % 4]),childCount: 10)) 效果就不展示了，可自行运行查看。 SliverToBoxAdapter还记得上节最后的代码中，有使用 SliverToBoxAdapter 这个部件吗，这个部件只需要传入一个 child 属性。因为在 CustomScrollView 中只允许传入 Sliver 部件，那么类似 Container 等普通部件就不可以使用了，那么这样就需要更多的 Sliver 组件才能完成视图，所以为了方便，直接通过 SliverToBoxAdapter 对普通部件进行包裹，这样就成为一个 Sliver 部件了。总结下 SliverToBoxAdapter 的功能就是 把一个普通部件包裹成为 Sliver 部件，例子就不举了，上节已经有了。 SliverPadding那么在 CustomScrollView 中部件之间如何设置间距呢，可能你会想到用 SliverToBoxAdapter 包裹一个 Padding 来处理，当然没问题。不过 Flutter 也提供了专门的部件 SliverPadding 使用方式同 Padding，但是需要传入一个 sliver 作为子类。 SliverPersistentHeaderFlutter 中，为我们提供了这么一个作为头部的部件 SliverPersistentHeader，这个部件可以根据滚动的距离缩小高度，有点类似 SliverAppBar 的背景效果。 const SliverPersistentHeader(&#123;Key key,@required this.delegate, // SliverPersistentHeaderDelegate，用来创建展示内容this.pinned = false, // 同 SliverAppBar 属性this.floating = false,&#125;) SliverPersistentHeaderDelegate这个代理比较特殊，是个抽象类，也就是需要我们自己进行继承后再实现方法。SliverPersistentHeaderDelegate 需要提供一个最大值，最小值，展示内容，以及更新部件条件 比如我们需要展示一个最大高度 300，最小高度 100，居中的文字，那么我们可以这么写这个代理类 class DemoHeader extends SliverPersistentHeaderDelegate &#123;@overrideWidget build(BuildContext context, double shrinkOffset, bool overlapsContent) &#123;return Container(color: Colors.pink,alignment: Alignment.center,child: Text('我是一个头部部件', style: TextStyle(color: Colors.white, fontSize: 30.0)));&#125; // 头部展示内容@overridedouble get maxExtent =&gt; 300.0; // 最大高度@overridedouble get minExtent =&gt; 100.0; // 最小高度@overridebool shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) =&gt; false; // 因为所有的内容都是固定的，所以不需要更新&#125; 使用 SliverPersistentHeader 代替 SliverAppBar，看下效果 class SliverDemoPage extends StatelessWidget &#123;final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];@overrideWidget build(BuildContext context) &#123;return Scaffold(body: CustomScrollView(slivers: &lt;Widget&gt;[SliverPersistentHeader(delegate: DemoHeader(), pinned: true),// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，// 可以在 child 属性加入需要展示的部件SliverFillRemaining(child: Center(child: Text('FillRemaining', style: TextStyle(fontSize: 30.0))),),]));&#125;&#125; 最后的效果图 当然，为了方便扩展，需要重新封装下 Delegate ，通过外部传入范围和展示内容 // 自定义 SliverPersistentHeaderDelegateclass CustomSliverPersistentHeaderDelegate extends SliverPersistentHeaderDelegate &#123;final double max; // 最大高度final double min; // 最小高度final Widget child; // 需要展示的内容CustomSliverPersistentHeaderDelegate(&#123;@required this.max, @required this.min, @required this.child&#125;)// 如果 assert 内部条件不成立，会报错: assert(max != null),assert(min != null),assert(child != null),assert(min &lt;= max),super();// 返回展示的内容，如果内容固定可以直接在这定义，如果需要可扩展，这边通过传入值来定义@overrideWidget build(BuildContext context, double shrinkOffset, bool overlapsContent) =&gt; child;@overridedouble get maxExtent =&gt; max; // 返回最大高度@overridedouble get minExtent =&gt; min; // 返回最小高度@overridebool shouldRebuild(CustomSliverPersistentHeaderDelegate oldDelegate) &#123;// 是否需要更新，这里我们定义当高度范围和展示内容被替换的时候进行刷新界面return max != oldDelegate.max || min != oldDelegate.min || child != oldDelegate.child;&#125;&#125; 然后我们就可以愉快的使用了，不需要每个 Delegate 都重新写一遍，例如替换下刚才写死的 DemoHeader SliverPersistentHeader(// 属性同 SliverAppBarpinned: true,floating: true,// 因为 SliverPersistentHeaderDelegate 是一个抽象类，所以需要自定义delegate: CustomSliverPersistentHeaderDelegate(max: 300.0, min: 100.0, child: Text('我是一个头部部件', style: TextStyle(color: Colors.white, fontSize: 30.0))),), 例如需要替换成一张图片，直接将 Text 修改成 Image 即可。 以上部分代码查看 sliver_main.dart 文件 NestedScrollView讲到这了，不得不提下 Scrollable 中比较重要的一员 NestedScrollView，先看下官方的解释 /// A scrolling view inside of which can be nested other scrolling views, with/// their scroll positions being intrinsically linked. 糟透了的翻译 X 1：一个内部能够嵌套其他滚动部件，并使其滚动位置联结到一起的滚动部件 /// The most common use case for this widget is a scrollable view with a/// flexible [SliverAppBar] containing a [TabBar] in the header (build by/// [headerSliverBuilder], and with a [TabBarView] in the [body], such that the/// scrollable view's contents vary based on which tab is visible. 糟透了的翻译 X 2：最常用的情况，就是在其 headerSliverBuilder 中使用携带 TabBar 的 SliverAppBar（就是使用 SliverAppBar 的 bottom 属性添加 tab 切换也），其 body 属性使用 TabBarView 来展示 Tab 页的内容，这样通过切换 Tab 页就能展示该页下的展示内容。 看下 headerSliverBuilder 的定义 /// Signature used by [NestedScrollView] for building its header.////// The `innerBoxIsScrolled` argument is typically used to control the/// [SliverAppBar.forceElevated] property to ensure that the app bar shows a/// shadow, since it would otherwise not necessarily be aware that it had/// content ostensibly below it.typedef NestedScrollViewHeaderSliversBuilder = List&lt;Widget&gt; Function(BuildContext context, bool innerBoxIsScrolled); 糟透了的翻译 X 3：用于构建 NestScrollView 的头部部件，innerBoxIsScrolled 主要用来控制 SliverAppBar 的 forceElevated 属性，当内部内容滚动时，显示 SliverAppbar 的阴影，主要用来提醒内部的内容低于 SliverAppBar （相当于给人一种物理层次感，否则很容易被认为，头部和内容是连接在一起的） 接下来看下 NestedScrollView 内部个人觉得有点重要的一个方法 sliverOverlapAbsorberHandleFor /// Returns the [SliverOverlapAbsorberHandle] of the nearest ancestor/// [NestedScrollView].////// This is necessary to configure the [SliverOverlapAbsorber] and/// [SliverOverlapInjector] widgets.////// For sample code showing how to use this method, see the [NestedScrollView]/// documentation.static SliverOverlapAbsorberHandle sliverOverlapAbsorberHandleFor(BuildContext context) &#123; final _InheritedNestedScrollView target = context.inheritFromWidgetOfExactType(_InheritedNestedScrollView); assert(target != null, 'NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.'); return target.state._absorberHandle;&#125; 请注意到中间的注释 糟透了的翻译 X 4：这个方法返回的值对于 SliverOverlapAbsorber 和 SliverOverlapInjector 部件是非常重要的参数 接着请注意代码中的那段 assert 中的文字 糟透了的翻译 X 5：sliverOverlapAbsorberHandleFor 传入的参数 context 中必须包含 NestedScrollView SliverOverlapAbsorber这边又引入了两个部件 SliverOverlapAbsorber + SliverOverlapInjector 还是看源码的解释吧 /// Creates a sliver that absorbs overlap and reports it to a/// [SliverOverlapAbsorberHandle].////// The [handle] must not be null.////// The [child] must be a sliver.const SliverOverlapAbsorber(&#123; Key key, @required this.handle, Widget child,&#125;) 糟透了的翻译 X 6：一个 sliver 部件，用于把部件重叠的高度反馈给 SliverOverlapAbsorberHandle，而且指明了 handle 不能空，可以通过 NestedScrollView 的 sliverOverlapAbsorberHandleFor 方法来赋值，并且 child 必须是个 sliver 部件，也就是说我们的 SliverAppBar 需要放到 SliverOverlapAbsorber 里面。 SingleChildScrollView/// Creates a sliver that is as tall as the value of the given [handle]'s/// layout extent.////// The [handle] must not be null.const SliverOverlapInjector(&#123; Key key, @required this.handle, Widget child,&#125;) 糟透了的翻译 X 7：创建一个和指定的 handle 一样高度的 sliver 部件，这个 handle 同 SliverOverlapAbsorber 的 handle 保持一致即可。 分析完源码后，例子的目标很明确，使用 SliverAppBar + TabBar + TabBarView，先看下最后的效果图吧 class NestedScrollDemoPage extends StatelessWidget &#123;final _tabs = &lt;String&gt;['TabA', 'TabB'];final colors = &lt;Color&gt;[Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];@overrideWidget build(BuildContext context) &#123;return Scaffold(body: DefaultTabController(length: _tabs.length,child: NestedScrollView(headerSliverBuilder: (context, innerScrolled) =&gt; &lt;Widget&gt;[SliverOverlapAbsorber(// 传入 handle 值，直接通过 `sliverOverlapAbsorberHandleFor` 获取即可handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),child: SliverAppBar(pinned: true,title: Text('NestedScroll Demo'),expandedHeight: 200.0,flexibleSpace: FlexibleSpaceBar(background: Image.asset('images/timg.jpg', fit: BoxFit.cover)),bottom: TabBar(tabs: _tabs.map((tab) =&gt; Text(tab, style: TextStyle(fontSize: 18.0))).toList()),forceElevated: innerScrolled,),)],body: TabBarView(children: _tabs// 这边需要通过 Builder 来创建 TabBarView 的内容，否则会报错// NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView..map((tab) =&gt; Builder(builder: (context) =&gt; CustomScrollView(// key 保证唯一性key: PageStorageKey&lt;String&gt;(tab),slivers: &lt;Widget&gt;[// 将子部件同 `SliverAppBar` 重叠部分顶出来，否则会被遮挡SliverOverlapInjector(handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),SliverGrid(delegate: SliverChildBuilderDelegate((_, index) =&gt; Image.asset('images/ali.jpg'),childCount: 8),gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 4, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0)),SliverFixedExtentList(delegate: SliverChildBuilderDelegate((_, index) =&gt; Container(child: Text('$tab - item$&#123;index + 1&#125;',style: TextStyle(fontSize: 20.0, color: colors[index % 6])),alignment: Alignment.center),childCount: 15),itemExtent: 50.0)],),)).toList()))),);&#125;&#125; 使用的部件和之前讲的没啥大区别，就是多了 SliverOverlapAbsorber 和 SliverOverlapInjector 没啥难度 以上部分代码查看 nested_scroll_main.dart 文件 sliver 部件常用的也就那么多了，望小伙伴好好吸收，跟着例子撸撸代码，撸顺下思路]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(七)之滑动部件]]></title>
    <url>%2Fposts%2F8d9ab46a.html</url>
    <content type="text"><![CDATA[前面的小节基本上讲完了常用的部件和容器部件，也可以完成很多的界面，但是又一个问题，假如我们要显示一段文字，比如将 一段又臭又长的文字 在界面上显示 1000 次，不难完成吧 // ..省略一些无关代码body: Text('一段又臭又长的文字' * 1000, softWrap: true) 很简单，运行到手机…「诶诶诶，**，怎么只显示了一部分，剩下的怎么画不下去」 日常开发中，会遇到很多这种情况，许多界面不是一页就能够显示完的。那么这里提下可滑动的容器部件 SingleChildScrollView这个部件非常简单，不贴源码了。最简单的使用方式只需要提供一个 child 即可。现在给前面写的 Text 包裹上一层 SingleChildScrollView 然后再运行，文字全部都展示出来了。 如果需要实现一个垂直的滚动列表，可以直接通过 SingleChildScrollView 包裹 Column 来实现，列表内容全部塞到 Column 即可 class SingleChildScrollDemoPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; /// letters 自由发挥吧...一定要大量，大量，大量 List&lt;String&gt; letters = [......]; return Scaffold( appBar: AppBar( title: Text('Single Child Demo'), ), body: SingleChildScrollView( child: Center( child: Column( children: List.generate( letters.length, (index) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Text(letters[index], style: TextStyle(fontSize: 18.0)), )), ), )), ); &#125;&#125; 运行结果会根据你的 letters 不同而不同，这边就不贴效果图了，反正你可以看到一串列表… 那么如果需要实现横向滚动列表呢，稍稍做下修改就行了 body: SingleChildScrollView( // 设置滚动方向 scrollDirection: Axis.horizontal, child: Center( // 修改为 `Row` 即可 child: Row( children: List.generate( letters.length, // 如果你的 letters 数量比较少，推荐加个 `Container` 把宽度指定大点 (index) =&gt; Container( child: Padding( padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 6.0), child: Text(letters[index], style: TextStyle(fontSize: 18.0)), ), width: 30.0)), ), )) 效果图也不贴了，都比较简单。 该部分代码查看 single_child_scroll_main.dart 文件* ListView平时开发 Android 的时候，如果有相同格式的列表要实现，一般会使用 ListView 或者 RecyclerView 来实现，Flutter 也提供了类似的部件 ListView 实现 ListView 的方法主要有 通过 ListView 设置 children 属性实现 通过 ListView.custom 实现 通过 ListView.builder 实现 通过 ListView.separated 实现带分割线列表 ListView children第一种方法实现列表，和通过 SingleChildScrollView + Column / Row 的方法比较类似，不过可以直接通过指定 ListView 的 scrollDirection 就可以了。 body: ListView( // 通过修改滑动方向设置水平或者垂直方向滚动 scrollDirection: Axis.vertical, // 通过 iterable.map().toList 和 List.generate 方法效果是一样的 children: letters .map((s) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: Center( child: Text(s)))) .toList()), ListView.custombody: ListView.custom( // 指定 item 的高度，可以加快渲染的速度 itemExtent: 40.0, // item 代理 childrenDelegate: SliverChildBuilderDelegate( // IndexedWidgetBuilder，根据 index 设置 item 中需要变化的数据 (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.red))), // 指定 item 的数量 childCount: letters.length, )), 如果每个 item 的高度可以确定，那么推荐通过 itemExtent 来设置 item 的高度/宽度，能够加快 ListView 的渲染速度。如果不指定高度/宽度，ListView 需要根据每个 item 来计算 ListView 的高度，这个计算过程是需要消耗时间和资源的 ListView.builder该方法同 custom 类似，custom 需要通过一个 Delegate 生成 item，该方法直接通过 builder 生成，同时也可以直接指定 item 的高度 body: ListView.builder( itemBuilder: (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.green))), itemExtent: 40.0, itemCount: letters.length),)), 相对比较简单，代码也比较少…就冲这点，我也愿意用这个方法 ListView.separated如果需要在每个 item 之间添加分割线，那么通过以上的方式实现就比较困难了，所以 Flutter 提供了 separated 方法用来快速构建带有分割线的 ListView 加入我们的 item 之间的分割线需要如下样式：奇数位和偶数位之间用黑色分割线，偶数位和奇数位之间用红色分割线 // 需要分割线的时候才使用，不能指定 item 的高度body: ListView.separated( itemBuilder: (_, index) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Center(child: Text(letters[index], style: TextStyle(color: Colors.blue))), ), // 这里用来定义分割线 separatorBuilder: (_, index) =&gt; Divider(height: 1.0, color: index % 2 == 0 ? Colors.black : Colors.red), itemCount: letters.length), 最终的效果如下： 以上代码查看 listview_main.dart 文件 总结下：如果 item 的高度能够准确获取，一定要指定 itemExtent 的值，这样会更加高效，至于要通过哪种方式来生成，完全看个人喜好吧。 ExpansionTile既然讲到了 ListView，在日常开发中，折叠列表也是一个比较常用的，所以这边要提下 ExpansionTile 这个部件，因为相对比较简单，所以直接上代码了 class ExpansionTilesDemoPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('ExpansionTile Demo'), ), body: ExpansionTile( // 最前面的 widget leading: Icon(Icons.phone_android), // 替换默认箭头// trailing: Icon(Icons.phone_iphone), title: Text('Parent'), // 默认是否展开 initiallyExpanded: true, // 展开时候的背景色 backgroundColor: Colors.yellow[100], // 展开或者收缩的回调，true 表示展开 onExpansionChanged: (expanded) =&gt; print('ExpansionTile is $&#123;expanded ? 'expanded' : 'collapsed'&#125;'), children: List.generate( 10, (position) =&gt; Container( padding: const EdgeInsets.only(left: 80.0), child: Text('Children $&#123;position + 1&#125;'), height: 50.0, alignment: Alignment.centerLeft, )), ), ); &#125;&#125; 这样就完成了一个折叠部件，看下最后的效果 那么实现折叠列表也就是通过 ListView 创建一个 ExpansionTile 列表即可，先准备下模拟的数据 final _keys = ['ParentA', 'ParentB', 'ParentC', 'ParentD', 'ParentE', 'ParentF']; final Map&lt;String, List&lt;String&gt;&gt; _data = &#123; 'ParentA': ['Child A0', 'Child A1', 'Child A2', 'Child A3', 'Child A4', 'Child A5'], 'ParentB': ['Child B0', 'Child B1', 'Child B2', 'Child B3', 'Child B4', 'Child B5'], 'ParentC': ['Child C0', 'Child C1', 'Child C2', 'Child C3', 'Child C4', 'Child C5'], 'ParentD': ['Child D0', 'Child D1', 'Child D2', 'Child D3', 'Child D4', 'Child D5'], 'ParentE': ['Child E0', 'Child E1', 'Child E2', 'Child E3', 'Child E4', 'Child E5'], 'ParentF': ['Child F0', 'Child F1', 'Child F2', 'Child F3', 'Child F4', 'Child F5'] &#125;; 在平时开发过程中，后台返回的数据应该是列表嵌套列表的形式比较多，我这边主要就是为了偷懒就随便弄了，接着修改下 body 的代码 body: ListView( children: _keys .map((key) =&gt; ExpansionTile( title: Text(key), children: _data[key] .map((value) =&gt; InkWell( child: Container( child: Text(value), padding: const EdgeInsets.only(left: 80.0), height: 50.0, alignment: Alignment.centerLeft, ), onTap: () &#123;&#125;)) .toList(), )) .toList()), 最终的效果就是个折叠列表了 该部分代码查看 expansion_tile_main.dart 文件 当然了，只要数据到位，别说两层折叠，三层，四层甚至更多层都能够实现，源码中有实现四层的 demo，这边就不贴代码了，有需要的小伙伴可以查看源码 GridView生成列表可以通过 ListView 来实现，那么同样，实现网格列表 Flutter 也提供了 GridView 来实现，实现 GridView 的方法也很多…我数了下，大概有 10 种..对你没看错，就是那么多，(诶诶诶，别走啊…虽然方法有点多，但是，大同小异) GridView GridView 需要一个 gridDelegate，gridDelegate 目前有两种 SliverGridDelegateWithFixedCrossAxisCount 看命名就知道，值固定数量的，这个数量是只单排的数量 SliverGridDelegateWithMaxCrossAxisExtent 这个是设置最大宽度/高度，在这个值范围内取最大值，比如一排能给你排下 6 个，但是远不到设置的最大值，它绝不给你排 6 个 那么接下来的使用就比较简单了 class GridViewDemoPage extends StatelessWidget &#123; // 自行设置 final List&lt;String&gt; letters = [ ..... ]; // 用于区分网格单元 final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('GridView Demo'), ), body: GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, // 单行的个数 mainAxisSpacing: 10.0, // 同 scrollDirection 挂钩，item 之间在主轴方向的间隔 crossAxisSpacing: 10.0, // item 之间在副轴方法的间隔 childAspectRatio: 1.0 // item 的宽高比 ), // 需要根据 index 设置不同背景色，所以使用 List.generate，如果不设置背景色，也可用 iterable.map().toList children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, child: Text(letters[index]), color: colors[index % 4], )), ), ); &#125;&#125; 关键地方已经添加了注释，跑下运行效果 接下来换一种 delegate 试试效果，当然这个最大值可以根据个人喜好来设置 body: GridView( // 通过设置 `maxCrossAxisExtent` 来指定最大的宽度，在这个值范围内，会选取相对较大的值 gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent( maxCrossAxisExtent: 60.0, crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0), children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, child: Text(letters[index]), color: colors[index % 4], )), ) 最后效果： 为了方便写法呢，Flutter 对以上的两种方式进行了封装，省略了 delegate GridView.count/GridView.extent 直接看下如何修改 // 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithFixedCrossAxisCount` 代理的方法 body: GridView.count( crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0, crossAxisCount: 5, childAspectRatio: 2.0, children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ))), // 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithMaxCrossAxisExtent` 代理的方法 body: GridView.extent( crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0, maxCrossAxisExtent: 60.0, children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ))), 运行的效果入和前面的相同 GridView.custom 这种生成方式，比 GridView 多了一个 childrenDelegate，childrenDelegate 主要分为两种，一种是通过 IndexedWidgetBuilder 来构建 item 的 SliverChildBuilderDelegate，还有一种是通过 List 来构建 item 的 SliverChildListDelegate，所以…这边直接有 4 中生成方式，当然，我们只需要了解 childrenDelegate 如何使用即可 body: GridView.custom( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 1.0), // item 通过 delegate 来生成，内部实现还是 `IndexedWidgetBuilder` childrenDelegate: SliverChildBuilderDelegate( (_, index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ), childCount: letters.length)), body: GridView.custom( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 1.0), // 内部通过返回控件列表实现 childrenDelegate: SliverChildListDelegate( List.generate( letters.length, (index) =&gt; Container( child: Text(letters[index]), alignment: Alignment.center, color: colors[index % 4], )), )), 运行效果也同上面。 GridView.builder 前面介绍的方法中，生成 item 的方式基本上是通过 List 进行转换的，在 custom 提到了 IndexWidgetBuilder 的生成方式，当然，在 ListView 的时候也用到了这种生成方式，当然 GridView 也有啊，要「雨露均沾」你说是吧 // 通过 `IndexedWidgetBuilder` 来构建 item，别的参数同上 body: GridView.builder( // 这里又需要分两种 `gridDelegate` gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0), itemCount: letters.length, itemBuilder: (_, index) =&gt; Container(color: colors[index % 4], child: Text(letters[index]), alignment: Alignment.center)), 到这 10 种方式就说完了。终于可以歇一口气了。 该部分代码查看 gridview_main.dart 文件 CustomScrollView在平时的开发中，应该会遇到这么种情况，头部是一个 GridView 接下来拼接一些别的部件，然后再拼接一个列表，例如下图 因为 GridView 和 ListView 亮着都是可滑动的部件，直接拼接肯定会有「滑动冲突」，所以 Flutter 就提供了一个粘合剂，CustomScrollView，那么 Flutter 如何实现呢，因为会涉及到 Sliver 系列部件，所以这边先看下大概的代码，下节会补充 Sliver 系列部件的内容 class CustomScrollDemoPage extends StatelessWidget &#123; // 这边用的 A-Z 字母 final List&lt;String&gt; letters = [ ..... ]; final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('CustomScrollDemo'), ), body: CustomScrollView( // 这里需要传入 `Sliver` 部件，下节课填坑 slivers: &lt;Widget&gt;[ // SliverGrid 实现同 GridView 实现方式一样 // 同样 SliverGrid 有提供 `count`, `entent` 方法便于快速生成 SliverGrid SliverGrid( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Image.asset('images/ali.jpg'), onTap: () &#123;&#125;, ), childCount: 8), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 4, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0)), // 这里下节讲 SliverToBoxAdapter( child: Container( color: Colors.black12, margin: const EdgeInsets.symmetric(vertical: 10.0), child: Column(children: &lt;Widget&gt;[ Divider(height: 2.0, color: Colors.black54), Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), Text('我是一些别的东西..例如广告', textScaleFactor: 1.5, style: TextStyle(color: Colors.red)) ], ), Divider(height: 2.0, color: Colors.black54), ], mainAxisAlignment: MainAxisAlignment.spaceBetween), alignment: Alignment.center)), // SliverFixedExtentList 实现同 List.custom 实现类似 SliverFixedExtentList( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Container( child: Text(letters[index] * 10, style: TextStyle(color: colors[index % colors.length], letterSpacing: 2.0), textScaleFactor: 1.5), alignment: Alignment.center, ), onTap: () &#123;&#125;, ), childCount: letters.length), itemExtent: 60.0) ], ), ); &#125;&#125; 该部分代码查看 custom_scroll_main.dart 文件 滑动部件其实还有好几个，但是以上介绍的在平时开发过程中够用了，如果后期发现还需要别的部件，我会继续补上。在结束前，我们再说下如何通过 ScrollController 来控制 Scrollable 的滚动位置。例如我们需要实现，当滚动的距离大于一定距离的时候显示一个回到顶部的按钮，有了 ScrollController 就能够非常方便的实现 ScrollController因为需要根据滑动的距离显示回到顶部按钮，那么就需要通过一个状态位来控制按钮显隐 class ScrollControllerDemoPage extends StatefulWidget &#123; @override _ScrollControllerDemoPageState createState() =&gt; _ScrollControllerDemoPageState();&#125;class _ScrollControllerDemoPageState extends State&lt;ScrollControllerDemoPage&gt; &#123; var _scrollController = ScrollController(); var _showBackTop = false; @override void initState() &#123; super.initState(); // 对 scrollController 进行监听 _scrollController.addListener(() &#123; // _scrollController.position.pixels 获取当前滚动部件滚动的距离 // window.physicalSize.height 获取屏幕高度 // 当滚动距离大于 800 后，显示回到顶部按钮 setState(() =&gt; _showBackTop = _scrollController.position.pixels &gt;= 800); &#125;); &#125; @override void dispose() &#123; // 记得销毁对象 _scrollController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('ScrollController Demo'), ), body: ListView( controller: _scrollController, children: List.generate( 20, (index) =&gt; Container(height: 50.0, alignment: Alignment.center, child: Text('Item $&#123;index + 1&#125;'))), ), floatingActionButton: _showBackTop // 当需要显示的时候展示按钮，不需要的时候隐藏，设置 null ? FloatingActionButton( onPressed: () &#123; // scrollController 通过 animateTo 方法滚动到某个具体高度 // duration 表示动画的时长，curve 表示动画的运行方式，flutter 在 Curves 提供了许多方式 _scrollController.animateTo(0.0, duration: Duration(milliseconds: 500), curve: Curves.decelerate); &#125;, child: Icon(Icons.vertical_align_top), ) : null, ); &#125;&#125; 最后的效果图]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(六)路由]]></title>
    <url>%2Fposts%2Fb89d6378.html</url>
    <content type="text"><![CDATA[上一节撸了个界面，虽然比较简单，但是把前面讲的知识串联了下，但是界面之间的跳转一直没说，这节就讲下 Flutter 中的「路由」来管理界面。 1、NavigatorFlutter 通过 Navigator 来进行页面之间的跳转，分为 push 系列和 pop 系列操作，带 push 方法为入栈操作，带 pop 方法为出栈操作。Navigator 的 push 方法分两类，一类是带 Name 的，需要在 MaterialApp 下将 routers 属性进行注册，否则将会找不到该路由，还有一个是不带 Name 的，可以通过 Router 直接跳转。 说那么多相信还不如直接上代码和图来的更直接。因为需要展示所有的跳转至少需要 3 个页面，所以我们创建最简单的三个界面，通过文字来区别不同的页面，因为需要调用带有 Name 的方法，所以需要先在 MaterialApp 对路由进行注册。 class DemoApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Learning Demo', // 在这里注册路由，关联 name 和界面 // '/' 表示根页面，也就是 home 所对应的页面，这边就不需要配置 home 属性了 routes: &#123;'/': (_) =&gt; APage(), '/page_b': (_) =&gt; BPage(), '/page_c': (_) =&gt; CPage()&#125;, debugShowCheckedModeBanner: false, ); &#125;&#125;/// Page A，Button 的跳转事件等会进行修改，目前先空着class APage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page A'), ), body: Center(child: RaisedButton(onPressed: () &#123;&#125;, child: Text('To Page B'))), ); &#125;&#125;/// Page Bclass BPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page B'), ), body: Center( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton(onPressed: () &#123;&#125;, child: Text('To Page C')), RaisedButton(onPressed: () &#123;&#125;, child: Text('Back Page A')) ])), ); &#125;&#125;/// Page Cclass CPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page C'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[RaisedButton(onPressed: () &#123;&#125;, child: Text('Back Last Page'))])), ); &#125;&#125; push / pushNamed 方式跳转 我们在 APage 的 RaiseButton 的 onPressed 方法加入如下代码 Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage())); 或者 Navigator.pushNamed(context, '/page_b'); 效果相同。跳转后，可以发现，在 BPage 的 AppBar 上有个返回按钮，点击可以返回 APage ，那么也就是说通过 push 或者 pushNamed 方式跳转的时候，界面堆栈的变化是直接在原来的堆栈上添加一个新的 page 为了凸显堆栈的变化，所以绘制的图中，会比使用的实际页面多一个，下图同 pushReplacement / pushReplacementNamed / popAndPushNamed 将 APage 中的跳转方式进行替换 Navigator.pushReplacement(context, MaterialPageRoute(builder: (_) =&gt; BPage())); 或者 Navigator.pushReplacementNamed(context, '/page_b'); 或者 / 如果是第一个界面跳转到下个界面，勿用，`BPage` 会显示返回按钮，但是点击后，界面会变黑// 因为 `APage` 已经不在堆栈中了，点击后堆栈就没有 `Page` 了，所以界面变黑Navigator.popAndPushNamed(context, '/page_b'); 效果相同，跳转后，可以发现 BPage 的返回按钮消失了，消失了，消失了，我们可以试下点击返回按键，发现 App 直接退出了，也就是说，BPage 替代了 APage 在堆栈中的位置。那么堆栈的变化图就是这样的 pushAndRemoveUntil / pushNamedAndRemoveUntil CASE 1 这个跳转方式需要通过 CPage 来协助完成，将 APage 的跳转方式修改为 push 方式，然后在 BPage 的第一个按钮加入如下代码 Navigator.pushAndRemoveUntil(context, MaterialPageRoute(builder: (_) =&gt; CPage()), (Route router) =&gt; false); 或者 Navigator.pushNamedAndRemoveUntil(context, '/page_c', (Route router) =&gt; false); 效果相同，点击 BPage 的跳转 CPage 按钮后，界面来到 CPage，然后发现还是没有返回按钮，没有返回按钮，没有返回按钮，点击下返回按键，然后发现 App 直接退出了，退出了，退出了，那么堆栈变化如图 CASE 2 你以为这两个方法只是为了把堆栈都清空吗，那就太图样图森破了，这边展示另一种。修改跳转的代码 Navigator.pushAndRemoveUntil(context, MaterialPageRoute(builder: (_) =&gt; CPage()), ModalRoute.withName('/')); 或者 Navigator.pushNamedAndRemoveUntil(context, '/page_c', ModalRoute.withName('/')); 点击跳转 CPage 以后，发现返回按钮又回来了…就这么回来了…只是修改了一个参数，点击返回按钮，又回到了 APage，你可以在 APage 跳转 BPage 中加入DPage EPage 等等更多的界面，只要保证 BPage 跳转 CPage 的方式不变，点击 CPage 的返回按钮，又回到 APage 了，所以…堆栈的变化图如下 SUMMARY 为什么会这样变化呢，还记得在 MaterialApp 中注册的 router 么，APage 的 name 对应的为 ‘/‘，也就是说，该方法会把堆栈中在 ModalRoute.withName 所对应的 page 上的所有都 pop 出堆栈，如果把参数换成 /page_b，然后在跳转 CPage 之前加入更多的界面，点击 CPage 的返回按钮，就会回到 BPage pop 在 BPage 的第二个按钮中加入 pop 操作 Navigator.pop(context); 跳转到 BPage 后点击该按钮，界面回到 APage，那么堆栈的变化很明显了，如图 popUntil 这个方法还需要借助 CPage ，在 CPage 的按钮中加入 Navigator.popUntil(context, ModalRoute.withName('/')); 点击返回按钮，界面跳过 BPage 回到了 APage，解释同 pushAndRemoveUntil 那么堆栈的变化也显而易见咯 2、Navigator 传值CASE 1 传值给下个界面 修改下 BPage 和 APage 的按钮点击事件 class BPage extends StatelessWidget &#123; final String message; BPage(&#123;Key key, @required this.message&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; print('passed value: $message'); return Scaffold( // 省略相同代码 ); &#125;&#125;// APage 跳转事件Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage(message: 'Message From Page A'))); 点击 APage 可以查看控制台有输出 2019-03-17 00:04:06.854 12868-12888/com.kuky.demo.flutterartsdemosapp I/flutter: passed value: Message From Page A 也就是成功把值传递过来了。但是，需要传递参数的话，之前在 MaterialApp 下注册的路由就需要去除了。 CASE 2 传值给上个界面 这边可以查看下 pop 方法 @optionalTypeArgs // pop 可以传入一个可选参数 result，这个 result 也就是回传给上个页面的参数值了 static bool pop&lt;T extends Object&gt;(BuildContext context, [ T result ]) &#123; return Navigator.of(context).pop&lt;T&gt;(result); &#125; 既然知道 pop 如何传递值给上个界面，那么如何在上个界面接收这个参数呢，还是看下 push 方法 @optionalTypeArgs static Future&lt;T&gt; push&lt;T extends Object&gt;(BuildContext context, Route&lt;T&gt; route) &#123; return Navigator.of(context).push(route); &#125;///@optionalTypeArgs Future&lt;T&gt; push&lt;T extends Object&gt;(Route&lt;T&gt; route) &#123; // ...省略无关代码 // 这边返回一个 Future 值，`pop` 所传递的值会在这边返回 return route.popped; &#125;/// The future completes with the value given to [Navigator.pop], if any.Future&lt;T&gt; get popped =&gt; _popCompleter.future; 官方的注释非常明白的指出，会在 Future 中携带 pop 传递的参数，那么我们对 APage跳转 BPage 以及 BPage 返回 APage 的逻辑进行修改 /// APageNavigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage(message: 'Message From Page A'))) .then((value) =&gt; print('BACK MESSAGE =&gt; $value')); /// BPageNavigator.pop(context, 'Message back to PageA From BPage'); 点击返回后，能够在控制台发现有如下输入 2019-03-17 16:35:53.820 13417-13442/com.kuky.demo.flutterartsdemosapp I/flutter: BACK MESSAGE =&gt; Message back to PageA From BPage 上个页面成功接收到下个页面回传的数据。 CASE 3 通过系统返回按钮传值 在 CASE 2 情况下，通过按钮对返回事件进行监听，那加入我们需求没有这个按钮，只能通过系统默认的返回按钮，或者物理返回按键，那该如何传值呢，这里就需要用 WillpopScope 对系统的返回按钮进行监听。我们对 CPage 做下修改，在 Scaffold 外面包裹一个 WillpopScope class CPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return WillPopScope( child: Scaffold( appBar: AppBar( title: Text('Page C'), ), body: Center( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123; Navigator.popUntil(context, ModalRoute.withName('/')); &#125;, child: Text('Back Last Page')) ])), ), // 这里对系统返回按钮做监听.. // 如果返回的是 `true` 则相当于 `pop` 操作，返回 `false` 则只执行上一步的 `pop` 操作 // 例如双击返回退出，也是通过 `WillpopScope` 来进行监听 onWillPop: () async &#123; Navigator.pop(context, 'Hello~'); return false; &#125;); &#125;&#125; 通过返回按钮，BPage 会成功收到从 CPage 返回的 Hello~ 值 以上代码查看 router_main.dart 文件 3、路由切换动画假如说我们不想用系统自带的切换动画，需要弄一些比较酷炫的效果该怎么办，那就需要用到自定义路由切换动画了。直接修改 BPage 跳转 CPage 的代码 Navigator.push( context, PageRouteBuilder( // 返回目标页面 pageBuilder: (context, anim, _) =&gt; CPage(), // 切换动画的切换时长 transitionDuration: Duration(milliseconds: 500), // 切换动画的切换效果，系统自带的常用 Transition // ScaleTransition: 缩放 SlideTransition: 滑动 // RotationTransition: 旋转 FadeTransition: 透明度 transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( // Tween 是 flutter 的补间动画，等讲到动画的时候再提吧，这边先记住这么使用 scale: Tween(begin: 0.0, end: 1.0).animate(anim), // 这个值必须记得要传，否则会不显示界面 child: child, ))); 当再次点击跳转的时候，切换的动画就有开始自带的平滑效果变成缩放效果了。那如果要实现多个动画呢，例如边缩放，边改变透明度，也很容易实现，只需要将 child 替换成 Transition 即可 Navigator.push( context, PageRouteBuilder( pageBuilder: (context, anim, _) =&gt; CPage(), transitionDuration: Duration(milliseconds: 500), transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( scale: Tween(begin: 0.0, end: 1.0).animate(anim), // 替换即可，如果要加入更多的动画，替换 `child` 属性就可以了 child: FadeTransition( opacity: Tween(begin: 0.0, end: 1.0).animate(anim), child: child, ), ))); 当然，为了方便重复利用，需要进行封装，例如我们要封装上面的缩放动画效果 class ScalePageRoute extends PageRouteBuilder &#123; final Widget widget; ScalePageRoute(this.widget) : super( transitionDuration: Duration(milliseconds: 500), pageBuilder: (context, anim, _) =&gt; widget, transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( scale: Tween(begin: 0.0, end: 1.0).animate(anim), child: child, ));&#125; 然后直接在 Navigator 跳转的时候调用该 Route 就可以了 该部分代码查看 custom_routes.dart 文件 还记得我们之前写的 demo 都是单个文件写一个入口的吗，现在我们就可以写一个统一管理的页面，对这些界面进行管理了，这个工作就交给大家伙自己了，当然我也在源码做了修改，可以查看 main.dart 文件 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(五)输入处理及登录界面实战]]></title>
    <url>%2Fposts%2F4b62f141.html</url>
    <content type="text"><![CDATA[前面提到基础部件的时候，忘了提输入内容处理部件，这里补上，然后顺带撸个实际的界面吧 1、TextFieldconst TextField(&#123; Key key, this.controller, // 定义一个 `TextEditingController` 实例，用来获取输入框内容等操作 this.focusNode, // 定义一个 `FocusNode` 实例，判断当前输入框是否获取到焦点等操作 this.decoration = const InputDecoration(), // 输入框样式，包括提醒字样，hint 等等 TextInputType keyboardType, // 输入文本类型，例如 数字，email 等等 this.textInputAction, // 键盘确认按钮的事件类型 this.textCapitalization = TextCapitalization.none, this.style, // 文字样式 this.textAlign = TextAlign.start, // 对齐方式 this.textDirection, // 文字方向 this.autofocus = false, // 是否自动获取焦点 this.obscureText = false, // 文字是否隐藏，多用于密码 this.autocorrect = true, this.maxLines = 1, // this.maxLength, // 最大长度 this.maxLengthEnforced = true, // 设置最大长度后，输入内容超出后是否强制不给输入 this.onChanged, // 输入内容发生变化时候的回调 this.onEditingComplete, // 输入完毕的回调 this.onSubmitted, // 提交内容的回调 this.inputFormatters, // this.enabled, // 是否可输入，false 不可输入 this.cursorWidth = 2.0, // 游标宽度 this.cursorRadius, // 游标半径 this.cursorColor, // 游标颜色 this.keyboardAppearance, // 该属性只在 iOS 设备有效 this.scrollPadding = const EdgeInsets.all(20.0), this.enableInteractiveSelection, this.onTap, // 点击事件 &#125;) 那么，简单的来个输入框示例吧，然后通过 Text 展示结果 class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; // 可以传入初始值 TextEditingController _editController = TextEditingController(); FocusNode _editNode = FocusNode(); // 保存按钮点击后的输入内容值 String _content = ''; // 监听输入内容变化的内容值 String _spyContent = ''; @override void initState() &#123; super.initState(); // 当输入框获取到焦点或者失去焦点的时候回调用 _editNode.addListener(() &#123; print('edit has focus? =&gt; $&#123;_editNode.hasFocus&#125;'); &#125;); &#125; @override void dispose() &#123; // 记得销毁，防止内存溢出 _editController.dispose(); _editNode.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Input Content'), ), body: Container( padding: const EdgeInsets.symmetric(horizontal: 12.0), child: Column( children: &lt;Widget&gt;[ TextField( controller: _editController, focusNode: _editNode, decoration: InputDecoration( icon: Icon(Icons.phone_iphone, color: Theme.of(context).primaryColor), labelText: '请输入手机号', helperText: '手机号', hintText: '手机号...在这儿输入呢'), keyboardType: TextInputType.number, // 输入类型为数字类型 textInputAction: TextInputAction.done, style: TextStyle(color: Colors.redAccent, fontSize: 18.0), textDirection: TextDirection.ltr, maxLength: 11, // 最大长度为 11 maxLengthEnforced: true, // 超过长度的不显示 onChanged: (v) &#123; // 输入的内容发生改变会调用 setState(() =&gt; _spyContent = v); &#125;, onSubmitted: (s) &#123; // 点击确定按钮时候会调用 setState(() =&gt; _spyContent = _editController.value.text); &#125;, ), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: RaisedButton( onPressed: () &#123; // 获取输入的内容 setState(() =&gt; _content = _editController.value.text); // 清理输入内容 _editController.clear(); setState(() =&gt; _spyContent = ''); &#125;, child: Text('获取输入内容'))), // 展示输入的内容，点击按钮会显示 Text(_content.isNotEmpty ? '获取到输入内容: $_content' : '还未获取到任何内容...'), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), // 监听输入内容的变化，会跟随输入的内容进行改变 child: Text('我是文字内容监听：$_spyContent'), ) ], )), ); &#125;&#125; 这边需要提下的是 setState 方法，该方法只有 StatefulWidget 才有，当需要修改某个值的内容的时候，通过该方法进行修改，最后的效果图如下，当输入框文字发生变化的时候，监听的 Text 内容会随之改变，获取内容的 Text 当点击按钮了才发生变化 该部分代码查看 text_field_main.dart 文件 那么如果有个需求，在点击按钮的时候需要对输入的内容的合理性进行检测，当然可以通过 TextEditingController 的结果进行检测，但是还有个更加方便的方法，可以直接使用部件 TextFormField 来实现，不过需要我们在外层加一个 Form 部件，接下来，就要准备通过 TextFormField 来撸一个登录界面，但是这之前，前面有个坑需要先解决下 2、导入自定义的图标在这之前，涉及到 Icon 部件，都是使用的系统自带的图标，那么如何导入第三方自定义图标呢，马上为你揭晓答案，首先我们需要打开「阿里妈妈」也就是 iconfont，不知道的小伙伴通过链接打开，然后需要注册个账户，也可以直接通过 Github 等三方登录，然后就可以搜索我们需要的图标了，接下来需要撸一个登录，那我们就找一个 用户 和 密码 的图标吧，选择喜欢的图标，然后鼠标放到图标会出现三个按钮，直接点击 购物车 那个按钮，然后就可以通过顶部的 购物车 按钮查看添加的图标，点击下载代码，把资源文件下载到本地。 解压后，需要用到的文件有两个，别的可以忽略 demo_index.html 这边用来查看图标的 unicode iconfont.ttf 这边就是图标资源文件了 回到项目，创建一个文件夹 fonts ，和 images 同级，将 iconfont.ttf 文件放到该文件夹下，然后打开 pubspec.ymal 文件，注册下导入的资源，可以自己命名 iconfont.ttf 文件名，便于自己发现就行，例如我命名为 third_part_icon.ttf，在注册图片下面继续添加 fonts: - family: ThirdPartIcons fonts: - asset: fonts/third_part_icon.ttf 注册完了记得点击 Package get，否则会找不到资源。接着新建个 third_icons.dart文件 import 'package:flutter/material.dart';class ThirdIcons &#123; // codePoint 值通过打开 `demo_index.html` 获取 // 会在相应 icon 下带有相应的 code，把 `&amp;#` 替换成 `0`，然后去掉最后的 `;` 即可 // 例如 &amp;#xe672; 对应我们需要的图标就是 0xe672 static const IconData username = ThirdIconData(0xe672); static const IconData password = ThirdIconData(0xe62f);&#125;class ThirdIconData extends IconData &#123; // fontFamily 就是我们在 `pubspec.yaml` 中注册的 family 值 const ThirdIconData(int codePoint) : super(codePoint, fontFamily: 'ThirdPartIcons');&#125; 接下来就可以通过该类导入需要的第三方图标了。 3、导入第三方插件其实 Flutter 中缺少很多功能，需要通过导入第三方插件来实现功能，插件就是 Flutter 和原生交互的桥梁，也就是说，要写 Flutter 的插件，需要写 Android 和 iOS 两端代码才可，否则只有在其中一个端能够实现功能。好在有很多现成的插件已经开源，可以通过 FlutterPackage 搜索到，例如等会我们会需要用到 FlutterToast 这个插件，用来做提醒用，在 FlutterPackage 中搜索到插件后，打开项目中的 pubspec.ymal 文件，在 dependencies 类目下将 fluttertoast 插件引入，如图： 然后点击 Package get 让其导入即可，别的插件也是这样导入。做好准备工作，我们就可以撸一个登录界面了~ 4、撸一个登录界面在开撸之前，我们先看下最终的效果图吧，虽然是比较常用的界面 因为两个界面比较相似，所以这边只贴外层的代码和登录的代码，具体的代码，可以查看源码，已经推到 Github void main() &#123; runApp(LoginApp()); if (Platform.isAndroid) &#123; var style = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(style); &#125;&#125;/// 外层界面，包裹登录界面和注册界面，使用的都是前面讲过的，忘记可以查看之前的章节class LoginApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Login Demo', debugShowCheckedModeBanner: false, theme: ThemeData(primarySwatch: Colors.lightBlue), home: LoginHomePage(), ); &#125;&#125;class LoginHomePage extends StatefulWidget &#123; @override _LoginHomePageState createState() =&gt; _LoginHomePageState();&#125;class _LoginHomePageState extends State&lt;LoginHomePage&gt; with SingleTickerProviderStateMixin &#123; TabController _tabController; List&lt;String&gt; _pageIndicators = ['登录', '注册']; List&lt;Widget&gt; _pages = []; int _position = 0; @override void initState() &#123; super.initState(); _tabController = TabController(length: _pageIndicators.length, vsync: this); // 将登录界面和注册界面添加到列表，用于放到 IndexStack 的 children 属性 _pages..add(LoginPage())..add(RegisterPage()); _tabController.addListener(() &#123; // 当 tab 切换的时候，联动 IndexStack 的 child 页面也进行修改，通过 setState 来修改值 if (_tabController.indexIsChanging) setState(() =&gt; _position = _tabController.index); &#125;); &#125; @override void dispose() &#123; super.dispose(); &#125; @override Widget build(BuildContext context) &#123; // 先忽略... return Theme( data: ThemeData(primarySwatch: Colors.pink, iconTheme: IconThemeData(color: Colors.pink)), child: Scaffold( body: Container( padding: const EdgeInsets.all(20.0), alignment: Alignment.center, decoration: BoxDecoration(image: DecorationImage(image: AssetImage('images/login_bg.png'), fit: BoxFit.cover)), // 先忽略...下面会讲，主要是解决软键盘弹出的时候，界面内容会溢出的问题 child: SingleChildScrollView( child: SafeArea( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 顶部页面切换指示器，代码可以参考 `app_bar_main.dart` 文件 TabBar( indicatorSize: TabBarIndicatorSize.label, controller: _tabController, indicatorWeight: 4.0, indicatorColor: Colors.white, // 返回 tab 列表 tabs: _pageIndicators .map((v) =&gt; Text(v, style: TextStyle(color: Colors.white, fontSize: 24.0))) .toList()), Padding( padding: const EdgeInsets.only(top: 30.0), child: SizedBox( // 切换界面列表 child: IndexedStack(children: _pages, index: _position), // 指定高度 height: MediaQuery.of(context).size.height / 2)) ])), ), ), )); &#125;&#125;/// 登录界面class LoginPage extends StatefulWidget &#123; @override _LoginPageState createState() =&gt; _LoginPageState();&#125;class _LoginPageState extends State&lt;LoginPage&gt; &#123; // 用于后面判断表单内容是否有效 GlobalKey&lt;FormState&gt; _formKey = GlobalKey(); // 用于获取输入框的内容 TextEditingController _usernameController = TextEditingController(); TextEditingController _passwordController = TextEditingController(); @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; // 防止内存溢出，记得销毁..销毁..销毁 _usernameController.dispose(); _passwordController.dispose(); super.dispose(); &#125; _login() &#123; // 取消焦点 FocusScope.of(context).requestFocus(FocusNode()); // 判断表单是否有效 if (_formKey.currentState.validate()) &#123; // 获取输入框内容 var username = _usernameController.value.text; var password = _passwordController.value.text; // 判断登录条件 if (username == 'kuky' &amp;&amp; password == '123456') // 引入的三方插件方法，`Flutter` 没有自带的 `Taost` Fluttertoast.showToast(msg: '登录成功'); else Fluttertoast.showToast(msg: '登录失败'); &#125; &#125; @override Widget build(BuildContext context) &#123; return Form( // 将 key 设置给表单，用于判断表单是否有效 key: _formKey, child: Column( children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), // 表单输入框，参数同 TextField 基本类似 child: TextFormField( controller: _usernameController, style: TextStyle(color: Colors.white, fontSize: 16.0), decoration: InputDecoration( icon: Icon(ThirdIcons.username, size: 24.0, color: Colors.white), labelText: '请输入用户名', labelStyle: TextStyle(color: Colors.white), helperStyle: TextStyle(color: Colors.white)), // 有效条件(为空不通过，返回提示语，通过返回 null) validator: (value) =&gt; value.trim().isEmpty ? '用户名不能为空' : null, ), ), Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: TextFormField( obscureText: true, controller: _passwordController, style: TextStyle(color: Colors.white, fontSize: 16.0), decoration: InputDecoration( icon: Icon(ThirdIcons.password, size: 24.0, color: Colors.white), labelText: '请输入密码', labelStyle: TextStyle(color: Colors.white), helperStyle: TextStyle(color: Colors.white)), validator: (value) =&gt; value.trim().length &lt; 6 ? '密码长度不能小于6位' : null, ), ), Padding( padding: const EdgeInsets.only(top: 20.0), child: SizedBox( // 主要用于使 RaisedButton 和上层容器同宽 width: MediaQuery.of(context).size.width, child: RaisedButton( color: Colors.pink, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(4.0))), onPressed: _login, child: Text( '登录', style: TextStyle(color: Colors.white, fontSize: 20.0), )), ), ) ], )); &#125;&#125; 撸完界面后，可以试下登录效果，如果输入框的内容，和 TextFormField 的 validator的条件不符合，则会显示错误文字的提示 如果按照条件用户名为 kuky 密码为 123456 (条件可以根据自己进行修改)则会显示登录成功的逻辑 以上代码查看 login_home_page.dart 文件 注册界面的逻辑和登录界面的逻辑几乎一样，算是第一次实战了，望小伙伴能够好好的写一遍 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(四)常用布局]]></title>
    <url>%2Fposts%2F14587b6a.html</url>
    <content type="text"><![CDATA[上节填完了 Scaffold 留下的坑，这节继续填坑，之前留下关于 Layout 的坑，又是一堆部件袭来 1、Container为了让我们的界面更容易被扩展，通常会在最外层包裹一层 Container，其构造函数也不是很难理解 Container(&#123; Key key, this.alignment, // child 的对齐方式，包括左对齐，居中，右对齐，左上对齐..等等 this.padding, // child 和 Container 的边距 Color color, // Container 的背景色 Decoration decoration, // 样式，可以设置背景图，圆角等属性 this.foregroundDecoration, // child 的样式 double width, // 宽度 double height, // 高度 BoxConstraints constraints, // 默认使用 BoxConstraints.tightFor，可以手动传入 this.margin, // Container 同上层容器的边距 this.transform, // 是个 Matrix4 矩阵，(嗯..这个参数基本很少用，没怎么了解 /捂脸) this.child, // 需要展示的内容 &#125;)// ...const BoxConstraints.tightFor(&#123; double width, double height &#125;): minWidth = width != null ? width : 0.0, maxWidth = width != null ? width : double.infinity, minHeight = height != null ? height : 0.0, maxHeight = height != null ? height : double.infinity; 让我们写个圆角矩形的外层，内层值显示白色文字 class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, // 宽，高度同上层容器相同 width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, margin: const EdgeInsets.all(8.0), padding: const EdgeInsets.all(20.0), // Container 的样式 decoration: BoxDecoration( borderRadius: BorderRadius.circular(20.0), color: Colors.red,// shape: BoxShape.circle, // 该属性不可同 borderRadius 一起使用 backgroundBlendMode: BlendMode.colorDodge, // 背景图片和颜色混合模式 image: DecorationImage(image: AssetImage('images/ali.jpg'), fit: BoxFit.cover)), child: Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0)),// color: Theme.of(context).primaryColor, // 该属性不可和 decoration 一起使用 )), ); &#125;&#125; 效果图如下 该部分代码查看 column_main.dart 文件 看到这，应该很多小伙伴注意到 margin 和 padding 属性用来和别的部件保持间距，那…那我就是不用 Container 呢(专门来挑事的…)，当然没问题，有个专门用来设置间距的部件 Padding，看名字就可以看出来作用了，修改下 child 部分代码，这边先提前用下接下来会讲的部件 child: Column( children: &lt;Widget&gt;[ Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0)), Padding( // 需要传入一个间隔值，`Flutter` 提供了很多 EdgeInsets 来设置间隔， // 参数也很明确，可以一一尝试 padding: const EdgeInsets.symmetric(vertical: 12.0), // 传入需要间隔的部件 child: Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0))) ], ), 效果就不展示了，接下来就要开始我的填坑之旅了…. 2、Flex，Row，Column写 Android 的小伙伴应该比较常用 LinearLayout，在 Flutter 中用两个部件，Row Column来代替 Android 中的 LinearLayout，其中 Row 是横向布局，Column 是垂直布局，因为 Row 和 Column 都是继承于 Flex 部件，Flex 比他们多了 direction 属性用来指定方向，所以主要拿 Column 来讲解，Flex 、Row 用法相同 Column(&#123; Key key, // 对齐方式，对于 `Column` start 为顶部，对于 `Row` 需要分语言，和语言同向 // 3 种比较特殊的对齐方式，前端的小伙伴会了解， // spaceAround 两个部件之间的间隔是部件和上层容器间隔的两倍 // spaceBetween 两侧部件同上层容器间隔为 0，部件之间的间隔相等 // spaceEvenly 部件之间的间隔同两侧部件与上层容器间隔 MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, // 主轴的大小 CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, // 副轴对齐方式 TextDirection textDirection, // 文字方向，决定 start VerticalDirection verticalDirection = VerticalDirection.down, // 垂直方向 TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[], // 内部子部件 &#125;) Row 和 Column 都有主轴和副轴，如何区分呢，布局平行方向为主轴，垂直方向为副轴，我们把 Container 的 child 修改成 Column，然后把 Text 放到 Column 中，多放几个，然后自己设置 mainAxisAlignment 属性，查看布局的变化 // ... 省略相同代码child: Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ Text('Container Text 1', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 2', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 3', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 4', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 5', style: TextStyle(color: Colors.white, fontSize: 30.0)), ], ) 最后的效果图如下 这边 Column 内部的子部件因为高度相同，如果不同还需要等分空间的话，就不可以通过设置 mainAxisAlignment 属性来实现了，这里介绍一个等分的部件 Expanded const Expanded(&#123; Key key, int flex = 1, // 所占比例 @required Widget child, // 子部件 &#125;) 直接给 Text 外层加一个 Expanded 即可实现效果，当然可以按照需求来设置 flex 来修改比例值。 当然，在使用过程中也会遇到那么些坑，我们修改下代码，把 child 的代码修改成如下 child: Row( children: &lt;Widget&gt;[ Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)) ], ) 然后运行下，你的屏幕就提示你 RIGHT OVERFLOWED BY XXX PIXELS 「, ***」我猜你内心肯定这样的，冷静冷静 既然遇到问题，当然要解决，不然和产品去撕逼吗..？这边，我们把 Row 换成另一个布局 Wrap 然后再运行，Prefect，Wrap 和 Row 的参数基本类似 3、WrapWrap(&#123; Key key, this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, // 两个子部件之间的间隔，默认 0.0，如果值过大，可能导致原来同行的两个部件分行 this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, // 排布方向上 两个子部件的间隔 this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;) 当然，很多时候只有以上的布局是不行的，比如我们需要实现一个圆形头像，然后一段文字在其上面 ，例如下面的效果 接下来介绍一个堆叠的部件 Stack，源码比较简单，就不贴了，直接上效果代码 class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Stack( // 内部子部件的对齐方式 alignment: Alignment.center, children: &lt;Widget&gt;[ // 圆形头像，指定半径，指定背景图为头像即可 CircleAvatar(backgroundImage: AssetImage('images/ali.jpg'), radius: 100.0), Text( 'Kuky', style: TextStyle(color: Colors.white, fontSize: 34.0)), ], )), ); &#125;&#125; 如果我们需要第三个部件，底部距离圆形头像10px，那么只靠 alignment 是不可能实现了 所以，另外一个灰常流弊的部件就出来了 Positioned，其源码也比较简单，我还是不贴了吧~，还是直接上代码，直接修改 class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ CircleAvatar(backgroundImage: AssetImage('images/ali.jpg'), radius: 100.0), Text( 'Kuky', style: TextStyle(color: Colors.white, fontSize: 34.0), ), Positioned(child: Text('另外一段文字', style: TextStyle(color: Colors.white, fontSize: 20.0)), bottom: 10.0), // left, right, top, bottom 分别表示和 stack 的间距 ], )), ); &#125;&#125; 最后的效果图如下 很好，今天填了布局的这个大坑，而且讲的部件貌似还挺多的，虽然还是比较简单，剩下的就给小伙伴们慢慢消化今天的内容。 下节，除了有常用的部件外，我会尽量加上实战内容 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(三)快速搭建界面]]></title>
    <url>%2Fposts%2F5c762cf7.html</url>
    <content type="text"><![CDATA[上一篇讲完 Flutter 中的一些基本部件，这篇就先填完上篇留下的没写的 AppBar 的坑，以及 Scaffold 其他参数的使用，在开始前，先补一张缩略版的脑图 1、AppBar这一部分，我们只关注 Scaffold 中的 AppBar 剩下的还是埋坑【坑4】(，居然已经埋了那么多坑了，坑虽多，代码还是要继续的)，因为稍后会用到 StatefulWidget 的属性，所以就直接先使用了，和 StatelessWidget 区别用法可以这么记 需要数据更新的界面用 StatefulWidget，当然也不是绝对的，就是之前留的【坑1】所说的状态管理 class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, // 标题内容居中 automaticallyImplyLeading: false, // 不使用默认 leading: Icon(Icons.menu, color: Colors.red, size: 30.0), // 左侧按钮 flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), // 背景 title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), // 标题内容 // 末尾的操作按钮列表 actions: &lt;Widget&gt;[ PopupMenuButton( onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], ), ); &#125;&#125; 最后的效果图，未点击右侧按钮如左侧所示，点击右侧按钮会弹出相应的 mune 该部分代码查看 app_bar_main.dart 文件 看到效果图，相信很多小伙伴会吐槽，「**，上面那层半透明的啥玩意，那么丑」，接下来我们来解决这个问题，修改 void main 方法 void main() &#123; runApp(DemoApp()); // 添加如下代码，使状态栏透明 if (Platform.isAndroid) &#123; var style = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(style); &#125;&#125; 关闭后重新运行，就可以看到那层丑丑的「半透明蒙层」没有了 接着介绍下 PopupMenuButton 这个部件，还是按照惯例看构造函数 // itemBuildertypedef PopupMenuItemBuilder&lt;T&gt; = List&lt;PopupMenuEntry&lt;T&gt;&gt; Function(BuildContext context);// onSelectedtypedef PopupMenuItemSelected&lt;T&gt; = void Function(T value);const PopupMenuButton(&#123; Key key, @required this.itemBuilder, // 用于定义 menu 列表，需要传入 List&lt;PopupMenuEntry&lt;T&gt;&gt; this.initialValue, // 初始值，是个泛型 T，也就是类型和你传入的值有关 this.onSelected, // 选中 item 的回调函数，返回 T value，例如选中 `s` 则返回 s this.onCanceled, // 未选择任何 menu，直接点击外侧使 mune 列表关闭的回调 this.tooltip, // 长按时的提示 this.elevation = 8.0, this.padding = const EdgeInsets.all(8.0), this.child, // 用于自定义按钮的内容 this.icon, // 按钮的图标 this.offset = Offset.zero, // 展示时候的便宜，Offset 需要传入 x,y 轴偏移量，会根据传入值平移 &#125;) 2、AppBar - bottomAppBar 还有个 bottom 属性没讲，因为 bottom 这个属性和图片背景一起使用会比较丑，所以就单独拎出来讲，我们直接在原来的代码上修改 // 这里需要用 with 引入 `SingleTickerProviderStateMixin` 这个类class _HomePageState extends State&lt;HomePage&gt; with SingleTickerProviderStateMixin &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; TabController _tabController; // TabBar 必须传入这个参数 @override void initState() &#123; super.initState(); // 引入 `SingleTickerProviderStateMixin` 类主要是因为 _tabController 需要传入 vsync 参数 _tabController = TabController(length: _abs.length, vsync: this); &#125; @override void dispose() &#123; // 需要在界面 dispose 之前把 _tabController dispose，防止内存泄漏 _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, automaticallyImplyLeading: false, leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, // 选中时的颜色 unselectedLabelColor: Colors.white, // 未选中颜色 controller: _tabController, isScrollable: false, // 是否固定，当超过一定数量的 tab 时，如果一行排不下，可设置 true indicatorColor: Colors.yellow, // 导航的颜色 indicatorSize: TabBarIndicatorSize.tab, // 导航样式，还有个选项是 TabBarIndicatorSize.label tab 时候，导航和 tab 同宽，label 时候，导航和 icon 同宽 indicatorWeight: 5.0, // 导航高度 tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), // 导航内容列表 ), ); &#125;&#125; 最终的效果图如下 3、PageView + TabBar那么如何通过 TabBar 切换界面呢，这边我们需要用到 PageView 这个部件，当然还有别的部件，例如 IndexStack 等，小伙伴可以自己尝试使用别的，这边通过 PageView 和 TabBar 进行关联，带动页面切换，PageViede 的属性参数相对比较简单，这边就不贴啦。最终的效果我们目前只展示一个文字即可，我们先定义一个通用的切换界面 class TabChangePage extends StatelessWidget &#123; // 需要传入的参数 final String content; // TabChangePage(this.content); 不推荐这样写构造方法 // 推荐用这样的构造方法，key 可以作为唯一值查找 TabChangePage(&#123;Key key, this.content&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // 仅展示传入的内容 return Container( alignment: Alignment.center, child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0))); &#125;&#125; 定义通用界面后，就可以作为 PageView 的子界面传入并展示 class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; with SingleTickerProviderStateMixin &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; TabController _tabController; // 用于同 TabBar 进行联动 PageController _pageController; @override void initState() &#123; super.initState(); _tabController = TabController(length: _abs.length, vsync: this); _pageController = PageController(initialPage: 0); _tabController.addListener(() &#123; // 判断 TabBar 是否切换位置了，如果切换了，则修改 PageView 的显示 if (_tabController.indexIsChanging) &#123; // PageView 的切换通过 controller 进行滚动 // duration 表示切换滚动的时长，curve 表示滚动动画的样式， // flutter 已经在 Curves 中定义许多样式，可以自行切换查看效果 _pageController.animateToPage(_tabController.index, duration: Duration(milliseconds: 300), curve: Curves.decelerate); &#125; &#125;); &#125; @override void dispose() &#123; _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, automaticallyImplyLeading: false, leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, unselectedLabelColor: Colors.white, controller: _tabController, isScrollable: false, indicatorColor: Colors.yellow, indicatorSize: TabBarIndicatorSize.tab, indicatorWeight: 5.0, tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), ), // 通过 body 来展示内容，body 可以传入任何 Widget，里面就是你需要展示的界面内容 // 所以前面留下 Scaffold 中 body 部分的坑就解决了 body: PageView( controller: _pageController, children: _abs.map((str) =&gt; TabChangePage(content: str)).toList(), // 通过 Map 转换后再通过 toList 转换成列表，效果同 List.generate onPageChanged: (position) &#123; // PageView 切换的监听，这边切换 PageView 的页面后，TabBar 也需要随之改变 // 通过 tabController 来改变 TabBar 的显示位置 _tabController.index = position; &#125;, ), ); &#125;&#125; 最终的效果图就不贴了，可以发现滑动 PageView 或者点击切换 TabBar 的位置，界面显示的内容都会随之改变，同时，解决前面 Scaffold 留下 body 属性没讲的一个坑，就剩下 drawer 、 bottomNavigationBar 属性没讲了，在解决这两个坑之前，我们先处理下另一个问题 Scaffold 能够使我们快速去搭建一个界面，但是，并不是所有的界面都需要 AppBar 这个标题，那么我们就不会传入 appBar 的属性，我们注释 _HomePageState 中 Scaffold 的 appBar 传入值，把 body 传入的 PageView 修改成单个 TabChangePage ，然后把 TabChangePage 这个类做下修改，把 Container 的 aligment 属性也注释了，这样显示的内容就会显示在左上角 // _HomePageState// ..@override Widget build(BuildContext context) &#123; return Scaffold(body: TabChangePage(content: 'Content')); &#125;class TabChangePage extends StatelessWidget &#123; final String content; TabChangePage(&#123;Key key, this.content&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0))); &#125;&#125; 然后运行下，「**，文字怎么被状态栏给挡了…」不要慌，静下心喝杯茶，眺望下远方，这里就需要用 SafeArea 来处理了，在 TabChangePage 的 Container 外层加一层 SafeArea @override Widget build(BuildContext context) &#123; return SafeArea( child: Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0)))); &#125; 然后重新运行，一切正常，SafeArea 的用途可以看下源码的解释 /// A widget that insets its child by sufficient padding to avoid intrusions by/// the operating system.////// For example, this will indent the child by enough to avoid the status bar at/// the top of the screen. 翻译过来大概就是「给子部件和系统点击无效区域留有足够空间，比如状态栏和系统导航栏」，SafeArea 可以很好解决刘海屏覆盖页面内容的问题，那么到目前为止，AppBar 的一些坑就说的差不多了，就要解决剩下的坑了 4、Scaffold - Drawerdrawer 同 endDrawer 属性是一样的，除了滑动的方向，Drawer 这个组件也相对比较简单，只要传入一个 child 即可，在展示之前，先对 appBar 做下处理，设置 leading 为系统默认，点击 leading 的时候 Drawer 就可以滑出来了，当然手动滑也可以 @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true,// automaticallyImplyLeading: false,// leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, unselectedLabelColor: Colors.white, controller: _tabController, isScrollable: false, indicatorColor: Colors.yellow, indicatorSize: TabBarIndicatorSize.tab, indicatorWeight: 5.0, tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), ), // body .... drawer: Drawer( // 记得要先添加 `SafeArea` 防止视图顶到状态栏下面 child: SafeArea( child: Container( child: Text('Drawer', style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0)), )), ), ); // return Scaffold(body: TabChangePage(content: 'Content')); &#125; 最终的效果图也不贴了，当手势从左侧滑出或者点击 leading 图标，抽屉就出来了 5、AppBar - bottomNavigationBarbottomNavigarionBar 可以传入一个 BottomNavigationBar 实例，BottomNavigationBar 需要传入 BottomNavigationBarItem 列表作为 items ，但是这边为了实现一个 bottomNavigationBar 和 floatingActionButton 一个特殊的组合效果，我们不使用 BottomNavigationBar，换做 BottomAppBar，直接上代码吧 @override Widget build(BuildContext context) &#123; return Scaffold( /// 一样的代码省略.... bottomNavigationBar: BottomAppBar( shape: CircularNotchedRectangle(), child: Row( mainAxisSize: MainAxisSize.max, mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ IconButton(icon: Icon(Icons.android, size: 30.0, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;), IconButton(icon: Icon(Icons.people, size: 30.0, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;) ], ), ), floatingActionButton: FloatingActionButton(onPressed: () =&gt; print('Add'), child: Icon(Icons.add, color: Colors.white)), // FAB 的位置，一共有 7 中位置可以选择，centerDocked, endDocked, centerFloat, endFloat, endTop, startTop, miniStartTop，这边选择悬浮在 dock floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, ); 最终的效果图 既然提到了 StatefulWidget，顺带提下两种比较简单的部件，也算是基础部件吧。CheckBox、CheckboxListTile，Switch、SwitchListTile 因为比较简单，就直接上代码了，里面都有完整的注释 class CheckSwitchDemoPage extends StatefulWidget &#123; @override _CheckSwitchDemoPageState createState() =&gt; _CheckSwitchDemoPageState();&#125;class _CheckSwitchDemoPageState extends State&lt;CheckSwitchDemoPage&gt; &#123; var _isChecked = false; var _isTitleChecked = false; var _isOn = false; var _isTitleOn = false; @override void initState() &#123; super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Check Switch Demo'), ), body: Column(children: &lt;Widget&gt;[ Row( children: &lt;Widget&gt;[ Checkbox( // 是否开启三态 tristate: true, // 控制当前 checkbox 的开启状态 value: _isChecked, // 不设置该方法，处于不可用状态 onChanged: (checked) &#123; // 管理状态值 setState(() =&gt; _isChecked = checked); &#125;, // 选中时的颜色 activeColor: Colors.pink, // 这个值有 padded 和 shrinkWrap 两个值， // padded 时候所占有的空间比 shrinkWrap 大，别的原谅我没看出啥 materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, ), /// 点击无响应 Checkbox(value: _isChecked, onChanged: null, tristate: true) ], ), Row( children: &lt;Widget&gt;[ Switch( // 开启时候，那个条的颜色 activeTrackColor: Colors.yellow, // 关闭时候，那个条的颜色 inactiveTrackColor: Colors.yellow[200], // 设置指示器的图片，当然也有 color 可以设置 activeThumbImage: AssetImage('images/ali.jpg'), inactiveThumbImage: AssetImage('images/ali.jpg'), // 开始时候的颜色，貌似会被 activeTrackColor 顶掉 activeColor: Colors.pink, materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, value: _isOn, onChanged: (onState) &#123; setState(() =&gt; _isOn = onState); &#125;), /// 点击无响应 Switch(value: _isOn, onChanged: null) ], ), CheckboxListTile( // 描述选项 title: Text('Make this item checked'), // 二级描述 subtitle: Text('description...description...\ndescription...description...'), // 和 checkbox 对立边的部件，例如 checkbox 在头部，则 secondary 在尾部 secondary: Image.asset('images/ali.jpg', width: 30.0, height: 30.0), value: _isTitleChecked, // title 和 subtitle 是否为垂直密集列表中一员，最明显就是部件会变小 dense: true, // 是否需要使用 3 行的高度，该值为 true 时候，subtitle 不可为空 isThreeLine: true, // 控制 checkbox 选择框是在前面还是后面 controlAffinity: ListTileControlAffinity.leading, // 是否将主题色应用到文字或者图标 selected: true, onChanged: (checked) &#123; setState(() =&gt; _isTitleChecked = checked); &#125;, ), SwitchListTile( title: Text('Turn On this item'), subtitle: Text('description...description...\ndescription...description...'), secondary: Image.asset('images/ali.jpg', width: 30.0, height: 30.0), isThreeLine: true, value: _isTitleOn, selected: true, onChanged: (onState) &#123; setState(() =&gt; _isTitleOn = onState); &#125;) ]), ); &#125;&#125; 该部分代码查看 checkbox_swicth_main.dart 文件 终于这节把 Scaffold 留下的坑都填完了，然后又讲了两种基础部件，下节要填留下的别的坑了，目测还留了 2 个大坑，那就等以后继续解决吧~ 最后代码的地址还是要的： 文章中涉及的代码：demos 基于郭神 cool weather 接口的一个项目，实现 BLoC 模式，实现状态管理：flutter_weather 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：flutter_shop 作者：Kuky_xs 链接：https://www.jianshu.com/p/9119a1c1a123 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(二)基础部件]]></title>
    <url>%2Fposts%2F88b946ec.html</url>
    <content type="text"><![CDATA[前言主要包括 MaterialApp、Scaffold、Text、Image、Icon、Button 以及 AppBar 部分内容，准备出发~ ​ 看完这篇文章你就在知道怎么写以上效果了 1、Flutter runApp新建 flutter 项目后，可以看到 lib 下的 main.dart 中 void main() =&gt; runApp(MyApp());这句就是程序的入口了。这里可以简单看下源码 void runApp(Widget app) &#123; WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame();&#125;///....static WidgetsBinding ensureInitialized() &#123; if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance;&#125;///....void attachRootWidget(Widget rootWidget) &#123; _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;( container: renderView, debugShortDescription: '[root]', child: rootWidget ).attachToRenderTree(buildOwner, renderViewElement);&#125; 首先会创建一个 WidgetsBinding 单例对象，然后把传入的 App 添加到 rootWidget中，scheduleWarmUpFrame 方法比较长，这边看下对该方法的注释第一句就能了解方法的主要功能了 Schedule a frame to run as soon as possible 「安排框架尽快运行起来」(原谅我这渣英语，只能看懂不会翻译..大概就是「快速启动框架」的意思吧) 2、Flutter App接着看下 MyApp 这个类，继承自 StatelessWidget 并在 build 方法返回一个 MaterialApp 实例，(偷偷讲下，其实这边还可以返回 CupertinoApp，这是一个 iOS 风格的 widget，基本上你看到部件带 「Cupertino」的都是 iOS 风格的 widget，这里先不讲 iOS 风格的部件，目前 flutter 对 Cupertino 系列的 widget 支持不是很好，包括部件的广度，多语言的支持等等方面都不是很友好，所以我们还是继续看 MD 风格的 Android 部件吧~)，这里先看下 MaterialApp 的构造函数，介绍一些常用的参数 const MaterialApp(&#123; Key key, this.navigatorKey, this.home, // 主界面的内容 widget this.routes = const &lt;String, WidgetBuilder&gt;&#123;&#125;, // 带 router 和路由跳转有关 this.initialRoute, this.onGenerateRoute, this.onUnknownRoute, this.navigatorObservers = const &lt;NavigatorObserver&gt;[], this.builder, this.title = '', // *类似标题 this.onGenerateTitle, // 主要用于多语言情况下，需要根据当前语言替换 title，需要使用该值 this.color, // 主题色，如果该值未设置，取 theme.primaryColor,未设置 theme 则取蓝色 this.theme, // App 的主题风格，包括主题色，按钮默认颜色等等 this.locale, // 带 locale 的和多语言适配相关 this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const &lt;Locale&gt;[Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, // debug 模式下，是否显示 DEBUG 标示横幅 &#125;) MaterialApp 继承自 StatefulWidget，它和 MyApp 所继承的类 StatelessWidget，就是日常开发中，自定义部件通常继承的抽象类了。 StatelessWidget 是状态不可变部件，通过其构建的部件一般用来展示固定内容，例如需要展示固定的功能按钮列表，不需要根据不同界面状态进行修改其展示内容 StatefulWidget 是可改变状态的部件，比如我们需要通过网络或者数据库获取数据，然后修改部件锁展示的数据内容，则需要通过 StatefulWidget 来构建。当然，不是说 StatelessWidget 不能实现修改界面数据的功能，这就需要涉及到 状态管理 的概念了，后面有机会再讲，这边先埋坑【坑1】 3、Flutter Scaffold进入 App 后就需要构建界面了，Flutter 提供了 Scaffold 来快速构建一个 MaterialDesign 风格的界面，还是先看下 Scaffold 的构造函数吧，了解几个比较常用的部分。 const Scaffold(&#123; Key key, this.appBar, // 界面顶部的那条栏，这边需要返回一个 AppBar 实例 this.body, // 界面的内容部分 this.floatingActionButton, // 悬浮部分，可以通过 floatingActionButtonLocation 设置位置 this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.drawer, // 侧滑抽屉部分，从左侧滑出(应该和语言有关，和文字方向同向) this.endDrawer, // 侧滑抽屉部分，从右侧滑出 this.bottomNavigationBar, // 底部导航栏，就是通常看到的底部 TAB 切换部件 this.bottomSheet, // 展示从底部弹出的，起到提示作用的，通过 showModalBottomSheet 展示 this.backgroundColor, // 界面的背景色 this.resizeToAvoidBottomPadding = true, // 避免 body 被底部弹出部件填充，例如输入法键盘 this.primary = true, // 当前的 Scaffold 是否需要被展示在屏幕最上层 &#125;) 来张图吧，简洁明了 了解完 Scaffold 的整体构造后，我们从上到下，通过构造函数来了解下各个 Widget的使用方法 4、AppBarAppBar(&#123; Key key, this.leading, // 用于设置 AppBar 前置的按钮，例如设置返回我们需要的返回按钮等 this.automaticallyImplyLeading = true, // 是否使用系统默认生成的按钮，如果替换 leading 的默认按钮，最好将该属性设置成 false this.title, // AppBar 所需要展示的组件，传入一个 Widget 实例，通常使用 Text 展示一个标题 this.actions, // AppBar 末尾悬浮的一些操作组件，例如常见的会在末尾设置一个「...」按钮，点击弹出一个 menue 提供给用户操作选择 this.flexibleSpace, // AppBar 的背景，可以设置颜色，背景图等等 this.bottom, // bottom 用于展示顶部导航 TAB this.elevation = 4.0, this.backgroundColor, // AppBar 的背景色，如果只需要修改颜色，可以不通过 flexibleSpace 修改 this.brightness, this.iconTheme, // 按钮的默认样式 this.textTheme, // 文字的默认样式 this.primary = true, this.centerTitle, // 是否将展示的 title 居中 this.titleSpacing = NavigationToolbar.kMiddleSpacing, // AppBar title 两侧的空白间隔 this.toolbarOpacity = 1.0, this.bottomOpacity = 1.0, &#125;) 在展示 AppBar 的 demo 之前，我们先学习几个基本的组件 Text、Image、Icon、Button 分布用于展示文字，图片，图标，按钮 5、Textconst Text(this.data, &#123; // Text 需要展示的文字 Key key, this.style, // 文字的样式，包括颜色，大小，间距等等属性，这边就不继续展示 TextStyle 构造函数了，不然我怕大家都不想继续看了，稍后通过例子来说明 this.textAlign, // 文字的对齐方式，包括左对齐，右对齐，居中等，详见 TextAlign 类 this.textDirection, // 文字方向，ltr(left to right) 或者 rtl(right to left) this.locale, this.softWrap, // 当文字一行显示不完是否换行 this.overflow, // 如果超出限制的行数，以哪种方式省略未展示的内容 this.textScaleFactor, // 文字缩放比例 this.maxLines, // 最多展示的行数 this.semanticsLabel, &#125;) 说了那么多，相信很多小伙伴都要急着撸代码了吧，接着来展示一些 Text 的示例，接下来的例子都会直接替换 HomePage 内的展示内容，其余都是相同的，接下来请关注 Text 别的部件先忽略，后面会介绍，这边先埋坑【坑2】 import 'package:flutter/material.dart';void main() =&gt; runApp(DemoApp());class DemoApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', debugShowCheckedModeBanner: false, theme: ThemeData(primarySwatch: Colors.lightBlue), home: HomePage(), ); &#125;&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('绿色背景黑色文字展示', style: TextStyle( color: Colors.black, // 设置文字颜色，不可和 foreground 同时设置 fontSize: 24.0, // 字体大小 letterSpacing: 2.0, // 每个字符之间的间隔 background: Paint()..color = Colors.green)), // 背景色 Text('这是一个带红色下划线的文字展示', style: TextStyle( color: Colors.black, fontSize: 24.0, // 文字装饰线，除了 underline 还有 overline, lineThrough， // 不同的样式小伙伴可以通过自己修改代码来查看 decoration: TextDecoration.underline, // 文字装饰线的类型，除了 solid 还有 double,dotted,dashed,wavy 可选 decorationStyle: TextDecorationStyle.solid, // 装饰线的颜色 decorationColor: Colors.red)) ], )), )); &#125;&#125; 该部分代码查看源码 text_main.dart 文件 最后的展示效果如下图 6、Image按照惯例，我们还是先看下 Image 的构造函数吧 const Image(&#123; Key key, // 一个 ImageProvider 实例，但是 ImageProvider 是一个抽象类，Flutter 已经给我们提供如下 // AssetImage，NetworkImage，FileImage，MemoryImage 这四种图片加载器，为了方便调用 // 我们可以直接通过 Image.asset, Image.network, Image.file, Image.memory 简化， // 通过方法名，可以看出分别从 asset 文件，网络，文件，内存中加载图片 @required this.image, this.semanticLabel, this.excludeFromSemantics = false, this.width, // 图片宽度 this.height, // 图片高度 this.color, // 图片背景色 this.colorBlendMode, // color 和图片的混合模式(这个值比较多，可以一个个尝试) this.fit, // 图片填充方式 fill, cover, contain, fillWidth, fillHeight, scaleDown, none this.alignment = Alignment.center, // 对齐方式 this.repeat = ImageRepeat.noRepeat, // 若未填充满空间，重复展示的方式 this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.filterQuality = FilterQuality.low, &#125;) 好了好了，我知道你们又想自己写代码尝试下了，在这之前，需要你先准备一张本地图片，然后在项目的根目录，也就是 lib 文件夹同层，创建一个新的文件夹，命名为 images，把你准备好的图片放到这个目录下。放好之后打开 pubspec.yaml 把图片资源文件注册下 # The following section is specific to Flutter.flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # 这边注册资源文件，以后有图片文件也可以只注册 images 文件夹，会自动读取内部的文件 assets: - images/ali.jpg 注册完成后，就可以继续愉快的撸代码了~ class HomePage extends StatelessWidget &#123; final String _assetAli = 'images/ali.jpg'; final String _picUrl = 'https://timg05.bdimg.com/timg?wapbaike&amp;quality=60&amp;size=b1440_952&amp;cut_x=143&amp;cut_y=0&amp;cut_w=1633&amp;' 'cut_h=1080&amp;sec=1349839550&amp;di=cbbc175a45ccec5482ce2cff09a3ae34&amp;' 'src=http://imgsrc.baidu.com/baike/pic/item/4afbfbedab64034f104872baa7c379310b551d80.jpg'; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 这种展示图片方式和下一种会有相同的效果 Image(image: AssetImage(_assetAli), width: 80.0, height: 80.0), // 接下来加载图片都会使用这些比较方便的方法 Image.asset(_assetAli, width: 80.0, height: 80.0), // 加载一张网络图片 Image.network(_picUrl, height: 80.0, // 横向重复 repeat: ImageRepeat.repeatX, // MediaQuery.of(context).size 获取到的为上层容器的宽高 width: MediaQuery.of(context).size.width), // 通过设置混合模式，可以看到图片展示的样式已经修改 Image.asset(_assetAli, width: 80.0, height: 80.0, color: Colors.green, colorBlendMode: BlendMode.colorDodge), // 会优先加载指定的 asset 图片，然后等网络图片读取成功后加载网络图片，会通过渐隐渐现方式展现 // cover 方式按照较小的边布满，较大的给切割 // contain 会按照最大的边布满，较小的会被留白 // fill 会把较大的一边压缩 // fitHeight, fitWidth 分别按照长宽来布满 FadeInImage.assetNetwork( placeholder: _assetAli, image: _picUrl, width: 120.0, height: 120.0, fit: BoxFit.cover), // Icon 相对属性少了很多，需要传入一个 IconData 实例，flutter 提供了很多图标， // 但是实际情况我们需要加入我们自己的图标，这边再埋坑【坑3】 // size 为图标显示的大小，color 为图标的颜色，这边通过 Theme 获取主题色调 Icon(Icons.android, size: 40.0, color: Theme.of(context).primaryColorDark) ], )), )); &#125;&#125; 该部分代码查看源码 image_main.dart 文件 最后的效果如下 7、ButtonFlutter 提供了各种类型的 Button 几乎是大同小异的，这边就抽取一些比较常用的展示下效果，常用的主要有 RaisedButton 、FlatButton、IconButton、OutlineButton、MaterialButton、FloatActionButton、FloatingActionButton.extended Button 都有一个 onPress 参数，是 VoidCallback 类型的参数，通过查看源码可以知道 VoidCallback 是无参无返回值的一种类型参数。如果该参数传入的值为 null 那么这个按钮的就不可点击状态，无点击效果，等会可以在例子中查看。还有就是 child 参数，这里就是传入你需要展示的内容，比如 Text、Icon 等等。别的参数基本可以通过参数名了解，这边不扩展了(再看源码我怕你们都不想继续看下去了…) Talk is cheap, show me the code class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123; print('This is a Rased Button can be clicked'); &#125;, child: Text('Raised Enable'), ), RaisedButton(onPressed: null, child: Text('Raised Disable')), FlatButton( onPressed: () =&gt; print('This is a Flat Button can be clicker'), child: Text('Flat Enable'), ), FlatButton(onPressed: null, child: Text('Flat Disable')), IconButton(icon: Icon(Icons.android), onPressed: () &#123;&#125;), IconButton(icon: Icon(Icons.android), onPressed: null), MaterialButton(onPressed: () &#123;&#125;, child: Text('Material Enable')), MaterialButton(onPressed: null, child: Text('Material Disable')), OutlineButton(onPressed: () &#123;&#125;, child: Text('Outline Enable')), OutlineButton(onPressed: null, child: Text('Outline Enable')), ], )), ), floatingActionButton: FloatingActionButton.extended(onPressed: () &#123;&#125;, icon: Icon(Icons.android), label: Text('Android')), floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, ); &#125;&#125; 该部分代码查看源码 button_main.dart 部分 最终的效果图 这篇终于到末尾了，最后留了 3 个坑等以后解决 文章 demo 的地址：https://github.com/kukyxs/flutter_arts_demos_app 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：https://github.com/kukyxs/flutter_shop 如果对你有帮助的话，记得给个 Star，先谢过，你的认可就是支持我继续写下去的动力~]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(一)Dart]]></title>
    <url>%2Fposts%2F6114f592.html</url>
    <content type="text"><![CDATA[前言最近 Flutter 真心火爆到不要不要的，随大流，学一波，在这之前，对于语言的语法还是需要有些必要的了解的，Dart 这门语言，说实话对于会 Java 这类面向对象的语言的小伙伴们来说，真的灰常灰常简单，这边我总结了一些 Dart 和 Java 的一些语法差异，当然，只是部分，但是，按照我目前的学习进度来说，了解了这些对于写 Flutter 项目绝对够了。小伙伴也可以自己查看，我这边提供一个自己学习的网址 Dart 快速入门：http://dart.goodev.org/guides/language 温馨提示：本篇文章没有图，没有图，没有图，可能会造成部分不适，请注意，请注意，请注意，系好安全带，我们要「开车了」…… 1、VariablesDart 变量类型可以通过具体的赋值进行推导，例如：var name = ‘kuky’ 则定义了一个 String 类型对象 name，也可以通过指定具体的类型 String name = ‘kuky’，如果没有初始化变量，则默认值为 null，类型为数字的变量默认值同为 null（同 java 不同，java 中 int 默认为 0.）如果需要定义常量，可以通过 final 和 const 进行定义，final 变量只能赋值一次，const 是编译时常量。 2、Build-in-typesDart 内置类型包括 ： Numbers 包括 int[-2^53 ~ 2^53]， double[64-bit 浮点数] Strings Dart 字符串是 UTF-16 编码的字符序列， 可以使用单引号或者双引号来创建字符串。 通过 == 判断两个字符串是否相同 通过三对单引号’’’aaa’’’或者双引号”””aaa”””可以创建多行字符串对象 使用前缀 r 创建 raw string，字符串内不会进行转义，例如：var a = r’haha \n breakLine’ 打印 a 对象则会按照输入的输出，不会进行换行 Booleans Dart 中，只有 true 对象才被认为是 true， 所有其他的值都是 false Lists 列表，例如：var list = [1, 2, 3, 4] 通过 const 关键词可以定义一个不可变列表 var list = const [1, 2, 3, 4] 参数化定义var name = [‘Jone’, ‘Jack’] Maps 键值对，例如：var map = {‘one’: 1, ‘two’: 2} 如果键值对需要添加新的键值对，直接指定即可，map[‘three’] = 3，若查找的键不存在，返回 null 参数化定义 var map = &lt;String, int&gt;{‘one’: 1, ‘two’: 2} Runes 代表字符串的 UTF-32 code points，通常使用 \uXXXX 的方式来表示 Unicode code point， XXXX 是4个 16 进制的数，例如 \u2665 返回心形符号 () Symbols 代表 Dart 程序中声明的操作符或者标识符，几乎不使用 3、Function函数方法的可选参数通过在参数列表中用 {} 指定，例如： void say(String name, &#123;String word = 'hello'&#125;)&#123; print('$name say $word'); &#125;// 通过（可选参数名 + :）进行可选参数的赋值main()&#123; say('zm', word: 'Hello World'); // kuky say Hello World&#125; word 参数为可选参数，默认值为 hello 4、Operators操作符几乎和别的语言类似，提个比较特殊的赋值操作符 ??= 和 ?.操作符 var a = 1;var b ?? = a; // 如果 b 的值是 null 则将 a 赋值给 b，否则保持不变var c = size?.x; // 如果 size 为 null 则返回 null，否则返回 size.a 的值 5、Conditional ExpressionsDart 可以通过两个特殊的操作符替换 if(){} else{} 表达式 /// condition? expr1: expr2 同 java 三目运算符var a = if(a &lt; 0) -a : a/// expr1 ?? expr2 String toString() =&gt; msg ?? super.toString() // 如果 expr1 不为 null 则返回 expr1 否则返回 expr 6、Cascade Notaion(..)级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量 class Size&#123; double x; double y; @override String toString() &#123; return 'Size&#123;x: $x, y: $y&#125;'; &#125;&#125;var size = Size();/// 通过级联操作符进行赋值，可以更加简洁，!!如果函数返回值为 void 则不能进行级联!!print(size ..x = 10 ..y = 100 ..toString()); /// 输出 Size&#123;x: 10.0, y: 100.0&#125; 7、foreach通过 foreach 循环遍历一个实现 Iterable 接口的对象 var items = [1, 2, 3, 4, 5];var maps = &#123;'a': 1, 'b': 2&#125;;items.where((i) =&gt; i &gt; 2).forEach((i) =&gt; print(i)); // 3, 4, 5maps.forEach((key, value) =&gt; print('$key =&gt; $value')); // a =&gt; 1, b =&gt; 2 8、Switch and case如果需要实现继续到下一个 case 语句中继续执行，则可以 使用 continue 语句跳转到对应的标签处继续执行 var command = 'Close';switch (command.toLowerCase()) &#123; case 'close': print('close'); continue open; open: // 这是个标签 case 'open': print('open'); break;&#125; 9、Assert如果条件表达式结果不满足需要，则可以使用 assert 语句俩打断代码的执行，例如：assert(a == 1); 10、Exceptions所有的 Dart 异常是非检查异常。捕捉 exceptions 的时候可以通过 on 指定 exceptions 类型，再使用 catch 捕获 try &#123; breedMoreLlamas();&#125; on OutOfLlamasException &#123; buyMoreLlamas();&#125; on Exception catch (e) &#123; print('Unknown exception: $e');&#125; catch (e, s) &#123; // 函数 catch 可以带有一个或两个参数，第一个参数为抛出的异常对象，第二个为堆栈信息 print('Something really unknown: $e'); print('Stack trace:\n $s'); rethrow; // 通过 rethrow 可以将异常重新抛出&#125; 11、ClassesDart 中的类都是单继承，但是同时支持 mixin 的继承机制（除 Object 类，每个类都只有一个超类），所有的类都继承于 Object，通过调用 runtimeType 判断实例的类型。每个实例变量都会自动生成一个 getter 方法（隐含的）， Non-final 实例变量还会自动生成一个 setter 方法。 Constructors Dart 的构造函数同 Java 类似 class Size &#123; num x, y; Size(num nx, num y)&#123; x = nx; this.y = y; // this 关键字只有当名字冲突时候使用，否则 Dart 推荐省略 this &#125; Size(this.x, this.y); // Dart 通过语法糖省略了构造函数的赋值过程，效果同上&#125; 如果没有定义构造函数，则会有个默认构造函数。默认构造函数没有参数，并且会调用超类的 没有参数的构造函数。子类不会继承超类的构造函数，子类如果没有定义构造函数，则只有一个默认构造函数。 Dart 通过命名构造函数为类创建多个构造函数，同时指明意图 class Size &#123; num x, y; Size(this.x, this.y); Size.fromJson(Map json)&#123; this.x = json['x']; this.y = json['y']; &#125; // 因为构造函数不能继承，如果希望子类也有超类一样的命名构造函数，必须在子类中实现该构造函数 // 构造函数体执行之前除了可以调用超类构造函数之外，还可以初始化实例参数 // 初始化列表非常适合用来设置 final 变量的值 Size.fromJsonInit(Map json) : this.x = json['x'], this.y = json['y'];&#125; 常量构造函数（如果类需要提供一个状态不变的对象，通过 const 构造函数实现） class ConstPoint &#123; final num x; final num y; const ConstPoint(this.x, this.y);&#125; 工厂方法构造函数（如果一个类不需要每次都提供一个新的对象，通过 factory 构造函数实现） class HttpCore &#123; HttpCore._internal(); factory HttpCore() &#123; if (_instance == null) _instance = HttpCore._internal(); return _instance; &#125; static HttpCore _instance; static HttpCore get instance =&gt; HttpCore(); void _request()&#123; //... &#125;&#125; 每个类都隐式的定义了一个包含所有实例成员的接口， 并且这个类实现了这个接口，通过抽象类实现类似 Java 接口的功能。 abstract class Callback &#123; void print(String msg);&#125;class A implements Callback&#123; @override void print(String msg) &#123; print(msg); &#125;&#125; Mixins Dart | 什么是Mixin：https://www.jianshu.com/p/a578bd2c42aa 12、Asynchrony supportFuture loopIntegers() &#123; // 通过 then 进行获取到 Future 对象后的操作 getListDelay().then((ints) =&gt; ints.forEach((i) =&gt; print(i)));&#125;// 生成一个 Future 对象Future&lt;List&lt;int&gt;&gt; getListDelay() &#123; return Future.delayed(Duration(seconds: 2), () =&gt; List.generate(10, (delta) =&gt; delta));&#125; 通过 async await 简化 Future 操作 runUsingFuture() &#123; //... findEntrypoint().then((entrypoint) &#123; return runExecutable(entrypoint, args); &#125;).then(flushThenExit);&#125;// 简化了 thenrunUsingAsyncAwait() async &#123; //... var entrypoint = await findEntrypoint(); var exitCode = await runExecutable(entrypoint, args); await flushThenExit(exitCode);&#125; 有时候要求调用很多异步方法，并且等待 所有方法完成后再继续执行，通过使用 Future.wait() 进行管理 Future deleteDone = deleteLotsOfFiles();Future copyDone = copyLotsOfFiles();Future checksumDone = checksumLotsOfOtherFiles();Future.wait([deleteDone, copyDone, checksumDone]) .then((List values) &#123; print('Done with all the long steps'); &#125;); Stream Dart|什么是 Stream：https://www.jianshu.com/p/a5d7758938ef 大概了解了 Dart 的语法，下节就开始写 Flutter 啦~，环境的安装具体查看官网，很详细 Flutter 环境安装 记得一定要配置镜像，配置镜像，配置镜像 https://flutterchina.club/get-started/install/]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发环境搭建Mac版]]></title>
    <url>%2Fposts%2F3223dff5.html</url>
    <content type="text"><![CDATA[系统环境要求Flutter因为是新出的框架，所以对系统还是有一定的要求的。 MacOS （64-bit） 磁盘空间：大于700M，如果算上Android Studio等编辑工具，尽量大于3G。 命令号工具：bash、mkdir、rm、git、curl、unzip、which、brew 这些命令在都可以使用。 注意：一般你会在brew这个命令下载坑，很多mac系统都没有安装这个，你可以进行安装，因为这个和本知识关系性不大，所以我就不写流程了，如果你出现问题，直接点击链接学习安装就可以了。 学习安装brew：https://segmentfault.com/a/1190000013317511 下载Flutter SDK包这里推荐去官网下载就好，我挂了梯子，速度并不慢。 网址：https://flutter.dev/docs/development/tools/sdk/releases?tab=macos 配置环境变量压缩包下载好以后，找个位置进行解压。这个位置很重要，因为下面配置环境变量的时候要用到。比如你配置到了根目录下的app文件夹。 1.打开终端工具（这个我就不用写了吧），使用vim进行配置环境变量，命令如下： open ~/.bash_profile 在打开的文件里增加一行代码，意思是配置flutter命令在任何地方都可以使用。 export PATH=/app/flutter/bin:$PATH 提示：这行命令你要根据你把压缩包解压的位置来进行编写，写的是你的路径，很有可能不跟文章一样。 配置完成后，需要用source命令重新加载一下 ，具体命令如下： source ~/.bash_profile 完成这部以后，就算我们flutter的安装工作完成了，但是这还不能进行开发。可以使用命令来检测一下，是否安装完成了。 flutter -h 检查开发环境到上边为止，我们安装好了Flutter，但是还不具备开发环境。开发还需要很多软件和插件的支持，那到底需要哪些插件和软件那？我们可以使用Flutter为我们提供的命令来进行检查： flutter doctor 如果你英文很好，你应该可以很容易读出上面的检测结果，有很多条目都没有通过。需要我们安装检测结果一条条进行安装，直到满足开发环境。（如果有[!]x标志，表示本行检测没有通过，就需要我们设置或者安装相应的软件了。） 如果你有安装，那么第一步要作的是允许协议（android-licenses）。允许方法就是在终端运行如下命令： flutter doctor --android-licenses 然后让你输入Y/N的时候，一路Y就可以了（至于什么意思，我也没仔细看，大概就和安装软件的下一步下一步是一样的，你按N是不能成功的）。 这不完成后，我们再使用flutter doctor进行检测后，会看到还是有很多x。 其实大概意思就是我们需要这些软件，Flutter推荐你用brew命令进行安装。 我们可以直接在终端里输入下列命令（每输完一个都要等一会，等待软件包安装完成） brew install --HEAD libimobiledevicebrew install ideviceinstallerbrew install ios-deploybrew install cocoapodspod setup 安装完这些，我们还需要为Android Studio安装一下Flutter插件（这个有可能你安装过，如果出现下面的提示，说明你还没有安装） ✗ Flutter plugin not installed; this adds Flutter specific functionality.✗ Dart plugin not installed; this adds Dart specific functionality. 打开Android Stuido 软件，然后找到Plugin的配置，搜索Flutter插件。 点中间的Search in repositories,然后点击安装。 安装完成后，你需要重新启动一下Android Studio软件。 Pub源的配置如果你没有梯子，一个人人都知道的原因，你还需要在环境变量里配置一下Pub源，不然你是无法进行使用的。 运行： open ~/.bash_profile 增加两行配置 export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 重新加载环境变量 source ~/.bash_profile Android studio新建Flutter项目打开Andorid Studio ，会出现下面的界面，我们选择第二项，新建Flutter项目。 打开第二个窗口后，选择第一个选项Flutter Application(flutter应用)。 这步完成后，系统就会自动为我们创建一个Flutter项目 安装AVD虚拟机 现在需要一个虚拟机来运行我们的程序，可以点击Android Studio中的上方菜单tool -AVD Manager选项。 出现新建菜单，选择Create Virtual Device.....,如果你一个虚拟机也没建过，这个选项在对话框的中间 选择虚拟机类型，这个你随意选就好，我选择的是Nexus 5x。（如果你屏幕小，就选择一个小屏幕的虚拟机） 选择系统，这里尽量选择最新的，我选择了Android 9.0系统，选择好后，又是一个漫长的等待过程。 安装好后，点击开始按钮，运行虚拟机了（第一次运行，需要安装系统，会慢一些），运行起来后，如下图。 让Flutter跑起来虚拟机运行以后，可以点击debug按钮，让Flutter程序跑起来。如果你幸运的话，你的Flutter程序经过编译后，就会跑起来了。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试笔记]]></title>
    <url>%2Fposts%2Fe9998381.html</url>
    <content type="text"><![CDATA[广播注册方式： 1、静态注册 ，在Manifest文件的application节点中配置广播接收者 &lt;receiver android:name=".MyBroadCastReceiver"&gt; &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt; &lt;intent-filter android:priority="20"&gt; &lt;actionandroid:name="android.provider.Telephony.SMS_RECEIVED"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 2、动态注册，通过Context对象的registerReceiver方法注册广播 //new出上边定义好的BroadcastReceiverMyBroadCastReceiver yBroadCastReceiver = new MyBroadCastReceiver();//实例化过滤器并设置要过滤的广播 IntentFilter intentFilter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");//注册广播 myContext.registerReceiver(smsBroadCastReceiver,intentFilter, "android.permission.RECEIVE_SMS", null); 区别：静态注册的为常驻型广播，即使应用程序关闭了，如果又信息广播来，程序也会被系统调用执行。而动态注册的广播不是常驻型，广播被取消注册或者应用程序关闭后都不能接收 广播的两种类型： 1、有序广播：按照优先级，一级一级向下传递，接收者可以修改广播数据，也可以终止广播事件。 2、无序广播：所有接收者都会接收事件，不能被拦截跟修改。 服务启动 1、使用Context的startService方法启动 &gt; onCreate()`---&gt;`onStartCommand()`---&gt;`onDestroy()&gt; 2、使用Context的bindService方法启动 &gt; onCreate()`---&gt;`onBind()`---&gt;`onUnBind()`---&gt;`onDestroy()&gt; 停止 1、在外部使用stopService方法，如果使用bindService的方式启动，则使用unbindService方法停止 2、在Service内部（onStartCommand方法内）使用stopSelf onStartCommand方法的返回值 1、START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完onStartCommand方法后，服务被异常kill掉，系统不会自动重启该服务 2、START_STICKY：如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。 3、START_REDELIVER_INTENT：重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。 IntentService继承于Service，启动方式与Service的传统启动方式一样，不同点在于内部有一个线程来处理耗时操作，当任务执行完成时服务会自动停止。 Activity的启动模式 standard：标准模式，默认的启动模式，不管是否已经存在实例都会生成新的实例 singleTop：栈顶复用模式，如果发现有对应Activity的实例正位于栈顶，则直接打开此页面，不再生成新的实例，同时onNewIntent方法会被执行，onCreate跟onStart方法都不会执行。否则跟standard模式一样继续生成新的实例。 singleTask：站内复用模式，如果栈内存在对应Activity的实例就会复用这个Activity，复用时会将它上面的Activity全部出栈，同时onNewIntent方法也会被执行。 singleInstance：单例模式，该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 Activity的启动过程app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。 Luncher.startActivitySafely() &gt; public final class Launcher extends Activity&gt; implements View.OnClickListener, &gt; OnLongClickListener, &gt; LauncherModel.Callbacks, &gt; AllAppsView.Watcher &#123;&gt; &gt; ......&gt; &gt; void startActivitySafely(Intent intent, Object tag) &#123;&gt; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&gt; try &#123;&gt; startActivity(intent);&gt; &#125; catch (ActivityNotFoundException e) &#123;&gt; ......&gt; &#125; catch (SecurityException e) &#123;&gt; ......&gt; &#125;&gt; &#125;&gt; &gt; ......&gt; &gt; &#125;&gt; Activity.startActivity &gt; public class Activity extends ContextThemeWrapper&gt; implements LayoutInflater.Factory,&gt; Window.Callback, KeyEvent.Callback,&gt; OnCreateContextMenuListener, ComponentCallbacks &#123;&gt; &gt; ......&gt; &gt; @Override&gt; public void startActivity(Intent intent) &#123;&gt; startActivityForResult(intent, -1);&gt; &#125;&gt; &gt; ......&gt; &gt; &#125;&gt; Activity.startActivityForResult &gt; public class Activity extends ContextThemeWrapper&gt; implements LayoutInflater.Factory,&gt; Window.Callback, KeyEvent.Callback,&gt; OnCreateContextMenuListener, ComponentCallbacks &#123;&gt; &gt; ......&gt; &gt; public void startActivityForResult(Intent intent, int requestCode) &#123;&gt; if (mParent == null) &#123;&gt; Instrumentation.ActivityResult ar =&gt; mInstrumentation.execStartActivity(&gt; this, mMainThread.getApplicationThread(), mToken, this,&gt; intent, requestCode);&gt; ......&gt; &#125; else &#123;&gt; ......&gt; &#125;&gt; &gt; &gt; ......&gt; &gt; &#125;&gt; Instrumentation.execStartActivity &gt; public class Instrumentation &#123;&gt; &gt; ......&gt; &gt; public ActivityResult execStartActivity(&gt; Context who, IBinder contextThread, IBinder token, Activity target,&gt; Intent intent, int requestCode) &#123;&gt; IApplicationThread whoThread = (IApplicationThread) contextThread;&gt; if (mActivityMonitors != null) &#123;&gt; ......&gt; &#125;&gt; try &#123;&gt; int result = ActivityManagerNative.getDefault()&gt; .startActivity(whoThread, intent,&gt; intent.resolveTypeIfNeeded(who.getContentResolver()),&gt; null, 0, token, target != null ? target.mEmbeddedID : null,&gt; requestCode, false, false);&gt; ......&gt; &#125; catch (RemoteException e) &#123;&gt; &#125;&gt; return null;&gt; &#125;&gt; &gt; ......&gt; &gt; &#125;&gt; 这里的ActivityManagerNative.getDefault返回ActivityManagerService的远程接口，即ActivityManagerProxy接口 ActivityManagerProxy.startActivity &gt; class ActivityManagerProxy implements IActivityManager&gt; &#123;&gt; &gt; ......&gt; &gt; public int startActivity(IApplicationThread caller, Intent intent,&gt; String resolvedType, Uri[] grantedUriPermissions, int grantedMode,&gt; IBinder resultTo, String resultWho,&gt; int requestCode, boolean onlyIfNeeded,&gt; boolean debug) throws RemoteException &#123;&gt; Parcel data = Parcel.obtain();&gt; Parcel reply = Parcel.obtain();&gt; data.writeInterfaceToken(IActivityManager.descriptor);&gt; data.writeStrongBinder(caller != null ? caller.asBinder() : null);&gt; intent.writeToParcel(data, 0);&gt; data.writeString(resolvedType);&gt; data.writeTypedArray(grantedUriPermissions, 0);&gt; data.writeInt(grantedMode);&gt; data.writeStrongBinder(resultTo);&gt; data.writeString(resultWho);&gt; data.writeInt(requestCode);&gt; data.writeInt(onlyIfNeeded ? 1 : 0);&gt; data.writeInt(debug ? 1 : 0);&gt; mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);&gt; reply.readException();&gt; int result = reply.readInt();&gt; reply.recycle();&gt; data.recycle();&gt; return result;&gt; &#125;&gt; &gt; ......&gt; &gt; &#125;&gt; ActivityManagerService.startActivity ContextContext是一个抽象基类，翻译为上下文，也可以理解为环境，提供一些程序运行基础信息。 Context有两个子类，ContextWrapper是上下文功能的封装类，而 ContextImpl 则是上下文功能的实现类。而 ContextWrapper 又有三个直接的子类， ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 Activity、Window、View三者之间的关系 Activity 构造的时候会初始化一个Window( PhoneWindw ) PhoneWindow 有一个 RootView ，这个RootView 是一个ViewGroup，是最初始的根视图 RootView 通过 addView 方法来一个个添加 View View的绘制流程View的绘制流程：onMeasure -&gt; onLayout -&gt; onDraw 第一步：onMeasure 测量视图大小，从顶层父View到子View递归调用 measure 方法，measure 方法又回调 onMeasure方法。 第二步：onLayout 确定View位置，进行页面布局。从顶层父View向子View递归调用 layout 方法的过程，即父View根据上一步 measure 得到的布局大小和布局参数，将子View放在合适的位置上。 第三步：onDraw 绘制视图。主要步骤为①：绘制背景，②：绘制自己，③：绘制子View，④：绘制滚动条 View、ViewGroup事件分发ViewGroup 包含 dispatchTouchEvent 、onInterceptTouchEvent 、onTouchEvent三个相关方法，View包含 dispatchTouchEvent、onTouchEvent两个相关方法。 当 Activity 接收到Touch事件时，将遍历子View进行Down事件分发，分发的目的是为了找到真正处理本次完整触摸事件的View，这个View会在 onTouchEvent 返回true。 当某个子View返回true时，就终止事件分发，并同时在ViewGroup中记录该View，接下来的move事件跟up事件都由该子View直接进行处理。 当ViewGroup所有子View都不捕获Down事件时，将触发ViewGroup自身的 onTouchEvent 事件。触发的方式是调用 super.dispatchTouchEvent函数，即调用父View的dispatchTouchEvent方法。 Handler实现原理Android的主线程不能进行耗时操作，子线程不能进行更新UI，所以就有了Handler，它的作用就是实现线程之间的通信。 Handler整个流程中主要有四个对象：Handler、Message、MessageQueue、Looper。通过将要传递的消息放在Message中，Handler通过 sendMessage 方法将消息放入 MessageQueue 中，Looper 对象会不断的调用loop() 方法不断从 MessageQueue 中取出 Message 交给 Handler进行处理。 Android内存泄露 内存泄漏跟内存溢出的区别： 内存泄漏：指程序在申请内存后，无法释放已经申请的内存空间 内存溢出：指程序在申请内存时，没有足够的内存空间供其使用 内存泄漏的原因： Handler引起的内存泄漏： 将Handler声明为静态内部类，就不会持有外部类的引用，其生命周期就跟外部类无关。如果Handler内部要使用Context，则可以使用弱引用的方式。 单例模式引起的内存泄漏： Context是ApplicationCotnext，ApplicationCotnext的生命周期与app一致，不会导致内存泄漏. 非静态内部类创建实例引起的： 创建为静态实例 非静态匿名内部类引起的： 将匿名内部类修改为静态的 注册/反注册未成对使用引起的内存泄漏 注册广播接受器、EventBus等，记得解绑 资源对象没有关闭引起的内存泄漏 在这些资源不使用的时候，记得调用相应的类似close()、destroy()、recycler()、release()等方法释放 集合对象没有及时清理引起的内存泄漏 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用 内存泄漏检测：LeakCanary ANRANR全名”Application not responding”，即应用无响应。产生的原因： 5s内无法响应用户输入事件 广播在10s内无法结束 Service在20s内无法结束]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android和java泛型扫盲]]></title>
    <url>%2Fposts%2Fc4ef6275.html</url>
    <content type="text"><![CDATA[Android、Java泛型扫盲首先我们定义A、B、C、D四个类，他们的关系如下 class A &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125;class D extends C &#123;&#125; 不指明泛型类型//以下代码均编译通过List list = new ArrayList();//不指明泛型类型，泛型默认为Object类型，故能往里面添加任意实例对象list.add(new A());list.add(new B());list.add(new C());//取出则默认为Object类型Object o = list.get(0); 这个好理解，因为所有的类都继承与Object，故能往list里面添加任意实例对象 无边界通配符 ？首先我们要明白一个概念，通配符？意义就是它是一个未知的符号，可以是代表任意的类。 //我们发现，这样写编译不通过，原因很简单，泛型不匹配，虽然B继承AList&lt;A&gt; listA = new ArrayList&lt;B&gt;(); //以下5行代码均编译通过List&lt;?&gt; list;list = new ArrayList&lt;A&gt;();list = new ArrayList&lt;B&gt;();list = new ArrayList&lt;C&gt;();list = new ArrayList&lt;D&gt;();Object o = list.get(0); //编译通过list.add(new A()); //编译不通过list.add(new B()); //编译不通过list.add(new C()); //编译不通过list.add(new D()); //编译不通过 知识点 无边界通配符 ？ 能取不能存。这个好理解，因为编译器不知道?具体是啥类型，故不能存；但是任意类型都继承于Object，故能取，但取出默认为Object对象。 上边界符 ？extends继续上代码 List&lt;? extends C&gt; listC;listC = new ArrayList&lt;A&gt;(); //编译不通过listC = new ArrayList&lt;B&gt;(); //编译不通过listC = new ArrayList&lt;C&gt;(); //编译通过listC = new ArrayList&lt;D&gt;(); //编译通过C c = listC.get(0); //编译通过listC.add(new C()); //编译不通过listC.add(new D()); //编译不通过 知识点 上边界符 ? extends 只是限定了赋值给它的实例类型(这里为赋值给listC的实例类型)，且边界包括自身。 上边界符 ? extends 跟 ？ 一样能取不能存，道理是一样的，虽然限定了上边界，但编译器依然不知道 ? 是啥类型，故不能存；但是限定了上边界，故取出来的对象类型默认为上边界的类型 下边界符 ？superList&lt;? super B&gt; listB;listB = new ArrayList&lt;A&gt;(); //编译通过listB = new ArrayList&lt;B&gt;(); //编译通过listB = new ArrayList&lt;C&gt;(); //编译不通过listB = new ArrayList&lt;D&gt;(); //编译不通过Object o = listB.get(0); //编译通过listB.add(new A()); //编译不通过listB.add(new B()); //编译通过listB.add(new C()); //编译通过listB.add(new D()); //编译通过 知识点 下边界符 ？super，跟上边界符一样，只是限定了赋值给它的实例类型，也包括边界自身 下边界符 ？super 能存能取，因为设定了下边界，故我们能存下边界以下的类型，当然也包括边界自身；然而取得时候编译器依然不知道 ? 具体是什么类型，故取出默认为Object类型。 类型擦除首先我们要明白一点：Java 的泛型在编译期有效，在运行期会被删除 我们来看一段代码 //这两个方法写在同一个类里public void list(List&lt;A&gt; listA) &#123;&#125; public void list(List&lt;B&gt; listB) &#123;&#125; 上面的代码会有问题吗？显然是有的，编译器报错，提示如下信息： list(List&lt;A&gt;) clashed with list(List&lt;B&gt;) ; both methods have same erasure 翻译过来就是，在类型擦除后，两个方法具有相同的签名，我们来看看类型擦除后是什么样子 public void list(List listA) &#123;&#125; public void list(List listB) &#123;&#125; 可以看出，两个方法签名完全一致，故编译不通过。 明白了类型擦除，我们还需要明白一个概念 泛型类并没有自己独有的Class类对象 比如并不存在List.class或是List.class，而只有List.class 接下来这个案例就好理解了 List&lt;A&gt; listA = new ArrayList&lt;A&gt;();List&lt;B&gt; listB = new ArrayList&lt;B&gt;();System.out.println(listA.getClass() == listB.getClass()); //输出true 泛型传递现实开发中，我们经常会用到泛型传递，例如我们经常需要对Http请求返回的结果做反序列化操作 public static &lt;T&gt; T fromJson(String result, Class&lt;T&gt; type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 此时我们传进去是什么类型，就会返回自动该类型的对象 String result="xxx";A a = fromJson(result, A.class);B b = fromJson(result, B.class);C c = fromJson(result, C.class);D d = fromJson(result, D.class);Integer integer = fromJson(result, Integer.class);String str = fromJson(result, String.class);Boolean boo = fromJson(result, Boolean.class); 那如果我们想返回一个集合呢，如List&lt;A&gt;，下面这样明显是不对的。 //编译报错，前面类型擦除时，我们讲过，不存List&lt;A&gt;.class这种类型ArrayList&lt;A&gt; list = fromJson(result, ArrayList&lt;A&gt;.class)； 那我们该怎么做呢？首先，我们对fromJson改造一下，如下： //type为一个数组类型public static &lt;T&gt; List&lt;T&gt; fromJson(String result, Class&lt;T[]&gt; type) &#123; try &#123; T[] arr = new Gson().fromJson(result, type);//首先拿到数组 return Arrays.asList(arr); //数组转集合 &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 这个时候我们就可以这么做了 String result="xxx";List&lt;A&gt; listA = fromJson(result, A[].class);List&lt;B&gt; listB = fromJson(result, B[].class);List&lt;C&gt; listC = fromJson(result, C[].class);List&lt;D&gt; listD = fromJson(result, D[].class);List&lt;Integer&gt; listInt = fromJson(result, Integer[].class);List&lt;String&gt; listStr = fromJson(result, String[].class);List&lt;Boolean&gt; listBoo = fromJson(result, Boolean[].class); ok，我在再来，相信大多数Http接口返回的数据格式是这样的： public class Response&lt;T&gt; &#123; private T data; private int code; private String msg; //省略get/set方法&#125; 那这种我们又该如何传递呢？显然用前面的两个fromJson方法都行不通，我们再来改造一下，如下: //这里我们直接传递一个Type类型public static &lt;T&gt; T fromJson(String result, Type type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 这个Type是什么鬼？点进去看看 public interface Type &#123; default String getTypeName() &#123; return toString(); &#125;&#125; 哦，原来就是一个接口，并且只有一个方法，我们再来看看它的实现类 发现有5个实现类，其中4个是接口，另外一个是Class类，我们再来看看Class类的声明 public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; //省略内部代码&#125; 现在有没有明白点，现在我们重点来关注下Type接口的其中一个实现接口ParameterizedType，我们来看下它的内部代码，里面就只有3个方法 public interface ParameterizedType extends Type &#123; /** * 例如: * List&lt;String&gt; list; 则返回 &#123;String.class&#125; * Map&lt;String,Long&gt; map; 则返回 &#123;String.class,Long.class&#125; * Map.Entry&lt;String,Long&gt; entry; 则返回 &#123;String.class,Long.class&#125; * * @return 以数组的形式返回所有的泛型类型 */ Type[] getActualTypeArguments(); /** * 例如: * List&lt;String&gt; list; 则返回 List.class * Map&lt;String,Long&gt; map; 则返回 Map.class * Map.Entry&lt;String,Long&gt; entry; 则返回 Entry.class * * @return 返回泛型类的真实类型 */ Type getRawType(); /** * 例如: * List&lt;String&gt; list; 则返回 null * Map&lt;String,Long&gt; map; 则返回 null * Map.Entry&lt;String,Long&gt; entry; 则返回 Map.class * * @return 返回泛型类持有者的类型，这里可以简单理解为返回外部类的类型，如果没有外部类，则返回null */ Type getOwnerType();&#125; 顾名思义，ParameterizedType 代表一个参数化类型。 这个时候我们来自定义一个类，并实现ParameterizedType接口，如下： public class ParameterizedTypeImpl implements ParameterizedType &#123; private Type rawType;//真实类型 private Type actualType;//泛型类型 public ResponseType(Type rawType,Type actualType) &#123; this.rawType = rawType; this.actualType = actualType; &#125; public Type[] getActualTypeArguments() &#123; return new Type[]&#123;actualType&#125;; &#125; public Type getRawType() &#123; return rawType; &#125; public Type getOwnerType() &#123; return null; &#125;&#125; 我们再次贴出fromJson方法 //这里我们直接传递一个Type类型public static &lt;T&gt; T fromJson(String result, Type type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 此时我们想得到Response&lt;T&gt;对象，就可以这样写 Response&lt;A&gt; responseA = fromJson(result, new ParameterizedTypeImpl(Response.class, A.class));Response&lt;B&gt; responseB = fromJson(result, new ParameterizedTypeImpl(Response.class, B.class));Response&lt;C&gt; responseC = fromJson(result, new ParameterizedTypeImpl(Response.class, C.class)); 想得到List&lt;T&gt;对象，也可以通过ParameterizedTypeImpl得到，如下: List&lt;A&gt; listA = fromJson(result, new ParameterizedTypeImpl(List.class, A.class));List&lt;B&gt; listB = fromJson(result, new ParameterizedTypeImpl(List.class, B.class));List&lt;C&gt; listC = fromJson(result, new ParameterizedTypeImpl(List.class, C.class)); 然而，如果我们想得到Response&lt;List&lt;T&gt;&gt;对象，又该如何得到呢？ ParameterizedTypeImpl一样能够实现，如下： //第一步，创建List&lt;T&gt;对象对应的Type类型Type listAType = new ParameterizedTypeImpl(List.class, A.class);Type listBType = new ParameterizedTypeImpl(List.class, B.class);Type listCType = new ParameterizedTypeImpl(List.class, C.class);//第二步，创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型Type responseListAType = new ParameterizedTypeImpl(Response.class, listAType);Type responseListBType = new ParameterizedTypeImpl(Response.class, listBType);Type responseListCType = new ParameterizedTypeImpl(Response.class, listCType);//第三步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType); 然后，能不能再简单一点呢？可以，我们对ParameterizedTypeImpl改造一下 /** * User: ljx * Date: 2018/10/23 * Time: 09:36 */public class ParameterizedTypeImpl implements ParameterizedType &#123; private final Type rawType; private final Type ownerType; private final Type[] actualTypeArguments; //适用于单个泛型参数的类 public ParameterizedTypeImpl(Type rawType, Type actualType) &#123; this(null, rawType, actualType); &#125; //适用于多个泛型参数的类 public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... actualTypeArguments) &#123; this.rawType = rawType; this.ownerType = ownerType; this.actualTypeArguments = actualTypeArguments; &#125; /** * 本方法仅使用于单个泛型参数的类 * 根据types数组，确定具体的泛型类型 * List&lt;List&lt;String&gt;&gt; 对应 get(List.class, List.class, String.class) * * @param types Type数组 * @return ParameterizedTypeImpl */ public static ParameterizedTypeImpl get(@NonNull Type rawType, @NonNull Type... types) &#123; final int length = types.length; if (length &gt; 1) &#123; Type parameterizedType = new ParameterizedTypeImpl(types[length - 2], types[length - 1]); Type[] newTypes = Arrays.copyOf(types, length - 1); newTypes[newTypes.length - 1] = parameterizedType; return get(rawType, newTypes); &#125; return new ParameterizedTypeImpl(rawType, types[0]); &#125; //适用于多个泛型参数的类 public static ParameterizedTypeImpl getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments) &#123; return new ParameterizedTypeImpl(null, rawType, actualTypeArguments); &#125; public final Type[] getActualTypeArguments() &#123; return actualTypeArguments; &#125; public final Type getOwnerType() &#123; return ownerType; &#125; public final Type getRawType() &#123; return rawType; &#125;&#125; 此时，我们就可以这样写 //第一步，直接创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型Type responseListAType = ParameterizedTypeImpl.get(Response.class, List.class, A.class);Type responseListBType = ParameterizedTypeImpl.get(Response.class, List.class, B.class)Type responseListCType = ParameterizedTypeImpl.get(Response.class, List.class, C.class)//第二步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType); 现实开发中，我们还可能遇到这样的数据结构 &#123; "code": 0, "msg": "", "data": &#123; "totalPage": 0, "list": [] &#125;&#125; 此时，Response&lt;T&gt; 里面的泛型传List肯定是不能正常解析的，我们需要再定一个类 public class PageList&lt;T&gt;&#123; private int totalPage; private List&lt;T&gt; list; //省略get/set方法&#125; 此时就可以这样解析数据 //第一步，直接创建Response&lt;PageList&lt;T&gt;&gt;对象对应的Type类型Type responsePageListAType = ParameterizedTypeImpl.get(Response.class, PageList.class, A.class);Type responsePageListBType = ParameterizedTypeImpl.get(Response.class, PageList.class, B.class)Type responsePageListCType = ParameterizedTypeImpl.get(Response.class, PageList.class, C.class)//第二步，通过Type对象，获取对应的Response&lt;PageList&lt;T&gt;&gt;对象Response&lt;PageList&lt;A&gt;&gt; responsePageListA = fromJson(result, responsePageListAType);Response&lt;PageList&lt;B&gt;&gt; responsePageListB = fromJson(result, responsePageListBType);Response&lt;PageList&lt;C&gt;&gt; responsePageListC = fromJson(result, responsePageListCType); 注：ParameterizedTypeImpl get(Type... types)仅仅适用于单个泛型参数的时候，如Map等，有两个泛型参数以上的不要用此方法获取Type类型。如果需要获取Map等两个泛型参数以上的Type类型。可调用getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments)构造方法获取，如： //获取 Map&lt;String,String&gt; 对应的Type类型Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, String.classs, String.class)//获取 Map&lt;A,B&gt; 对应的Type类型Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, A.classs, B.class) 到这，泛型相关知识点讲解完毕，如有疑问，请留言。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5 to ESNext 自2015以来JavaScript新增的所有新特性]]></title>
    <url>%2Fposts%2Fbf9085e4.html</url>
    <content type="text"><![CDATA[这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。 JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。 JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。 目录ECMAScript 简介ES2015 let 和 const 箭头函数 类 默认参数 模板字符串 解构赋值 增强的对象字面量 For-of 循环 Promises 模块 String 新方法 Object 新方法 展开运算符 Set Map Generators ES2016 Array.prototype.includes() 求幂运算符 ES2017 字符串填充 Object.values() Object.entries() Object.getOwnPropertyDescriptors() 尾逗号 共享内存 and 原子操作 ES2018 Rest/Spread Properties Asynchronous iteration Promise.prototype.finally() 正则表达式改进 ESNext Array.prototype.{flat,flatMap} try/catch 可选的参数绑定 Object.fromEntries() String.prototype.{trimStart,trimEnd} Symbol.prototype.description JSON improvements Well-formed JSON.stringify() Function.prototype.toString() ECMAScript 简介每当阅读 JavaScript 相关的文章时，我都会经常遇到如下术语： ES3, ES5, ES6, ES7, ES8, ES2015, ES2016, ES2017, ECMAScript 2017, ECMAScript 2016, ECMAScript 2015 等等，那么它们是指代的是什么？ 它们都是指代一个名为 ECMAScript 的标准。 JavaScript 就是基于这个标准实现的，ECMAScript 经常缩写为 ES。 除了 JavaScript 以外，其它基于 ECMAScript 实现语言包括： ActionScript ( Flash 脚本语言)，由于 Adobe 将于 2020 年末停止对 Flash 的支持而逐渐失去热度。 JScript (微软开发的脚本语言),在第一次浏览器大战最激烈的时期，JavaScript 只被Netscape所支持，微软必须为 Internet Explorer 构建自己的脚本语言。 但是现在流传最广、影响最大的基于 ES 标准的语言实现无疑就是 JavaScript了 为啥要用这个奇怪的名字呢？Ecma International 是瑞士标准协会，负责制定国际标准。 JavaScript 被创建以后，经由 Netscape 和 Sun Microsystems 公司提交给欧洲计算机制造商协会进行标准化，被采纳的 ECMA-262 别名叫 ECMAScript。 This press release by Netscape and Sun Microsystems (the maker of Java) might help figure out the name choice, which might include legal and branding issues by Microsoft which was in the committee, according to Wikipedia. IE9 之后微软的浏览器中就看不到对 JScript 这个命名的引用了，取而代之都统称为 JavaScript。 因此，截至201x，JavaScript 成为最流行的基于 ECMAScript 规范实现的语言。 ECMAScript 当前的版本。目前的最新的 ECMAScript 版本是 ES2018。 于 2018 年 6 月发布。 TC39 是什么？TC39（Technical Committee 39）是一个推动 JavaScript 发展的委员会。 TC39的成员包括各个主流浏览器厂商以及业务与浏览器紧密相连的公司，其中包括 Mozilla，Google ，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。 每个标准版本提案都必须经过四个不同的阶段，这里有详细的解释。 ES Versions令我费解的是 ES 版本的命名依据有时根据迭代的版本号，有时却根据年份来进行命名。而这个命名的不确定性又使得人们更加容易混淆 JS/ES 这个两个概念😄。 在 ES2015 之前，ECMAScript 各个版本的命名规范通常与跟着标准的版本更新保持一致。因此，2009年 ECMAScript 规范更新以后的的正式版本是 ES5。 Why does this happen? During the process that led to ES2015, the name was changed from ES6 to ES2015, but since this was done late, people still referenced it as ES6, and the community has not left the edition naming behind — the world is still calling ES releases by edition number. 为什么会发生这一切？在ES2015诞生的过程中，名称由ES6更改为ES2015，但由于最终完成太晚，人们仍然称其为ES6，社区也没有将版本号完全抛之于后 — 世界仍然使用 ES 来定义版本号。 接下来，我们来深入了解 JavaScript 自 ES5 以来增加的特性。 let和constES2015 之前, var 是唯一可以用来声明变量的语句。 var a = 0 上面语句如果你遗漏了 var，那么你会把这个值（0）赋给一个未声明的变量，其中声明和未声明变量之间存在一些差异。 在现代浏览器开启严格模式时，给未声明的变量赋值会抛出 ReferenceError 异常，在较老的浏览器（或者禁用严格模式）的情况下，未声明的变量在执行赋值操作时会隐式的变为全局对象的属性。 当你声明一个变量却没有进行初始化，那么它的值直到你对它进行赋值操作之前都是 undefined 。 var a //typeof a === 'undefined' 你可以对一个变量进行多次重新声明，并覆盖它： var a = 1var a = 2 你也可以在一条声明语句中一次声明多个变量： var a = 1, b = 2 作用域是变量可访问的代码部分。 在函数之外用 var 声明的会分配给全局对象，这种变量可以在全局作用域中被访问到。而在函数内部声明的变量只能在函数局部作用域被访问到，这类似于函数参数。 在函数中定义的局部变量名如何跟全局变量重名，那么局部变量的优先级更高，在函数内无法访问到同名的全局变量。 需要注意的是，var 是没有块级作用域（标识符是一对花括号）的，但是 var 是有函数作用域的，所以在新创建的块级作用域或者是函数作用域里面声明变量会覆盖全局同名变量，因为 var 在这两种情况下没有创建新的作用域。 在函数内部，其中定义的任何变量在所有函数代码中都是可见的，因为JavaScript在执行代码之前实际上将所有变量都移到了顶层（被称为悬挂的东西）。 在函数的内部定义的变量在整个函数作用域中都是可见（可访问），即使变量是在函数体末尾被声明，但是仍然可以再函数体开头部分被引用，因为 JavaScript存在变量提升机制。为避免混淆，请在函数开头声明变量，养成良好的编码规范。 Using letlet 是ES2015中引入的新功能，它本质上是具有块级作用域的 var 。它可以被当前作用域（函数以及块级作用域）以及子级作用域访问到。 现代 JavaScript 开发者在 let 和 var 的选择中可能会更倾向于前者。 如果 let 看起来是一个很抽象的术语，当你阅读到 let color = ‘red’ 这一段，因为使用 let 定义了color 为红色，那么这一切就变的有意义了。 在任何函数之外用 let 声明变量，和 var相反的是 它并不会创建全局变量。 Using const使用变量 var 或 let 声明的变量可以被重新赋值。 使用 const 声明的变量一经初始化，它的值就永远不能再改变，即不可重新被赋值。 const a = 'test' 我们不能再为 a 进行赋值操作。然而，a 如果它是一个具有属性或者方法的对象，那么我们可以改变它的属性或者方法。 const 并不意味着具有不可变性，只是保证用 const 声明的变量的引用地址不被变更。 类似于 let，const 也具有块级作用域。 现代 JavaScript 开发者在遇到不会进行二次赋值的变量声明时，应该尽量使用 const。 箭头函数箭头函数的引入极大的改变了代码的书写风格和一些工作机制。 在我看来，箭头函数很受开发者欢迎，现在很少在比较新的代码库中看到 function 关键字了，虽然它并未被废弃。 箭头函数看起来会更加的简洁，因为它允许你使用更短的语法来书写函数： const myFunction = function() &#123; //...&#125; 到 const myFunction = () =&gt; &#123; //...&#125; 如果函数体中只包含一条语句，你甚至可以省略大括号并直接书写这条语句： const myFunction = () =&gt; doSomething() 参数在括号中传递： const myFunction = (param1, param2) =&gt; doSomething(param1, param2) 如果该函数只有一个参数，那么可以省略掉括号： const myFunction = param =&gt; doSomething(param) 由于这种简短的语法，使得我们可以更便捷的使用比较简短的函数 隐式返回箭头函数支持隐式返回：可以正常的 return 一个返回值但是可以不使用 return 关键字。 隐式返回只在函数体内只包含一条语句的情况下生效： const myFunction = () =&gt; 'test'myFunction() //'test' 需要注意的一种情况，当返回一个对象时，记得将大括号括在括号中以避免产生歧义，误将其（大括号）解析为函数体的大括号。 const myFunction = () =&gt; (&#123; value:'test' &#125;)myFunction() //&#123;value: 'test'&#125; 箭头函数中的 thisthis 可能是一个很难掌握的概念，因为它会根据上下文而进行变化，并且会在不同的 JavaScript的模式（是否为严格模式）下表现出差异。 理解 this 这个概念对于箭头函数的使用很重要，因为与常规函数相比，箭头函数的表现非常不同。 对象的方法为常规函数时，方法中的this指向这个对象，因此可以这样做： const car = &#123; model:'Fiesta', manufacturer:'Ford', fullName:function() &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 执行 car.fullName() 会返回 “Ford Fiesta”。 如果上述方法使用是是箭头函数，由于箭头中的 this 的作用域继承自执行上下文，箭头函数自身不绑定 this，因此 this 的值将在调用堆栈中查找，因此在此代码 car.fullName() 中不会返回常规函数那样的结果，实际会返回字符串 “undefined undefined”： const car = &#123; model:'Fiesta', manufacturer:'Ford', fullName:() =&gt; &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 因此，箭头函数不适合作为对象方法。 同样，箭头函数也不适合使用在作为创建构造函数，因为在实例化对象时会抛出 TypeError。 所以在不需要动态上下文时请使用常规函数。 当然，在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数： const link = document.querySelector('#link')link.addEventListener('click', () =&gt; &#123; // this === window&#125;)const link = document.querySelector('#link')link.addEventListener('click', function() &#123; // this === link&#125;) Classes类JavaScript 实现继承的方式比较罕见：原型继承。原型继承虽然在我看来很棒，但与其它大多数流行的编程语言的继承实现机制不同，后者是基于类的。 因此 Java、Python 或其它语言的开发者很难理解原型继承的方式，因此 ECMAScript 委员会决定在原型继承之上实现 class 的语法糖，这样便于让其它基于类实现继承的语言的开发者更好的理解 JavaScript 代码。 注意：class 并没有对 JavaScript 底层做修改，你仍然可以直接访问对象原型。 class 定义如下是一个 class 的例子： class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125; class 具有一个标识符，我们可以使用 new ClassIdentifier() 来创建一个对象实例。 初始化对象时，调用 constructor方法，并将参数传递给此方法。 类声明语句中也可以增加类需要的一些原型方法。在这种情况下 hello 是 Person 类的一个原型方法，可以在这个类的对象实例上调用： const flavio = new Person('Flavio')flavio.hello() Class 继承一个子类可以 extend 另一个类，通过子类实例化出来的对象可以继承这两个类的所有方法。 如果子类中的方法与父类中的方法名重复，那么子类中的同名方法优先级更高： class Programmer extends Person &#123; hello() &#123; return super.hello() + ' I am a programmer.' &#125;&#125;const flavio = new Programmer('Flavio')flavio.hello() (上述代码会打印出：“Hello, I am Flavio. I am a programmer.”) 类没有显示的类变量声明，但你必须在初始化构造函数 constructor 中去初始化类成员变量。 在子类中，你可以通过调用super()引用父类。 静态方法在类中，通常会把方法直接挂载到实例对象上，直接在实例对象上调用。 而静态方法则是直接使用类名来调用，而不是通过对象实例调用： class Person &#123; static genericHello() &#123; return 'Hello' &#125;&#125;Person.genericHello() //Hello 私有方法JavaScript 没有内置真正意义上的受保护的私有方法。 社区有解决方法，但我不会在这里做讲解。 Getters 和 setters你可以通过增加方法 前缀 get 或者 set 创建一个 getter 和 setter，getter 和 setter会在你去获取特定值或者修改特定值的时候执行 get 或者 set内的相关方法。 class Person &#123; constructor(name) &#123; this._name = name &#125; set name(value) &#123; this._name = value &#125; get name() &#123; return this._name &#125;&#125; 如果你只有 getter，该属性无法被设置，并且设置此属性的操作都会被忽略： class Person &#123; constructor(name) &#123; this._name = name &#125; get name() &#123; return this._name &#125;&#125; 如果你只有一个 setter，则可以更改该值，但不能从外部访问它： class Person &#123; constructor(name) &#123; this._name = name &#125; set name(value) &#123; this._name = value &#125;&#125; 默认参数函数 doSomething 接收一个 param1 参数。 const doSomething = (param1) =&gt; &#123;&#125; 我们可以给 param1 设定默认值，如果在调用函数时未传入参数，那么该参数自动设定未默认值。 const doSomething = (param1 = 'test') =&gt; &#123;&#125; 当然，这种机制同样适用于多个参数： const doSomething = (param1 = 'test', param2 = 'test2') =&gt; &#123;&#125; 假如你的函数是一个具有特定属性的对象该怎么处理？ 曾几何时，如果我们必须要取一个对象的特定属性值，为了做兼容处理（对象格式不正确），你必须在函数中添加一些代码： const colorize = (options) =&gt; &#123; if (!options) &#123; options = &#123;&#125; &#125; const color = ('color' in options) ? options.color :'yellow' ...&#125; 通过解构，你可以给特定属性提供默认值，如此可以大大简化代码： const colorize = (&#123; color = &apos;yellow&apos; &#125;) =&gt; &#123; ...&#125; 如果在调用 colorize 函数时没有传递任何对象，我们同样可以得到一个默认对象作为参数以供使用： const spin = (&#123; color = 'yellow' &#125; = &#123;&#125;) =&gt; &#123; ...&#125; 模板字符串模板字符串不同于 ES5 以前的版本，你可以用新颖的方式使用字符串。 这个语法看起来非常简便，只需要使用一个反引号替换掉单引号或双引号： const a_string = `something` 这个用法是独一无二的，因为它提供了许多普通字符串所没有的功能，如下： 它为定义多行字符串提供了一个很好的语法 它提供了一种在字符串中插入变量和表达式的简单方法 它允许您创建带有模板标签的DSL (DSL意味着领域特定语言，例如：就如同在 React 中使用 styled-components 定义你组件的 CSS 一样) 下面让我们深入每个功能的细节。 多行字符串在 ES6 标准之前，创建跨越两行的字符串只能在一行的结尾使用 ‘’ 字符： const string = 'first partsecond part' 这样使得你创建的字符串虽然跨越了两汉，但是渲染时仍然表现成一行： first part second part 需要渲染为多行的话，需要在一行结尾添加 ‘ ’，比如这样： const string = 'first line second line' 或者 const string = 'first line'+ 'second line' 模板字符串使得定义多行字符串变得更加简便。 一个模板字符串由一个反引号开始，你只需要按下回车键来创建新的一行，不需要插入特殊符号，最终的渲染效果如下所示： const string = `Heythisstringis awesome!` 需要特别留意空格在这里是有特殊意义的，如果这样做的话： const string = `First Second` 那么它会创建出像下面的字符串： First Second 有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格： const string = `FirstSecond`.trim() 插值模板字符串提供了插入变量和表达式的便捷方法 你只需要使用 ${…} 语法 const var = 'test'const string = `something $&#123;var&#125;` //something test 在 ${} 里面你可以加入任何东西，甚至是表达式： const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y'&#125;` Template tags标记模板可能是一个听起来不太有用的功能，但它实际上被许多流行的库使用，如 Styled Components 、Apollo 、GraphQL客户端/服务器库，因此了解它的工作原理至关重要。 在 Styled Components 模板标签中用于定义CSS字符串 const Button = styled.button` font-size: 1.5em; background-color: black; color: white; 在 Apollo 中，模板标签用于定义 GraphQL 查询模式： const query = gql` query &#123; ... &#125;` 上面两个例子中的styled.button和gql模板标签其实都是函数: function gql(literals, ...expressions) &#123;&#125; 这个函数返回一个字符串，可以是任意类型的计算结果。 字面量(literals)是一个包含了表达式插值的模板字面量的序列。 表达式(expressions)包含了所有的插值。 举个例子： const string = `something $&#123;1 + 2 + 3&#125;` 这个例子里面的字面量是由2个部分组成的序列。第1部分就是something，也就是第一个插值位置(${})之前的字符串，第2部分就是一个空字符串，从第1个插值结束的位置直到字符串的结束。 这个例子里面的表达式就是只包含1个部分的序列，也就是6。 举一个更复杂的例子： const string = `somethinganother $&#123;'x'&#125;new line $&#123;1 + 2 + 3&#125;test` 这个例子里面的字面量的序列里面，第1个部分是： ;`somethinganother ` 第2部分是： ;`new line ` 第3部分是： ;`test` 这个例子里面的表达式包含了2个部分：x和6。 拿到了这些值的函数就可以对其做任意处理，这就是这个特性的威力所在。 比如最简单的处理就是字符串插值，把字面量和表达式拼接起来： const interpolated = interpolate`I paid $&#123;10&#125;€` 插值的过程就是： function interpolate(literals, ...expressions) &#123; let string = `` for (const [i, val] of expressions) &#123; string += literals[i] + val &#125; string += literals[literals.length - 1] return string&#125; 解构赋值给定一个object，你可以抽取其中的一些值并且赋值给命名的变量： const person = &#123; firstName:'Tom', lastName:'Cruise', actor:true, age:54, //made up&#125;const &#123;firstName: name, age&#125; = person name和age就包含了对应的值。 这个语法同样可以用到数组当中： const a = [1,2,3,4,5]const [first, second] = a 下面这个语句创建了3个新的变量，分别取的是数组a的第0、1、4下标对应的值： const [first, second, , , fifth] = a 更强大的对象字面量ES2015赋予了对象字面量更大的威力。 简化了包含变量的语法原来的写法： const something = 'y'const x = &#123; something: something&#125; 新的写法： const something = 'y'const x = &#123; something&#125; 原型原型可以这样指定： const anObject = &#123; y:'y' &#125;const x = &#123; __proto__: anObject&#125;super()const anObject = &#123; y:'y', test:() =&gt; 'zoo' &#125;const x = &#123; __proto__: anObject, test() &#123; return super.test() + 'x' &#125;&#125;x.test() //zoox 动态属性const x = &#123; ['a' + '_' + 'b']:'z'&#125;x.a_b //z For-of循环2009年的ES5引入了forEach()循环。虽然很好用，但是它跟for循环一样，没法break。 ES2015引入了for-of 循环，就是在forEach的基础上加上了break的功能： //iterate over the valuefor (const v of ['a', 'b', 'c']) &#123; console.log(v);&#125;//get the index as well, using `entries()`for (const [i, v] of ['a', 'b', 'c'].entries()) &#123; console.log(index) //index console.log(value) //value&#125; 留意一下const的使用。这个循环在每次迭代中都会创建一个新的作用域，所以我们可以使用const来代替let。 它跟for…in的区别在于： for…of遍历属性值 for…in遍历属性名 Promisespromise的一般定义： 它是一个代理，通过它可以最终得到一个值. Promise是处理异步代码的一种方式，可以少写很多回调。 异步函数是建立在promise API上面的，所以理解Promise是一个基本的要求。 promise的原理简述一个promise被调用的时候，首先它是处于pending状态。在promise处理的过程中，调用的函数（caller）可以继续执行，直到promise给出反馈。 此时，调用的函数等待的promise结果要么是resolved状态，要么是rejected状态。但是由于JavaScript是异步的，所以promise处理的过程中，函数会继续执行。 为什么JS API使用promises?除了你的代码和第三方库的代码之外，promise在用在现代的Web API中，比如： 电池API Fetch API Service Workers 在现代的JavaScript中，不使用promise是不太可能的，所以我们来深入研究下promise吧。 创建一个promisePromise API暴露了一个Promise构造函数，可以通过new Promise()来初始化： let done = trueconst isItDoneYet = new Promise((resolve, reject) =&gt; &#123; if (done) &#123; const workDone = 'Here is the thing I built' resolve(workDone) &#125; else &#123; const why = 'Still working on something else' reject(why) &#125;&#125;) promise会检查done这个全局变量，如果为true，就返回一个resolved promise，否则就返回一个rejected promise。 通过resolve和reject，我们可以得到一个返回值，返回值可以是字符串也可以是对象。 使用一个promise上面讲了怎么创建一个promise，下面就讲怎么使用（consume）这个promise。 const isItDoneYet = new Promise()//...const checkIfItsDone = () =&gt; &#123; isItDoneYet .then(ok =&gt; &#123; console.log(ok) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;)&#125; 运行checkIfItsDone()方法时，会执行isItDoneYet()这个promise，并且等待它resolve的时候使用then回调，如果有错误，就用catch回调来处理。 链式promise一个promise可以返回另一个promise，从而创建promise链条（chain）。 一个很好的例子就是Fetch API，它是基于XMLHttpRequest API的一个上层API，我们可以用它来获取资源，并且在获取到资源的时候链式执行一系列promise。 Fetch API是一个基于promise的机制，调用fetch()相当于使用new Promise()来声明我们自己的promise。 链式promise的例子 const status = response =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return Promise.resolve(response) &#125; return Promise.reject(new Error(response.statusText))&#125;const json = response =&gt; response.json()fetch('/todos.json') .then(status) .then(json) .then(data =&gt; &#123; console.log('Request succeeded with JSON response', data) &#125;) .catch(error =&gt; &#123; console.log('Request failed', error) &#125;) 在这个例子当中，我们调用fetch()，从根目录的todos.json文件中获取一系列的TODO项目，并且创建一个链式promise。 运行fetch()方法会返回一个response，它包含很多属性，我们从中引用如下属性： status, 一个数值，表示HTTP状态码 statusText, 一个状态消息，当请求成功的时候返回OK response还有一个json()方法，它返回一个promise，返回内容转换成JSON后的结果。 所以这些promise的调用过程就是：第一个promise执行一个我们定义的status()方法，检查response status，判断是否一个成功的响应(status在200和299之间)，如果不是成功的响应，就reject这个promise。 这个reject操作会导致整个链式promise跳过后面的所有promise直接到catch()语句，打印Request failed和错误消息。 如果这个promise成功了，它会调用我们定义的json()函数。因为前面的promise成功之后返回的response对象，我们可以拿到并作为第2个promise的参数传入。 在这个例子里面，我们返回了JSON序列化的数据，所以第3个promise直接接收这个JSON： .then((data) =&gt; &#123; console.log('Request succeeded with JSON response', data)&#125;) 然后我们把它打印到console。 处理错误在上一节的的例子里面，我们有一个catch接在链式promise后面。 当promise链中的任意一个出错或者reject的时候，就会直接跳到promise链后面最近的catch()语句。 new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;).catch(err =&gt; &#123; console.error(err)&#125;)// ornew Promise((resolve, reject) =&gt; &#123; reject('Error')&#125;).catch(err =&gt; &#123; console.error(err)&#125;) 级联错误如果在catch()里面抛出一个错误，你可以在后面接上第二个catch()来处理这个错误，以此类推。 new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;) .catch(err =&gt; &#123; throw new Error('Error') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 组织多个promisePromise.all()如果你要同时完成不同的promise,可以用Promise.all()来声明一系列的promise，然后当它们全部resolve的时候再执行一些操作。 例子： const f1 = fetch('/something.json')const f2 = fetch('/something2.json')Promise.all([f1, f2]) .then(res =&gt; &#123; console.log('Array of results', res) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 结合ES2015的解构赋值语法，你可以这样写： Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123; console.log('Results', res1, res2)&#125;) 当然这不限于使用fetch， 这适用于任何promise. Promise.race()Promise.race()运行所有传递进去的promise，但是只要有其中一个resolve了，就会运行回调函数，并且只执行一次回调，回调的参数就是第一个resolve的promise返回的结果。 例子： const promiseOne = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, 'one')&#125;)const promiseTwo = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'two')&#125;)Promise.race([promiseOne, promiseTwo]).then(result =&gt; &#123; console.log(result) // 'two'&#125;) 模块ES Module是用于处理模块的ECMAScript标准。 虽然 Node.js 多年来一直使用 CommonJS标准，但浏览器却从未有过模块系统，因为模块系统的决策首先需要 ECMAScript 标准化后才由浏览器厂商去实施实现。 这个标准化已经完成在 ES2015中，浏览器也开始实施实现这个标准，大家试图保持一致，以相同的方式工作。现在 ES Module 可以在 Chrome Safari Edge 和 Firefox（从60版本开始） 中使用。 模块非常酷，他们可以让你封装各种各样的功能，同时将这些功能作为库暴露给其它 JavaScript 文件使用。 ES 模块语法引入模块的语法: import package from 'module-name' CommonJS 则是这样使用： const package = require('module-name') 一个模块是一个 JavaScript 文件，这个文件使用 export 关键字 导出 一个或多个值（对象、函数或者变量）。例如，下面这个模块提供了一个将字符串变成大写形式的函数： uppercase.jsexport default str =&gt; str.toUpperCase() 在这个例子中，这个模块定义了唯一一个 default export，因此可以是一个匿名函数。否则，需要一个名称来和其它 导出 做区分。 现在，任何其它的 JavaScript 模块 可以通过 import 导入 uppercase.js 的这个功能。 一个 HTML 页面可以通过使用了特殊的 type=module 属性的 &lt;script&gt; 标签添加一个模块。 &lt;script type="module" src="index.js"&gt;&lt;/script&gt; 注意: 这个模块导入的行为就像 defer 脚本加载一样。具体可以看 efficiently load JavaScript with defer and async 需要特别注意的是，任何通过 type=”module” 载入的脚本会使用 严格模式 加载。 在这个例子中，uppercase.js 模块定义了一个 default export，因此当我们在导入它的时候，我们可以给他起一个任何我们喜欢的名字： import toUpperCase from './uppercase.js' 同时我们可以这样使用它: toUpperCase('test') //'TEST' 你也可以通过一个绝对路径来导入模块，下面是一个引用来自其它域底下定义的模块的例子： import toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js' 下面同样是一些合法的 import语法： import &#123; toUpperCase &#125; from '/uppercase.js'import &#123; toUpperCase &#125; from '../uppercase.js' 下面是错误的使用: import &#123; toUpperCase &#125; from 'uppercase.js'import &#123; toUpperCase &#125; from 'utils/uppercase.js' 因为这里既不是使用绝对地址，也不是使用的相对地址。 其它的 import/export 语法我们了解了上面的例子： export default str =&gt; str.toUpperCase() 这里生成了一个 default export。然而，你可以通过下面的语法在一个文件里面 导出 多个功能： const a = 1const b = 2const c = 3export &#123; a, b, c &#125; 另外一个模块可以使用下面的方式 import 导入所有： import * from 'module' 你也可以通过解构赋值的方式仅仅 import 导出一部分： import &#123; a &#125; from 'module'import &#123; a, b &#125; from 'module' 为了方便，你还可以使用 as 重命名任何 import 的东西： import &#123; a, b as two &#125; from 'module' 你可以导入模块中的默认出口以及通过名称导入任何非默认的出口： import React, &#123; Component &#125; from 'react' 这是一篇关于 ES 模块的文章，可以看一下： https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html CORS(跨域资源共享)进行远程获取模块的时候是遵循 CORS 机制的。这意味着当你引用远程模块的时候，必须使用合法的 CORS 请求头来允许跨域访问（例如：Access-Control-Allow-Origin: *）。 对于不支持模块的浏览器应该怎么做？结合 type=”module”、nomodule 一起使用： &lt;script type="module" src="module.js"&gt;&lt;/script&gt;&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt; 包装模块ES 模块是现代浏览器中的一大特性。这些特性是 ES6 规范中的一部分，要在浏览器中全部实现这些特性的路还很漫长。 我们现在就能使用它们！但是我们同样需要知道，有一些模块会对我们的页面性能产生性能影响。因为浏览器必须要在运行时执行它们。 Webpack 可能仍然会被大量使用，即使 ES 模块可以在浏览器中执行。但是语言内置这个特性对于客户端和 nodejs 在使用模块的时候是一种巨大的统一。 新的字符串方法任何字符串有了一些实例方法： repeat() codePointAt() repeat() 根据指定的次数重复字符串： 'Ho'.repeat(3) //'HoHoHo' 没有提供参数以及使用 0 作为参数的时候返回空字符串。如果给一个负数参数则会得到一个 RangeError 的错误。 codePointAt()这个方法能用在处理那些需要 2 个 UTF-16 单元表示的字符上。 使用 charCodeAt 的话，你需要先分别得到两个 UTF-16 的编码然后结合它们。但是使用 codePointAt() 你可以直接得到整个字符。 下面是一个例子，中文的 “𠮷” 是由两个 UTF-16 编码组合而成的： "𠮷".charCodeAt(0).toString(16) //d842"𠮷".charCodeAt(1).toString(16) //dfb7 如果你将两个 unicode 字符组合起来： "𠮷" //"𠮷" 你也可以用 codePointAt() 得到同样的结果: "𠮷".codePointAt(0) //20bb7 如果你将得到的 unicode 编码组合起来： "𠮷" //"𠮷" 更多关于 Unicode 的使用方法，参考我的Unicode guide。 新的对象方法ES2015 在 Object 类下引入了一些静态方法： Object.is() 确定两个值是不是同一个 Object.assign() 用来浅拷贝一个对象 Object.setPrototypeOf 设置一个对象的原型 Object.is() 这个方法用来帮助比较对象的值： 使用方式: Object.is(a, b) 返回值在下列情况之外一直是 false： a 和 b 是同一个对象 a 和 b 是相等的字符串(用同样的字符组合在一起的字符串是相等的) a 和 b 是相等的数字 a 和 b 都是 undefined, null, NaN, true 或者都是 false 0 和 -0 在 JavaScript 里面是不同的值, 所以对这种情况要多加小心（例如在比较之前，使用 + 一元操作符将所有值转换成 +0）。 Object.assign()在 ES2015 版本中引入，这个方法拷贝所有给出的对象中的可枚举的自身属性到另一个对象中。 这个 API 的基本用法是创建一个对象的浅拷贝。 const copied = Object.assign(&#123;&#125;, original) 作为浅拷贝，值会被复制，对象则是拷贝其引用（不是对象本身），因此当你修改了源对象的一个属性值，这个修改也会在拷贝出的对象中生效，因为内部引用的对象是相同的。: const original = &#123; name:'Fiesta', car:&#123; color:'blue' &#125;&#125;const copied = Object.assign(&#123;&#125;, original)original.name = 'Focus'original.car.color = 'yellow'copied.name //Fiestacopied.car.color //yellow 我之前提到过，源对象可以是一个或者多个: const wisePerson = &#123; isWise:true&#125;const foolishPerson = &#123; isFoolish:true&#125;const wiseAndFoolishPerson = Object.assign(&#123;&#125;, wisePerson, foolishPerson)console.log(wiseAndFoolishPerson) //&#123; isWise: true, isFoolish: true &#125;Object.setPrototypeOf() 设置一个对象的原型。可以接受两个参数：对象以及原型。 使用方法: Object.setPrototypeOf(object, prototype) 例子: const animal = &#123; isAnimal:true&#125;const mammal = &#123; isMammal:true&#125;mammal.__proto__ = animalmammal.isAnimal //trueconst dog = Object.create(animal)dog.isAnimal //trueconsole.log(dog.isMammal) //undefinedObject.setPrototypeOf(dog, mammal)dog.isAnimal //truedog.isMammal //true 展开操作符你可以展开一个数组、一个对象甚至是一个字符串，通过使用展开操作符 …。 让我们以数组来举例，给出： const a = [1, 2, 3] 你可以使用下面的方式创建出一个新的数组： const b = [...a, 4, 5, 6] 你也可以像下面这样创建一个数组的拷贝： const c = [...a] 这中方式对于对象仍然有效。使用下面的方式克隆一个对象： const newObj = &#123; ...oldObj &#125; 用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组： const hey = 'hey'const arrayized = [...hey] // ['h', 'e', 'y'] 这个操作符有一些非常有用的应用。其中最重要的一点就是以一种非常简单的方式使用数组作为函数参数的能力： const f = (foo, bar) =&gt; &#123;&#125;const a = [1, 2]f(...a) （在之前的语法规范中，你只能通过 f.apply(null, a) 的方式来实现，但是这种方式不是很友好和易读。） 剩余参数（rest element）在和数组解构（array destructuring）搭配使用的时候非常有用。 const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers 下面是展开元素 （spread elements）: const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) ES2018 引入了 剩余属性 ，同样的操作符但是只能用在对象上。 剩余属性（Rest properties）:const &#123; first, second, ...others &#125; = &#123; first:1, second:2, third:3, fourth:4, fifth:5&#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 属性展开（Spread properties）允许我们结合跟在 … 操作符之后对象的属性： const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; Set一个 Set 数据结构允许我们在一个容器里面增加数据。 一个 Set 是一个对象或者基础数据类型（strings、numbers或者booleans）的集合，你可以将它看作是一个 Map，其中值作为映射键，map 值始终为 true。 初始化一个 SetSet 可以通过下面的方式初始化： const s = new Set() 向 Set 中添加一项你可以使用 add 方法向 Set 中添加项： s.add('one')s.add('two') Set 仅会存贮唯一的元素，因此多次调用 s.add(‘one’) 不会重复添加新的元素。 你不可以同时向 set 中加入多个元素。你需要多次调用 add() 方法。 检查元素是否在 set 中我们可以通过下面的方式检查元素是否在 set 中： s.has('one') //trues.has('three') //false 从 set 中删除一个元素：使用 delete() 方法： s.delete('one') 确定 set 中元素的数量使用 size 属性： s.size 删除 set 中的全部元素使用 clear() 方法： s.clear() 对 set 进行迭代使用 keys() 或者 values() 方法 - 它们等价于下面的代码： for (const k of s.keys()) &#123; console.log(k)&#125;for (const k of s.values()) &#123; console.log(k)&#125; entries() 方法返回一个迭代器，你可以这样使用它： const i = s.entries()console.log(i.next()) 调用 i.next() 将会以 { value, done = false } 对象的形式返回每一个元素，直到迭代结束，这时 done 是 true。 你也可以调用 set 的 forEach() 方法： s.forEach(v =&gt; console.log(v)) 或者你就直接使用 for..of 循环吧： for (const k of s) &#123; console.log(k)&#125; 使用一些初始值初始化一个 set你可以使用一些值初始化一个 set： const s = new Set([1, 2, 3, 4]) 将 set 转换为一个数组 const a = [...s.keys()]// orconst a = [...s.values()] WeakSet一个 WeakSet 是一个特殊的 Set. 在 set 中，元素不会被 gc（垃圾回收）。一个 weakSet 让它的所有元素都是可以被 gc 的。weakSet 中的每个键都是一个对象。当这个对象的引用消失的时候，对应的值就可以被 gc 了。 下面是主要的不同点： WeakSet 不可迭代 你不能清空 weakSet 中的所有元素 不能够得到 weakSet 的大小 一个 weakSet 通常是在框架级别的代码中使用，仅仅暴露了下面的方法： add() has() delete() Map一份map结构的数据允许我们建立数据和key的关系 在ES6之前在引入Map之前，开发者通常把对象(Object)当Map使用，把某个object或value值与指定的key进行关联: const car = &#123;&#125;car['color'] = 'red'car.owner = 'Flavio'console.log(car['color']) //redconsole.log(car.color) //redconsole.log(car.owner) //Flavioconsole.log(car['owner']) //Flavio 引入Map之后ES6引入了Map数据结构，它为我们处理这种数据结构提供了一种合适的工具 Map的初始化: const m = new Map() 添加条目到Map中 你可以通过set()方法把条目设定到map中： m.set(&apos;color&apos;, &apos;red&apos;)m.set(&apos;age&apos;, 2) 通过key值从map中获取条目 你可以通过get()方法从map中取出条目: const color = m.get('color')const age = m.get('age') 通过key值从map中删除条目 使用delete()方法： m.delete('color') 从map中删除所有条目 使用clear()方法： m.clear() 通过key值检查map中是否含有某个条目 使用has()方法 const hasColor = m.has('color') 获取map中的条目数量 使用 size 属性: const size = m.size 用value值初始化一个map 你可以用一组value来初始化一个map： const m = new Map([['color', 'red'], ['owner', 'Flavio'], ['age', 2]]) Map 的key值 任何值(对象，数组，字符串，数字)都可以作为一个map的value值(使用key-value键值的形式)，任何值也可以用作key，即使是object对象。 如果你想通过get()方法从map中获取不存在的key，它将会返回undefined 在真实世界中你几乎不可能找到的诡异情况 const m = new Map()m.set(NaN, 'test')m.get(NaN) //testconst m = new Map()m.set(+0, 'test')m.get(-0) //test 使用Iterate迭代器获取map的keys值 Map提供了keys()方法，通过该方法我们可以迭代出所有的key值: for (const k of m.keys()) &#123; console.log(k)&#125; 使用Iterate迭代器获取map的values值 Map提供了values()方法，通过该方法我们可以迭代出所有的value值: for (const v of m.values()) &#123; console.log(v)&#125; 使用Iterate迭代器获取key-value组成的键值对 Map提供了entries()方法，通过该方法我们可以迭代出所有的键值对: for (const [k, v] of m.entries()) &#123; console.log(k, v)&#125; 使用方法还可以简化为： for (const [k, v] of m) &#123; console.log(k, v)&#125; 将map的keys值转换为数组 const a = [...m.keys()] 将map的values值转换为数组 const a = [...m.values()] WeakMapWeakMap是一种特殊的Map 在一个map对象中，定义在其上数据永远不会被垃圾回收，WeakMap替而代之的是它允许在它上面定义的数据可以自由的被垃圾回收走，WeakMap的每一个key都是一个对象，当指向该对象的指针丢失，与之对应的value就会被垃圾回收走。 这是WeakMap的主要不同处： 你不可以在WeakMap上迭代keys值和values值(或者key-value键值对) 你不可以从WeakMap上清除所有条目 你不可以获取WeakMap的大小WeakMap提供了如下几种方法，这些方法的使用和在Map中一样： get(k) set(k, v) has(k) delete(k) 关于WeakMap的用例不如Map的用例那么明显，你可能永远也不会在哪里会用到它，但从实际出发，WeakMap可以构建不会干扰到垃圾回收机制的内存敏感性缓存，还可以满足封装的严谨性及信息的隐藏性需求。 Generators生成器Generators是一种特殊的函数，它能够暂停自身的执行并在一段时间后再继续运行，从而允许其它的代码在此期间运行(有关该主题的详细说明，请参阅完整的“javascript生成器指南”)。 Generators的代码决定它必须等待，因此它允许队列中的其它代码运行，并保留“当它等待的事情”完成时恢复其操作的权力。 所有这一切都是通过一个简单的关键字“yield`”完成的。当生成器包含该关键字时，将停止执行。 generator生成器可以包含许多yield关键字，从而使自己能多次停止运行，它是由*function关键字标识(不要将其与C、C++或Go等低级语言中使用的取消指针引用操作符混淆)。 Generators支持JavaScript中全新的编程范式，包括： 在generator运行时支持双向通信 不会“冻结”长期运行在程序中的while循环 这里有一个解释generator如何工作的例子： function *calculator(input) &#123; var doubleThat = 2 * (yield (input / 2)) var another = yield (doubleThat) return (input * doubleThat * another)&#125; 我们先初始化它： const calc = calculator(10) 然后我们在generator中开始进行iterator迭代： calc.next()第一个迭代器开始了迭代，代码返回如下object对象： &#123; done:false value:5&#125; 具体过程如下：代码运行了函数，并把input=10传入到生成器构造函数中，该函数一直运行直到抵达yield，并返回yield输出的内容: input / 2 = 5，因此，我们得到的值为5，并告知迭代器还没有done(函数只是暂停了)。 在第二个迭代处，我们输入7： calc.next(7) 然后我们得到了结果： &#123; done:false value:14&#125; 7被作为doubleThat的值，注意：你可能会把input/2作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2. 然后，我们得到第二个yield的值，它返回doubleThat，因此返回值为14。 在下一个，也是最后一个迭代器，我们输入100 calc.next(100) 这样我们得到: &#123; done:true value:14000&#125; 当迭代器完成时(没有更多的yield关键字)，我们返回input doubleThat another，这相当于10 14100。 这些都是在2015年的ES2015引入的特性，现在我们深入了解下ES2016，它的作用域范围更小。 Array.prototype.includes()该特性引入了一种更简洁的语法，同来检查数组中是否包含指定元素。 对于ES6及更低版本，想要检查数组中是否包含指定元素，你不得不使用indexOf方法，它检查数组中的索引，如果元素不存在，它返回-1，由于-1被计算为true，你需对其进行取反操作，例子如下： if (![1,2].indexOf(3)) &#123; console.log('Not found')&#125; 通过ES7引入的新特性，我们可以如此做： if (![1,2].includes(3)) &#123; console.log('Not found')&#125; 求幂运算符求幂运算符**相当于Math.pow()方法，但是它不是一个函数库，而是一种语言机制： Math.pow(4, 2) == 4 ** 2 对于需要进行密集数学运算的程序来说，这个特性是个很好的增强，在很多语言中，**运算符都是标准(包括Python、Ruby、MATLAB、Perl等其它多种语言)。 这些都是2016年引入的特性，现在让我们进入2017年。 字符串填充字符串填充的目的是给字符串添加字符，以使其达到指定长度。 ES2017引入了两个String方法：padStart()和padEnd()。 padStart(targetLength [, padString])padEnd(targetLength [, padString]) 使用例子： Object.values()该方法返回一个数组，数组包含了对象自己的所有属性，使用如下： const person = &#123; name:'Fred', age:87 &#125;Object.values(person) // ['Fred', 87] Object.values()也可以作用于数组： const people = ['Fred', 'Tony']Object.values(people) // ['Fred', 'Tony'] Object.entries()该方法返回一个数组，数组包含了对象自己的所有属性键值对，是一个[key, value]形式的数组，使用如下： const person = &#123; name:'Fred', age:87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] Object.entries()也可以作用于数组： const people = ['Fred', 'Tony']Object.entries(people) // [['0', 'Fred'], ['1', 'Tony']] Object.getOwnPropertyDescriptors()该方法返回自己(非继承)的所有属性描述符，JavaScript中的任何对象都有一组属性，每个属性都有一个描述符，描述符是属性的一组属性(attributes)，由以下部分组成： value: 熟悉的value值 writable: 属性是否可以被更改 get: 属性的getter函数, 当属性读取时被调用 set: 属性的setter函数, 当属性设置值时被调用 configurable: 如果为false, 不能删除该属性，除了它的value值以为，也不能更改任何属性。 enumerable: 该属性是否能枚举 Object.getOwnPropertyDescriptors(obj)接受一个对象，并返回一个带有描述符集合的对象。 In what way is this useful?ES6给我们提供了Object.assign()方法，它从一个一个或多个对象中复制所有可枚举的属性值，并返回一个新对象。 但是，这也存在着一个问题，因为它不能正确的复制一个具有非默认属性值的属性。 如果对象只有一个setter，那么它就不会正确的复制到一个新对象上，使用Object.assign()进行如下操作： const person1 = &#123; set name(newName) &#123; console.log(newName) &#125;&#125; 这将不会起作用： const person2 = &#123;&#125;Object.assign(person2, person1) 但这将会起作用： const person3 = &#123;&#125;Object.defineProperties(person3, Object.getOwnPropertyDescriptors(person1)) 通过一个简单的console控制台，你可以查看以下代码： person1.name = 'x'"x"person2.name = 'x'person3.name = 'x'"x" person2没有setter，它没能复制进去，对象的浅复制限定也出现在Object.create()方法中。 尾逗号该特性允许在函数定义时有尾逗号，在函数使用时可以有尾逗号： const doSomething = (var1, var2,) =&gt; &#123; //...&#125;doSomething('test2', 'test2',) 该改变将鼓励开发者停止“在一行开始时写逗号”的丑陋习惯 异步函数JavaScript在很短的时间内从回调函数进化到Promise函数(ES2015)，并自从ES2017以来，异步JavaScript的async/wait语法变得更加简单。 异步函数是Promise和generator的结合，基本上，它是比Promise更高级的抽象，我再重复一般：async/await是基于Promise建立的 为什么要引入async/await它减少了围绕promise的引用，并打破了Promise — “不要打断链式调用”的限制。 当Promise在ES2015中引入时，它的本意是来解决异步代码的问题，它也确实做到了，但在ES2015和ES2017间隔的这两年中，大家意识到：Promise不是解决问题的终极方案。 Promise是为了解决著名的回调地狱而被引入的，但它本身也带来了使用复杂性和语法复杂性。 Promise是很好的原生特性，围绕着它开发人员可以探索出更好的语法，因此当时机成熟后，我们得到了async函数 async函数使代码看起来像是同步函数一样，但其背后却是异步和非堵塞的。 它如何工作一个async函数会返回一个promise，如下例： const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125; 当你想要调用该函数时，你在前面加上了一个wait，这样调用就会被停止，直到该promise进行resolve或reject，需注意的是：外层函数必须定义为async，这是例子： const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125; 一个上手示例这是一个使用async/await进行异步函数的简单示例： const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 上面的代码将会在浏览器的console中打印出如下结果： BeforeAfterI did something //after 3s 关于 Promise将 async 关键字标记在任何函数上，意味着这个函数都将返回一个 Promise，即使这个函数没有显式的返回，它在内部也会返回一个 Promise，这就是下面这份代码有效的原因： const aFunction = async () =&gt; &#123; return 'test'&#125;aFunction().then(alert) // This will alert 'test' 下面的例子也一样: const aFunction = async () =&gt; &#123; return Promise.resolve('test')&#125;aFunction().then(alert) // This will alert 'test' 更易于阅读的代码正如上述的例子，我们将它与普通回调函数或链式函数进行比较，我们的代码看起来非常的简单。 这是一个很简单的例子，当代码足够复杂时，它会产生更多的收益。 例如，使用 Promise 来获取 JSON 资源并解析它： const getFirstUserData = () =&gt; &#123; return fetch('/users.json') // get users list .then(response =&gt; response.json()) // parse JSON .then(users =&gt; users[0]) // pick first user .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // get user data .then(userResponse =&gt; response.json()) // parse JSON&#125;getFirstUserData() 这是使用 async/await 实现相同功能的例子： const getFirstUserData = async () =&gt; &#123; const response = await fetch('/users.json') // get users list const users = await response.json() // parse JSON const user = users[0] // pick first user const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // get user data const userData = await user.json() // parse JSON return userData&#125;getFirstUserData() 串行多个异步功能async 函数非常容易，并且它的语法比 Promise 更易读。 const promiseToDoSomething = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 10000) &#125;)&#125;const watchOverSomeoneDoingSomething = async () =&gt; &#123; const something = await promiseToDoSomething() return something + ' and I watched'&#125;const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; &#123; const something = await watchOverSomeoneDoingSomething() return something + ' and I watched as well'&#125;watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; &#123; console.log(res)&#125;) 打印结果: I did something and I watched and I watched as well 更简单的调试调试 Promise 就很困难，因为调试器无法跨越异步代码，但调试 async/await 就非常的简单，调试器会像调试同步代码一样来处理它。 共享内存和原子WebWorkers 可以在浏览器中创建多线程程序。 它们通过事件的方式来传递消息，从 ES2017 开始，你可以使用 SharedArrayBuffer 在每一个 Worker 中和它们的创建者之间共享内存数组. 由于不知道写入内存部分需要多长的周期来广播，因此在读取值时，任何类型的写入操作都会完成，Atomics 可以避免竞争条件的发生。 关于它的更多细节可以在proposal中找到。 这是 ES2017，接下来我将介绍 ES2018 的功能。 Rest/Spread PropertiesES2015 引入了解构数组的方法，当你使用时： const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers and 展开参数: const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) ES2018 为对象引入了同样的功能。 解构: const &#123; first, second, ...others &#125; = &#123; first:1, second:2, third:3, fourth:4, fifth:5 &#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 展开属性 允许通过组合在展开运算符之后传递的对象属性而创建新对象： const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; 异步迭代器for-await-of 允许你使用异步可迭代对象做为循环迭代： for await (const line of readLines(filePath)) &#123; console.log(line)&#125; 因为它使用的了 await，因此你只能在 async 函数中使用它。 Promise.prototype.finally()当一个 Promise 是 fulfilled 时，它会一个接一个的调用 then。 如果在这个过程中发生了错误，则会跳过 then 而执行 catch。 而 finally() 允许你运行一些代码，无论是成功还是失败： fetch('file.json') .then(data =&gt; data.json()) .catch(error =&gt; console.error(error)) .finally(() =&gt; console.log('finished')) 正则表达式改进ES2018 对正则表达式引入了许多改进，这些都可以在 https://flaviocopes.com/javascript-regular-expressions/ 上找到。 以下是关于 ES2018 正则表达式改进的具体补充： RegExp lookbehind assertions: 根据前面的内容匹配字符串 这是一个 lookahead: 你可以使用 ?= 来匹配字符串，后面跟随一个特定的字符串： /Roger(?=Waters)//Roger(?=Waters)/.test('Roger is my dog') //false/Roger(?=Waters)/.test('Roger is my dog and Roger Waters is a famous musician') //true ?! 可以执行逆操作，如果匹配的字符串是no而不是在此后跟随特定的子字符串的话： /Roger(?!Waters)//Roger(?!Waters)/.test('Roger is my dog') //true/Roger(?!Waters)/.test('Roger Waters is a famous musician') //false Lookaheads 使用 ?= Symbol，它们已经可以用了。 Lookbehinds, 是一个新功能使用?&lt;=. /(?&lt;=Roger) Waters//(?&lt;=Roger) Waters/.test('Pink Waters is my dog') //false/(?&lt;=Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //true 如果一个 lookbehind 是否定，那么使用 ?&gt;!: /(?&lt;!Roger) Waters//(?&lt;!Roger) Waters/.test('Pink Waters is my dog') //true/(?&lt;!Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //false Unicode属性转义 p{…} and P{…}在正则表达式模式中，你可以使用 d 来匹配任意的数字，s 来匹配任意不是空格的字符串，w 来匹配任意字母数字字符串，以此类推。 This new feature extends this concept to all Unicode characters introducing p{} and is negation P{}. 这个新功能扩展了unicode字符，引入了 p{} 来处理 任何 unicode 字符都有一组属性，例如 script 确认语言，ASCII 是一个布尔值用于检查 ASCII 字符。你可以将此属性方在() 中，正则表达式将来检查是否为真。 /^p&#123;ASCII&#125;+$/u.test('abc') //✅/^p&#123;ASCII&#125;+$/u.test('ABC@') //✅/^p&#123;ASCII&#125;+$/u.test('ABC🙃') //❌ ASCII_Hex_Digit 是另一个布尔值，用于检查字符串是否包含有效的十六进制数字： /^p&#123;ASCII_Hex_Digit&#125;+$/u.test('0123456789ABCDEF') //✅/^p&#123;ASCII_Hex_Digit&#125;+$/u.test('h') //❌ 此外，还有很多其它的属性。你可以在()中添加它们的名字来检查它们，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji等等： /^p&#123;Lowercase&#125;$/u.test('h') //✅/^p&#123;Uppercase&#125;$/u.test('H') //✅/^p&#123;Emoji&#125;+$/u.test('H') //❌/^p&#123;Emoji&#125;+$/u.test('🙃🙃') //✅ 除了二进制属性外，你还可以检查任何 unicode 字符属性以匹配特定的值，在这个例子中，我检查字符串是用希腊语还是拉丁字母写的： /^p&#123;Script=Greek&#125;+$/u.test(&apos;ελληνικά&apos;) //✅/^p&#123;Script=Latin&#125;+$/u.test(&apos;hey&apos;) //✅ 阅读https://github.com/tc39/proposal-regexp-unicode-property-escapes 获取使用所有属性的详细信息。 Named capturing groupsIn ES2018 a capturing group can be assigned to a name, rather than just being assigned a slot in the result array: const re = /(?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;)/const result = re.exec('2015-01-02')// result.groups.year === '2015';// result.groups.month === '01';// result.groups.day === '02';The s flag for regular expressionsThe s flag, short for single line, causes the . to match new line characters as well. Without it, the dot matches regular characters but not the new line:/hi.welcome/.test('hiwelcome') // false/hi.welcome/s.test('hiwelcome') // true ESNext什么是 ESNext ？ ESNext 是一个始终指向下一个版本 JavaScript 的名称。 当前的 ECMAScript 版本是 ES2018，它于2018年6月被发布。 历史上 JavaScript 标准化的版本都是在夏季被发布，因此我们可以预期 ECMAScript 2019 将于 2019 年的夏季被发布。 所以在编写本文时 ES2018 已经被发布，因此 ESNext 指的是 ES2019。 ECMAScript 标准的提案是分阶段组织的，第一到第三阶段属于功能性的孵化，第四阶段的功能才最终确定为新标准的一部分。 在编写本文时主要浏览器都实现了第四阶段大部分的功能，因此我将在本文中介绍它们。 其中一些变化主要在内部使用，但知道发生了什么这也很好。 第三阶段还有一些其它功能，可能会在接下来的几个月内升级到第四阶段，你可以在这个 Github 仓库中查看它们：https://github.com/tc39/proposals。 Array.prototype.&#123;flat,flatMap&#125; flat() 是一个新的数组实例方法，它可以将多维数组转化成一维数组。 例子: ['Dog', ['Sheep', 'Wolf']].flat()//[ 'Dog', 'Sheep', 'Wolf' ] 默认情况下它只能将二维的数组转化成一维的数组，但你可以添加一个参数来确定要展开的级别，如果你将这个参数设置为 Infinity 那么它将展开无限的级别到一维数组： ['Dog', ['Sheep', ['Wolf']]].flat()//[ 'Dog', 'Sheep', [ 'Wolf' ] ]['Dog', ['Sheep', ['Wolf']]].flat(2)//[ 'Dog', 'Sheep', 'Wolf' ]['Dog', ['Sheep', ['Wolf']]].flat(Infinity)//[ 'Dog', 'Sheep', 'Wolf' ] 如果你熟悉数组的 map 方法，那么你就知道使用它可以对数组的每个元素执行一个函数。 flatMap() 是一个新的数组实例方法，它将 flat() 和 map 结合了起来，当你期望在map函数中做一些处理时这非常有用，同时又希望结果如同 flat ： ['My dog', 'is awesome'].map(words =&gt; words.split(' '))//[ [ 'My', 'dog' ], [ 'is', 'awesome' ] ]['My dog', 'is awesome'].flatMap(words =&gt; words.split(' '))//[ 'My', 'dog', 'is', 'awesome' ] Optional catch binding有时候我们并不需要将参数绑定到 try/catch 中。 在以前我们不得不这样做： try &#123; //...&#125; catch (e) &#123; //handle error&#125; 即使我们从来没有通过 e 来分析错误，但现在我们可以简单的省略它： try &#123; //...&#125; catch &#123; //handle error&#125;Object.fromEntries()Objects have an entries() method, since ES2017. 从 ES2017 开始 Object将有一个 entries() 方法。 它将返回一个包含所有对象自身属性的数组的数组，如[key, value]： const person = &#123; name:'Fred', age:87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] ES2019 引入了一个新的 Object.fromEntries() 方法，它可以从上述的属性数组中创建一个新的对象： const person = &#123; name:'Fred', age:87 &#125;const entries = Object.entries(person)const newPerson = Object.fromEntries(entries)person !== newPerson //trueString.prototype.&#123;trimStart,trimEnd&#125; 这些功能已经被 v8/Chrome 实现了近一年的时间，它将在 ES2019 中实现标准化。 trimStart()删除字符串首部的空格并返回一个新的字符串： 'Testing'.trimStart() //'Testing'' Testing'.trimStart() //'Testing'' Testing '.trimStart() //'Testing ''Testing'.trimStart() //'Testing' trimEnd()删除字符串尾部的空格并返回一个新的字符串： 'Testing'.trimEnd() //'Testing'' Testing'.trimEnd() //' Testing'' Testing '.trimEnd() //' Testing''Testing '.trimEnd() //'Testing' Symbol.prototype.description现在你可以使用 description 来获取 Symbol 的值，而不必使用 toString() 方法： const testSymbol = Symbol('Test')testSymbol.description // 'Test' JSON improvements在此之前 JSON 字符串中不允许使用分隔符（）和分隔符（）。 使用 JSON.parse 时，这些字符会导致一个 SyntaxError 错误，但现在它们可以正确的解析并如 JSON 标准定义的那样。 Well-formed JSON.stringify()修复 JSON.stringify() 在处理 UTF-8 code points (U+D800 to U+DFFF)。 在修复之前，调用 JSON.stringify() 将返回格式错误的 Unicode 字符，如（a “�”)。 现在你可以安全放心的使用 JSON.stringify() 转成字符串，也可以使用 JSON.parse() 将它转换回原始表示的形态。 Function.prototype.toString()函数总会有一个 toString 方法，它将返回一个包含函数代码的字符串。 ES2019 对返回值做了修改，以避免剥离注释和其它字符串（如：空格），将更准确的表示函数的定义。 If previously we had 以前也许我们这样过： function /* this is bar */ bar () &#123;&#125; 当时的行为： bar.toString() //'function bar() &#123;&#125; 现在的行为： bar.toString(); // 'function /* this is bar */ bar () &#123;&#125;' 总结一下，我希望这篇文章可以帮助你了解一些最新的 JavaScript 以及我们在 2019 年即将看见的内容。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程看这篇就够了]]></title>
    <url>%2Fposts%2F52228cda.html</url>
    <content type="text"><![CDATA[引如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。 用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。 很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码： void transferMoney(User from, User to, float amount)&#123; to.setMoney(to.getBalance() + amount); from.setMoney(from.getBalance() - amount);&#125; 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。 好了，让我们开始吧。我准备分成几部分来总结涉及到多线程的内容： 扎好马步：线程的状态 内功心法：每个对象都有的方法（机制） 太祖长拳：基本线程类 九阴真经：高级多线程控制类 一、扎好马步：线程的状态先来两张图： ​ 线程状态 ​ 线程状态转换 各种状态一目了然，值得一提的是”Blocked”和”Waiting”这两个状态的区别： 线程在Running的过程中可能会遇到阻塞(Blocked)情况对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。从jdk源码注释来看，blocked指的是对monitor的等待（可以参考下文的图）即该线程位于等待区。 线程在Running的过程中可能会遇到等待（Waiting）情况线程可以主动调用object.wait或者sleep，或者join（join内部调用的是sleep，所以可看成sleep的一种）进入。从jdk源码注释来看，waiting是等待另一个线程完成某一个操作，如join等待另一个完成执行，object.wait()等待object.notify()方法执行。 Waiting状态和Blocked状态有点费解，我个人的理解是：Blocked其实也是一种wait，等待的是monitor，但是和Waiting状态不一样，举个例子，有三个线程进入了同步块，其中两个调用了object.wait()，进入了waiting状态，这时第三个调用了object.notifyAll()，这时候前两个线程就一个转移到了Runnable,一个转移到了Blocked。 从下文的monitor结构图来区别：每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态Blocked,从jstack的dump中来看是 “Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是Waiting，表现在jstack的dump中是 “in Object.wait()”。 此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 二、 内功心法：每个对象都有的方法（机制）synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们 他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 再讲用法： synchronized单独使用： 代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;&#125; 直接用于方法：相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。 public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125; synchronized, wait, notify结合:典型场景生产者消费者问题 /** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println("产品已满,请稍候再生产"); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println("生产者生产第" + this.product + "个产品."); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println("缺货,稍候再取"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println("消费者取走了第" + this.product + "个产品."); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; volatile 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。 针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。 三、太祖长拳：基本线程类基本线程类指的是Thread类，Runnable接口，Callable接口Thread 类实现了Runnable接口，启动一个线程的方法： MyThread my = new MyThread(); my.start(); Thread类相关方法： //当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）public static Thread.yield()//暂停一段时间public static Thread.sleep()//在一个线程中调用other.join(),将等待other执行完后才继续本线程。 public join()//后两个函数皆可以被打断public interrupte() 关于中断：它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。Thread.interrupted()检查当前线程是否发生中断，返回booleansynchronized在获锁的过程中是不能被中断的。 中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体 Thread类最佳实践：写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。 如何获取线程中的异常 ​ 不能用try,catch来获取线程中的异常 Runnable 与Thread类似 Callable future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态 ExecutorService e = Executors.newFixedThreadPool(3); //submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.Future future = e.submit(new myCallable());future.isDone() //return true,false 无阻塞future.get() // return 返回值，阻塞直到该线程运行结束 四、九阴真经：高级多线程控制类以上都属于内功心法，接下来是实际项目中常用到的工具了，Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。 1.ThreadLocal类 用处：保存线程的独立变量。对一个线程类（继承自Thread)当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。 实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。 主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。 2.原子类（AtomicInteger、AtomicBoolean……） 如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized //返回值为booleanAtomicInteger.compareAndSet(int expect,int update) 该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为： if(b.value.compareAndSet(old, value))&#123; return ;&#125;else&#123; //try again // if that fails, rollback and log&#125; AtomicReference 对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号 3.Lock类 lock: 在java.util.concurrent包内。共有三个实现： ReentrantLock ReentrantReadWriteLock.ReadLock ReentrantReadWriteLock.WriteLock 主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。 区别如下： lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序） 提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。 本质上和监视器锁（即synchronized是一样的） 能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。 和Condition类的结合。 性能更高，对比如下图： ​ synchronized和Lock性能对比 ReentrantLock 可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。使用方法是： 1.先new一个实例 static ReentrantLock r=new ReentrantLock(); 2.加锁 r.lock()或r.lockInterruptibly(); 此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch） 3.释放锁 r.unlock() 必须做！何为必须做呢，要放在finally里面。以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。 ReentrantReadWriteLock 可重入读写锁（读写锁的一个实现） ReentrantReadWriteLock lock = new ReentrantReadWriteLock() ReadLock r = lock.readLock(); WriteLock w = lock.writeLock(); 两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码 4.容器类 这里就讨论比较常用的两个： BlockingQueue ConcurrentHashMap BlockingQueue 阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管 道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究 BlockingQueue在队列的基础上添加了多线程协作的功能： 除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队 列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。 常见的阻塞队列有： ArrayListBlockingQueue LinkedListBlockingQueue DelayQueue SynchronousQueue ConcurrentHashMap 高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap 5.管理类 管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean ThreadPoolExecutor 如果不了解这个类，应该了解前面提到的ExecutorService，开一个自己的线程池非常方便： ExecutorService e = Executors.newCachedThreadPool(); ExecutorService e = Executors.newSingleThreadExecutor(); ExecutorService e = Executors.newFixedThreadPool(3); // 第一种是可变大小线程池，按照任务数来分配线程， // 第二种是单线程池，相当于FixedThreadPool(1) // 第三种是固定大小线程池。 // 然后运行 e.execute(new MyRunnableImpl()); 该类内部是通过ThreadPoolExecutor实现的，掌握该类有助于理解线程池的管理，本质上，他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc： ​ ThreadPoolExecutor参数解释 翻译一下：corePoolSize:池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。maximumPoolSize:线程最大值，线程的增长始终不会超过该值。keepAliveTime：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态unit：时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS workQueue:待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿死(starving)threadFactory:线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让我们聊一聊计算机基础知识的最小集合组]]></title>
    <url>%2Fposts%2F2d2dd747.html</url>
    <content type="text"><![CDATA[前言很多人工作后痛感计算机基础知识的缺乏， 那计算机基础知识都有哪些呢？ 我觉得首先计算机专业的那六大件：组成原理，操作系统，数据库，编译原理，计算机网络，数据结构（这个说太多遍了，这次不再讲了）， 其次还得加上分布式的基础知识， 因为现在的系统都变成分布式的了。 如果你是做应用层开发的，那几门课程中的有些内容和日常工作关联度不大，我挑那些最重要的来说一说，也算是一个最小集合吧！ 一、计算机组成原理如果你不是做操作系统/驱动程序的，直接和硬件打交道的机会很少，因为操作系统已经把他们屏蔽掉了，提供了抽象的API给我们使用。 但是还必须理解冯诺依曼体系的结构，CPU和内存，硬盘，各种外设之间的关系，寄存器、缓存等知识。 CPU有哪些指令，如何执行这些指令，如果实现数组，结构体，函数调用，这就涉及到汇编的知识。 像原码，反码，补码，定点数、浮点数的表示和运算也是编程中必备的知识，几乎每种语言都要涉及。 现在很多语言都是在虚拟机上运行的，你只要是了解了计算机的组成原理，再去看哪些虚拟机，就会发现概念都是相通的。 另外CPU中的缓存，缓存一致性协议，DMA的异步思想都会在应用层中有所体现。 如果能找一本书，尽可能多的囊括这些知识的话，我觉得还是神书《深入理解计算机系统》的前4章。 《编码》是一个更加科普性，但是也更加有趣的讲组成原理的书。 二、操作系统言操作系统是比较枯燥的， 站在应用层的角度，我认为重点是掌握操作系统对外提供的抽象，包括进程、线程，文件，虚拟内存，以及进程间的通信问题。 几乎所有的编程语言都会涉及到对多进程或者多线程编程的支持， 特别是多线程的并发编程，所以必须得搞明白他们的本质是什么，线程都有哪些实现方式（对以后学习各种语言和并发模型有极大好处）。得真正地体会到“进程是资源分配的最小单位，线程是调度的最小单位。” 这句话的含义。 几乎所有的编程语言都会涉及到锁和死锁，最好在最底层理解锁是怎么实现的。 需要理解虚拟内存和物理内存直接的关系，分段和分页，文件系统的基本原理。 对于进程的调度，页面分配/置换算法，磁盘的调度算法，I/O系统，我认为优先级比较低。 三、计算机网络我认为必须要理解的是这些： 什么分组交换 TCP可靠性传输原理，TCP/IP的协议细节， 三次握手，四次挥手，TCP状态转换。 几个重要的协议DHCP，UDP, ARP, DNS。 能够说出一个客户端如何在接入网络以后，通过这些协议，跨域网络和服务器通信的。 和应用层结合非常紧密的Socket知识和网络安全（对称加密，非对称加密，Hash, 数字签名，以及集大成者Https） 至于网络层的路由选择算法，链路层的各种协议，我认为优先级比较低。 还有一个重要的知识点，一般的网络书都没提，就是I/O多路复用，涉及到同步/异步，阻塞/非阻塞，select/epoll ，这个是很多软件的基础，在《Unix网络编程》，《深入理解计算机系统》中有讲述。 以上这些知识，在你学习Redis ,Ngnix, Tomcat, LVS等软件时将有极大的帮助。 四、数据库你这一辈子也许都不会去写一个编译器，但是很有可能会利用现成的工具去生成/操作一个抽象语法树（AST），甚至可以会写一个DSL（领域特定语言）。所以你得理解词法分析、语法分析、语义分析，中间代码生成，代码优化这个基本编译的过程。 学习了编译与原理，会对语言的一些设计有更深的理解，比如LISP。 五、分布式的理论知识由于现在的系统慢慢地变成了分布式， 所以又扩展出了很多相关基础知识需要学习： 数据复制与一致性: CAP理论， BASE原则，幂等性, 2PC, TCC Paxos , Raft , Gossip 数据分片和路由: Hash分片：Hash取模（实际中非常常见的算法）， 虚拟桶（Redis使用），一致性Hash（memcached使用） 范围分片 最后想说的是，不能带着特别功利的目的去学习这些基础，不能想着立刻、马上就应用到实战中，从中获益。更重要的理解掌握它们背后的思想，有一天你会发现：奥，这个问题我在哪里见过，可以用类似的办法来解决啊！]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-数组]]></title>
    <url>%2Fposts%2F979f2162.html</url>
    <content type="text"><![CDATA[一、创建方法1、空数组var Obj = new Array(); 2、指定长度数组var Obj = new Array(Size); 3、指定元素数组var Obj = new Array(元素1,元素2,元素3,...,元素N); 4、单维数组var Obj = [元素1,元素2,元素3,...,元素N] 5、多维数组var a = new Array([数组序列1],[数组序列2],[数组序列N]); 二、基本操作1、存取数组元素 单维数组 数组名[下标索引] 多维数组 数组名[外层数组下标][内层元素下标] 特性 数组长度是弹性的，可自由伸缩 数组下标从0开始 下标类型 数值 非数值 转为字符串 生成关联数组 下标将作为对象属性的名字 数组元素可添加到对象中 2、增加数组使用“[]”运算符指定一个新下标 3、删除数组delete数组名[下标]; 4、遍历数组for(var 数组元素变量 in 数组) 三、数组属性1、constructor引用数组对象的构造函数 2、length返回数组的长度 3、prototype通过增加属性和方法扩展数组定义 四、ECMAScript 3 方法1、添加 push() 在数组末尾增加数组 unshift 在数组头部添加元素 concat 合并两个数组 2、删除 pop() 删除并返回数值的最后一个元素 shift() 删除并返回数组的第一个元素 队列方法，先进先出 栈方法，后进先出 3、子数组 splice() 删除任意数量的项 要删除的起始下标 要删除的项数 在指定位置插入指定的项 起始下标 0（不删除任何项） 要插入的项 替换任意数量的项 起始下标 要删除的项数 要插入的项 功能 从已有数组中选取部分元素构成新数组 参数 返回项的起始位置 返回项的结束位置 特性 如果是负数，则用数组长度加上该值确定位置 起始位置实为数组的实际下标 结束位置的实际下标为结束数值减1 4、数组排序 reverse() 颠倒数组中元素的顺序 sort() 功能：对字符数组或数字数组进行排序 特性：按数值大小比较，需函数支持（升序） functioncompare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125;&#125; 5、数组转换 toString() 转换为字符串并返回 toLocaleString() 转换为本地格式字符串并返回 join() 用指定分隔符分割数组并转换为字符串 五、ECMAScript 5 方法1、位置方法 indexof 从数组的起始位置开始查找 lastIndexof 从数组的结束位置开始查找 参数 要查找的项 标识查找起点的位置索引 2、迭代方法 every 如果该函数对每一项都返回true，则返回true filter 返回值为true的所有数组成员 forEach 无返回值 map 返回每次函数调用的结果数组 some 有任意一项返回true，则返回true 参数 接收参数 要在每一项上运行的函数 运行该函数的作用域对象 传入参数 数组项的值 item 该项在数组中的位置index 数组对象本身 array 3、缩小方法 reduce 从数组起始位开始遍历 reduceRight 从数组末尾开始遍历 参数 接收参数 每一项上调用的函数 作为缩小基础的初始值 传入参数 前一个值 prev 当前值 cur 项的索引 index 数组对象 array]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-函数基础]]></title>
    <url>%2Fposts%2F5768cb4e.html</url>
    <content type="text"><![CDATA[一、定义方法1、静态方法function 函数名([虚参数列表])&#123; 函数体; [return[函数返回值;]]&#125; 2、动态匿名方法var 函数名 = new Function([“虚参数列表”],”函数体”); 3、直接量方法函数名 = function([虚参数列表]){函数体;} 二、调用方法1、直接调用函数名(实参列表) 2、在连接中调用&lt;a herf = &quot;javascript:函数名()&quot;&gt;描述字&lt;/a&gt; 3、在事件中调用事件类型 = “函数名()” 4、递归调用 定义 在函数体内部调用函数自身 格式 function 函数名()&#123; 代码; 函数名();&#125; 三、方法1、apply 将函数作为对象的方法来调用 将参数以数组形式传递给该方法 2、call 将函数作为对象的方法来调用 将指定参数传递给该方法 3、toString 返回函数的字符串表示 四、arguments对象1、功能 存放实参的参数列表 2、特性 仅能在函数体内使用 带有下标属性，并非数组 函数声明时自动初始化 3、属性 length 获取函数实参的长度 callee 返回当前正在指向的函数 caler 返回调用当前正在执行的函数的函数名 五、函数参数1、参数类型 形参 定义函数时使用的参数 接收该函数时传递的参数 实参 调用函数时传递给函数的实际参数 2、特性 参数个数没有限制 实参 &lt; 形参 ：多余形参 = undefined 实参 &gt; 形参 ：多余实参被忽略 参数的数据类型没有限制 通过arguments对象访问参数数组 参数始终按值传递 基本类型：传值 引用类型：传址 六、指针标识1、this指向当前操作对象 2、callee指向形参集合所属函数 3、prototype指向函数附带的原型对象 4、constructor指向创建该对象的构造函数]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-运算符]]></title>
    <url>%2Fposts%2F4cf212f3.html</url>
    <content type="text"><![CDATA[一、算术运算符1、运算符a、+ 功能 对数字进行代数求和 对字符串进行连接操作 将一个数值转换成字符串（数值+空字符串） 字符串拼接 字符串+字符串（二者直接拼接） 字符串+数值（数值转为字符串再拼接） b、- 功能 对操作数进行“取反”操作 对数字进行减法操作 将字符串转换成数值（数值型字符串 - 0） c、* 功能 对两个运算数进行乘法运算 符号问题 同号得正，异号得负 d、/ 功能 对两个运算数进行除法运算 符号问题 同号得正，异号得负 e、% 功能 返回两个除数的余数 符号问题 和第一个运算数的符号相同 2、复合赋值运算符 +=、- =、*=、/=、%= 二、自增与自减1、功能相反 ++：对唯一的运算数进行递增操作（每次加1） —：对唯一的运算数进行递减操作（每次减1） 2、规则相同 运算数必须是一个变量、数组的一个元素或者对象的属性 如果运算数是非数值的则运算符会将它转成数值 3、符号位置决定运算结果 运算数之前：先进行递增（递减）操作，再进行求值 运算数之后：先求值，再进行递增（递减）操作 三、关系运算符1、大小关系检测a、运算符 &lt; ：如果A小于B，则返回true，否则返回false &lt;=：如果A小于等于B，则返回true，否则返回false &gt;=：如果A大于等于B，则返回true，否则返回false &gt;：如果A大于B，则返回true，否则返回false b、操作规则 数值与数值的比较：比较它们的代数值 仅一个运算数是数值：将另一个运算数转换成数值，并比较它们的代数值 字符串间的比较：逐字符比较它们的Unicode数值 字符串与非数值的比较：将运算符转换成字符串并进行比较 运算数即非数值也非字符串：转换成数值或字符串后进行比较 运算数无法转换成数值或字符串：返回值为false 与NaN的比较：返回值为false 2、等值关系检测a、相等比较 操作符 ==：比较两个运算数的返回值看是否相等 !=：比较两个运算数的返回值看是否不相等 类型转换 布尔值 true：1 false：0 对象 调用valueOf()，基本类型 字符串与数值的比较 字符串转换为数值 比较原则 null与undefined 相等 比较前不进行任何转换 NaN 与任何数值都不相等包括其本身 对象 是否属于同一对象 是：== 否：!= b、相同比较 运算符 ===：比较两个运算数的返回值及数据类型看是否相同 !==：比较两个运算数的返回值及数据类型看是否不同 比较原则 值类型比较 只有数据类型相同，且数值相等时才能够相同 值类型与引用类型比较 肯定不相同 引用类型间比较 比较它们的引用值（内存地址） 四、对象运算符 in：判断左侧运算数是否为右侧运算数的成员 instancesof：判断对象实例是否属于某个类或构造函数 new：根据构造函数创建一个新的对象，并初始化该对象 delete：删除指定对象的属性，数组元素或变量 .及[]：存取对象或数组元素 ()：函数调用，改变运算运算符优先级等 五、逻辑运算符1、! 逻辑非a、返回值 true 空字符串 0 null NaN undefined false 对象 非空字符串 非0数值（Infinity） b、特性 如果运算数的值为false则返回true，否则返回false 连续使用两次!，可将任意类型转为布尔值 2、&amp;&amp;逻辑与a、规则 第一个操作数是对象：返回第二个操作数 第二个操作数是对象：第一个操作数值为true时返回该对象 两个操作数都是对象：返回第二个操作数 一个操作数是null：返回null 一个操作数是NaN：返回NaN 一个操作数是undefined：返回undefined b、特性 当且仅当两个运算数的值都是true时，才返回true，否则返回false 短路操作：当第一个操作数的值为false则不再对第二个操作数进行求值 3、||逻辑或a、规则 第一个操作数是对象：返回第一个操作数 第一个操作数值为false：返回第二个操作数 两个操作数都是对象：返回第一个操作数 两个操作数是null：返回null 两个操作数是NaN：返回NaN 两个操作数是undefined：返回undefined b、特性 当且仅当连个运算数的值都是false时，才返回false，否则返回true 如果第一个操作数为true，则不会对第二个操作数进行求值 六、位运算符1、基础知识a、类型 有符号 数值位：前31位 符号位：第32位 0：正数 1：负数 无符号 只能是正数 第32位表示数值 数值范围可以加大 b、数值范围 - 2147483648 ~ 2147483647 c、存储方式 正数 纯二进制存储 31位中每一位表示2的幂 用0补充无用位 负数 二进制补码存储 补码的计算步骤 确定该数字的非负版本的二进制表示 求得二进制反码，既要把0替换为1，把1替换为0 在二进制反码上加1 d、当做0来处理的特殊值 NaN Infinity 2、逻辑位运算符a、返回值为1 按位非~：0 按位与&amp;：对应位全是1 按位或|：任何一位都是1 按位异或^：既不同时为0，也不同时为1 b、返回值为0 按位非~：1 按位与&amp;：任何一位都是0 按位或|：对应位全是0 按位异或^：对应位全是0或全是1 3、位移操作a、左移&lt;&lt; 将数值的所有位左移指定的位数 所有空位用0补充 左移1位对其乘2，左移2为对其乘4，以此类推 b、有符号右移&gt;&gt; 将数值的所有位右移指定的位数 移除位被舍弃 保留符号位 右移1位对其除2，右移2为对其除4，以此类推 c、无符号右移&gt;&gt; 正数：与有符号右移结果相同 负数：会出现无限大的数值 4、复合赋值运算符 位操作符与等号结合，复合赋值不会有性能方面的提升 七、其他运算符1、? 条件运算符，简洁的if else 2、type of 类型判定运算符 3、, 逗号，在一行语句中执行多个不同的操作 4、void 舍弃运算数的值，返回undefined作为表达式的值]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-DOM基本操作]]></title>
    <url>%2Fposts%2Faf67cb0c.html</url>
    <content type="text"><![CDATA[一、获取节点1、document getElementById 语法：document.getElementById(元素id) 功能：通过元素ID获取节点 getElementByName 语法：document.getElementByName(元素name属性) 功能：通过元素的name属性获取节点 getElementByTagName 语法：document.getElementByTagName(元素标签) 功能：通过元素标签获取节点 2、节点指针 firstChild 语法：父节点.firstChild 功能：获取元素的首个子节点 lastChild 语法：父节点.lastChild 功能：获取元素的最好一个子节点 childNodes 语法：父节点.childNodes 功能：获取元素的子节点列表 previousSibling 语法：兄弟节点.previousSibling 功能：获取已知节点的前一个节点 nextSibling 语法：兄弟节点.nextSibling 功能：获取已知节点的后一个节点 parentNodes 语法：子节点.parentNodes 功能：获取已知节点的父节点 二、节点操作1、创建节点 createElement 语法：document.createElement(元素标签) 功能：创建元素节点 createAttribute 语法：documen.createAttribute(元素属性) 功能：创建属性节点 createTextNode 语法：document.createTextNode(文本内容) 功能：创建文本节点 2、插入节点 appendChild 语法：appendChild(所添加的新节点) 功能：向节点的子节点列表的末尾添加新的子节点 insertBefore 语法：insertBefore(所要添加的新节点，已知子节点) 功能：在已知子节点钱插入一个新的子节点 3、替换节点 replaceChild 语法：replaceChild(要插入的新元素，将被替换的老元素) 功能：将某个子节点替换为另一个 4、复制节点 cloneNode 语法：需要被复制的节点.cloneNode(true/fasle) 功能：创建置顶节点的副本 参数 true：复制当前节点及其所有子节点 false：仅复制当前节点 5、删除节点 removeChild 语法：removeChild*(要删除的节点) 功能：删除指定的节点 三、属性操作1、获取属性 getAttribute 语法：元素节点.getAttribute(元素属性名) 功能：获取元素节点中指定属性的属性值 2、设置设置属性 setAttribute 语法：元素节点.setAttribute(属性名,属性值) 功能：创建或改变元素节点的属性 3、删除属性 removeAttribute 语法：元素节点.removeAttribute(属性名) 功能：删除元素中的指定属性 四、文本操作 insertData(offset,string) ：从offset指定的位置插入string appendata(sring) ：将string插入到文本节点的末尾处 deleteData(offset,count) ：从offset起删除count个字符 replaceData(off,count,string) ：从off将count个字符用string替代 splitData(offset)：从offset起将文本节点分成两个节点 substring(offset,count)：返回由offset起的count个节点]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-流程语句]]></title>
    <url>%2Fposts%2F121ee7e9.html</url>
    <content type="text"><![CDATA[一、循环语句1、while 语法 while(条件表达式)&#123; 循环执行代码段&#125; 流程 判断条件表达式的值 当值为true时循环执行代码段 当值为false时退出循环体 热性 先检查条件，再执行循环 条件不满足则循环一次也不执行 时机 一个动作被重复执行到满足某个 条件时 2、do-while 语法 do&#123; 循环执行的代码段&#125;while(条件表达式) 流程 先执行循环体内代码段再进行判断 如果表达式的值为true，则重复执行代码段 如果表达式的值为false，则退出循环体 特性 先执行循环体，再进行条件判断 循环体内代码至少执行一次 时机 希望一个动作至少被执行一次时 3、for 语法 for(循环变量 = 初值;循环条件;递增/递减计数器)&#123; 循环代码段&#125; 流程 用循环变量初始值与循环条件相比较，确定返回值 如果返回值为true则执行循环体 执行完一次后进行递增/递减运算 将运算结果与循环条件相比较 如果返回值为true则继续执行循环体 如果返回值为false则退出循环体 时机 重复一个动作到一定次数时 4、for-in 语法 for(声明变量 in 对象)&#123; 代码段&#125; 作用 枚举对象属性 注意事项 循环输出的属性顺序不可预知 对象的值不能是null或undefined 二、跳转语句1、return 终止函数体的运行，并返回一个值 2、break 终止整个循环，不再进行判断 3、continue 结束本次循环，接着去判断是否执行下次循环 三、选择语句1、if 语法 if(条件表达式1)&#123; 代码段1&#125;else if(条件表达式2)&#123; 代码段2&#125;else&#123; 代码段3&#125; 流程 判断条件1，如果返回值为true则执行代码段1 如果条件1的返回值为false则跳过语句1并检测条件2 如果所有的表达式的值均为false则执行else后面的语句 特性 结构复杂，可嵌套 可测试多个条件表达式 表达式的值具有线性特征 表达式的值是动态的 适用于任意类型的数据 可处理复杂的逻辑关系 2、switch 语句 switch(条件表达式)&#123; case 标签1: 代码段1; break; case 标签2: 代码段2; break; …… …… default: 代码段n;&#125; 流程 计算表达式的值，并与各标签相比较 若找到与之匹配的标签，则执行其后的代码段 若没有找到与之匹配的标签则执行default之后的代码段 格式 case标签为常量，可以是字符串或数字 每个标签均以冒号:结束 虽然break与default为可选性，但为了逻辑清晰最好不要省略 case标签的值必须和条件表达式在值完全匹配 特性 结构简洁，专为多重选择设计 仅可测试一条条件表达式 表达式的值具有离散性 表达式的值是固定的，不会动态变化的 仅能应用整数，枚举，字符串等类型数据 仅能处理多个枚举型逻辑关系 四、异常处理语句 throw 主动抛出异常 try 指明需要处理的代码段 catch 捕获异常 finally 后期处理]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-正则表达式]]></title>
    <url>%2Fposts%2F75cf4b3.html</url>
    <content type="text"><![CDATA[一、创建1、方式 字面量：var变量名 = / 表达式 / 模式修饰符 函数构造：var变量名 = new RegExp(“表达式”,”模式修饰符”) 2、说明a、表达式 单个字符与数字 . : 匹配除换行符之外的任意字符 [a-z0-9] ：匹配方括号中的任意字符 [^a-z0-9] ：匹配不在方括号中的任意字符 \d：匹配数字 \D：匹配非数字 \w：匹配字母 \W：匹配非字母 空白字符 \0：匹配null字符 \b：匹配空格字符 \f：匹配换页符 \n：匹配换行符 \r：匹配回车符 \s：匹配空白字符、空格、制表符或换行符 \S：匹配非空白字符 \t：匹配制表符 定位符 ^：行首匹配 $：行尾匹配 \A：只匹配字符串的开始处 \b：匹配单词边界，词在[]内无效 \B：匹配非单词边界 \G：匹配当前搜索的开始位置 \Z：匹配字符串结束处或行尾 \z：只匹配字符串结束处 限定符 x?：匹配0个或1个x x*：匹配0个或任意多个x x+：匹配至少1个x x(m,n)：匹配最少m个，最多n个x 分组 (?:x)：匹配x但不记录匹配结果 x(?=y)：当x后接y时匹配x x(?!y)：当x后不是y时匹配x 引用 \1…\9：$1…$9，返回九个在模式匹配期间找到的、最近保存的部分 或模式 x|y|z：匹配x或z或y b、模式修饰符 g ：全局模式，应用于所有字符串 i ：区分大小写模式 m ：多行匹配模式 二、属性1、实例属性 global：检测是否设置g标记 ignoreCase：检测是否设置i标记 multiline：检测是否设置了m标记 lastIndex：开始检索下一个匹配项的字符位置，开始为0 source：返回正则表达式的字符串表示 2、构造函数属性 $_ input ：返回最近一次匹配的字符串 $&amp; lastMatch：返回最近一次的匹配项 $+ lastParen：返回最近一次匹配的捕获组 $` leftContext：返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符 $’ rightContext：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符 $* multiline：检测表达式是否采用多行模式匹配m 三、方法1、实例方法a、exec 功能：在字符串中执行匹配检索，返回结果数组 参数：要应用模式匹配的字符串 特性 使用全局标记g：持续查找所有匹配项并返回 不使用全局标记g：始终返回第一个匹配项信息 执行过程 检索字符串参数，获取正则表达式匹配文本 找到匹配文本则返回一个数组 第0个元素：与整个模式匹配的字符串 其他元素：与捕获组匹配的字符串 否则返回null 派生属性 index：匹配项在字符串中的位置 input：应用正则表达式的字符串 length：返回数组元素个数 b、test 功能：在字符串中测试模式匹配，返回true或false 2、字符串方法 match：找到一个或多个正则表达式的匹配 replace：替换与正则表达式匹配的子串 seach：检索与正则表达式相匹配的值 split：把字符串分割为字符串数组]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-字符串函数]]></title>
    <url>%2Fposts%2F2675d2d0.html</url>
    <content type="text"><![CDATA[一、查找方法1、字符方法a、charAt() 功能：返回字符串中第n个字符 参数：超出范围，返回空字符串 返回值：string中第n个字符的实际值 b、charCodeAt() 功能：返回字符串中第n个字符的代码 参数：超出范围，返回Nan 返回值： 内容：string中第n个字符的Unicode编码 范围：0~65535之间的16位整数 c、fromCharCode() 功能：根据字符编码创建字符串 参数：0个或多个整数，代码字符的Unicode编码 返回值：由指定编码字符组成的新字符串 特效：静态方法，实为构造函数String()的属性 d、关系charAt和charCodeAt共性 功能：根据下标查找指定字符 参数：n，要查询的字符下标；有效范围，0~length~1之间 charCodeAt与fromCharCode 互为反向操作 2、位置方法a、indexOf() 从前向后检索字符串，看其是否含有指定子串 b、lastIndexOf() 从后向前检索字符串，看其是否含有指定子串 c、共性 功能：根据字符串查找下标位置 参数： 必选：将要查询的字符串 可选：开始查找的位置下标 值为负数，视作 0 省略，从默认起始位开始查找 超出 0~length~1，返回 -1 返回值 找到：字串首次出现的下标 未找到：返回-1 3、匹配方法a、match() 功能：找到一个或多个正则表达式的匹配 参数 要进行模式匹配的正则表达式 非正则表达式，将其传递给RegExp()的构造函数，并转换为正则表达式对象 返回值：存放匹配结果的数组 有全局标记g：执行全局检索 找到：返回数组 内容：所有匹配的子串 缺陷 没有派生属性 不提供与子表达式匹配的文本信息 不声明每个匹配子串的位置 弥补：使用RegExp.exec()方法 没找到：返回null 无全局标记g：执行一次匹配 找到：返回数组 内容 第0个元素，匹配文本 其他元素，与正则表达式匹配的文本 属性 input，调用该方法的字符串对象 index，匹配为本的起始字符在字符串中的位置 lastIndex，匹配为本的末尾字符在字符串中的位置 未找到：返回null b、seach() 功能：检索字符串中与正则表达式匹配的子串 参数：与match()相同 返回值 找到：字符串中第一个与正则表达式相匹配的子串的起始位置 未找到：返回 -1 特性：忽略全局标记g与lastIndex()属性 c、replace() 功能：替换一个与正则表达式匹配的子串 参数 参数 1：需要进行替换正则表达式对象或字符串 参数 2：替换文本或替换函数 特性 如果参数1仅为字符串则只进行一次匹配替换，若替代所有子串则必选制定全局标记g 如果参数2仅为字符串则可使用特殊字符序列 $$ : $ $&amp; : 匹配整个模式的子字符串 $’ : 匹配的子字符串之前的子字符串 $` : 匹配的子字符串之后的子字符串 $n : 匹配第n个捕获组的子字符串，n=0~9 $nn: 匹配第nn个捕获组的子字符串，nn=01~99 d、split() 功能：根据指定分隔符将字符串分割成多个子串，并返回成数组 参数 必须：指定的分隔符 可选：指定数组的长度 二、操作方法1、拼接方法a、concat() 语法：string.cancat(varue,…) 功能：连接字符串 参数：要连接到string上的一个或多个值 返回值：把所有参数都连接到字符串string上得到的新字符串 特性：功能与‘’+‘’相同原始字符串的实际值并未被真正修改 2、截取方法a、 根据下标截取子串 slice() : 赋值参数，与字符长度相加 substring() : 赋值参数，转换为0 共性 ：参数2的子字符串最后一个字符后面的下标 b、根据长度截取子串 substr() 参数2 ：返回的字符个数 赋值参数 参数1：与字符串长度相加 参数2：转换为0 c、共性 功能：截取被操作字符串中的子串 参数1：指定子串的开始位置 省略参数2：以字符串长度为结束位置 3、空格处理 trim：清除前置及后缀空格 trimLeft：清除前置空格 trimRight：清除后缀空格 4、比较方法a、localeCompare() 功能：用本地特定顺序比较两个字符串 参数：与原字符串进行比较的字符串 返回值：说明比较结果的数字 负数：原字符串 &lt; 参数字符串 0 ： 原字符串 = 参数字符串 正数：原字符串 &gt; 参数字符串 三、编码方法1、字符串常规编码与解码 escape() unescape() 2、URI字符串编码与解码 encodeURI() decodeURI() 3、URI组件编码与解码 encodeURIComponent() decodeURIComponent() 四、转换方法1、大小写转换a、转为大写 toUpperCase() toLocaleUpperCase() ：本地 b、转为小写 toLowerCase() toLocaleLowerCase() ：本地 2、代码转换 用js动态格式化html，不具语义性，舍弃]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-变量]]></title>
    <url>%2Fposts%2Fb062d643.html</url>
    <content type="text"><![CDATA[一、命名1、方法a、匈牙利命名法（变量名=类型+对象描述） Int 整型 i float 浮点型 fi Bollean 布尔 b String 字符串 s Array 数组 a Obeject 对象 o Function 函数 fn Regular Expression 正则 re b、驼峰命名法 全部小写 单词与单词间用下划线分割 大小写混合 大驼峰：每个单词首字母大写 小驼峰：第一个单词首字母小写，其他首字母大写 2、规则 首字母：英文字母或者下划线 组成：英文字母，数字，下划线 禁忌：JavaScript关键词与保留字 二、声明1、显示声明 var变量名 2、陋习 没有类型 重复声明 隐式声明 不声明直接赋值 3、正解 先声明、后读写 先赋值、后运算 三、变量类型1、值类型 占用空间固定，保存在栈中 保存与复制的是值本身 使用typeof检测数据的类型 基本类型数据是值类型 2、引用类型 占用空间不固定，保存在堆中 保存与复制的是指向对象的一个指针 使用instanceof检测数据的类型 使用new()方法构造出的对象是引用型 四、作用域1、全局变量a、包含 在函数体外定义的变量 在函数体内定义的无var声明的变量 b、调用 任何位置 2、局部变量a、包含 在函数内部使用var声明的变量 函数的参数变量 b、调用 当前函数体部 3、优先级 局部变量高于同名全局变量 参数变量高于同名全局变量 局部变量高于同名参数变量 4、热性a、忽略块级作用域b、全局变量是全局对象的属性c、局部变量是调用对象的属性d、作用域链 内层函数可访问外层函数局部变量 外层函数不能访问内层函数局部变量 e、生命周期 全局变量：除非被显示删除，否则一直存在 局部变量：自声明起至函数运行完毕或被显示删除 回收机制 标记清除 引用计数]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件之间8种组件通信方式总结]]></title>
    <url>%2Fposts%2F40775045.html</url>
    <content type="text"><![CDATA[对于vue来说，组件之间的消息传递是非常重要的，下面是我对组件之间消息传递的各种方式的总结，总共有8种方式。 1 props和$emit 2 $attrs和$listeners 3 中央事件总线 4 provide和inject 5 v-model 6 $parent和$children 7 boradcast和dispatch 8 vuex处理组件之间的数据交互 1.props和$emit父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。 Vue.component(&apos;child&apos;,&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;/div&gt; `, props:[&apos;message&apos;],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit(&apos;getChildData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child :message=&quot;message&quot; v-on:getChildData=&quot;getChildData&quot;&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125;, methods:&#123; //执行子组件触发的事件 getChildData(val)&#123; console.log(val) &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 在上面的例子中，有父组件parent和子组件child。1).父组件传递了message数据给子组件，并且通过v-on绑定了一个getChildData事件来监听子组件的触发事件；2).子组件通过props得到相关的message数据,最后通过this.$emit触发了getChildData事件。 2.$attrs和$listeners第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。 Vue.component(&apos;C&apos;,&#123; template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt; &lt;/div&gt; `, methods:&#123; passCData(val)&#123; //触发父组件A中的事件 this.$emit(&apos;getCData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;B&apos;,&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt; &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt; &lt;/div&gt; `, props:[&apos;message&apos;],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit(&apos;getChildData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;A&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;B :messagec=&quot;messagec&quot; :message=&quot;message&quot; v-on:getCData=&quot;getCData&quot; v-on:getChildData=&quot;getChildData(message)&quot;&gt;&lt;/B&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos;, messagec:&apos;hello c&apos; //传递给c组件的数据 &#125; &#125;, methods:&#123; getChildData(val)&#123; console.log(&apos;这是来自B组件的数据&apos;) &#125;, //执行C子组件触发的事件 getCData(val)&#123; console.log(&quot;这是来自C组件的数据：&quot;+val) &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;A&gt;&lt;/A&gt; &lt;/div&gt; ` &#125;) 3.中央事件总线上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。 Vue.component(&apos;brother1&apos;,&#123; data()&#123; return &#123; mymessage:&apos;hello brother1&apos; &#125; &#125;, template:` &lt;div&gt; &lt;p&gt;this is brother1 compoent!&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;/div&gt; `, methods:&#123; passData(val)&#123; //触发全局事件globalEvent bus.$emit(&apos;globalEvent&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;brother2&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is brother2 compoent!&lt;/p&gt; &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, data()&#123; return &#123; mymessage:&apos;hello brother2&apos;, brothermessage:&apos;&apos; &#125; &#125;, mounted()&#123; //绑定全局事件globalEvent bus.$on(&apos;globalEvent&apos;,(val)=&gt;&#123; this.brothermessage=val; &#125;) &#125; &#125;) //中央事件总线 var bus=new Vue(); var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt; &lt;/div&gt; ` &#125;) 4.provide和inject父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。 Vue.component(&apos;child&apos;,&#123; inject:[&apos;for&apos;],//得到父组件传递过来的数据 data()&#123; return &#123; mymessage:this.for &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;tet&quot; v-model=&quot;mymessage&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, provide:&#123; for:&apos;test&apos; &#125;, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 5.v-model父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值 Vue.component(&apos;child&apos;,&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$emit(&apos;input&apos;,this.mymessage);//通过如此调用可以改变父组件上v-model绑定的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @change=&quot;changeValue&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;child v-model=&quot;message&quot;&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 6.$parent和$childrenVue.component(&apos;child&apos;,&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$parent.message = this.mymessage;//通过如此调用可以改变父组件的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @change=&quot;changeValue&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;button @click=&quot;changeChildValue&quot;&gt;test&lt;/button &gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, methods:&#123; changeChildValue()&#123; this.$children[0].mymessage = &apos;hello&apos;; &#125; &#125;, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 7.boradcast和dispatchvue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和on和emit的封装，但在一些基础组件中却很实用。 function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; var name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat(params)); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;; 8.vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。 详情可参考：https://vuex.vuejs.org/zh-cn/]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（十）DOM0和DOM2级事件]]></title>
    <url>%2Fposts%2F64d673ce.html</url>
    <content type="text"><![CDATA[JS中的DOM0和DOM2事件JS中的事件基础及核心原理以及项目实战事件的定义 事件：元素天生具备的行为方式（和写不写JS代码没有关系）【onclick不是事件，click才是事件，浏览器会把一些常用事件挂载到元素对象的私有属性上，让我们可以实现DOM0事件绑定】，当我们去操作元素的时候会触发元素的很多事件事件绑定：给当前元素的某个事件绑定方法，目的是让当前元素某个事件被触发时，做出一些反应 事件绑定的两种方法 DOM0级事件绑定 curEle.onclick=function(){}; DOM2级事件绑定 标准浏览器：curEle.addEventListener(‘click’,function(){},false) IE6-8:curEle.attachEvent(‘onclick’,function(){}) DOM0事件常用事件汇总[PC端] 表单元素常用的事件 blur:失去焦点 focus:获取焦点 change:内容改变 select:被选中事件 键盘常用事件行为 keydown:键盘按下 keyup:键盘抬起 keypress:键盘按下（中文输入法不能触发，英文状态下可以触发，因为文本被输入到文本框中） 鼠标常用事件行为 click:点击（不是单击） dblclick:双击（300ms之内连续触发两次点击事件） mouseover:鼠标滑过 mouseout:鼠标滑出 mouseenter: 鼠标进入 mouseleave: 鼠标离开 mousedown:鼠标按下（左键） mouseup:鼠标左键抬起 mousewheel:鼠标滚轮滚动 其他常用事件行为 load:加载成功 error:加载失败 scroll: resize:大小改变事件:window.onresize:浏览器窗口改变大小触发该事件 [移动端 移动端键盘一般都是虚拟键盘，虽然存在keydown,keyup,但兼容不好，使用input事件代替移动端没有鼠标，所以鼠标类事件在移动端兼容性非常差，mouse类事件基本无法使用移动端大部分事件是靠手指完成的，所以它独有手指事件-单手指事件：touchstart touchmove touchend touchcancel-多手指事件：gesturestart gestuerchange gestuerend…..移动端还有很多事件是靠硬件完成的：手机传感器，陀螺仪，重力感应器等移动端兼容click事件，它把click当做单击使用（会有300MS的延迟事件） 事件对象 对以下事件绑定的严谨版描述：基于DOM0级事件的绑定方式，给box的click事件绑定了一个方法。当手动触发click事件时，会把绑定的方法执行box.onclick=function(e){arguments[0]===e;//=&gt;e就是事件对象e=e||window.event;(兼容版获取事件对象的写法)};当元素的某个事件行为被触发，不仅会把之前绑定的方法执行，还会给绑定的方法传递一个值（浏览器默认传递的），我们把传递的这个值称为事件对象：（标准浏览器） 这个值是个对象类型的值，里面存储了很多的属性和方法， 这些存储的值都是当前本次操作的基本信息，例如：鼠标位置，触发行为类型。。。。【只和本次操作有关,一个页面中只有一个事件对象】 IE6-8下关于事件对象的机制 方法被触发执行时，浏览器并没有把事件对象当做值传递给函数；(e是undefined) IE6-8下的事件对象需要我们通过window.event来获取 鼠标事件对象（mouseevent） clientX/clientY:当前鼠标触发点距离当前窗口左上角的X/Y坐标 pageX/pageY:当前鼠标触发点距离BODY左上角的X/Y坐标(IE6-8中没有这两个属性)兼容处理 box.onckick=function(e)&#123; if(typeof e==='undefined')&#123; e=window.event; //-&gt;处理e //-&gt;pageX/pageY e.pageX=e.clientX+(document.documentElement.scrollLeft||document.body.scrollLeft); e.pageY=e.clientY+(document.documentElement.scrollTop||document.body.scrollTop); //-&gt;target e.target=e.srcElement; //-&gt;preventDafault e.preventDefault=function()&#123; e.returnValue=false; &#125;; //=&gt;stopPropagation e.stopPropagation=function()&#123; e.cancelBubble=true &#125; &#125; &#125;//该兼容比较完整，当处理一个简单兼容时可简单处理 type:当前触发事件的类型 target：事件源（当前鼠标操作的是那个元素）（IE6-8没有该属性，用srcElement这个属性代表事件源） preventDefault:作用：阻止事件的默认行为；（IE6-8没有该方法，使用 returnValue=false处理） stopPropagation:阻止事件的冒泡传播 [IE6-8不兼容，使用cancelBubble=true来处理] 键盘事件对象(keyboardEvent) code:当前按得键盘按键是哪一个 【IE6-8没有这个属性】key属性和code一样，储存形式不一样 keyCode：存储的是当前按键的码值（大部分按键都有自己的码值） which:和keyCode一样，也是当前按键的码值（which不兼容IE6-8） 这几个码值需要记住（删除：8 、 回车：13、 空格：32、 tab ：9、） 手指事件对象（TouchEvent）touches&amp;&amp;changedTouches&amp;&amp;targetTouches:存储的是当前屏幕上每一个手指操作的位置信息 touches：只有手指在屏幕上我们才能获取相关信息，手指离开后，这样touchend事件中我们就无法通过touches获取手指信息 changedTouches：手指在屏幕上时，和touches一样可以获得相关信息，手指离开后也可以记录手指离开屏幕一瞬间所在的位置信息（最常用的） touchesEvent type:'touchStart', target:事件源， touches: 0:&#123; clientX:xxx, clientY:xxx, pageX:xxx, pageY:xxx, ..... &#125; ... lentth：1 chan 详细处理 let oBox = document.querySelector('#box');oBox.ontouchstart = function (e) &#123; let point = e.changedTouches[0]; //=&gt;记录当前手指的起始坐标位置(记录在当前元素的自定义属性上) this.strX = point.pageX; this.strY = point.pageY; this.isMove = false;&#125;;oBox.ontouchmove = function (e) &#123; let point = e.changedTouches[0]; //=&gt;一般我们手指操作，都会或多或少的发生一些偏移（习惯性偏移），此时不应该算作滑动，只有滑动的距离超出一定范围，我们按照滑动处理即可（一般都是把10px作为偏差值） let changeX = point.pageX - this.strX, changeY = point.pageY - this.strY; this.changeX = changeX; this.changeY = changeY; if (Math.abs(changeX) &gt; 10 || Math.abs(changeY) &gt; 10) &#123; this.isMove = true; &#125;&#125;;oBox.ontouchend = function (e) &#123; let point = e.changedTouches[0]; //=&gt;手指离开的时候：验证是否发生滑动 if (!this.isMove) &#123; //=&gt;点击操作 console.log('我是点击操作~~'); return; &#125; //=&gt;滑动操作 let dir = null; if (Math.abs(this.changeX) &gt; Math.abs(this.changeY)) &#123; //=&gt;左右滑动 dir = this.changeX &lt; 0 ? 'LEFT' : 'RIGHT'; &#125; else &#123; //=&gt;上下滑动 dir = this.changeY &lt; 0 ? 'UP' : 'DOWN'; &#125; console.log(`当前手指滑动的方向为：$&#123;dir&#125;`);&#125;; 手机移动端的点击、长按、滑动等都是基于内置的原生的touchstart/touchmove/touchend事件模拟出来的一些效果，没有现成的事件市场上有许多成熟的类库，我们直接使用即可1、fastclick.js:目的就是解决了移动端click事件300ms的延迟问题2、百度云touch手指事件库3、hammer.js4、zepto.js:提供移动端事件操作的板块，也是目前市场上使用率最高的 阻止事件的默认行为A标签的默认行为及阻止 1.超链接：点击A标签可以实现页面的跳转2、锚点定位：通过HASH值定位到当前页面的指定ID盒子位置- 首先URL地址栏末尾追加了一个HASH;- 如果地址栏包含hash值，浏览器在渲染页面后，会默认定位到hash值的位置 真实项目中我们想用A标签做一个普通按钮（优势：它的：hover样式是兼容所有浏览器的）此时，要把之前提到的两个默认行为阻止掉才可以 阻止A标签的默认行为 在HTML中阻止默认行为（常用） ; 在JS中阻止 单点击A标签时 首先会触发click事件 其次按照href中的地址页面进行跳转link.onclick=function(){ return false;}//阻止页面行为link.onclick=function(e){​ e=e||window.event;​ e.preventDefault?e.preventDefault():e.returnValue=false;​ } 事件的传播机制事件传播有三个阶段Event.prototype： - 0 NONE:默认值，不代表任何意思- 1 `CAPTURING_PHASE 捕获阶段`- 2 ` AT_TARGET 目标阶段（当前事件源）`- 3 `BUBBLING _PHASE :冒泡阶段` 当前元素的某个事件行为被触发，它的所有的祖先元素（一直到document）的相关事件行为也会被触发执行（由里向外），我们把这种传播机制叫做冒泡传播 mouseover和mouseenter事件的区别mouseover：鼠标滑到元素上：存在事件的冒泡传播机制 mouseenter：鼠标进入元素里；浏览器阻止了它的冒泡传播机制； 不同点 区别 mouseover mouseenter 区别 1 存在冒泡传播机制 冒泡传播机制被浏览器阻止 区别 2 当鼠标从父元素进入到子元素时，首先会触发父元素的mouseout事件，再触发子元素的mouseover事件，由于冒泡传播机制，导致父元素的mouseover事件也被触发 当鼠标从父元素进入到子元素时,并不会触发父元素的mouseout事件，但是触发了子元素的mouseenter事件，由于浏览器阻止了它的冒泡传播，所以父元素的该事件不会被触发 事件委托（very important）原理：利用事件的冒泡传播机制完成（mouseenter不存在冒泡传播） 当一个容器内的很多元素都要为同一事件绑定方法，那么我们只需要给外层容器的该事件绑定方法，当里层元素的事件被出发时，会通过冒泡传播机制传到最外层容器那里，触发外层容器绑定的方法执行，在方法执行时，我们只需要根据判断事件源的不同而做不同的事情。（利用事件委托可提高50%左右的性能） 拖拽当中鼠标焦点丢失问题在拖拽登陆窗口的案例中（11.25） 当鼠标移动速度过快时，鼠标离开了h3，因为盒子跟不上奔跑的速度，所以导致以下几个问题 - 鼠标在h3之外飞，不会触发H3的mousemove，盒子就不动了； - 鼠标在h3之外抬起，也不会触发h3的mouseup，那么原有绑定的dragmove无法被移除，鼠标重新进入h3,此时不管鼠标是否按下，都会触发H3的dragmove； 原因：鼠标飞出h3,再怎么操作就和h3没有关系 解决方案： 1.把mouseup和mousemove事件绑定给document,原因：不管鼠标怎么飞，都飞不出document；（使用箭头函数）只要你鼠标还在文档中，那么mousemove和mouseup永远生效 2.setCapture（不兼容谷歌，支持Ie） DOM2事件绑定 //=&gt;标准浏览器 oBox.addEventLister('click',function(e)&#123; //this:obx &#125;,false) //false=&gt;让事件在冒泡传播时执行//true=&gt;让事件在捕获阶段执行（非常少见） //=&gt;IE6-8浏览器 oBox.attachEvent('onclick',function(e)&#123; //e:事件对象，不同于DOM0级事件，浏览器会默认将事件对象传递进来，与window.event的值相同，因此对于：pageX/pageY/target...等依旧存在兼容； &#125;) //=&gt;绑定的方法都是在冒泡传播阶段执行 DOM1? 在DOM第一代升级迭代的时候，事件绑定依然沿用DOM0绑定的方式..so… DOM0于DOM2事件绑定的区别DOM0事件绑定的原理 给当前元素的某一私有属性（onXXX）赋值的过程；（之前属性默认值是null，如果我们赋值了一个函数，就相当于绑定了一个方法） 当我们赋值成功（赋值一个函数），此时浏览器会把DOM元素和赋值的的函数建立关联，以及建立DOM元素的行为监听，当某一行为被用户触发，浏览器会把赋值的函数执行； DOM0事件绑定的特点 只有DOM元素天生拥有这个私有属性（onxxx事件私有属性），我们赋值的方法才叫事件绑定，否则属于设置自定义属性 移除事件绑定的时候，我们只需要赋值为null； 在DOM0事件绑定中，只能给当前元素的某一个事件行为绑定一个方法，绑定多个方法，最后一次的绑定的会替换前面绑定的 DOM2事件绑定的原理 DOM2事件绑定使用的addEventListener/attachEvent方法都是在eventTarget这个内置类的原型上定义的，我们调用的时候，首先要通过原型链找到这个方法，然后执行完成事件绑定的效果 浏览器会给当前元素的某个事件行为开辟一个事件池（事件队列）【浏览器有一个统一的事件池，每个元素绑定的行为都放在这里，通过相关标志区分】，当我们通过 addEventListener/attachEvent进行事件绑定的时候，会把绑定的方法放在事件池中； 当元素的某一行为被触发，浏览器回到对应事件池中，把当前放在事件池的所有方法按序依次执行 特点 所有DOM0支持的行为，DOM2都可以用，DOM2还支持DOM0没有的事件行为（这样说比较笼统）（核心）【浏览器会把一些常用事件挂载到元素对象的私有属性上，让我们可以实现DOM0事件绑定，DOM2：凡是浏览器给元素天生设置的事件在DOM2中都可以使用】例如：onDOMContentLoaded（所有的DOM0和IE6-8的DOM2都不支持）​onDOMContentLoaded//当前浏览器中的DOM结构加载完成，就会触发这个事件 DOM2中可以给当前元素的某一事件行为绑定多个不同方法（因为绑定的所有方法都放在事件池中）； 事件的移除:事件类型、绑定的方法、传播阶段三个完全一致，才可以完成移除(因此在绑定方法时，尽量不要用匿名函数，否则不好移除) //=&gt;ON:给当前元素的某个事件绑定某个方法 var on = function (curEle, type, fn) &#123; if (document.addEventListener) &#123; //=&gt;标准浏览器 curEle.addEventListener(type, fn, false); return; &#125; //=&gt;IE6~8 curEle.attachEvent('on' + type, fn);&#125;;//=&gt;OFF:移除当前元素某个事件绑定的某个方法13.var off = function (curEle, type, fn) &#123;14. if (document.removeEventListener) &#123;15. curEle.removeEventListener(type, fn, false);16. return;17. &#125;18. //=&gt;IE6~819. curEle.detachEvent('on' + type, fn);20.&#125;; xxx.removeEventLister(&#39;click&#39;,function(){},false) ==DOM0和DOM2绑定的方法是毫无联系的（因为是两套完全不同的机制），即使绑定的方法相同，也是执行两次，谁先绑定，就先执行谁== window.onload&amp;&amp;$(document).ready()的区别window.onload:当浏览器中的所有资源（DOM结构、文本内容、图片）都加载完成，触发load事件； 它是基于DOM0的事件绑定机制完成的，所以在同一页面中只能为他绑定一个方法，绑定多个，以最后一个为主； 如果想在一个页面中使用多次，应该是基于DOM2绑定的； function fn1()&#123;&#125; function fn1()&#123;&#125;window.addEventListener('load',fn1,false);window.addEventListener('load',fn2,false); $(function(){})或者$(document).ready(function(){});当文档中的DOM结构加载完成，就会触发执行，在一个页面中可以使用多次 JQ中提供的方法，JQ是基于onDOMContentLoaded这个事件完成操作的 JQ中的事件绑定都是基于DOM2事件绑定的 onDOMContentLoaded在IE6-8下attachEvent也是不支持的，JQ在IE6-8下使用readystatechange来完成 DOM2事件的兼容处理 语法上的兼容标准： curEle.addEventListener（’type’,fn,false）;IE6-8: curEle.attachEvent（’on’+type,fn）; 顺序问题标准：按照绑定的顺序依次执行IE6-8:当事件行为被触发，IE6-8执行是乱序 重复问题标准：可以自动去重，已经存在的方法不允许再次添加IE6-8:在向事件池中增加方法时没有去重机制 this问题标准：当事件行为被触发，方法中的this指向当前元素本身IE6-8:当事件行为被触发，方法中的this指向window IE6-8事件池机制vs标准浏览器事件池机制（比较规范的回答） 1、向事件池中添加方法时，标准浏览器是使用addEventListener,IE6-8使用的是attachEvent；而且标准浏览器有自动去重的机制，已经添加的方法不允许再次添加。IE6-8没有去重机制；2、浏览器执行事件池中的方法时，不仅把方法执行，还把事件对象当作实参传递给给对应的方法，但是也是有区别的，IE6-8传递的事件对象的值和window.event是相同 的，因此存在兼容问题；3.当事件行为被触发，标准浏览器是依次执行，方法中的this指向当前元素；IE6-8下，是乱序执行，且方法中的this指向window； 不兼容的本质：IE6-8低版本浏览器对于他的内置事件池处理机制的不完善导致的。DOM2事件绑定兼容处理机制原理：自己创建一个类似于标准浏览器的自定义事件池（针对IE6-8） on :手动创建一个自定义事件池，把需要绑定的方法全部存在自定义事件池中 off: 把不需要绑定的方法从自定义事件池中移除 run：把run放在内置事件池中，当行为触发，需要浏览器把run执行，在run中把自定义事件池的方法执行。 //向事件池追加方法var on = function (curEle, type, fn) &#123; //标准浏览器无需处理 if (document.addEventListener) &#123; curEle.addEventListener(type, fn, false); return; &#125; //创建自定义事件池：创建到当前元素的自定义属性上，不受作用域限制，以后在其他方法中需要使用，可直接获取（不放在全局是防止全局污染） // 每一个事件都有一个独立的事件池 if (typeof curEle[type + 'pond'] === 'undefined') &#123; curEle[type + 'pond'] = []; //只要执行on,就说明当前方法已被绑定 //把run放到内置事件池中； // curEle.attachEvent('on'+type,run);//需要保证run中的 this是当前元素 curEle.attachEvent('on' + type, function () &#123; run.call(curEle, e);//将run放在一个匿名函数中，强制改变this &#125;); &#125; var aryPond = curEle[type + 'pond']; // 去重操作，当前事件池中是否有当前事件 for (var i = 0; i &lt; ary.length; i++) &#123; if (aryPond[i] === fn) &#123; return; &#125; &#125; aryPond.push(fn);&#125;;//移除事件池的某个方法var off = function (curEle, type, fn) &#123; if (document.removeEventListener) &#123; curEle.removeEventListener(type, fn, false); return; &#125; var aryPond = curEle[type + 'pond']; if (!aryPond) return; for (var i = 0; i &lt; ary.length; i++) &#123; if (aryPond[i] === fn) &#123; // aryPond.splice(i,1);此方法会导致原始数组索引改变，此时正在执行的run循环，索引和想要的索引不一致，数组塌陷 //我们不能让当前数组的索引改变； aryPond[i] = null;//置空，索引没变 &#125; &#125;&#125;;//把自定义事件池中的方法依次执行var run = function (e) &#123; // this=&gt;curEle //e:window.event，不兼容，需要处理 if (typeof e.target === 'undefined') &#123; e.target = e.srcElement; e.which = e.keyCode; e.pageX = e.clientX + document.documentElement.scrollLeft || document.body.scrollLeft; e.stopPropagation = e.cancelBubble = true; e.preventDefault = e.returnValue = false; &#125; var aryPond = curEle[type + 'pond']; if (!aryPond) return; for (var i = 0; i &lt; aryPond.length; i++) &#123; var itemFn = aryPond[i]; // itemFn();=&gt;这样执行itemFn里的this时window，须将他替换成函数里的this if (itemFn === null) &#123; //当前这一项在执行的时候，可以将off中置空的那一项删除 aryPond.slice(i, 1); i--; continue; &#125; itemFn.call(this, e); &#125;&#125;; Bind方法的封装//ES5封装 BIND Function.prototype.myBind = function myBind(context) &#123; //this=&gt;当前需要处理的函数 //context=&gt;我们需要预先改变的this值（如果不传，默认window）； //arguments=&gt;存储包含context在内的所有实参； context = context || window; var outerArg = Array.prototype.slice.call(arguments, 1); var _this = this; if('bind' in this)&#123;//如果不是IE6-8，直接返回 return _this.bind.apply(_this,arguments) ; &#125; return function () &#123; var innerArg = Array.prototype.slice.call(arguments); outerArg = outerArg.contact(innerArg); _this.apply(context, outerArg); &#125; &#125; //ES6方法 Function.prototype.myBind = function myBind(context = window, ...outer) &#123; //使用ES6中的剩余运算符 if ('bind' in this) &#123; return this.bind(arguments); &#125; return function (...inner) &#123; this.apply(context, outer.concat(inner)); &#125; &#125;;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（九）定时器]]></title>
    <url>%2Fposts%2Fdb9fe196.html</url>
    <content type="text"><![CDATA[JS中的定时器&amp;&amp;动画&amp;&amp;同步异步编程定时器设置一个定时器并设定一个等待时间，当到达时间，执行指定要完成的事情；JS中的定时器一共有两种： window.setTimeout（执行一次） window.setTimeout(function,[interval]):设置了一个定时器，当到达指定时间后执行对应的方法（执行一次定时器就结束了）；（第一个参数是函数，第二个参数是时间，a单位都是毫秒，自己不需要加单位，17是个比较理想的时间） window.setTimeout(function()&#123;console.log('ok');//100ms后输出一次 ‘ok'，此时定时器结束，但是定时器并没有被清除；&#125;,100);//定时器等待时间设置为0也不是立马执行，浏览器也有一个最小反应时间（13MS-14ms）， [interval]：时间因子，需要等待的时间 window.setInterval（执行多次） window.setInterval(function,[interval])：设置一个定时器，当达到指定时间后执行对应的方法（以后每隔这么长时间就重新执行这个方法，直到定时器清除为止，执行很多次） var n=0；window.setInterval(function()&#123;console.log(n++);//每隔100ms输出一次 ，1，2，3，4。。。。&#125;,100);//定时器等待时间设置为0也不是立马执行，浏览器也有一个最小反应时间（13MS-14ms）， 定时器的返回值定时器的返回值，不管是setTimeout还是setInterval都会有一个数字类型的返回值，代表当前是在浏览器中设置的第几个定时器（返回的是定时器的序号） setTimeout和setInterval虽然是处理不同需求的定时器，但是都是浏览器的定时器，所以设置的时候，返回的序号是依次排序setInterval：设置完成时定时器会有一个返回值，不管执行多少次，这个代表序号的的返回值不变（设置定时器就会有返回值，执行多少次是定时器的处理 定时器的清除定时器都需要手动清除，下面两个清除的方法没有区别 clearTimeout([定时器排队的序号])clearIterval（[定时器的排队序号]） 当方法执行完成后，我们清除定时器即可 eg: clearTimeout(1) ，这相当于在浏览器中将第一个定时器清除了。同时我们还需要将之前存储序号的变量赋值为null，例如t1=null，优化JS的内存空间 var timer1=setInterval(function()&#123; &#125;,192);//timer1=1，是该定时器的返回值（即该定时器序号）var n=0；var timer2=setTimeout(function()&#123; n++;console.log(n); if(n&gt;=10)&#123; clearSetInterval(timer2);//手动清除 &#125;&#125;,192);//timer2=2，是该定时器的返回值 定时器的原理 当我们在JS中创建一个定时器后，浏览器会把计时执行方法的这个任务放在浏览器的等待任务队列（等待任务池）中，并且安排一个监控者（属于浏览器开辟的新线程），也就是记录当前已经走的时间，到达时间后，监控者会通知浏览器时间到了，浏览器（在把主任务队列的内容执行完后）会把之前放在等待任务队列中的方法拿出来执行； JS中动画实现的原理 浏览器实现动画有三种常用发方法CSS动画在CSS3中提供了transtation动画和animation动画两种动画，优势在于性能好，实现简单，（一般能用css写的绝不用其他方式），弊端在于不兼容IE或其他低版本浏览器（移动端的动画一般都是基于css来完成的）JS中的动画在JS中实现动画常用的有：=&gt;使用定时器驱动的动画=&gt;使用requestAnimationFrame来完成动画而所谓的CANVAS动画基本上也是基于站两种方式完成的（CANVAS本身是绘图）FLASH动画早期实现动画的方法，现在一些简单的DOM动画都告别了FLASH时代 基于定时器的动画 基于定时器实现的动画的两种解决方案- 固定步长的动画- 固定时间的动画（比较常用）我们最好封装一个方法，支持固定时间的多方向的匀速或飞匀速运动 如何实现多方向匀速 回调函数(callBack) 把一个函数当做实参传递给另一个函数，在另外一个函数中执行这个函数，这种处理机制叫做回调函数 function fn(callBack) &#123; //=&gt;callBack:传递进来的匿名函数 callBack();&#125;fn(function () &#123; console.log('ok');&#125;); 凡是在当前方法执行的某个阶段，执行一个不确定的事情，我们可以将这件事情当做参数 JS中的同步编程和异步编程 JS是单线程的（一次只能执行一个任务，当前任务没有完成，下面的任务是不进行处理的）同步编程（sync）：当前任务是按照顺序一件件完成的，当前任务没有完成，下面的任务不进行处理异步编程（async）：当前任务在等待执行的时候，我们不去执行，继续完成下面的任务，当下面的任务完成后，也到达的等待的时间了，才去完成当前的任务 定时器都是异步编程的-所有的事件绑定也是异步的-AJAX中有异步编程-有些人把回调函数当做异步编程其余都是同步编程 var startTime=new Date();//获取开始的时间 for (var i = 0; i &lt; 1000; i++) &#123;if(1===99)&#123; console.log(i);&#125;&#125;console.log(new date -startTime);//计算完成循环的时间 在项目中，要避免出现死循环，因为循环时同步编程，当前循环无法结束证明任务没有完成，后续任务无法进行 var n = 0;//第一件任务：创建一个变量 // 第二件任务：创建一个定时器（等待任务，1000MS执行方法是一个等待执行的任务） setTimeout(function () &#123; n++； console.log(n);//再输出n=1 &#125;, 1000);//第三件任务：输出0console.log(n); //首先输出n=0; 同步异步编程的核心原理 JS中有两个任务队列（存放任务列表的空间） 1、主任务队列：同步执行任务（从上到下依次执行）2、等待任务队列：异步执行任务]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（八）盒子模型]]></title>
    <url>%2Fposts%2Fba5b0d45.html</url>
    <content type="text"><![CDATA[JS中DOM盒子模型深入分析CSS盒子模型传统盒子模型width height:不是盒子的宽高，而是盒子中的内容 盒子的宽度=width+border2+padding2//在一个对称的模型中 CSS3新增加的盒子模型增加该属性，width和height的数值就是盒子的宽高； box-sizing:border-box; JS盒子模型 提供一些属性和方法用来描述盒子的样式的 clientclientWidth / clientHeight 当前盒子可视区域的宽度和高度可视区域：内容的宽高+padding*2clientHeight=height+padding(top&amp;&amp;bottom)clientWidth=height+padding(left&amp;&amp;right)和内容是否溢出和我们是否设置了overflow:hidden没有关系 document.documentElement.clientWidth||document.body.clientHight //获取当前页面一屏幕的宽度 在不知盒子宽高的情况下，让盒子居中 var winH=document.documentElement.clientHeight||document.body.clientHeight;var winW=document.documentElement.clientWigth||document.body.clientWigth;var boxW=box.clientWidth;var boxH=box.clientHeight;box.style.left=(winW-boxW)/2+'px';box.style.top=(winH-boxH)/2+'px'; clientTop 和 clientLeft 只有top和left，没有其他的clientTop：盒子上边框的高度clientLeft：盒子左边框的宽度通过JS盒子模型获取的结果是不带单位的，而且只能是整数，（他会自动四舍五入） offsetoffsetWidth 和 offsetHeight 在clientHeight和clientWidth的基础上加上了边框的长度；offsetWidth=clientWidth+左右边框(border)offsetHight=clienthight+上下边框真实项目中，如果想要得到盒子的宽度和高度一般都用offsetWidth和offsetHeight，这样就包含了盒子的边框 var winH=document.documentElement.offsetHeight||document.bodyElement.offsetHeight;var winW=document.documentElement.offsetWigth||document.bodyElement.offsetclientWigth;var boxW=box.offsetWidth;var boxH=box.offsetHeight;box.style.left=(winW-boxW)/2+'px';box.style.top=(winH-boxH)/2+'px'; offssetParent 当前和盒子的父级参照物（得到父级参照物元素） 父级参照物不等价于父级元素，与父级元素没有直接关系父级参照物：同一平面中最外层容器是所有里层盒子的父级参照物一般情况下，一个页面所有元素的父级参照物都是body，body没有父级参照物； 当我们给元素设置定位（会让元素脱离文档流）的时候，会改变父级参照物（不在一个平面上） offsetTop&amp;offsetLeft:当前元素外边框距离父级参照物的内边框的偏移量（标准IE8浏览器特殊性： 当前元素最外边框距离父级参照物的外边框的偏移里量 ）window.navigator.userAgent 获取浏览器的版本号 获取页面中任何一个元素距离body的左偏移和上偏移，不知道该元素的具体位置。思路： 首先获取自己的偏移量及父级参照物如果父级参照物不是body，我们加上父级参照物的边框和偏移量。。。一直加到父级参照物为body的元素为止 scrollscrollHeight &amp;&amp; scrollWidth 没有内容溢出：获取的结果和clientWidth、clientHeight的结果相同；有内容溢出：真实内容的宽度或高度，包含溢出内容的值，再加上padding或左padding的值scrollWidth&amp;&amp;scrollHeight获取的是约等于的值由于内容溢出，每个浏览器对于行高或文字的渲染不一样，回去的结果也不一样是否设置overflow：hidden对最后的结果也有影响 获取当前页面的真实高度（包含溢出） document.documentElement.scrollWidth||document.body.scrollHight scrollLeft &amp;&amp; scrollTop 横向或竖向滚动条卷去的宽度或高度(在拉动滚动条时，上面的内容会被卷去，就是scrollTop) 最小值：0 最大值：scrollHight-clientHight:真实页面高度-一屏幕的高度 前面的JS盒子模型的属性都是只读属性，只能获取，不能修改；而scrollTop&amp;&amp;scrollLeft是可读写属性，既可以获取，也可以修改； window.onscrollwindow.onscroll:浏览器滚动条滚动事件（只要滚动就会触发该事件） * 1、鼠标滚轮控制 或者 手动拖动滚动条 * 2、键盘按键控制 * 3、使用JS代码控制 * … * 不管什么方式,只要滚动条动了就会触发这个事件 在JS中获取元素的具体的样式值 通过JS盒子模型12个属性（不包含offsetParent）获取的结果都是整数，没有单位，如果有小数，浏览器会自动四舍五入通过JS盒子模型 属性获得的值都是组合值，不能单独获取某一个具体样式值 curEle.style.xxx; 获取当前元素所有写在行内样式上的样式值(如果样式没有设置在行内元素上 得到空字符串)特殊：只有把样式写在行内样式上，才可以通过这种方法获取到=》这种方法在真实项目中比较少见，因为我们很少在行内样式上写样式 window.getComputedStyle &amp;&amp; curEle.currentStyle 只要当前元素在页面中显示出来，我们就可以获得其样式值（不管是行内还是样式表），也就是获取所有经过浏览器计算过的值，包括你没有写浏览器默认设置的值。window.getComputedStyle:适用于标准浏览器，IE6-8不兼容，在IE6-8的Window全局对象中，没有提供getComputedStyle这个属性和方法，我们使用curEle.currentStyle来获取需要的样式值 //通过getComputedStyle获得的结果是一个对象,包含当前元素所有的样式属性和属性值 语法：window.getComputedStyle([当前需要操作的元素],[当前元素的伪类，一般写null])window.getComputedStyle(box,null).paddingleft; //通过 curEle.currentStyle来获取样式box.currentStyle.paddingleft; 封装一个公共的方法：getCss //getCSS：获取当前元素某一个样式的属性值//@parameter curEle:当前需要操作的元素//attr:要获取样式的属性名function getCss(curEle,attr)&#123;var value=null;var reg=null;try&#123;value=window.getComputedStyle(cueEle,null)[attr];&#125;catch(e)&#123;value=curEle.currentStyle&#125;reg=/^-?\d+(\.\d+)?(px|pt|em|rem)?$/i;//去除单位reg.test(value)?value=parseFloat(value):null;return value;&#125;console.log(getCss(box,'display')); 方法二： function getCss(curEle, attr) &#123;var value = null,reg = null;if ('getComputedStyle' in window) &#123;value = window.getComputedStyle(curEle, null)[attr];&#125; else &#123;value = curEle.currentStyle[attr];&#125;//=&gt;去除单位reg = /^-?\d+(\.\d+)?(px|pt|rem|em)?$/i;reg.test(value) ? value = parseFloat(value) : null;return value;&#125;console.log(getCss(box, 'display')); 设置元素的样式 curEle.style.xx=xxx;设置当前元素的行内样式；（JS设置样式一般都设置在行内样式上，因为行内样式优先级最大）（JS操作属性不支持-，所有-改成下一个单词大写）curEle.className=xxx;设置元素的样式类名； curEle['style'][attr]=value;//传递value值，如果没有单位，需要补单位//并不是所有的值都需要补单位，//传递的值带单位，不需要不单位 if(attr==='opacity')&#123;curEle.style.opacity=value;curEle.style.filter='alpha(opacity='+value*100%');&#125; !isNaN(value)&amp;&amp;!/^(zoom|lineHeight|zIndex|fontWeight)$/i.test(value)?value+='px':null;curEle['style'][attr]=value;&#125;setCss(box,'padding','20px');将3个方法封装在一个里面var css = function () &#123;var len = arguments.length,type = Object.prototype.toString.call(arguments[1]),fn = getCss;len &gt;= 3 ? fn = setCss : (len === 2 &amp;&amp; type === '[object Object]' ? fn = setGroupCss : null);return fn.apply(this, arguments);&#125;; children 不管在什么浏览器中，都可以获得当前元素的子节点,（元素节点）但在IE6-8下，也会将注释节点获取到，因此有所差别 function children(curEle)&#123;&#125; 编程常用方法：假设法 排除法 JS中的动画 1、步长偿固定，完成时间不固定2、固定时间动画 function linear(t, b, c, d) &#123;return t / d * c + b;&#125;var oBox = document.getElementById('box');var time = 0,//已经运动的时间duration = 1000,//总时间begin = utils.css(oBox, 'left'),//左边距target = utils.winBox('clientWidth') - oBox.offsetWidth,//目的地change = target - begin;//总共需要走的距离var timer = setInterval(function () &#123;time += 17;if (time &gt;= duration) &#123;utils.css(oBox, 'left', target);clearInterval(timer);return;&#125;var curL = linear(time, begin, change, duration);utils.css(oBox, 'left', curL);&#125;, 17); 图片懒加载原理：1、IMG标签的SRC不存放图片的地址(如果存放真实的地址,页面一加载图片肯定就加载出来了),我们把真实图片的地址存储在当前IMG标签的自定义属性上(DATA-IMG)2、为了保证当前图片没有真实地址的时候,浏览器中不会出现叉叉或者出现ALT中的内容,我们一般都会把图片先隐藏(display:none opacity:0…)，等到后期把真实图片加载出来，在让当前图片展示3、看不到真实图片了，我们最好给一个占位图片（占位图：要求一定要很小,最好是1KB）：我们在IMG外面包一层DIV盒子,把占位图赋值给当前盒子的背景图片来处理 =&gt;开始IMG不显示,展示的是默认的背景图,当IMG真实地址加载完成后,我们让IMG显示,此时真实图片会覆盖住背景图]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础知识（七）正则]]></title>
    <url>%2Fposts%2Feda90d92.html</url>
    <content type="text"><![CDATA[正则正则的基础知识什么是正则？ 正则就是一个规则，用来处理字符串的规则1、正则匹配 编写一个规则，验证某个字符串是否匹配这个规则，用test方法 2、正则捕获 编写一个规则，在一个字符串中，把符合规则的内容都获取到，使用方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则 var reg=/^$/;//两个斜杠之间包含的内容就是正则，两个斜杠之间的全部内容都是元字符 正则的元字符和修饰符 任何一个正则都是由元字符和修饰符组成的 修饰符 g(global):全局匹配 i(ignore):忽略大小写匹配 m(mutiline)：多行匹配 元字符[量词元字符] +：让前面的元字符出现1到多次 ？：出现0到1次 *：出现0到多次 {n}:出现n次 {n,}:出现n到多次 {n,m}:出现n到m次 [特殊意义的元字符]-\ ：转义字符-.：除了\n（换行符）以外的任意字符-\d：匹配一个0-9的任意字符 \D ：匹配一个非0-9的任意字符 \w ：匹配一个[0-9a-zA-Z_]之间的任意字符 \s ：匹配一个任意空白符 \b ：匹配一个边界符(单词的左右，-的左右两边) x|y：匹配两者中的其中一个 [a-z] ：匹配a-z中的任意一个字符 [^a-z] ：匹配非a-z中的任意一个字符 [xyz] ：匹配xyz中的其中一个 [^xyz]：匹配除了xyz以外的任意字符 ()：正则小分组 ^：以某一个元字符开始 $ ：以某一个元字符结束 ？： 只匹配不捕获 ？=：正向预查 ？！ ：负向预查 var reg=/^\d$/; //说明以数字开头，以数字结尾 ，且只包含一个数字 var reg=/^2.3$/;//.代表除了\n以外的任意字符 reg.test(2.3); true var reg=/^18|19$/;// x|y的情况// 18或19// 以1开头以9结尾，中间是8或1// 以18开头或以19结尾//var reg=/^（18|19）$/;//18或19 //（）正则里的分组，大正则里的小分组，我们可以使用它改变默认的优先级//此时只有18或者19符合规则 （） （）正则里的分组，大正则里的小分组，我们可以使用它变默认的优先级 小分组还有第二个作用：分组引用 小分组第三个作用： 分组捕获 分组引用：\1 表示出现和第1个分组一模一样的字符 var reg=/^([a-z])([a-z])\2(a-z)$/;// 类似于food week feel oppo等都符合该正则 [ ] [xyz] [^xyz] [^a-z]var reg=/^[a-zA-Z0-9_]$/;//等同于\w[ ]中出现的元字符，一般都代表本身的含义var reg=/^[.?+]$/里面的.代表.本身//需求类的命名规则：数字字母下划线 _，（-不能作为开头）var reg=/^\w[\w-]*$///不要让-出现在中间就可代表其本身的含义，出现在中间表示范围链接符 var reg=/^[18-65]$/代表的意思：1或8~6或5中的任意一个字符 ，中括号出现的18不代表数字18而是1或者8，当前正则非法18-65岁份三阶段18~19 (18|19)20~59([2-5]\d)60~65(6[0-5]) 验证是否为有效数字 可能正数，可能是负数整数或小数只要出现小数点，后面至少出现一位小数点前必须有数字var reg=/^-?(\d|([1-9]\d+)(\.\d+)?$/ 电话号码 var reg=/^1\d&#123;10&#125;$/ 中文姓名 /^[\u4E00-\u9FA5]$/ :中文汉字的正则var reg = /^[\u4E00-\u9FA5]&#123;2,10&#125;(·[\u4E00-\u9FA5]&#123;2,10&#125;)?$/;尼古拉斯·王武 邮箱 reg=/^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/分析需求： * 以数字字母下划线开头 * @前面可以是 数字、字母、下划线、-、. 这些符号 * 不能把 -和. 连续出现，出现一次后面必须跟数字字母下划线 * * @后面的部分支持 * 企业邮箱* .com.cn 多域名情况 *///这样写不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面的每一个小分组也可以分别捕获到"分组捕获" 身份证号 var reg=/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(X|\d)$/ 正则捕获 把当前字符串中的符合规则的字符捕获到RegExp.prototype.exec实现正则捕获的方法当我们执行reg.exec(str)的时候， 1、先去验证当前字符串和正则是否匹配，如果不匹配则返回结果null； 2、如果匹配，从字符串最左边开始，向右查找匹配内容，并把匹配内容返回 exec捕获到的结果的格式：获取的是一个数组数组中的第一项是当前本次大正则匹配的结果index:记录了本次捕获到结果的起始的索引input：当前正则操作的原始字符串如果当前正则当中有分组，获取的数组中，从第二项开始，都是每个小分组执行一次exec只能把符合正则规则的一个内容捕捉到，若果还有其他符合规则的， 需要再次执行exec才有可能捕获到； 正则捕获的懒惰性正则为什么会存在懒惰性 正则本身有一个属性：lastIndex（下一次正则在字符串匹配查找时的开始索引）默认值：0，从字符串的第一个字符开始查找匹配的内容默认不管执行多少次exec，正则的lastIndex值都不会变，也就是还是从第一个字符开始查找并且当我们手动改变last Index的值时，不会起任何作用由此导致：执行一次exec捕获到第一个符合规定的内容，第二次执行exec，捕获到的依然是第一个匹配内容，后面的无论执行多少次都捕获不到 解决正则的懒惰性 在正则的末尾加修饰符g(全局匹配)加了修饰符g，每次exec结束后，浏览器会默认把lastIndex的值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容了 var reg=/\d+/g;//开启全局匹配 exec有自己的局限性，执行一次exec只能捕获到一个结果，如果想要全部捕获到，就要执行多次，下面封装的myExecAll方法，可以将正则匹配的全部内容捕获到 RegExp.prototype.myExecAll=function()&#123;//this 是当前需要处理的正则//str是当前需要处理的字符串var str=agruments[0]||'';var result=[];//首先判断是否加了全局修饰符G，如果没有加，我们直接将第一次的结果返回即可if(!this.global)&#123; return this.exec(str);&#125;var ary=this.exec(str);while (ary)&#123;//(等同于ary!==null:可以捕获到内容，我们继续下一次捕获 result.push(ary[0]);//第一项为匹配到的结果 ary=this.exec(str);//继续执行下一次捕获&#125;return result;&#125;； 使用字符串中的match实现捕获 使用字符串match捕获， 如果正则加了g,会捕获到所有匹配结果 如果不加g,则只会捕获到第一个匹配结果 match的局限性 在加了修饰符g的情况下，·执行match只会把大正则匹配的结果捕获到，对于小分组里的匹配结果会自动忽略· 使用test实现捕获不管是正则的匹配还是捕获，在处理的时候是没有区别的，从字符串里的第一个字符开始查找符合规则的字符，如果可以找到，则返回true，exec捕获返回捕获的内容，如果没有找到，test返回false，exec捕获返回null 如果正则设置了修饰符g，不管是使用test还是exec的任何方法，都会改变lastIndex值，（下一次查找是基于上一次匹配结果向后查找的） var str='my name is &#123;0&#125;~~';svar reg=/\&#123;(\d+)\&#125;/g;if(reg.test(str))&#123;//-&gt;lastIndex=0console.log(reg.exec(str));//-&gt;null lastIndex值被修改，向后查找，无匹配&#125; test不仅可以找到匹配的内容，也肯能将匹配的内容获取 console.log(RegExp.$1);//获取当前匹配内容的第1个小分组; 所有支持正则的方法，都可以实现字符串的捕获（一般都是字符串方法） 字符串中常见的支持正则的方法 match split var str=’name=”珠峰”&amp;age=8’;str.split(/(&amp;|=)/); //使用split进行字符串进行拆分的时候，如果正则包含小分组，会把小分组的内容捕获到，放在最后的数组中//本案例()只是为了改变优先级，但我们只想匹配不想捕获分组里的内容，?:可以解决str.split(/?:(&amp;|=)/);// 这样浏览器就不会把小分组的内容捕获到；要计算是第几个分组，从左到右数( =&gt;半括号即可replace 字符串中原有字符的替换str.replace(old,new) var str='珠峰2011珠峰1021';str=str.replace('珠峰','珠峰培训');str.replace(/珠峰/g,'珠峰培训'); 在不使用正则的情况下，执行一次replace只能替换一个原有字符，第二次执行replace，依旧是从第一个字符开始查找，类似于正则的懒惰性 工作中，replace都是和正则一起搭配使用replace原理： 当replace方法执行，第一项传递一个正则 正则不加g,把当前第一个字符串中和正则匹配的内容捕获到，替换成新字符 正则加g,把当前所有和正则匹配的内容都捕获到，并替换成新字符 当replace执行，第二次参数传递的是一个函数（回调函数） 首先用正则在字符串中进行匹配，匹配到一个符合规则的，就把传递的函数执行一次 不仅执行这个函数，还把正则本次捕获的结果（同执行exec捕获的结果,包含小分组）当做实参传递给这个函数（这样就可以在函数中获得这些值，这些值就是正则每一次捕获的结果） 正则捕获方法统计 方法名 不加g 加g exec 懒惰性，只能到捕获第一个匹配值包括小分组 多次捕获可得所有匹配字符，包括小分组 match 懒惰性 同上 一次捕获到所有匹配字符，但不能匹配到小分组 test 懒惰性同上 多次捕获可得全部内容，每执行一次test，就console.log(RegExp.$1)，可得当前匹配字符 replace 懒惰性，只替换一个 全部替换 正则案例=&gt;单词首字母大写 var str='my name is zhu-feng-pei-xun,i am 8 years old,i am qian duan pei xun no1!';//先把混淆边界符的-替换为下划线 str=str.replace(/-/g,_);//通过边界符匹配到每个单词str=str.replace(/\b(\w)(\w*)\b/g,function()&#123; console.log(agruments); return agruments[1].toUpperCase()+agruments[2];&#125;)str=str.replace(/_/g,-); var str='2017-11-07 16:30';//改写成2017年11月07日16时30分//replace 模板匹配（） var template='&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒';var reg=/\d+/g;var ary=str.match(reg)var str='2017-11-07 16:30';//先将str的有效数字匹配出来，得到一个数组（match）//其次 将template中的&#123;0&#125;与之数组对应索引替换（/\&#123;(\d)\&#125;）;var template=template.replace(（/\&#123;(\d)\&#125;）,function()&#123; var index=arguments[1];//有多少个匹配的字符串，函数就会被执行多少次，这是每次匹配的小分组，即0/1/2... var value=ary[index];//将数组中对应索引的值拿出来 return value;&#125;) 正则创建方式字面量方式 var reg=/\d+/img; 构造函数创建 new RegExp('元字符'，'修饰符') var reg= new RegExp('\\d+'，'g');//将一个\换成\\才是转义字符的意思，''里面放的都是字符串 构造函数可以动态加入一个变量的值 问号传参（面试题）let url = 'http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e';//实现方法String.prototype.myQueryURLParameter = function myQueryURLParameter() &#123; let reg = /[?&amp;]([^?&amp;=]+)(?:=([^?&amp;=]*))?/g, obj = &#123;&#125;; this.replace(reg, (...arg) =&gt; &#123; let [, key, value] = arg; obj[key] = value; &#125;) return obj;&#125;;//方法调用let result = url.myQueryURLParameter();=》&#123; a: '1', b: '2', c: '', d: 'xxx', e: undefined &#125;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（六）关于面向对象的理解]]></title>
    <url>%2Fposts%2F2801c46e.html</url>
    <content type="text"><![CDATA[关于面向对象的理解(构造函数、原型链)OOP(面向对象编程思想) 它是一种编程思想，让我们基于类和实例的概念来编程开发和学习。 单例模式单例设计模式是一种把对象数据类型实现把描述同一件事物的属性或者特征归纳汇总在一起，以此避免全局变量冲突问题的方式和思想。把描述同一件事务的属性或者方法存放在某一个命名空间下，多个命名空间中的属性和方法是互不干扰的。 //=&gt;单例模式//1、singleton不仅仅是对象名了，在单例模式中，singleton称之为 “命名空间(nameSpace)”var singleton=&#123; xxx:xxx, ...&#125;; var singleton=&#123; nameSpace1:&#123; xxx:xxx, ... &#125;, nameSpace2:&#123; xxx:xxx, ... &#125; ...&#125;;使用单例模式实现模块化开发模块化开发：把一个复杂页面按照具体功能划分成几大块，然后由不同的人分别去开发，这种模块划分的思想就是模块化开发功能。//=&gt;项目主管（开发人员）：公共模块 var utils=&#123; trim:function()&#123;&#125;&#125;; //=&gt;李雷：搜索模块var searchModel=&#123; submit:function()&#123; utils.trim(); &#125;, ...&#125;; //=&gt;韩梅梅：天气模块var weatherModel=&#123; setWeather:function()&#123;&#125;, ...&#125;;//=&gt;小红：频道模块var channelModel=&#123; show:function()&#123; //=&gt;在当前的命名空间下调取其它命名空间的方法：指定好对应的命名空间名字即可，使用 [NameSpace].[property] 就可以操作了 searchModel.submit(); //=&gt;调取本模块中的一些方法，可以直接使用THIS处理即可：此方法中的THIS一般都是当前模块的命名空间 this.setChannel(); &#125;, setChannel:function()&#123;&#125;, ... &#125;; 高级单例模式基于JS高阶编程技巧惰性思想，来实现的单例模式，并且可以把一些常用的设计模式（如：命令模式、发布订阅模式、promise设计模式等）融合进来，最后清晰的规划我们的业务逻辑代码，方便后期二次开发和维护，这种设计思想综合体就是高级单例模式，也是最常用的。 var serchModel=(function()&#123; function submit()&#123; &#125; return &#123; init:function()&#123; this.submit(); &#125; &#125; &#125;)(); searchModel.init(); 对象、类、实例对象：万物皆对象类：对象的具体细分（按照属性或特性细分的一些类别）实例：某一个类中的具体事物 JS常用的内置类数据类型的类Number：每个数字或者NaN是它的一个实例String：字符串类Boolean：布尔类NullUndefined：浏览器屏蔽了我们操作null和udnefined这个类Object：对象类，每个对象数据类型都是它的实例• Array：数组类• RegExp：正则类• Date：日期类Function：函数类，每个函数都是它的一个实例元素对象或者元素集合的类HTMLCollection：元素集合类• getElementsByTagName()• getElementsByClassName()• querySelectorAllNodeList：节点集合类• childNodes• getElementsByName()HTMLDivElementHTMLElementElement(标签类)Node(节点类，Element只是其中的一个元素节点) 为什么getElementById的上下文只能是document？(即getElementById为什么只能通过document来调用)？因为只有在Document这个类上才有getElementById这个方法，其他类上(如：HTMLDivElement类)没有getElementById这个方法，而document是HTMLDocument这个类的一个实例,能通过document.proto.proto找到Document这个类的原型上公有的getElementById方法。 基于面向对象创建数据创建方式：两种1.字面量创建方式• var obj={}；2.实例创建方式（构造函数方式）• var obj=new Array();如果传递的参数只是一个数值 1、对于引用数据类型来说，两种创建方式是大致相同的，只不过，两种方法创建的语法不同。两种创建方式在核心意义上没有差别，都是创建Array这个类的一个实例，但是在语法上是有区别的 2、构造函数创建方式new Array(10)：创建一个长度为10的数组,数组中的每一项都是空new Array(‘10’)：如果只传递一个实参，并且实参不是数字，相当于把当前值作为数组的第一项存储进来new Array(10,20,30)：如果传递多个实参，不是设置长度，而是把传递的内容当做数组中的每一项存储起来 2、对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象，数据类型值也是标准的对象数据类型，也是标准的内置类的实例；对于字面量方式创建出来的结果是基本数据类型的值，不是严格的实例，但是由于JS的松散特点，导致了可以使用 内置类.prototype上提供的方法； 构造函数设计模式使用构造函数方式，主要是为了创建类和实例的，也就是基于面向对象思想来实现一些需求在JS中，当我们使用new xxx()执行函数的时候，此时的函数就不是普通的函数了，而是变为一个类，返回的结果叫做当前类的实例，我们这种new xxx执行的方式称之为构造函数设计模式 function fn()&#123; &#125;new fn();//new fn()是fn的一个实例 构造函数执行时new都干了些什么？在new Fn()，执行的时候，是先把函数执行了，后面的Fn()先执行，形成一个私有作用域，形参赋值变量提升，在变量提升完了之后，new操作符才起了作用，此时，浏览器开始创建一个新的对象，让Fn中的this指向这个新创建的对象（实例），然后让这个对象的proto指向Fn.prototype，然后JS代码才开始继续往下执行，开始往类中添加每个实例私有的属性和方法。JS代码执行完成后，会默认返回当前创建的这个对象。 普通函数执行与构造函数执行的区别 在代码从上而下执行之前，构造函数有特殊的操作：浏览器会在当前的作用域中默认创建一个对象数据类型的值，并且会让当前函数中的this指向创建的这个对象。然后JS代码再执行， 代码执行完成后，即使函数中没有写return，在构造函数模式中：浏览器会默认的把创建的对象返回到函数外面 总结： 构造函数执行期间，既具备函数执行的一面，也同时具备自己独有的操作：在构造函数执行期间，浏览器会默认创建一个对象，这个对象就是当前这个构造函数(类)实例，函数执行完成后，浏览器会默认的把这个实例返回。所以new Fn()执行，Fn是一个类，返回的结果就是Fn这个类的一个实例 构造函数执行后面的‘()’问题构造函数执行如果不需要传递参数，函数后面的()可省略，如new Fn()可写为new Fn；注意：• 如果要在new Fn之后直接调用实例的方法，则必须要加小括号，即必须写成new Fn().方法名 构造函数模式的返回值问题构造函数模式中默认返回值是当前的实例，如果有return,返回分2种情况：1、return 后面是一个基本数据类型的值，当前实例是不变的，例如return 100；我们的返回值还是当前类的实例；2、return 后面是一个引用数据类型的值(window除外)，当前实例会被返回的值给替换掉例如return {name:”李雷”}我们的返回值就不再是当前类的实例了，而是对象 {name:”李雷”}； A instanceof B 检测某一个实例是否属于这个类, 判断A实例是否属于B类 hasOwnProperty VS inin：用来检测当前这个属性是否隶属于对象（不管是对象私有的还是公有的属性，只要有返回的就是true） hasOwnProperty：用来检测当前这个属性是否是对象的私有属性（不仅要是对象的属性，而且需要是私有的才可以） attr in object//检测attr是否是object的属性，不管是私有属性还是公有属性只要存在，用in来检测都是truea.hasOwnProperty(attr)//attr是否是A实例的私有属性 原型链模式基于构造函数模式的原型链模式解决了方法或者属性公有的问题，把实例之间公有的属性和方法写在当前类的prototype属性上； 每一个函数数据类型都有一个天生自带的属性：prototype（原型），并且这个属性的属性值是一个对象数据类型的值，浏览器默认为其开辟一个堆内存； 在浏览器给prototype开辟的这个堆内存上浏览器天生给它加了一个constructor属性（构造函数），属性值是当前函数（类）本身； 每一个对象数据类型(普通对象、数组、正则、实例、protoype..)也天生自带一个属性:proto，属性值指向当前实例所属类的原型(prototype);(IE中屏蔽了对象的proto属性，但是确实有，只是不让我们使用而已) Object是JS中所有对象数据类型的基类（最顶层的类）； 原型链模式中的this分两种情况原型模式中的this分两种情况： 在类中this.xxx=xxx;this-&gt;当前类的实例 原型链中提供的私有(公有)方法中的this问题： 总结：看执行的时候”.”前面是谁this就是谁。具体操作步骤如下 需要先确定this的指向（this） 把this替换成对应的的代码 按照原型链查找的机制，一步步的查找结果 重构原型让某个构造函数的原型指向自己开辟的堆内存，但是自己开辟的堆内存当中是没有constructor属性的，所以要往自己开辟的堆内存中添加constructor属性，属性值为当前构造函数本身； contrcutor:fn缺点：重构原型后，会导致之前添加的属性和方法都没有了，只能使用重构之后添加的属性和方法；注意：• 不要忘了重构之后要添加constructor属性指向当前构造函数；• 内置类的原型不能重构，浏览器不允许我们这么做； 类的继承、封装和多态 它是一种编程思想（Object Oriented Programming）,我们的编程和学习其实是按照类和实例来完成的 我们要学习类的继承、封装、多态 封装 把实现一个功能的代码封装在一个函数中，以后再要实现这个功能，只要执行函数方法即可，不需要重新编写代码低耦合高内聚减少页面代码冗余，提高代码利用率 多态一个类（函数）的多种形态：重载、重写 重载 后台JAVA等编程语言中，对于重载的概念：方法名相同，参数名不同，叫做方法的重载JS中没有类似于后台严格意义的重载，JS中，如果方法名相同了，最后只能保留一个（和实参没有关系）JS中的重载：同一个方法，通过传递实参的不同，（arguments）我们完成不同的功能，我们把这个也可以理解为重载 function sum(num1,num2)&#123;return num1+num2;&#125;function sum()&#123;var ary=[].slice.call(arguments);return&#125;//只会执行后面那个sum 重写 不管是后台语言还是JS，都有重写，子类重写父类的方法； 继承 原理：子类继承父类的中的一些属性和方法 原型继承 让子类的原型指向父类的实例；child.prototype=new parent(); 我们首先让子类的原型指向父类的实例，然后在向子类原型上扩展方法，防止提前增加方法，等原型重新指向后，之前在子类原型上扩展的方法都没用了（子类原型已经指向新的空间地址了）； 让子类原型重新指向父类实例，子类原型上的原有constructor就没了，为了保证构造函数的完整性，我们需要重新手动设置constructor: child.protype.constructor.call(child) 原理 原型继承并不是把父类的属性和方法copy一份给子类，而是给子类和父类之间搭建一个连接的桥梁，以后子类或者子类的实例，可以通过原型链的查找机制，找到父类原型的方法，从而调取这些方法。 特征 子类不仅可以继承父类原型上的公有属性方法，也可以继承父类提供给实例的私有属性和方法，并把其放在子类的公有属性和方法上。 call继承（继承私有的） 原理在子类的构造体中，把父类做普通方法执行，让父类方法中的this指向子类实例特点：把父类 构造体中的私有属性和方法，原封不动复制了一份给子类实例（继承完成后，子类和父类是没有关系的）注意我们一般把call放在第一行，就是创建子类实例的时候，首先继承，然后在给实例赋值自己私有的（好处：自己可以把继承的结果替换掉） function A()&#123; this.x=100;&#125;function B()&#123;//一般都把call继承放在子类函数体中的第一行,这样做的好处就是子类私有的可以替换掉继承过来的结果； A.call(this); this.y=200&#125; 寄生组合式继承 Object.create（[obj]）:创建一个空对象，把obj作为新对象的原型（继承公有）Object.create不兼容 var obj=&#123;name:'李雷'&#125;;var newObj=Object.create(obj);newObj.__proto__===obj; child.protype= Object.create(parent.protorype); 利用Object.create创建一个的空对象； 该空对象指向parent.protorype； 将该对象的地址赋值给child.protype，从而导致child和child的实例都可以通过原型链找到parent的原型； 该方法只能继承parent的公有方法和属性 自己实现类似于Object.create的方法 Object.myCreate=function myCreate()&#123;var Fn = new Function();Fn.prototype = obj; return new Fn()&#125; ES6中的类及继承class Fn &#123;//constructor就是当前函数本身=Fnconstructor()&#123; this.x='xxx';//给当前实例增加私有属性 .........&#125;//增加公有属性，相当于在原型上添加xxX()&#123; ......... &#125;//这些属性方法都是将Fn当做普通对象设置的私有属性和方法，和实例没有任何关系 static xxx()&#123;.............&#125;&#125; class A &#123; constructor() &#123; this.x = 100; &#125; getX() &#123; console.log(this.x);&#125; &#125; class B extends A &#123; constructor() &#123; super();//=&gt;CALL继承 this.y = 200;&#125; getY() &#123; console.log(this.y);&#125;&#125;var b = new B();]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（五）数组汇总]]></title>
    <url>%2Fposts%2F4834a967.html</url>
    <content type="text"><![CDATA[数组详解给数组开头增加新内容的方法:unshift; ary.[0]=xxx; ary.splice(0,0,X); ary.slice(); //删除数组第一项： shift; splice(0,1); //给数组末尾增加： push; splice(ary.length,0,x) //数组克隆； slice(); 数组的基础结构 数组是对象类型属性名是数字 类数组类似数组 但不是数组（以下是类数组） 通过getElementsByTagName等获取的元素集合 函数中的实参集合argument 记忆数组要按以下几个维度1、方法的意义2、方法的形参3、方法的返回值4、通过此方法，原来数组是否发生改变） 数组的增加、修改、删除 var ary=[12,34,5]; ary.push('sd'); 增加 push向数组末尾增加新内容参数：一个到多个，任何数据都可以，用逗号隔开返回值：新增数组后的长度原有的数组变了 unshift向数组开头增加新内容参数：一个到多个，任何数据都可以，用逗号隔开返回值：新增数组后的长度其余同push 把数组当做一个普通的对象，使用对象键值对操作，给其设置新的属性 ary[length]=xxx;向数组末尾添加一个新内容 删除 pop功能：删除数组最后一项参数：无返回值：被删除的那一项原有数组改变了 shift删除数组第一项（后面每一项索引都要向前进一位）参数：无返回值：被删除那一项原有数组改变 delete 把数组当做普通的对象操作 delete ary[索引]删除指定那一项，其余的索引不会改变，数组的length也不变 ary.length–;删除数组最后一项 splice: 数组中内置的方法，可以实现数组的增加、修改、删除 splice实现删除 splice(n,m):从索引n开始删除m个 （m不写是删除到末尾，都不写是不删除）ary.splice(0)全部删除 返回值：被删除的内容（以一个新数组来保存被删除的内容） 原有数组改变 splice实现修改 splice(n,m,x):用x代替删除的内容 splice 实现增加 splice(n,0,x);在修改的基础上，一项都不删除，将x放在n的前面 splice(0,0,x) 向数组开头增加一个 splice(ary.length,0,x) 向数组末尾增加一项 splice(0,1);删除数组第一项 splice(ary.length-1,1) 删除数组最后一项 数组查询slice:数组查询 参数：slice(n,m)从索引n开始找到索引m处（不包含m） 返回值：把找到的部分以一个新数组返回 原来数组不改变 slice(n);从n开始找到末尾 slice(0)/slice();数组克隆，克隆一份和原来一模一样的新数组； slice支持负数，解析时按照：总长度+负数索引 来处理 将两个数组进行拼接concat 将多个数组拼接在一起 参数：要拼接的内容放在原数组后面 返回：拼接后新数组 原有数组不变 concat(),什么都没有拼接，相当于把原有的数组克隆； 数组克隆后出现的是一个新数组，与原有数组不相同，拷贝一份 把数组转化为字符串toString 实现把数组转化为字符串，一逗号分隔 参数：无参数 返回：转换后的字符串 原有数组不变 join 把数组按照指定的分隔符转换为字符串，和字符串中的split相对应 参数：指定连接符 返回值：转化后的字符串 原有数组不变 eval:把字符串变为JS表达式执行var total=eval(ary.join(‘+’)); 可实现数组求和；(一般项目中尽量不要用eval，性能较差) 实现数组中每一项的排序和排列reverse 把数组倒过来排列 参数 ：无 返回值：排序后的数组 原有数组改变 sort 实现数组排序 参数：无或回调函数； 返回值：排序后的 原有数组改变不传参的情况下，只能识别10以内的数字，多位数只识别第一位 ary.sort(function(a,b)&#123;return a-b; //升序 a-b&gt;0,a和b交换位置 return b-a;//降序 &#125;) 遍历数组中每一项的方法（ 以下方法在IE6-8都不支持） 方法名 是否操作原数组 方法返回结果 回调函数返回结果 filter（过滤） 否 过滤后的新数组 true/false,若true则放到新数组中 map（映射） 否 新数组 return后的值 find 否 返回找到的那一项，没有返回-1 返回true表示找到了，并停止 some 否 boolean 找true，找不到返回false every 否 boolean 找false，找不到返回true reduce 否 累积后的结果 返回的是下一次的prev 遍历数组或类数组、字符串每一项 for …of let arr = [2, 4, 1, 3]; for(let val of arr)&#123; console.log(val);//2，4，1，3&#125; find 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 let arr = [2, 4, 1, 3];res=arr.find((item)=&gt;&#123; return item&gt;1; &#125;) console.log(res);//2 findIndex find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 res=arr.find((item)=&gt;&#123; return item&gt;1; &#125;) console.log(res);//0=&gt;2的索引//find,findIndex都可以接受第二个参数，用来绑定回调函数的this对象 forEach（不支持return） 对数组中的每一项运行给定函数，没有返回值 let arr = [2, 4, 1, 3];arr.forEach(function (item, index) &#123; console.log(item);//2, 4, 1, 3&#125;) some 对数组中的每一项运行给定函数,只要一个条件成立，则返回true，条件都不成立才返回false; let arr = [2, 4, 1, 3];res = arr.some((item, index) =&gt; &#123; return item &gt; 3;&#125;)console.log(res);//true every 对数组中的每一项运行给定函数,条件都成立才返回true，只要有一个不成立，则返回false let arr = [2, 4, 1, 3];let res4 = arr.every((item, index) =&gt; &#123; return item &gt; 3;&#125;)console.log(res4);//false map()：（映射） 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 let ary = [2, 4, 1, 3];let res1=ary.map((item,index)=&gt;&#123; return item*2;&#125;);console.log(res1);//[4,8,2,6] 两个归并数组的方法:reduce,reduceRightreduce: 对数组中的每一项运行给定函数,计算数组每一项的累积值 prev:累积项，next当前项4个参数:[pre,next,index,ary] index：next的索引，ary：原数组 let arr = [2, 4, 1, 3];//实现每一项成员的累加let res5 = arr.reduce((prev, next) =&gt; &#123;//当没有第二个参数时，第一次prev是第一项，next是第二项，然后将他们的和赋值给prev，然后next值会等于第三项，prev就等于累加项，以此类推 return prev + next;&#125;,0)//0是给prev设置的默认值，可不加，当prev有默认值时，next从第一项开始console.log(res5);//10 eg2：let arr1= [&#123;price: 10, count: 2&#125;, &#123;price: 3, count: 6&#125;];//求总金额let res6 = arr.reduce((prev,next =&gt; &#123; return prev+next.price+next.count;&#125;), 0);//0是prev的默认值，此时next第一次就等于数组第一项;console.log(res6); reduceRight 使用 reduce()还是 reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。 filter （过滤） 对数组中的每一项运行给定函数, 筛选掉不符合条件的，返回匹配条件的 （返回的是一个新数组） let res2 = ary2.filter((item,index)=&gt;&#123; //删除功能时用的多 return item&lt;4&#125;)console.log(res2);//[2,1,3] 数组方法，验证数组中是否包含某一项indexOf/lastIndexOf :获取当前项在数组中第一次或最后一次出现位置的索引 数组中这两个方法在IE6-8下不兼容 字符串中的这两个方法兼容所有的浏览器 如果当前数组中没有这一项，则返回-1； 数组去重方法一： 遍历数组将数组的每一项和上一项比较，如果相同，则删除这一项（for） 方法二 遍历数组每次将数组的某一项和剩下的比较indexOf，如果相同，就删除该项，那么最后留下来的就没有重复项了； var ary=[2,7,8,9,45,8,78,4,2,7]; for(var i;i&lt;ary.length;i++)&#123; var ary2=ary[i]; ary3=ary.splice(i+1); if (ary3.indexOf(ary2)&gt;-1)&#123; ary.splice（i,1); i--; &#125; &#125; console.log(ary); 方式三（键值对的方式） 遍历数组每一项把每一项作为新对象的属性名和属性值存起来，例如当前项1，则[1,1];所以以后如果出现相同的属性名，则删除该项，typeOf obj.[xxx]===undefined;则该项不是重复值在原型上添加一个数组去重的方法 Array.prototype.myDistinct= function () &#123; let obj=&#123;&#125;; for (let i = 0; i &lt; this.length; i++) &#123; let item= this[i]; if(typeof obj[item]!=='undefined')&#123;//该项是重复的 this[i]=this[this.length-1];//用最后一项的值赋值给当前项， this.length--;//将最后一项删除（上一步已将最后一项保存至前面） i--; continue; &#125; obj[item]=item; &#125; obj=null; return this;&#125;; //另一种写法，不会改变原数组的相对顺序Array.prototype.myDistinct = function myDistinct() &#123; let obj = &#123;&#125;; for (let i = 0; i &lt; this.length; i++) &#123; let item = this[i]; if (obj[item] === this[i]) &#123; this.splice(i, 1); i--; continue; &#125; obj[item] = item; &#125; obj = null; return this;&#125;; 冒泡排序 原理：让数组中的当前项和后面的每一项进行比较，如果当前项大于后一项，我们让两者交换位置（小—大），就好像是气泡升到表面一样，因此得名总共比较：length-1次； function bubble(ary) &#123; //-&gt;外层循环控制的是比较的轮数： for (var i = 0; i &lt; ary.length - 1; i++) &#123; //-&gt;里层循环控制每一轮比较的次数. for (var k = 0; k &lt; ary.length - 1 - i; k++) &#123; //ary[k]:当前本次拿出来这一项 //ary[k+1]:当前项的后一项 if (ary[k] &gt; ary[k + 1]) &#123; //当前项比后一项大,我们让两者交换位置 var temp = ary[k]; ary[k] = ary[k + 1]; ary[k + 1] = temp;//可用结构赋值[ary[k],ary[k+1]]=[ary[k+1],ary[k]]; &#125; &#125; &#125; return ary;&#125; 每一轮从前到后两两比较，虽然不一定实现最后的排序效果，但是可以把当前最大的放在末尾具体比较的轮数：ary.length-1 数组有多长，我们只需要把总长度-1个数分别放在末尾，即可实现最后的排序对于数组[12, 13, 23, 14, 16, 11]；第一轮比较5次：一共六个，不需要和自己比较第二轮比较4次：一共六个，不用和自己比，也不用和第一轮放在末尾的那个最大值比第三轮比较3次每一轮比较的次数 ary.length-1(不用和自己比)-当前已经执行的轮数(执行一轮向末尾放一个最大值,这些值不需要再比较) 数组中的深度克隆首先使用JSON.Stringfy将数组转化为无意义的字符串，在使用JSON.parse将字符串转化为对象]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（四）String和Math中常用的方法]]></title>
    <url>%2Fposts%2Fe28a6795.html</url>
    <content type="text"><![CDATA[字符串中常用的方法 索引特点，从0开始length属性，字符串的长度如果指定索引不存在，会得到undefined真实项目中,我们经常操作字符串，此时我们需要掌握一些常用方法console.dir(String,prototype) charAt&amp;&amp;charCodaAt【兼容所有浏览器】 str.charAt();返回索引指定的字符,当指定索引不存在时返回””,当指定索引不存在时str[100]返回undefined;str.charCodeAt(),在charAt的基础上，获取指定位置字符的unicode编码Str.fromcharCode()通过unicoed码 得到原有字符 与charCodeAt相反 substr&amp;&amp;substring&amp;&amp;slice str.substr(n,m):从索引n开始，截取m个字符（第一个参数支持负数）str.subtring(n,m):从索引n开始，截取到索引m处，不包含m;（不支持负数）str.slice(n,m):从索引n开始，截取到索引m处，不包含m,(支持负数)； 当索引时负数时，是用字符串的总长度加上索引，在按照正数操作注意：如果只传递1个参数n，则从n截取到末尾如果索引超过最大值，则能截取多少是多少如果没有传参数，则相当于把整个字符串都截取了（字符串克隆） toUperCase&amp;&amp;toLowerCase toUperCase():把字母全部大写 str.toUpperCase()toLowerCase():把字母全部小写 indexOf&amp;&amp;lastIndexOf【兼容所有浏览器】 indexOf:获取当前字符首次出现的位置lastIndexOf:获取当前字符最后一次出现的位置 注意 如果当前字符串没有出现过，结果为-1；由此可以借用此方法来检查是否具有某元素 split Str.split:按照某一元素将字符串划分为几组,返回的是一个数组若不存在，则保持原来的Str支持正则 str='wedfg';str.split('d');//返回值是个数组(2) ["we", "fg"]0: "we"1: "fg"length: 2__proto__: Array(0) replace Str.replace:实现字符的替换Str.replace(a,b) //用b替换a执行一次只能替换一个，想替换多个的多次执行，真实项目中一般正和则一起使用； trim&amp;&amp;trimLeft&amp;&amp;trimRight Str.trimLeft:去除字符串左边兼容Str.trimRight:去除字符串右边空格Str.trim:去除字符串收尾空格 案例：queryURLParameter 获取地址栏中URL地址问号的传递参数值https://www.baidu.com/s?word=谷歌浏览器&amp;tn=93219212_hao_pg&amp;ie=utf-8问号后面就是我们传递的参数https://www.baidu.com/s?f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;word=小说&amp;tn=94076069_hao_pg 我们的目标：把问号传递的参数值给解析出来obj={word:’谷歌浏览器’,tn:93219212_hao_pg,ie:utf-8}&gt; function queryURLParameter(url)&#123;&gt; //=&gt;定义一个函数&gt; var quesIndex=url.indexOf('?');&gt; //获取？的位置&gt; var obj=&#123;&#125;;//定义一个空函数&gt; if(quesIndex===-1)&#123;&gt; //如果？不存在&gt; return obj;&gt; &#125;&gt; url=url.substr(quesIndex+1);&gt; //获取?后面的字符串&gt; var ary=url.split('&amp;');&gt; //用&amp;将字符串划分为数组&gt; for(var i=0;i&lt;ary.length;i++)&#123;&gt; var curAry=ary[i].split('=');&gt; //用=将字符串划分为长度为2的数组&gt; obj[curAry[0]]= curAry[1];&gt; //数组中第一个为属性，第二个为属性值&gt; return obj;&gt; &#125; &gt; &gt; &#125;&gt; Math中常用的方法 数学函数，但是他是对象类型Math 中为我们提供了很多常用操作数字的方法conlse.dir(Math)查看有很多方法 @[abs] Math.abs() 取绝对值 @[ceil/floor] Math.ceil() 向上取整Math.flloor() 向下取整 @[round] Math.round() 四舍五入 @[random] Math.random() 获取[0-1)之间的随机小数 //获取0-10之间的随机小数[0-10]Math.round(Math.random()*10)//获取[]3-15]的随机整数Math.round(Math.random())*12+3 注意规律 获取[n,m]之间的随机整数Math.round(Math.random())*(m-n)+n @[max/min] Matn.max:获取一组数据的最大值Math.min:获取一组数据的最小值 @[PI] Math,PI:获取圆周率 @[pow/sqrt] Math.pow:获取一个值的多少次幂Math.sqrt 开平方 案例：验证码基本功能实现 （结合Math和String） 一般是由后台处理，后台返回给客户端一张图片（图片中包含了验证码） （防止批量注册，前端容易被解析）验证码形式1、字母数字2、问答3、选择图片4、成语拼图5、图片拼图6、滑动拖拽 案例主要思想(获取4个字母和数字的组合) 获取文档中的元素(最后数字要放进去)定义一个空数组（用于存放随机获得的字符）定义一个取值区域（0-9，a-z,A-Z）共62个创建for循环获取一个0-61的随机整数（Math.round(Math.random*61)）利用这个整数获取该位置的字符，charAt()]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（三）数据类型汇总]]></title>
    <url>%2Fposts%2F4b7ffcca.html</url>
    <content type="text"><![CDATA[数据类型的转换汇总Number类型的转换把其他数据类型转换为number类型的方法 isNaN,Number,parsseIn,praseFloat在进行加减乘除运算时 '12px'=&gt;NaN; "主灯"=&gt;NaN[ ] /null /false / ' ' /=&gt;0&#123; &#125; /^$/ function()&#123;&#125;/ undefined /=&gt;NaN*注：引用类型在转化Number时，先转化为字符串（toString），再转变为数字(Nubber)。*parseFloat('');=&gt;NaN 与number不同 js中的数学运算 +、-、*、/、% 加减乘除取模除了加法有特殊性，其与运算遇到非数字类型时都要先转换为Number在进行运算 注：+有字符串拼接的作用(就是把其他值转化为 字符串再拼接)特殊：({ }).toString()==&gt;&#39;[object object ]&#39;//对象的{}要用（）包起来，否则报错，因为{}会被认为是代码块其余都直接转化为字符串 //加法的特殊性12+3+'2'=&gt;152'3'+4 =&gt;34null+'2' =&gt; 'null2'// 其余运算1-'1' =&gt;010*null =&gt;0 2+null+false+undefined+NaN+[1,2]+'珠 峰'+32+null =&gt;2+0=22+false =&gt;2+0=22+undefined =&gt;2+NaN=NaNNaN+NaN=NaNNaN+[1,2] =&gt;NaN+'1,2'=&gt;'NaN1,2'数组要先转化为字符串再转为数字再相加，但在转换为字符串时就会进行字符串的拼接'NaN1,2'+'珠峰'+3='NaN1,2珠峰3' 布尔类型的转换将其他数据转换为布尔类型(3种) Blooean / ! / !!判断语句除以下5种外，其余都为true0, null, ’ ‘, NaN, undefined, 注意 //对象和对象比较：比较的是空间地址,不是同一个空间，肯定是false[]==[] =&gt;false var a=&#123;&#125;;var b=a;a==b =&gt;true //(空间地址相同) //对象和数字比较，先调用toString方法[]==0 =&gt;true(&#123;&#125;)==NaN =&gt;false NaN和任何东西都不等，包括自己 //对象和字符串比较 (把两边都转化为字符串)[]=='' =&gt;true //对象和布尔：（把两边都转化为数字）[]==true =&gt;0==1 =&gt;false[]==false =&gt;true![]==false =&gt;true //![]把数组变为布尔再取反[]=true //字符串和数字：（把两边都转化为数字）//字符串和布尔： （把两边都转化为数字）//布尔和数字： （把两边都转化为数字） 规律，两个等于号比较时，左右两边的的数据类型不一样，浏览器会把两边类型都转为数字再比较（对象类型比较特殊，应该先转化为字符串，再转化为数字），但是null和undefined除外null和undefined和其他任何值都不相等 null==undefined =&gt;true null===undefined =&gt; false 规律，两个等于号比较时，两边类型相同时，直接比较，对象和对象比较的是空间地址；{}！={}，另外NaN和任何值都不等 JS中的数据类型检测汇总typeof 用来检测数据类型的运算符语法：typeof [value]，typeof后面跟的都是值返回结果：首先是个字符串，字符串中包含了我们需要检测的数据类型typeof null=’object’ &gt;虽然时基本数据类型，但是它属于空对象指针，检测结果是对象（局限性）并且不能细分出当前对象是数组还是正则（局限性）typeof 1&gt;1?1:2; =&gt;2 //优先级，先计算typeof 1;再比较， instanceof&amp;constructor instanceof:检测某一实例是否属于当前类constructor:构造函数使用instanceof检测某个值是否属于某个数据类型 的内之类，从而检测出它是否是这个类型的值，对对象类型的值有明显的区分 instanceof检测的弊端基本类型的值无法基于它检测var num=12; typeof num =&gt; ‘Number’num instanceof Number =&gt;falsevar num2=Number(12); typeof num2 =&gt; ‘object’num2 instanceof Number =&gt;true不管是哪一种方式创建基本类型值，都是自己所属类的实例，只不过类型不一样而已 instanceof 是基于原型链来检测的，是要当前类的实例在原型链上，最后返回的结果都是true,这也是instanceof的弊端 constructor获取要检测数据类型的constructor属性，判断它是否为某个数据类型的内置类来检测ary.constructor===Array; =&gt;true;ary.constructor=’AA’;ary.constructor===”AA’; =&gt;true=&gt;由于constructor的值可以被修改，所以检测结果非常不可靠 Object.prototype.toString.call([value]) 获取Object.prototype的toString方法，将方法中的this改为需要检测数据类型的值，然后执行在Number String Boolean Array……这些类的原型上都有toString方法，这个方法就是把本身的值转换为字符串的在Object这个类的原型上也有一个toString方法，但是这个方法是返回当前值的所属类详细信息，固定结构：[Object 所属的类型]使用该方法检测，不管你是什么值，我们都可以正正常检测出我们需要的结果 var obj=&#123;name:'珠峰'&#125;;obj.toString() //=&gt;"[object Object]" 调取的正是Object.prototype.toString /** obj.toString()* 首先执行Object.prototype.toString方法* 这个方法中的this就是我们操作的数据值obj* =&gt;总结：Object.prototype.toString执行的时候会返回当前方法中this的所属类信息** 也就是，我想知道谁的所属类信息，我们就把这个toString方法执行，并且让this变为我们检测的这个数据值，那么方法返回的结果就是当前检测这个值的所属类信息** Object.prototype.toString.call([value])* (&#123;&#125;).toString.call([value])*/ 因为alert弹出的都是字符串，所以会自动将（）中的内容调用toString,而对象类型调用toString,会出现[Object 所属的类型]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（二）函数专题]]></title>
    <url>%2Fposts%2F9f7bba47.html</url>
    <content type="text"><![CDATA[函数专题函数是指一段在一起的、可以做某一件事儿的代码。可以随时运行，可以重复使用。 创建函数function fn[函数名]()&#123;//=&gt;[函数体]//实现功能的具体JS代码&#125; 函数执行fn(); //=&gt;把创建的函数执行，而且这个函数可以执行很多次 每一次执行都相当于把函数体中实现功能的JS代码重复执行了一遍 在真实项目中，我们一般都会把实现一个具体功能的代码封装在函数中：1、如果当前这个功能需要在页面中执行多次，不封装成为函数，每一次想实现这个功能，都需要重新把代码写一遍；而封装在一个函数中，以后想实现这个功能，只需要把函数重新的执行即可，提高了开发效率；2、封装在一个函数中，页面中就基本上很难出现重复一样的代码了，减少了页面中代码的冗余度，提高了代码的重复利用率：低耦合高内聚 我们把以上的特点称为函数封装（OOP面向对象编程思想，需要我们掌握的就是类的继承、封装、多态） JS中函数的核心原理函数作为JS中引用数据类型中的一种，也是按照引用地址来操作的 1、函数执行首先会形成一个新的私有作用域，目的是为函数体中的代码提供一个执行的环境（而且这个环境是私有的） 2、把创建时候存储的代码字符串copy一份到自己的私有作用域中，然后把字符串转换为JS表达式，再然后依次自上而下执行目的：把之前存储的实现具体功能的JS代码执行 函数执行步骤 形参赋值 私有作用域中的变量提升 把之前创建时候存储的那些JS代码字符串，拿到私有作用域中，然后把它们变为JS表达式从上到下执行 私有作用域是否销毁的问题[根据栈内存是否被占用] 函数中的变量提升 在当前作用域中，js代码自上而下执行之前，浏览器首先会把所有带var/function关键字的进行提前的声明或者定义 声明(declare)：var num; 在当前作用域中吼一嗓子我有num这个名了定义(defined)：num=11; 把声明的名字赋一个值 带var关键字的只是提前的声明一下；带function关键字的在变量提升阶段把声明和定义都完成了； 变量提升详解对于带var和function关键字在与解释的时候操作不一样 var 在预解释的时候只是提前声明 function 在预解释时提前将声明和定义都完成了； 1、.预解释只发生在当前作用域中，开始只对window下的预解释，只有在函数执行时，才会对函数体中的进行预解释2、在if判断中，在预解释时，不管你条件是否成立，都要将带var的进行预解释（在老版本浏览器中，函数会被声明和定义，新版本浏览器中，函数只会被声明）3、var fn=function(){},在匿名函数值函数表达式中只对等号左边进行预解释，右边是值，不参加预解释 真实项目中，应用这个原理，我们创建函数的时候可以使用函数表达式的方式：1、因为只能对等号左边的进行提升，所以变量提升完成后，当前函数只是声明了，没有定义，想要执行函数只能放在赋值的代码之后执行（放在前面执行相当于让undefined执行，会报错的）2、这样让我们的代码逻辑更加严谨，以后想要知道一个执行的函数做了什么功能，只需要向上查找定义的部分即可（不会存在定义的代码在执行下面的情况） 4、function fn（n）{};(10); 自执行函数，在全局作用域下不进行预解释，在执行到该位置是定义和执行一起完成。5、当函数中有return时，return下面的函数不执行，但是会预解释；return后面跟的是返回值，所以不进行预解释。6、在预解释中，如果名字已经声明过了，后面就不重新声明，但会重新赋值； 如何区分私有变量和全局变量 在全局作用域下声明的都是全局变量 在私有作用域下声明的变量和函数的形参都是私有 变量 在私有作用域中，我们代码执行的时候遇到一个变量，首先我们要确定他是否为私有变量，如果是私有变量，那么他和外面没有任何关系；如果不是私有变量，（不加var）那么就要向他的上级查找，一直到window为止； 看当前函数在哪个作用域定义，那么他的上级作用于就是谁，跟在哪里运行没有关系 在全局作用域中带var和不带var的区别 1、带var的可以先进行预解释，所以在赋值前执行不会报错；不带var的没有进行预解释，在前面执行会报错；2、num=12;console.log(num2); ==&gt;12 //含义：相当于给window增加一个属性，属性名=num，属性值=12；3、var num=12;console.log(num); =&gt; 12// 首先给全局作用域增加一个全局变量，而且也为window增加一个属性 in ：判断变量是否存在当前作用域中； ++i和i++的区别都是自增1的意思在运算中不同点i++是先进行运算，再自增++i是先自增1再运算 作用域链函数执行形成一个私有的作用域（保护私有变量），进入到私有作用域中，首先变量提升（声明过的变量是私有的），接下来代码执行1、执行的时候遇到一个变量，如果这个变量是私有的，那么按照私有处理即可2、如果当前这个变量不是私有的，我们需要向它的上级作用域进行查找，上级如果也没有，则继续向上查找，一直找到window全局作用域为止，我们把这种查找机制叫做作用域链1）如果上级作用域有这个变量，我们当前操作的都是上级作用域中的变量（假如我们在当前作用域把值改了，相当于把上级作用域中的这个值给修改了）2）如果上级作用域中没有这个变量(找到window也没有)：变量 = 值 ：相当于给window设置了一个属性，以后再操作window下就有了alert(变量)：想要输出这个变量，但是此时是没有的，所以会报错 闭包函数执行会形成一个私有的作用域，让里面的私有变量和外界互不影响（相互不干扰、外面的无法直接获取里面的变量值），此时我们可以理解为私有作用域把私有变量保护起来的，我们把这种保护机制称之为闭包闭包的作用：保护：私有作用域把私有变量保护起来的保存：函数执行形成一个私有作用域，函数执行完成，形成的这个栈内存一般情况下都会自动释放但是还有其他情况：函数执行完成，当前私有作用域（栈内存）中的某一部分内容被栈内存以外的其它东西（变量/元素的事件）占用了，当前的栈内存就不能释放掉，也就形成了不销毁的私有作用域（里面的私有变量也不会销毁） 堆内存所有的引用数据类型，它们需要存储的内容都在堆内存中（相当于一个仓库，目的是存储信息） 对象会把键值对存储进来函数会把代码当做字符串存储进来释放：如果当前的堆内存被变量（或者函数以及元素事件等）占用了（占用了：堆内存地址赋值给变量了），此时的堆内存是有用的，不能销毁；我们想要手动释放堆内存，只需要让存储地址的变量等于其它值即可（最好等于null，null是空对象指针，本意就是不指向任何的堆内存）； 函数中的形参和实参形参：相当于函数提供的入口，需要用户执行函数的时候把需要的值传递进来，形参是个变量，用来存储和接收这些值 实参：用户执行的时候传递给形参的具体值 在非严格模式下：函数的形参和实参有一一对应的映射关系；当没有传递实参时，这种映射关系被切断，严格模式下不存在映射关系 //=&gt;随便求出两个数的和function sum(num1,num2)&#123;//=&gt;num1/num2就是形参变量(类似于var了一下)var total = num1+num2;total*=10;total=total.toFixed(2);console.log(total);&#125;sum(10,20);//-&gt;10/20是实参 num1=10 num2=20sum(10); //-&gt;num1=10 num2=undefined 定义了形参但是执行的时候没有传递实参，默认实参的值是undefined 此时num2与实参的映射关系被切断 function sum(num1, num2) &#123;//=&gt;如果有一个值没有传递的话,我们为了保证结果不是NaN,我们为其设置一个默认的值:0//=&gt;容错处理num1 = num1 || 0;num2 = num2 || 0;var total = num1 + num2;total *= 10;total = total.toFixed(2);console.log(total);&#125;sum(10, 20);//在非严格模式下，函数的两个形参可以重名，但是函数只会接收后一个参数传的值，如果只传入一个实参，则如下图所示： 在严格模式下，形参不可以重名 arguments实参集合 当我们不知道用户具体要传递几个值的时候（传递几个值都行），此时我们无法设置形参的个数；遇到此类需求，需要使用函数内置的实参集合：arguments1、arguments只有函数才有2、不管执行函数的时候是否传递实参，arguments天生就存在，没有传递实参ARG是个空的集合，传递了ARG中包含了所有传递的实参值3、不管是否设置了形参，ARG中始终存储了所有的实参信息 arguments是一个类数组集合1、以数字作为索引(属性名)，从零开始arguments[0] 第一个实参信息arguments[2] 第三个实参信息2、有一个length的属性，存储的是当前几个的长度（当前传递实参的个数）arguments.lengtharguments[‘length’]arguments.callee：存储的是当前函数本身arguments.callee.caller：存储的是当前函数在哪执行的（宿主函数），在全局作用域下执行的，结果是null 在非严格模式下，agruments与形参有一一对应的关系，但当没有传入实参时，这种映射关系会被切断，在严格模式下，agruments与形参的映射关系也被切断了"use strict"; //=&gt;在JS代码执行之前加入这句话：开启JS的严格模式function sum() &#123;console.log(arguments.callee);//=&gt;Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them&#125;sum(10, 20, '珠峰', &#123;name: '珠峰'&#125;);//=&gt;arguments.callee或者arguments.callee.caller一般真正项目中很少使用：因为在严格的JS模式下不允许我们使用这两个属性，然而现有项目大部分都是基于严格模式来的 JS中的返回值 return 返回值是函数提供的一个出口：我们如果想在外面使用函数私有的一些信息，那么就需要通过return，把这些信息返回出来供外面使用 - RETURN后面跟着的都是值（返回的都是值） 如果函数中没有写RETURN或者RETURN后面啥也没有,默认返回的结果就是undefined 在函数体中遇到RETURN后,RETURN后面的代码都不在执行了function sum() &#123;var total = null;return total;//=&gt;RETURN后面跟着的都是值（返回的都是值）：此处不是把TOTAL变量返回，而是把TOTAL存储的值返回而已 &lt;=&gt; RETURN 60;//return 1+1; //&lt;=&gt; RETURN 2;&#125;console.log(sum(10, 20, 30));//=&gt;sum：代表的是函数本身//=&gt;sum()：让函数先执行,代表的是当前函数返回的结果(RETURN 后面是啥,相当于函数返回的是啥) function sum() &#123;var total = null;for (var i = 0; i &lt; arguments.length; i++) &#123;var cur = Number(arguments[i]);!isNaN(cur) ? total += cur : null;&#125;return total;&#125;var total = sum(10, 20, 30);//=&gt;外面是全局下的TOTAL和函数中的TOTAL没有必然的联系console.log(total.toFixed(2)); JS中的匿名函数没有名字的函数 函数表达式:把一个函数作为值赋值给一个变量或某个事件（函数表达式右边的都是匿名函数） 自执行函数:创建函数和执行函数放在一起了，创建完成立马执行oBox.onclick = function()&#123;//=&gt;把一个没有名字的函数(有名字也无所谓)作为值赋值给一个变量或者一个元素的某个事件等：`函数表达式`&#125; ;(function(n)&#123;//=&gt;创建函数和执行函数放在一起了，创建。，完成立马执行：·自执行函数·//n形参 n=10&#125;)(10);//=&gt;以下都是自执行函数，符号只是控制语法规范，~function(n)&#123;&#125;(10);-function(n)&#123;&#125;(10);+function(n)&#123;&#125;(10);!function(n)&#123;&#125;(10); 函数的三种角色和call、apply、bind 第一种角色：普通函数栈内存(私有作用域)作用域链形参argumentsreturn 第二种角色：类类实例私有和公有属性prototypeproto 第三种角色：普通对象键值对操作 三种角色之间没有直接的关系function Fn()&#123;var name='珠峰培训';this.age=8;&#125;Fn.prototype.say=function()&#123;&#125;//原型上的方法Fn.eat=function()&#123;&#125;//普通函数的方法var f = new Fn(); 阿里超经典面试题 function Foo() &#123;getName = function () &#123;console.log(1);&#125;;return this;&#125;Foo.getName = function () &#123;console.log(2);&#125;;Foo.prototype.getName = function () &#123;console.log(3);&#125;;var getName = function () &#123;console.log(4);&#125;;function getName() &#123;console.log(5);&#125; Foo.getName(); //执行Foo.getName 输出2getName(); // 执行var getName 输出4Foo().getName();//执行function Foo()，（getName是公有属性，相当于给getName重新赋值） 输出1getName(); //由于上一轮的重新赋值，输出1new Foo.getName();//返回Foo.getName()的一个实例，输出2new Foo().getName();//先new Foo()，返回foo的一个实例，在执行实例.getName()，=》3；new new Foo().getName();// 先new Foo()，返回foo的一个实例，再返回this.getName（）的一个实例 ，3； call apply bind都是天生自带的方法(Function.prototype)，所有的函数都可以调取这三个方法 三个方法都是改变THIS指向的 call fn.call(context,para1,…)把fn方法立即执行，并且让fn方法中的this变为context,而para1…都是给fn传递的实参 //=&gt;非严格模式function fn(num1,num2)&#123;console.log(this);&#125;var obj=&#123;fn:fn&#125;;fn();//=&gt;this:windowobj.fn();//=&gt;this:objvar opp=&#123;&#125;;//opp.fn();//=&gt;报错:opp中没有fn这个属性fn.call(opp);//=&gt;this:opp num1&amp;&amp;num2都是undefinedfn.call(1,2);//=&gt;this:1 num1=2 num2=undefinedfn.call(opp,1,2);//=&gt;this:opp num1=1 num2=2//-&gt;CALL方法的几个特殊性fn.call();//=&gt;this:window num1&amp;&amp;num2都是undefinedfn.call(null);//=&gt;this:windowfn.call(undefined);//=&gt;this:window//=&gt;JS严格模式下"use strict";fn.call();//=&gt;this:undefinedfn.call(undefined);//=&gt;this:undefinedfn.call(null);//=&gt;this:null apply apply的语法和call基本一致，作用原理也基本一致，唯一的区别：apply把传递给函数的实参以数组形式存放（但是也相当于在给函数一个个的传递实参值） fn.call(null,10,20,30); fn.apply(null,[10,20,30]); //=&gt;传递给fn的时候也是一个个的传递进去的 bind 也是改变THIS的方法，它在IE6~8下不兼容；它和call(以及apply)改变this的原理不一样 fn.call(opp,10,20); //=&gt;把fn执行,让fn中的this变为opp,并且把10&amp;&amp;20分别传递给fnfn.bind(opp,10,20); //=&gt;预先让fn中的this指向opp,并且把10和20预先传递给fn,此时的fn没有被执行(只有当执行的时候this和实参才会起到应有的作用)//=&gt;需求：点击box这个盒子的时候，需要执行fn，并且让fn中的this指向oppoBox.onclick=fn; //=&gt;点击的时候执行了fn,但此时fn中的this是oBoxoBox.onclick=fn.call(opp); //=&gt;绑定事件的时候就已经把fn立即执行了(call本身就是立即执行函数),然后把fn执行的返回值绑定给事件oBox.onclick=fn.bind(opp);//=&gt;fn.bind(opp)：fn调取Function.prototype上的bind方法，执行这个方法返回了一个匿名函数/** function()&#123;* fn.call(opp);* &#125;*/oBox.onclick=function()&#123;//=&gt;this:oBoxfn.call(opp);&#125; 回调函数 凡是在函数执行的某一阶段需要完成某件不确定的事情，可以利用回到函数机制，把要处理的事情当做函数传进来，传进来的这个参数就是回调函数 我们可以在函数中根据需要随时使用回调函数 我们还可以给回调函数传递参数 我们还可以把回调函数中的this进行修改 我们还可以接收回调函数的返回值 回调函数的this指向回调函数中的this一般都是window（严格模式下是undefined）setTimeout&amp;&amp;setInterval默认执行主体都是window，（严格模式下也是同样的） forEach和map当传第二个参数时，会改变this指向，this会指向传递的第二个参数(some.filter,find,every这些方法的第二个参数都是改变this指向的) 我们一般在执行回调函数的时候，没有特意指定执行主体，所以默认一般都是window。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（一）数据类型基本介绍，检测数据类型端方法简介]]></title>
    <url>%2Fposts%2Fd035ffec.html</url>
    <content type="text"><![CDATA[基础知识 ECMAScript(ES)：规定了JS的一些基础核心的知识（变量、数据类型、语法规范、操作语句等）DOM：document object model 文档对象模型，里面提供了一些属性和方法，可以让我们操作页面中的元素BOM：browser object model 浏览器对象模型，里面提供了一些属性和方法，可以让我们操作浏览器 常用浏览器内核浏览器的内核是分为两个部分的，一是渲染引擎，另一个是JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎。 webkit内核（V8引擎） 谷歌 大部分移动端浏览器 国内大部分浏览器 360 QQ UC 猎豹 搜狗 NODE基于V8来渲染JS Gecko 火狐浏览器 Presto 欧朋浏览器 Trident IE浏览器 数据类型的分类和检测 Number String bloean null:空对象指针基础 undefined:未定义 function 函数类型 object对象数据类型: {}普通对象 数组 /$/ 正则 [对象数据类型:是把描述同一事物的属性和方法放在一个内存空间中，起到了分组的作用] 检测数据类型 typeof:检测数据类型的运算符 instanceof:检测某个实例是否属于这个类 constructor:获取当前实例的构造器 Object.prototype.toString.call:获取当前实例所属的类信息 typeof：结果返回的是一个字符串，字符串内包含的是数据类型 typeof 的局限性 typeof null 的检测结果不是‘null’ 而是’object’: 而null是基本数据类型 ，并不是object 使用typeof 无法具体区分出到底是数组还是正则或普通对象 Boolean 把其他类型转换为布尔类型 只有0，NaN,空字符串、null、undefined为false;其余都是true; ! 或者 !!的意义 ! ：先将数据类型转化为布尔值，再取反 !! ：两次取反相当于没有取反，只是把数据类型转化为布尔类型!null =&gt; true!!undefined =&gt;false Number[NaN] js中新增了一个数据类型：NaN（not a number 不是一个有效数字，但是属于number） typeof NaN =&gt;’number’ NaN!=NaN NaN和任何值都不等 [isNaN] isNaN:用来检测这个值是否是有效数字，如果不是，则为true,反之，则为false 当时使用isNaN检测时，（）中如果不是number类型： 基本数据类型：先将其他类型值转化为Number类型值再运算 对象数据类型：先将对其调用toString方法，再转化为Number类型值 [Number] 使用Number把字符串转换为数字的时候，空字符串是零，其它字符串中如果出现的字符代表纯数字可以转为正常的数字，如果出现了任何一个非有效数字的字符，最后的结果都是NaN 将引用类型转化数据类型时，先将其转化为字符串，后再转化为number; (&#123;name:'zxt'&#125;).toString() =&gt;"[object Object]"Number(undefined) =&gt;NaN[parseInt()] 将其他类型值转换number,和Number不同，提取规则：从左至右依次查找有效数字字符，直到遇见非有效字符为止(不管后面还有没数字)parseInt(‘12px’) =&gt;12parseInt(‘px1’) =&gt;NaN parseInt(‘122.3’) =&gt;122 [parseFloat()]与parseInt不同的是支持小数 parseFloat(‘12.34pxc’)= 12.34由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心 0.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996[toFixed()] 控制数字保留小数点后面几位 var num = parseFloat('width:12.5px'); //=&gt;NaNif(num==12.5)&#123; alert(12.5); &#125;else if(num==NaN)&#123;//=&gt; NaN!=NaN alert(NaN); &#125;else if(typeof num=='number')&#123;//=&gt; typeof NaN-&gt;'number' alert(0);//=&gt;'0' &#125;else&#123; alert('啥也不是!'); &#125; null 和 undefinednull: 没有,没有开辟内存空间undefined: 未定义“” : 空字符串，什么都没有，但是开辟了内存空间 null：什么都没有，但一般都是自己手动赋值的，后期再自己赋值unfefined：完全不在预期之内 Object对象是由0到多组键值对组成的，每一组之间用逗号分离 每一个对象数据类型，都是有0到多组的属性名和属性值组成的属性名：描述当前对象具备的某些特征（数字/字符串格式）属性值：具体特征的值（任何数据类型）操作一个对象的属性有2种方式obj[‘key’]obj.key(属性名是数字不可以使用这种方法) 创建对象 字面量方式：var obj={}构造函数方式：var obj=new Object(); 对象键值对的操作：增、删、改、查 var obj = {};obj.name = ‘zxt’;//=&gt;增加一个叫做NAME的属性,属性值是:’zxt’obj[‘name’] = 29;//=&gt;修改NAME对应的属性值：一个对象的属性名是不能重复的，之前没有这个属性，我们的操作是增加操作，之前有这个属性，当前操作就是在修改现有属性名的属性值obj.age = null; //=&gt;假删除：把属性值设置为空，但是属性名是存在的 &lt;=&gt; obj[‘age’] = null =&gt;获取age的属性值结果是nulldelete obj.age;//=&gt;真删除：把属性名和属性值彻底从对象中移除掉 =&gt;获取age的属性值结果是undefined获取一个对象某一个属性名对应的属性值，如果当前这个属性在对象中并不存在，获取的结果是undefined obj[name]和obj[‘name’]的区别 //-&gt; age：变量名，代表的是它存储的值//-&gt; ‘age’：常量，字符串的具体值var age = ‘name’;var obj = {name:’zhufeng’,age:8};console.log(obj.age); =&gt;8console.log(obj[‘age’]); =&gt;8console.log(obj[age]); =&gt; obj[age变量] =&gt;obj[‘name’] =&gt;获取name属性名的属性值 =&gt;’zhufeng’ Object.keys: Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的对象上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。可以用来判断对象是否为空：Object.keys(obj).length let obj = { 0 : “a”, 1 : “b”, 2 : “c”};console.log(Object.keys(obj));// [‘0’, ‘1’, ‘2’] 函数数据类型 函数数据类型也是按照引用地址来操作的 函数：具备一定功能的方法 基本数据类型和引用数据类型的区别 JS是运行在浏览器中的（内核引擎），浏览器会给JS提供一个赖以生存的环境，所以我们把这个环境叫做全局作用域 window(global是后台的) JS代码是自上而下依次执行的 基本数据类型是按值操作的：基本数据类型再赋值时，是直接把值赋值给变量即可 var a=12;var b=a; // b=12 把变量a存的值赋值给变量bb=13;alert(a); //a=12 引用数据类型是按空间地址（引用地址）来操作的： var n={name:’主动’}；1、先创建一个变量n;2.浏览器首先会开辟一个存储空间（内存空间），是把对象中需要存储的键值对分别存储在这个空间中，后期为了方便找到这个空间，浏览器会给空间设个地址（16进制）；3、把空间的地址赋值给变量;所以n存储的是一个引用地址，并不是一个具体的值 &amp;&amp;逻辑与||逻辑或 在条件判断中&amp;&amp;：所有都为真，才是真||：只要一个为真，就是真 在赋值操作中 (短路操作)||: a||b;看a的真假，a为真，则返回a的值，a为假，则返回b,不管b是什么&amp;&amp;：a&amp;&amp;b, a为假，则返回a的值，a为真，则返回b,不管b是什么真实项目中应用逻辑或实现默认值的设置操作 逻辑与的优先权高于逻辑或 JavaScript常用的操作语句 通过一系列的逻辑判断，来完成特定的事情for循环if循环:当在判断的操作中,很多条件都是符合的,执行完成第一个符合的条件后,后面的条件不管是否符合都不在处理了 for in 循环用来遍历（循环）对象键值对的, ‘循环数组中的每一项’, ‘条件？条件成立执行：条件不成执行；, 执行步骤： key存储的值都是字符串格式，key中存的是属性名在for in 循环遍历时，大部分浏览器都是先把对象中的键值对进行排序（整数数字在前，由小到大，其余按原来编写顺序排列）（小数算作字母，不算数字）for in循环会遍历对象原型上的方法itin [Tab] for in 循环快捷键 三元运算符 [‘条件？条件成立执行：条件不成执行；]是简单的if、else的另外一种写法如果某种情况并不需要做处理，我们可以用null,undefined,void 0占位即可某一情况执行多条操作，使用（）包起来，每一项处理的事情之间用逗号分隔在三元运算符中不能出现 break/continue/return会出现 SyntaxErrorr 语法错误 switch case 也是if else某种特定情况的简写，可以在switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。每一种case情况结束都需要加break，达到条件成立处理完成，跳出当前判断每一种case情况的比较都是使用===进行比较的：绝对相等 =：赋值，变量=值==：比较，值==值绝对比较，值=== 如果左右两边比较的值是相同类型的，那么直接比较内容是否一样即可；如果两边值的类型不一样，==和===是有区别的：===类型不一样，最后的结果就是false，更加的严谨==类型不一样，浏览器首先会默认的把类型转化为一样的，然后再比较内容，相对松散一些 for循环语句for(初始值;验证条件;步长累加){ 循环体} 设置初始值验证条件条件成立执行循环体，否则推出循环步长累加验证条件···············没有步长累加会陷入死循环 for循环与for in循环的区别：for in 循环可以遍历到原型上的公有属性，而for循环只能遍历私有的属性]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份非常完整的MySQL规范]]></title>
    <url>%2Fposts%2Ff4255724.html</url>
    <content type="text"><![CDATA[一、数据库命令规范 二、数据库基本设计规范 三、数据库字段设计规范 四、索引设计规范 五、常见索引列建议 六、如何选择索引列的顺序 七、避免建立冗余索引和重复索引 八、优先考虑覆盖索引 九、索引SET规范 十、数据库SQL开发规范 十一、数据库操作行为规范 一、数据库命令规范· 所有数据库对象名称必须使用小写字母并用下划线分割 · 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） · 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符 · 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀 · 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低） 二、数据库基本设计规范1、所有表必须使用Innodb存储引擎 没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好 2、数据库和表的字符集统一使用UTF8 兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效 3、所有表和字段都需要添加注释 使用comment从句添加表和列的备注 从一开始就进行数据字典的维护 4、尽量控制单表数据量的大小，建议控制在500万以内 500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小 5、谨慎使用MySQL分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据 6、尽量做到冷热数据分离，减小表的宽度 MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作） 7、禁止在表中建立预留字段 预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定 8、禁止在数据库中存储图片，文件等大的二进制数据 通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息 9、禁止在线上做数据库压力测试 10、禁止从开发环境，测试环境直接连接生成环境数据库 三、数据库字段设计规范1、优先选择符合存储需要的最小的数据类型 · 原因 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差 · 方法 1）将字符串转换成数字类型存储，如：将IP地址转换成整形数据。 mysql提供了两个方法来处理ip地址： inet_aton // 把ip转为无符号整型(4-8位)inet_ntoa // 把整型的ip转为地址 插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。 2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储 因为：无符号相对于有符号可以多出一倍的存储空间 SIGNED INT -2147483648~2147483647UNSIGNED INT 0~4294967295 VARCHAR(N)中的N代表的是字符数，而不是字节数 使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存 2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据 · 建议把BLOB或是TEXT列分离到单独的扩展表中 Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。 而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。 如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。 · TEXT或BLOB类型只能使用前缀索引 因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。 3、避免使用ENUM类型 · 修改ENUM值需要使用ALTER语句 · ENUM类型的ORDER BY操作效率低，需要额外操作 · 禁止使用数值作为ENUM的枚举值 4、尽可能把所有列定义为NOT NULL 原因： · 索引NULL列需要额外的空间来保存，所以要占用更多的空间； · 进行比较和计算时要对NULL值做特别的处理 5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。 TIMESTAMP 占用4字节和INT相同，但比INT可读性高 超出TIMESTAMP取值范围的使用DATETIME类型存储。 经常会有人用字符串存储日期型的数据（不正确的做法）： · 缺点1：无法用日期函数进行计算和比较 · 缺点2：用字符串存储日期要占用更多的空间 6、同财务相关的金额类数据必须使用decimal类型 · 非精准浮点：float,double · 精准浮点：decimal Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。 四、索引设计规范1、限制每张表上的索引数量，建议单张表索引不超过5个 索引并不是越多越好！索引可以提高效率同样可以降低效率。 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。 因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。 2、禁止给表中的每一列都建立单独的索引 5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好 3、每个Innodb表必须有个主键 Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。 每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。 主键建议使用自增ID值。 五、常见索引列建议· 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列 · 包含在ORDER BY、GROUP BY、DISTINCT中的字段 并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好 · 多表join的关联列 六、如何选择索引列的顺序建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 · 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）； · 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）； · 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。 七、避免建立冗余索引和重复索引因为这样会增加查询优化器生成执行计划的时间。 · 重复索引示例：primary key(id)、index(id)、unique index(id) · 冗余索引示例：index(a,b,c)、index(a,b)、index(a) 八、优先考虑覆盖索引对于频繁的查询优先考虑使用覆盖索引。 覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引 覆盖索引的好处： · 避免Innodb表进行索引的二次查询 Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息， 如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。 · 可以把随机IO变成顺序IO加快查询效率 由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。 九、索引SET规范尽量避免使用外键约束 · 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引； · 外键可用于保证数据的参照完整性，但建议在业务端实现； · 外键会影响父表和子表的写操作从而降低性能。 十、数据库SQL开发规范1、建议使用预编译语句进行数据库操作 预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。 2、避免数据类型的隐式转换 隐式转换会导致索引失效。如：select name,phone from customer where id = ‘111’; 3、充分利用表上已经存在的索引 · 避免使用双%号的查询条件。 如a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的） · 一个SQL只能利用到复合索引中的一列进行范围查询 如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。 使用left join或 not exists来优化not in操作 因为not in 也通常会使用索引失效。 4、数据库设计时，应该要对以后扩展进行考虑 5、程序连接不同的数据库使用不同的账号，进制跨库查询 · 为数据库迁移和分库分表留出余地 · 降低业务耦合度 · 避免权限过大而产生的安全风险 6、禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询 原因： · 消耗更多的CPU和IO以网络带宽资源 · 无法使用覆盖索引 · 可减少表结构变更带来的影响 7、禁止使用不含字段列表的INSERT语句 如：insert into values (‘a’,’b’,’c’); 应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’); 8、避免使用子查询，可以把子查询优化为join操作 通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。 子查询性能差的原因： · 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响； · 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大； · 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。 9、避免使用JOIN关联太多的表 对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。 在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。 如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。 10、减少同数据库的交互次数 数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 11、对应同一列进行or判断时，使用in代替or in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。 12、禁止使用order by rand() 进行随机排序 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式 13、WHERE从句中禁止对列进行函数转换和计算 对列进行函数转换或计算时会导致无法使用索引。 · 不推荐： where date(create_time)=&apos;20190101&apos; · 推荐： where create_time &gt;=&apos;20190101&apos; and create_time &lt;=&apos;20190102&apos; 14、在明显不会有重复值时使用UNION ALL而不是UNION · UNION会把两个结果集的所有数据放到临时表中后再进行去重操作 · UNION ALL不会再对结果集进行去重操作 15、拆分复杂的大SQL为多个小SQL · 大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL · MySQL：一个SQL只能使用一个CPU进行计算 · SQL拆分后可以通过并行执行来提高处理效率 十一、数据库操作行为规范1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作 · 大批量操作可能会造成严重的主从延迟 主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况 · binlog日志为row格式时会产生大量的日志 大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。 · 避免产生大事务操作 大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。 特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。 2、对于大表使用pt-online-schema-change修改表结构 · 避免大表修改产生的主从延迟 · 避免在对表字段进行修改时进行锁表 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。 pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。 把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。 把原来一个DDL操作，分解成多个小的批次进行。 3、禁止为程序使用的账号赋予super权限 当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。 4、对于程序连接数据库账号，遵循权限最小原则 程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀的程序员需要懂那些数学知识？]]></title>
    <url>%2Fposts%2Fdd6f5090.html</url>
    <content type="text"><![CDATA[安利一本书，专门讲程序员需要懂的数学。 一位科技博主Jeremy Kun花了4年时间，写成一本书《程序员数学入门》，在科技论坛Hack News引发热议。 这本书精简了大量数学内容，为程序员提供所需的基本数学知识。 书中主要内容有：多项式、集合、图论、微积分、线性代数、群论等。 好玩的不止这些，这位博主在个人网站中整理了很多数学知识，甚至做成了wiki的形式： https://jeremykun.com/primers/ 里面基本是程序员的大学数学课程内容：虽然没有高等数学（微积分），但是有抽象代数、离散数学、傅立叶分析、拓扑学等等。 这个网站叫做“站在数学和编程的十字路口”（Math ∩ Programming），所以当然不会只有数学课，还包括机器学习、图像生成、自然语言处理、加密学等计算机学方面的内容。 链接：https://www.zhihu.com/question/21425201/answer/615681300]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着9张思维导图学习Javascript]]></title>
    <url>%2Fposts%2Fd64e1f56.html</url>
    <content type="text"><![CDATA[学习的道路就是要不断的总结归纳，好记性不如烂笔头，so，下面将 po 出我收集的 9 张 javascript 相关的思维导图（非原创）。 JavaScript-Learn-MindMapping 思维导图小tips:思维导图又叫心智图，是表达发射性思维的有效的图形思维工具 ，它简单却又极其有效，是一种革命性的思维工具。思维导图运用图文并重的技巧，把各级主题的关系用相互隶属与相关的层级图表现出来，把主题关键词与图像、颜色等建立记忆链接，思维导图充分运用左右脑的机能，利用记忆、阅读、思维的规律，协助人们在科学与艺术、逻辑与想象之间平衡发展，从而开启人类大脑的无限潜能。思维导图因此具有人类思维的强大功能。 分别归类为： javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 文档对象模型DOM javascript正则表达式 能够认真看完就是一次对javascript的回顾与提升，可以很好的检验基础。 javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 文档对象模型DOM BOM浏览器对象模型 javascript正则表达式 是的，没有高深的知识，没有进阶的技巧。 只是，万丈高楼平地起；只是，千里之行始于足下；只是，千里长提溃于蚁穴。 能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享几个优质开源项目 | 电商类app，趣享 gif，研发助手DoraemonKit，github小程序]]></title>
    <url>%2Fposts%2Ff4e97b38.html</url>
    <content type="text"><![CDATA[非常方便的 github 小程序员 趣享 gif 开源版本 酷欧天气的Jetpack版本实现，采用了MVVM架构 充满设计感的电商类APP 滴滴开源的研发助手 非常方便的 github 小程序员经常想在手机上看一些最新的github项目，可以说这是我发现的最方便的小程序了。 GitHub Trending 是根据仓库的最近热门程度展示的，该小程序希望准确获取最近新出现的仓库集合，使用该小程序能够根据语言筛选，获取每天新出现的 Trending 仓库。 开源地址：https://github.com/ZhuPeng/mp-githubtrending 这个小程序已经上线了，可以扫码体验，相信会对你有帮助的 趣享 gif 开源版本这个相信就是老郭对外的开源版本了，相信不少同学早已体验过了，没有的话，可以在各大市场搜索“趣享 gif”体验一下，开源版本也是个非常棒的学习项目。 https://github.com/guolindev/giffun 老郭的MVVM项目酷欧天气的Jetpack版本实现，采用了MVVM架构。 功能比较少，不过老郭写代码一向非常注重代码风格，相信是一个非常值得学习的项目。项目使用语言是kotlin，应该也是为第一行代码第三版做准备。 分享个有意思的事情，之前我和老郭吹逼，我说去 github 搜索 wanandroid有几百个开源版本，一脸自豪… 然后老郭上了个，搜索“cool weather”的截图： 项目架构： https://github.com/guolindev/coolweatherjetpack* 充满设计感的电商类APP 项目涉及的技术要点：1. 组件化+Kotlin结合开发，如何管理第三方依赖 2. BaseActivity和BaseFragment等基类及通用布局的封装 3. MVP+Dagger 2+Retrofit+Rxjava（包括了多个BaseUrl请求的场景处理） 4. 组件化开发下ARouter的运用 5. EventBus的使用 6. Google原生数据库Room的使用 7. Glide的使用（封装加载图片工具类GlideUtils，圆形、圆角图片、背景图片加载等） 8. Kotlin下使用ButterKnife 9. CommonAdapter万能适配器（包括多类型布局的运用—首页的逛模块和视频分类详情都有运用） 10. GSYVideoPlayer实现视频播放（包括全屏切换功能） 11. 5.0新特性CoordinatorLayout +AppBarLayout效果实现（视频分类详情） 12. 沉浸式状态栏（Activity和在Fragment中的使用及不同手机的适配） 13. DataBinding的使用 14. 约束布局ConstraintLayout的使用 这是一个来自投稿的项目，我也跑了一下，还有些问题，不过适合用于学习。 https://www.jianshu.com/p/12c09376fa97 https://github.com/GraceJoJo/Designer 研发助手滴滴开源的研发助手。 简称 “DoKit” 。一款功能齐全的客户端（ iOS 、Android ）研发助手，你值得拥有。 https://github.com/didi/DoraemonKit* 开源组件DoraemonKit之Android版本技术实现（一） https://juejin.im/post/5c4dcfe8518825261e1f2978 大家手机上或多或少有一些对学习有用的app，小程序吧？留言分享一下吧！]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>骨架屏</tag>
        <tag>加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github上10个开源免费且优秀的后台控制面板]]></title>
    <url>%2Fposts%2Fa81c9ec4.html</url>
    <content type="text"><![CDATA[Web 开发中几乎的平台都需要一个后台管理，但是从零开发一套后台控制面板并不容易，幸运的是有很多开源免费的后台控制面板可以给开发者使用，那么有哪些优秀的开源免费的控制面板呢？我在 Github 上收集了一些优秀的后台控制面板，并总结得出 Top 10。 AdminLTE vue-Element-Admin tabler Gentelella ng2-admin ant-design-pro blur-admin vue-admin iview-admin material-dashboard AdminLTEGithub Star 数 24969 ， Github 地址：https://github.com/almasaeed2010/AdminLTE。 非常流行的基于 Bootstrap 3.x 的免费的后台 UI 框架。 vue-Element-AdminGithub Star 数 19546， Github 地址： https://github.com/PanJiaChen/vue-element-admin。 一个基于 vue2.0 和 Eelement 的控制面板 UI 框架。 tablerGithub Star 数 15870， Github 地址：https://github.com/tabler/tabler。 构建在 BootStrap 4 之上的免费的 HTML 控制面板框架 GentelellaGithub Star 数 15654， Github 地址：https://github.com/puikinsh/gentelella。 一个基于 Bootstarp 的免费的后台控制面板。 ng2-adminGithub Star 数 13181， Github 地址：https://github.com/akveo/ngx-admin。 基于 Angular 2, Bootstrap 4 和 Webpack 的后台管理面板框架。 ant-design-proGithub Star 数 12707，Github 地址：https://github.com/ant-design/ant-design-pro。 开箱即用的中台前端/设计解决方案 blur-adminGithub Star 数 9241，Github 地址：https://github.com/akveo/blur-admin。 基于 Angular 和 Bootstrap 的后台管理面板框架。 vue-adminGithub Star 数 8676，Github 地址：https://github.com/vue-bulma/vue-admin。 基于 Vue 和 Bulma 的控制面板。 iview-adminGithub Star 数 8668，Github 地址：https://github.com/iview/iview-admin。 基于 iView 的 Vue 2.0 控制面板。 material-dashboardGithub Star 数 7111，Github 地址：https://github.com/creativetimofficial/material-dashboard。 基于 Bootstrap 4 和 Material 风格的控制面板。]]></content>
      <categories>
        <category>Java</category>
        <category>开源</category>
      </categories>
      <tags>
        <tag>后台控制面板</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些架构设计原则]]></title>
    <url>%2Fposts%2F5125d3e0.html</url>
    <content type="text"><![CDATA[《Clean Architecture》一书中对于软件架构目的的解释： The goal of software architecture is to miminize the human resources required to build and maintain the required system. 即：软件架构的目的就是将构建和维护系统需要的人力成本降到最低。 因此，可以得出架构设计的关键思维就是判断和取舍（程序设计的关键思维是逻辑和实现），即如何选择技术、组合技术使得需要的人力资源最少。 需要注意的一点是，脱离业务谈架构是不合理的，技术架构及其演进都是业务目标驱动的。 架构原则 避免过度设计：简单的架构就是最好的架构。最简单的方案最容易实现和维护，也可以避免浪费资源。但方案中需要包括扩展。 冗余设计：对服务、数据库的做结点冗余，保证服务的高可用。通过数据库主从模式、应用集群来实现。 多活数据中心：为了容灾，从根本上保障应用的高可用性。需要构建多活的数据中心，以防止一个数据中心由于不可控因素出现故障后，引起整个系统的不可用。 无状态设计：API、接口等的设计不能有前后依赖关系，一个资源不受其他资源改动的影响。无状态的系统才能更好地进行扩展。如果非得有状态，则要么客户端管理状态，要么服务端用分布式缓存管理状态。 可回滚：对于任何业务尤其是关键业务，都具有恢复机制。可以使用基于日志的WAL、基于事件的Event sourcing等来实现可回滚。 可禁用/自我保护：具有限流机制，当上游的流量超过自身的负载能力时，能够拒绝溢出的请求。可以通过手动开关或者自动开关（监测异常流量行为），在应用前端挡住流量。限流算法包括：令牌桶（支持突发流量）、漏桶（匀速流量）、计数器以及信号量（限制并发访问的数量）。此外永远不要信赖第三方服务的可靠性，依赖于第三方的功能务必有服务降级措施以及熔断管理，如：对于每一个网络操作，都需要设置超时时间，超过这个时间就放弃或者返回兜底响应。 问题可追踪：当系统出现问题时，能够定位请求的轨迹、每一步的请求信息等。分布式链路追踪系统即解决的此方面的问题。 可监控：可监控是保障系统能够稳定运行的关键。包括对业务逻辑的监控、应用进程的监控以及应用依赖的CPU、硬盘等系统资源的监控。每一个系统都需要做好这几个层面的监控。 故障隔离：将系统依赖的资源(线程、CPU)和服务隔离开来能够使得某个服务的故障不会影响其他服务的调用。通过线程池或者分散部署结点可以对故障进行隔离。此外，为不同的用户提供单独的访问通道，不仅仅能够做故障隔离，也有利于做用户权限控制。 成熟可控的技术选型：使用市面上主流、成熟、文档、支持资源多的技术，选择合适的而非最火的技术实现系统。如果面对自研和开源技术的选择，需要考虑契合度：如果功能需求契合度很高，那么选择开源即可；如果开源技术是需求的子集或者超集，那么要衡量吃透这个开源技术的成本和自研的成本那个高。 梯级存储：内存-&gt;SSD硬盘-&gt;传统硬盘-&gt;磁带，可以根据数据的重要性和生命周期对数据进行分级存储。 缓存设计：隔离请求与后端逻辑、存储，是就近原则的一种机制。包括客户端缓存（预先下发资源）、Nginx缓存、本地缓存以及分布式缓存。 异步设计：对于调用方不关注结果或者允许结果延时返回的接口，采用队列进行异步响应能够很大程度提高系统性能；调用其他服务的时候不去等待服务方返回结果直接返回，同样能够提升系统响应性能。异步队列也是解决分布式事务的常用手段。 前瞻性设计：根据行业经验和对业务量的预判，提前把可扩展性、后向兼容性、容量预警设计好。以防止超过系统容量后造成各种问题影响服务。 水平扩展：相比起垂直扩展，能够通过堆机器解决问题是最优先考虑的问题，系统的负载能力也才能接近无限扩展。此外，基于云计算技术根据系统的负载自动调整容量能够在节省成本的同时保证服务的可用性。 小步构建和发布：快速迭代项目，快速试错。不能有跨度时间过长的项目规划。 自动化：打包、测试的自动化称为持续集成，部署的自动化称为持续部署。自动化机制是快速迭代和试错的基础保证。 架构六步思考法 笔者对美团总架构师夏华夏一次分享提出的架构六步思考法的理解。 这里尤其需要注意的一点是在面对问题时，首先要试图将未知问题转化为已知问题，而不是创造新问题。 数据设计原则 注意存储效率 减少事务 减少联表查询 适当使用索引 考虑使用缓存 避免依赖于数据库的运算功能(函数、存储器、触发器等)，将负载放在更容易扩展的业务应用端 数据统计场景中，实时性要求较高的数据统计可以用Redis；非实时数据则可以使用单独表，通过队列异步运算或者定时计算更新数据。此外，对于一致性要求较高的统计数据，需要依靠事务或者定时校对机制保证准确性。 索引区分度法则：辨识度超过20%的属性，如果有查询需求，就应该建立索引。 对于数值型数据，可以使用保序压缩方式在保证顺序不变的前提下减少字符串长度。如：进行36进制转化即一种保序压缩方式。 大量数据的去重计数如果允许误差可以选择基数估计算法（Hyperhyperlog、Loglogcount）或者布隆过滤器。 系统响应性能提升五板斧 异步：队列缓冲、异步请求。 并发：利用多CPU多线程执行业务逻辑。 就近原则：缓存、梯度存储。 减少IO：合并细粒度接口为粗粒度接口、频繁的覆盖操作可以只做最后一次操作。这里一个需要特别注意的地方: 代码中尽量避免在循环中调用外部服务，更好的做法是使用粗粒度批量接口在循环外面只进行一次请求。 分区：频繁访问的数据集规模保持在合理的范围。 系统容量规划需要对系统/关键模块做好评估、量化，以防止超出容量时不至于压垮服务器，仍然能够服务于大部分用户。 根据流量模型、历史数据、预测算法预估未来某一个时间点的业务量：QPS、每日数据量等。 评估单点最大承载量（数据库的单点承载数据量、应用服务器的单点承载并发量）【通过性能测试】，根据业务量计算需要部署的结点数目，做1.5倍部署（DID原则）。 性能压测验证整个系统的负载能力。 设计达到容量预估值时的预警、限流、快速恢复措施以及后续扩展方案。 PS: 在容量预估中，机器数目的计算遵循DID原则：20倍设计、3倍实施/实现、1.5倍部署。即需要部署1.5倍的可承载预估业务流量的机器数目。 架构重构的原则一个系统的架构是随着业务而不断演化的，因此不可避免地会留下很多技术债。如果一味地不去管，那么总有一天技术债会爆发出来造成意想不到的破坏。因此很多时候对架构的重构是必须的。其需要遵循的原则如下： 确定重构的目的和必要性：为了业务需要；有无其他备选方案 定义“重构完成”的界限 渐进式重构 确定当前的架构状态 不要忽略数据 管理好技术债务 远离那些虚荣的东西 做好面对压力的准备 了解业务 做好面对非技术因素的准备 能够掌握代码质量 其他 系统扩展思路 通过克隆扩展-&gt;高可用 通过拆分不同的东西来扩展-&gt;垂直扩展 拆分类似的东西来扩展-&gt;水平扩展 讨论技术方案时，以是否合理为依据，而不要以工作量少为依据。]]></content>
      <categories>
        <category>Java</category>
        <category>架构设计与原则</category>
      </categories>
      <tags>
        <tag>架构设计与原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈架构的概念、架构的形式、架构设计原则]]></title>
    <url>%2Fposts%2Fba1b4470.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>架构设计与原则</category>
      </categories>
      <tags>
        <tag>架构设计与原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序原生高颜值组件库--ColorUI组件库]]></title>
    <url>%2Fposts%2F71ce4a1f.html</url>
    <content type="text"><![CDATA[简介ColorUI是一个Css类的UI组件库！不是一个Js框架。相比于同类小程序组件库，ColorUI更注重于视觉交互！ 浏览GitHub：https://github.com/weilanwl/ColorUI 如何使用？先下载源码包→ Github 引入到我的小程序将 /demo/ 下的 colorui.wxss 和 icon.wxss 复制到小程序的根目录下 在 app.wxss 引入两个文件 @import "icon.wxss";@import "colorui.wxss"; 使用模板全新开发复制 /template/ 文件夹并重命名为你的项目，微信开发者工具导入为小程序就可以使用ColorUI了 体验沉浸式导航 App.js 获取系统参数并写入全局参数。 //App.jsApp(&#123; onLaunch: function() &#123; wx.getSystemInfo(&#123; success: e =&gt; &#123; this.globalData.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); this.globalData.Custom = custom; this.globalData.CustomBar = custom.bottom + custom.top - e.statusBarHeight; &#125; &#125;) &#125;&#125;) Page.js 页面配置获取全局参数。 //Page.jsconst app = getApp()Page(&#123; data: &#123; StatusBar: app.globalData.StatusBar, CustomBar: app.globalData.CustomBar, Custom: app.globalData.Custom &#125; &#125;) Page.wxml 页面构造导航。更多导航样式请下载Demo查阅 操作条组件。 &lt;view class="cu-custom" style="height:&#123;&#123;CustomBar&#125;&#125;px;"&gt; &lt;view class="cu-bar fixed bg-gradual-pink" style="height:&#123;&#123;CustomBar&#125;&#125;px;padding-top:&#123;&#123;StatusBar&#125;&#125;px;"&gt; &lt;navigator class='action border-custom' open-type="navigateBack" delta="1" hover-class="none" style='width:&#123;&#123;Custom.width&#125;&#125;px;height:&#123;&#123;Custom.height&#125;&#125;px;margin-left:calc(750rpx - &#123;&#123;Custom.right&#125;&#125;px)'&gt; &lt;text class='icon-back'&gt;&lt;/text&gt; &lt;text class='icon-homefill'&gt;&lt;/text&gt; &lt;/navigator&gt; &lt;view class='content' style='top:&#123;&#123;StatusBar&#125;&#125;px;'&gt;操作条&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 自定义系统Tabbar 按照官方 自定义 tabBar 配置好Tabbar (开发工具和版本库请使用最新版)。 使用ColorUI配置Tabbar只需要更改 Wxml 页的内容即可。 更多Tabbar样式请下载Demo查阅 操作条组件。 /custom-tab-bar/index.wxml &lt;view class="cu-bar tabbar bg-white shadow"&gt; &lt;view class="action" wx:for="&#123;&#123;list&#125;&#125;" wx:key="index" data-path="&#123;&#123;item.pagePath&#125;&#125;" data-index="&#123;&#123;index&#125;&#125;" bindtap="switchTab"&gt; &lt;view class='icon-cu-image'&gt; &lt;image src='&#123;&#123;selected === index ? item.selectedIconPath : item.iconPath&#125;&#125;' class='&#123;&#123;selected === index ? "animation" : "animation"&#125;&#125;'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='&#123;&#123;selected === index ? "text-green" : "text-gray"&#125;&#125;'&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 作者叨叨ColorUI是一个高度自定义的Css样式库，包含了开发常用的元素和组件，元素组件之间也能相互嵌套使用。我也会不定期更新一些扩展到源码。 感谢阅读。 转自链接：https://juejin.im/post/5c773b746fb9a049f43bff0f]]></content>
      <categories>
        <category>前端</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ColorUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager要被废弃？官方ViewPager2升级版来临]]></title>
    <url>%2Fposts%2Fabf696ca.html</url>
    <content type="text"><![CDATA[从文档注释来看ViewPager2确实是用来替代ViewPager 的，顺带解决之前ViewPager的一些问题，并且加入了 RTL,竖向滚动支持，下面一起来详细看下吧。 ViewPager2 replaces ViewPager, addressing most of its predecessor’s pain-points, including right-to-left layout support, vertical orientation, modifiable Fragment collections, etc. 概述这两天浏览安卓开发者官网的时候，发现google悄然推出了一个新的控件：ViewPager2，一看名称就知道这是一个和我们常用的ViewPager功能相似的控件，算是ViewPager的升级版吧。目前还只是推出了第一个预览版，我们可以直接引入来使用了： implementation &apos;androidx.viewpager2:viewpager2:1.0.0-alpha01&apos; https://developer.android.google.cn/reference/androidx/viewpager2/widget/ViewPager2 我们先来看看有哪些功能和使用上的变化： 新功能： 支持RTL布局 支持竖向滚动 完整支持notifyDataSetChanged API的变动： FragmentStateAdapter替换了原来的 FragmentStatePagerAdapter RecyclerView.Adapter替换了原来的 PagerAdapter registerOnPageChangeCallback替换了原来的 addPageChangeListener 看了上面这些介绍，有一点比较吸引人的就是支持竖向滚动了，这是怎么实现的呢？ViewPager2的源码不长，我们来简单分析一下。 简单解析通过查看源码得知，ViewPager2是直接继承ViewGroup的，意味着和ViewPager不兼容，类注释上也写了它的作用是取代ViewPager，不过短时间内ViewPager应该还不会被废弃掉。 继续查看源码，发现了两个比较重要的成员变量： private RecyclerView mRecyclerView;private LinearLayoutManager mLayoutManager; 所以很清楚得知，ViewPager2的核心实现就是RecyclerView+LinearLayoutManager了，因为LinearLayoutManager本身就支持竖向和横向两种布局方式，所以ViewPager2也能很容易地支持这两种滚动方向了，而几乎不需要添加任何多余的代码。 其实在此之前也不乏有大神采用RecyclerView来实现轮播图效果的，具体实现发生略有不同，但大体思想是一致的。这次ViewPager2的推出意味着这种方法终于被扶正了。 为了让RecyclerView变得像原来的ViewPager，需要设置下SnapHelper： new PagerSnapHelper().attachToRecyclerView(mRecyclerView); 熟悉RecyclerView的同学都知道，SnapHelper用于辅助RecyclerView在滚动结束时将Item对齐到某个位置。PagerSnapHelper的作用让滑动结束时使当前Item居中显示，并且 限制一次只能滑动一页，不能快速滑动，这样就和viewpager的交互很像了。 另外和viewpager一样，viewpager2可以承载fragment，我们需要继承实现它提供的FragmentStateAdapter： public abstract class FragmentStateAdapter extends RecyclerView.Adapter&lt;FragmentViewHolder&gt; implements StatefulAdapter 这是一个包含FragmentManager和数据状态恢复功能的RecyclerView.Adapter，具体实现可以参看源码。所以大家也可以用TabLayout+ViewPager2+Fragment来实现联动展示效果。 使用通过android:orientation来指定滚动方向 &lt;androidx.viewpager2.widget.ViewPager2 android:id="@+id/viewpager2" android:layout_width="match_parent" android:layout_height="200dp" android:orientation="vertical" /&gt; 在代码中设置一个普通的RecyclerView.adapter： ViewPager2 viewPager2=findViewById(R.id.viewpager2);RecyclerviewAdapter adapter = new RecyclerviewAdapter(this);viewPager2.setAdapter(adapter); 这样竖直轮播图就大功告成了。 小结viewpager2利用recyclerview来实现viewpager的功能，无疑使使其可扩展性大大提升，代码也变得更优雅简洁，使用起来也更灵活。不过目前viewpager2只是第一个预览版，还存在稳定性方面的问题，不建议大家引入到正式项目中来，尝尝鲜就好。 PS：如果有谁愿意深入解析，示例对比演示等，欢迎火速联系我，投稿分享给大家。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 函数式编程和 lambda 表达式]]></title>
    <url>%2Fposts%2F81a39ed5.html</url>
    <content type="text"><![CDATA[为什么要使用函数式编程函数式编程更多时候是一种编程的思维方式，是种方法论。函数式与命令式编程的区别主要在于：函数式编程是告诉代码你要做什么，而命令式编程则是告诉代码要怎么做。说白了，函数式编程是基于某种语法或调用API去进行编程。例如，我们现在需要从一组数字中，找出最小的那个数字，若使用用命令式编程实现这个需求的话，那么所编写的代码如下： public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;; int min = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &lt; min) &#123; min = num; &#125; &#125; System.out.println(min);&#125; 而使用函数式编程进行实现的话，所编写的代码如下： public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;; int min = IntStream.of(nums).min().getAsInt(); System.out.println(min);&#125; 从以上的两个例子中，可以看出，命令式编程需要自己去实现具体的逻辑细节。而函数式编程则是调用API完成需求的实现，将原本命令式的代码写成一系列嵌套的函数调用，在函数式编程下显得代码更简洁、易懂，这就是为什么要使用函数式编程的原因之一。所以才说函数式编程是告诉代码你要做什么，而命令式编程则是告诉代码要怎么做，是一种思维的转变。 说到函数式编程就不得不提一下lambda表达式，它是函数式编程的基础。在Java还不支持lambda表达式时，我们需要创建一个线程的话，需要编写如下代码： public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("running"); &#125; &#125;).start();&#125; 而使用lambda表达式一句代码就能完成线程的创建，lambda强调了函数的输入输出，隐藏了过程的细节，并且可以接受函数当作输入（参数）和输出（返回值）： public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println("running")).start();&#125; 注：箭头的左边是输入，右边则是输出 该lambda表达式的作用其实就是返回了Runnable接口的实现对象，这与我们调用某个方法获取实例对象类似，只不过是将实现代码直接写在了lambda表达式里。我们可以做个简单的对比： public static void main(String[] args) &#123; Runnable runnable1 = () -&gt; System.out.println("running"); Runnable runnable2 = RunnableFactory.getInstance();&#125; JDK8接口新特性1.函数接口，接口只能有一个需要实现的方法，可以使用@FunctionalInterface 注解进行声明。如下： @FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i);&#125; 使用lambda表达式获取该接口的实现实例的几种写法： public static void main(String[] args) &#123; // 最常见的写法 Interface1 i1 = (i) -&gt; i * 2; Interface1 i2 = i -&gt; i * 2; // 可以指定参数类型 Interface1 i3 = (int i) -&gt; i * 2; // 若有多行代码可以这么写 Interface1 i4 = (int i) -&gt; &#123; System.out.println(i); return i * 2; &#125;;&#125; 2.比较重要的一个接口特性是接口的默认方法，用于提供默认实现。默认方法和普通实现类的方法一样，可以使用this等关键字： @FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125; 之所以说默认方法这个特性比较重要，是因为我们借助这个特性可以在以前所编写的一些接口上提供默认实现，并且不会影响任何的实现类以及既有的代码。例如我们最熟悉的List接口，在JDK1.2以来List接口就没有改动过任何代码，到了1.8之后才使用这个新特性增加了一些默认实现。这是因为如果没有默认方法的特性的话，修改接口代码带来的影响是巨大的，而有了默认方法后，增加默认实现可以不影响任何的代码。 3.当接口多重继承时，可能会发生默认方法覆盖的问题，这时可以去指定使用哪一个接口的默认方法实现，如下示例： @FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125;@FunctionalInterfaceinterface Interface2 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125;@FunctionalInterfaceinterface Interface3 extends Interface1, Interface2 &#123; @Override default int add(int x, int y) &#123; // 指定使用哪一个接口的默认方法实现 return Interface1.super.add(x, y); &#125;&#125; 函数接口我们本小节来看看JDK8里自带了哪些重要的函数接口： 可以看到上表中有好几个接口，而其中最常用的是Function接口，它能为我们省去定义一些不必要的函数接口，减少接口的数量。我们使用一个简单的例子演示一下 Function 接口的使用： import java.text.DecimalFormat;import java.util.function.Function;class MyMoney &#123; private final int money; public MyMoney(int money) &#123; this.money = money; &#125; public void printMoney(Function&lt;Integer, String&gt; moneyFormat) &#123; System.out.println("我的存款: " + moneyFormat.apply(this.money)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999); Function&lt;Integer, String&gt; moneyFormat = i -&gt; new DecimalFormat("#,###").format(i); // 函数接口支持链式操作，例如增加一个字符串 me.printMoney(moneyFormat.andThen(s -&gt; "人民币 " + s)); &#125;&#125; 运行以上例子，控制台输出如下： 我的存款: 人民币 99,999,999 若在这个例子中不使用Function接口的话，则需要自行定义一个函数接口，并且不支持链式操作，如下示例： import java.text.DecimalFormat;// 自定义一个函数接口@FunctionalInterfaceinterface IMoneyFormat &#123; String format(int i);&#125;class MyMoney &#123; private final int money; public MyMoney(int money) &#123; this.money = money; &#125; public void printMoney(IMoneyFormat moneyFormat) &#123; System.out.println("我的存款: " + moneyFormat.format(this.money)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999); IMoneyFormat moneyFormat = i -&gt; new DecimalFormat("#,###").format(i); me.printMoney(moneyFormat); &#125;&#125; 然后我们再来看看Predicate接口和Consumer接口的使用，如下示例： public static void main(String[] args) &#123; // 断言函数接口 Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; 0; System.out.println(predicate.test(-9)); // 消费函数接口 Consumer&lt;String&gt; consumer = System.out::println; consumer.accept("这是输入的数据");&#125; 运行以上例子，控制台输出如下： false这是输入的数据 这些接口一般有对基本类型的封装，使用特定类型的接口就不需要去指定泛型了，如下示例： public static void main(String[] args) &#123; // 断言函数接口 IntPredicate intPredicate = i -&gt; i &gt; 0; System.out.println(intPredicate.test(-9)); // 消费函数接口 IntConsumer intConsumer = (value) -&gt; System.out.println("输入的数据是：" + value); intConsumer.accept(123);&#125; 运行以上代码，控制台输出如下： false输入的数据是：123 有了以上接口示例的铺垫，我们应该对函数接口的使用有了一个初步的了解，接下来我们演示剩下的函数接口使用方式： public static void main(String[] args) &#123; // 提供数据接口 Supplier&lt;Integer&gt; supplier = () -&gt; 10 + 1; System.out.println("提供的数据是：" + supplier.get()); // 一元函数接口 UnaryOperator&lt;Integer&gt; unaryOperator = i -&gt; i * 2; System.out.println("计算结果为：" + unaryOperator.apply(10)); // 二元函数接口 BinaryOperator&lt;Integer&gt; binaryOperator = (a, b) -&gt; a * b; System.out.println("计算结果为：" + binaryOperator.apply(10, 10));&#125; 运行以上代码，控制台输出如下： 提供的数据是：11计算结果为：20计算结果为：100 而BiFunction接口就是比Function接口多了一个输入而已，如下示例： class MyMoney &#123; private final int money; private final String name; public MyMoney(int money, String name) &#123; this.money = money; this.name = name; &#125; public void printMoney(BiFunction&lt;Integer, String, String&gt; moneyFormat) &#123; System.out.println(moneyFormat.apply(this.money, this.name)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999, "小明"); BiFunction&lt;Integer, String, String&gt; moneyFormat = (i, name) -&gt; name + "的存款: " + new DecimalFormat("#,###").format(i); me.printMoney(moneyFormat); &#125;&#125; 运行以上代码，控制台输出如下： 小明的存款: 99,999,999 方法引用在学习了lambda表达式之后，我们通常会使用lambda表达式来创建匿名方法。但有的时候我们仅仅是需要调用一个已存在的方法。如下示例： Arrays.sort(stringsArray, (s1, s2) -&gt; s1.compareToIgnoreCase(s2)); 在jdk8中，我们可以通过一个新特性来简写这段lambda表达式。如下示例： Arrays.sort(stringsArray, String::compareToIgnoreCase); 这种特性就叫做方法引用(Method Reference)。方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号）。 目前方法引用共有以下四种形式： 类型 示例 代码示例 对应的Lambda表达式 引用静态方法 ContainingClass::staticMethodName String::valueOf (s) -&gt; String.valueOf(s) 引用某个对象的实例方法 containingObject::instanceMethodName x::toString() () -&gt; this.toString() 引用某个类型的任意对象的实例方法 ContainingType::methodName String::toString (s) -&gt; s.toString 引用构造方法 ClassName::new String::new () -&gt; new String() 下面我们用一个简单的例子来演示一下方法引用的几种写法。首先定义一个实体类： public class Dog &#123; private String name = "二哈"; private int food = 10; public Dog() &#123; &#125; public Dog(String name) &#123; this.name = name; &#125; public static void bark(Dog dog) &#123; System.out.println(dog + "叫了"); &#125; public int eat(int num) &#123; System.out.println("吃了" + num + "斤"); this.food -= num; return this.food; &#125; @Override public String toString() &#123; return this.name; &#125;&#125; 通过方法引用来调用该实体类中的方法，代码如下： package org.zero01.example.demo;import java.util.function.*;/** * @ProjectName demo * @Author: zeroJun * @Date: 2018/9/21 13:09 * @Description: 方法引用demo */public class MethodRefrenceDemo &#123; public static void main(String[] args) &#123; // 方法引用，调用打印方法 Consumer&lt;String&gt; consumer = System.out::println; consumer.accept("接收的数据"); // 静态方法引用，通过类名即可调用 Consumer&lt;Dog&gt; consumer2 = Dog::bark; consumer2.accept(new Dog()); // 实例方法引用，通过对象实例进行引用 Dog dog = new Dog(); IntUnaryOperator function = dog::eat; System.out.println("还剩下" + function.applyAsInt(2) + "斤"); // 另一种通过实例方法引用的方式，之所以可以这么干是因为JDK默认会把当前实例传入到非静态方法，参数名为this，参数位置为第一个，所以我们在非静态方法中才能访问this，那么就可以通过BiFunction传入实例对象进行实例方法的引用 Dog dog2 = new Dog(); BiFunction&lt;Dog, Integer, Integer&gt; biFunction = Dog::eat; System.out.println("还剩下" + biFunction.apply(dog2, 2) + "斤"); // 无参构造函数的方法引用，类似于静态方法引用，只需要分析好输入输出即可 Supplier&lt;Dog&gt; supplier = Dog::new; System.out.println("创建了新对象：" + supplier.get()); // 有参构造函数的方法引用 Function&lt;String, Dog&gt; function2 = Dog::new; System.out.println("创建了新对象：" + function2.apply("旺财")); &#125;&#125; 类型推断通过以上的例子，我们知道之所以能够使用Lambda表达式的依据是必须有相应的函数接口。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上Lambda的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。 如果大家想学习以上路线内容，在此我向大家推荐一个架构学习交流群。交流学习群号874811168 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构等这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 所以说 Lambda 表达式的类型是从 Lambda 的上下文推断出来的，上下文中 Lambda 表达式需要的类型称为目标类型，如下图所示： 接下来我们使用一个简单的例子，演示一下 Lambda 表达式的几种类型推断，首先定义一个简单的函数接口： @FunctionalInterfaceinterface IMath &#123; int add(int x, int y);&#125; 示例代码如下： public class TypeDemo &#123; public static void main(String[] args) &#123; // 1.通过变量类型定义 IMath iMath = (x, y) -&gt; x + y; // 2.数组构建的方式 IMath[] iMaths = &#123;(x, y) -&gt; x + y&#125;; // 3.强转类型的方式 Object object = (IMath) (x, y) -&gt; x + y; // 4.通过方法返回值确定类型 IMath result = createIMathObj(); // 5.通过方法参数确定类型 test((x, y) -&gt; x + y); &#125; public static IMath createIMathObj() &#123; return (x, y) -&gt; x + y; &#125; public static void test(IMath iMath)&#123; return; &#125;&#125; 变量引用Lambda表达式类似于实现了指定接口的内部类或者说匿名类，所以在Lambda表达式中引用变量和我们在匿名类中引用变量的规则是一样的。如下示例： public static void main(String[] args) &#123; String str = "当前的系统时间戳是: "; Consumer&lt;Long&gt; consumer = s -&gt; System.out.println(str + s); consumer.accept(System.currentTimeMillis());&#125; 值得一提的是，在JDK1.8之前我们一般会将匿名类里访问的外部变量设置为final，而在JDK1.8里默认会将这个匿名类里访问的外部变量给设置为final。例如我现在改变str变量的值，ide就会提示错误： 至于为什么要将变量设置final，这是因为在Java里没有引用传递，变量都是值传递的。不将变量设置为final的话，如果外部变量的引用被改变了，那么最终得出来的结果就会是错误的。 下面用一组图片简单演示一下值传递与引用传递的区别。以列表为例，当只是值传递时，匿名类里对外部变量的引用是一个值对象： 若此时list变量指向了另一个对象，那么匿名类里引用的还是之前那个值对象，所以我们才需要将其设置为final防止外部变量引用改变： 而如果是引用传递的话，匿名类里对外部变量的引用就不是值对象了，而是指针指向这个外部变量： 所以就算list变量指向了另一个对象，匿名类里的引用也会随着外部变量的引用改变而改变： 级联表达式和柯里化在函数式编程中，函数既可以接收也可以返回其他函数。函数不再像传统的面向对象编程中一样，只是一个对象的工厂或生成器，它也能够创建和返回另一个函数。返回函数的函数可以变成级联 lambda 表达式，特别值得注意的是代码非常简短。尽管此语法初看起来可能非常陌生，但它有自己的用途。 级联表达式就是多个lambda表达式的组合，这里涉及到一个高阶函数的概念，所谓高阶函数就是一个可以返回函数的函数，如下示例： // 实现了 x + y 的级联表达式Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; function1 = x -&gt; y -&gt; x + y;System.out.println("计算结果为: " + function1.apply(2).apply(3)); // 计算结果为: 5 这里的 y -&amp;gt; x + y 是作为一个函数返回给上一级表达式，所以第一级表达式的输出是 y -&amp;gt; x + y这个函数，如果使用括号括起来可能会好理解一些： x -&gt; (y -&gt; x + y) 级联表达式可以实现函数柯里化，简单来说柯里化就是把本来多个参数的函数转换为只有一个参数的函数，如下示例： Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; function2 = x -&gt; y -&gt; z -&gt; x + y + z;System.out.println("计算结果为: " + function2.apply(1).apply(2).apply(3)); // 计算结果为: 6 如果大家想学习以上路线内容，在此我向大家推荐一个架构学习交流群。交流学习群号874811168 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构等这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 函数柯里化的目的是将函数标准化，函数可灵活组合，方便统一处理等，例如我可以在循环里只需要调用同一个方法，而不需要调用另外的方法就能实现一个数组内元素的求和计算，代码如下： public static void main(String[] args) &#123; Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; f3 = x -&gt; y -&gt; z -&gt; x + y + z; int[] nums = &#123;1, 2, 3&#125;; for (int num : nums) &#123; if (f3 instanceof Function) &#123; Object obj = f3.apply(num); if (obj instanceof Function) &#123; f3 = (Function) obj; &#125; else &#123; System.out.println("调用结束, 结果为: " + obj); // 调用结束, 结果为: 6 &#125; &#125; &#125;&#125; 级联表达式和柯里化一般在实际开发中并不是很常见，所以对其概念稍有理解即可，这里只是简单带过，若对其感兴趣的可以查阅相关资料。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中字符串全部替换]]></title>
    <url>%2Fposts%2F5bf0344a.html</url>
    <content type="text"><![CDATA[在js中字符串全部替换可以用以下方法： str.replace(/需要替换的字符串/g，&quot;新字符串&quot;) 比如： &quot;yyyy-MM-dd-hh-mm-ss&quot;.replace(/-/g,&quot;/&quot;)结果如下：&quot;yyyy/MM/dd/hh/mm/ss&quot; 原理请看JavaScript replace() 方法介绍 定义和用法replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 语法stringObject.replace(regexp/substr,replacement) 参数 描述 regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 返回值一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 说明字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 js字符串替换参考资料：http://www.w3school.com.cn/jsref/jsref_replace.asp js正则使用参考资料：http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取指定字符前/后的字符串简单实例]]></title>
    <url>%2Fposts%2F1dfc2d5c.html</url>
    <content type="text"><![CDATA[&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt;/* string 字符串; str 指定字符; split(),用于把一个字符串分割成字符串数组; split(str)[0],读取数组中索引为0的值（第一个值）,所有数组索引默认从0开始; */function getStr(string,str)&#123; var str_before = string.split(str)[0]; var str_after = string.split(str)[1]; alert('前：'+str_before+' - 后：'+str_after);&#125;&lt;/script&gt;&lt;body&gt;&lt;input type="button" onClick="getStr('string','r');" value="获取值" /&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles在线破解工具]]></title>
    <url>%2Fposts%2Fc05a8eb3.html</url>
    <content type="text"><![CDATA[点击在线生成破解后的charles.jar文件 用法 输入RegisterName(此名称随意，用于显示 Registered to xxx)，选择本地已安装的版本，点击生成，并下载charles.jar文件 替换本地charles.jar文件 macOS: /Applications/Charles.app/Contents/Java/charles.jar Windows: C:\Program Files\Charles\lib\charles.jar]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac端口被占用的解决办法（Hexo为例）]]></title>
    <url>%2Fposts%2F3a2cfc51.html</url>
    <content type="text"><![CDATA[查看端口 看看端口被哪个进程占用 lsof -i :4000 输入kill PID 记住要杀掉的进程PID，加在kill -9后面 kill -9 16149]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js面试中常问知识点整理]]></title>
    <url>%2Fposts%2Fadbc7180.html</url>
    <content type="text"><![CDATA[看看面试题，只是为了查漏补缺，看看自己那些方面还不懂。切记不要以为背了面试题，就万事大吉了，最好是理解背后的原理，这样面试的时候才能侃侃而谈。不然，稍微有水平的面试官一看就能看出，是否有真才实学还是刚好背中了这道面试题（有空再把例子中代码补上）。 一、对于MVVM的理解？MVVM 是 Model-View-ViewModel 的缩写。 Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。 View 代表UI 组件，它负责将数据模型转化成UI 展现出来。 ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 二、Vue的生命周期beforeCreate（创建前），在数据观测和初始化事件还未开始 created（创建后），完成数据观测，属性和方法的运算，初始化事件， $el 属性还没有显示出来 beforeMount（载入前），在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted（载入后），在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate（更新前），在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated（更新后），在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前），在实例销毁之前调用。实例仍然完全可用。 destroyed（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 1、什么是vue生命周期？ 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 2、vue生命周期的作用是什么？ 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 3、vue生命周期总共有几个阶段？ 答：它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。 4、第一次页面加载会触发哪几个钩子？ 答：会触发下面这几个beforeCreate、created、beforeMount、mounted 。 5、DOM 渲染在哪个周期中就已经完成？ 答：DOM 渲染在 mounted 中就已经完成了。 三、 Vue实现数据双向绑定的原理：Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令，最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &apos;txt&apos;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&apos;txt&apos;).value = newValue document.getElementById(&apos;show&apos;).innerHTML = newValue &#125; &#125;) document.addEventListener(&apos;keyup&apos;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt; 四、Vue组件间的参数传递1、父组件与子组件传值 父组件传给子组件：子组件通过props方法接受数据； 子组件传给父组件： $emit 方法传递参数 2、非父子组件间的数据传递，兄弟组件传值 eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道）。 五、Vue的路由实现：hash模式 和 history模式hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 六、Vue与Angular以及React的区别？版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟。 1、与AngularJS的区别 相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。 不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 2、与React的区别 相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。 不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。 七、vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next。 to：route即将进入的目标路由对象。 from：route当前导航正要离开的路由。 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 八、vuex是什么？怎么使用？哪种功能场景使用它？只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 在main.js引入store，注入。新建了一个目录store，… export 。 场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车 state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters：类似vue的计算属性，主要用来过滤一些数据。 action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 const store = new Vuex.Store(&#123; //store实例 state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。 const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125; &#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125; &#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB&#125;) 九、其它小知识点1、css只在当前组件起作用 答：在style标签中写入scoped即可 例如： &lt;stylescoped&gt;&lt;/style&gt; 2、v-if 和 v-show 区别 答：v-if按照条件是否渲染，v-show是display的block或none； 3、$route和$router的区别 答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 PS：缺少的案例代码，这几天再补上去。有些地方可能描述的不够清楚，如果有歧义，可能是我理解错了。]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidManifest.xml文件详解（application）]]></title>
    <url>%2Fposts%2F6f32c165.html</url>
    <content type="text"><![CDATA[语法（SYNATX）：&lt;applicationandroid:allowTaskReparenting=["true" | "false"] android:backupAgent="string" android:debuggable=["true" | "false"] android:description="string resource" android:enabled=["true" | "false"] android:hasCode=["true" | "false"] android:hardwareAccelerated=["true" | "false"] android:icon="drawable resource" android:killAfterRestore=["true" | "false"] android:label="string resource" android:logo="drawable resource" android:manageSpaceActivity="string" android:name="string" android:permission="string" android:persistent=["true" | "false"] android:process="string" android:restoreAnyVersion=["true" | "false"] android:taskAffinity="string" android:theme="resource or theme" android:uiOptions=["none" | "splitActionBarWhenNarrow"] &gt; . . .&lt;/application&gt; 被包含于（CONTAINED IN）：** &lt;manifest&gt; 能够包含的元素（CAN CONTAIN）：&lt;activity&gt;&lt;activity-alias&gt;&lt;service&gt;&lt;receiver&gt;&lt;provider&gt;&lt;meta-data&gt; 说明（DESCRIPTION）： 这个元素用于应用程序的 声明。它包含了每个应用程序组件所声明的子元素，并且还有能够影响所有组件的属性。其中的很多属性（如icon、label、permission、 process、taskAffinity和allowTaskReparenting）会给组件元素中对应的属性设置默认值。其他的给是应用程序整体设 置的值（如debuggable、enabled、description、allowClearUserData），并且这些属性值不能被组件的属性所 覆盖。 属性（ATTRIBUTES）： Android:allowTaskReparenting 当一个与当前任务有亲缘 关系的任务被带到前台时，用这个属性来指定应用程序中定义的Activity能否从他们当前的任务中转移到这个有亲缘关系的任务中。如果设置为true， 则能够转移，如果设置为false，则应用程序中的Activity必须保留在它们所在的任务中。默认值是false。&lt;activity&gt;元素有它们自己的allowTaskReparenting属性，它能够覆盖&lt;application&gt;元素中的设置。 android:allowBackup Whether to allow the application to participate in the backup and restore infrastructure. If this attribute is set to false, no backup or restore of the application will ever be performed, even by a full-system backup that would otherwise cause all application data to be saved via adb. The default value of this attribute is true. 是否允许备份应用的数据，默认是true,当备份数据的时候，它的数据会被备份下来。如果设为false，那么绝对不会备份应用的数据，即使是备份整个系统。 android:backupAgent 这个属性用于定义应用程 序备份代理的实现类的名称，这个类是BackupAgent类的一个子类。它的属性值应该是完整的Java类的名称 （如，com.example.project.MyBackupAgent）。但是，也可以使用用”.”符号开头的简称 （如，.MyBackupAgent），系统会把元素中指定的包名追加到”.”符号的前面。 android:debuggable 这个属性用于指定应用程序是否能够被调试，即使是以用户模式运行在设备上的时候。如果设置为true，则能够被调试，否则不能调试，默认值是false。 android:description 这个属性用于定义应用程序相关的用户可读文本，它要比应用程序标签更长、更详细。它的的值必须被设置成一个字符串资源的引用。跟label属性不一样，label属性可以使用原生的字符串。这个属性没有默认值。 android:enabled 这个属性用于指定 Android系统能否实例化应用程序组件。如果设置为true，这个可以实例化其组件，否则不能够实例化。如果这个属性被设置为true，那么就会使用 每个组件自己enabled属性的设置来判断其是否能够被实例化。如果这个属性被设置为false，它会覆盖其所有组件自己指定的值，应用程序中的所有组 件都会被禁用。 默认值是true。 android:hasCode 这个属性用于设置应用程序是否包含了代码，如果设置为true，则包含代码，否则不包含任何代码。在这个属性被设置为false的时候，系统在加载组件的时候不会试图加载任何应用程序的代码。默认值是true。 如果应用程序没有使用任何应用内置组件类以外的组件，那么这个应用程序就不会有任何自己的代码，像使用AliasActivity类的Activity，是很少发生的。 android:hardwareAccelerated 这个属性用于设置能够给应用程序中的所有Activity和View对象启用硬件加速渲染。如果设置为true，则应该启用，如果设置为false，则不会启用。默认值是false。 从Android3.0 开始，应用程序可以使用硬件加速的OpenGL渲染器，来改善很多共同的2D图形操作的性能。当硬件加速渲染被启动的时候，在Canvas、Paint、 Xfermode、ColorFilter、Shader和Camera中的大多数操作都会被加速。这样会使动画、滚动更加平滑，并且会改善整体的响应效 果，即使应用程序没有明确的使用框架的OpenGL类库。 要注意的是，不是所有的OpenGL 2D操作都会被加速。如果启用了硬件加速渲染器，就要对应用程序进行测试，以确保使用渲染器时不发生错误。 android:icon 这个属性用于设置应用程 序的整个图标，以及每个应用组件的默认图标。对于、、、、 和元素，请看它们各自的icon属性。 设置这个属性时，必须要引用一个包含图片的可绘制资源（例如，“@drawable/icon”）。没有默认的图标。 android:killAfterRestore 这个属性用于指定在全系统的恢复操作期间，应用的设置被恢复以后，对应的问题程序是否应该被终止。单包恢复操作不会导致应用程序被关掉。全系统的复原操作通常只会发生一次，就是在电话被首次建立的时候。第三方应用程序通常不需要使用这个属性。 默认值是true，这意味着在全系统复原期间，应用程序完成数据处理之后，会被终止。 android:largeHeap Whether your application’s processes should be created with a large Dalvik heap. This applies to all processes created for the application. It only applies to the first application loaded into a process; if you’re using a shared user ID to allow multiple applications to use a process, they all must use this option consistently or they will have unpredictable results.Most apps should not need this and should instead focus on reducing their overall memory usage for improved performance. Enabling this also does not guarantee a fixed increase in available memory, because some devices are constrained by their total available memory.To query the available memory size at runtime, use the methods getMemoryClass() or getLargeMemoryClass().无论您的应用程序的进程应该是一个多大的Dalvik堆。这适用于为应用程序创建的所有进程。它只适用于加载到进程中的第一个应用程序，如果你使用一个共享的用户身份证，允许多个应用程序使用一个进程，他们都必须使用此选项一致或他们将有不可预测的结果。大多数应用程序不应该需要这个，而应该把重点放在减少对性能的整体内存使用上。启用此也不保证可用内存的固定增加，因为一些设备被其总可用内存限制。查询可用的内存大小在运行时，使用的方法getmemoryclass()或getlargememoryclass()。 android:label 这个属性用于设置应用程 序整体的用户可读的标签，并也是每个应用程序组件的默认标签。对于、、、和元素，请看它们各自的 label属性。 设置这个属性值时，应该引用一个字符串资源。以便它能够跟用户界面中的其他字符串一样能够被本地化。但是为了应用程序开发的便利，也能够用原生的字符串来设置。 android:logo 这个属性用于给整个应用程序设置一个Logo，而且它也是所有Activity的默认Logo。 设置这个属性时，必须要引用一个包含图片的可绘制资源（如：“@drawable/logo”）。没有默认的Logo。 android:manageSpaceActivity 这个属性定义了一个完整的Activity子类的名字，系统能够把这个名字加载到由用户管理被应用程序所占用的设备上的内存。这个Activity也应该用元素来声明。 android:name 这整个属性用完整的Java类名，给应用程序定义了一个Application子类的实现。当应用程序进程被启动时，这个类在其他任何应用程序组件被实例化之前实例化。 这个子类实现是可选的，大多数应用程序不需要一个子类的实现。如果没有实现自己的子类，Android系统会使用基本的Application类的一个实例。 android:permission 这个属性定义了一个权限，为了跟应用程序进行交互，客户端必须要有这个权限。这个属性是为给所有的应用程序组件设置权限提供了便利的方法。它能够被独立组件所设置的permission属性所覆盖。 android:persistent 这个属性用户设置应用程序是否应该时刻保持运行状态，如果设置为true，那么就保持，否则不保持。默认值是false。普通的应用程序不应该设置这个属性，持久运行模式仅用于某些系统级的应用程序。 android:process 这个属性用于定义一个进程名称，应用程序的所有组件都应该运行在这个进程中。每个组件都能够用它自己process属性的设置来覆盖这个元素中的设置。 默认情况下，当应用程序的第一个组件需要运行时，Android系统就会给这个应用程序创建一个进程。然后，应用中的所有组件都运行在这个进程中。默认的进程名是跟元素中设置的包名进行匹配的。 通过设置这个属性，能够跟另外一个应用程序共享一个进程名，能够把这两个应用程序中的组件都安排到同一个进程中运行—但是仅限于这两个应用程序共享一个用户ID，并且带有相同的数字证书。 如果这个进程名称用“：”开头，那么在需要的时候，就会给应用程序创建一个新的、私有的进程。如果进程名用小写字符开头，就会用这个名字创建一个全局的进程，这个全局的进程能够被其他应用程序共享，从而减少资源的使用。 android:restoreAnyVersion 设置这个属性表示应用程序准备尝试恢复任何备份的数据集，即使备份比设备上当前安装的应用程序的版本要新。这个属性设置为true，即使是在版本不匹配而产生数据兼容性提示的时候，也会允许备份管理来恢复备份的数据，所以要谨慎使用。 这个属性的默认值是false。 android:taskAffinity 这个属性给应用的所有的Activity设置了一个亲缘关系名，除了那些用它们自己的taskAffinity属性设置不同亲缘关系的组件。 默认情况下，应用程序中的所有Activity都会共享相同的亲缘关系，亲缘关系的名称跟由元素设置的包名相同。 android:theme 这个属性给应用程序中所有的Activity设置默认的主题，属性值要引用一个样式资源。每个独立的Activity的主题会被它们自己的theme属性所覆盖。 android:uiOptions 这个属性设置了Activity的UI的额外选项。它必须是下表中的一个值： 值 说明 none 默认设置，没有额外的UI选项。 splitActionBarWhenNarrow 在水平空间受到限制的时 候，会在屏幕的底部添加一个用于显示ActionBar中操作项的栏，例如：在纵向的手持设备上。而不是在屏幕顶部的操作栏中显示少量的操作项。它会把操 作栏分成上下两部分，顶部用于导航选择，底部用于操作项目。这样就会确保可用的合理空间不仅只是针对操作项目，而且还会在顶部给导航和标题留有空间。菜单 项目不能被分开到两个栏中，它们要显示在一起。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis,mysql,sequelize,node,linux,docker,索引优秀文章集锦]]></title>
    <url>%2Fposts%2F325455a3.html</url>
    <content type="text"><![CDATA[redis Redis 数据库入门指南 Redis 数据类型之字符串(String)类型 Redis 数据类型之哈希(Hash)类型 Redis 数据类型之列表(List)类型 Redis 数据类型之集合(Set)类型 Redis 数据类型之有序集合(Sorted Set) Redis 键(Key)的操作命令 redis - Node.js Redis客户端模块 mysql Linux 源码编译安装MySQL 5.7 MySQL 自定义函数和存储过程的使用 MySQL 事件调度器(Event Scheduler)创建定时任务 MySql视图view的使用：创建、修改、删除 MySql触发器trigger的使用 使用MySQL的DATE_FORMAT()函数进行日期/时间格式化 索引 参考1 参考2 Sequelize 定义索引 MySQL索引使用－创建、查看、删除MySQL索引 MySQL索引的优点和缺点及注意事项 sequelize Sequelize 中文API文档－1. 快速入门、Sequelize类 Sequelize 中文API文档－2. Model 的定义、使用与Model类的API Sequelize 中文API文档－3. 模型（表）之间的关系/关联 Sequelize 中文API文档－4. 查询与原始查询 Sequelize 中文API文档－5. 实例的使用、Instance类介绍 Sequelize 中文API文档－6. 事务的使用与Transaction类 Sequelize 中文API文档－8. 钩子函数的使用、Hooks相关API Sequelize 中文API文档－7. Scopes 作用域的使用 Sequelize 中文API文档－9. 数据类型类 DataTypes 及其API Sequelize 中文API文档－10. Migrations 数据迁移与QueryInterface对象 Sequelize 嵌套模型查询及嵌套模型字段排序 Sequelize 连接查询时include中model与association的区别 在Sequelize中使用group by分组聚合查询 Node.js Sequelize 实现数据库读写分离 Sequelize belongsToMany关系的使用及 is not associated with 问题的处理 Sequelize 中事务的使用－启动、提交、回滚 NODE Node.js 基于流将日志、错误分别写入不同文件 Node.js 核心(原生)模块整理 Node.js 中有哪些类型的错误 Node.js 事件循环（Event Loop）介绍 Node.js（npm）中的包和模块 Linux curl 命令行工具的使用及命令参数说明 ssh-keygen实现基于SSH密钥的SSH、SCP无密码登录 Linux命令ftp文件传输 搭建FTP服务器 Linux命令grep查找文件里符合条件的字符串 加快网页访问速度Nginx配置gzip压缩功能 docker Docker 的安装 MySQL 官方Docker镜像的使用 使用 Docker 部暑Node.js应用 Docker 容器数据卷(Data Volume)与数据管理 Docker镜像构建文件Dockerfile及相关命令介绍 构建自已的 Docker 镜像 Docker 镜像(Image)与仓库(Repository)基础 Docker 容器(Container)的管理]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[editorConfig编辑器配置]]></title>
    <url>%2Fposts%2F6d832a8b.html</url>
    <content type="text"><![CDATA[当多人团队进行一个项目开发时，每个人可能喜欢的编辑器不同，有人喜欢Webstrom、有人喜欢sublime、还有人喜欢Hbuilder。 这个时候，问题便迎面而来，如何使使用不同编辑器的开发者能够轻松惬意的遵守最基本的代码规范呢？ 最后终于找到了editorConfig这个东东，发现在这里配置的代码规范规则优先级高于编辑器默认的代码格式化规则。比如我使用的是Webstrom编辑器，我每一次写完代码之后，都习惯性的按下“Ctrl+Alt+L”快捷键去整理代码格式。如果我没有配置editorconfig，执行的就是编辑器默认的代码格式化规则；如果我已经配置了editorConfig，则按照我设置的规则来，从而忽略浏览器的设置。 下面说说它的常用配置和使用方法： 常用配置 （1）charset 编码格式 （2）indent_style 缩进方式 （3）indent_size 缩进大小 （4）insert_final_newline 是否让文件以空行结束 （5）trim_trailing_whitespace 自动删除文件末尾空白行 （6）max_line_length 疑似最大行宽 使用方法 （1）下载相关编辑器的editorconfig插件。 （2）在项目根目录下，新建.editorconfig文件。 （3）配置规范，如下图所示： # http://editorconfig.orgroot = true[*]#缩进风格：空格indent_style = space#缩进大小2indent_size = 2#换行符lfend_of_line = lf#字符集utf-8charset = utf-8#是否删除行尾的空格trim_trailing_whitespace = true#是否在文件的最后插入一个空行insert_final_newline = true[*.md]trim_trailing_whitespace = false[Makefile]indent_style = tab 官方网站 atom网站：https://atom.io/packages/editorconfig GitHub：https://github.com/sindresorhus/atom-editorconfig 使用建议配合代码检查工具使用，比如说：ESLint和TSLint，统一代码风格。 支持的编辑器 虽然editor编辑器的可用配置并不多，但目前现有的一些配置也差不多能满足最基本格式需求。]]></content>
      <categories>
        <category>前端</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>editorConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webstorm激活破解方法大全]]></title>
    <url>%2Fposts%2F9468177.html</url>
    <content type="text"><![CDATA[webstorm 作为最近最火的前端开发工具,也确实对得起那个价格,但是秉着勤俭节约的传统美德,我们肯定是能省则省啊。 方法一：（更新时间：2018/4/8）v3.3 不一定长期有效注册时，在打开的License Activation窗口中选择“License server”，在输入框输入下面的网址： http://180.76.140.202:9123 (2018/07/20) http://idea.wrbugtest.tk/ (2018/06/16) 点击：Activate即可。 方法二：获取注册码（推荐）打开网址IntelliJ IDEA 注册码，我们能看到下面的界面，直接点击获取激活码，将生成的激活码粘贴到WebStorm激活对话框中的Lisence Code输入框，点击OK即可破解。 方法三：使用破解补丁（推荐）首先下载补丁，看图！ 最新版本下载地址：IntelliJ IDEA 注册码 第一步:将补丁复制到安装目录的bin目录下 \...\WebStorm\bin PS：一定要把这个jar包复制到这个bin目录，不然后面操作可能无法进行。 第二步：修改同目录下的 WebStorm.vmoptions 用文本编辑器打开之后，在文件最上面加一行代码 ： -javaagent: D:/Program Files (x86)/JetBrains/WebStorm/bin/破解补丁名字.jar 第三步：配置好之后，保存文件。在此再次启动WebStorm，选择activation code，并将-javaagent:你的WebStorm路径前缀/WebStorm/bin/破解补丁名字.jar 方法四:自己搭建IntelliJ IDEA授权服务器这个比较繁琐,喜欢折腾的人可以试试: IntelliJ IDEA License Server本地搭建教程 ilanyu’s大牛的博客里有详细的步骤 如果有更好的方法,欢迎留言交流。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome的控制台,Console命令的各种用法你真的都已经了解了吗？]]></title>
    <url>%2Fposts%2F8910c6e9.html</url>
    <content type="text"><![CDATA[前言作为前端工程师，我们每天都离不开用控制台调试代码，console.log也成了我们最常用的命令，那除了用console.log，还有许多console的方法可以使用，熟练掌握它们，可以让我们在控制台看到的信息更美观准确，也会大大提高我们的开发效率哦，下面就跟小肆一起来看看吧. Chrome的控制台大部分常用浏览器都有各自的控制台，不过小肆用着最习惯的还是Chrome的控制台，打开chrome，win系统按F12，mac系统按command+option+J就可以呼出控制台了，切换到Console标签就能看到如下信息： 我们可以看到，baidu还在控制台给我们留了个小彩蛋，我想这个彩蛋也是为我们程序员同学留的吧。让我们先学第一个命令清除控制台来开始吧。 清除控制台在chorme下清除控制台的方法有很多： 输入console.clear()命令或clear()命令 使用快捷键 Control + J 或 Command + K 点击控制台左上角第二个图标 🚫 显示信息的命令console.log('技术放肆聊') // 输出普通信息console.info('技术放肆聊') // 输出提示信息console.warn('技术放肆聊') // 输出警告信息console.error('技术放肆聊') // 输出错误信息console.debug('技术放肆聊') // 输出调试信息 console.log、console.info、console.debug这三个命令可以理解为一个，我们只需要用console.log就行，并且chrome还不支持console.debug命令。 console.warn命令输出警告信息，信息前带有黄色警告符号。console.error输出错误信息，信息前带有红色错误符号，表示出错，同时会显示错误发生的堆栈。上段代码在chrome控制台输出效果如下: 在safari输出效果如下: 占位符console上述的命令支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）: 占位符 作用 %s 字符串 %d or %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 //字符(%s)console.log("%s","技术放肆聊");//整数(%d或%i)console.log("%d年%d月%d日",2019,1,6); //浮点数(%f)console.log("PI=%f",3.1415926); 显示效果如下： %o、%O 都是用来输出 Object 对象的，对普通的 Object 对象，两者没区别，但是打印dom节点时就不一样了： %c 占位符是最常用的。使用 %c 占位符时，对应的后面的参数必须是 CSS 语句，用来对输出内容进行 CSS 渲染。常见的输出方式有两种：文字样式、图片输出。 信息分组console.group()用于将显示的信息分组，可以把信息进行折叠和展开。console.groupEnd()结束内联分组 将对象以树状结构展现console.dir()可以显示一个对象所有的属性和方法. 显示某个节点的内容console.dirxml()用来显示网页的某个节点(node)所包含的html/xml代码 判断变量是否是真console.assert()用来判断一个表达式或变量是否为真，此方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 计时功能console.time()和console.timeEnd()，用来显示代码的运行时间 console.time("控制台计时器");for(var i = 0; i &lt; 10000; i++)&#123; for(var j = 0; j &lt; 10000; j++)&#123;&#125; &#125;console.timeEnd("控制台计时器"); 性能分析performance profileconsole.profile()和console.proileEnd()用来分析程序各个部分的运行时间，找出瓶颈所在。 function All()&#123; for(var i = 0; i &lt; 10; i++)&#123; funcA(100); &#125; funcB(1000); &#125; function funcA(count)&#123; for(var i = 0; i &lt; count; i++)&#123;&#125;; &#125;function funcB(count)&#123; for(var i = 0; i &lt; count; i++)&#123;&#125;;&#125;console.profile("性能分析器");All();console.profileEnd(); 详细的信息在chrome控制台里的”profile”选项里查看 console.count()统计代码被执行的次数function myFunction()&#123; console.count("myFunction 被执行的次数");&#125;myFunction(); //myFunction 被执行的次数: 1myFunction(); //myFunction 被执行的次数: 2myFunction(); //myFunction 被执行的次数: 3 console.table表格显示方法 总结合理的利用console的各种方法，会使我们的调试过程更加愉悦，今天的分享就到这里了，记得右下角点好看呦！ 转自：https://mp.weixin.qq.com/s/8jcqYIPZGQVsLo3fou41Zw]]></content>
      <categories>
        <category>前端</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强力推荐！那些你不能错过的GitHub插件和工具]]></title>
    <url>%2Fposts%2Ff033121.html</url>
    <content type="text"><![CDATA[以代码托管平台起家的 GitHub 网站，已然成为全球程序员工作和生活中不可或缺的一份子。从优秀的企业，到优秀的程序员，都将自己最优秀的代码作品存放在这片开源净土里，供彼此学习交流。 GitHub Trending 栏目甚至已经成为 IT 从业人员的新闻日报，每日必读。 既然 GitHub 这么重要，又被我们使用得这么频繁，那关于 GitHub 的一些优秀浏览器插件或者其他工具，我们就一定不可错过啦。本文就来整理一些，都是我平常使用最得心应手的东西，全都倾力推荐出来，绝对干货！ Chrome 扩展程序 备注：这个分类的部分均可以在 Chrome 应用商店 搜索得到，也可以直接点击小标题直接跳转至插件详情页。 Octotree 很好奇的是，GitHub 作为代码托管平台，竟然没有提供项目目录，方便用户在线快速浏览项目结构。所以，在线分析项目源码就会变得很繁琐，必须一层一层点击，然后再一次一次地向上返回。要知道，本来 GitHub 网站在中国区的访问就已经很慢了。最无奈的做法就是，下载到本地，再使用 Sublime 等编辑器打开。 Octotree 作为 Chrome 浏览器的一款插件，刚好解决这个使用痛点。他能够像 IDE 一样提供项目目录，快捷导航，方便浏览。同时支持 GitHub 和 GitLab 两个常用的代码托管网站。更贴心的是，你可以自行选择是否显示目录。 GitHub Plus 同样作为 Chrome 的插件，GitHub Plus 提供的功能也是非常实用。能够显示代码仓库的大小，以及其中每个文件的大小和下载链接。使用这款插件，我们再也不用因为需要某个单一文件而被迫下载整个项目源码，尤其是在网速不给力的时候。 GitHub Hovercard 使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。有点类似 StackOverflow 网站的用户头像的鼠标悬停效果。Hovercard 插件支持的悬停位置更多，包括用户头像，仓库地址，Issue 链接，个人主页等。咱们还是用图说话比较直接： Sourcegraph for GitHub 代码搜索，查看引用，自动跳转，项目目录导航，这些 IDE 上常用的功能操作，借助 Sourcegraph 插件，都能帮你直接在线使用。如图： Octo Mate 这款插件提供的功能与前面提到的 GitHub Plus 有点类似，展示项目大小，任意文件点击下载等。如图： Awesome Autocomplete for GitHub GitHub 智能搜索插件。有点类似自动补全功能，实时监听输入的搜索关键字，自动列出相关内容。正如官方介绍那样，致力于打造 GitHub 上最好的搜索引擎，助你在搜索仓库和用户方面，比以往更快人一步。 Isometric Contributions 3D 像素立体展示 GitHub 上的仓库提交记录。相比传统的方块图表，更有美感。当然，使用这款插件之后，你可以自由切换展示方式，而不是一刀切。 高效率管理工具 前面提到的都是 Chrome 的插件系列，基本上可以解决平时我们使用 GitHub 在线搜索或者浏览某一仓库时所遇到的痛点问题。但是还有一个很重要的痛点没有解决，那就是我们 Star 过的仓库管理问题。 任何一个 IT 领域，GitHub 网站都有成千上万个优秀开源项目可供参考学习。所以，收藏关注几十几百个项目是再平常不过的一件事了。没有标签，没有便捷的检索功能，如何高效率地管理这些关注过的项目呢？也许你可以尝试这些网站提供的工具。 OhMyStar2 强力推荐 OhMyStar2 客户端，号称是管理 GitHub Stars 最好的方式。自动同步 GitHub 账号的 Stars，拥有标签和评分两种分类方式助你分组管理项目，根据名称、日期等指标自动排序，三方分享功能，甚至提供每日 Trending 浏览，说是最好，名符其实！ Astral 也是提供标签式的方式管理 GitHub 账号关注的项目。只不过，通过网站在线管理，没有提供 PC 版客户端。免费试用。 Insight.io 这个工具使用起来有点类似 IDE，提供开发中常用的快速导航、代码搜索功能、查看引用和点击跳转等功能。 我想，有了这些工具，一定能大幅提高我们程序员使用 GitHub 时的效率。工欲善其事，必先利其器。站在巨人的肩膀上，更容易事半功倍。利用好工具，换种角度来看，也是一种不可忽视的能力。 从事 IT 行业以来，越发觉得，互联网对于我们每个人来说，都是公平的，如何开拓视野，利用网络平台提升自己的学习能力和工作效率，显得尤为重要。很庆幸，我们都在这个最潮流的行业，共同学习，一起进步。 备注：更多开发中的优秀 Chrome 插件，可访问我的 GitHub 仓库地址：https://github.com/zhangmiaocc/powerful-chrome-plugins]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediaMetadataRetriever获取网络/本地视频第一帧图片]]></title>
    <url>%2Fposts%2Ff0cf7486.html</url>
    <content type="text"><![CDATA[获取视频第一帧图片，这种需求不多，项目中用到了这个功能踩了点坑，很骚。 获取网络视频MediaMetadataRetriever mmr = new MediaMetadataRetriever();//后面这个是传请求Headers，如果有需要可以添加mmr.setDataSource(url, new HashMap()); 获取本地视频(setDataSource中不需要传第二个参数，直接传路径就好)MediaMetadataRetriever mmr = new MediaMetadataRetriever();//后面这个是传请求Headers，如果有需要可以添加mmr.setDataSource(path, new HashMap()); 封装的代码如下：public class MediaUtils &#123; public static final int MEDIA_TYPE_IMAGE = 1; public static final int MEDIA_TYPE_VIDEO = 2; public static File file; /** * Create a file Uri for saving an image or video */ public static Uri getOutputMediaFileUri(Context context, int type) &#123; Uri uri = null; //适配Android N if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; return FileProvider.getUriForFile(context, context.getApplicationContext().getPackageName() + ".provider", getOutputMediaFile(type)); &#125; else &#123; return Uri.fromFile(getOutputMediaFile(type)); &#125; &#125; /** * Create a File for saving an image or video */ public static File getOutputMediaFile(int type) &#123; // To be safe, you should check that the SDCard is mounted // using Environment.getExternalStorageState() before doing this. File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), "image"); // This location works best if you want the created images to be shared // between applications and persist after your app has been uninstalled. // Create the storage directory if it does not exist if (!mediaStorageDir.exists()) &#123; if (!mediaStorageDir.mkdirs()) &#123; return null; &#125; &#125; // Create a media file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); File mediaFile; if (type == MEDIA_TYPE_IMAGE) &#123; mediaFile = new File(mediaStorageDir.getPath() + File.separator + "IMG_" + timeStamp + ".jpg"); &#125; else if (type == MEDIA_TYPE_VIDEO) &#123; mediaFile = new File(mediaStorageDir.getPath() + File.separator + "VID_" + timeStamp + ".mp4"); &#125; else &#123; return null; &#125; file = mediaFile; return mediaFile; &#125; /** * 获取视频的第一帧图片 */ public static void getImageForVideo(String videoPath, OnLoadVideoImageListener listener) &#123; LoadVideoImageTask task = new LoadVideoImageTask(listener); task.execute(videoPath); &#125; public static class LoadVideoImageTask extends AsyncTask&lt;String, Integer, File&gt; &#123; private OnLoadVideoImageListener listener; public LoadVideoImageTask(OnLoadVideoImageListener listener) &#123; this.listener = listener; &#125; @Override protected File doInBackground(String... params) &#123; MediaMetadataRetriever mmr = new MediaMetadataRetriever(); String path = params[0]; if (path.startsWith("http")) //获取网络视频第一帧图片 mmr.setDataSource(path, new HashMap()); else //本地视频 mmr.setDataSource(path); Bitmap bitmap = mmr.getFrameAtTime(); //保存图片 File f = getOutputMediaFile(MEDIA_TYPE_IMAGE); if (f.exists()) &#123; f.delete(); &#125; try &#123; FileOutputStream out = new FileOutputStream(f); bitmap.compress(Bitmap.CompressFormat.JPEG, 90, out); out.flush(); out.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mmr.release(); return f; &#125; @Override protected void onPostExecute(File file) &#123; super.onPostExecute(file); if (listener != null) &#123; listener.onLoadImage(file); &#125; &#125; &#125; public interface OnLoadVideoImageListener &#123; void onLoadImage(File file); &#125;&#125; 因为考虑到处理视频比较耗时，上面代码使用了AsycTask+Callback的方式来实现，先保存到本地后在加载本地的图片。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷炫的Activity切换动画，打造更好的用户体验]]></title>
    <url>%2Fposts%2F908dd83e.html</url>
    <content type="text"><![CDATA[毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。 我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码： Intent intent=new Intent(this,SecondActivity.class);startActivity(intent);overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim); 在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊： ​ 先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。 1 使用内置Activity之间切换动画代码步骤Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示： enter：用于决定第一次打开当前Activity时的动画 exit : 用于决定退出当前Activity时的动画 reenter: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画 shared elements:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果 那么应该怎么去使用Activity切换动画呢？我们看看使用步骤： 1.首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画 getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 2.接下来就是加载切换动画 其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。 Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode); 3.告诉Window，当前的Activity在什么情况下使用上面的动画 上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果： //退出时使用getWindow().setExitTransition(explode);//第一次进入时使用getWindow().setEnterTransition(explode);//再次进入时使用getWindow().setReenterTransition(explode); 当然了，你也可以不使用代码的方式，直接在你使用的主题&lt;style&gt;标签里添加类似如下代码： &lt;item name="android:windowExitTransition"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowEnterAnimation"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowReenterTransition"&gt;@transition/explode&lt;/item&gt; 4.调用startActivity 跟我们之前使用的startActivity(Intent intent);不同，这里多了一个参数Bundle，我们是先通过makeSceneTransitionAnimation函数创建一个ActivityOptions对象，再将其转为Bundle对象: startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); 整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~ 2 Explode效果Explode即爆炸效果，使用Explode效果很简单，在res/transition目录下新建一个xml文件(如explode.xml)，内容如下： &lt;explode xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; 其中duration表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200~500毫秒比较合适。我们看看效果吧~ 3 Slide效果即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如slide.xml)，内容如下： &lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot; android:slideEdge=&quot;end&quot;/&gt; 其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧 GIF 效果看的比较死板，可以下载我的源码实际运行一下~ 如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定： &lt;slide xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:interpolator/decelerate_cubic" android:slideEdge="end"&gt; &lt;targets&gt; &lt;target android:excludeId="@android:id/navigationBarBackground" /&gt; &lt;target android:excludeId="@android:id/statusBarBackground" /&gt; &lt;/targets&gt;&lt;/slide&gt; 4 Fade效果Fade效果即淡化效果，使用淡化效果依然是很简单，在res/transition目录下新建一个xml文件(如fade.xml)，内容如下： &lt;fade xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~ 5 Shared Element效果即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下： 从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~ 接下来我们看看如何实现这个效果： 1.将两个Activity中需要过渡的View加上android:transitionName属性 两个View的android:transitionName属性取值要一致，比如： 第一个Activity布局： &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:id="@+id/firstSharedView" android:layout_width="100dp" android:layout_height="100dp" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 第二个Activity布局： &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:layout_width="match_parent" android:layout_height="300dp" android:layout_alignParentBottom="true" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 两个绿色的View都添加android:transitionName属性，并且取名一致。 2.调用startActivity ActivityOptions的makeSceneTransitionAnimation函数第一个参数Activity没啥解释的，第二个参数就是第一个Activity中的View对象，第三个参数就是两个Activity的View的 android:transitionName属性的值。 startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView, "sharedView").toBundle()); 现在就可以实现这种Shared Element效果啦，但是可能你会想实现同时让两个View有这样的效果，可是makeSceneTransitionAnimation函数却只能让我们设置一个View和一个transitionName属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。 除了需要将两个Activity中需要过渡的View对应取相同的名称外，还需将需要过渡的View和transitionName取值对应的String这两个对象封装到一个Pair对象中： Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView)); 然后调用ActivityOptionsCompat类的makeSceneTransitionAnimation的另一个重载函数makeSceneTransitionAnimation(Activity activity, Pair&lt;View, String&gt;... sharedElements)，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。 ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second); 最后调用startActivity ActivityCompat.startActivity(this, intent, transitionActivityOptions.toBundle()); 说了这么多步骤，我们来看看效果吧~ 多个子View的过渡效果 5.1 自定义 Shared Element切换动画如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下： 1.创建一个View的过渡移动的轨迹路径PathMotion类 我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看【ArcMotion官方文档】 ArcMotion arcMotion = new ArcMotion();arcMotion.setMinimumHorizontalAngle(50f);arcMotion.setMinimumVerticalAngle(50f); 2.定义ChangeBounds类 我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数： 1.ViewGroup sceneRoot：屏幕根View，即DecorView，第二个Activity的DecorView。 TransitionValues startValues ：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数captureStartValues里放置，因此你可以重写captureStartValues函数，并把你自定义的属性动画中的属性放进去。 TransitionValues endValues ：与startValues类似，表示属性动画结束时的属性值。可以通过重写captureEndValues函数，并把你自定义的属性动画里面的最终属性值放进去。 我们先看一个最简单的示例： package com.zm.util;import android.animation.Animator;import android.transition.ChangeBounds;import android.transition.TransitionValues;import android.view.ViewGroup;import android.view.animation.AnimationUtils;public class CustomChangeBounds extends ChangeBounds &#123; @Override public Animator createAnimator(final ViewGroup sceneRoot, TransitionValues startValues, final TransitionValues endValues) &#123; Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues); if (startValues == null || endValues == null || changeBounds == null) return null; changeBounds.setDuration(300); changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(), android.R.interpolator.fast_out_slow_in)); return changeBounds; &#125;&#125; 看看效果吧~ 参考资料：https://labs.ribot.co.uk/exploring-meaningful-motion-on-android-1cd95a4bc61d#.cf6pub9xu https://github.com/hitherejoe/animate]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity切换动画常用实现方式]]></title>
    <url>%2Fposts%2Fa8391ded.html</url>
    <content type="text"><![CDATA[一. overridePendingTransition()：此方式只需要在启动另一个activity和退出activity的时候调用就行，这个方法接收两个参数，一个是新启动的activity进入时的动画，另一个是当前activity消失时的动画。 启动： startActivity(newIntent(MainActivity.this,TestActivityWithTheme.class));overridePendingTransition(R.anim.open_in, R.anim.open_out); 退出： @Override public void finish() &#123; super.finish(); overridePendingTransition(R.anim.close_in, R.anim.close_out); &#125; 二. ActivityOptionsCompat：这个类是supportv4中新加的一个类，可以为activity添加各种动画效果，这里面的api至少要求4.0以上的系统，部分要求5.0以上，谷歌为我们封装好了的一些拉伸扩散动画，共享元素动画等等，下面只介绍一种简单效果的实现方式， 启动： ActivityOptionsCompat compat = ActivityOptionsCompat.makeCustomAnimation(MainActivity.this, R.anim.open_in, R.anim.open_out);ActivityCompat.startActivity(MainActivity.this,intent, compat.toBundle()); 退出： Overridepublic void onBackPressed() &#123; super.onBackPressed(); ActivityCompat.finishAfterTransition(this);&#125; 注意：该退出方法不能达到预期的动画效果，还需要使用第一种方式实现退出overridePendingTransition(R.anim.close_in, R.anim.close_out); 三.AppTheme: 直接在主题中修改activity动画样式：我们可以在 AndroidManifest.xml 文件中，通过Android:theme 属性设置 Activity 的主题。主题中可以定义 Activity 的切换动画。这是应用 Activity 切换动画的一种方法。下面是通过主题来设置 Activity 间的切换动画的实现方式。 3.1、定义包含动画的 Activity 主题res/values/styles.xml &lt;style name="AnimActivityTheme" parent="@android:style/Animation.Activity"&gt; &lt;item name="android:windowAnimationStyle"&gt;@style/MyWindowAnimTheme&lt;/item&gt;&lt;/style&gt; 就是使用 windowAnimationStyle 这个属性，指定切换动画的style即可。 3.2、定义切换动画 styleres/values/styles.xml &lt;style name="MyWindowAnimTheme"&gt; &lt;item name="android:activityOpenEnterAnimation"&gt;@anim/top_to_bottom_in&lt;/item&gt; &lt;item name="android:activityOpenExitAnimation"&gt;@anim/top_to_bottom_out&lt;/item&gt; &lt;item name="android:activityCloseEnterAnimation"&gt;@anim/bottom_to_top_in&lt;/item&gt; &lt;item name="android:activityCloseExitAnimation"&gt;@anim/bottom_to_top_out&lt;/item&gt;&lt;/style&gt; 下面具体介绍这4个属性的意思，假设我们有 2 个 Activity，分别是 A 和 B： A 启动 B 时，A 从屏幕上消失，这时执行的是A的 android:activityOpenExitAnimation A 启动 B 时，B 出现在屏幕上，这时执行的是B的 android:activityOpenEnterAnimation 从 B 返回A时，B从屏幕上消失，这时执行的是B的 android:activityCloseExitAnimation 从 B 返回A时，A 出现在屏幕上，这时执行的是A的 android:activityCloseEnterAnimation 3.3、定义具体动画文件 res/anmi/res/top_to_bottom_in.xml res/anmi/res/top_to_bottom_out.xml res/anmi/res/bottom_to_top_in.xml res/anmi/res/bottom_to_top_out.xml 这里不再介绍动画文件的实现。 3.4、应用到对应 ActivityAndroidMenifest.xml &lt;activity android:name=".MainActivity" android:theme="@style/AnimActivityTheme”&gt; 3.5、另外在使用AppTheme设置动画时发现了两个问题，3.5.1、添加动画后，出现从黑屏到新activity的过度。原因：没有设置相应的消失动画。 解决方法：设置相应的消失动画，如果不想设置消失动画，可以使用写一个假动画，这个动画是没有任何效果，只是为了避免出现黑屏，运行效果为原acticity静止不动，新启动的activity执行进入动画。 3.5.2、没有动画，或动画与设置不一致原因：当页面切换时需要进入和消失两个动画，当没有进入动画时，消失动画也不会执行，会执行系统动画，如果没有系统动画则没有动画，或者某个页面使用第一或第二种方式设置了动画（动画执行优先级，系统动画 &lt; AppTheme &lt; (overridePendingTransition\ActivityOptionsCompat)）。 解决方法：为了保证进入和消失都有动画，要将动画主题设置到两个Activity上。也可以将主题设置到application上，这样整个应用都是用该切换动画。如果是某个页面使用第一或第二种方式设置了动画，那么在启动和退出时最好都要设置，不然会造成启动和退出不一致的情况。 总结：第一种方式：灵活可以随意控进入消失动画，但是实现不方便。第二种方式：与第一种方式类似，但是该种方式为我们提供了多种特殊动画。第三种方式：使用方便，只需要配置主题，不需要添加过多代码，但是不够灵活 建议：定义一种动画主题，并设置到application上，将整个应用的切换动画统一，如果某个页面有特殊要求，再根据不用需求使用第一或第二种类型单独处理。]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android横竖屏切换]]></title>
    <url>%2Fposts%2Fa6a76007.html</url>
    <content type="text"><![CDATA[Android开发中，大多APP可能根据实际情况直接将APP的界面方向设死了，或竖屏或横屏。但是，我们还是会遇到横竖屏切换的功能需求，不管是通过物理重力感应触发，还是用户手动触发。所以，我们有必要去弄清楚Android中横竖屏切换到底做了什么。 Follow me …… 一、android:screenOrientation &amp; android:configChanges android:screenOrientation是用来设置 activity在设备上的显示方向的，只能是下面的唯一值： 值 描述 unspecified 默认值。系统自动选择屏幕方向 behind 跟activity堆栈中的下面一个activity的方向一致 landscape 横屏方向，显示的宽比高长 portrait 竖屏方向，显示的高比宽长 sensor 由设备的物理方向传感器决定，如果用户旋转设备，这屏幕就会横竖屏切换 nosensor 忽略物理方向传感器，这样就不会随着用户旋转设备而横竖屏切换了（”unspecified”设置除外） user 用户当前首选的方向 reverseLandscape API 9 以上，反向横屏 reversePortrait API 9 以上，反向竖屏 sensorLandscape API 9 以上，横屏，但是可以根据 物理方向传感器来切换正反向横屏 sensorPortrait API 9 以上，竖屏，但是可以根据 物理方向传感器来切换正反向竖屏 fullSensor API 9 以上，上下左右四个方向，由物理方向传感器决定 locked API 18 以上，锁死当前屏幕的方向 如果你上传应用到 Google Play，需要注意以下提示： Note: When you declare one of the landscape or portrait values, it is considered a hard requirement for the orientation in which the activity runs. As such, the value you declare enables filtering by services such as Google Play so your application is available only to devices that support the orientation required by your activities. For example, if you declare either”landscape”, “reverseLandscape”, or “sensorLandscape”, then your application will be available only to devices that support landscape orientation. However, you should also explicitly declare that your application requires either portrait or landscape orientation with the element. For example, . This is purely a filtering behavior provided by Google Play (and other services that support it) and the platform itself does not control whether your app can be installed when a device supports only certain orientations. android:configChanges用来设置 activity配置改变（不仅仅是屏幕方向，还有语言、地区等等）的集合。当一个配置改变在运行中发生时，activity默认情况下会先销毁然后重新创建。但是，如果通过这个属性声明了某个配置后，将可以避免上面的情况，而是依然运行，并回调 onConfigurationChanged()) 方法。该属性可以设置多个值： 值 描述 mcc IMSI移动台的国家代码（MCC）发生变化——一个SIM被探测到并且更新MCC mnc IMSI移动台的网络代码（MNC）发生变化——一个SIM被探测到并且更新MNC locale 区域发生变化——用户选择了一个文本需要显示的新语言 keyboard 键盘类型发生变化——例如：用户插入了外接键盘。 keyboardHidden 键盘的可访问性发生变化——例如：用户发现了硬件键盘。 screenLayout 屏幕布局发生变化——这个会导致显示不同的Activity。 orientation 屏幕方向发生变化——用户旋转了屏幕。注意：如果应用程序的目标API级别是13或更高（通过属性minSdkVersion和属性targetSdkVersion声明），你也需要声明配置项screenSize，因为这将在设备选择肖像和屏幕方向时发生改变。 screenSize 当前可用屏幕大小发生变化。这代表一个当前可用大小的变化，和当前的比率相关，因此当用户选择不同的画面和图像，会发生变化。然而，如果你的程序目标API级别是12或更低，你的Activity总是会自己处理这个配置变化（这个变化不会引起Activity的重启，甚至在Android 3.2或更新的设备上）。在API级别13里加入的。 smallestScreenSize 物理屏幕大小的变化。不管方向的变化，仅仅在实际物理屏幕打包变化的时候，如：外接显示器。这个配置项的变化引起在smallestWidth configuration里的变化。然而，如果你的程序目标API级别是12或更低，你的Activity将自己处理这个变化（这个变化不会引起Activity的重启，甚至在Android 3.2或更新的设备上）在API级别13里加入的。 layoutDirection 布局方向变化。例如书写方式从左向右（LTR）转换为从右向左（RTL） 想了解更多就看官方文档。 二、横竖屏切换对Activity生命周期的影响通过打印Activity各个生命周期的执行情况，我们根据以下几种情况来分析： 1. 不配置 configChanges2. 配置 android:configChanges=&quot;orientation&quot;3. 配置android:configChanges=&quot;orientation|keyboardHidden&quot; 竖屏切横屏 11-02 20:17:44.898 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-02 20:17:45.008 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-02 20:17:45.008 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-02 20:17:45.018 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-02 20:17:45.038 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 横屏切竖屏： 11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-02 20:19:00.318 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 从上面的 3种方式配置 打印的 Log （三种方式 Log是一样的，故合并显示），我们可以总结如下： 不设置Activity的android:configChanges时，或 设置Activity的android:configChanges=&quot;orientation&quot;时，或设置Activity的android:configChanges=&quot;orientation|keyboardHidden&quot;时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次方法。 而我们经常在其他地方看到的结论如下： 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 4. 所以是什么原因导致我们的结论不一样呢？需要说明的是： 我的测试环境是 targetSdkVersion 24，测试模拟器是 系统API 5.0！ 查看官方文档，发现有如下提示： 注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本系统的应用时，若要避免由于设备方向改变而导致运行时重启（正如 minSdkVersion 和 targetSdkVersion 属性中所声明），则除了”orientation”值以外，您还必须添加 “screenSize”值。即，您必须声明 android:configChanges=”orientation|screenSize”。但是，如果您的应用是面向 API 级别 12 或更低版本的系统，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重启 Activity）。 我们现在测试第四种配置方式。 5. 配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 竖屏切横屏 11-02 20:44:06.568 7792-7792/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 横屏切竖屏 11-02 20:44:52.918 7792-7792/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 结论： 从 API 13开始，配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，才不会销毁 activity，且只调用 onConfigurationChanged方法。 6. 横竖屏切换小结 （一）、Android 3.2 （API 级别 13）以前1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 注意： 不设置Activity的android:configChanges时，切换竖屏activity的各个生命周期执行两次，有人说是 在API 2.x下，我未测试，大家可以考证下。 （二）、从 Android 3.2 (API级别 13)开始1、不设置Activity的android:configChanges，或设置Activity的android:configChanges=&quot;orientation&quot;，或设置Activity的android:configChanges=&quot;orientation|keyboardHidden&quot;，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次。2、配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，才不会销毁 activity，且只调用 onConfigurationChanged方法。 三、代码中动态切换横竖屏在代码中切换屏幕的方向主要调用 setRequestedOrientation（int requestedOrientation） 方法，此方法的作用等同于在 AndroidManifest.xml设置Activity 的android:screenOrientation，所以，其可传递的参数如 android:screenOrientation表格中一样。 示例代码： findViewById(R.id.btn_click).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.d(TAG,"被点击了"); //判断当前屏幕方向 if(getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &#123; //切换竖屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125;else&#123; //切换横屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125; &#125;&#125;); 非重启Activity模式：即设置了android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，Log输出（横竖屏切换一样） 11-03 10:38:33.998 20317-20317/com.ys.yoosir.screenconfigchange D/MainActivity: 被点击了11-03 10:38:34.108 20317-20317/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 重启Activity模式：即没有设置android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，Log输出（横竖屏切换一样） 11-03 10:59:23.268 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: 被点击了11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-03 10:59:23.428 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 注意： 通过 setRequestedOrientation（int requestedOrientation） 修改了屏幕方向后，就类似于设置了android:screenOrientation，效果是一样的，比如：调用setRequestedOrientation（ActivityInfo.SCREEN_ORIENTATION_PORTRAIT），无论屏幕怎么旋转，都不会切换屏幕方向。如果要恢复为响应横竖屏随物理方向传感器设备变换，那么就需要手动调用类似setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);代码进行恢复。 四、横竖屏切换我们需要做的事 重启Activity模式在重启Activity模式下，横竖屏切换的时候会导致数据丢失，我们可以通过如下代码来保正数据不丢失： @Overrideprotected void onSaveInstanceState(Bundle outState) &#123; Log.d(TAG," -- onSaveInstanceState"); Log.d(TAG," -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture"); outState.putString("name","yoosir"); outState.putInt("age",24); outState.putBoolean("handsome",true); super.onSaveInstanceState(outState);&#125;.... @Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); Log.d(TAG," -- onRestoreInstanceState"); if(savedInstanceState != null) &#123; String name = savedInstanceState.getString("name"); int age = savedInstanceState.getInt("age"); boolean isHandsome = savedInstanceState.getBoolean("handsome"); Log.d(TAG, " -- onRestoreInstanceState get: name = " + name + ",age = " + age + ",handsome = " + isHandsome); &#125;&#125; 横竖屏切换Log 输出： 11-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture11-03 12:03:31.688 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-03 12:03:31.688 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-03 12:03:31.758 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-03 12:03:31.758 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate get: name = yoosir,age = 24,handsome = true11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState get: name = yoosir,age = 24,handsome = true11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 如上，大家可以看到在 onCreate() 中也是可以拿到我们之前保存的数据的。 补充一点： 如果大家在资源目录res 中添加了 layout-land（横向布局文件夹） 和 layout-port （竖想布局文件夹），重启Activity模式的横竖屏切换，系统会自动帮我们显示正确方向的布局UI。 非重启Activity模式非重启Activity模式下横竖屏切换，我们的Activity 不会销毁重建，数据也不会丢失。但是，如果我们想根据不同的屏幕方向来展示不同UI或做不同的事，应该怎么做呢？直接上代码： @Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.d(TAG," -- onConfigurationChanged"); if(newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)&#123; //切换到竖屏 //修改布局文件 setContentView(R.layout.activity_main); //findViewById .... //TODO something Log.d(TAG," -- onConfigurationChanged 可以在竖屏方向 to do something"); &#125;else&#123; //切换到横屏 //修改布局文件 setContentView(R.layout.activity_main); //findViewById .... //TODO something Log.d(TAG," -- onConfigurationChanged 可以在横屏方向 to do something"); &#125;&#125; 横竖屏切换Log 输出： 11-03 14:56:50.465 28612-28612/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged11-03 14:56:50.495 28612-28612/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 可以在横屏方向 to do something 大家可以看到，在非重启Activity模式下，横竖屏切换修改UI布局文件时，其实挺麻烦的（我是这样的看法，^_~），需要重新初始化一遍UI。不过，不需要我们手动保存数据倒是挺方便的。 五、横竖屏切换对Fragment的影响打印 Activity 和 Fragment 各个生命周期，并在Activity 的 onCreate() 中添加如下代码： //是否已经 add 了 Fragmentif(getSupportFragmentManager().findFragmentByTag("child") == null) &#123; Log.d(TAG, " -- onCreate has no child "); FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction(); blankFragment = BlankFragment.newInstance("one", "two"); fragmentTransaction.add(R.id.root_view, blankFragment, "child"); fragmentTransaction.commit();&#125;else&#123; Log.d(TAG, " -- onCreate has child ");&#125; 重建Activity模式Log： 带有 BlankFragment 即为 Fragment 的打印，其他则为 Activity 的打印进入Activity的Log： 我们可以关注下第 2 行log——-- onCreate has no child 11-03 17:56:19.465 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate - orientation11-03 17:56:19.525 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate has no child 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- newInstance 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onAttach 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreate 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreateView 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStart 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStart11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onResume11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onResume 11-03 17:57:02.285 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- one btn click 11-03 17:57:05.705 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- two btn click 横竖屏切换的Log： 1、我们关注一下 第17行 onCreate has child ，所以 Fragment 本身是没有被 destroy，它的views 是被destroy 的 2、关注一下 第5、6、19 和 20 行，Fragment 的局部变量数据被销毁了，我们可以在onSaveInstanceState 保存数据，虽然 Fragment 不像 Activity 拥有 onRestoreInstanceState 方法，但是我们可以在 onActivityCreated 中获取之前保存的数据。 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onPause 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onPause11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onSaveInstanceState11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onSaveInstanceState 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onSaveInstanceState save str11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStop 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStop11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDestroyView 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDestroy 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDetach 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onDestroy11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onAttach 11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreate 11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate - orientation11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate get: name = yoosir,age = 24,handsome = true11-03 17:57:40.175 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate has child 11-03 17:57:40.175 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreateView 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated get 我设置了参数11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStart 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStart11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onRestoreInstanceState11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onRestoreInstanceState get: name = yoosir,age = 24,handsome = true11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onResume11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onResume 非重建Activity模式：横竖屏切换Log(进入Activity的Log 与 重建Activity模式一样 )：横竖屏切换时，Fragment 和 Activity 都只会调用 onConfigurationChanged 方法。 11-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onConfigurationChanged 11-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged11-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged 可以在横屏方向 to do something11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onConfigurationChanged 11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged 可以在竖屏方向 to do something 六、其他小技巧如果我们应用是手机和平板都可用的，且手机的只能是竖屏不可切换，平板的只能是横屏不可切换。首先，我们要区分设备是手机还是平板，然后设置屏幕方向。代码如下： /** * 判断是否平板设备 * @param context * @return true:平板,false:手机 */private boolean isTabletDevice(Context context) &#123; return (context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) &gt;= Configuration.SCREENLAYOUT_SIZE_LARGE;&#125;//设置屏幕方向private void setScreenOrientation(Context context)&#123; if(!isTabletDevice(context))&#123; //手机，竖屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125;else&#123; //平板，横屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125;&#125; 参考学习的文章：The Real Best Practices to Save/Restore Activity’s and Fragment’s state 《===== 重点推荐阅读 [译] 保存/恢复 Activity 和 Fragment 状态的最佳实践 《=== 上面一篇文章的译文 如何在Android设备旋转时暂存数据以保护当前的交互状态？ Android横竖屏切换小结 附图两张： 小小总结通过一步一步代码验证，我们终于明白了横竖屏切换时发生了什么，又可以愉快的写代码了，啦啦啦…，I AM CODER！若有错误的地方，欢迎大家指正和评论，谢谢！:-)]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awesome-comment神级注释]]></title>
    <url>%2Fposts%2F86664ecf.html</url>
    <content type="text"><![CDATA[一时兴起就收集了以下神注释，希望能为广大ITer带来快乐，缓解你们工作中的压力，下面开车，先自爆头像，下文会给出制作链接。 魔性图 /** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 * 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 * 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 * 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 * 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 * 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 * 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 * 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 * 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己 * 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙 * 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙 * 丶十乙十十丶 丶丶亅十瓦鬼車瓦己 * 丶亅亅丶 亅日瓦日 * 丶 */ 就不卖关子了，图片转字符可以上这个传送门，白底的话会按空格补全，否则都为字符。 前面的传送门貌似出了点问题，下面再补上个新的传送门，也是很好用的，可以选择质量。 这不，下面的两只doge和一头滑稽就是产自于它，have fun，快去制作专属的字符注释吧。 再补上一个好玩的网站Ascii World，由于这网站的图形太多了，我就不贴上来了。 /** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM&amp;59M#As..,,,,:,is, * .rr,,,;9&amp;1 hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s; r9&amp;BMHBHMB9: . .,,,,;ri. * :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */ /** * ii. ;9ABH, * SA391, .r9GG35&amp;G * &amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:&amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB&amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1&amp;@@@@@@MXs. . .,,:,:&amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s&amp;: .... .sS553B@@HX3s;,. .,;13h. .:::&amp;1 * SXr . ...;s3G99XA&amp;X88Shss11155hi. ,;:h&amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi * 1831, .,;irrrrrs&amp;@ * ;5A8r. .:;iiiiirrss1H * :X@H3s....... .,:;iii;iiiiirsrh * r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1 * ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h * 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h * i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111 * 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111 *//** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM&amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;&amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ /** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ *//** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ____/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * * ............................................. * 佛祖保佑 永无BUG *//** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ *//** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ___/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * ............................................. * 佛曰：bug泛滥，我已瘫痪！ *//** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ *//** * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::' * '::::::::::::' * .:::::::::: * '::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::' .:::. * ::::' ':::::' .::::::::. * .::::' :::: .:::::::'::::. * .:::' ::::: .:::::::::' ':::::. * .::' :::::.:::::::::' ':::::. * .::' ::::::::::::::' ``::::. * ...::: ::::::::::::' ``::. * ```` ':. ':::::::::' ::::.. * '.:::::' ':'````.. *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ &gt; &lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! *//** * ___====-_ _-====___ * _--^^^#####// \\#####^^^--_ * _-^##########// ( ) \\##########^-_ * -############// |\^^/| \\############- * _/############// (@::@) \\############\_ * /#############(( \\// ))#############\ * -###############\\ (oo) //###############- * -#################\\ / VV \ //#################- * -###################\\/ \//###################- * _#/|##########/\######( /\ )######/\##########|\#_ * |/ |#/\#/\#/\/ \#/\##\ | | /##/\#/ \/\#/\#/\#| \| * ` |/ V V ` V \#\| | | |/#/ V ' V V \| ' * ` ` ` ` / | | | | \ ' ' ' ' * ( | | | | ) * __\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! *//** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \_|// |||\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \/ ||| \\ _/~~- * __---~~~.==~||\=_ -_--~/_-~|- |\\ \\ _/~ * _-~~ .=~ | \\-_ '-~7 /- / || \ / * .~ .~ | \\ -_ / /- / || \ / * / ____ / | \\ ~-_/ /|- _/ .|| \ / * |~~ ~~|--~~~~--_ \ ~==-/ | \~--===~~ .\ * ' ~-| /| |-~\~~ __--~~ * |-~~-_/ | | ~\_ _-~ /\ * / \ \__ \/~ \__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ '.|||' -_| ~~-/ , . _|| * -_ ~\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\ * 神兽保佑 * 代码无BUG! *//** _ * _._ _..._ .-', _.._(`)) * '-. ` ' /-._.-' ',/ * ) \ '. * / _ _ | \ * | a a / | * \ .-. ; * '-('' ).-' ,' ; * '-; | .' * \ \ / * | 7 .__ _.-\ \ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ '`-' *//** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-" "-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * | "=._"(_ ^^ _)"_.=" | * * | "=\__|IIIIII|__/=" | * * | _.="| \IIIIII/ |"=._ | * * | _ _.="_.="\ /"=._"=._ _ | * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * | &gt; _.=" "=._ &lt; | * * | (_/ \_) | * * | | * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * ************************************************************** *//** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ *//** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ *//** * ,%%%%%%%%, * ,%%/\%%%%/\%% * ,%%%\c "" J/%%% * %. %%%%/ o o \%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%' * // ;%%%%`\-/%%%' * (( / `%%%%%%%' * \\ .' | * \\ / \ | | * \\/ ) | | * \ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |'_ \ * \ V /| |\ V /| | (_| | | | | * \_/ |_| \_/ |_|\__,_|_| |_| *//** * https://gold.xitu.io/ * １１１ １ * １１１ １１１１１１１１１１１１ １１１ * １１ １１１１１１１１１１１１ １１１１１ * １１ １１１ １１ １１１１１１１ * １１１１ １ １１１１１１１１１１１ １１１ １１１１ * １１１１１１ １１１１１１１１１１１ １１１１ １１１１１ * １１１１１１ １１ １１１１ １１１１１１ * １１ １１１１１１１１ １１ １１１１１１１１１１１１１１１１１１ * １１ １１１１１１１１１１１ １１１１１１１１１１１１１１１１１１１ * １１１１１１１１１ １１ １１ １１ １１ * １１１１１１１１１１１１１１１１１１ １１ * １１１１ １１１１１１１１１１１１ １１１１１１１１１１１１１１ * １１１１ １１ １１ １１１１１１１１１１１１１１ * １１ １１ １１ １１ １１１ １１ １１ １１１ * １１ １１ １１ １１ １１ １１１ １１ １１１ * １１ １１１ １１ １１ １１ １１１ １１ １１１ * １１１１ １１１ １１１１１１１１１ １１ １１１ １１ １１１１１１１ * １１１１１１ １１１１１１１１１１ １１１１１１１１１１１１１１１１１ * １１ １１１ １１１ １１１１１１１１１１１１１１１１１ *//** * https://www.zhihu.com/ * _____ _____ _____ _____ * /\ \ /\ \ /\ \ /\ \ * /::\____\ /::\ \ /::\ \ /::\ \ * /:::/ / \:::\ \ /::::\ \ /::::\ \ * /:::/ / \:::\ \ /::::::\ \ /::::::\ \ * /:::/ / \:::\ \ /:::/\:::\ \ /:::/\:::\ \ * /:::/____/ \:::\ \ /:::/__\:::\ \ /:::/__\:::\ \ * /::::\ \ /::::\ \ /::::\ \:::\ \ /::::\ \:::\ \ * /::::::\ \ _____ ____ /::::::\ \ /::::::\ \:::\ \ /::::::\ \:::\ \ * /:::/\:::\ \ /\ \ /\ \ /:::/\:::\ \ /:::/\:::\ \:::\____\ /:::/\:::\ \:::\ \ * /:::/ \:::\ /::\____\/::\ \/:::/ \:::\____\/:::/ \:::\ \:::| |/:::/__\:::\ \:::\____\ * \::/ \:::\ /:::/ /\:::\ /:::/ \::/ /\::/ |::::\ /:::|____|\:::\ \:::\ \::/ / * \/____/ \:::\/:::/ / \:::\/:::/ / \/____/ \/____|:::::\/:::/ / \:::\ \:::\ \/____/ * \::::::/ / \::::::/ / |:::::::::/ / \:::\ \:::\ \ * \::::/ / \::::/____/ |::|\::::/ / \:::\ \:::\____\ * /:::/ / \:::\ \ |::| \::/____/ \:::\ \::/ / * /:::/ / \:::\ \ |::| ~| \:::\ \/____/ * /:::/ / \:::\ \ |::| | \:::\ \ * /:::/ / \:::\____\ \::| | \:::\____\ * \::/ / \::/ / \:| | \::/ / * \/____/ \/____/ \|___| \/____/ *//** * http://www.freebuf.com/ * _.._ ,------------. * ,' `. ( We want you! ) * / __) __` \ `-,----------' * ( (`-`(-') ) _.-' * /) \ = / ( * /' |--' . \ * ( ,---| `-.)__` * )( `-.,--' _`-. * '/,' ( Uu", * (_ , `/,-' ) * `.__, : `-'/ /`--' * | `--' | * ` `-._ / * \ ( * /\ . \. freebuf * / |` \ ,-\ * / \| .) / \ * ( ,'|\ ,' : * | \,`.`--"/ &#125; * `,' \ |,' / * / "-._ `-/ | * "-. "-.,'| ; * / _/["---'""] * : / |"- ' * ' | / * ` | *//** * https://campus.alibaba.com/ * `:::::::::::, * `::;:::::::;:::::::, ` * `::;;:::::::@@@@;:::::::` * ,:::::::::::::@ #@':::::` * :::::::::::::::'@@ @;:::: * ::::::::::::'@@@@'``` .+:::` * ::::::::::;@@@#. ,:::, * .::::::::+@#@` :::: * :::::::+@@' :::: * `:::::'@@: `:::. * ,::::@@: ` :::: * ;::::::@ .:::; * :;:::::;@` ` :::; * :::::::::@` @ ;:::: * :::::::::#` @` ,:::: * :::::::::@` +@ @ .::::` * .::::::'@@` `@@' @ ::::, * :::::::++@@@@@@@@@@. ::::; * ;:::::::+, `..` ::::: * ,::::::::', ::::: * :::::::::+, :::::` * :::::::::+@. ,::::.` `, * ::::::;;@+ .::;:: `; * :::::::@@ `:::;: `::`` * ::::::#@ ;:::: .::` * :::::;@ :::::` .;::` * :::::@ `:;::: `::::; * :::::# :::::. `,;::::: * :::::: ` ::::::,.,::::::::::. * ,::::::` .:: ::::::::::::::::;` * ;::::::::,````.,:::::, ::::::::::::::. * :::::::::::::::::: ` `::::::::::` * `::::::::::::, .:::. * `..` *//** * http://www.flvcd.com/ * .--, .--, * ( ( \.---./ ) ) * '.__/o o\__.' * &#123;= ^ =&#125; * &gt; - &lt; * / \ * // \\ * //| . |\\ * "'\ /'"_.-~^`'-. * \ _ /--' ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 *//** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 *//** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 *//** * /88888888888888888888888888\ * |88888888888888888888888888/ * |~~____~~~~~~~~~"""""""""| * / \_________/"""""""""""""\ * / | \ \ * / | 88 88 \ \ * / | 88 88 \ \ * / / \ | * / | ________ \ | * \ | \______/ / | * /"\ \ \____________ / | * | |__________\_ | | / / * /""""\ \_------' '-------/ -- * \____/,___________\ -------/ * ------* | \ * || | \ * || | ^ \ * || | | \ \ * || | | \ \ * || | | \ \ * \| / /"""\/ / * ------------- | | / * |\--_ \____/___/ * | |\-_ | * | | \_ | * | | \ | * | | \_ | * | | ----___ | * | | \----------| * / | | ----------""\ * /"\--"--_| | | \ * |_______/ \______________/ ) * \___/ *//** * d*##$. * zP"""""$e. $" $o * 4$ '$ $" $ * '$ '$ J$ $F * 'b $k $&gt; $ * $k $r J$ d$ * '$ $ $" $~ * '$ "$ '$E $ * $ $L $" $F ... * $. 4B $ $$$*"""*b * '$ $. $$ $$ $F * "$ R$ $F $" $ * $k ?$ u* dF .$ * ^$. $$" z$ u$$$$e * #$b $E.dW@e$" ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#" . zo$&gt; #$r .uF * $L .u$*" $&amp;$$$k .$$d$$F * $$" ""^"$$$P"$P9$ * JP .o$$$$u:$P $$ * $ ..ue$" "" $" * d$ $F $ * $$ ....udE 4B * #$ """"` $r @$ * ^$L '$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $"" $F * '$ $ * $L $ * '$ $ * $ $ *//** * ,----------------, ,---------, * ,-----------------------, ," ,"| * ," ,"| ," ," | * +-----------------------+ | ," ," | * | .-----------------. | | +---------+ | * | | | | | | -==----'| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ," * | `-----------------' |," .;'| |(((( | ," * +-----------------------+ ;; | | |," * /_)______________(_/ //' | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \,"----------- * / ==ooooooooooooooo==.o. ooo= // ,`\--&#123;)B ," * /_==__==========__==_ooo__ooo=_/' /___________," * *//** * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.' ~. .~ `.__ * .'// \./ \\`. * .'// | \\`. * .'// .-~"""""""~~~~-._ | _,-~~~~"""""""~-. \\`. * .'//.-" `-. | .-' "-.\\`. * .'//______.============-.. \ | / ..-============.______\\`. * .'______________________________\|/______________________________`. * *//** 无可奉告 一颗赛艇 * uJjYJYYLLv7r7vJJ5kqSFFFUUjJ7rrr7LLYLJLJ7 * JuJujuYLrvuEM@@@B@@@B@B@B@@@MG5Y7vLjYjJL * JYjYJvr7XM@BB8GOOE8ZEEO8GqM8OBBBMu77LLJ7 * LJLY7ru@@@BOZ8O8NXFFuSkSu25X0OFZ8MZJ;vLv * YvL7i5@BM8OGGqk22uvriiriii;r7LuSZXEMXrvr * vv7iU@BMNkF1uY7v7rr;iiii:i:i:ii7JEPNBPir * L7iL@BM8Xjuujvv77rr;ri;i;:iiiii:iLXFOBJ: * 7ri@B@MOFuUS2Y7L7777rii;:::::i:iirjPG@O: * 7:1B@BBOPjXXSJvrL7rr7iiii:i::::i;iv5MBB, * r:0@BBM8SFPX2Y77rri::iirri:::::iii75O@G. * 7:SB@BBGqXPk0122UJL::i::r:::i:i;i:v2@Bk. * ri:MB@BBEqEMGq2JLLL1u7.iX51u77LF27iSB@r, * ri,v@B@MB8@qqNEqN1u:5B8BOFE0S7ii7qMB@F:: * ii,J80Eq1MZkqPPX5YkPE@B@iXPE52j7:vBjE7:: * ii:7MSqkS0PvLv7rrii0@L.Z1iLr::ir:rO,vi:: * ii::EZXPSkquLvii:iF@N:.,BUi7ri,::UY;r::: * i::.2ONXqkPXS5FUUEOPP;..iSPXkjLYLLrr:::, * :::,iMXNP0NPLriiLGZ@BB1P87;JuL7r:7ri:::, * :::,.UGqNX0EZF2uUjUuULr:::,:7uuvv77::::. * ::::..5OXqXNJ50NSY;i:.,,,:i77Yvr;v;,,::. * :::,:.jOEPqPJiqBMMMO8NqP0SYLJriirv:.:,:. * ,:,,,.,Zq0P0X7vPFqF1ujLv7r:irrr7j7.,,::. * ,,,....0qk0080v75ujLLv7ri:i:rvj2J...,,,. * ......8@UXqZEMNvJjr;ii::,:::7uuv...,.,,. * .....B@BOvX88GMGk52vririiirJS1i.......,. * .JEMB@B@BMvL0MOMMMO8PE8GPqSk2L:......... * @B@@@B@M@B@L:7PGBOO8MOMOEP0Xri@B@Mk7,... * B@B@BBMBB@B@0::rJP8MO0uvvu7..,B@B@B@B@Z7 * MMBM@BBB@B@B@Br:i,..:Lur:....7@OMMBM@B@@ * 8OOMMMOMMMMBB@B:....,PZENNi..JBOZ8GMOOOO */ 神注释 /** * 这个公司没有年终奖的,兄弟别指望了,也别来了,我准备辞职了 * 另外这个项目有很多*Bug* 你坚持不了多久的,拜拜! */ /** * 1只羊 == one sheep * 2只羊 == two sheeps * 3只羊 == three sheeps * 4只羊 == four sheeps * 5只羊 == five sheeps * 6只羊 == six sheeps * 7只羊 == seven sheeps * 8只羊 == eight sheeps * 9只羊 == nine sheeps * 10只羊 == ten sheeps * 11只羊 == eleven sheeps * 12只羊 == twelve sheeps * 13只羊 == thirteen sheeps * 14只羊 == fourteen sheeps * 15只羊 == fifteen sheeps * 16只羊 == sixteen sheeps * 17只羊 == seventeen sheeps * 18只羊 == eighteen sheeps * 19只羊 == nineteen sheeps * 20只羊 == twenty sheeps * 21只羊 == twenty one sheeps * 22只羊 == twenty two sheeps * 23只羊 == twenty three sheeps * 24只羊 == twenty four sheeps * 25只羊 == twenty five sheeps * 26只羊 == twenty six sheeps * 27只羊 == twenty seven sheeps * 28只羊 == twenty eight sheeps * 29只羊 == twenty nine sheeps * 30只羊 == thirty sheeps * 现在瞌睡了吧，好了，不要再改下面的代码了，睡觉咯~~ */ /** * You may think you know what the following code does. * But you dont. Trust me. * Fiddle with it, and youll spend many a sleepless * night cursing the moment you thought youd be clever * enough to "optimize" the code below. * Now close this file and go play with something else. *//** * 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。 * 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。 * 现在请关闭这个文件去玩点别的吧。 */ /** * somedev1 - 6/7/02 Adding temporary tracking of Login screen * somedev2 - 5/22/07 Temporary my ass *//** * 一些修改1 - 2002/6/7 增加临时的跟踪登录界面 * 一些修改2 - 2007/5/22 我临时的犯傻 */ /** * 程序员1（于2010年6月7日）：在这个坑临时加入一些调料 * 程序员2（于2011年5月22日）：临你个屁啊 * 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕 * 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！ * 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you're died */ /** * For the brave souls who get this far: You are the chosen ones, * the valiant knights of programming who toil away, without rest, * fixing our most awful code. To you, true saviors, kings of men, * I say this: never gonna give you up, never gonna let you down, * never gonna run around and desert you. Never gonna make you cry, * never gonna say goodbye. Never gonna tell a lie and hurt you. *//** * 致终于来到这里的勇敢的人： * 你是被上帝选中的人，是英勇的、不敌辛苦的、不眠不休的来修改我们这最棘手的代码的编程骑士。 * 你，我们的救世主，人中之龙，我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己， * 永远不要哭啼，永远不要说再见，永远不要说谎来伤害自己。 */ /** * Dear maintainer: * * Once you are done trying to 'optimize' this routine, * and have realized what a terrible mistake that was, * please increment the following counter as a warning * to the next guy: * * total_hours_wasted_here = 42 *//** * 亲爱的维护者： * * 如果你尝试了对这段程序进行'优化' * 下面这个计数器的个数用来对后来人进行警告 * * 浪费在这里的总时间 = 42h */ Exception up = new Exception("Something is really wrong.");throw up; //ha ha /** * When I wrote this, only God and I understood what I was doing * Now, God only knows *//*** 写这段代码的时候，只有上帝和我知道它是干嘛的* 现在，只有上帝知道*/ stop(); // Hammertime! // Autogenerated, do not edit. All changes will be undone. // sometimes I believe compiler ignores all my comments// 有时候我相信编译器忽略了我所有的注释 /** * I dedicate all this code, all my work, to my wife, Darlene, who will * have to support me and our three children and the dog once it gets * released into the public. */ // drunk, fix later// 有点晕了，以后再修改 // Magic. Do not touch.// 麻鸡。勿动。 #define TRUE FALSE// Happy debugging suckers // I'm sorry. return 1; # returns 1 /** * Always returns true. */public boolean isAvailable() &#123; return false;&#125; &lt;!-- Here be dragons --&gt;&lt;!-- 前方高能 --&gt; double penetration; // ouch// 自行了解，不方便解释 // To understand recursion, see the bottom of this fileAt the bottom of the file:// To understand recursion, see the top of this file// 想要明白递归须看文件末尾到了文末// 想要明白递归须看文件顶部 /* Please work */ long long ago; /* in a galaxy far far away */// 很久很久以前 在一个遥远的银河中（出自星球大战） // This code sucks, you know it and I know it. // Move on and call me an idiot later.// 你我都知道这代码很烂// 先不要骂我2B了，请先继续往下看 // I am not sure why this works but it fixes the problem.// 虽然我不知道为什么这样管用，但它却是修复了问题 // If this comment is removed the program will blow up// 如果删了此处注释程序就炸了 // This function has been here since 1987. DON'T FXXKING TOUCH IT// 这函数1987年就这在了，别他娘动它 // if i ever see this again i'm going to start bringing guns to work// 如果要是再让我看见这样的代码，也许我会带着一把枪来上班 // no comments for you// it was hard to write// so it should be hard to read// 难写的代码，肯定很难读。因此，我没有注释留给你。 // I will give you two of my seventy-two virgins if you can fix this.// 要是你能修正这个问题的话，我会在我的七十二个处女中挑两个送你 // I am not responsible of this code.// They made me write it, against my will.// 下面的代码，我不负责。因为是他们逼我写的，违背了我的意愿。 /* You are not expected to understand this *//* 你绝不会明白的 */ // I have to find a better job// 看来我需要找份更好的工作了 /** * 这个类是Object的子类 */]]></content>
      <categories>
        <category>Android</category>
        <category>注释模板</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>注释模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构，如何巧妙设计？]]></title>
    <url>%2Fposts%2Fda9c2260.html</url>
    <content type="text"><![CDATA[重构不止是代码整理，它提供了一种高效且受控的代码整理技术 （一）重构原则1、何谓重构对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 另一种解释是：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 2、为何重构改进软件设计：如果没有重构，程序的设计会逐渐变质，重构很像是在整理代码，你所做的就是让所有的东西回到应处的位置上。帮助找到bug：对代码进行重构，可以深入理解代码的作为，在搞清楚程序结构的同时，想不把bug揪出来都难。提高编程速度：良好的设计是快速开发的根本，改善设计、提高可读性，减少错误，这些都是提高质量。 3、何时重构任何情况下我都反对专门拨出时间进行重构。重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地的进行。 三次法则 第一次做某件事情是只管去做；第二次做类似的事情会产生反感；第三次再做类似的事，你就应该重构 最常见的重构时机是想给软件添加新特性的时候； 重构的另个一原动力是：代码的设计无法帮助我轻松的添加所需要的特性 修改错误的时候，review代码的时重构 间接层和重构 计算机科学是这样一门科学：它相信所有的问题都可以通过增加一个间接层来解决。 大多数重构都为程序引入了更多的间接层，重构往往把大型的对象拆成多个小型的对象，把大型的函数拆成多个小型的函数。但是，间接层是一把双刃剑。每次把一个东西分成两份，你就需要多管理一个东西。如果某个对象委托另一个对象，后者又委托另一个对象，程序会愈加难以阅读。 何时不该重构：有时候既有代码实在太混乱，重构它还不如重新写一个来得简单。 重写而非重构的一个清楚讯号是：现有代码根本不能正常运作。 （二）代码的坏味道1、重复代码如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将它们合二为一，程序会变得更好 。 同一个类中有相同的表达式：提炼出重复的代码，然后让两个地方都调用被提炼出来的那一段代码； 两个互为兄弟的子类内含有相同的表达式：提炼出相同代码，将它推入超类内； 两个毫不相干的类中出现：将重复的代码提炼到一个独立的类中。 2、过长的类拥有短函数的对象活得比较好、比较长。 间接层所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型函数支持的。 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。 如何确定提炼哪一段代码？寻找注释是一个很好的技巧。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是提醒你：可以将这段代码替换成一个函数。 条件表达式和循环常常也是提炼的信号。 3、过大的类如果想利用单个类做太多的事情，其内往往就会出现太多实力变量。类内如果有太多代码，也是代码重复、混乱病最终走向死亡的源头。 4、过长参数列太长的参数列难以理解，太多的参数会造成前后不一致、不容易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给函数，大多数修改都将没有必要。 5、发散式变化如果某个类经常因为不同的原因在不同的方向上发生变化，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因为一种变化而需要修改。 6、散弹式修改如果没遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是散弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。 把所有需要修改的代码放进同一个类中，如果眼下没有合适的类可以安置这些代码就创造一个。 7、依恋情结对象技术的要点在于：将数据和对数据的操作行为包装在一起.有一种经典的气味是：函数对某个类的兴趣高过对自己所处类的兴趣。某个函数为了计算某个值，从另一个对象那调用几乎半打的取值函数。 一个函数往往会用到几个类的功能，那么它该置于何处？我们的原则是：判断哪个类拥有最大被此函数使用的数据，然后就把这个函数和那些数据放在一起。 8、数据泥团很多地方看到相同的三四项数据一起出现。这些总是绑在一起出现的数据应该拥有属于他们自己的对象。 首先找到这些数据以字段形式出现的地方，将它们提炼到一个独立的对象中。这么做的直接好处是可以将很多参数列缩短简化函数调用。 9、基本类型偏执对象的一个极大价值在于：它们模糊了横旦与基本数据和体积较大的类之间的界限 对象技术的新手通常不愿意在小任务上运用小对象——结合数值和比重的money类、有一个起始值和一个结束值组成的range类。将原本单独存在的数值替换成对象，从而走出传统的洞窟，进入炙手可热的对象世界。 10、switch惊悚现身面向对象的一个最明显的特征是：少用switch语句一看到switch语句，就应该考虑以多态来替换它。 如果只是在单一函数中有些选择实例，且并不想改动它们，那么多态就有点杀鸡用牛刀了。 11、平行集成体系每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。 12、冗余类某个类原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作，这个时候请让这个类庄严赴义吧。 13、夸夸其谈未来性企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种怀味道就出现了。如果用到了那就值得去做，如果用不到那就不值得，只会挡你的路，所以把它挪开吧。 如果你的某个抽象类其实没有起到太大的作用，函数上的某些参数未被使用…可以移除它们了。 14、令人迷惑的暂时字段某个实例变量仅为某种特定的情况而设。这样的代码让人不易理解。在变量未被使用的情况下猜测当初其设置目的，会让你发疯的。 15、过度耦合消息链如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另个一对象……..这就是消息链。采用这种方式，意味着客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应的修改。 16、中间人封装往往伴随着委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。 17、狎昵关系有时会看到两个类过于亲密，话费太多的时间去探究彼此的private成分。过分狎昵的类必须拆散，帮它们划清界线，从而减少狎昵行径。继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让孩子独立生活了，让他离开继承。 18、异曲同工的类两个函数做同一件事，却有着不同的签名。 19、不完美的类库类库函数构造的不够好，又不能修改它们： 如果只想修改类的一两个函数，可以引入外加函数。如果想要添加一大堆额外行为，建立一个新类包含这些额外行为，让其成为子类。 20、纯稚的数据类纯稚的数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。 封装public字段; 恰当封装容器类字段; 移除不应修改的字段的设置函数; 提炼调用函数以隐藏取值/设值函数; 21、被拒绝的遗赠子类只运用了父类的一部分函数和数据。 为子类建立一个兄弟类,将所有用不到的字段/函数下移至兄弟类,保证超类的纯粹; 22、过多的注释注释之所以存在是因为代码很糟糕 。注释的最高境界——代码即注释。 当你感觉需要撰写注释时，请先尝试重构，试着让所有的注释都变得多余。 （三）重新组织函数1、提炼函数动机：看到一个过长的函数或者一段需要注释才能让人理解用途的代码，将这段代码放一个独立的函数中；做法： 创造一个新函数，根据这个函数的意图来命名它； 只要新函数的名称能够以更好的方式昭示代码意图，你也应该提炼它。但如果想不到一个更有意义的名称就别动 将提炼的代码从原函数复制到新建的目标函数中；将被提炼代码段中需要读取的局部变量，当作参数传递给目标函数；在源函数中，将被提炼代码段替换为目标函数调用。 2、内联函数一个函数的本体与名称同样清楚易懂。在函数调用点插入函数本体，然后移除该函数。动机： 一群组织不甚合理的函数。你可以将它们都内联到一个大函数中，再从中提炼出组织合理的小型函数。使用的太多的间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在委托动作之间晕头转向。 做法： 1、检查函数，确定不具备多态；如果子类继承了这个函数，就不要将此函数内联，因为子类无法复写一个根本不存在的函数。 2、找出这个函数的所有调用点；3、将这个函数的所有调用点都替换成函数本体。3、内联临时变量有一个临时变量，只被一个简单的表达是赋值一次，而它妨碍了其他重构手法。将所有对该变量的引用动作，替换为对它赋值的那个表达式自身double basePrice = anOrder.basePrice();return (base &gt; 10000 ); 替换为： return (anOrder.basePrice &gt; 1000); 4、以查询取代临时变量你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立的函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。 double basePrice = quantity * timePrice;if(basePrice &gt; 1000)&#123; return basePrice * 09.5;&#125; else &#123; return basePrice * 0.98;&#125; 替换为： if(basePrice() &gt; 1000)&#123; return basePrice * 09.5;&#125; else &#123; return basePrice * 0.98;&#125;double basePrice()&#123; return quantity * timePrice;&#125; 临时变量只在所属的函数中可见，如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个份信息，这将带给你极大的帮助，使你能够为这个类编写更清晰的代码。 5、引入注释性变量你有一个复杂的表达式。将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。 if ((platform.toUpperCase().indexOf("MAC") &gt; -1) &amp;&amp; (browser.toUpperCase().indexOf("IE") &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt;0)&#123; //do smothing&#125; 替换为： final boolean isMacOs = platform.toUpperCase().indexOf("MAC") &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf("IE") &gt; -1;final boolean wasResized = resize &gt;0;if(isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123; //do smothing&#125; 表达式有可能非常复杂难以理解。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。 在条件逻辑中，你可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。另一种情况是：在较长的算法中，可以运用临时变量来解释每一步运算的意义。 6、分解临时变量你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。 针对每次赋值，创造一个独立、对应的临时变量。 double temp = 2 * (height + width);System.out.println(temp);temp = height * width;System.out.println(temp); 替换为： double perimeter = 2 * (height + width);System.out.println(perimeter);double area = height * width;System.out.println(area); 如果临时变量被赋值超过一次，就意味着它们在函数中承担了一个以上的责任。如果临时变量承担多个责任，它就应该被替换为多个临时变量。每个变量只承担一个责任，同一个临时变量承担两件不同的事情会令代码阅读者糊涂 7、移除对参数的赋值代码对一个参数进行复制。以一个临时变量取代该参数的位置。 int discount (int inputVal, int quantity, int yearToData)&#123; if(inputVal &gt; 50) inputVal -= 2;&#125; 替换为： int discount (int inputVal, int quantity, int yearToData)&#123; int result = inputVal; if(inputVal &gt; 50) result -= 2;&#125; 如果代码的语义是按引用传递的，请在调用段检查调用后是否还使用了这个参数。 8、替换算法想要把某个算法替换为另一个更清晰的算法。将函数本体替换成为另一个算法。 String foundPerson(String[] people)&#123; for(int i = 0;i &lt; people.length; i++)&#123; if(people[i].equals("Don"))&#123; return "Don"; &#125; if(people[i].equals("John"))&#123; return "John"; &#125; if(people[i].equals("Kent"))&#123; return "Kent"; &#125; &#125; return "";&#125; 替换为： String foundPerson(String[] people)&#123; List candidates = Arrays.asList(new String[]&#123;"Don", "John", "Kent"&#125;); for(int i = 0;i &lt; people.length; i++)&#123; if(candidates.contains(people[i]))&#123; return prople[i]; &#125; &#125; return "";&#125; （四）在对象之间搬移特性在对象设计过程中，决定把责任放在哪儿是即使不是最重要的事，也是最重要的事之一。 常常只使用搬移函数和搬移字段简单地移动对象行为，就可以解决这些问题。如果这两个重构手法都需要用到，我会首先使用搬移字段，再使用搬移方法。 如果一个类承担了太多责任而变得臃肿不堪，这种情况下会使用提炼类将一部分责任分离出去。如果一个类变得太不负责任，使用将类内联化将它融入到另一个类中。 1、搬移函数你的程序中，有个函数与其所驻类之外的另个一类进行跟过的交流：调用后者或被后者调用。在该函数最长引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或者将旧函数完全移除。如果一个类有太多行为，或如果一个类与另一个类有太多合作而高度耦合，就需要搬移函数。可以是系统中的类更简单 2、搬移字段程序中，某个字段被其所驻类之外的另一个类更多的用到。在目标类新建一个字段，修改原字段的所有用户，令他们改用新字段 3、提炼类某个类做了应该由两个类做的事。建立一个新类，将相关字段和函数从就类搬到新类。 4、将类内联化某个类没有做太多的事情，不在承担足够责任，不再有的那单独存在的理由。将这个类的所有特性搬移到另一个类中，然后移除原类。 5、隐藏“委托关系”客户通过一个委托类来调用另一个对象。在服务类上建立客户所需要的所有函数，用来隐藏委托关系。 封装意味每个对象都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的对象就会比较少。 如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数。那么客户就必须知晓这一层委托关系。万一委托关系变化，客户也要相应变化。 6、移除中间人某个类做了过多的简单委托。让客户直接调用委托类。每当客户要使用手委托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受委托类的特性越来越多，这一过程会让你很痛苦。 7、引入外加函数你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。 Date newStart = new Date(year, month, date + 1); 替换为： Date newStart = nextDay(nowDate);private static Date nextDay(Date arg)&#123; retrun new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);&#125; 如果可以修改源码，你可以自行添加一个新函数；如果不能，你就得在客户端编码，补足你要的那个函数 8、引入本地扩展你需要为服务类踢狗一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。 ##（五）重新组织数据 1、自封装字段直接访问一个字段。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。 private int low, high;boolean includes(int arg)&#123; retrun arg &gt;= low &amp;&amp; arg &lt;= high;&#125; 替换为： private int low, high;boolean includes(int arg)&#123; retrun arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();&#125;int getLow()&#123; retrun low;&#125;int getHigh()&#123; return high;&#125; 在“字段访问方式”这个问题上，存在两种截然不同的观点： 在该变量定义所在的类中，你可以自由的访问。 即使在这个类中你也应该只使用访问函数间接访问。*间接访问的好处是：子类可以通过复写一个函数而改变获取数据的途径；它支持更灵活的数据管理方式，例如延迟初始化。 2、以对象取代数据值你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变为对象。 一开始你肯能会用一个字符串来表示“电话号码”概念，但是随后你会发现，电话号码需要“格式化”、“区号”之类的行为。这时候就需要为带替换的数值新建一个类。 3、将值对象改为引用对象你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。 4、将引用对象改为值对象你有一个引用对象，很小且不可改变，而且不易管理。将它变成一个值对象。 5、以对象取代数组你有一个数组，其中的元素各自代表不同的东西。以对象替换数组。对于数组中的每个元素，以一个字段来表示 6、复制“被监视数据”你有一些领域数据置身GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。 7、将单向关联改为双向关联两个类都需要使用对方特性，但其间只有一条单向连接。添加一个反向指针，并使修改函数能够同时更新两条连接。 8、将双向关联改为单向关联两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。 9、以字面常量取代魔数你有一个字面数值，带有特别含义。 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为常量。 10、封装字段你的类中存在一个public字段。将它声明为private，并提供相应的访问函数。 11、封装集合有个函数返回一个集合。让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。 ##（六）简化条件表达式 1、分解条件表达式有一复杂的条件语句。从if、then、else三个段落中分别提炼出独立函数。 2、合并表达式你有一系列条件测试，都得到相同结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼成一个独立函数。 3、合并重复的条件代码在表达式的每个分支上都执行了相同的一段代码。 将这段重复代码搬移到条件表达式之外。 4、移除控制标记在一系列布尔表达式中,某个变量带有”控制标记”的作用。 以break/return语句取代控制标记。 5、以多态取代条件表达式有个条件表达式根据对象类型的不同而选择不同的行为。 将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数 （七）简化函数调用1、函数改名函数的名称未能揭示其用途。 修改函数名称。 2、添加参数某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带仅函数所需信息。 3、移除参数函数本体不再需要某个参数。 去除参数。 4、分离查询函数和修改函数某个函数既返回对象状态值，又修改对象值。 建立两个不同函数,其中一个负责查询,另一个负责修改。 5、令函数携带参数若干函数做了类似的工作，但在函数本体中包含了不同的值。建立单一函数,以参数表达那些不同的值。有这样两个函数：它们做着类似的工作，但因少数几个值致使行为略有不同。在这种情况下，你可以将这些各自分离的函数同一起来，并通过参数来处理那些变化情况，用以简化问题。 6、以明确函数取代参数你有一个函数，其中完全取决于参数值而采用不同行为。 针对该参数的每一个可能值，建立一个独立函数。如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，那么就应该使用本项重构。 7、保持对象完整从某个对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。 8、以函数取代参数对象调用某个函数，并将所得结果作为参数，传递给另一函数，而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该参数，直接调用前一个函数。 9、引入参数对象某些参数总是很自然的同时出现。以一个对象取代这些参数。 10、移除设值函数类中某个字段在对象创建时被设值，然后不再改变。去掉该字段的所有设值函数。 11、隐藏函数某个函数，从来没有被其他任何类用到 。将函数修改为private。 12 、以工厂函数取代构造函数希望在创建对象时不仅仅是做简单的建构动作 。 将构造函数替换为工厂函数。 ##（八）处理概括关系 1、字段上移两个子类拥有相同的字段。将该字段移至超类。 2 、函数上移有些函数在各子类中产生完全相同的结果。将该函数移至超类。 3 、构造函数本体上移各个子类中有一些构造函数本体几乎完全一致 。在超类中新建一个构造函数，并在子类构造函数中调用它。 4、函数下移超类中的某个函数只与部分(而非全部)子类用到。 将函数移到相关的子类中。 5、字段下移超类中的某个字段只被部分(而非全部)子类用到。 将字段移到需要它的子类中。 6、提炼子类类中的某些特性只被某些(而非全部)实例用到。 新建一个子类，将上述部分的特性移到子类中。 7、提炼超类两个类有相似特性。 为这两个类建立一个超类,将相同特性移至超类。 8、提炼接口若干客户使用类接口中的同一子集，或两个类的接口有部分相同。将相同的子集提炼到一个独立接口中。 9、折叠继承体系超类和子类之间无太大区别。 将它们合为一体。 10、塑造模板函数子类中某些函数以相同顺序执行类似操作，但各操作细节略有不同。将操作放进独立函数(保持签名相同)，然后将它们移至超类。 11、以委托取代继承某个子类只使用超类接口中的一部分或根本不需要继承而来的数据。子类新建字段保存超类，调整子类函数为委托超类，取消继承关系。 12、以继承取代委托你在两个类中使用委托关系，并经常为整个接口编写许多极简单的委托函数。`让委托类继承受托类。]]></content>
      <categories>
        <category>Android</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UUID通用唯一识别码]]></title>
    <url>%2Fposts%2Fb4fbe497.html</url>
    <content type="text"><![CDATA[import java.util.UUID; public class UploadUtils &#123; /** * 传入文件的名称，返回的唯一的名称 * 例如：gril.jpg 返回sdjsljfsjdl.jpg * @param filename * @return */ public static String getUUIDName(String filename)&#123; // 先查找 int index = filename.lastIndexOf("."); // 截取 String lastname = filename.substring(index, filename.length()); // 唯一 字符串 fsd-sfsdf-sfsd-sdfsd String uuid = UUID.randomUUID().toString().replace("-", ""); return uuid+lastname; &#125; public static void main(String[] args) &#123; String filename = "girl.jpg"; String uuid = getUUIDName(filename); System.out.println(uuid); &#125;&#125; UUID含义是通用唯一识别码 (Universally Unique Identifier)，这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部份。UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。目前最广泛应用的 UUID，即是微软的 Microsoft’s Globally Unique Identifiers (GUIDs)，而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。 UUID.randomUUID().toString()是javaJDK提供的一个自动生成主键的方法。UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的，是由一个十六位的数字组成,表现出来的形式。由以下几部分的组合：当前日期和时间(UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同)，时钟序列，全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得），UUID的唯一缺陷在于生成的结果串会比较长。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android:label=REPLACE and android:label=REPLACE]]></title>
    <url>%2Fposts%2Fc46aabc2.html</url>
    <content type="text"><![CDATA[Multiple entries with same key: 尝试从tools:replace列表中删除空格。 tools:replace=&quot;android:label,theme,allowBackup,android:icon,android:supportsRtl&quot; 这为我修复了构建错误，但我仍在试图找出为什么忽略空格后的条目.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习]]></title>
    <url>%2Fposts%2Fd3a7443d.html</url>
    <content type="text"><![CDATA[JavaScript权威指南第6版中文版JavaScript高级程序设计（第3版）中文你不知道的 JavaScript（上卷）你不知道的 JavaScript（中卷）你不知道的 JavaScript（下卷）]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo修改永久链接的默认格式]]></title>
    <url>%2Fposts%2F36589e41.html</url>
    <content type="text"><![CDATA[Hexo的永久链接的默认格式是:year/:month/:day/:title/，比如访问站点下某一篇文章时，其路径是 2018/04/12/xxxx/，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。 解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。 安装插件在站点根目录使用 git bash 执行命令： npm install hexo-abbrlink --save 修改站点配置文件打开根目录下的_config.yml 文件，修改如下配置： # permalink: :year/:month/:day/:title/# permalink_defaults:permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 这里将页面都添加了.html的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。 接下来重新部署三连，可以看到我们的文章路径变成了/posts/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation位移渐变组合动画了解一下]]></title>
    <url>%2Fposts%2F91718fcd.html</url>
    <content type="text"><![CDATA[一：需求分析最近要实现一个view上下循环滚动的动画，需要带有位置移动和透明度转变的动画。类似于从A到B发生位移动画，且view逐渐显示。而从B到C发生位移动画，且view渐变暗消失。实现效果如图所示： 二：需求拆分接到这个需求后，首先将需求进行细分，分为位移动画和逐渐变量（变暗）两个部分。对应的Android的动画类分别是TranslateAnimation(位移动画)和AlphaAniamtion(透明度变化动画)。首先先熟悉一下这两种动画。 1：TranslateAnimation 位移动画private void startTranslateAnimation() &#123; /** * 进行位移动画，标准步骤 * 1. 创建位移动画对象 * 构造函数 TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) * 参数含义：相对于原图位置 fromXDelta X轴起点相对于原图偏移 toXDelta X轴终点相对于原图偏移 * fromYDelta Y轴起点相对于原图偏移 toYDelta Y轴终点相对于原图偏移 * 2. 设置动画终点是否保持 setFillAfter ： true 动画结束后留在终点 false:动画结束后返回起点 */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -200.0f); translateAnimation.setFillAfter(true); translateAnimation.setDuration(1000); mTextView.startAnimation(translateAnimation);&#125; 这里需要注意的一个小点：设置FillAfter的值，为true代表动画后View停留在终点位置处，false代表动画结束后返回起点。 2：AlphaAnimation 透明度转变动画private void startAlphaAnimation() &#123; /** * 进行透明度变化动画，标准步骤 * 1. 创建AlphaAnimation动画 * 构造函数 AlphaAnimation fromAlphaVal toAlphaVal */ AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); alphaAnimation.setFillAfter(true); alphaAnimation.setDuration(1000); mTextView.startAnimation(alphaAnimation);&#125; 3：同时完成位移和透明度动画需求private void startAppearanceAnimation() &#123; /** * 核心类 AnimationSet 顾名思义，可以简单理解为将多种动画放在一个set集合里面 * 产生渐渐显示+位移动画，将加速小火箭渐渐显示出来; * */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -200.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); mTextView.startAnimation(animationSet);&#125; 实现叠加的动画效果：这里一定要注意的是，对AnimationSet动画，fillAfter和duration需要在AniamtionSet对象中设置，不要设置单个动画对象上。 4：完成的动画过程（位移+渐渐显示 停留 位移+渐渐隐藏）package com.zm.animationdemo;import android.os.Bundle;import android.os.Handler;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.animation.AlphaAnimation;import android.view.animation.Animation;import android.view.animation.AnimationSet;import android.view.animation.TranslateAnimation;import android.widget.Button;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; TextView tv_text; Button btn; List&lt;String&gt; textList = new ArrayList&lt;String&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_text = findViewById(R.id.tv_text); btn = findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startAppearanceAnimation(); &#125; &#125;); textList.add("Hello World!"); textList.add("Welcome to my blog!"); textList.add("https://zhangmiao.cc"); textList.add("Knowledge is power."); textList.add("Learn and live."); textList.add("可以不成功，但不可以不成长！"); textList.add("加油💪"); &#125; private void startAppearanceAnimation() &#123; /** * 核心类 AnimationSet 顾名思义，可以简单理解为将多种动画放在一个set集合里面 * 产生渐渐显示+位移动画 * */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -50.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); animationSet.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; startDisappearanceAnimation(); &#125; &#125;, 1500); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); tv_text.startAnimation(animationSet); int index = (int) (Math.random() * textList.size()); tv_text.setText(textList.get(index)); &#125; private void startDisappearanceAnimation() &#123; TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, -50.0f, -100.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f, 0.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); animationSet.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; startAppearanceAnimation(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); tv_text.startAnimation(animationSet); &#125;&#125; 总结 位移动画TranslateAnimation实现位移，SetFIllAfter=true可让View停留在动画终点处,false返回动画起点 透明度动画 AlphaAnimation实现透明度变化，可实现View的渐显或者渐隐效果 动画效果可以叠加展示，通过AnimationSet实现。整个动画的fillAfter和duration需要设置在AnimationSet对象上，而不是单个对象单独设置（单独设置不会有效果）]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种获取栈顶Activity的方法]]></title>
    <url>%2Fposts%2F104e2eeb.html</url>
    <content type="text"><![CDATA[有时候，需要获取当前位于栈顶的activity的实例。这里介绍2种方法，以及各自适用的场景。 第一种方法：获取栈顶activity的实例应用场景：项目中，activity都继承于一个BaseActivity，在这个base中，有个广播接收器，收到广播，就弹出一个dialog。现打开多个activity，这个时候，通过三方推送等方法，发出一个广播，base接收到。因为只需要在栈顶的activity弹出，而不是每个activity都弹出，所以，需要获取栈顶activity的实例（即上下文，传给dialog的构造方法），而不能简单的传个this，否则，会导致每个activity都有dialog弹出。 获取方法：在application中 public class MyApplication extends Application &#123; private static MyApplication mInstance; private Activity app_activity = null; @Override public void onCreate() &#123; super.onCreate(); mInstance = this; initGlobeActivity(); &#125; private void initGlobeActivity() &#123; registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; app_activity = activity; Log.e("onActivityCreated===", app_activity + ""); &#125; @Override public void onActivityDestroyed(Activity activity) &#123; app_activity = activity; Log.e("onActivityDestroyed===", app_activity + ""); &#125; /** Unused implementation **/ @Override public void onActivityStarted(Activity activity) &#123; app_activity = activity; Log.e("onActivityStarted===", app_activity + ""); &#125; @Override public void onActivityResumed(Activity activity) &#123; app_activity = activity; Log.e("onActivityResumed===", app_activity + ""); &#125; @Override public void onActivityPaused(Activity activity) &#123; app_activity = activity; Log.e("onActivityPaused===", app_activity + ""); &#125; @Override public void onActivityStopped(Activity activity) &#123; app_activity = activity; Log.e("onActivityStopped===", app_activity + ""); &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; &#125;); &#125; /** * 获取实例 * @return */ public static MyApplication getInstance() &#123; return mInstance; &#125; /** * 公开方法，外部可通过 MyApplication.getInstance().getCurrentActivity() 获取到当前最上层的activity */ public Activity getCurrentActivity() &#123; return app_activity; &#125;&#125; 注意：initGlobeActivity()、getInstance()、getCurrentActivity() 这3个方法 使用方法：在base的展示dialog方法中Activity currentActivity = MyApplication.getInstance().getCurrentActivity();Dialog dialog = new Dialog(currentActivity, R.style.PushDialog); 第二种方法：获取栈顶activity的完整包名应用场景：仅仅为了判断当前activity是不是在栈顶，以便决定要不要弹toast等等。注意：获取到的仅仅是完整包名，判断当前activity在不在栈顶，需要用到String方法中的contains方法等。这个时候需要注意，以免出错。如：栈顶activity名为AB，里面包含A，就认为A是在栈顶，就出错了。最好这个activity的名字很特殊，和其他的没有重合部分 在工具类中创建方法：/** * 获得栈中最顶层的Activity * * @param context * @return */public static String getTopActivity(Context context) &#123; android.app.ActivityManager manager = (android.app.ActivityManager) context.getSystemService(context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = manager.getRunningTasks(1); if (runningTaskInfos != null) &#123; return (runningTaskInfos.get(0).topActivity).toString(); &#125; else return null; &#125; 使用：String topActivity_1 = Util.getTopActivity(this);Log.e("topActivity_1", topActivity_1);]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Viewpager+Fragment动态处理（添加、删除）]]></title>
    <url>%2Fposts%2Fbcdbaf4f.html</url>
    <content type="text"><![CDATA[问题在进行Fragment的添加和删除时，适配器刷新之后发现并没有什么变化，这是为什么呢？ 理解FragmentPagerAdapter 适合少量的页面显示。该类每一个生成的Fragment对象都会储存在内存中，所以适合相对静态、页面少的情况，如果是页面多，且Fragment的处理相对动态（添加、删除等）时，使用FragmentStatePagerAdapter较为适合。 FragmentStatePagerAdapter 适合大量的页面显示，当页面处于不可见时，可能会被销毁，只保留该片段的保存状态。与FragmentPagerAdapter切换页面产生的大量开销对比，这允许了适配器保持与每个被访问页面相关联的更少的存储器。 分析在切换页面时，FragmentPagerAdapter与FragmentStatePagerAdapter对于上上页（预加载默认1，所以取上上页）的处理是不相同的，FragmentPagerAdapter只是销毁对应Fragment的视图，而FragmentStatePagerAdapter则是把Fragment的实例和视图都销毁了。 当我们对页面进行动态处理时，添加（或删除）是对适配器所持有的list对象进行长度的变化，操作完之后就进行适配器的刷新，也就是notifyDataSetChanged方法，先看看该方法： //PagerAdapter.classpublic void notifyDataSetChanged() &#123; synchronized (this) &#123; if (mViewPagerObserver != null) &#123; //根据源码可知mViewPagerObserver的对象是ViewPager里面PagerObserver类的实例 mViewPagerObserver.onChanged(); &#125; &#125; mObservable.notifyChanged(); &#125; //ViewPager.classprivate class PagerObserver extends DataSetObserver &#123; PagerObserver() &#123; &#125; @Override public void onChanged() &#123; //调用的是该方法 dataSetChanged(); &#125; @Override public void onInvalidated() &#123; dataSetChanged(); &#125; &#125; 对FragmentPagerAdapter（或FragmentStatePagerAdapter）执行的方法大概进行注释一下，方便理解，//ViewPager.classvoid dataSetChanged() &#123; // This method only gets called if our observer is attached, so mAdapter is non-null. final int adapterCount = mAdapter.getCount(); mExpectedAdapterCount = adapterCount; boolean needPopulate = mItems.size() &lt; mOffscreenPageLimit * 2 + 1 &amp;&amp; mItems.size() &lt; adapterCount; int newCurrItem = mCurItem; boolean isUpdating = false; //遍历所有item for (int i = 0; i &lt; mItems.size(); i++) &#123; final ItemInfo ii = mItems.get(i); //先调用adapter的getItemPosition方法，获得newPos值 final int newPos = mAdapter.getItemPosition(ii.object); if (newPos == PagerAdapter.POSITION_UNCHANGED) &#123; continue; &#125; if (newPos == PagerAdapter.POSITION_NONE) &#123; mItems.remove(i); i--; if (!isUpdating) &#123; mAdapter.startUpdate(this); isUpdating = true; &#125; //newPos值为PagerAdapter.POSITION_NONE的时候才会执行destroyItem方法 mAdapter.destroyItem(this, ii.position, ii.object); needPopulate = true; if (mCurItem == ii.position) &#123; // Keep the current item in the valid range newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1)); needPopulate = true; &#125; continue; &#125; if (ii.position != newPos) &#123; if (ii.position == mCurItem) &#123; // Our current item changed position. Follow it. newCurrItem = newPos; &#125; ii.position = newPos; needPopulate = true; &#125; &#125; if (isUpdating) &#123; //finishUpdate方法主要是对事务的操作进行commit mAdapter.finishUpdate(this); &#125; Collections.sort(mItems, COMPARATOR); if (needPopulate) &#123; // Reset our known page widths; populate will recompute them. final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = getChildAt(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (!lp.isDecor) &#123; lp.widthFactor = 0.f; &#125; &#125; // setCurrentItemInternal(newCurrItem, false, true); requestLayout(); &#125; &#125; Adapter.getItemPosition方法默认返回的是PagerAdapter.POSITION_UNCHANGED值，如果我们不重写getItemPosition方法，使其返回PagerAdapter.POSITION_NONE的话，那么默认是不操作destroyItem方法的，而在destroyItem方法中，FragmentPagerAdapter和FragmentStatePagerAdapter 对Fragment对象的操作也不一样，上面有说过，FragmentPagerAdapter是只销毁视图，FragmentStatePagerAdapter 是把实例和视图都销毁，就是在destroyItem方法实现的，贴代码：//FragmentPagerAdapter@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Detaching item #" + getItemId(position) + ": f=" + object + " v=" + ((Fragment)object).getView()); //这里是对fragment进行detach操作，fragmentManager中还保存该实例 mCurTransaction.detach((Fragment)object); &#125;//FragmentStatePagerAdapter @Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object + " v=" + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) &#123; mSavedState.add(null); &#125; mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); //而这里是对fragment进行remove，直接在fragmentManager中移除掉 mCurTransaction.remove(fragment); &#125; 解决根据上面的分析，在进行添加删除的时候，我采用了FragmentStatePagerAdapter的子类，进行方法的重写，主要是对该类的两个方法（instantiateItem和destroyItem）进行重写，替换父类的实现，代码如下： package com.voctex.adapter;import android.os.Parcelable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentStatePagerAdapter;import android.support.v4.view.PagerAdapter;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;public class DynamicFragmentAdapter extends FragmentStatePagerAdapter &#123; private FragmentManager mFragmentManager; private List&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;(); public DynamicFragmentAdapter(FragmentManager fm, List&lt;Fragment&gt; list) &#123; super(fm); this.mFragmentManager = fm; if (list == null) return; this.mFragments.addAll(list); &#125; public void updateData(List&lt;Fragment&gt; mlist) &#123; if (mlist == null) return; this.mFragments.clear(); this.mFragments.addAll(mlist); notifyDataSetChanged(); &#125; @Override public Fragment getItem(int arg0) &#123; return mFragments.get(arg0);// &#125; @Override public int getCount() &#123; return mFragments.size();// &#125; @Override public Parcelable saveState() &#123; return null; &#125; @Override public int getItemPosition(Object object) &#123; if (!((Fragment) object).isAdded() || !mFragments.contains(object)) &#123; return PagerAdapter.POSITION_NONE; &#125; return mFragments.indexOf(object); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; Fragment instantiateItem = ((Fragment) super.instantiateItem(container, position)); Fragment item = mFragments.get(position); if (instantiateItem == item) &#123; return instantiateItem; &#125; else &#123; //如果集合中对应下标的fragment和fragmentManager中的对应下标的fragment对象不一致，那么就是新添加的，所以自己add进入；这里为什么不直接调用super方法呢，因为fragment的mIndex搞的鬼，以后有机会再补一补。 mFragmentManager.beginTransaction().add(container.getId(), item).commitNowAllowingStateLoss(); return item; &#125; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; //如果getItemPosition中的值为PagerAdapter.POSITION_NONE，就执行该方法。 if (mFragments.contains(fragment)) &#123; super.destroyItem(container, position, fragment); return; &#125; //自己执行移除。因为mFragments在删除的时候就把某个fragment对象移除了，所以一般都得自己移除在fragmentManager中的该对象。 mFragmentManager.beginTransaction().remove(fragment).commitNowAllowingStateLoss(); &#125; &#125; 结束语 在不断的看源码，查资料，调试程序中，终于是把该问题解决了，网上的资料都说得模棱两可，很多时候都得自己操刀，理解了才是自己的，特别是Fragment在FragmentManager中的mIndex值，有点坑，这里没拿出来说，以后有机会再补补。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Viewpager</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的 Mac 技巧 - 截图，Gif 制作及 App 推荐]]></title>
    <url>%2Fposts%2Fae0ce15d.html</url>
    <content type="text"><![CDATA[概述首先要说明的是，我不可能，也不打算把所有快捷键都列出来。写这篇博文的目的是列出来那些我经常使用的，而且我认为可以显著的提高工作效率的快捷键。所以多少会有些主观色彩 Anyway，老规矩，如果大家有任何疑问、意见或者建议，请在下方留言评论 截图macOS 系统内置了截图功能，每次截图都会发出声音，当然这个声音可以关，后面会提到。基础操作有以下四种（快捷键也可以自定义，后面也会提到）： 1. 截图并保存至桌面Cmd + Shift + 3 截取整个屏幕，并保存截图至桌面Cmd + Shift + 4 截取区域，并保存截图至桌面 激活区域截图之后，鼠标指针会变成下图这样，然后按住拖动就可以了 2. 截图并复制有些时候，截图内容只是我们临时要用一下的，而不打算保存下来。我们只需要： Cmd + Ctrl + Shift + 3 截取整个屏幕并复制Cmd + Ctrl + Shift + 4 截取区域并复制 以上两个快捷键，截图之后，我们只需要 “Cmd” + “v” 就可以随意粘贴了 3. 关于新版 MacBook 的 Touch Bar新版的 MacBook 加入了 Touch Bar，同时系统也为我们提供了截取 Touch Bar 屏幕的快捷键： Cmd + Shift + 6 截取 Touch Bar 显示内容，并保存至桌面Cmd + Ctrl + Shift + 6 截取 Touch Bar 显示内容并复制 4. 一些高级操作a. 截取窗口一个比较常用的功能就是截取某个窗口，不需要用截取区域的快捷键然后拉满整个窗口，只需要在 “Cmd” + [“Ctrl” +] “Shift” + “4” 之后按一下 空格，然后鼠标和窗口就会变成这样： 鼠标会变成红色箭头指的那个照相机形状，要截取的窗口也会变成“选中”模式的颜色。这时候只要单击一下鼠标就可以了直接截取窗口了，要取消的话就按 “ESC”。同样道理，快捷键加上了 “Ctrl” 就会复制这个窗口的截图。如果没加，那就会把这个窗口截图保存至桌面 可能有些人会问，为什么上面的“选中”模式是这么漂（nan）亮（kan）的颜色，在这里就可以设置，颜色是我自己调的，非系统默认： b. 实时调整大小还有一些高级操作，都是在开启区域模式并选中一个区域，松开鼠标按键前可以执行的，这里就简单提一下，感兴趣的朋友可以自己试试： 这时候按住 “空格” 并移动鼠标，就可以保持区域大小不变，同时移动区域 这时候按住 “Shift” 并移动鼠标，就可以保持区域的其他三个边不变，移动一个边的位置 这时候按住 “Alt” 并移动鼠标，就可以对称地调整区域大小 就我个人而言，空格那个我偶尔会用下，不过 “Shift” 和 “Alt” 这两个，我是用的真不多 3. 截图标注我们只需要用自带的 Preview（预览）就可以完成截图标注 对于保存到桌面的截图，首先我们在桌面上单击一下图片，然后直接按下 “空格”。空格键是 macOS 上的 Quick View（快速预览），以后的文章中我们会细说。然后只需要点击下图箭头指的这个 Open with Preview： 然后再点一下箭头指的这个工具箱图标，就可以进行标注了。macOS 为我们提供的标注功能有选取（圆形、矩形及套索）、亮度选取、画笔、几何图形标注（圆形、矩形、箭头等）、文字、签名、调色以及裁剪： 这里不得不提一下亮度选取，这个功能可以根据亮度智能选取背景。举个例子，上面的截图，点击亮度选取，然后按住鼠标，左右（或上下）拖动，就能看到选取区域的变化。选好背景后，我们反转一下选取（快捷键 “Cmd” + “Shift” + “i”），然后直接 “delete”，就得到了这个： 4. 延时截图及 Grab 应用a. Grab有时候我们需要延时截图，macOS 为我们提供了这个功能，只是藏的比较深。我们可以直接用 Alfred 或者 macOS 自带的 Spotlight 搜索到，直接输入 Grab 即可： 回车之后没有打开任何窗口，你可能觉得刚刚是打开了假的 App。但其实，这个 App 本身就是没有 UI 的，只会在 Menu Bar 上面显示一条菜单。我们可以在这里找到延时截图的选项： 点击之后，按照提示操作就好，默认的延时时间是 10 秒。要注意的是，延时截图会截取整个屏幕，不能截区域。我们可以先把图片保存下来，然后再打开 Preview（预览）App 裁剪就好了 b. 个性化默认的延时时间和保存路径都是可以更改的。只要打开 Terminal（终端），然后输入这个命令并执行： screencapture -T 10 screenshot1.jpg 其中，10 就表示延时十秒，”screenshot1” 就是默认的文件名，你可以把它改成其他文件名，也可以给它加上一个文件夹路径用于设置默认的保存位置 5. 截图功能的配置a. 禁用提示音截图提示音是可以关闭的，大家只需要打开 System Preferences，然后选择 Sound (声音)，然后只要把红色箭头指的这个关掉就行： b. 快捷键设置可能有朋友觉得系统自带快捷键好麻烦，讲真，习惯几天就好了。原则上我不是很建议大家自己改，因为如果快捷键设置的不当，就很可能会在某些 App 中产生快捷键冲突。比如，你把截图快捷键改成了 “Ctrl” + “c”，那么恭喜你，以后关闭 Server 只能 “kill ${pid}” 了?。当然，如果你足够熟悉快捷键，改改倒是也无妨，大不了弄乱了直接恢复成默认 我们可以在 “系统设置 -&gt; 键盘 -&gt; 快捷键” 中设定快捷键，先定位到 Services （服务），然后就可以找到设置截图的快捷键了： 就算把这些都关掉，像上图那样，文中之前提到的那些快捷键也都是能用的，因为那些都是系统默认的快捷键。同时，我们注意到这里也提供了延时截图的快捷键，如果你常用这个功能，那不妨也绑定一个快捷键吧，比如 “Cmd” + “Shift” + “5”，方便又好记 c. 截图默认保存路径设置同样，我也不推荐改这个设置，虽然改一下也不会炸。比如你想把截图放到桌面的 myScreenshot 文件夹，那么打开 Terminal（终端），输入： defaults write com.apple.screencapture location ~/Desktop/myScreenshot 然后，记得要重启一下系统的 UI 服务，执行这个命令： killall SystemUiServer 之后，如果你再通过 “Cmd” + “Shift” + “3/4” 截图，图片就会保存在这个文件夹里 macOS 上截图相关的快捷键就介绍到这里，能想到的也就这些了。以下为 App 推荐环节，写给有需要的朋友 截图 App 推荐经常会被问到，Mac 上如何制作 Gif，以及有什么截图 App 可以替代原生的截图工具。这里推荐以下几款，从免费到收费的都有。顺便提一句，Windows 系统自带的截图工具就很方便了，另外 PicPick 也是极好的。可以一直免费试用，不需要去找破解，只是这款 App 没有 Mac 版本 1. 系统截图 App 替代品以下提到的三款软件均免费，至少在标注方面比原生的略胜一筹，详情请点击链接查看 a. 浏览器插件 Awesome ScreenshotAwesome Screenshot 是一款免费的截图工具，非本地 App，只是一个浏览器插件。它支持延时截图区域截图等常用功能。也内置了一个网页版的标注工具 b. Evernote 旗下的 SkitchSkitch | Evernote 也是一款免费的截图 App，标注功能相比 Awesome Screenshot 会稍好一些。如果你用 Evernote（印象笔记），经常需要截图并保存到自己的笔记中，那么这款 App 可能会比较适合你。同时，Skitch 也有 iOS 版本 c. JingJing 同样是一款免费的截图 App，来自 TechSmith 公司，这家公司出品的另一款更为强大的截图工具 SnagIt 会在后文详细说明 2. 制作 Gif经常会被问到，如何在 macOS 上制作 Gif。这里给大家推荐以下几个不错的 App a. LICEcap (收费)LICEcap 是一款老牌的 macOS 系统 Gif 制作工具，不免费。相比其他 App，LICEcap 本身并不提供分享和上传功能，所以我本人并不是很推荐 b. Giphy Capture (免费)GIPHY Capture 是由一个很火的 Gif 分享网站 GIPHY 开发的。一个很方便的功能就是可以直接上传至 giphy.com（可能需要 VPN 才能访问），然后把链接 Share 给朋友就可以了。同样，保存至本地也没问题 3. SnagIt - 全套解决方案我一般的习惯是，如果截图只是为了粘贴到聊天框之类的地方，而且不需要标注的话，就会用系统截图。如果需要标注，或者想要留下来，就会用一个第三方的 App：Snagit)。虽然是付费软件，价格也有点儿高，但我觉得还是很值得购买的。目前我的博客和 GitHub 上的截图、动图都是用这个做的 a. 截图功能SnagIt 在截图方面提供了区域延时截图、全景截图、Expose 模式截图甚至摄像头输入内容截图这些很实用的功能。个人觉得，它 Menu Bar 的 Panel（面板）本身颜值就很高： 而且自带一个颜值更高，功能也更多的图片编辑器： 保存的图片格式也可以自己选择，还可以保存为感人的 Retina 清晰度 b. 编辑功能作为一款付费 App，它确实为我们提供了相比 macOS 原生 Preview 更多的编辑功能。暂且不去比较已有的箭头之类的功能，虽然我还是觉得 SnagIt 里面的元素更好看些，SnagIt 还提供了打码功能，效果嘛，大家可以参考下上面 Grab 那里的配图。放大镜功能也是极好的，突出重点的时候很有用。还有 Stamp（图章），有茫茫多的图章选择，从 PC 键盘按键图章，到 Emoji 表情，再到数学符号和花体英文字母，都可以直接扔到截图上。虽然没有提供直接的拼图工具，但拼起来也不麻烦，裁好图，加上分割线，粘贴到一起就可以了 c. 视频功能首先，SnagIt 可以录制很高清的视频，时长也是没有限制的。支持全屏和区域录制两种模式，同时也可以录制摄像头输入和麦克风输入，这个功能用来录制会议视频应该也是极好的。另一个应用场景就是，我们在一些网站上看到喜欢的视频想留下来，而网站又不提供下载，那我们就可以直接选好视频播放的区域来自己录成视频 d. 上传与同步功能TechSmith 自己提供了 http://screencast.com 和 TechSmith relay 服务，当然我们也可以选择上传到 Google Drive 或者 Dropbox。也以配置自己的 FTP，或者直接扔到 iCloud 文件夹也是没问题的。同样，也可以选择本地文件夹保存，支持命名规则等方面的设置]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础控件ViewFlipper的使用，垂直滚动广告条]]></title>
    <url>%2Fposts%2Fced0f833.html</url>
    <content type="text"><![CDATA[学习，学习，学以致用ViewFlipper是安卓自带的控件，很多人可能很少知道这个控件，这个控件很简单，也很好理解。 从源码可以看出，其实ViewFlipper间接的继承了FrameLayout，也可以说ViewFlipper其实就是个FrameLayout，只不过在内部封装了动画实现和Handler实现一个循环而已。 ViewFlipperDemo ###一、ViewFlipper的布局实现布局的编写很简单，跟普通布局一样的 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ViewFlipper android:id="@+id/marqueeView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginTop="10dip" android:layout_marginBottom="30dip" android:autoStart="true" android:background="#fff" android:flipInterval="3000" android:inAnimation="@anim/anim_marquee_in" android:outAnimation="@anim/anim_marquee_out" android:paddingLeft="30dp"/&gt;&lt;/LinearLayout&gt; 这里介绍ViewFlipper用到的属性，这些属性其实都可以使用代码实现，只不过这里为了代码看上去美观，才放在布局里的 android:autoStart：设置自动加载下一个View android:flipInterval：设置View之间切换的时间间隔 android:inAnimation：设置切换View的进入动画 android:outAnimation：设置切换View的退出动画 下面是ViewFlipper常用的方法介绍，除了可以设置上面的属性之外，还提供了其他方法 isFlipping： 判断View切换是否正在进行 setFilpInterval：设置View之间切换的时间间隔 startFlipping：开始View的切换，而且会循环进行 stopFlipping：停止View的切换 setOutAnimation：设置切换View的退出动画 setInAnimation：设置切换View的进入动画 showNext： 显示ViewFlipper里的下一个View showPrevious：显示ViewFlipper里的上一个View 这里还涉及到两个动画其实就是一个平移的动画，它们都保存在anim文件夹中 anim_marquee_in.xml &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="1500" android:fromYDelta="100%p" android:toYDelta="0"/&gt;&lt;/set&gt; anim_marquee_out.xml &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="1500" android:fromYDelta="0" android:toYDelta="-100%p"/&gt;&lt;/set&gt; 当然，如果你对动画xml比较熟悉，自己可以实现更多好看的效果 ###二、自定义ViewFlipper的广告条当我们准备好了ViewFlipper之后，就应该在ViewFlipper里面添加我们的广告条了，下面是其中一个广告条的布局文件，另外两个雷同，只不过改了文字而已 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="25dip" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/iv_image" android:layout_width="25dip" android:layout_height="25dip" android:src="@mipmap/ic_launcher"/&gt; &lt;TextView android:id="@+id/tv_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dip" android:text="华为王牌亮相，5G+4000万徕卡"/&gt;&lt;/LinearLayout&gt; ###三、代码为ViewFlipper添加广告条所有的准备条件都准备好了，该开始使用代码将准备好的东西黏在一起了，代码很简单，这里就不多解释了 package com.zm.viewflipperdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.LayoutInflater;import android.view.View;import android.widget.TextView;import android.widget.ViewFlipper;public class MainActivity extends AppCompatActivity &#123; private ViewFlipper marqueeView; private String[] textArray = &#123;"华为王牌亮相，5G+4000万徕卡", "圣诞来袭，扫码关注领取大礼！", "2018即将过去，说说您的心里话"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; marqueeView = findViewById(R.id.marqueeView); &#125; private void initData() &#123; LayoutInflater inflater = LayoutInflater.from(this); for (int i = 0; i &lt; textArray.length; i++) &#123; View view = inflater.inflate(R.layout.marquee_scroll_content, null); TextView text = view.findViewById(R.id.tv_text); text.setText(textArray[i]); marqueeView.addView(view); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewFlipper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View获取width和height的四种方法]]></title>
    <url>%2Fposts%2Fdd1673d3.html</url>
    <content type="text"><![CDATA[很经常当我们动态创建某些View时，需要通过获取他们的width和height来确定别的view的布局，但是在onCreate()获取view的width和height会得到0.view.getWidth()和view.getHeight()为0的根本原因是控件还没有完成绘制，你必须等待系统将绘制完View时，才能获得。这种情况当你需要使用动态布局（使用wrap_content或match_parent）就会出现。一般来讲在Activity.onCreate(…)、onResume()方法中都没有办法获取到View的实际宽高。所以，我们必须用一种变通的方法，等到View绘制完成后去获取width和Height。下面有一些可行的解决方案。 1、监听Draw/Layout事件：ViewTreeObserverViewTreeObserver监听很多不同的界面绘制事件。一般来说OnGlobalLayoutListener就是可以让我们获得到view的width和height的地方.下面onGlobalLayout内的代码会在View完成Layout过程后调用。 view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; mScrollView.post(new Runnable() &#123; public void run() &#123; view.getHeight(); //height is ready &#125; &#125;); &#125;&#125;); 但是要注意这个方法在每次有些view的Layout发生变化的时候被调用（比如某个View被设置为Invisible）,所以在得到你想要的宽高后，记得移除onGlobleLayoutListener： 在 SDK Lvl &lt; 16时使用public void removeGlobalOnLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim) 在 SDK Lvl &gt;= 16时使用public void removeOnGlobalLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim) 2、将一个runnable添加到Layout队列中：View.post()这个解决方案是我最喜欢的，但是几乎没人知道有这个方法。简单地说，只要用View.post()一个runnable就可以了。runnable对象中的方法会在View的measure、layout等事件后触发，具体的参考Romain Guy： UI事件队列会按顺序处理事件。在setContentView()被调用后，事件队列中会包含一个要求重新layout的message，所以任何你post到队列中的东西都会在Layout发生变化后执行。 final View view=//smth;...view.post(new Runnable() &#123; @Override public void run() &#123; view.getHeight(); //height is ready &#125; &#125;); 这个方法比ViewTreeObserver好：1、你的代码只会执行一次，而且你不用在在每次执行后将Observer禁用，省心多了。2、语法很简单参考：http://stackoverflow.com/a/3602144/774398http://stackoverflow.com/a/3948036/774398 3、重写View的onLayout方法这个方法只在某些场景中实用，比如当你所要执行的东西应该作为他的内在逻辑被内聚、模块化在view中，否者这个解决方案就显得十分冗长和笨重。 view = new View(this) &#123; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); view.getHeight(); //height is ready &#125;&#125;; 需要注意的是onLayout方法会调用很多次，所以要考虑好在这个方法中要做什么，或者在第一次执行后禁用掉你的代码。 4、获取固定宽高如果你要获取的view的width和height是固定的，那么你可以直接使用： View.getMeasureWidth()View.getMeasureHeight() 但是要注意，这两个方法所获取的width和height可能跟实际draw后的不一样。官方文档解释了不同的原因： View的大小由width和height决定。一个View实际上同时有两种width和height值。 第一种是measure width和measure height。他们定义了view想要在父View中占用多少width和height（详情见Layout）。measured height和width可以通过getMeasuredWidth() 和 getMeasuredHeight()获得。 第二种是width和height，有时候也叫做drawing width和drawing height。这些值定义了view在屏幕上绘制和Layout完成后的实际大小。这些值有可能跟measure width和height不同。width和height可以通过getWidth()和getHeight获得。 参考链接 https://stackoverflow.com/questions/3591784/getwidth-and-getheight-of-view-returns-0/24035591#24035591]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpannableString之富文本显示效果]]></title>
    <url>%2Fposts%2F9e398b2.html</url>
    <content type="text"><![CDATA[TextViewSpannableString一：简介SpannableString其实和String一样，都是一种字符串类型，SpannableString可以直接作为TextView的显示文本，不同的是SpannableString可以通过使用其方法setSpan方法实现字符串各种形式风格的显示,重要的是可以指定设置的区间，也就是为字符串指定下标区间内的子字符串设置格式。 setSpan(Object what, int start, int end, int flags)方法需要用户输入四个参数，what表示设置的格式是什么，可以是前景色、背景色也可以是可点击的文本等等，start表示需要设置格式的子字符串的起始下标，同理end表示终了下标，flags属性就有意思了，共有四种属性： Spanned.SPAN_INCLUSIVE_EXCLUSIVE 从起始下标到终了下标，包括起始下标Spanned.SPAN_INCLUSIVE_INCLUSIVE 从起始下标到终了下标，同时包括起始下标和终了下标Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 从起始下标到终了下标，但都不包括起始下标和终了下标Spanned.SPAN_EXCLUSIVE_INCLUSIVE 从起始下标到终了下标，包括终了下标 SpannableString的setSpan()方法可以同时使用多个，实现多种效果叠加。 二：Span常用的格式2.1：ForegroundColorSpan ForegroundColorSpan，为文本设置前景色，效果和TextView的setTextColor()类似，实现方法如下： SpannableString spannableString = new SpannableString("设置文字的前景色为淡蓝色");ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor("#0099EE"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 设置的区间是9到字符串的最后，也就是图中“淡蓝色”三字。 2.2：BackgroundColorSpan BackgroundColorSpan，为文本设置背景色，效果和TextView的setBackground()类，实现方法如下： SpannableString spannableString = new SpannableString("设置文字的背景色为淡绿色");BackgroundColorSpan colorSpan = new BackgroundColorSpan(Color.parseColor("#AC00FF30"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.3：RelativeSizeSpan RelativeSizeSpan，设置文字相对大小，在TextView原有的文字大小的基础上，相对设置文字大小，实现方法如下： SpannableString spannableString = new SpannableString("万丈高楼平地起");RelativeSizeSpan sizeSpan01 = new RelativeSizeSpan(1.2f);RelativeSizeSpan sizeSpan02 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan03 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan04 = new RelativeSizeSpan(1.8f);RelativeSizeSpan sizeSpan05 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan06 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan07 = new RelativeSizeSpan(1.2f);spannableString.setSpan(sizeSpan01, 0, 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan02, 1, 2, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan03, 2, 3, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan04, 3, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan05, 4, 5, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan06, 5, 6, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan07, 6, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.4：StrikethroughSpan StrikethroughSpan，为文本设置中划线，也就是常说的删除线，实现方法如下： SpannableString spannableString = new SpannableString("为文字设置删除线");StrikethroughSpan strikethroughSpan = new StrikethroughSpan();spannableString.setSpan(strikethroughSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.5：UnderlineSpan UnderlineSpan，为文本设置下划线，具体实现方法如下： SpannableString spannableString = new SpannableString("为文字设置下划线");UnderlineSpan underlineSpan = new UnderlineSpan();spannableString.setSpan(underlineSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.6：SuperscriptSpan SuperscriptSpan，设置上标，具体实现方法如下： SpannableString spannableString = new SpannableString("为文字设置上标");SuperscriptSpan superscriptSpan = new SuperscriptSpan();spannableString.setSpan(superscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 从效果图可以看出，被设置为上标的文字大小和下面的文本文字大小一样，只要我们稍加修饰，结合RelativeSizeSpan设置小字体文本作为上标，分分钟实现指数公式有木有，再也不用2^2+3^2=13这样缺乏审美的数学公式了，是不是超实用？ 2.7：SubscriptSpan SubscriptSpan，设置下标，功能与设置上标类似，不做过多描述，具体实现方法如下： SpannableString spannableString = new SpannableString("为文字设置下标");SubscriptSpan subscriptSpan = new SubscriptSpan();spannableString.setSpan(subscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.8：StyleSpan StyleSpan，为文字设置风格（粗体、斜体），和TextView属性textStyle类似，实现方法如下： SpannableString spannableString = new SpannableString("为文字设置粗体、斜体风格");StyleSpan styleSpan_B = new StyleSpan(Typeface.BOLD);StyleSpan styleSpan_I = new StyleSpan(Typeface.ITALIC);spannableString.setSpan(styleSpan_B, 5, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(styleSpan_I, 8, 10, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString); 2.9：ImageSpan ImageSpan，设置文本图片，实现方法如下： SpannableString spannableString = new SpannableString("在文本中添加表情（表情）");Drawable drawable = getResources().getDrawable(R.mipmap.a9c);drawable.setBounds(0, 0, 42, 42);ImageSpan imageSpan = new ImageSpan(drawable);spannableString.setSpan(imageSpan, 6, 8, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 这一个是不是很炫酷？再加一个解析算法，将文本中特定的文本转换成特定的表情图片，分分钟实现聊天表情显示效果有木有啊朋友们！ 3.0：ClickableSpanClickableSpan，设置可点击的文本，设置这个属性的文本可以相应用户点击事件，至于点击事件用户可以自定义，就像效果图显示一样，用户可以实现点击跳转页面的效果，具体实现方法如下： SpannableString spannableString = new SpannableString("为文字设置点击事件");MyClickableSpan clickableSpan = new MyClickableSpan("https://zhangmiao.cc/");spannableString.setSpan(clickableSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696")); textView.setText(spannableString); class MyClickableSpan extends ClickableSpan &#123; private String content; public MyClickableSpan(String content) &#123; this.content = content; &#125; @Override public void updateDrawState(TextPaint ds) &#123; ds.setUnderlineText(false); &#125; @Override public void onClick(View widget) &#123; Intent intent = new Intent(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString("content", content); intent.putExtra("bundle", bundle); startActivity(intent); &#125;&#125; 代码中我们自定义MyClickableSpan类，继承至ClickableSpan，并重写其中一些方法。ds.setUnderlineText()控制是否让可点击文本显示下划线，很明显，在上面代码中我选择了false，不显示下滑写。onClick点击事件的具体实现方法写在其中。如上代码，我们重写ClickableSpan的onClick方法实现Activity的跳转效果，并传递跳转数据。 注意：使用ClickableSpan的文本如果想真正实现点击作用，必须为TextView设置setMovementMethod方法，否则没有点击相应，至于setHighlightColor方法则是控制点击是的背景色。 URLSpanURLSpan，设置超链接文本，其实聪明的小伙帮在讲到ClickableSpan的时候就能实现超链接文本的效果了，重写onClick点击事件就行，也确实看了URLSpan的源码，URLSpan就是继承自ClickableSpan，也和想象中一样，就是重写了父类的onClick事件，用系统自带浏览器打开链接，具体实现方法如下： SpannableString spannableString = new SpannableString("为文字设置超链接");URLSpan urlSpan = new URLSpan("https://zhangmiao.cc/");spannableString.setSpan(urlSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString); URLSpanonClick事件的源码如下： @Overridepublic void onClick(View widget) &#123; Uri uri = Uri.parse(getURL()); Context context = widget.getContext(); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName()); try &#123; context.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Log.w("URLSpan", "Actvity was not found for intent, " + intent.toString()); &#125;&#125; 除此之外，还有MaskFilterSpan可以实现模糊和浮雕效果，RasterizerSpan可以实现光栅效果，因为以上两个使用频率不高，而且效果也不是很明显，就不做详细说明，有兴趣的小伙伴不妨去试一试。 SpannableStringBuilder应该有不少开发的小伙伴知道StringBuilder，可以使用append()方法实现字符串拼接，非常方便。同样，SpannableString中也有SpannableStringBuilder，顾名思义，就是实现对，SpannableString的一个拼接效果，同样是append()方法，可以实现各种风格效果的SpannableString拼接，非常实用。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SpannableString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android跳转权限设置界面的终极适配（支持各大定制ROM）]]></title>
    <url>%2Fposts%2F559aa4a0.html</url>
    <content type="text"><![CDATA[前言： 当我们的用户使用App时不小心拒绝了某项必要权限，而导致无法正常使用。这时候希望重新去打开该权限，那么问题来了，Android厂家定制的room五花八门，很多时候却发现找不到权限管理的入口。为了解决这一问题，如果我们应用中直接提供权限管理入口给用户，是不是会很方便的解决用户这一困扰呢?经过一番研究，整理出了大部分国产手机直接打开权限管理界面的方法 权限界面的跳转一般项目中我们都会通过一个类来管理我们的Permission，即PermissionPageUtils /** * 权限请求页适配，不同手机系统跳转到不同的权限请求页 * * @author Donkor */public class PermissionPageUtils &#123; private final String TAG = "PermissionPageManager"; private Context mContext; //自己的项目包名 private String packageName="com.zm.demo"; public PermissionPageUtils(Context context) &#123; this.mContext = context; &#125; public void jumpPermissionPage() &#123; String name = Build.MANUFACTURER; L.e(TAG, "jumpPermissionPage --- name : " + name); switch (name) &#123; case "HUAWEI": goHuaWeiMainager(); break; case "vivo": goVivoMainager(); break; case "OPPO": goOppoMainager(); break; case "Coolpad": goCoolpadMainager(); break; case "Meizu": goMeizuMainager(); break; case "Xiaomi": goXiaoMiMainager(); break; case "samsung": goSangXinMainager(); break; case "Sony": goSonyMainager(); break; case "LG": goLGMainager(); break; default: goIntentSetting(); break; &#125; &#125; private void goLGMainager()&#123; try &#123; Intent intent = new Intent(packageName); ComponentName comp = new ComponentName("com.android.settings", "com.android.settings.Settings$AccessLockSummaryActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private void goSonyMainager()&#123; try &#123; Intent intent = new Intent(packageName); ComponentName comp = new ComponentName("com.sonymobile.cta", "com.sonymobile.cta.SomcCTAMainActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private void goHuaWeiMainager() &#123; try &#123; Intent intent = new Intent(packageName); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); ComponentName comp = new ComponentName("com.huawei.systemmanager", "com.huawei.permissionmanager.ui.MainActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private static String getMiuiVersion() &#123; String propName = "ro.miui.ui.version.name"; String line; BufferedReader input = null; try &#123; Process p = Runtime.getRuntime().exec("getprop " + propName); input = new BufferedReader( new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); return null; &#125; finally &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return line; &#125; private void goXiaoMiMainager() &#123; String rom = getMiuiVersion(); L.e(TAG,"goMiaoMiMainager --- rom : "+rom); Intent intent=new Intent(); if ("V6".equals(rom) || "V7".equals(rom)) &#123; intent.setAction("miui.intent.action.APP_PERM_EDITOR"); intent.setClassName("com.miui.securitycenter", "com.miui.permcenter.permissions.AppPermissionsEditorActivity"); intent.putExtra("extra_pkgname", packageName); &#125; else if ("V8".equals(rom) || "V9".equals(rom)) &#123; intent.setAction("miui.intent.action.APP_PERM_EDITOR"); intent.setClassName("com.miui.securitycenter", "com.miui.permcenter.permissions.PermissionsEditorActivity"); intent.putExtra("extra_pkgname", packageName); &#125; else &#123; goIntentSetting(); &#125; mContext.startActivity(intent); &#125; private void goMeizuMainager() &#123; try &#123; Intent intent = new Intent("com.meizu.safe.security.SHOW_APPSEC"); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.putExtra("packageName", packageName); mContext.startActivity(intent); &#125; catch (ActivityNotFoundException localActivityNotFoundException) &#123; localActivityNotFoundException.printStackTrace(); goIntentSetting(); &#125; &#125; private void goSangXinMainager() &#123; //三星4.3可以直接跳转 goIntentSetting(); &#125; private void goIntentSetting() &#123; Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts("package", mContext.getPackageName(), null); intent.setData(uri); try &#123; mContext.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void goOppoMainager() &#123; doStartApplicationWithPackageName("com.coloros.safecenter"); &#125; /** * doStartApplicationWithPackageName("com.yulong.android.security:remote") * 和Intent open = getPackageManager().getLaunchIntentForPackage("com.yulong.android.security:remote"); * startActivity(open); * 本质上没有什么区别，通过Intent open...打开比调用doStartApplicationWithPackageName方法更快，也是android本身提供的方法 */ private void goCoolpadMainager() &#123; doStartApplicationWithPackageName("com.yulong.android.security:remote"); /* Intent openQQ = getPackageManager().getLaunchIntentForPackage("com.yulong.android.security:remote"); startActivity(openQQ);*/ &#125; private void goVivoMainager() &#123; doStartApplicationWithPackageName("com.bairenkeji.icaller"); /* Intent openQQ = getPackageManager().getLaunchIntentForPackage("com.vivo.securedaemonservice"); startActivity(openQQ);*/ &#125; /** * 此方法在手机各个机型设置中已经失效 * * @return */ private Intent getAppDetailSettingIntent() &#123; Intent localIntent = new Intent(); localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= 9) &#123; localIntent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); localIntent.setData(Uri.fromParts("package", mContext.getPackageName(), null)); &#125; else if (Build.VERSION.SDK_INT &lt;= 8) &#123; localIntent.setAction(Intent.ACTION_VIEW); localIntent.setClassName("com.android.settings", "com.android.settings.InstalledAppDetails"); localIntent.putExtra("com.android.settings.ApplicationPkgName", mContext.getPackageName()); &#125; return localIntent; &#125; private void doStartApplicationWithPackageName(String packagename) &#123; // 通过包名获取此APP详细信息，包括Activities、services、versioncode、name等等 PackageInfo packageinfo = null; try &#123; packageinfo = mContext.getPackageManager().getPackageInfo(packagename, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; if (packageinfo == null) &#123; return; &#125; // 创建一个类别为CATEGORY_LAUNCHER的该包名的Intent Intent resolveIntent = new Intent(Intent.ACTION_MAIN, null); resolveIntent.addCategory(Intent.CATEGORY_LAUNCHER); resolveIntent.setPackage(packageinfo.packageName); // 通过getPackageManager()的queryIntentActivities方法遍历 List&lt;ResolveInfo&gt; resolveinfoList = mContext.getPackageManager() .queryIntentActivities(resolveIntent, 0); Log.e("PermissionPageManager", "resolveinfoList" + resolveinfoList.size()); for (int i = 0; i &lt; resolveinfoList.size(); i++) &#123; Log.e("PermissionPageManager", resolveinfoList.get(i).activityInfo.packageName + resolveinfoList.get(i).activityInfo.name); &#125; ResolveInfo resolveinfo = resolveinfoList.iterator().next(); if (resolveinfo != null) &#123; // packageName参数2 = 参数 packname String packageName = resolveinfo.activityInfo.packageName; // 这个就是我们要找的该APP的LAUNCHER的Activity[组织形式：packageName参数2.mainActivityname] String className = resolveinfo.activityInfo.name; // LAUNCHER Intent Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); // 设置ComponentName参数1:packageName参数2:MainActivity路径 ComponentName cn = new ComponentName(packageName, className); intent.setComponent(cn); try &#123; mContext.startActivity(intent); &#125; catch (Exception e) &#123; goIntentSetting(); e.printStackTrace(); &#125; &#125; &#125;&#125; 另外：当前已适配测试的机型包括小米，华为，三星，锤子。代码仅供参考。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
        <tag>Android Tips</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Omniplan 5分钟入个门]]></title>
    <url>%2Fposts%2F3df11d4f.html</url>
    <content type="text"><![CDATA[https://xclient.info/s/omni-plan.html 00:00 什么要用omniplan？最近工作当中，对项目交付的要求越来越高了。 这意味着不能像之前那样，做完方案就丢给开发，然后到了指定时间再收获了。 那么怎么掌握项目全部的进度呢，用万能的excel画格子吗？ 画格子 当然在产品经理面前，Excel无所不能，上到画原型，下到数据库管理。但是在面对一个较大的项目的时候，仍然会有一些问题： 我的项目进度到哪了？ 项目瓶颈是什么？ 还有没有更好的项目组织的方案？ 这些问题的答案就是 omniplan。 00:30 打开omniplan看看什么，才过了30秒？是的。 安装下载omniplan可以直接到官网或者mac app store购买下载，对于一个生产力工具来说，价格不算贵。 当然你要是找到了别的渠道来下载……那我是管不着的。 界面 恩，这些红字加的很不优雅，但不重要。 左边是任务列表，可以加分组，中间是时间的甘特图，可以拖拽。上边是面板的切换。 右边是信息列表，可以填写一些更仔细的信息。 相信我，5分钟时间里，你基本是用不到右侧的这些内容的。 01:00 录入任务，分组点击左边的列表，就可以录入任务，打完之后按回车，快速新建下一个任务。 分组 另一个很有用的功能是多选多个任务，新建一个群组。群组的时间和进度会根据子任务计算。 同样的，你也可以拖拽任务上下移，排序，剪切，复制什么的。 01:20 给任务安排时间给任务安排时间很简单，鼠标放到蓝条的最右边，然后拖拽拉长就行。 我们都知道，任务实际上是存在逻辑顺序的，比如得先完成原型，才能做视觉，才能开始开发。 所以我们需要给这些任务加上关联关系： 拖拽这个右边的箭头关联到下一个任务上，就完成了 A任务完成时-B任务开始的逻辑。 omniplan会根据你的任务逻辑关系自动安排时间，看起来不错！ 02:00 节奏好像不对？所有的项目都安排好了时间，但是现在有两个时间上的问题： web上线好像是一个节点而不是一个时间段。 app发版是按固定节奏来的，并不是做完就上线，只有在发版之后，才算是开发完毕。 为了解决这个问题，我们需要另外两个表现任务节点的工具。 里程碑 弹性任务（omniplan中叫做吊床任务） 里程碑是一种没有时间消耗的任务，用来标记一个项目的状态变化，或者把一个大项目拆成若干阶段都是很好用的。 弹性任务很有意思，它自己本身的起点和终点都取决于前后的任务。在这个例子中，直到发版之前，工程师都可以继续对性能调优。 想要切换任务状态很简单，在右边信息面板中切换就行（怎么感觉打自己脸了）。 03:00 谁来负责？完成了所有项目节奏之后，接下来要解决的问题是人员安排的问题（当然你可以先把人员确定之后再安排时间节奏。） 点第二个视图，切换到下一个界面。 这里是资源列表（资源可以是人，也可以是设备，素材等。）考虑到我们的例子是个开发的项目，我添加一些工程师进去吧。 好像全是犬科动物……后面的单位表示这个人是全职（100%工时）。 接下来给他们把工作都分配一下，很简单，用拖动的办法。 这时返回任务面板看一下： 看起来不错！ 04:00 项目在运行项目开始运行起来之后，我们需要时刻关注其中的进度变化。 比如田园犬完成了自己的原型，我们需要在甘特图中标识出来。 拖动这个进度指示器来展示工作的进度。 如果任务建了分组，那么分组的进度也会变化。 04:30 糟糕，项目延误了！这大概是大家都不愿意遇到的问题，项目遇到了一些不按预期进展的情况。 这里假设一下，产品经理这几天状态不好，比实际上用时晚了一天。 本来23号设计师就开始工作了，但是因为产品经理不给力，导致24号才开始。这里我们需要将产品经理的用时拉长一天，其他的任务会一起后移。 怎么体现出来产品经理确实延误了呢？ 我们需要讲一下今天最后一个功能：基线。 这个功能是将当前的项目进度保存一份，方便与实际的进度进行比对。 点击面板切换右边的基线比对选项，直接选择 拆分：实际 vs 基线。 这么一比对就很清晰了 都是产品经理的锅！！ 05:00 结语五分钟时间带着大家飞快的过了一下核心的功能，但是omni家的这些软件其实功能都很强大，还有很多值得研究学习的。 希望大家都能把项目跑的平稳，吃好喝好不加班！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
        <tag>omniplan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genymotion上不能安装APK软件的问题]]></title>
    <url>%2Fposts%2Ff1cdd64c.html</url>
    <content type="text"><![CDATA[Genymotion模拟器不能安装APK的原因官网给出的解释：Genymotion模拟器使用的是x86架构，在第三方市场上的应用有部分不采用x86这么一种架构，所以在编译的时候不通过，报“APP not installed”，可以下载Genymotion提供的ARM转换工具包，将应用市场中的ARM架构的apk转换成Genymotion可以编译的x86架构； 直接安装报错如下图：An error occured while deploying the file.This probably means that the app contains ARM native code and your Genymotion device cannot run ARM instructions. You should either build your native code to x86 or install an ARM translation tool in your device.部署文件时出错。这可能意味着应用程序包含本地ARM代码和你的genymotion设备无法运行ARM指令。你可以建立你的原生代码的x86或在您的设备上安装一个臂的翻译工具。 解决方法1.用Android Studio 创建一个ARM的虚拟机；（当然这个不是你想要的）2.下载Genymotion-ARM-Translation-Librarities工具转换包；下载路径： 链接:https://pan.baidu.com/s/1OOj72JqNnTtSZJnCXCoFzA 密码:p8c4 将下载号的工具包直接拖拽到Genymotion中，然后提示重启模拟器；]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Genymotion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美解决Genymotion无法使用adb命令的问题]]></title>
    <url>%2Fposts%2Fc3520239.html</url>
    <content type="text"><![CDATA[我在运行Genymotion虚拟机进行android应用调试的时候，无法用Powershell(cmd)进入adb shell，显示的界面是这样的： 导致无法正常进行adb调试，找了很多方法都没用，后来修改了genymotion中的settings 中的ADB选项中的SDK路径，保持跟你当前应用的eclipse或者android studio中的SDK库一致，然后问题就解决了；]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Genymotion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活计划]]></title>
    <url>%2Fposts%2Fa5f172c4.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android权限大全]]></title>
    <url>%2Fposts%2Fcf915ee9.html</url>
    <content type="text"><![CDATA[概述Android安全架构规定：默认情况下，任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。这包括读写用户的私有数据（如联系人或电子邮件等）、读写其他应用的文件、执行网络访问、使设备保持唤醒状态等等。如果要使用这些受保护的设备功能，首先要在应用的清单文件(AndroidManifest.xml)中添加一个或多个 标记： &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.app.myapp" &gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; ...&lt;/manifest&gt; 概述 权限 说明 访问登记属性 android.permission.ACCESS_CHECKIN_PROPERTIES 读取或写入登记check-in数据库属性表的权限 获取错略位置 android.permission.ACCESS_COARSE_LOCATION 通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米 获取精确位置 android.permission.ACCESS_FINE_LOCATION 通过GPS芯片接收卫星的定位信息，定位精度达10米以内 访问定位额外命令 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 允许程序访问额外的定位提供者指令 获取模拟定位信息 android.permission.ACCESS_MOCK_LOCATION 获取模拟定位信息，一般用于帮助开发者调试应用 获取网络状态 android.permission.ACCESS_NETWORK_STATE 获取网络信息状态，如当前的网络连接是否有效 访问Surface Flinger android.permission.ACCESS_SURFACE_FLINGER Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 获取WiFi状态 android.permission.ACCESS_WIFI_STATE 获取当前WiFi接入的状态以及WLAN热点的信息 账户管理 android.permission.ACCOUNT_MANAGER 获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 验证账户 android.permission.AUTHENTICATE_ACCOUNTS 允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 电量统计 android.permission.BATTERY_STATS 获取电池电量统计信息 绑定小插件 android.permission.BIND_APPWIDGET 允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 绑定设备管理 android.permission.BIND_DEVICE_ADMIN 请求系统管理员接收者receiver，只有系统才能使用 绑定输入法 android.permission.BIND_INPUT_METHOD 请求InputMethodService服务，只有系统才能使用 绑定RemoteView android.permission.BIND_REMOTEVIEWS 必须通过RemoteViewsService服务来请求，只有系统才能用 绑定壁纸 android.permission.BIND_WALLPAPER 必须通过WallpaperService服务来请求，只有系统才能用 使用蓝牙 android.permission.BLUETOOTH 允许程序连接配对过的蓝牙设备 蓝牙管理 android.permission.BLUETOOTH_ADMIN 允许程序进行发现和配对新的蓝牙设备 变成砖头 android.permission.BRICK 能够禁用手机，非常危险，顾名思义就是让手机变成砖头 应用删除时广播 android.permission.BROADCAST_PACKAGE_REMOVED 当一个应用在删除时触发一个广播 收到短信时广播 android.permission.BROADCAST_SMS 当收到短信时触发一个广播 连续广播 android.permission.BROADCAST_STICKY 允许一个程序收到广播后快速收到下一个广播 WAP PUSH广播 android.permission.BROADCAST_WAP_PUSH WAP PUSH服务收到后触发一个广播 拨打电话 android.permission.CALL_PHONE 允许程序从非系统拨号器里输入电话号码 通话权限 android.permission.CALL_PRIVILEGED 允许程序拨打电话，替换系统的拨号器界面 拍照权限 android.permission.CAMERA 允许访问摄像头进行拍照 改变组件状态 android.permission.CHANGE_COMPONENT_ENABLED_STATE 改变组件是否启用状态 改变配置 android.permission.CHANGE_CONFIGURATION 允许当前应用改变配置，如定位 改变网络状态 android.permission.CHANGE_NETWORK_STATE 改变网络状态如是否能联网 改变WiFi多播状态 android.permission.CHANGE_WIFI_MULTICAST_STATE 改变WiFi多播状态 改变WiFi状态 android.permission.CHANGE_WIFI_STATE 改变WiFi状态 清除应用缓存 android.permission.CLEAR_APP_CACHE 清除应用缓存 清除用户数据 android.permission.CLEAR_APP_USER_DATA 清除应用的用户数据 底层访问权限 android.permission.CWJ_GROUP 允许CWJ账户组访问底层信息 手机优化大师扩展权限 android.permission.CELL_PHONE_MASTER_EX 手机优化大师扩展权限 控制定位更新 android.permission.CONTROL_LOCATION_UPDATES 允许获得移动网络定位信息改变 删除缓存文件 android.permission.DELETE_CACHE_FILES 允许应用删除缓存文件 删除应用 android.permission.DELETE_PACKAGES 允许程序删除应用 电源管理 android.permission.DEVICE_POWER 允许访问底层电源管理 应用诊断 android.permission.DIAGNOSTIC 允许程序到RW到诊断资源 禁用键盘锁 android.permission.DISABLE_KEYGUARD 允许程序禁用键盘锁 转存系统信息 android.permission.DUMP 允许程序获取系统dump信息从系统服务 状态栏控制 android.permission.EXPAND_STATUS_BAR 允许程序扩展或收缩状态栏 工厂测试模式 android.permission.FACTORY_TEST 允许程序运行工厂测试模式 使用闪光灯 android.permission.FLASHLIGHT 允许访问闪光灯 强制后退 android.permission.FORCE_BACK 允许程序强制使用back后退按键，无论Activity是否在顶层 访问账户Gmail列表 android.permission.GET_ACCOUNTS 访问GMail账户列表 获取应用大小 android.permission.GET_PACKAGE_SIZE 获取应用的文件大小 获取任务信息 android.permission.GET_TASKS 允许程序获取当前或最近运行的应用 允许全局搜索 android.permission.GLOBAL_SEARCH 允许程序使用全局搜索功能 硬件测试 android.permission.HARDWARE_TEST 访问硬件辅助设备，用于硬件测试 注射事件 android.permission.INJECT_EVENTS 允许访问本程序的底层事件，获取按键、轨迹球的事件流 安装定位提供 android.permission.INSTALL_LOCATION_PROVIDER 安装定位提供 安装应用程序 android.permission.INSTALL_PACKAGES 允许程序安装应用 内部系统窗口 android.permission.INTERNAL_SYSTEM_WINDOW 允许程序打开内部窗口，不对第三方应用程序开放此权限 访问网络 android.permission.INTERNET 访问网络连接，可能产生GPRS流量 结束后台进程 android.permission.KILL_BACKGROUND_PROCESSES 允许程序调用killBackgroundProcesses(String).方法结束后台进程 管理账户 android.permission.MANAGE_ACCOUNTS 允许程序管理AccountManager中的账户列表 管理程序引用 android.permission.MANAGE_APP_TOKENS 管理创建、摧毁、Z轴顺序，仅用于系统 高级权限 android.permission.MTWEAK_USER 允许mTweak用户访问高级系统权限 社区权限 android.permission.MTWEAK_FORUM 允许使用mTweak社区权限 软格式化 android.permission.MASTER_CLEAR 允许程序执行软格式化，删除系统配置信息 修改声音设置 android.permission.MODIFY_AUDIO_SETTINGS 修改声音设置信息 修改电话状态 android.permission.MODIFY_PHONE_STATE 修改电话状态，如飞行模式，但不包含替换系统拨号器界面 格式化文件系统 android.permission.MOUNT_FORMAT_FILESYSTEMS 格式化可移动文件系统，比如格式化清空SD卡 挂载文件系统 android.permission.MOUNT_UNMOUNT_FILESYSTEMS 挂载、反挂载外部文件系统 允许NFC通讯 android.permission.NFC 允许程序执行NFC近距离通讯操作，用于移动支持 永久Activity android.permission.PERSISTENT_ACTIVITY 创建一个永久的Activity，该功能标记为将来将被移除 处理拨出电话 android.permission.PROCESS_OUTGOING_CALLS 允许程序监视，修改或放弃播出电话 读取日程提醒 android.permission.READ_CALENDAR 允许程序读取用户的日程信息 读取联系人 android.permission.READ_CONTACTS 允许应用访问联系人通讯录信息 屏幕截图 android.permission.READ_FRAME_BUFFER 读取帧缓存用于屏幕截图 读取收藏夹和历史记录 com.android.browser.permission.READ_HISTORY_BOOKMARKS 读取浏览器收藏夹和历史记录 读取输入状态 android.permission.READ_INPUT_STATE 读取当前键的输入状态，仅用于系统 读取系统日志 android.permission.READ_LOGS 读取系统底层日志 读取电话状态 android.permission.READ_PHONE_STATE 访问电话状态 读取短信内容 android.permission.READ_SMS 读取短信内容 读取同步设置 android.permission.READ_SYNC_SETTINGS 读取同步设置，读取Google在线同步设置 读取同步状态 android.permission.READ_SYNC_STATS 读取同步状态，获得Google在线同步状态 重启设备 android.permission.REBOOT 允许程序重新启动设备 开机自动允许 android.permission.RECEIVE_BOOT_COMPLETED 允许程序开机自动运行 接收彩信 android.permission.RECEIVE_MMS 接收彩信 接收短信 android.permission.RECEIVE_SMS 接收短信 接收Wap Push android.permission.RECEIVE_WAP_PUSH 接收WAP PUSH信息 录音 android.permission.RECORD_AUDIO 录制声音通过手机或耳机的麦克 排序系统任务 android.permission.REORDER_TASKS 重新排序系统Z轴运行中的任务 结束系统任务 android.permission.RESTART_PACKAGES 结束任务通过restartPackage(String)方法，该方式将在外来放弃 发送短信 android.permission.SEND_SMS 发送短信 设置Activity观察器 android.permission.SET_ACTIVITY_WATCHER 设置Activity观察器一般用于monkey测试 设置闹铃提醒 com.android.alarm.permission.SET_ALARM 设置闹铃提醒 设置总是退出 android.permission.SET_ALWAYS_FINISH 设置程序在后台是否总是退出 设置动画缩放 android.permission.SET_ANIMATION_SCALE 设置全局动画缩放 设置调试程序 android.permission.SET_DEBUG_APP 设置调试程序，一般用于开发 设置屏幕方向 android.permission.SET_ORIENTATION 设置屏幕方向为横屏或标准方式显示，不用于普通应用 设置应用参数 android.permission.SET_PREFERRED_APPLICATIONS 设置应用的参数，已不再工作具体查看addPackageToPreferred(String)介绍 设置进程限制 android.permission.SET_PROCESS_LIMIT 允许程序设置最大的进程数量的限制 设置系统时间 android.permission.SET_TIME 设置系统时间 设置系统时区 android.permission.SET_TIME_ZONE 设置系统时区 设置桌面壁纸 android.permission.SET_WALLPAPER 设置桌面壁纸 设置壁纸建议 android.permission.SET_WALLPAPER_HINTS 设置壁纸建议 发送永久进程信号 android.permission.SIGNAL_PERSISTENT_PROCESSES 发送一个永久的进程信号 状态栏控制 android.permission.STATUS_BAR 允许程序打开、关闭、禁用状态栏 访问订阅内容 android.permission.SUBSCRIBED_FEEDS_READ 访问订阅信息的数据库 写入订阅内容 android.permission.SUBSCRIBED_FEEDS_WRITE 写入或修改订阅内容的数据库 显示系统窗口 android.permission.SYSTEM_ALERT_WINDOW 显示系统窗口 更新设备状态 android.permission.UPDATE_DEVICE_STATS 更新设备状态 使用证书 android.permission.USE_CREDENTIALS 允许程序请求验证从AccountManager 使用SIP视频 android.permission.USE_SIP 允许程序使用SIP视频服务 使用振动 android.permission.VIBRATE 允许振动 唤醒锁定 android.permission.WAKE_LOCK 允许程序在手机屏幕关闭后后台进程仍然运行 写入GPRS接入点设置 android.permission.WRITE_APN_SETTINGS 写入网络GPRS接入点设置 写入日程提醒 android.permission.WRITE_CALENDAR 写入日程，但不可读取 写入联系人 android.permission.WRITE_CONTACTS 写入联系人，但不可读取 写入外部存储 android.permission.WRITE_EXTERNAL_STORAGE 允许程序写入外部存储，如SD卡上写文件 写入Google地图数据 android.permission.WRITE_GSERVICES 允许程序写入Google Map服务数据 写入收藏夹和历史记录 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS 写入浏览器历史记录或收藏夹，但不可读取 读写系统敏感设置 android.permission.WRITE_SECURE_SETTINGS 允许程序读写系统安全敏感的设置项 读写系统设置 android.permission.WRITE_SETTINGS 允许读写系统设置项 编写短信 android.permission.WRITE_SMS 允许编写短信 写入在线同步设置 android.permission.WRITE_SYNC_SETTINGS 写入Google在线同步设置]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWord Vue项目创建]]></title>
    <url>%2Fposts%2F55860431.html</url>
    <content type="text"><![CDATA[准备 node &amp; npm $ brew install node 检查 node &amp; npm $ node -v$ npm -v vue-cli $ npm install -g vue-cli 或 $ npm install -g @vue/cli @vue/cli-init @vue/cli-service-global 初始化 $ vue create hello-world 根据提示依次输入相关信息↓ 最后出现finished安装完成 ↓ 在终端中运行 ↓ 即可查看初始化完成的效果 cd hello-world/npm run serve 添加依赖项目初始化完成后添加项目常用依赖包 npm install --save vuex axios qsnpm install --save-dev node-sass sass-loader pug pug-loader 包含vuex、axios、qs、sass、pug等，其他依赖包根据项目需求自己选择vue-router在脚手架 init 的时候会提示是否选择安装 完善项目结构添加views文件夹 src 下添加 views 文件夹主要存放页面级的 vue 组件src 下的 components 文件夹主要用于存放通用的组件 在 views 文件夹中创建Home.vue作为主页 删除App.vue中无用的内容，只保留router-view &lt;template&gt; &lt;div id="app"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 如果是移动端项目用 rem 作为单位，可以在src/main.js中添加如下代码做自适应 ↓ if (window.addEventListener) &#123; const html = document.documentElement function setFont() &#123; const k = 750 html.style.fontSize = (html.clientWidth / k) * 100 + 'px' &#125; setFont() setTimeout(function() &#123; setFont() &#125;, 300) document.addEventListener('DOMContentLoaded', setFont, false) window.addEventListener('resize', setFont, false) window.addEventListener('load', setFont, false)&#125; 调整router配置 更多路由相关使用方法请访问：https://router.vuejs.org/zh-cn/ 目录结构 ↓ router ├── index.js # 我们组装模块并导出 store 的地方 └── modules ├── home.js # 首页模块 ├── cart.js # 购物车模块 └── products.js # 产品模块 修改路由主文件router/index.js 使用require.context实现路由去中心化 import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)let router = new Router(&#123; base: '/', // 应用的基路径 mode: 'hash', // "hash" (URL hash 模式) | "history"(HTML5 History 模式) | "abstract" (Node.js 环境) scrollBehavior(to, from, savedPosition) &#123; // 路由切换的滚动行为，只在 HTML5 history 模式下可用 if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125; &#125;, routes: (r =&gt; &#123; // 去中心化 // console.log('r', r); // __webpack_require__ let sourceMap = [] let res = r.keys().map(key =&gt; &#123; let rKey = r(key) sourceMap.push(...rKey.default) // console.log('key', key, rKey); // ./modules/home/route.js // &#123;default: Array(3), __esModule: true&#125; return rKey &#125;) return sourceMap &#125;)(require.context('./', true, /^\.\/modules\/\w+\.js$/)),&#125;)router.beforeEach((to, from, next) =&gt; &#123; // console.log('router beforeEach=&gt;', to, from) // 全局路由切换前执行 // 是否有用户信息，并且用户ID是否存在 // if (window.localStorage.getItem("loginInfo") &amp;&amp; JSON.stringify(window.localStorage.getItem("loginInfo")).userId) &#123; // next(&#123;path: '/login'&#125;)//重定向到登录页面 // &#125; else &#123; // next()//正常跳转 // &#125; next()&#125;)router.afterEach((to, from) =&gt; &#123; // console.log('router afterEach=&gt;', router)&#125;)export default router 在 router 文件夹下添加 modules 文件夹 在 modules 文件夹下添加 home.js ，这个 home.js 对应首页业务模块，首页相关的路由页面都可以写到 home.js 文件里。 如果以后添加其他业务模块，只需要在 modules 文件夹添加相对应的业务模块文件，并在其中添加业务相关的路由页面。这样所有不同业务线的开发人员就可以互不干扰 ↓ import Home from '../../views/Home'const routes = [ &#123; path: '/', name: 'index', redirect: '/home', &#125;, &#123; path: '/home', name: 'home', component: Home, &#125;,]export default routes 对于不需要即时加载的非一级页面可以使用异步路由组件 // region 异步组件 - 路由地址demo// ES 提案的 import（推荐）&#123; name: 'index', path: '/', component: () =&gt; import('../views/index')&#125;,// ES 提案的 import，带分组，指定webpackChunkName，相同的name打包到一个js文件&#123; name: 'index', path: '/', component: () =&gt; import(webpackChunkName:'viewsIndex','../views/index')&#125;,// Webpack 风格的异步组件&#123; name: 'index', path: '/', component: resolve =&gt; require.ensure(['views/Foo.vue'], () =&gt; resolve(require('views/Foo.vue')))&#125;,// Webpack 风格的异步组件，带分组&#123; name: 'index', path: '/', component: resolve =&gt; require.ensure([], () =&gt; resolve(require('views/index.vue')), 'group-index')&#125;,// AMD 风格的异步组件&#123; name: 'index', path: '/', component: resolve =&gt; require(['views/index.vue'], resolve)&#125;,// endregion 添加store文件夹 src 下的 store 文件夹主要是存放 vuex 相关信息的更多 vuex 相关使用方法请访问：https://vuex.vuejs.org/zh-cn/ 在 store 文件夹下创建目录结构 ↓ store ├── index.js # 我们组装模块并导出 store 的地方 ├── getters.js # 根级别的 getter ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── mutation-types.js # 定义链接 action 和 mutation 的方法名常量 └── modules ├── base.js # 首页模块 ├── cart.js # 购物车模块 └── products.js # 产品模块 下面开始改造 store 文件夹 ↓ 在mutation-types.js中添加一个常量 export const BASE = &#123; SET_USER_INFO: 'SET_USER_INFO',&#125; 在action-types.js中添加一个常量 export const BASE = &#123; login: 'login',&#125; 修改modules/base.js import Vue from 'vue'import &#123; base &#125; from '../mutation-types'import axios from 'axios'import qs from 'qs'const state = &#123; version: '', token: null, user: &#123; userID: '', userName: '', name: '', tel: '', email: '', head: '', &#125;,&#125;const getters = &#123; versionGetter(state, getters) &#123; return state.version &#125;,&#125;const mutations = &#123; [BASE.SET_USER_INFO](state, userInfo) &#123; userInfo.userID &amp;&amp; (state.user.userID = userInfo.userID) userInfo.USERNAME &amp;&amp; (state.user.userName = userInfo.USERNAME) userInfo.NAME &amp;&amp; (state.user.name = userInfo.NAME) userInfo.TEL &amp;&amp; (state.user.tel = userInfo.TEL) userInfo.EMAIL &amp;&amp; (state.user.email = userInfo.EMAIL) userInfo.HEAD &amp;&amp; (state.user.head = userInfo.HEAD) &#125;,&#125;const actions = &#123; async login(&#123; commit, dispatch, state &#125;, &#123; userName, password &#125;) &#123; let userInfo = await axios.post('/api/login', qs.stringify(&#123; userName, password &#125;)) commit(BASE.SET_USER_INFO, userInfo) &#125;,&#125;export default &#123; // namespaced: true, // https://vuex.vuejs.org/zh/guide/modules.html#命名空间 state, mutations, actions, getters,&#125; 修改 vuex 主文件index.js，组合所有状态模块 import Vue from 'vue'import Vuex from 'vuex'import getters from './getters'import actions from './actions'import mutations from './mutations'import base from './modules/base'import cart from './modules/cart'import products from './modules/products'// import createLogger from 'vuex/dist/logger' //vuex内置的Logger日志插件const debug = process.env.NODE_ENV !== 'production' // 发布品种时需要用 Webpack 的 DefinePlugin 来转换 process.env.NODE_ENV !== 'production' 的值为 falseVue.use(Vuex)const state = &#123;&#125;export default new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; base, cart, products, // https://vuex.vuejs.org/zh/guide/modules.html#模块动态注册 &#125;, strict: debug, // 开发阶段使用 // plugins: debug ? [createLogger()] : []//vuex插件,https://vuex.vuejs.org/zh/guide/plugins.html&#125;) 修改main.js，引入 vuex //...import store from './store/index'//...new Vue(&#123; el: '#app', router, store, // components: &#123; App &#125;, // template: '&lt;App/&gt;', render: h =&gt; h(App), // https://cn.vuejs.org/v2/guide/render-function.html#JSX&#125;) https://juejin.im/post/5bcd967b6fb9a05d07197b1e Vuex 实战：如何在大规模 Vue 应用中组织 Vuex 代码 super-vuex 添加mixins文件夹目录结构 ↓ mixins ├── index.js # 全局mixin 添加filters文件夹目录结构 ↓ filters ├── index.js # 全局过滤器 添加utils文件夹目录结构 ↓ utils ├── fetch.js # axios ├── filters.js # 全局filter └── mixin.js # 全局mixin src/main.js中添加全局引用 ↓ import * as filters from './utils/filters'import fetch from './utils/fetch'/* 全局注册fetch */Vue.prototype.$fetch = fetch/* 注册全局过滤器 */Object.keys(filters).forEach(key =&gt; &#123; Vue.filter(key, filters[key])&#125;) 封装 axiosimport Vue from 'vue'import router from '../router'import axios from 'axios'import qs from 'qs'import Toast from '../components/toast'// #region config// 每页条数export const ROW = 10// 加载最小时间export const MINI_TIME = 300// 超时时间（超时时间）export const TIME_OUT_MAX = 8000// 环境valueexport const _env = process.env.NODE_ENV// 请求组（判断当前请求数）export const _requests = []// #endregion// #region 实例化axiosconst _instance = axios.create(&#123; timeout: TIME_OUT_MAX,&#125;)// #endregion// region request统一处理操作_instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'// POST传参序列化_instance.interceptors.request.use( config =&gt; &#123; if (config.method === 'post') &#123; config.data = qs.stringify(config.data) &#125; return config &#125;, error =&gt; &#123; Toast('错误的传参') return Promise.reject(error) &#125;,)// endregion// region response统一处理操作_instance.interceptors.response.use( res =&gt; &#123; let _message = null if (res.status !== 200) &#123; console.error(res) switch (res.status) &#123; case 404: _message = '404,错误请求' break case 401: router.push(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;) _message = '未授权' break case 403: _message = '禁止访问' break case 408: _message = '请求超时' break case 500: _message = '服务器内部错误' break case 501: _message = '功能未实现' break case 503: _message = '服务不可用' break case 504: _message = '网关错误' break default: _message = '未知错误' &#125; Toast(_message) return Promise.reject(_message) &#125; else &#123; return res &#125; &#125;, error =&gt; &#123; console.error(error) Toast(error || '服务器繁忙，请稍后重试') return Promise.reject(error || '服务器繁忙，请稍后重试') &#125;,)// endregion// #region send get/postlet toast = null/** * 发送GET请求 * @param api 接口api * @param params 请求参数 * @returns &#123;Promise.&lt;T&gt;&#125; */async function get(api, params) &#123; try &#123; if (!toast) toast = Toast(&#123; time: -1, message: '加载中', icon: 'loading' &#125;) let &#123; data &#125; = await _instance.get(api, &#123; params &#125;) toast.close() return data &#125; catch (e) &#123; toast.close() Toast(&#123; message: '网络异常', position: 'bottom' &#125;) throw e &#125;&#125;/** * 发送POST请求 * @param api 接口api * @param params 请求参数 * @returns &#123;Promise.&lt;T&gt;&#125; */async function post(api, params) &#123; try &#123; if (!toast) toast = Toast(&#123; time: -1, message: '加载中', icon: 'loading' &#125;) let &#123; data &#125; = await _instance.post(api, qs.stringify(params)) toast.close() return data &#125; catch (e) &#123; toast.close() Toast(&#123; message: '网络异常', position: 'bottom' &#125;) throw e &#125;&#125;// #endregionexport default &#123; _instance, get, post,&#125; config 配置build 生成的文件路径使用相对路径修改config/index.js文件中build节点的assetsPublicPath值 module.exports = &#123; dev: &#123; // ... &#125;, build: &#123; // ... assetsPublicPath: './', // ... &#125;,&#125; 开发的的时候需要使用代理(proxy)跨域访问服务器接口修改config/index.js文件中dev节点的proxyTable值 module.exports = &#123; dev: &#123; // ... proxyTable: &#123; '/api': &#123; target: 'https://123.57.89.97:8081', changeOrigin: true, // pathRewrite: &#123; // '^/api': '/api' // &#125; &#125;, &#125;, // ... &#125;,&#125; 分离线上环境和本地环境的配置信息修改config/dev.env.js与config/prod.env.js，为不同的环境配置文件添加与NODE_ENV同级的环境变量 module.exports = &#123; NODE_ENV: '"development"', API: '"https://123.57.89.97:8081"',&#125; 通用样式(SCSS)目录结构 ↓ assets └── scss ├── base.scss # 基础样式 ├── common.scss # 通用样式 ├── fun.scss # 函数 ├── mixin.scss # 混合 └── variable.js # 变量 base.scss@charset "utf-8";@import 'variable';@import 'fun';@import 'mixin';@import 'common';/*基础样式*/html,body,#app &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1; width: 100%; height: 100%; font-family: Arial, 'Microsoft YaHei', '微软雅黑', Verdana, sans-serif;&#125;ul,li &#123; padding: 0; margin: 0; list-style: none;&#125;* &gt; img &#123; max-width: 100%; max-height: 100%;&#125;button &#123; position: relative; display: block; margin-left: auto; margin-right: auto; padding-left: 14px; padding-right: 14px; box-sizing: border-box; font-size: 18px; text-align: center; text-decoration: none; line-height: 2.55555556; border-radius: 5px; -webkit-tap-highlight-color: transparent; overflow: hidden; color: #000000; background-color: #f8f8f8; &amp;::after &#123; content: ' '; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid rgba(0, 0, 0, 0.2); -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0; box-sizing: border-box; border-radius: 10px; &#125;&#125;//页面切换动画.slide &#123; &amp;-enter, &amp;-leave-to &#123; -webkit-transform: translate(100%, 0); transform: translate(100%, 0); &#125; &amp;-enter-active, &amp;-leave-active &#123; transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1); &#125; &amp;-enter-to, &amp;-leave &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0); &#125;&#125; common.scss@charset "UTF-8";@import 'fun';@import 'mixin';@import 'variable';/*通用样式*/* &#123; box-sizing: border-box;&#125;.clear &#123; display: block !important; clear: both !important; float: none !important; margin: 0 !important; padding: 0 !important; height: 0; line-height: 0; font-size: 0; overflow: hidden;&#125;.clearfix &#123; zoom: 1;&#125;.clearfix:after &#123; content: ''; display: block; clear: both; height: 0;&#125; fun.scss@charset "UTF-8";/*函数*/@function rem($pixels) &#123; @return $pixels / 100px * 1rem;&#125; mixin.scss@charset "UTF-8";/*混合*/@mixin fullpage &#123; position: absolute; top: 0; bottom: 0; right: 0; left: 0;&#125; variable.scss@charset "UTF-8";@import 'fun';/*变量*/$headerHeight: rem(50px); 查缺补漏我用了 axios , 为什么 IE 浏览器不识别(IE9+)那是因为 IE 整个家族都不支持 promise, 解决方案: npm install es6-promise// 在 main.js 引入即可// ES6的polyfillrequire('es6-promise').polyfill()]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Style Guide For 前端]]></title>
    <url>%2Fposts%2F16482fed.html</url>
    <content type="text"><![CDATA[命名 文件夹、.JS、.CSS: 小驼峰(little camel-case) .vue 组件: 大驼峰(big camel-case)* css的class命名遵循 BEM 重构组件组件存放位置只有 一个 页面内的组件，放在页面文件夹下的 components 文件夹下； 两个 页面共用的组件，放在第一个页面文件夹下的 components 文件夹下； 三个以上 页面的共用组件，放在项目文件夹下的 components 文件夹下。 组件存放的位置会在开发过程中不断的调整重构。 添加项目级公用组件需将组件参数及用法描述添加到 README.md 。 Vue 引用组件一律使用 大驼峰(big camel-case) 命名。 如遇 Footer 组件则可将组件名定义为 VFooter ，不要使用 MyFooter 。 weex页面文件夹命名使用 小驼峰(little camel-case) ，文件夹由 至少两个单词组成 。 gittag 命名规范 分支+版本号+日期。版本号前3位逢9进1，最后一位极限逢99进1。例如：dev-v0.3.3.01-20180110 pre-v0.3.9.05-20181101 master-v0.3.9.05-20180101 master的tag根据pre的最后一个版本。 更多 Vue 风格指南 Airbnb JavaScript Style Guide]]></content>
      <categories>
        <category>前端</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这次，彻底弄懂接口及抽象类]]></title>
    <url>%2Fposts%2F912e5c18.html</url>
    <content type="text"><![CDATA[本文旨在讨论抽象类和接口的作用、实例及使用场景，都是我的理解和总结。更多关于接口和抽象类的概念知识，可自行查阅相关文档。 1. 抽象类及其作用抽象类，顾名思义，即类的抽象。 在介绍面向对象概念时，我们知道类是客观事物的抽象，而抽象类又是类的进一步抽象，该怎么理解呢？ 举个例子，我们定义若干个类 class BMW、class Benz、class Audi，分别对客观事物“宝马”、“奔驰”、“奥迪”三种汽车进行抽象，包含相关属性和行为（即方法）。但是我们知道，汽车都有通用的属性和行为，比如品牌、发动机、方向盘、轮胎等属性，前进、后退、转弯等行为，所以我们可以在宝马、奔驰等汽车之上，进一步抽象出“汽车”类 abstract class Car，包含通用的特性（属性和方法）。让 BMW、Benz、Audi 等继承抽象类 extends Car，便拥有了汽车的通用特性，然后在抽象类基础上定义各自的特殊属性及方法。 这里的 abstract class Car 即抽象类，可以看出，抽象类是用来捕捉子类的通用特性的，包括属性及行为。 2. 接口及其作用下面我们来看看接口，假使我研发出来一台会飞的汽车“伯特莱斯”（Bote-Royce），在程序中定义如下： class BoteRoyce extends Car &#123; //...省略通用特性 /** * 可以飞 */ void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 看起来没问题： BoteRoyce extends Car：表达这是一辆汽车； fly() 方法：体现这车可以飞。 但是，随着技术发展，出现了众多可以制造飞行汽车的厂商，难道每一个可以飞的汽车都去定义一个 fly() 方法？ 心想这还不简单，在抽象类 Car 中定义一个抽象方法 abstract void fly() 让子类去实现，不就可以了吗？ No No No… 正如不是所有牛奶都叫特仑苏一样，不是所有汽车都会飞，飞行功能不是汽车的通用特性。将 fly() 方法定义在 Car 中，显然违背了“抽象类用来捕捉子类的通用特性”这一原则。 在这种场景下，解决方案之一就是使用接口，如下： /** * 飞行器接口 */public interface Aircraft &#123; //定义抽象方法 void fly();&#125; 类 BoteRoyce 的定义修改如下： /* * 实现 Aircraft 接口，表示具备飞行器能力 */class BoteRoyce extends Car implements Aircraft &#123; /** * 覆写接口方法，实现飞行能力 */ @Override void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 再有其他品牌的飞行汽车，都可以通过 extends Car implements Aircraft 实现飞行能力。 上述定义的 interface Aircraft 即为接口，我们通常使用接口对行为进行抽象。 3. 接口和抽象类的区别关于二者的区别，可以结合前面的例子，来加深理解。 抽象类是对类本质的抽象，表达的是 is a 的关系，比如：BMW is a Car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是 like a 的关系。比如：Bote-Royce like a Aircraft（像飞行器一样可以飞），但其本质上 is a Car。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。 4. 接口与抽象类的使用场景熟悉 Java 的同学可能会质疑，上述关于接口的使用，完全可以通过再次抽象 Car 去实现： /** * 会飞的汽车 */abstract class FlyCar extends Car &#123; //定义抽象方法 public abstract void fly();&#125; 普通的汽车依然 extends Car，可以飞行的汽车 extends FlyCar 即可： /* * 继承 FlyCar，表示是可以飞行的汽车 */class BoteRoyce extends FlyCar &#123; /** * 覆写抽象方法，实现飞行能力 */ @Override public void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 如果你也这么想，表示你 get 到了抽象类的点。不过话说回来，这样的话接口岂不是没有存在的意义了？ 当然不是了。就 BoteRoyce 而言，如果你关心的是“飞行汽车”这个整体，那么定义抽象类 FlyCar 是个不错的选择；如果你关心的是汽车具备“飞行”的行为，那不妨继续沿用前面使用 Aircraft 接口的方案。 这一点与设计模式中六大原则之一的“里氏替换原则”不谋而合，该原则指出：所有引用基类（抽象类或接口）的地方必须能透明地使用其子类的对象。也就是说，当你遵循该原则时，你必须要考虑你关心的是“飞行汽车”实体，还是“飞行”行为，并将其作为基类，从而决定程序所能接受的子类对象。 同时，“接口隔离原则”指导我们，一个类对另一个类的依赖应该建立在最小的接口上。相比于抽象类 FlyCar，接口 Aircraft 能最大限度的减少对外暴露的接口，并隐藏细节，更符合这一原则。 所以说啊，面向对象只是指导我们编程的思想，而非条条框框。在实际开发中，具体使用抽象类还是接口，并没有绝对限制，而是取决于你的业务场景和架构设计。 5. 总结好了，本次关于接口与抽象类的总结就到这儿，你彻底弄懂了吗？下期分享再见~]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夯实Java：从面向对象说起]]></title>
    <url>%2Fposts%2F92341839.html</url>
    <content type="text"><![CDATA[刚学习 Java 那会就接触了“面向对象”的概念，但当时并没有太多实战经验，所以对其的理解也仅限于概念。当工作两年后再回顾一下，有些概念能够落地了，遂记录一下。 1. 什么是面向对象面向对象是一种程序设计的思想，而不是一种方法，亦或准则。其指导我们从现实世界中客观存在的事物出发，进行程序设计。 2. 什么是对象Everything is Object，在 Java 语言的世界中，万事万物皆对象。上面提到“从现实世界中客观存在的事物出发”，这里客观存在的事物，我们称之为“对象”。 在程序中，对象是程序的基本构成单元，是客观存在的事物的体现。一个对象通常由一组属性和对这组属性进行操作的若干服务（方法）构成。 3. 面向对象与面向过程的出现面对简单的软件程序，我们往往不需要考虑过多的设计，任何一个小的功能单元或模块，都可以按照一定的步骤去实现，这种 step by step 的方式即为面向过程。 随着程序的复杂性提升，我们无法按步骤去描述并实现编码，所以面向过程已无法适应。加之考虑到代码的可读及复用性等，便有了对象的概念，以及面向对象的编程思想。 当然，还有面向组件、面向服务等设计思想，不在此讨论。 4. 面向对象与面向过程的区别要知道，二者并不是非此即彼，而是相辅相成的。 面向对象思想要求我们从宏观上进行程序设计，抽象出一个个“对象”。而面向过程，则在微观上对“对象”内部进行具体的实现。 可以看出，面向对象最终还是离不开面向过程。 举例来说，需要编程实现绘制圆形、三角形、矩形。 面向过程实现： drawCircle... //一坨绘制相关的代码，下同drawTriangledrawRect 面向对象实现： //抽象出画笔对象class Painter &#123; drawCircle()&#123; //上述面向过程实现，下同 &#125; drawTriangle()&#123;&#125; drawRect()&#123;&#125;&#125;//面向对象，使用画笔绘制1. painter.drawCircle() //此处只需要调用对象的方法，下同1. painter.drawTriangle()2. painter.drawRect() 5. 对象与类前面介绍了对象以及面向对象，下面回到 Java 中聊聊类的概念。 5.1 类我们常说“物以类聚”，表达“ 同类的东西聚在一起”。其实 Java 中的类也可以这么去理解：“物”即客观存在的“对象”，同类物体的特征描述，即为“类”。 上面是我的个人理解，用术语概括就是：类是客观事物的抽象，或者说是对现实生活中事物的一种描述（属性和行为）。 例如前面定义的 Painter 类，是对客观事物画笔的抽象，包含了一些绘制的方法（行为）。 5.2 对象与类的关系类进行实例化可生成对象，所以，类的具体表现或者实例就是对象，而对象的抽象或者总概括就是类。 6. 面向对象的三大特性说到面向对象，就不得不说其三大特性：封装、继承和多态。 下面简单说说自己的理解吧，就不再贴相关示例了，网上有很多优秀的例子。 6.1 封装封装是面向对象最基础的特性。在前面介绍对象时，提到“一个对象通常由一组属性和对这组属性进行操作的若干服务（方法）构成”，这里的构成体现的就是封装性。 封装，是指对外隐藏对象内部的属性和实现细节，只提供相应的接口和方法进行交互。一方面，外部只需专注于对象所提供的能力，而不用关心内部实现细节；另一方面，避免了外部随意修改或访问内部属性和方法，从而提升了程序的健壮性；同时，封装能提升代码的复用率。 6.2 继承继承指一个对象从另一个对象中获得属性和方法的过程，继承者称为子类，被继承者称为父类。继承使得子类对象拥有父类对象的全部属性与方法（非私有）。 Key point: 子类也可以被其他类继承成为父类； 父类可以拥有多个子类，但一个子类只能有一个父类。这一点与现实中父亲与孩子的关系是一致的； Java 中任何类都是 java.lang.Object 的直接或间接子类； 子类不能继承父类中访问权限为 private 的成员变量和方法； 子类可以重写（override）父类的方法； 子类可以通过 super 关键字访问父类的成员变量、方法和构造器； final 声明的类或方法，不能被继承或重写； 6.3 多态多态是在继承的基础上实现的，多态实现的三个必要条件： 继承 方法重写（override） 父类引用指向子类对象，例如：Human human = new Man()，这里 Man extends Human。 当使用多态方式调用方法时，会依据以下规则： 首先检查父类中是否有该方法，如果没有，则编译错误； 若子类重写了该方法，调用子类的重写方法； 若子类没有重写该方法，则调用父类的方法； 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 7. 总结以上是本文的全部内容，希望能对你有所启发。内容说不上全面、无误，还望读者朋友补充、指正。 最后，感谢阅读。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的.so文件、abi兼容，通用armeabi-v7a和arm64-v8a架构的方法]]></title>
    <url>%2Fposts%2F75a88a70.html</url>
    <content type="text"><![CDATA[了解完 armeabi、armeabi-v7a、arm64-v8a、mips、mips64、x86、x86_64等abi的原理后，很久以前一般都只是用armeabi在做兼容。 现在其实市面上主流的手机都支持armeabi-v7a和arm64-v8a。请看如下简介：各版本的分析如下所示： mips / mips64: 极少用于手机可以忽略，有兴趣的可以百度一下。 x86 / x86_64: x86 架构的手机都会包含由 Intel 提供的称为 Houdini 的指令集动态转码工具，实现 对 arm .so 的兼容，再考虑 x86 1% 以下的市场占有率，x86 相关的两个 .so 也是可以忽略的 armeabi: ARM v5 这是相当老旧的一个版本，缺少对浮点数计算的硬件支持，在需要大量计算时有性能瓶颈 armeabi-v7a: ARM v7 目前主流版本，一般市面上的骁龙系列或者麒麟系列的处理器绝大部分都是这种架构 arm64-v8a: 64位支持所谓的ARMv8架构，就是在MIPS64架构上增加了ARMv7架构中已经拥有的的TrustZone技术、虚拟化技术及NEON advanced SIMD技术等特性，研发成的。 综上所述建议大家兼容armeabi-v7a和arm64-v8a这两个，其他架构少之又少，armeabi基本淘汰所以现在就不怎么考虑了。对于一般项目来说，足够了。 在build.gradle的android里的defaultConfig内添加如下内容:defaultConfig &#123; ndk &#123; abiFilters &quot;armeabi-v7a&quot; abiFilters &quot;arm64-v8a&quot; &#125; 然后在项目中集成so文件的时候 只把armeabi-v7a和arm64-v8a这两个的so文件夹copy到libs里面，具体细节第三方平台的教程里面都写得很详细 如果报错:Error:(15, 1) A problem occurred evaluating project ':app'.&gt; Error: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set "android.useDeprecatedNdk=true" in gradle.properties to continue using the current NDK integration. 请在 gradle.properties 中 添加android.useDeprecatedNdk=true 对于新手Android开发者来说，像集成百度地图SDK、JPush等再出现找不到.so文件的问题直接只使用armeabi-v7a和arm64-v8a就足以。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>armeabi-v7a</tag>
        <tag>arm64-v8a</tag>
        <tag>abi兼容</tag>
        <tag>.so文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的.so文件、ABI和CPU的关系]]></title>
    <url>%2Fposts%2Fb9d5fd68.html</url>
    <content type="text"><![CDATA[早期的Android系统几乎只支持ARMv5的CPU架构，你知道现在它支持多少种吗？ Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。 应用程序二进制接口ABI（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。 为什么你需要重点关注.so文件 项目中使用到了NDK，它将会生成.so文件。 如果只使用Java语言进行编码，你可能在想不需要关注.so文件了吧，因为Java是跨平台的。但你可能并没有意识到项目中依赖的函数库或者引擎库里面已经嵌入了.so文件，并依赖于不同的ABI。 Android应用支持的ABI取决于APK中位于lib/ABI目录中的.so文件，其中ABI可能是上面说过的七种ABI中的一种。 本地库监视器Native Libs Monitor这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。 ABI和CPU的关系很多设备都支持多于一种的ABI。当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。但最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等）。 我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件 ABI目录（横向）和cpu（纵向） armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64 ARMv5 支持 ARMv7 支持 支持 ARMv8 支持 支持 支持 MIPS 支持 MIPS64 支持 支持 x86 支持 支持 支持 x86_64 支持 支持 支持 不同的ABI，针对不同的cpu架构有不同的优先权 例如： x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件。 x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备。 64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。 .so文件重要法则处理.so文件时有一条简单却并不知名的重要法则。 你应该尽可能的提供专为每个ABI优化过的.so文件，你不应该混合着使用（不能就装对不同cpu架构的so文件，放在同一个ABI目录下）。你应该为每个ABI目录提供对应的.so文件。 NDK兼容性使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是后向兼容（兼容过去的版本）的，而是前向兼容（兼容将来的版本）的。推荐使用app的minSdkVersion对应的编译平台。 这也意味着当你引入一个预编译好的.so文件时，你需要检查它被编译所用的平台版本。 混合使用不同C++运行时编译的.so文件.so文件可以依赖于不同的C++运行时，静态编译或者动态加载。混合使用不同版本的C++运行时可能导致很多奇怪的crash，是应该避免的。 一个经验法则 当只有一个.so文件时，静态编译C++运行时是没问题的， 当存在多个.so文件时，应该让所有的.so文件都动态链接相同的C++运行时。 这意味着当引入一个新的预编译.so文件，而且项目中还存在其他的.so文件时，我们需要首先确认新引入的.so文件使用的C++运行时是否和已经存在的.so文件一致。 ###关于.so文件的错误示例问题： 你的app目前只支持armeabi-v7a和x86架构，你想让app支持更多的cpu类型，新增了一个函数库依赖，这个函数库包含.so文件并支持更多的CPU架构。 发布我们的app后，会发现它在某些设备上会发生Crash，例如Galaxy S6，最终可以发现只有64位目录下的.so文件被安装进手机。 解决方案： 重新编译我们的.so文件使其支持缺失的ABIs 也可以设置ndk.abiFilters显示指定支持的ABIs 在IDE中的路径 Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定） Eclipse工程放在libs/ABI目录中（这也是ndk-build命令默认生成.so文件的目录） 在AAR压缩包中的路径AAR压缩包中位于jni/ABI目录中（.so文件会自动包含到引用AAR压缩包的APK中） 在APK中的路径最终APK文件中的lib/ABI目录中 通过PackageManager安装后，.so文件路径通过PackageManager安装后，在小于Android 5.0的系统中，.so文件位于app的nativeLibraryPath目录中；在大于等于Android 5.0的系统中，.so文件位于app的nativeLibraryRootDir/CPU_ARCH目录中。 生成不同ABI版本的APK以减少APK包大小为由是一个错误的借口，因为你也可以选择在应用市场上传指定ABI版本的APK，生成不同ABI版本的APK可以在build.gradle中如下配置：android &#123; ... splits &#123; abi &#123; enable true reset() include 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a' //select ABIs to build APKs for universalApk true //generate an additional APK that contains all the ABIs &#125; &#125; // map for the version code project.ext.versionCodes = ['armeabi': 1, 'armeabi-v7a': 2, 'arm64-v8a': 3, 'mips': 5, 'mips64': 6, 'x86': 8, 'x86_64': 9] android.applicationVariants.all &#123; variant -&gt; // assign different version code for each output variant.outputs.each &#123; output -&gt; output.versionCodeOverride = project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode &#125; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>.so文件</tag>
        <tag>ABI</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你必须知道的ABI和CPU关系]]></title>
    <url>%2Fposts%2F8c0a549.html</url>
    <content type="text"><![CDATA[ABI和CPU的重要知识1、 大部分cpu都支持多于一种的ABI。2、 当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。3、 ABI目录（横向）和cpu（纵向） armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64 ARMv5 支持 ARMv7 支持 支持 ARMv8 支持 支持 支持 MIPS 支持 MIPS64 支持 支持 x86 支持 支持 支持 x86_64 支持 支持 支持 注意：上表格中的空白部分，是我不知道它是否支持，极有可能是不支持 解析： x86设备上，选择ABI的优先级 libs/x86目录中如果存在.so文件的话，会被安装 如果不存在，则会选择armeabi-v7a中的.so文件 如果也不存在，则选择armeabi目录中的.so文件 x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备，因为是运行在x86设备上模拟arm的虚拟层上。 4、 64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。 5、 最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等）。 6、 会安装优先级较高的ABI目录，则其它优先级较低的ABI目录（包括其它module中的ABI目录），都无法安装。例如：在cpu是ARMv7架构的手机上，如果检测到armeabi-v7a，就会选择安装armeabi-v7a，则armeabi下的文件，都无法安装了。 7、 相应的ABI二进制文件，要放进相应的ABI目录中 8、一般情况下不要简单得修改架构目录名 我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件，如果在对应的lib／ABI目录中存在.so文件的话。 ###工具查看项目中ABI文件的架构类型腾讯bugly，符号表工具，下载地址：http://bugly.qq.com/whitebook Native Libs Monitor这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。 ###疑难杂症虽然规则制定出来了，但总是会出现一些，不合规的现象，导致一些错误，难以理解。现在就让我们来一起把把脉，看看到底是什么疑难杂症 ####一、.so文件，放进了优先级低的ABI目录 1、如果你的项目中，有其他优先级更高的ABI目录，但是你把ABI文件放到了优先级低的目录，则你的ABI文件无法被加载2、如果你的项目中，ABI文件放在了，项目中优先级最高的ABI目录中（这个ABI目录是手机所支持的在项目中优先级最高的，但不一定是手机所支持的优先级最高的），则这个ABI文件，可以被加载，加载为ABI目录的所表示的架构类型。例子： 我的手机cpu架构是ARMv7，ABI文件是armeabi-v7a，但是放进了armeabi目录中 在运行的过程中会出现两种情况： 1、项目中有armeabi-v7a的目录，armeabi目录中的文件，无法被加载，运行后报错，出现如下log信息。Caused by: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/.xx../base.apk"],nativeLibraryDirectories=[/data/app/.xx../lib/arm, /vendor/lib, /system/lib]]] couldn't find "lib..xx...so" 2、项目中只有armeabi的目录，armeabi目录是该项目优先级最高的ABI目录（虽然armeabi目录在ARMv7所支持的优先级最高的ABI目录不是最高），作为armv5，安装到手机上。 ####二、ABI二进制文件，放进了优先级高的ABI目录可以被加载使用，被加载为ABI文件所表示的结构类型 例子： 我的手机cpu架构是ARMv7，ABI文件是armeabi-v5te，但是放进了armeabi-v7a目录中。 可以被加载，但是加载为ABI文件所表示的架构类型。这样就出现了，同一个应用中ABI文件，出现两种的情况。 ####三、两个第三的SDK中ABI文件优先级不一样问题： 两个第三方的SDK中ABI文件优先级不一样，手机加载运行时，会导致优先级低的库，无法被加载 例子： 我的手机cpu架构是ARMv7，项目中使用两个第三方SDK：企业A和企业B 企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。 在运行时，会发现运行后crash，出现如下log信息。Caused by: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/.xx../base.apk"],nativeLibraryDirectories=[/data/app/.xx../lib/arm, /vendor/lib, /system/lib]]] couldn't find "lib..xx...so" 解决办法： #####1、使用同一优先级的ABI文件，ABI文件放入优先级相同的ABI目录 企业A：ABI文件是armeabi-v5te，放进armeabi目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。或企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。 #####2、使用不同优先级的ABI文件，ABI文件放入优先级相同的ABI目录。一般情况不建议这么做。 企业A：ABI文件是armeabi-v7a，但是放进armeabi目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。或企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v5te，但是放进armeabi-v7a目录中。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>ABI</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android下setTextSize的正确使用姿势]]></title>
    <url>%2Fposts%2F99d586fa.html</url>
    <content type="text"><![CDATA[问几个问题先在app/src/main/res/values/dimens.xml中定义尺寸如下： &lt;dimen name="font1"&gt;18sp&lt;/dimen&gt; 在代码中引用此尺寸如下： mText.setTextSize(18); // 方法1mText.setTextSize(getResources().getDimension(R.dimen.font1)); // 方法2mText.setTextSize(TypedValue.COMPLEX_UNIT_PX,getResources().getDimension(R.dimen.font1)); // 方法3mText.setTextSize(TypedValue.COMPLEX_UNIT_SP,18); // 方法4 问题1: 方法1和方法2设置的文字尺寸大小相同么？问题2:方法3和方法4设置的文字尺寸大小相同么？问题3:方法1和方法4设置的文字尺寸大小相同么？ 如果你能很清楚的给出上面问题的答案，那就没必要再向下看了；如果你对以上问题感到模棱两可的话，请继续往下看: 要想解开以上疑惑，其实主要从以下两个方法的源码入手 setTextSize(…)进入TextView类，找到setTextSize(…)方法，发现它调用了另一个重载方法，注意这里调用重载方法时传入的第一个参数是一个默认值 TypedValue.COMPLEX_UNIT_SP，因此方法1和方法4设置的文字尺寸大小相同. public void setTextSize(float size) &#123; setTextSize(TypedValue.COMPLEX_UNIT_SP, size);&#125;public void setTextSize(int unit, float size) &#123; Context c = getContext(); Resources r; if (c == null) r = Resources.getSystem(); else r = c.getResources(); setRawTextSize(TypedValue.applyDimension(unit, size, r.getDisplayMetrics()));&#125; 重载方法中有两个方法需要重点看setRawTextSize(…)方法通过它的几个方法会发现它的作用就是真正设置文字大小并刷新显示： private void setRawTextSize(float size) &#123; if (size != mTextPaint.getTextSize()) &#123; mTextPaint.setTextSize(size); if (mLayout != null) &#123; nullLayouts(); requestLayout(); invalidate(); &#125; &#125;&#125; TypedValue类中的applyDimension(…)方法根据传入的unit单位来处理文字大小，返回的尺寸为px (通过第一个case条件得知). public static float applyDimension(int unit, float value, DisplayMetrics metrics)&#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0;&#125; 如果传入的unit为COMPLEX_UNIT_PX，则会将value直接返回如果传入的unit为COMPLEX_UNIT_SP，则会将value处理成px返回 getDimension(…)进入Resources类，找到getDimension(…)方法 public float getDimension(@DimenRes int id) throws NotFoundException &#123; synchronized (mAccessLock) &#123; TypedValue value = mTmpValue; if (value == null) &#123; mTmpValue = value = new TypedValue(); &#125; getValue(id, value, true); if (value.type == TypedValue.TYPE_DIMENSION) &#123; return TypedValue.complexToDimension(value.data, mMetrics); &#125; throw new NotFoundException("Resource ID #0x" + Integer.toHexString(id) + " type #0x" + Integer.toHexString(value.type) + " is not valid"); &#125;&#125; 这里方法不多，点getValue(…)方法进去看会发现它内部又调用了native方法，这里我无法进一步追溯它的实现，不过没关系，因为我发现有个方法很眼熟那就是：TypedValue.complexToDimension(…) ，进入此方法会惊奇的发现它也调用了上面讲到的applyDimension(…)方法. public static float complexToDimension(int data, DisplayMetrics metrics)&#123; return applyDimension( (data&gt;&gt;COMPLEX_UNIT_SHIFT)&amp;COMPLEX_UNIT_MASK, complexToFloat(data), metrics);&#125; 由此可以大胆的猜测 getDimension(…)方法最终也会将数据处理成px返回，因此方法3和方法4设置的文字尺寸大小相同，只是写法不同而已. 好了，回到开篇提到的四个问题，可以得出以下结论： 方法1：文字尺寸以sp为单位，大小为18方法2：文字尺寸以sp为单位，大小为（18sp转换为px的值）方法3：文字尺寸以px为单位，大小为（18sp转换为px的值）方法4：文字尺寸以sp为单位，大小为18方法1=方法3=方法4!＝方法2 至此，文章结束，希望此文能帮助到你，如果对此文有不同见解，欢迎直接评论！]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>TypedValue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用Handler造成内存泄露的分析和解决]]></title>
    <url>%2Fposts%2F91b033d9.html</url>
    <content type="text"><![CDATA[Java使用有向图机制，通过GC自动检查内存中的对象（什么时候检查由虚拟机决定），如果GC发现一个或一组对象为不可到达状态，则将该对象从内存中回收。也就是说，一个对象不被任何引用所指向，则该对象会在被GC发现的时候被回收；另外，如果一组对象中只包含互相的引用，而没有来自它们外部的引用（例如有两个对象A和B互相持有引用，但没有任何外部对象持有指向A或B的引用），这仍然属于不可到达，同样会被GC回收。 Android中使用Handler造成内存泄露的原因Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; mImageView.setImageBitmap(mBitmap); &#125;&#125; 上面是一段简单的Handler的使用。当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。 内存泄露的危害只有一个，那就是虚拟机占用内存过高，导致OOM（内存溢出），程序出错。对于Android应用来说，就是你的用户打开一个Activity，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制，FC。 使用Handler导致内存泄露的解决方法 通过程序逻辑来进行保护1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。 将Handler声明为静态类静态类不持有外部类的对象，所以你的Activity可以随意被回收。代码如下： static class MyHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; mImageView.setImageBitmap(mBitmap); &#125;&#125; 但其实没这么简单。使用了以上代码之后，你会发现，由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）： static class MyHandler extends Handler &#123; WeakReference&lt;Activity &gt; mActivityReference; MyHandler(Activity activity) &#123; mActivityReference= new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; final Activity activity = mActivityReference.get(); if (activity != null) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;&#125; 将代码改为以上形式之后，就算完成了。 具体示例代码： /** * * 实现的主要功能。 * * @version 1.0.0 * @author Abay Zhuang &lt;br/&gt; * Create at 2014-7-28 */public class HandlerActivity2 extends Activity &#123; private static final int MESSAGE_1 = 1; private static final int MESSAGE_2 = 2; private static final int MESSAGE_3 = 3; private final Handler mHandler = new MyHandler(this); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandler.sendMessageDelayed(Message.obtain(), 60000); // just finish this activity finish(); &#125; public void todo() &#123; &#125;; private static class MyHandler extends Handler &#123; private final WeakReference&lt;HandlerActivity2&gt; mActivity; public MyHandler(HandlerActivity2 activity) &#123; mActivity = new WeakReference&lt;HandlerActivity2&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; System.out.println(msg); if (mActivity.get() == null) &#123; return; &#125; mActivity.get().todo(); &#125; &#125; 上面这样就可以了吗？ 当Activity finish后 handler对象还是在Message中排队。 还是会处理消息，这些处理有必要？正常Activitiy finish后，已经没有必要对消息处理，那需要怎么做呢？解决方案也很简单，在Activity onStop或者onDestroy的时候，取消掉该Handler对象的Message和Runnable。通过查看Handler的API，它有几个方法：removeCallbacks(Runnable r)和removeMessages(int what)等。 代码如下： @Overridepublic void onDestroy() &#123; // If null, all callbacks and messages will be removed. mHandler.removeCallbacksAndMessages(null);&#125; 延伸：什么是WeakReference？WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Handler</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美团面试，我竟然输给了冒泡排序…]]></title>
    <url>%2Fposts%2F4ef397b8.html</url>
    <content type="text"><![CDATA[前一阵子有个读者在微信里跟我聊了一件很有趣的事情，他去美团实习，面试让他哭笑不得，因为败在了冒泡排序上。 情况是这样子的，当时和面试官聊的感觉还可以，就在他觉得好像差不多快结束的时候，面试官给他扔了个题：“我这刚好有纸和笔，你来写个冒泡排序吧。” 这位读者心里一慌，为什么慌，倒并不是因为不会写，因为作为一个程序员，冒泡排序基本上没有不会写的，而是事发突然，感觉不太妙。当时他是这么写的： public void bubbleSort(int[] a) &#123; for(int i = a.length - 1; i &gt; 0; i--) &#123; for(int j = 0; j &lt; i; j++) &#123; if(a[j] &gt; a[j+1]) //交换，具体实现略 swap(a, j, j+1); &#125; &#125;&#125; 果不其然，他写了之后，面试官就问他，这种写法有没有什么问题？能否继续优化？结果还真没答上来。（看到这里，读者们不妨也先思考下如何优化。） 今天就这个冒泡排序，我们再多聊几句，回归一下经典。也希望以后有朋友实习也好，校招也罢，不要再栽在同样的问题上了。 冒泡排序算法的时间复杂度高，如果不清楚算法复杂度如何计算，可以参考下这篇文章：循序渐进带你学习时间复杂度和空间复杂度。但是冒泡排序简单，基本流程是：每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。如何实现？就如上面这位朋友所写的那样，基本上大家都会写。 但是今天主要讨论的是如何优化，有人可能会说，这是再简单不过的算法了，还有什么好优化的？确实，上面这段代码没有毛病，但的确是有可优化之处的。 我们可以假设一种场景，比如 8 1 2 3 5 7，进行一次排序之后，结果就变成了 1 2 3 5 7 8，那我们还有必要再像上面代码里那样继续循环下去吗？肯定没有必要了，因为这已经是最终结果了。 那针对上面的代码，我们优化的点主要在于：假如某一趟排序之后已经有序，我们需要减少排序的趟数。否则就做了很多无用功。 针对这个问题，我们可以考虑在算法中加入一个布尔变量，来标识该轮有没有进行数据的交换，若在某一趟排序中未发现数据位置的交换，则说明待排序的无序区中所有的项均已满足排序后的结果。那么就没有必要再次排序下去了。可以如下改造： public void bubbleSort(int[] a) &#123; boolean exchange; for(int i = a.length - 1; i &gt; 0; i--) &#123; exchange = false; for(int j = 0; j &lt; i; j++) &#123; if(a[j] &gt; a[j+1]) &#123; swap(a, j, j+1); exchange = true; &#125; &#125; if(!exchange) return; &#125;&#125; 这样就优化完了，其实代码逻辑很简单，通过一个布尔变量即可监控一趟过程有没有进行数据交换。 冒泡排序最好的情况是初始状态是正序的，一次扫描即可完成排序，所以最好的时间复杂度为O(N)；最坏的情况是反序的，此时最坏的时间复杂度为O(N^2)。平均情况，每轮N/2次循环，N轮时间复杂度为O(N^2)。所以它并不是个好的排序算法。这个问题的讨论就到此结束，如果有更好的优化算法也欢迎留言讨论。 冒泡排序并不好，但为什么面试官还会去问？针对这件事情，我们需要注意什么呢？ 经典的东西，可能已经不用了，但是从经典的东西身上，我们能学到的还有很多，否则也不会成为经典。特别是那些面试经常被问到的，总有它存在的合理性。 教科书上的东西不代表实战，所以很多时候考虑到非理想情况下，就可能不那么适用了。面试官往往更加注重的是在不适用的情况下，面试者是如何应对的。面试官更加看重的是面试者的思路。 应届生不能浮躁，特别是在准备面试的时候，一定要步步为营，切忌好高骛远，浅尝辄止，多学习学习经典的数据结构和算法，多做做算法题还是很有必要的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle依赖配置说明]]></title>
    <url>%2Fposts%2F7a69db10.html</url>
    <content type="text"><![CDATA[之前对Android Gradle构建的依赖一直傻傻分不清，这段时间正好接入集团的一个二方库，踩了很多坑，也顺带把Gradle依赖这块搞清楚了，主要整理了下Gradle依赖的类型、依赖配置、如何查看依赖、依赖冲突如何解决。 依赖类型dependencies DSL标签是标准Gradle API中的一部分，而不是Android Gradle插件的特性，所以它不属于android标签。 依赖有三种方式，如下面的例子： apply plugin: 'com.android.application'android &#123; ... &#125;dependencies &#123; // Dependency on a local library module implementation project(":mylibrary") // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3'&#125; 本地library模块依赖 implementation project(":mylibrary") 这种依赖方式是直接依赖本地库工程代码的（需要注意的是，mylibrary的名字必须匹配在settings.gradle中include标签下定义的模块名字）。 本地二进制依赖 implementation fileTree(dir: 'libs', include: ['*.jar']) 这种依赖方式是依赖工程中的 module_name/libs/目录下的Jar文件（注意Gradle的路径是相对于build.gradle文件来读取的，所以上面是这样的相对路径）。 如果只想依赖单个特定本地二进制库，可以如下配置： implementation files('libs/foo.jar', 'libs/bar.jar') 远程二进制依赖 implementation 'com.example.android:app-magic:12.3' 上面是简写的方式，这种依赖完整的写法如下： implementation group: 'com.example.android', name: 'app-magic', version: '12.3' group、name、version共同定位一个远程依赖库。需要注意的点是，version最好不要写成”12.3+”这种方式，除非有明确的预期，因为非预期的版本更新会带来构建问题。远程依赖需要在repositories标签下声明远程仓库，例如jcenter()、google()、maven仓库等。 依赖配置目前Gradle版本支持的依赖配置有：implementation、api、compileOnly、runtimeOnly和annotationProcessor，已经废弃的配置有：compile、provided、apk、providedCompile。此外依赖配置还可以加一些配置项，例如AndroidTestImplementation、debugApi等等。 常用的是implementation、api、compileOnly三个依赖配置，含义如下： implementation与compile对应，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。使用这个配置，可以显著提升构建时间，因为它可以减少重新编译的module的数量。建议，尽量使用这个依赖配置。 api与compile对应，功能完全一样，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现，也就是会泄漏一些不应该不使用的实现。举个例子，A依赖B，B依赖C，如果都是使用api配置的话，A可以直接使用C中的类（编译时和运行时），而如果是使用implementation配置的话，在编译时，A是无法访问C中的类的。 compileOnly与provided对应，Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。这可以减少输出的体积，在只在编译时需要，在运行时可选的情况，很有用。 runtimeOnly与apk对应，gradle添加依赖只打包到APK，运行时使用，但不会添加到编译路径。这个没有使用过。 annotationProcessor与compile对应，用于注解处理器的依赖配置，这个没用过。 查看依赖树可以查看单个module或者这个project的依赖，通过运行依赖的Gradle任务，如下： 1、View -&gt; Tools Windows -&gt; Gradle（或者点击右侧的Gradle栏）； 2、展开 AppName -&gt; Tasks -&gt; android，然后双击运行AndroidDependencies。运行完，就会在Run窗口打出依赖树了。 ### 依赖冲突解决随着很多依赖加入到项目中，难免会出现依赖冲突，出现依赖冲突如何解决？ 定位冲突 依赖冲突可能会报类似下面的错误： Program type already present com.example.MyClass 通过查找类的方式（command + O）定位到冲突的依赖，进行排除。 如何排除依赖 1、dependencies中排除（细粒度） compile('com.taobao.android:accs-huawei:1.1.2@aar') &#123; transitive = true exclude group: 'com.taobao.android', module: 'accs_sdk_taobao'&#125; 2、全局配置排除 configurations &#123; compile.exclude module: 'cglib' //全局排除原有的tnet jar包与so包分离的配置，统一使用aar包中的内容 all*.exclude group: 'com.taobao.android', module: 'tnet-jni' all*.exclude group: 'com.taobao.android', module: 'tnet-so'&#125; 3、禁用依赖传递 compile('com.zhyea:ar4j:1.0') &#123; transitive = false&#125;configurations.all &#123; transitive = false&#125; 还可以在单个依赖项中使用@jar标识符忽略传递依赖： compile 'com.zhyea:ar4j:1.0@jar' 4、强制使用某个版本 如果某个依赖项是必需的，而又存在依赖冲突时，此时没必要逐个进行排除，可以使用force属性标识需要进行依赖统一。当然这也是可以全局配置的： compile('com.zhyea:ar4j:1.0') &#123; force = true&#125;configurations.all &#123; resolutionStrategy &#123; force 'org.hamcrest:hamcrest-core:1.3' &#125;&#125; 5、在打包时排除依赖 先看一个示例： task zip(type: Zip) &#123; into('lib') &#123; from(configurations.runtime) &#123; exclude '*unwanted*', '*log*' &#125; &#125; into('') &#123; from jar from 'doc' &#125;&#125; 代码表示在打zip包的时候会过滤掉名称中包含“unwanted”和“log”的jar包。这里调用的exclude方法的参数和前面的例子不太一样，前面的参数多是map结构，这里则是一个正则表达式字符串。 也可以使用在打包时调用include方法选择只打包某些需要的依赖项： task zip(type: Zip) &#123; into('lib') &#123; from(configurations.runtime) &#123; include '*ar4j*', '*spring*' &#125; &#125; into('') &#123; from jar from 'doc' &#125;&#125; 主要是使用dependencies中排除和全局配置排除。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android骨架屏，了解一下]]></title>
    <url>%2Fposts%2F2114cdef.html</url>
    <content type="text"><![CDATA[以前做应用开发时，在数据尚未加载前一般会先给用户一个提示，最简单粗暴的方式就是菊花图，大多数做法是放一张有个性的静态图，示意正在加载数据，这样体验会好些，直到出现 Skeleton Screen（中文一般叫做骨架屏）极大地提升用户感知体验。其实一开始我并不知道这个效果叫什么名字，后来在 GitHub 看到有人开源了，赶紧 Star。今天我给大家推荐几个 Skeleton Screen 相关库，来了解学习一波。 1、ShimmerRecyclerView简介A custom recycler view with shimmer views to indicate that views are loading （英语渣渣，这句话始终翻译不顺/捂脸）。 效果预览 源码地址https://github.com/sharish/ShimmerRecyclerView 2、Skeleton简介这个库提供了一种显示骨架加载视图的简便方法，它现在使用闪存动画的内存优化版本，因此速度更快，您也可以设置更大的布局动画。 效果预览 源码地址https://github.com/ethanhua/Skeleton 3、spruce-android简介Spruce 是一个轻量级动画库，可帮助编排屏幕上的动画。该库同时支持 iOS。 效果预览 源码地址https://github.com/willowtreeapps/spruce-android]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>骨架屏</tag>
        <tag>加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，Flutter]]></title>
    <url>%2Fposts%2Fbe2502a3.html</url>
    <content type="text"><![CDATA[什么是Flutter2018年2月27日，在2018世界移动大会上，Google发布了Flutter的第一个Beta版本。Flutter是Google用以帮助开发者在Ios和Android两个平台开发高质量原生应用的全新移动UI框架，点击查看Flutter介绍视频。 其实我第一次听说Flutter是在收到谷歌开发者公众号的推送里，当时读完了那篇文章觉得Flutter的优点确实比较突出： 热重载（Hot Reload），作为一个菜鸟安卓开发者，能热重载真的太舒服了，利用Android Studio直接一个ctrl+s就可以保存并重载，模拟器立马就可以看见效果，就这一点比原生安卓制作简直不知道高到哪里去了。 一切皆为Widget的理念，对于Flutter来说，手机应用里的所有东西都是Widget，通过可组合的空间集合、丰富的动画库以及分层课扩展的架构实现了富有感染力的灵活界面设计。 借助可移植的GPU加速的渲染引擎以及高性能本地代码运行时以达到跨平台设备的高质量用户体验。 这段介绍是直接抄下来的，虽然我并不知道什么叫可移植的GPU加速的渲染引擎，但是最终结果就是利用Flutter构建的应用在运行效率上会和原生应用差不多。 酷安上有一个Flutter的演示Demo，Flutter Gallery。 如果经常逛酷安的一定会发现这个画廊的演示Demo的图标和另一个演示Demo的图标是一样的，Google Fuchsia OS Preview,这个应用的是传闻的Google正在研发的新一代操作系统，所以个人认为，Flutter的存在可能不仅仅是实现在安卓和IOS上的运行，更是为了日后丰富Fuchsia这个新系统的软件生态而存在的。 Flutter的核心内容接下来我想写一下我自己通过这两天的接触对于Flutter的核心内容也就是上面好处的第二点的理解。 一切都是控件（Widget）在Flutter中，每个应用程序都是Widget，这点和其他的应用框架不一样，Flutter的对象模型是统一的，也就是控件。 一个控件可以定义： 结构元素（比如按钮或者菜单） 风格元素（比如字体或者颜色方案） 布局 一些业务逻辑 等等。。。。 控件是基于构图形成层次结构，每个控件嵌套在其中，并从其父代继承属性，没有单独的“应用程序”对象，只有根控件。 您可以通过告知框架用另一个控件替换层次结构中的控件来响应事件，比如用户交互，然后框架会对比新的控件和旧的控件，并有效的更新用户界面，即更新有变化的控件。 也就是说，在Flutter中，一个应用就是有许许多多的Widget组合而成的。 构建第一个Flutter实例先来介绍一下Flutter里面的基本空间： Text：文本控件，在应用中创建各种样式的文本。 Row,Column：Flex控件，可以创建水平(Row)或垂直(Column)方向的布局，是基于Web的flexbox的布局模式设计的。 Stack：非线性布局（水平或垂直），控件可以堆叠在其他控件上，可以使用Positioned控件控制Stack相对顶部、右部、底部和左部的位置，是基于Web的absolute定位的布局模式。 Container：创建矩形的可视元素，可以用BoxDecoration来设计样式，比如背景、边框和阴影，Container也有边距、填充和大小限制，另外，还可以在三维空间利用矩阵进行变换。 结合实例分析： import 'package:flutter/material.dart';class MyAppBar extends StatelessWidget &#123; MyAppBar(&#123;this.title&#125;); final Widget title; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Container( height: 56.0, padding: const EdgeInsets.symmetric(horizontal: 8.0), decoration: new BoxDecoration(color: Colors.blue[500]), //new Row意味着该子布局为水平布局 child: new Row( children: &lt;Widget&gt;[ //布局依次为图标按钮，剩余容器和图标按钮，如果把第二个IconButton移动到Expanded前则内容会发生改变 new IconButton( icon: new Icon(Icons.menu), tooltip: '导航菜单', onPressed: null ), //Expanded的作用可以使用剩余的所有空间。 new Expanded( child: title ), new IconButton( icon: new Icon(Icons.search), tooltip: '搜索', onPressed: null ) ], ), ); &#125;&#125;class MyScaffold extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Material( child: new Column( children: &lt;Widget&gt;[ new MyAppBar( title: new Text( '示例标题', style: Theme .of(context) .primaryTextTheme .title, ), ), new Expanded( child: new Center( child: new Text('你好世界！'), ), ) ], ), ); &#125;&#125;void main() &#123; runApp(new MaterialApp( title: '我的应用', home: new MyScaffold(), ));&#125; 其实说真的我第一眼看到这段代码的时候，第一想法就是，为什么会有这么多括号？但是这不是重点，有点编程经验的都知道要先从main函数看起，这里的main函数里面套了一个runApp函数， runApp函数接受指定的控件(Widget)，并使其作为控件树(widget tree)的根控件。 runApp里面new了一个MaterialApp对象，然后这个对象有两个参数，第一个是titile，指明了这个控件的标题是啥，第二个参数是home，指明了这个控件的主体是啥。 再深入的看就会发现，home的值是一个new出来的MyScaffold对象，这时我们就可以去查看MyScaffold这个类的声明代码。 MyScaffold控件为子控件设置垂直布局，在垂直顶部放置一个MyAppBar的实例（这个控件也是自己创建的），将MyAppBar的Text控件作为标题使用，将控件作为参数传递给其他控件非常方便实用的，你可以创建通用的控件，以各种方式重复的使用。最后，MyScaffold使用Expanded，用一个中心文本来填充剩余的空间。 MyAppBar控件创建了一个Container(容器)，高度为56设备无关像素(device-independent pixels)，内部左右填充8像素(pixels)。在容器内部，MyAppBar为子控件设置Row(水平)布局，中间的title控件被设置成Expanded，Expanded的作用是展开Row、Column和Flex的子控件，意味它可以使用剩余的所有空间。 其实上述的分析过程就是一个对控件数的一个遍历，从根控件到里面的子控件，Flutter的设计理念就是一切皆为控件，组件套组建。虽然上述代码不是java，c等主流代码，但是理解起来却并不是非常难懂，上手难度确实不大，值得体验。 最后，推荐一些链接： Flutter官网 Flutter教程 Flutter中文开发者论坛]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP长连接说明]]></title>
    <url>%2Fposts%2Fa8aa4c4c.html</url>
    <content type="text"><![CDATA[[HTTP协议与TCP/IP协议的关系] [如何理解HTTP协议是无状态的] 什么是长连接、短连接？ [TCP连接] [TCP短连接] [TCP长连接] [长连接和短连接的优点和缺点] 目前腾讯云负载均衡对七层负载均衡的HTTP长连接配置，可设置为默认值75s，用户可对不同的负载均衡实例进行自定义配置。那么，HTTP长连接、短连接究竟是什么？ HTTP协议与TCP/IP协议的关系HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。 如何理解HTTP协议是无状态的HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 什么是长连接、短连接？在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 TCP连接当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。 经典的三次握手建立连接示意图： 经典的四次握手关闭连接示意图： TCP短连接模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。 短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。 TCP长连接我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。 如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态： 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。 长连接和短连接的优点和缺点由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。 长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。 转自腾讯云：HTTP长连接说明]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>HTTP长连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动App网络优化概述]]></title>
    <url>%2Fposts%2F38627c74.html</url>
    <content type="text"><![CDATA[一般开发一个 APP，会直接调用系统提供的网络请求接口去服务端请求数据，再针对返回的数据进行一些处理，或者使用AFNetworking/OKHttp这样的网络库，管理好请求线程和队列，再自动做一些数据解析，就结束了。 但对于一些大型 APP，还会想针对网络的一些问题进行进一步优化，包括： 速度：网络请求的速度怎样能进一步提升？ 弱网：移动端网络环境随时变化，经常出现网络连接很不稳定可用性差的情况，怎样在这种情况下最大限度最快地成功请求？ 安全：怎样防止被第三方窃听/篡改或冒充，防止运营商劫持，同时又不影响性能？ 对基于浏览器的前端开发来说，网络这块能做的事情很少，但对于客户端 APP 来说，整个网络请求过程是自由控制的，可以做很多事情，很多大型 APP 都针对这三个问题做了很多网络层的优化，一些新的网络层协议像 HTTP2 / QUIC 也是在这些方面进行了不少优化，在这里边学习边整理，大致列举一下常见的做法。 速度正常一条网络请求需要经过的流程是这样： DNS 解析，请求DNS服务器，获取域名对应的 IP 地址。 与服务端建立连接，包括 tcp 三次握手，安全协议同步流程。 连接建立完成，发送和接收数据，解码数据。 这里有明显的三个优化点： 直接使用 IP 地址，去除 DNS 解析步骤。 不要每次请求都重新建立连接，复用连接或一直使用同一条连接(长连接)。 压缩数据，减小传输的数据大小。 逐条来看能做什么。 1.DNSDNS 完整的解析流程很长，会先从本地系统缓存取，若没有就到最近的 DNS 服务器取，若没有再到主域名服务器取，每一层都有缓存，但为了域名解析的实时性，每一层缓存都有过期时间，这种 DNS 解析机制有几个缺点： 缓存时间设置得长，域名更新不及时，设置得短，大量 DNS 解析请求影响请求速度。 域名劫持，容易被中间人攻击，或被运营商劫持，把域名解析到第三方 IP 地址，据统计劫持率会达到7%。 DNS 解析过程不受控制，无法保证解析到最快的IP 一次请求只能解析一个域名。 为了解决这些问题，就有了 HTTPDNS，原理很简单，就是自己做域名解析的工作，通过 HTTP 请求后台去拿到域名对应的 IP 地址，直接解决上述所有问题： 域名解析与请求分离，所有请求都直接用IP地址，无需 DNS 解析，APP 定时请求 HTTPDNS 服务器更新IP地址即可。 通过签名等方式，保证 HTTPDNS 请求的安全，避免被劫持。 DNS 解析由自己控制，可以确保根据用户所在地返回就近的 IP 地址，或根据客户端测速结果使用速度最快的 IP。 一次请求可以解析多个域名。 其余细节就不多说了，HTTPDNS 优点这么多，几乎成为中大型 APP 的标配。至此解决了第一个问题 — DNS 解析耗时的问题，顺便把一部分安全问题 — DNS 劫持也解决了。 2.连接第二个问题，连接建立耗时的问题，这里主要的优化思路是复用连接，不用每次请求都重新建立连接，如何更有效率地复用连接，可以说是网络请求速度优化里最主要的点了，并且这里的优化仍在演进过程中，值得了解下。 keep-aliveHTTP 协议里有个 keep-alive，HTTP1.1默认开启，一定程度上缓解了每次请求都要进行TCP三次握手建立连接的耗时。原理是请求完成后不立即释放连接，而是放入连接池中，若这时有另一个请求要发出，请求的域名和端口是一样的，就直接拿出连接池中的连接进行发送和接收数据，少了建立连接的耗时。 实际上现在无论是客户端还是浏览器都默认开启了keep-alive，对同个域名不会再有每发一个请求就进行一次建连的情况，纯短连接已经不存在了。但有个问题，就是这个 keep-alive 的连接一次只能发送接收一个请求，在上一个请求处理完成之前，无法接受新的请求。若同时发起多个请求，就有两种情况： 若串行发送请求，可以一直复用一个连接，但速度很慢，每个请求都要等待上个请求完成再进行发送。 若并行发送这些请求，那么首次每个请求都要进行tcp三次握手建立新的连接，虽然第二次可以复用连接池里这堆连接，但若连接池里保持的连接过多，对服务端资源产生较大浪费，若限制了保持的连接数，并行请求里超出的连接仍每次要建连。 对这个问题，新一代协议 HTTP2 提出了多路复用去解决。 多路复用HTTP2 的多路复用机制一样是复用连接，但它复用的这条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行，也就解决了上面说的并发请求需要建立多条连接带来的问题，网络上有张图可以较形象地表现这个过程： ￼ HTTP1.1的协议里，在一个连接里传送数据都是串行顺序传送的，必须等上一个请求全部处理完后，下一个请求才能进行处理，导致这些请求期间这条连接并不是满带宽传输的，即使是HTTP1.1的pipelining可以同时发送多个request，但response仍是按请求的顺序串行返回，只要其中一个请求的response稍微大一点或发生错误，就会阻塞住后面的请求。 HTTP2 这里的多路复用协议解决了这些问题，它把在连接里传输的数据都封装成一个个stream，每个stream都有标识，stream的发送和接收可以是乱序的，不依赖顺序，也就不会有阻塞的问题，接收端可以根据stream的标识去区分属于哪个请求，再进行数据拼接，得到最终数据。 解释下多路复用这个词，多路可以认为是多个连接，多个操作，复用就是字面上的意思，复用一条连接或一个线程。HTTP2这里是连接的多路复用，网络相关的还有一个I/O的多路复用(select/epoll)，指通过事件驱动的方式让多个网络请求返回的数据在同一条线程里完成读写。 客户端来说，iOS9 以上 NSURLSession 原生支持 HTTP2，只要服务端也支持就可以直接使用，Android 的 okhttp3 以上也支持了 HTTP2，国内一些大型 APP 会自建网络层，支持 HTTP2 的多路复用，避免系统的限制以及根据自身业务需要增加一些特性，例如微信的开源网络库 mars，做到一条长连接处理微信上的大部分请求，多路复用的特性上基本跟 HTTP2 一致。 TCP队头阻塞HTTP2 的多路复用看起来是完美的解决方案，但还有个问题，就是队头阻塞，这是受限于 TCP 协议，TCP 协议为了保证数据的可靠性，若传输过程中一个 TCP 包丢失，会等待这个包重传后，才会处理后续的包。HTTP2的多路复用让所有请求都在同一条连接进行，中间有一个包丢失，就会阻塞等待重传，所有请求也就被阻塞了。 对于这个问题不改变 TCP 协议就无法优化，但 TCP 协议依赖操作系统实现以及部分硬件的定制，改进缓慢，于是 GOOGLE 提出 QUIC 协议，相当于在 UDP 协议之上再定义一套可靠传输协议，解决 TCP 的一些缺陷，包括队头阻塞。具体解决原理网上资料较多，可以看看。 QUIC 处于起步阶段，少有客户端接入，QUIC 协议相对于 HTTP2 最大的优势是对TCP队头阻塞的解决，其他的像安全握手 0RTT / 证书压缩等优化 TLS1.3 已跟进，可以用于 HTTP2，并不是独有特性。TCP 队头阻塞在 HTTP2 上对性能的影响有多大，在速度上 QUIC 能带来多大提升待研究。 3.数据第三个问题，传输数据大小的问题。数据对请求速度的影响分两方面，一是压缩率，二是解压序列化反序列化的速度。目前最流行的两种数据格式是 json 和 protobuf，json 是字符串，protobuf 是二进制，即使用各种压缩算法压缩后，protobuf 仍会比 json 小，数据量上 protobuf 有优势，序列化速度 protobuf 也有一些优势，这两者的对比就不细说了。 压缩算法多种多样，也在不断演进，最新出的 Brotli 和Z-standard实现了更高的压缩率，Z-standard 可以根据业务数据样本训练出适合的字典，进一步提高压缩率，目前压缩率表现最好的算法。 除了传输的 body 数据，每个请求 HTTP 协议头的数据也是不可忽视，HTTP2 里对 HTTP 协议头也进行了压缩，HTTP 头大多是重复数据，固定的字段如 method 可以用静态字典，不固定但多个请求重复的字段例如 cookie 用动态字典，可以达到非常高的压缩率，这里有详细介绍。 通过 HTTPDNS，连接多路复用，更好的数据压缩算法，可以把网络请求的速度优化到较不错的程度了，接下来再看看弱网和安全上可以做的事情。 弱网手机无线网络环境不稳定，针对弱网的优化，微信有较多实践和分享，包括： 提升连接成功率复合连接，建立连接时，阶梯式并发连接，其中一条连通后其他连接都关闭。这个方案结合串行和并发的优势，提高弱网下的连接成功率，同时又不会增加服务器资源消耗：￼ 制定最合适的超时时间对总读写超时(从请求到响应的超时)、首包超时、包包超时(两个数据段之间的超时)时间制定不同的计算方案，加快对超时的判断，减少等待时间，尽早重试。这里的超时时间还可以根据网络状态动态设定。 调优TCP参数，使用TCP优化算法。对服务端的TCP协议参数进行调优，以及开启各种优化算法，使得适合业务特性和移动端网络环境，包括RTO初始值，混合慢启动，TLP，F-RTO等。 针对弱网的这些细致优化未成为标准，系统网络库没有内置，不过前两个客户端优化微信的开源网络库 mars 有实现，若有需要可以使用。 安全标准协议 TLS 保证了网络传输的安全，前身是 SSL，不断在演进，目前最新是 TLS1.3。常见的 HTTPS 就是 HTTP 协议加上 TLS 安全协议。 安全协议概括性地说解决两个问题：1.保证安全 2. 降低加密成本 在保证安全上： 使用加密算法组合对传输数据加密，避免被窃听和篡改。 认证对方身份，避免被第三方冒充。 加密算法保持灵活可更新，防止定死算法被破解后无法更换，禁用已被破解的算法。 降低加密成本上： 用对称加密算法加密传输数据，解决非对称加密算法的性能低以及长度限制问题。 缓存安全协议握手后的密钥等数据，加快第二次建连的速度。 加快握手过程：2RTT-&gt; 0RTT。加快握手的思路，就是原本客户端和服务端需要协商使用什么算法后才能加密发送数据，变成通过内置的公钥和默认的算法，在握手的同时就把数据发出去，也就是不需要等待握手就开始发送数据，达到0RTT。 这些点涉及的细节非常多，对 TLS 的介绍有一篇雄文，说得很详细，在此推荐。 目前基本主流都支持 TLS1.2，iOS 网络库默认使用 TLS1.2，Android4.4 以上支持 1.2。TLS1.3 iOS 还处于测试阶段，Android 未查到消息。对于普通 APP，只要正确配置证书，TLS1.2 已经能保证传输安全，只是在建连速度上会有所损耗，有一些大型 APP 像微信就自行实现)了 TLS1.3 的部分协议，早一步全平台支持。 最后网络优化这个话题非常庞大，本文只是在学习过程中从优化思路上列举了目前业界常见的优化点，还有很多细节很多更深入的优化没涉及到，网络层实践开发经验不足，若有错误欢迎指出。]]></content>
      <categories>
        <category>Android</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公司Android项目架构演进]]></title>
    <url>%2Fposts%2F600a4740.html</url>
    <content type="text"><![CDATA[入职ZTC接近两年，因为业务繁重，从入职开始一直在做业务上的需求，项目还是MVC模式开发，由此可见工程的耦合度极高，也是众多反锁的业务互相关联导致最初开发的时候没有很好的设计架构。经过大半年的边重构项目边合并老项目新需求的开发，见证了开发团队一路走来的努力，Android团队也在自己预期的想法中向前迈进。 前言在公司的发展方向上，由单一的求职平台，到人脉社交，问答社区的扩展，让我察觉到组件化必然是正确的演进方向。在项目gradle升级到3.x后，依赖隔离的新特性更是帮助我对组件化的推进工作。 组件化优点在现在的大环境下组件化的优点相信大家都比较熟悉。 高内聚，低耦合，代码边界清晰，每一个组件都可以拆分出来独立运行 功能集中，每一个组件负责属于自己组件的工作，不受其他组件影响也不影响其他组件功能 提高开发效率，每个组件可单独调试，保证代码质量 减少重复造轮子和维护工作量 加快编译速度，最理想的情况是，App工程仅仅是一个空壳，用于加载各个组件 组件化方案现在GitHub上面流行着各大家公司开源的路由库，他们基本采用组件化的方案是 这个是比较通用组件化的一个方式，当然不同厂有着会根据自己的实际情况进行改造流程，但是基本大同小异，我们五花八门讨论得最多的是不同业务组件的路由通讯协议封装，我们将一个个业务组件细化拆分，不可能最后是互相直接依赖使用导致各种混乱和耦合，我们此时需要的是路由，它帮我们管理各业务组件间有序地通讯，路由重点划一下:事件分发和动态拦截。 我第一期组件化的工作方向是功能模块化与业务组件化相结合。这是因为我们项目是一直遵循着模块化，对功能的整理比较好，我这边不对每一个业务进行拆分组件化，也就是不采用现很热门的路由通讯方式，因为如果我将项目弄成完全组件化，是过度封装了，导致开发成本不协调，然而目前我们首要处理的问题是业务组件复用问题，所以避免我们重复造轮子，我们先将咨询组件、支付组件、定位组件、网络请求组件、推送组件进行分离，同时优化封装图片加载库、普通工具库、Banner工具库、友盟第三方库、图片选择库、JSBridge库、地图库等非业务性的基础库。 总结组件化的推进工作，从简单的分离代码，里面帮助我们更好地梳理了陈旧代码，及时整理好wiki。到享受面向过程、面向对象、面向接口、面向切面的编程乐趣。 展望到了最后，这次组件化构架演进，只是一个开始，就如一开始所说的，将来会有一天多款App会进行整合，我个人推荐的是通过插件化的方式加载对应的业务模块，在前段时间官方所推出的动态化框架Android App Bundles更适合未来的发展。另外在未来大前端完全介入商城日常开发，架构还会继续进行调整。以上是我的简单总结和对模块化的一些尝试，不足之处还望大家交流指正。]]></content>
      <categories>
        <category>Android</category>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中JSBridge的原理与实现]]></title>
    <url>%2Fposts%2F88a3890e.html</url>
    <content type="text"><![CDATA[Android中的JSBridge是H5与Native通信的桥梁，其作用是实现H5与Native间的双向通信。要实现H5与Native的双向通信，解决如下四个问题即可： 1、Java如何调用JavaScript 2、JavaScript如何调用Java 3、方法参数以及回调如何处理 4、通信的数据格式是怎么样的 下面从以上问题依次开始讨论: 1、Java如何调用JavaScript在Android 中，Java与JavaScript的一切交互都是依托于WebView的。可通过如下方法来完成，其中function（）即为JavaScript代码，来实现相应的具体H5层功能 WebView.loadUrl("javascript:function()"); 2、JavaScript如何调用Java要实现在JavaScript中调用Java，就需要在JavaScript中有触发Java方法的对象和方法。在JavaScript中，当调用window对象的prompt方法时，会触发Java中的WebChromeClient对象的onJsPrompt方法，因此可以利用这个机制来实现js调用native的代码。 3、方法参数以及回调处理任何IPC通信都涉及到参数序列化的问题，同理，Java与JavaScript之间只能传递基础类型（包括基本类型和字符串），不包括其他对象或者函数。所以可以采用json格式来传递数据。JavaScript与Java相互调用不能直接获取返回值，只能通过回调的方式来获取返回结果。 4、通信的数据格式Java与JavaScript通信需要遵循一定的通信协议，可以仿照HTTPS协议来将此协议定义为jsbridge协议： jsbridge://className:port/methodName?jsonObj 当js调用native功能时，应当指定native层要完成某个功能调用的类名（className）和方法名（methodName），以及js传递过来的参数（jsonObj）。port值是指当native需要将操作结果返回给js时，在js中定义一个callback，并将这个callback存储在指定的位置上，这个port就定义了callback的存储位置。 JSBridge的具体工作流程图如上所示：1、js触发调用native层的行为 JSBridge.call(className, methodName, params, callback); 将call方法中的参数组合成jsbridge协议格式的url。然后通过prompt方法将url传递到native层。 window.prompt(url); 2、通过WebChromeClient来获取js传递过来的url. public class JSBridgeWebChromeClient extends WebChromeClient &#123; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; result.confirm(JSBridge.callJava(view, message)); return true; &#125;&#125; 3、JSBridge类管理暴露给前端方法，前端调用的方法应该在此类中注册才可使用。register的实现是从Map中查找key是否存在，不存在则反射取得对应class中的所有方法,具体方法是在BridgeImpl中定义的，方法包括三个参数分别为WebView、JSONObject、CallBack。如果满足条件，则将所有满足条件的方法put到map中。 private static Map&lt;String, HashMap&lt;String, Method&gt;&gt; exposedMethods = new HashMap&lt;&gt;();public static void register(String exposedName, Class&lt;? extends IBridge&gt; clazz) &#123; if (!exposedMethods.containsKey(exposedName)) &#123; try &#123; exposedMethods.put(exposedName, getAllMethod(clazz)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; JSBridge类中的callJava方法就是将js传递过来的URL解析，根据将要调用的类名从刚刚建立的Map中找出，根据方法名调用具体的方法，并将解析出的三个参数传递进去。 public static String callJava(WebView webView, String uriString) &#123; String methodName = ""; String className = ""; String param = "&#123;&#125;"; String port = ""; if (!TextUtils.isEmpty(uriString) &amp;&amp; uriString.startsWith("JSBridge")) &#123; Uri uri = Uri.parse(uriString); className = uri.getHost(); param = uri.getQuery(); port = uri.getPort() + ""; String path = uri.getPath(); if (!TextUtils.isEmpty(path)) &#123; methodName = path.replace("/", ""); &#125; &#125; if (exposedMethods.containsKey(className)) &#123; HashMap&lt;String, Method&gt; methodHashMap = exposedMethods.get(className); if (methodHashMap != null &amp;&amp; methodHashMap.size() != 0 &amp;&amp; methodHashMap.containsKey(methodName)) &#123; Method method = methodHashMap.get(methodName); if (method != null) &#123; try &#123; method.invoke(null, webView, new JSONObject(param), new Callback(webView, port)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; return null; &#125; 4、CallBack类是用来回调js中回调方法的Java对应类。Java层处理好的返回结果是通过CallBack类来实现的。在这个回调类中传递的参数是JSONObject（返回结果）、WebView和port，port应与js传递过来的port相对应。 private static Handler mHandler = new Handler(Looper.getMainLooper()); private static final String CALLBACK_JS_FORMAT = "javascript:JSBridge.onFinish('%s', %s);"; private String mPort; private WeakReference&lt;WebView&gt; mWebViewRef; public Callback(WebView view, String port) &#123; mWebViewRef = new WeakReference&lt;&gt;(view); mPort = port; &#125; public void apply(JSONObject jsonObject) &#123; final String execJs = String.format(CALLBACK_JS_FORMAT, mPort, String.valueOf(jsonObject)); if (mWebViewRef != null &amp;&amp; mWebViewRef.get() != null) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mWebViewRef.get().loadUrl(execJs); &#125; &#125;); &#125; &#125; 5、JSBridgeImpl类中定义所有暴露给前端的方法的具体实现。本文以showToast为例来通过native代码显示toast，并给出js的回调函数，返回一个JSONObject对象。 public static void showToast(WebView webView, JSONObject param, final Callback callback) &#123; String message = param.optString("msg"); Toast.makeText(webView.getContext(), message, Toast.LENGTH_SHORT).show(); if (null != callback) &#123; try &#123; JSONObject object = new JSONObject(); object.put("key", "value"); object.put("key1", "value1"); callback.apply(getJSONObject(0, "ok", object)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 6、在js中通过 JSBridge.call('bridge','showToast',&#123;'msg': 'Hello'&#125;, function(res)&#123;alert(JSON.stringi fy(res))&#125;)" 即可调用在Java层定义的showToast方法，调用前不要忘记在java层的JSBridge中注册该方法。 JSBridge.register("bridge", BridgeImpl.class); 二、总结：JSBridge的基本原理为：H5-&gt;通过某种方式触发一个url-&gt;Native捕获到url,进行分析-&gt;原生做处理-&gt;Native调用H5的JSBridge对象传递回调。如下图 三、安全性： Android4.2以下，addJavascriptInterface方法有安全漏洞，js代码可以获取到Java层的运行时对象，来伪造当前用户执行恶意代码。 ios7以下，JavaScript无法调用native代码。 通过js声明的对象，是通过loadUrl注入到页面中的，所以这个对象是js对象，而不是Java对象，没有getClass等Object方法，因此也无法获得Runtime对象，避免了恶意代码的注入。 JSBridge采用URL解析的交互方式，是一套成熟的解决方案，便于拓展，无重大安全性问题。]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradle.properties文件使用]]></title>
    <url>%2Fposts%2Ffb76c4ba.html</url>
    <content type="text"><![CDATA[在一些项目中会分拆app 和 lib , 这时候引用support的时候,一旦更改版本会出现需要同步更改两个地方的问题.这种情况,可以通过配置gradle.properties实现替换.在项目编译过程中,gradle.properties配置的值会被编译解析,其作为配置文件使用是很有必要的. 1. 概述在Android Studio 创建一个项目的时候，Project下面会生成gradle.properties和local.properties文件，如下图: 2. properties的数据格式properties里面的数据格式采用键值对的方式，大概有以下几种写法:1. key=value 2. key:value 3. key :value 4. # 作为注释 这里主要参考以下链接：https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html注意: 在Android Studio 中最好使用第一种写法，要不会有警告 3. 如何使用3.1 在项目根目录的gradle.properties文件配置:# Project-wide Gradle settings.#添加ndk支持(按需添加)android.useDeprecatedNdk=true# 应用版本名称VERSION_NAME=1.0.0# 应用版本号VERSION_CODE=100# 支持库版本SUPPORT_LIBRARY=24.2.1# MIN_SDK_VERSIONANDROID_BUILD_MIN_SDK_VERSION=14# TARGET_SDK_VERSIONANDROID_BUILD_TARGET_SDK_VERSION=24# BUILD_SDK_VERSIONANDROID_BUILD_SDK_VERSION=24# BUILD_TOOLS_VERSIONANDROID_BUILD_TOOLS_VERSION=24.0.3 3.2 这时候配置app和lib的build.gradle可以这样写:android &#123; compileSdkVersion project.ANDROID_BUILD_SDK_VERSION as int buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION defaultConfig &#123; applicationId project.APPLICATION_ID // lib项目不需要配置这一项 versionCode project.VERSION_CODE as int versionName project.VERSION_NAME minSdkVersion project.ANDROID_BUILD_MIN_SDK_VERSION as int targetSdkVersion project.ANDROID_BUILD_TARGET_SDK_VERSION as int &#125;&#125;dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) //这里注意是双引号 compile &quot;com.android.support:appcompat-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:design:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:recyclerview-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:support-annotations:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:cardview-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:support-v4:$&#123;SUPPORT_LIBRARY&#125;&quot;&#125; 这样配置后,当你需要升级你的编译版本,版本号,支持库等的时候,仅需要修改项目根目录的gradle.properties文件即可,是不是又方便了一点点?]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unable to resolve dependency for ':trunk@debug/compileClasspath']]></title>
    <url>%2Fposts%2F4cae3fd9.html</url>
    <content type="text"><![CDATA[repositories &#123; google() jcenter() &#125; Go to File-&gt;Settings-&gt;Build, Execution, Deployment-&gt;Gradle-&gt;Uncheck Offline work option.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码规范指南]]></title>
    <url>%2Fposts%2F89cc132f.html</url>
    <content type="text"><![CDATA[前言 无论你是个人开发还是团队，一个良好的代码规范，能够在项目当中发挥举足轻重的作用；它不仅能使你们的开发更加高效，而且还会减少BUG产生的几率，增强代码可维护性及稳定性。 关于规范，我们分两部分来讲，因为Android主要是用Java语言来写的，所以我们区别对待。 JAVA代码规范强制性规范: 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 类名使用UpperCamelCase 风格，必须遵从驼峰形式。 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长例如：MAX_STOCK_COUNT。 抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类 命名以它要测试的类的名称开始。 杜绝不规范的英文缩写：AbstractClass 缩写成AbsClass；condition缩写成condi;此类随意缩写严重降低了代码的可阅读性。 如果使用到了设计模式，建议在类名中体现出具体的模式： 关于Service或Dao层的命名 public class ComponentFactorypublic class BufferStrategypublic class ScrollerProxy 实体类必须重载toString()方法，这样可以通过调用对象的toString()来排查问题。 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例: “test”.equals(object); 反例: object.equals(“test”); 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 推荐规范： 集合初始化时，尽量指定集合初始值大小； ArrayList尽量使用ArrayList(int initialCapacity) 初始化 。 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历 说明:keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效 率更高。如果是 JDK8，使用 Map.foreach 方法。 高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格: 集合类 Key Value Super 说明 Hashtable 不允许为null 不允许为null Dictionary 线程安全 ConcurrentHashMap 不允许为null 不允许为null AbstractMap 分段锁技术 TreeMap 不允许为null 允许为null AbstractMap 线程不安全 HashMap 允许为null 允许为null AbstractMap 线程不安全 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。 通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优 化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题 解决方案中较为简单一种(适用于 JDK5 及以上版本)，将目标属性声明为 volatile 型。 *反例*：class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members... &#125; Android代码规范代码： Activity 命名一律使用 模块名+Activity 的方式。例如，LoginActivity、SignupActivity； Fragment 命名一律使用 模块名+Fragment 的方式； 自定义View：Custom(建议)+功能名+View/ViewGroup(具体的组件名称)。例如：CustomImageScroller、CustomRatingBar。 Widget 小组件：ScanWidget、WeatherWidget。 Dialog对话框：功能名+Dialog。例如：LoginDialog、ProgressDialog 尽量在每一个Activity或类中加入TAG,方便我们查看Activity的信息。(Tip : 使用Android Studio提供的快捷键logt可快速生成当前 类的常量) 对于使用Intent传递数据，声明一些Key的时候： EXTRA_KEY_+具体Key名称，例如我们现在有一个人的名字和年龄要传那么首先定义： public static final String EXTRA_KEY_PERSON_NAME=&quot;EXTRA_KEY_PERSON_NAME&quot;public static final String EXTRA_KEY_PERSON_AGE=&quot;EXTRA_KEY_PERSON_AGE&quot; 然后在具体的页面 new Intent()，依次传递进去值，这样写其实没什么问题；但是试想一下，如果你要调用的Activity是类似于一个工具性质或通用的Activity（图片选择器、登录、注册等等），这时候你要传递的key又很多，如果业务复杂的话，你应该会被这样冗余且不易阅读的代码直接搞崩溃掉。 所以最好的办法就是在你要调用Activity提供一个静态工厂方法，要知道静态工厂方法所带来的好处太多了，由于Activity是不允许通过new的方式来初始化的，所以静态工厂方法的好处在此就不那么明显，但是已经足够我们优化我们的代码了。举个例子，我们有一个笔记 NoteActivity，用于创建笔记和修改笔记， //笔记Idprivate static final String EXTRA_KEY_NOTE_ID =&quot;EXTRA_KEY_NOTE_ID&quot; ;//笔记内容private static final String EXTRA_KEY_NOTE_CONTENT =&quot;EXTRA_KEY_NOTE_CONTENT&quot; ;//笔记模式private static final String EXTRA_KEY_NOTE_MODE =&quot;EXTRA_KEY_NOTE_MODE&quot; ;//用于创建笔记public static void startForCreate(Context context, int noteId) &#123; start(context, noteId, null, MODE_CREATE);&#125; //用于编辑笔记public static void startForEdit(Context context, int noteId, String content) &#123; start(context, noteId, content, MODE_UPDATE);&#125;public static void start(Context context, int noteId, String content, int mode) &#123; Intent starter = new Intent(context, TableShareListSettingActivity.class); starter.putExtra(EXTRA_KEY_NOTE_ID,noteId); starter.putExtra(EXTRA_KEY_NOTE_CONTENT,content); starter.putExtra(EXTRA_KEY_NOTE_CONTENT,mode); context.startActivity(starter);&#125; 通过以上方法，我们能够很好的解耦复杂的Activity之间的调用，再加上静态方法工厂方法名，代码可阅读行大大提高，最终我们看到的调用NoteActivity将会是很简洁的一段代码： NoteActivity.startForCreate(this,noteId);NoteActivity.startForEdit(this,noteId,content); 此外，Android Studio工具中其实已经在Live Template中提供了这样的代码:CMD+J( For MAC OS),简单的输入starter就可以快速地在当前的Activity中添加一个Intent的静态操作方法，这其实也说明了Android官方团队也鼓励我们这么做。 如下图所示： 一下子省了好多代码，简直太赞了有木有！ 增加类注释，使用Android Studio的 File And Code Template： 所有的常量加上注释，且功能相同的排放在一起，不同的进行换行； Activity中变量采用m开头+类名。例如，mTable、mPerson； Activity中的控件：m+模块名+控件类型名称。例如，mLoginEditText,mLoginTextView; 资源Res1.按照资源的类型，分为以下几种 控件Id命名：控件缩写 _模块（module) _功能名(function) 控件类型 ID命名规则 TextView tv_module_function EditText et_module_function ImageView iv_module_function Button btn_module_function ListView lv_module_function GridView gv_module_function CheckBox check_module_function RadioButton radio_module_function LinearLayout ll_module_function RelativeLayout rl_module_function FrameLayout fl_module_function GridLayout gl_module_function ··· ··· Color资源命名 Resources Type 命名规则 color 组件名+具体作用名。例 R.color.button_text String资源命名 Resources Type 命名规则 string 具体功能。 例 R.string.hello Drawable资源命名 Resources Type 命名规则 launcher icon ic_launcher。例R.drawable.ic_launcher normal icon ic_具体模块_功能。例R.drawable.ic_audio_pause Toolbar icon ic_ab_功能名。例如ic_ab_search selector selector_模块_功能名。例如 selector_login_button shape shape_模块功能名状态。例如 R.drawable.shape_login_button_normal Layout资源命名 类型 命名规则 activity activity_模块名。例如 R.layout.activity_login fragment fragment_模块名。例如 R.layout.fragment_login_layout_header include layout_模块名_功能名。例如 @layout/layout_login_bottom adapter adapter_item_模块名_功能名。例如 R.layout.adapter_item_simple_text dialog dialog_模块_功能名。例如 R.layout.dialog_time_picker list header header_模块_功能。例如 R.layout.header_main_top_ad list footer footer_模块_功能。例如 R.layout.footer_main_bottom_action widget widget_模块_功能。例如 R.layout.widget_app_clock ··· ··· Menu资源命名 Resources Type 命名规则 menu menu_模块名。例如 menu_login Values资源命名 Resources Type 命名规则 color 模块名_color。例如 material_design_color dimens 模块名_dimens。例如 material_design_dimens style 模块名_style。例如 material_design_style themes 模块名_themes。例如 material_design_themes 总结其实代码规范只是一个Guideline，没有说非要某一种风格来编写代码。如果你的团队有自己的一套代码规范，然后开发也很高效，代码也很容易阅读且可维护，就完全可以按照自己的团队的技术规范来。我想表达的是，在编写的代码的时候，能有一个Guideline（准则）或者说是一个约定，我们共同遵守这样的约定，来达到我一开始说的代码规范性所带来的意义。 正所谓，“离娄之明，公输子之巧，不以规矩，不能成方圆。” 参考资料阿里巴巴Java开发手册]]></content>
      <categories>
        <category>Android</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置iPhone来电铃声]]></title>
    <url>%2Fposts%2Fb0d3dc9.html</url>
    <content type="text"><![CDATA[步骤 1保证电脑上有可以播放的音乐，找到喜欢的一首歌曲，鼠标右击用 iTunes 打开，「选中歌曲《故乡》」—「右键」—「歌曲信息」，如下图： 点击「歌曲信息」后，出现一个弹框，点击「选项」，勾选「停止」，右边的输入框里面输入 0:28，因为铃声必须是40秒之内的，然后点击「好」，如图： （PS：假设这首歌的时间是5:20，你可以任意设置播放的时间段，假如高潮部分是1:32到2:05，则勾选’开始’并输入1:32，勾选’停止’并输入2:05） 步骤 2还是选中歌曲《故乡》，右上角，依次选择「文件」—「转换」—「创建 AAC 版本」，如图： 然后可能会听到一个声音，说明创建成功，在刚刚选中的歌曲《故乡》下面会多出一个一模一样的来，只不过时间变成刚刚我填写的，如图： 步骤 3选中时间较短的《故乡》，右键选择「在 Finder 中显示」，如图： 这时可以看到故乡.m4a这样一个文件，是可以播放的，把它复制到桌面上来。鼠标选中桌面上的故乡.m4a，改为故乡.m4r，选择「使用 .m4r」，如图： 步骤 4选择你的手机，如图： 勾选「手动管理音乐和视频」，之后点击「应用」，等待完成，如图： 步骤 5在桌面上把故乡.m4r歌曲拖到手机上，如下图： 这时候发现手机下的「铃声」目录，会出现刚刚的歌曲，如图： 继续选择你的手机，点击同步，静静等待完成。 在同步的过程中，如果出现如下图所示，则说明设置的铃声时间过长，应当在 40s 之内： 结束同步完成后，算是大功告成了，拿起iPhone，按顺序 选择「设置」—「声音」—「电话铃声」，激动人心的时刻终于来了~~~ 大功告成.png]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidView的绘制流程]]></title>
    <url>%2Fposts%2Fd94c207f.html</url>
    <content type="text"><![CDATA[本文主要是梳理 View 绘制的整体流程，帮助开发者对 View 的绘制有一个更深层次的理解。 整体流程View 绘制中主要流程分为measure，layout， draw 三个阶段。 measure ：根据父 view 传递的 MeasureSpec 进行计算大小。 layout ：根据 measure 子 View 所得到的布局大小和布局参数，将子View放在合适的位置上。 draw ：把 View 对象绘制到屏幕上。 那么发起绘制的入口在哪里呢？在介绍发起绘制的入口之前，我们需要先了解Window，ViewRootImpl，DecorView之间的联系。 一个 Activity 包含一个Window，Window是一个抽象基类，是 Activity 和整个 View 系统交互的接口，只有一个子类实现类PhoneWindow，提供了一系列窗口的方法，比如设置背景，标题等。一个PhoneWindow 对应一个 DecorView 跟 一个 ViewRootImpl，DecorView 是ViewTree 里面的顶层布局，是继承于FrameLayout，包含两个子View，一个id=statusBarBackground 的 View 和 LineaLayout，LineaLayout 里面包含 title 跟 content，title就是平时用的TitleBar或者ActionBar，contenty也是 FrameLayout，activity通过 setContent（）加载布局的时候加载到这个View上。ViewRootImpl 就是建立 DecorView 和 Window 之间的联系。 这三个阶段的核心入口是在 ViewRootImpl 类的 performTraversals() 方法中。 private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 在源码中这个方法贼长，但是核心还是这三个步骤，就是判断根据之前的状态判断是否需要重新 measure，是否需要重新 layout ，是否需要重新 draw。 measureSpeac在介绍 measure 方法之前，需要了解一个很核心的概念：measureSpeac 。在 Google 官方文档中是这么定义 measureSpeac 的 A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. A MeasureSpec is comprised of a size and a mode.大概意思是：MeasureSpec 封装了从父View 传递给到子View的布局需求。每个MeasureSpec代表宽度或高度的要求。每个MeasureSpec都包含了size（大小）和mode（模式）。 我觉得这是measureSpeac 最好的解释了。 后面两句不难理解。MeasureSpec 一个32位二进制的整数型，前面2位代表的是mode，后面30位代表的是size。mode 主要分为3类，分别是 EXACTLY：父容器已经测量出子View的大小。对应是 View 的LayoutParams的match_parent 或者精确数值。 AT_MOST：父容器已经限制子view的大小，View 最终大小不可超过这个值。对应是 View 的LayoutParams的wrap_content UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。(这种不怎么常用，下面分析也会直接忽略这种情况) 封装了从父 View 传递给到子 View 的布局需求，这句话又怎么理解呢？ View 的 MeasureSpec 并不是父 View 独自决定，它是根据父 view 的MeasureSpec加上子 View 的自己的 LayoutParams，通过相应的规则转化。 看代码： View 测量流程是父 View 先测量子 View，等子 View 测量完了，再来测量自己。在ViewGroup 测量子 View 的入口就是 measureChildWithMargins protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //获取子View的LayoutParam final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //通过父View的MeasureSpec和子View的margin，父View的padding计算，算出子View的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //通过计算出来的MeasureSpec，让子View自己测量。 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //计算子View的大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // 父View是EXACTLY的 case MeasureSpec.EXACTLY: //子View的width或height是个精确值,则size为精确值，mode为 EXACTLY if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 EXACTLY &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; //子View的width或height是WRAP_CONTENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 2、父View是AT_MOST的 case MeasureSpec.AT_MOST: //子View的width或height是个精确值,则size为精确值，mode为 EXACTLY if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 父View是UNSPECIFIED的 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 通过代码我们很可以很看到 View 的子 View 的 MeasureSpec 转化规则，但是感觉可能有点懵，我们用一个”商城-衣服”例子来比喻一下： 我们把父 View 看做成商城，子 View 看做成衣服，EXACTLY / MATCH_PARENT 看做成高档品牌，AT_MOST / WRAP_CONTENT 看做成杂牌，精确值看做成价格，View的大小看做价格。 如果是衣服（子 View）产地是高档品牌（LayoutParams = LayoutParams.MATCH_PARENT），商城是（父 View）高档的商城（EXACTLY），那么衣服的价格（size 大小）就会根据高档商城价格来定，能有多高就卖多高（View的大小取决于父View大小）。 如果是衣服（子 View）产地是高档品牌（LayoutParams = LayoutParams.MATCH_PARENT），商城是（父 View）杂牌的商城（AT_MOST），那么衣服的价格（size 大小）也会根据低档商城价格来定，太高普通人也买不起呀（View的大小取决于父View大小）。 如果是衣服（子 View）产地是杂牌（LayoutParams = LayoutParams.WRAP_CONTENT），商城是（父 View）高档的商城（EXACTLY），那么衣服的价格（size 大小）也会根据高档商城价格来定，能有多高就卖多高，毕竟店大欺人，绝不打折（View的大小取决于父View大小）。 如果是衣服（子 View）产地是杂牌（LayoutParams = LayoutParams.WRAP_CONTENT），商城是（父 View）杂牌的商城（AT_MOST），那么衣服的价格（size 大小）就会根据低档商城价格来定，小巷步行街不都是这样卖的吗（View的大小取决于父View大小） 如果是衣服（子 View）已经全国明码标价（android:layout_xxxx=”200dp”），商城是（父 View）无论是杂牌的商城（AT_MOST）还是高档的商城（EXACTLY），那么衣服的价格（size 大小）就不会变的。，不然打你小屁屁。 如果你觉得例子真的糟糕透了，那么看以下一表正经总结： 一表正经总结以下： 当父View的mode是EXACTLY的时候：说明父View的大小是确定的 子View的宽或高是MATCH_PARENT： 子View的宽或高是WRAP_CONTENT：子View是包裹布局，说明子View的大小还不确定，所以子View最大不能超过父View的大小mode=AT_MOST。 子View的宽或高是具体数值：子viewd大小已经固定了，子View的大小就是固定这个数值，mode=EXACTLY。 当父View的mode是AT_MOST的时候：说明父View大小是不确定的。 子View的宽或高是MATCH_PARENT：父View大小是不确定的，子View是填充布局情况，也不能确定大小，所以View大小不能超过父View的大小，mode=AT_MOST 子View的宽或高是WRAP_CONTENT：子View是包裹布局，大小不能超过父View的大小，mode=AT_MOST。 子View的宽或高是具体数值：子viewd大小已经固定了，子View的大小就是固定这个数值，mode=EXACTLY。 需要注意一点就是，此时的MeasureSpec并不是View真正的大小，只有setMeasuredDimension之后才能真正确定View的大小。 measuremeasure 主要功能就是测量设置 View 的大小。该方法是 final 类型，子类不能覆盖，在方法里面会调用 onMeasure()，我们可以复写 onMeasure（） 方法去测量设置 View 的大小。 public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; /*-----------省略代码---------------* onMeasure(widthMeasureSpec, heightMeasureSpec); /*-----------省略代码---------------*/ &#125; 在 onMeasure( ) 方法中protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; onMeasure( ) 方法就是执行测量设置 View 代码的核心所在。 我们先来看下 getSuggestedMinimumWidth() protected int getSuggestedMinimumWidth() &#123; //返回建议 View 设置最小值宽度 return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; 这里返回的建议最小值就是我们xml 布局中用的属性 minWidth或者是背景大小。 同理可得 getSuggestedMinimumHeight()。 看下 getDefaultSize 主要作用就是根据View的建议最小值，结合父View传递的measureSpec，得出并返回measureSpec 看代码 public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; //获取父View传递过来的模式 int specMode = MeasureSpec.getMode(measureSpec); //获取父View传递过来的大小 int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size;//View的大小父View未定，设置为建议最小值 break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; getDefaultSize 的逻辑跟我们之前分析的 MeasureSpec 转化规则非常相似。就是根据specMode设置大小。如果specMode是UNSPECIFIED 未确定大小，则会使用建议最小值，如果其他两种情况，则使用父View传递过来的大小。再次强调：并不是父View 独自决定，它是根据父 view 的MeasureSpec加上子vIew的自己的LayoutParams，通过相应的规则转化而得到的大小。 再来看下 setMeasuredDimension setMeasuredDimension 作用就是将测量好的宽跟高进行存储。在onMeasure（） 必须调用这个方法，不然就会抛出 IllegalStateException 异常。 我们重新梳理一下刚才那些流程： 在measure 方法，核心就是调用onMeasure( ) 进行View的测量。在onMeasure( )里面，获取到最小建议值，如果父类传递过来的模式是MeasureSpec.UNSPECIFIED，也就是父View大小未定的情况下，使用最小建议值，如果是AT_MOST或者EXACTLY模式，则设置父类传递过来的大小，然后调用setMeasuredDimension 方法进行存储大小。 layout()作用描述measure（） 方法中我们已经测量出View的大小，根据这些大小，我们接下来就需要确定 View 在父 View 的位置进行排版布局，这就是layout 作用。对 View 进行排版布局，还是要看父 View，也就是 ViewGroup。 看代码@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 代码不多，大致作用就是判断 View 是否在执行动画，如果是在执行动画，则等待动画执行完调用 requestLayout()，如果没有添加动画或者动画已经执行完了，则调用 layout（），也就是调用View的 layout（）。 public void layout(int l, int t, int r, int b) &#123; /*-----------省略代码---------------*/ boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; /*-----------省略代码---------------*/&#125; View 的 layout 的方法也是非常长。大致作用就是设置 View 的在父 View 的位置，然后判断位置是否发生变化，是否需要重新调用排版布局，如果是需要重新布局则用了 onLayout（）方法。在OnLayout 方法中，View 里面是一个空实现，而 ViewGroup 则是一个抽象方法。为什么这么设计呢？因为onLayout中主要就是为了给遍历View然后进行排版布局，分别设置View在父View中的位置。既然如此，那么View的意义就不大了，而ViewGruo 必须实现，不然没法对子View进行布局。那么如何对 View 进行排版呢？举例个简单的demo。 protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); for ( int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); child.layout(l, t, r, b); &#125;&#125; 就是遍历所有的子 View 然后调用 child.layout(l, t, r, b)。 大家有兴趣也可以参考一下 FrameLayout， LinearLayout这类布局。 draw（）经过前面两部的测量跟布局之后，接下来就是绘制了，也就是真正把 View 绘制在屏幕可见视图上。draw（）作用就是绘制View 的背景，内容，绘制子View,还有前景跟滚动条。看下 View 的draw（） 源码 @CallSuperpublic void draw(Canvas canvas) &#123; /*-----------省略代码---------------*/ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; /*-----------省略代码---------------*/ if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); /*-----------省略代码---------------*/ return; &#125; draw 过程中一共分成7步，其中两步我们直接直接跳过不分析了。 第一步：drawBackground(canvas)： 作用就是绘制 View 的背景。 第三步：onDraw(canvas) ：绘制 View 的内容。View 的内容是根据自己需求自己绘制的，所以方法是一个空方法，View的继承类自己复写实现绘制内容。 第三步：dispatchDraw（canvas）：遍历子View进行绘制内容。在 View 里面是一个空实现，ViewGroup 里面才会有实现。在自定义 ViewGroup 一般不用复写这个方法，因为它在里面的实现帮我们实现了子 View 的绘制过程，基本满足需求。 第四步：onDrawForeground(canvas)：对前景色跟滚动条进行绘制。 第五步：drawDefaultFocusHighlight(canvas)：绘制默认焦点高亮。 好了，整个绘制流程就分析完毕了！]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年轻人一定要知道的71条做饭技巧，让你做出美味又营养的美食！]]></title>
    <url>%2Fposts%2F7de80bae.html</url>
    <content type="text"><![CDATA[1、煮水饺时，在水里放一颗大葱或在水开后加点盐，再放饺子，饺子味道鲜美不粘连；在和面时，每500克面粉加拌一个鸡蛋，饺子皮挺刮不粘连2、 炖肉时，在锅里加上几块桔皮，可除异味和油腻并增加汤的鲜味3、煮骨头汤时加一小匙醋，可使骨头中的磷、钙溶解于汤中，并可保存汤中的维生素。5、烧豆腐时，加少许豆腐乳或汁，味道芳香7、将绿豆在铁锅中炒10分钟再煮能很快煮烂，但注意不要炒焦8、煮蛋时水里加点醋可防蛋壳裂开，事先加点盐也可 9、煮海带时加几滴醋易烂；放几棵波菜也行 10、煮火腿之前，将火腿皮上涂些白糖，容易煮烂，味道更鲜美12、煮水饺时，在锅中加少许食盐，锅开时水也不外溢 15、熬粥或煮豆时不要放碱，否则会破坏米、豆中的营养物质 16、用开水煮新笋容易熟，且松脆可口；要使笋煮后不缩小，可加几片薄荷叶或盐17、猪肚煮熟后，切成长块，放在碗内加一些鲜汤再蒸一会儿，猪肚便会加厚一倍18、煮猪肚时，千万不能先放盐，等煮熟后吃时再放盐，否则猪肚会缩得象牛筋一样硬 20、煮牛肉和其他韧、硬肉类以及野味禽类时，加点醋可使其软化。 21、炖老鸡：在锅内加二三十颗黄豆同炖，熟得快且味道鲜；或在杀老鸡之前，先灌给鸡一汤匙食醋，然后再杀，用文火煮炖，就会煮得烂熟；或放３～４枚山楂，鸡肉易烂 23、炖老鸭：在锅里放几个田螺容易烂熟 24、烧鸭子时，把鸭子尾端两侧的臊豆去掉，味道更美 25、煮咸肉：用十几个钻有许多小孔的核桃同煮，可消除臭味26、红烧牛肉时，加少许雪里红，肉味鲜美 27、做红烧肉前，先用少许硼砂把肉腌一下，烧出来的肉肥而不腻，甘香可口 28、油炸食物时，锅里放少许食盐，油不会外溅 29、在春卷的拌馅中适量加些面粉，能避免炸制过程中馅内菜汁流出糊锅底的现象30、炸土豆之前，先把切好的土豆片放在水里煮一会儿，使土豆皮的表面形成一层薄薄的胶质层，然后再用油炸 31、炸猪排时，在有筋的地方割２～３个切口，炸出来的猪排就不会收缩 32、将鸡肉先腌一会儿，封上护膜放入冰箱，待炸时再取出，炸出的鸡肉酥脆可口33、煎荷包蛋时，在蛋黄即将凝固之际浇一点冷开水，会使蛋又黄又嫩34、煎鸡蛋时，在平底锅放足油，油微热时蛋下锅，鸡蛋慢慢变熟，外观美，不粘锅35、煎鸡蛋时，在热油中撒点面粉，蛋会煎得黄亮好看，油也不易溅出锅外36、用羊油炒鸡蛋，味香无异味 38、炒鸡蛋时加入几滴醋，炒出的蛋松软味香 39、炒茄子时，在锅里放点醋，炒出的茄子颜色不会变黑 40、炒土豆时加醋，可避免烧焦，又可分解土豆中的毒素，并使色、味相宜41、炒豆芽时，先加点黄油，然后再放盐，能去掉豆腥味 42、炒波菜时不宜加盖 43、炒肉片：肉切成薄片加酱油、黄油、淀粉，打入一个鸡蛋，拌匀，炒散；等肉片变色后，再加佐料稍炒几下，肉片味美、鲜嫩45、炒肉菜时放盐过早熟得慢，宜在将熟时加盐，在出锅前再加上几滴醋，鲜嫩可口48、做肉饼和肉丸子时，一公斤肉馅放2小匙盐 49、做丸子按50克肉10克淀粉的比例调制，成菜软嫩 50、做滑炒肉片或辣子肉丁，按50克肉５克淀粉的比例上浆，成菜鲜嫩味美51、做馒头时，如果在发面里揉进一小块猪油，蒸出来的馒头不仅洁白、松软，而且味香52、蒸馒头时掺入少许桔皮丝，可使馒头增加清香 53、蒸馒头碱放多了起黄，如在原蒸锅水里加醋２～３汤匙，再蒸10～15分钟可变白54、将少量明矾和食盐放入清水中，把切开的生红薯浸入十几分钟，洗净后蒸煮，可防止或减轻腹胀56、放有辣椒的菜太辣时或炒辣椒时加点醋，辣味大减57、烹调时，放酱油若错倒了食醋，可撒放少许小苏打，醋味即可消除58、菜太酸，将一只松花蛋捣烂放入，菜太辣，放一只鸡蛋同炒 ，菜太苦，滴入少许白醋62、汤太咸又不宜兑水时，可放几块豆腐或土豆或几片蕃茄到汤中；也可将一把米或面粉用布包起来放入汤中63、汤太腻，将少量紫菜在火上烤一下，然后撒入汤中64、花生米用油炸熟，盛入盘中，趁热撒上少许白酒，稍凉后再撒上少许食盐，放置几天几夜都稣脆如初65、菜籽油有一股异味，可把油烧热后投入适量生姜、蒜、葱、丁香、陈皮同炸片刻，油即可变香66、用菜油炸一次花生米就没有怪味了，炒出的菜肴香味可口，并可做凉拌菜67、炸完食物后的油留下一些残渣并变得混浊，可将白萝卜切成厚圆片，用筷子把萝卜戳几个洞，放入剩油中炸，残渣会附着在萝卜片上，取出清除残渣，再反复放入锅中炸，混浊的油可变清澈69、当锅内温度达到最高时加入料酒，易使酒蒸发而去除食物中的腥味70、熬猪油：在电饭褒内放一点水或植物油，然后放入猪板油或肥肉，接通电源后，能自动将油炼好，不溅油，不糊油渣，油质清纯71、泡菜坛中放十几粒花椒或少许麦芽糖，可防止产生白花]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端使用技巧，切换到其他路径和目录]]></title>
    <url>%2Fposts%2F14a2657.html</url>
    <content type="text"><![CDATA[如果你想将当前 command line 会话切换到其他目录，需要用到三个命令：pwd，ls和cd pwd的含义是“print working directory”，会显示当前目录的绝对路径。 ls的含义是“list directory contents”，它会列出当前目录的内容。这个命令还有其他参数可选。 cd的含义是“change directory”，它会改变当前目录到你指定的目录。如果你不指定，则会返回你的 home folder。 命令 含义 pwd 当前工作目录 cd（不加参数） 进root cd（folder） 进入文件夹 cd .. 上级目录 cd ~ 返回root cd - 返回上一个访问的目录 rm 文件名 删除 cat 文件名 在终端下查看文件 ls 列出目录下所有文件 cp 文件名 目标目录 将文件拷贝到目标目录下 ~代表root 如：~/Document/ZM/ mkdiv 新建文件夹]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio混淆模板及常用第三方混淆]]></title>
    <url>%2Fposts%2F9a4f9efd.html</url>
    <content type="text"><![CDATA[首先要在build.gradle中开启混淆，也就是 minifyEnabled true ，我用的build.gradle具体如下所示： def releaseTime() &#123; return new Date().format("yyyy.MM.dd", TimeZone.getTimeZone("UTC"))&#125;android &#123; .... buildTypes &#123; release &#123; // 混淆 minifyEnabled true // Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为appname-1.0-beta1-xxxx-xx-xx.apk def fileName = "app-$&#123;defaultConfig.versionName&#125;-beta1-$&#123;releaseTime()&#125;.apk" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; ....&#125; 上面注释中写到proguard-android.txt文件，这是系统默认的混淆文件，具体在../sdk/tools/proguard/目录下，其中包含了android最基本的混淆，一般不需要改动，我们需要配置的是项目中app下的proguard-rules.pro文件，在此提供一份混淆模板。 ############################################### 对于一些基本指令的添加############################################### 代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5 # 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames # 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses # 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose # 指定不去忽略非公共库的类成员-dontskipnonpubliclibraryclassmembers # 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify # 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses # 避免混淆泛型-keepattributes Signature # 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable # 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/* ############################################### Android开发中一些需要保留的公共部分############################################## # 保留我们使用的四大组件，自定义的Application等等这些类不被混淆# 因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService # 保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125; # 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.** # 保留R下面的资源-keep class **.R$* &#123;*;&#125; # 保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; # 保留在Activity中的方法参数是view的方法，# 这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125; # 保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; # 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125; # 保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125; # 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125; # 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event); void *(**On*Listener);&#125; # webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125; # 移除Log类打印各个等级日志的代码，打正式包的时候可以做为禁log使用，这里可以作为禁止log打印的功能使用# 记得proguard-android.txt中一定不要加-dontoptimize才起作用# 另外的一种实现方案是通过BuildConfig.DEBUG的变量来控制#-assumenosideeffects class android.util.Log &#123;# public static int v(...);# public static int i(...);# public static int w(...);# public static int d(...);# public static int e(...);#&#125; ############################################### 项目中特殊处理部分############################################## #-----------处理反射类--------------- #-----------处理js交互--------------- #-----------处理实体类---------------# 在开发的时候我们可以将所有的实体类放在一个包内，这样我们写一次混淆就行了。#-keep public class com.ljd.example.entity.** &#123;# public void set*(***);# public *** get*();# public *** is*();#&#125; #-----------处理第三方依赖库--------- 下面介绍常用第三方混淆配置（已按字母排序，不定期更新）： # AndroidEventBus-keep class org.simple.** &#123; *; &#125;-keep interface org.simple.** &#123; *; &#125;-keepclassmembers class * &#123; @org.simple.eventbus.Subscriber &lt;methods&gt;;&#125;# 百度地图（jar包换成自己的版本，记得签名要匹配）-libraryjars libs/baidumapapi_v2_1_3.jar-keep class com.baidu.** &#123;*;&#125;-keep class vi.com.** &#123;*;&#125;-keep class com.sinovoice.** &#123;*;&#125;-keep class pvi.com.** &#123;*;&#125;-dontwarn com.baidu.**-dontwarn vi.com.**-dontwarn pvi.com.**# Bugly-dontwarn com.tencent.bugly.**-keep class com.tencent.bugly.** &#123;*;&#125;# ButterKnife-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125; -keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;# EventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Facebook-keep class com.facebook.** &#123;*;&#125;-keep interface com.facebook.** &#123;*;&#125;-keep enum com.facebook.** &#123;*;&#125;# FastJson-dontwarn com.alibaba.fastjson.**-keep class com.alibaba.fastjson.** &#123; *; &#125;-keepattributes Signature-keepattributes *Annotation*# Fresco-keep class com.facebook.fresco.** &#123;*;&#125;-keep interface com.facebook.fresco.** &#123;*;&#125;-keep enum com.facebook.fresco.** &#123;*;&#125;# 高德相关依赖# 集合包:3D地图3.3.2 导航1.8.0 定位2.5.0-dontwarn com.amap.api.**-dontwarn com.autonavi.**-keep class com.amap.api.**&#123;*;&#125;-keep class com.autonavi.**&#123;*;&#125;# 地图服务-dontwarn com.amap.api.services.**-keep class com.map.api.services.** &#123;*;&#125;# 3D地图-dontwarn com.amap.api.mapcore.**-dontwarn com.amap.api.maps.**-dontwarn com.autonavi.amap.mapcore.**-keep class com.amap.api.mapcore.**&#123;*;&#125;-keep class com.amap.api.maps.**&#123;*;&#125;-keep class com.autonavi.amap.mapcore.**&#123;*;&#125;# 定位-dontwarn com.amap.api.location.**-dontwarn com.aps.**-keep class com.amap.api.location.**&#123;*;&#125;-keep class com.aps.**&#123;*;&#125;# 导航-dontwarn com.amap.api.navi.**-dontwarn com.autonavi.**-keep class com.amap.api.navi.** &#123;*;&#125;-keep class com.autonavi.** &#123;*;&#125;# Glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;# Gson-keepattributes Signature-keepattributes *Annotation*-keep class sun.misc.Unsafe &#123; *; &#125;-keep class com.google.gson.stream.** &#123; *; &#125;# 使用Gson时需要配置Gson的解析对象及变量都不混淆。不然Gson会找不到变量。# 将下面替换成自己的实体类-keep class com.example.bean.** &#123; *; &#125;# Jackson-dontwarn org.codehaus.jackson.**-dontwarn com.fasterxml.jackson.databind.**-keep class org.codehaus.jackson.** &#123; *;&#125;-keep class com.fasterxml.jackson.** &#123; *; &#125;# 极光推送-dontoptimize-dontpreverify-dontwarn cn.jpush.**-keep class cn.jpush.** &#123; *; &#125;# OkHttp-keep class com.squareup.okhttp.** &#123; *; &#125;-keep interface com.squareup.okhttp.** &#123; *; &#125;-dontwarn com.squareup.okhttp.**# OkHttp3-dontwarn com.squareup.okhttp3.**-keep class com.squareup.okhttp3.** &#123; *;&#125;-dontwarn okio.**# Okio-dontwarn com.squareup.** -dontwarn okio.** -keep public class org.codehaus.* &#123; *; &#125; -keep public class java.nio.* &#123; *; &#125;# OrmLite-keepattributes *DatabaseField* -keepattributes *DatabaseTable* -keepattributes *SerializedName* -keep class com.j256.**-keepclassmembers class com.j256.** &#123; *; &#125;-keep enum com.j256.**-keepclassmembers enum com.j256.** &#123; *; &#125;-keep interface com.j256.**-keepclassmembers interface com.j256.** &#123; *; &#125;# Realm-keep class io.realm.annotations.RealmModule-keep @io.realm.annotations.RealmModule class *-keep class io.realm.internal.Keep-keep @io.realm.internal.Keep class * &#123; *; &#125;-dontwarn javax.**-dontwarn io.realm.**# Retrofit-dontwarn retrofit2.**-keep class retrofit2.** &#123; *; &#125;-keepattributes Signature-keepattributes Exceptions# Retrolambda-dontwarn java.lang.invoke.*# RxJava RxAndroid-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;# Universal-Image-Loader-v1.9.5-libraryjars libs/universal-image-loader-1.9.5-SNAPSHOT-with-sources.jar-dontwarn com.nostra13.universalimageloader.**-keep class com.nostra13.universalimageloader.** &#123; *; &#125;# 微信支付-dontwarn com.tencent.mm.**-dontwarn com.tencent.wxop.stat.**-keep class com.tencent.mm.** &#123;*;&#125;-keep class com.tencent.wxop.stat.**&#123;*;&#125;# 信鸽-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep class com.tencent.android.tpush.** &#123;* ;&#125;-keep class com.tencent.mid.** &#123;* ;&#125;-keepattributes *Annotation*# 新浪微博-keep class com.sina.weibo.sdk.* &#123; *; &#125; -keep class android.support.v4.* &#123; *; &#125; -keep class com.tencent.* &#123; *; &#125; -keep class com.baidu.* &#123; *; &#125; -keep class lombok.ast.ecj.* &#123; *; &#125; -dontwarn android.support.v4.** -dontwarn com.tencent.**s -dontwarn com.baidu.** # 讯飞语音-dontwarn com.iflytek.**-keep class com.iflytek.** &#123;*;&#125;# xUtils3.0-keepattributes Signature,Annotation-keep public class org.xutils.** &#123;public protected *;&#125;-keep public interface org.xutils.** &#123;public protected *;&#125;-keepclassmembers class * extends org.xutils.** &#123;public protected *;&#125;-keepclassmembers @org.xutils.db.annotation.* class * &#123;;&#125;-keepclassmembers @org.xutils.http.annotation. class * &#123;*;&#125;-keepclassmembers class * &#123;@org.xutils.view.annotation.Event ;&#125;# 银联-dontwarn com.unionpay.**-keep class com.unionpay.** &#123; *; &#125;# 友盟统计分析-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keepclassmembers enum com.umeng.analytics.** &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 友盟自动更新-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keep public class cn.irains.parking.cloud.pub.R$*&#123; public static final int *; &#125;-keep public class * extends com.umeng.**-keep class com.umeng.** &#123; *; &#125;# 支付宝钱包-dontwarn com.alipay.**-dontwarn HttpUtils.HttpFetcher-dontwarn com.ta.utdid2.**-dontwarn com.ut.device.**-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125;-keep class com.alipay.mobilesecuritysdk.*-keep class com.ut.*]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的会写单例吗]]></title>
    <url>%2Fposts%2F6bfd7458.html</url>
    <content type="text"><![CDATA[提到单例模式，相信都不会陌生，今天对其进行总结。 以下是单例模式的特点： 单例类只能有一个实例。 单例类必须自己自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 种类的话不好说有几类，因为要考虑到是否在多线程下运行，下面来介绍主要的几类： 懒汉类//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 懒汉么，所以在多线程下会失效，所以下面介绍三种懒汉的升级版来适应多线程 在getinstance前加上synchronized（同步），但这导致的是每次getInstance都会去同步，消耗资源。 public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; // 静态工厂方法 public static synchronized Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 双重检查锁，它是在以上做的修改，判断两次空，所以只有在第一次调用的时候会同步，避免了每次同步资源的消耗，注意 volatile 关键字。 public class Singleton &#123; private Singleton() &#123; &#125; private volatile static Singleton singleton = null; // 声明成 volatile //静态工厂方法 public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 内部静态类，这种我觉得是最好的，既实现了线程安全，也避免了同步带来的性能影响。 public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 饿汉类饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。 //饿汉式单例类.在类初始化时，已经自行实例化public class Singleton &#123; private Singleton() &#123; &#125; private static final Singleton single = new Singleton(); //静态工厂方法 public static Singleton getInstance() &#123; return single; &#125;&#125; 这种也是我比较喜欢的，因为简单易懂，但当实现了Serializable接口后，反序列化时单例会被破坏，实现Serializable接口需要重写readResolve，才能保证其反序列化依旧是单例： private Object readResolve() throws ObjectStreamException &#123; return single; &#125; 枚举类public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。 以上就是常用的单例模式，一般的情况下，我会使用饿汉式，只有在要明确实现lazy loading效果时才会使用内部静态类，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android发送短信的两种方式]]></title>
    <url>%2Fposts%2F9f23975a.html</url>
    <content type="text"><![CDATA[Demo地址：SendSMSDemo SMS涉及的主要类SmsManager实现SMS主要用到SmsManager类，该类继承自java.lang.Object类，下面我们介绍一下该类的主要成员。 公有方法： ArrayList divideMessage(String text)当短信超过SMS消息的最大长度时，将短信分割为几块。参数：text——初始的消息，不能为空返回值：有序的ArrayList，可以重新组合为初始的消息 static SmsManager getDefault()获取SmsManager的默认实例。返回值：SmsManager的默认实例 void SendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data,PendingIntent sentIntent, PendingIntent deliveryIntent)发送一个基于SMS的数据到指定的应用程序端口。参数：1)、destinationAddress——消息的目标地址2)、scAddress——服务中心的地址or为空使用当前默认的SMSC 3)destinationPort——消息的目标端口号4)、data——消息的主体，即消息要发送的数据5)、sentIntent——如果不为空，当消息成功发送或失败这个PendingIntent就广播。结果代码是Activity.RESULT_OK表示成功，或RESULT_ERROR_GENERIC_FAILURE、RESULT_ERROR_RADIO_OFF、RESULT_ERROR_NULL_PDU之一表示错误。对应RESULT_ERROR_GENERIC_FAILURE，sentIntent可能包括额外的“错误代码”包含一个无线电广播技术特定的值，通常只在修复故障时有用。每一个基于SMS的应用程序控制检测sentIntent。如果sentIntent是空，调用者将检测所有未知的应用程序，这将导致在检测的时候发送较小数量的SMS。6)、deliveryIntent——如果不为空，当消息成功传送到接收者这个PendingIntent就广播。异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。 void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList parts,ArrayList sentIntents, ArrayList deliverIntents)发送一个基于SMS的多部分文本，调用者应用已经通过调用divideMessage(String text)将消息分割成正确的大小。参数：1)、destinationAddress——消息的目标地址2)、scAddress——服务中心的地址or为空使用当前默认的SMSC3)、parts——有序的ArrayList，可以重新组合为初始的消息4)、sentIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent5)、deliverIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。 void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent,PendingIntent deliveryIntent)发送一个基于SMS的文本。参数的意义和异常前面的已存在的一样，不再累述。 常量： public static final int RESULT_ERROR_GENERIC_FAILURE 表示普通错误，值为1(0x00000001) public static final int RESULT_ERROR_NO_SERVICE表示服务当前不可用，值为4 (0x00000004) public static final int RESULT_ERROR_NULL_PDU表示没有提供pdu，值为3 (0x00000003) public static final int RESULT_ERROR_RADIO_OFF表示无线广播被明确地关闭，值为2 (0x00000002) public static final int STATUS_ON_ICC_FREE表示自由空间，值为0 (0x00000000) public static final int STATUS_ON_ICC_READ表示接收且已读，值为1 (0x00000001) public static final int STATUS_ON_ICC_SENT表示存储且已发送，值为5 (0x00000005) public static final int STATUS_ON_ICC_UNREAD表示接收但未读，值为3 (0x00000003) public static final int STATUS_ON_ICC_UNSENT表示存储但为发送，值为7 (0x00000007) 第一：调用系统短信接口直接发送短信；主要代码如下： /** * 直接调用短信接口发短信 * * @param phoneNumber * @param message */ public void sendSMS(String phoneNumber, String message) &#123; // 获取短信管理器 android.telephony.SmsManager smsManager = android.telephony.SmsManager .getDefault(); // 拆分短信内容（手机短信长度限制） List&lt;String&gt; divideContents = smsManager.divideMessage(message); for (String text : divideContents) &#123; smsManager.sendTextMessage(phoneNumber, null, text, sentPI,deliverPI); &#125; &#125; 第二：调起系统发短信功能；主要代码如下： /** * 调起系统发短信功能 * * @param phoneNumber * @param message */ public void doSendSMSTo(String phoneNumber, String message) &#123; if (PhoneNumberUtils.isGlobalPhoneNumber(phoneNumber)) &#123; Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:" + phoneNumber)); intent.putExtra("sms_body", message); startActivity(intent); &#125; &#125; 下面来主要讲解第一种方法，第一种方法可以监控发送状态和对方接收状态使用的比较多。 处理返回的状态代码如下: //处理返回的发送状态 String SENT_SMS_ACTION = "SENT_SMS_ACTION"; Intent sentIntent = new Intent(SENT_SMS_ACTION); sentPI= PendingIntent.getBroadcast(this, 0, sentIntent, 0); // register the Broadcast Receivers this.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context _context, Intent _intent) &#123; switch (getResultCode()) &#123; case Activity.RESULT_OK: Toast.makeText(MainActivity.this, "短信发送成功", Toast.LENGTH_SHORT) .show(); break; case SmsManager.RESULT_ERROR_GENERIC_FAILURE: break; case SmsManager.RESULT_ERROR_RADIO_OFF: break; case SmsManager.RESULT_ERROR_NULL_PDU: break; &#125; &#125; &#125;, new IntentFilter(SENT_SMS_ACTION)); //处理返回的接收状态 String DELIVERED_SMS_ACTION = "DELIVERED_SMS_ACTION"; // create the deilverIntent parameter Intent deliverIntent = new Intent(DELIVERED_SMS_ACTION); deliverPI = PendingIntent.getBroadcast(this, 0,deliverIntent, 0); this.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context _context, Intent _intent) &#123; Toast.makeText(MainActivity.this,"收信人已经成功接收", Toast.LENGTH_SHORT) .show(); &#125; &#125;, new IntentFilter(DELIVERED_SMS_ACTION)); 别忘了权限的问题： &lt;uses-permission android:name="android.permission.SEND_SMS" /&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>SMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0～9.0适配]]></title>
    <url>%2Fposts%2Fdd367189.html</url>
    <content type="text"><![CDATA[1.前言 大家还记得Android 6.0权限适配的泪水吗？而现在谷歌已经出了Android P的稳定版，而且谷歌粑粑，为了大家能给辛苦熬夜加班，特地的和个大市场合作，要强制推出9.0的适配，而近期在下不才，为了报着多踩坑的心态，做了一下7.0～9.0的适配，脸颊也是老泪两行 2.安卓6.0的适配2.1 怎么适配 ● 在6.0所有权限都需要申请？ 曰：当然不是。只有属于危险权限的才需要申请。危险权限看下表1-2 ● 那危险权限也很多啊，也要一个个申请？ 曰：当然不是。你看看下面的表，都分好组了（9组），对于同一组内的权限，只要有一个被同意，其他的都会被同意。 ● 谁最帅 曰：当然是子信。 2.2 列举权限的分组 表1-2危险权限分组 分组 名字 分割线 PHONE android.permission.READ_PHONE_STATE android.permission.CALL_PHONE android.permission.READ_CALL_LOG android.permission.ADD_VOICEMAIL android.permission.WRITE_CALL_LOG android.permission.USE_SIP android.permission.PROCESS_OUTGOING_CALLS CALENDAR android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR CAMERA android.permission.CAMERA CONTACTS android.permission.READ_CONTACTS android.permission.WRITE_CONTACTS android.permission.GET_ACCOUNTS LOCATION android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_COARSE_LOCATION MICROPHONE android.permission.RECORD_AUDIO SENSORS android.permission.BODY_SENSORS SMS android.permission.SEND_SMS android.permission.RECEIVE_SMS android.permission.READ_SMS android.permission.RECEIVE_WAP_PUSH android.permission.RECEIVE_MMS STORAGE android.permission.READ_EXTERNAL_STORAGE android.permission.WRITE_EXTERNAL_STORAGE &lt;!-- 危险权限 start --&gt;&lt;!--PHONE--&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt;&lt;uses-permission android:name="android.permission.READ_CALL_LOG"/&gt;&lt;uses-permission android:name="android.permission.ADD_VOICEMAIL"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CALL_LOG"/&gt;&lt;uses-permission android:name="android.permission.USE_SIP"/&gt;&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;&lt;!--CALENDAR--&gt;&lt;uses-permission android:name="android.permission.READ_CALENDAR"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CALENDAR"/&gt;&lt;!--CAMERA--&gt;&lt;uses-permission android:name="android.permission.CAMERA"/&gt;&lt;!--CONTACTS--&gt;&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CONTACTS"/&gt;&lt;uses-permission android:name="android.permission.GET_ACCOUNTS"/&gt;&lt;!--LOCATION--&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;&lt;!--MICROPHONE--&gt;&lt;uses-permission android:name="android.permission.RECORD_AUDIO"/&gt;&lt;!--SENSORS--&gt;&lt;uses-permission android:name="android.permission.BODY_SENSORS"/&gt;&lt;!--SMS--&gt;&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_SMS"/&gt;&lt;uses-permission android:name="android.permission.READ_SMS"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_WAP_PUSH"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_MMS"/&gt;&lt;!--STORAGE--&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;!-- 危险权限 Permissions end --&gt; 以上是列出9组需要动态申请的权限，建议自己代码统一封装成一个工具类，这里就不细说了， Android6.0权限工具 3.Android 7.0的适配3.1 应用间共享文件 在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 Android 7.0 行为变更 通过FileProvider在应用间共享文件这篇文章 3.2 APK signature scheme v2 Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。 1）只勾选v1签名就是传统方案签署，但是在7.0上不会使用V2安全的验证方式。 2）只勾选V2签名7.0以下会显示未安装，7.0上则会使用了V2安全的验证方式。 3）同时勾选V1和V2则所有版本都没问题。 3.3 org.apache不支持问题 // build.gradle里面加上这句话defaultConfig &#123; useLibrary 'org.apache.http.legacy' &#125; 3.3 SharedPreferences闪退 SharedPreferences read = getSharedPreferences(RELEASE_POOL_DATA, MODE_WORLD_READABLE);//MODE_WORLD_READABLE ：7.0以后不能使用这个获取，会闪退，修改成MODE_PRIVATE 4.Android 8.0的适配4.1 安卓8.0中PHONE权限组新增两个权限 ANSWER_PHONE_CALLS：允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 acceptRingingCall() 函数。READ_PHONE_NUMBERS ：权限允许您的应用读取设备中存储的电话号码。 4.2 通知适配 安卓8.0中，为了更好的管制通知的提醒，不想一些不重要的通知打扰用户，新增了通知渠道，用户可以根据渠道来屏蔽一些不想要的通知 兼容的代码 /** * 安卓8。0通知的兼容类哦， * NotifyCompatYc yc : 是雨辰的简写，谢谢哦，嘿嘿 ----高贵的子信 */public class NotifyCompatYc &#123; public static final String QFMD_CHANNEL_ID = "com.oms.mingdeng"; public static final String QFMD_CHANNEL_NAME = "祈福明燈"; public static final String LJMS_DEFAULT_CHANNEL_NAME = "靈機妙算"; public static final String LJMS_CHANNEL_ID = "com.oms.mmcnotity"; public static final String XYS_CHANNEL_ID = "com.oms.xuyuanshu"; public static final String XYS_CHANNEL_NAME = "許願樹"; public static void setONotifyChannel(NotificationManager manager, NotificationCompat.Builder builder, String channeId, String channelName) &#123; if (TextUtils.isEmpty(channeId)||TextUtils.isEmpty(channelName))&#123; L.e("NotifyCompatYc: ".concat("安卓8.0的通知兼容库中 channeId 与 channelName 不能为empty")); &#125; if (Build.VERSION.SDK_INT &gt;= 26) &#123; //第三个参数设置通知的优先级别 NotificationChannel channel = new NotificationChannel(channeId, channelName, NotificationManager.IMPORTANCE_DEFAULT); channel.canBypassDnd();//是否可以绕过请勿打扰模式 channel.canShowBadge();//是否可以显示icon角标 channel.enableLights(true);//是否显示通知闪灯 channel.enableVibration(true);//收到小时时震动提示 channel.setBypassDnd(true);//设置绕过免打扰 channel.setLockscreenVisibility(NotificationCompat.VISIBILITY_SECRET); channel.setLightColor(Color.RED);//设置闪光灯颜色 channel.getAudioAttributes();//获取设置铃声设置 channel.setVibrationPattern(new long[]&#123;100, 200, 100&#125;);//设置震动模式 channel.shouldShowLights();//是否会闪光 if (manager != null) &#123; manager.createNotificationChannel(channel); &#125; if (builder != null) &#123; builder.setChannelId(channeId);//这个id参数要与上面channel构建的第一个参数对应 &#125; &#125; &#125; public static void setONotifyChannel(NotificationManager manager, String channeId, String channelName) &#123; setONotifyChannel(manager,null,channeId,channelName); &#125; public static Notification getNotification(Context context, String channelId) &#123; NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(context, channelId); Notification notification = notificationBuilder.setOngoing(true) .setSmallIcon(R.drawable.ic_launcher) .setPriority(NotificationManager.IMPORTANCE_MIN) .setCategory(Notification.CATEGORY_SERVICE) .build(); return notification; &#125;&#125;复制代码public class NotifyManager &#123; // 单例开始 private volatile static NotifyManager INSTANCE; private NotifyManager(Context context) &#123; initNotifyManager(context); &#125; public static NotifyManager getInstance(Context context) &#123; if (INSTANCE == null) &#123; synchronized (NotifyManager.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new NotifyManager(context); &#125; &#125; &#125; return INSTANCE; &#125; // 单例结束 private NotificationManager manager; // NotificationManagerCompat private NotificationCompat.Builder builder; //初始化通知栏配置 private void initNotifyManager(Context context) &#123; context = context.getApplicationContext(); manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); // 如果存在则清除上一个消息// manager.cancel(news_flag); builder = new NotificationCompat.Builder(context,NotifyCompatYc.QFMD_CHANNEL_ID); NotifyCompatYc.setONotifyChannel(manager,builder,NotifyCompatYc.QFMD_CHANNEL_ID,NotifyCompatYc.QFMD_CHANNEL_NAME); // 设置标题 builder.setContentTitle(context.getResources().getString(R.string.qfmd_notify_title1)); // 状态栏的动画提醒语句 builder.setTicker(context.getResources().getString(R.string.qfmd_notify_ticker)); // 什么时候提醒的 builder.setWhen(System.currentTimeMillis()); // 设置通知栏的优先级 builder.setPriority(Notification.PRIORITY_DEFAULT); // 设置点击可消失 builder.setAutoCancel(true); // 设置是否震动等 builder.setDefaults(Notification.DEFAULT_VIBRATE); // 设置icon builder.setSmallIcon(R.drawable.lingji_icon); // 设置点击意图 Intent intent = new Intent(context, GongdenggeActivity.class); Bundle bundle = new Bundle(); bundle.putBoolean(Contants.INTENT_GOTO_MYLMAP, true); intent.putExtras(bundle); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pendingIntent = PendingIntent.getActivity(context, 230, intent, PendingIntent.FLAG_UPDATE_CURRENT); builder.setContentIntent(pendingIntent); &#125; /** * 显示祈福明灯过期通知 */ public void showQiFuLampOutOfDateNotify(Context context) &#123; // 设置内容 builder.setContentText(context.getResources().getString(R.string.qfmd_notify_content1)); manager.notify(13251, builder.build()); &#125; public void showQiFuLampBlessNotify(Context context) &#123; builder.setContentText(context.getResources().getString(R.string.qfmd_notify_content2)); manager.notify(13255, builder.build()); &#125;&#125; 4.3 安装APK 首先在AndroidManifest文件中添加安装未知来源应用的权限: &lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/&gt; 这样系统会自动询问用户完成授权。当然你也可以先使用 canRequestPackageInstalls()查询是否有此权限，如果没有的话使用Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES这个action将用户引导至安装未知应用权限界面去授权。 private static final int REQUEST_CODE_UNKNOWN_APP = 100; private void installAPK()&#123; if (Build.VERSION.SDK_INT &gt;= 26) &#123; boolean hasInstallPermission = getPackageManager().canRequestPackageInstalls(); if (hasInstallPermission) &#123; //安装应用 &#125; else &#123; //跳转至“安装未知应用”权限界面，引导用户开启权限 Uri selfPackageUri = Uri.parse("package:" + this.getPackageName()); Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri); startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP); &#125; &#125;else &#123; //安装应用 &#125; &#125; //接收“安装未知应用”权限的开启结果 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123; installAPK(); &#125; &#125; 4.4 SecurityException的闪退 问题原因：项目使用了ActiveAndroid，在 8.0 或 8.1 系统上使用 26 或以上的版本的 SDK 时，调用 ContentResolver 的 notifyChange 方法通知数据更新，或者调用 ContentResolver 的 registerContentObserver 方法监听数据变化时，会出现上述异常。 解决方案： （1）在清单文件配置 &lt;provider android:name=&quot;com.activeandroid.content.ContentProvider&quot; android:authorities=&quot;com.ylmf.androidclient&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;&gt;&lt;/provider&gt;复制代码 （2）去掉这个监听刷新的方法，改为广播刷新 4.5 静态广播无法正常接收 问题原因： Android 8.0 引入了新的广播接收器限制，因此您应该移除所有为隐式广播 Intent 注册的广播接收器 解决方案： 使用动态广播代替静态广播 4.6 Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation 问题原因： Android 8.0 非全屏透明页面不允许设置方向（后面8.1系统谷歌就去掉了这个限制，可能很多人真的不习惯吧）解决方案： （1）android:windowIsTranslucent设置为false (2)如果还是想用的话，就去掉清单文件中Activity中的android:screenOrientation=&quot;portrait&quot;， （3）就是使用透明的dialog或者PopupWindow来代替，也可以用DialogFragment，看自己的需求和喜好. Android 9.0的适配9.1 CLEARTEXT communication to life.115.com not permitted by network security policy 问题原因： Android P 限制了明文流量的网络请求，非加密的流量请求都会被系统禁止掉 解决方案： 在资源文件新建xml目录，新建文件 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 清单文件配置： &lt;application android:networkSecurityConfig="@xml/network_security_config"&gt; &lt;!--9.0加的，哦哦--&gt; &lt;uses-library android:name="org.apache.http.legacy" android:required="false" /&gt; &lt;/application&gt; 但还是建议都使用https进行传输 9.2 其他Api的修改 java.lang.IllegalArgumentException: Invalid Region.Op - only INTERSECT and DIFFERENCE are allowed if (Build.VERSION.SDK_INT &gt;= 26) &#123; canvas.clipPath(mPath); &#125; else &#123; canvas.clipPath(mPath, Region.Op.REPLACE); &#125; 总结 经过几天的踩坑，终于把targetSdkVersion升级到28，对于以上的经验，也许还存在某些疏漏的，也希望大家可以指正，补充，告诉，希望对你有一定的帮助，鄙人也很开心。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>权限</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端-iTerm2使用]]></title>
    <url>%2Fposts%2Fe6bc65de.html</url>
    <content type="text"><![CDATA[iTerm2 https://www.zhihu.com/question/27447370 https://medium.com/ayuth/iterm2-zsh-oh-my-zsh-the-most-power-full-of-terminal-on-macos-bdb2823fb04c https://jeremysu0131.github.io/Tool-Mac-iTerm-2-Oh-My-Zsh-Powerlevel9k-設定/ 智能选中双击选中、三击选中整行、四击智能选中（智能规则可配置），选中即复制 巧用 ⌘ 键按住 ⌘ 键 可以拖拽选中的字符串； 点击 url：调用默认浏览器访问该网址； 点击文件：调用默认程序打开文件； 如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行； 点击文件夹：在 finder 中打开该文件夹； 同时按住⌥键，可以以矩形选中，类似于 vim 中的⌃ v操作。 快捷键标签新建标签：⌘ + t 关闭标签：⌘ + w 切换标签：⌘ + 数字 ⌘ + 左右方向键 切换全屏：⌘ + enter 查找：⌘ + f 分屏垂直分屏：⌘ + d 水平分屏：⌘ + ⇧ + d 切换屏幕：⌘ + ⌥ + 方向键⌘ + [ 或 ⌘ + ] 查看历史命令：⌘ + ; 查看剪贴板历史：⌘ + ⇧ + h 其他清除当前行：⌃ + u 到行首：⌃ + a 到行尾：⌃ + e 前进后退：⌃ + f/b (相当于左右方向键) 上一条命令：⌃ + p 搜索命令历史：⌃ + r 删除当前光标的字符：⌃ + d 删除光标之前的字符：⌃ + h 删除光标之前的单词：⌃ + w 删除到文本末尾：⌃ + k 交换光标处文本：⌃ + t 清屏 1：⌘ + r 清屏 2：⌃ + l 时间线：⌘ + ⇧ + e 自带有哪些很实用的功能/快捷键⌘ + 数字 在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 /⌘ + ⇧ + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ⌃ + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + ⇧ + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 常用的一些快捷键⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 ⌘←` / `⌘→` 到一行命令最左边/最右边 ，这个功能同 `C+a` / `C+e ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在 Iterm 中已经预定义好了，⌥f / ⌥b，看个人习惯了 好像就这几个 设置方法如下 当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但 iterm 中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的自负 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 标记跳转 类似编辑器的 mark 工具，iTerm2 也可以在命令行位置设置标记 设置标记：⌘ + ⇧ + m 跳转到上个标记：⌘ + ⇧ + j 多个标记切换：⌘ + ⇧ + 方向键 选中即复制iterm2 有 2 种好用的选中即复制模式。 一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自 动复制了。另一种是无鼠标模式，⌘+f,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 tab，查找窗口将自动变化内容，并将其复制。如果输入的是 ⇧+tab，则自动将查找内容的左边选中并复制。 自动完成输入打头几个字母，然后输入 ⌘+; iterm2 将自动列出之前输入过的类似命令。 剪切历史输入 ⌘+⇧+h，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 Preferences &gt; General &gt; Save copy/paste history to disk 中设置。 及时回放 某个交互命令会覆写屏幕上的输入，之前的历史信息可能会被覆盖掉，无法查看，iterm2 这个及时回放功能，会记录历史输入，输出，有点类似视频录制。 进入回放：⌘ + opt + b 方向键控制时间 ：arrow 退出回放：esc oh-my-zsh https://www.zhihu.com/question/29977255 智能补全cd ~/ 切换目录，敲击两下tab，会列出当前目录下的所有目录，并且可以使用键盘上下左右键来选择要进入的目录。 命令选项补齐，比如输入 docker，然后按 tab，即可显示出 docker 都有哪些命令选项。 智能切换目录进入一个很深的目录，例如 /var/log/nginx/error/lastyear/may/first/monday, 用 zsh 可以这样输入 cd /v/l/n/e/l/m/f/m 然后按 tab 即可补全整个路径。或者你实现知道当前目录名称，可以直接输入目录，即可进去目录。 在 zsh 下可以记录最近进过的 10 个目录，只需要输入d，然后就可以看到对应的 0-9 的目录，输入cd -数字即可进入对应的目录。 或者直接输入 cd - 然后 tab，会列出最近使用过的 31 个目录。 配置需要的时候把 iterm2 呼出来,不需要的时候自动隐藏iTerm2 &gt; Preferences &gt; Keys，左侧 Hotkey 选项 勾选 Show/hide iTerm2 with a system-wide hotkey，设置快捷键 复用上个会话的目录iTerm2 &gt; Preferences &gt; Profiles &gt; Working Directory &gt; Reuse previous session’s directory 别名alias zsh-config=&apos;vim ~/.zshrc&apos; 终端下命令行下用 Sublime、vscode、atom 打开文件夹或目录vscode 命令行调用VS Code 提供了一个 code 命令，用来在 shell 环境下调用编辑器。使用快捷键 ⇧⌘P（或 F1） 唤起命令面板，输入以下命令即可完成安装。 code 命令后可接多个路径或文件： code pro6.js pro6.scss ../ 文件对比： code -d new-file.js old-file.js 打开文件并跳至指定行： code -g source/cn/static/global/tracker.js:15 更多 code 命令行使用方法，参见《Additional Command line arguments》。 手动添加 打开终端，随便一个目录输入 cd 检查是否有.zshrc文件 ls -al 1) 添加启动命令 sudo nano .zshrc 在文件末尾加上别名： alias atom=&apos;/Applications/Atom.app/Contents/MacOS/Atom&apos;alias subl=&apos;/Applications/SublimeText.app/Contents/SharedSupport/bin/subl&apos;alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos; `⌘ + X` 再输入 `y` 保存，重启 iterm2。 查找 APP 路径： vim配色终端输入vim ~/.vimrc，设置内容如下， syntax onset numberset ruler powerlevel9k主题 配置项Stylizing Your Prompt 其他人的配置Show Off Your Config 我的配置export DEFAULT_USER=&quot;Leo&quot;export TERM=&quot;xterm-256color&quot;ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;# 调整字体模式POWERLEVEL9K_MODE=&apos;nerdfont-complete&apos;# 左侧提示符显示内容:系统时间(time)、root权限指示(root_indicator)、username and host(context)、当前工作目录(dir)、目录写入权限(dir_writable)、git信息(vcs)POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(time root_indicator dir dir_writable vcs)# 右侧提示符显示内容:上一命令执行状态(status)、后台任务个数(background_jobs)、上一命令执行时间(command_execution_time)、可用RAM(ram)、系统的负载均值(load)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs command_execution_time ram load)# context也就是你的用户名以及终端名称，默认是 `%n@%m`。POWERLEVEL9K_CONTEXT_TEMPLATE=&quot;Leo&quot;# 低于这个值的命令执行时间不显示，0 也就是命令执行时间多长都显示POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=&quot;0&quot;# 时间格式化POWERLEVEL9K_TIME_FORMAT=&quot;%D&#123;%H:%M&#125;&quot;# 显示分支版本POWERLEVEL9K_SHOW_CHANGESET=true 如果图标显示不出来可以进入 iTerm 的设置 &gt; Profiles &gt; Text &gt; Change Font &gt; 选择 Hack Nerd Font 字体 Regular 大小 18pt，完成后重新启动 iTerm ，设置完成。 插件 打开配置文件：~/.zshrc autojump：快速切换目录 zsh-syntax-highlighting：zsh 可用命令高亮 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting zsh-autosuggestions：命令自动提示 git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions plugins=(brew git node npm osx autojump zsh-autosuggestions zsh-syntax-highlighting)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感恩节的简介和习俗]]></title>
    <url>%2Fposts%2F3b06da8c.html</url>
    <content type="text"><![CDATA[感恩节的简介每年11月的第四个星期四是感恩节。感恩节是美国人民独创的—个古老节日，也是美国人合家欢聚的节日，因此美国人提起感恩节总是倍感亲切。 感恩节的由来，要一直追溯到美国历史的发端。1620年9月，著名的“五月花”号船，满载不堪忍受英国国内迫害的清教徒102人离港启航。在漫无边际的大洋中，漂泊了整整65天，经历了狂风巨浪的种种折磨，方才在马萨诸塞州科德角顶的普洛文斯敦港靠岸。接着，“五月花”号按计划继续南行，打算在弗吉尼亚的詹姆斯敦靠岸，但因航行误差，他们来到了普利茅斯附近。在那里，由于对地形和环境茫无所知，他们十分谨慎地让大部分人仍然留在船上，只派一批精明强干的人出外探测地形。1个月后，他们终于发现了普利茅斯港口，并且意外地在这里找到了一个优良的渔港。这里有几块已经收获过的玉米田，有清亮的淡水小溪，还有十分宜于筑垒设防的山丘，但空无一人。原来这里是一个印第安人的村落、不久前天花流行。夺去了全体村民的生命。几天后，“五月花”号就渡过科德角湾，在普利茅斯港抛锚上岸。这里成为英国移民在美洲的第二块永久居留地。后来他们把登岸的一块大礁石命名为普利茅斯石。​到了1620年和1621年之交的冬天，他们遇到了难以想象的困难。在寒冷无比的冬季，他们自己搭盖的简陋房屋难以抵御风雪，粮食也不足，再加上繁重的劳动和传染病的侵袭，待到冬天结束，活下来的移民只有50来人了。​开春时节，普利茅斯村的移民结识了一位名叫斯·昆图的印第安人。斯·昆图对移民们十分友好。不久，他把自己部落的酋长马萨索德介绍给移民。心地善良的印第安人热情地欢迎远道而来的客人，马萨索德不仅给移民带来礼物，还特地派本部落的人教会移民们怎样狩猎、捕鱼和种植玉米、南瓜、蚕豆。在印第安人的帮助下，移民们终于获得了丰收。​移民们在欢庆丰收的日子里，按照传统习俗，规定了感谢上帝的日子，并决定为感谢印第安朋友的真诚帮助，邀请他们一同来欢庆节日。印第安人欣然接受了邀请，并且提前送来了5只鹿，表示他们的友好情谊。这就是感恩节的由来。 感恩节的习俗集体庆祝初时感恩节没有固定日期，由各州临时决定，直到美国独立后，感恩节才成为全国性的节日。 每逢感恩节这一天，美国举国上下热闹非常，基督徒按照习俗前往教堂做感恩祈祷，城市乡镇到处都有化装游行、戏剧表演或体育比赛等。分别了一年的亲人们也会从天南海北归来，一家人团圆，品尝以“火鸡”为主的感恩节美食。 ​美国当地最著名的庆典则是从1924年开始的梅西百货感恩节游行（Macy’s Thanksgiving Day Parade）。 每逢感恩节这一天，美国举国上下热闹非凡，人们按照习俗前往教堂做感恩祈祷，城乡市镇到处举行化装游行、戏剧表演和体育比赛等，学校和商店也都按规定放假休息。孩子们还模仿当年印第安人的模样穿上离奇古怪的服装，画上脸谱或戴上面具到街上唱歌、吹喇叭。散居在他乡外地的家人也会回家过节，一家人团团围坐在一起，大嚼美味火鸡，并且对家人说：“谢谢！”。感恩节后，学校会让同学们画一张感恩节的画，大部分学生都画的是火鸡。 同时，好客的美国人也忘不掉这一天邀请好友、单身汉或远离家乡的人共度佳节。从18世纪起，美国就开始出现一种给贫穷人家送一篮子食物的风俗。当时有一群年轻妇女想在一年中选一天专门做善事，认为选定感恩节是最恰当不过的。所以感恩节一到，她们就装上满满一篮食物亲自送到穷人家。这件事远近传闻，不久就有许多人学着她们的样子做起来。不管遇到谁，他们都会说：“Thank you！” 节日购物感恩节购物已经成为了美国人的习俗。从感恩节到圣诞节这一个月，美国零售业奥巴马特赦火鸡“勇气”。​总销售额能占到全年的1/3强，是各个商家传统的打折促销旺季。疯狂的购物月从感恩节的次日（星期五）开始，这一天即被称为Black Friday（黑色星期五）。之所以叫这个名字，据说是因为周五这天一大早，所有人都要摸着黑冲到商场排队买便宜货，这种行为有个非常形象的说法，叫Early Bird（早起的鸟儿）[4]。在外国“感恩节”和中国的春节一样重要！ 每年一度的总统放生火鸡仪式始于1947年杜鲁门总统当政时期，但实际上这个传统仪式可以追溯到美国内战林肯总统当政的时期。1863年的一天，林肯的儿子泰德突然闯入内阁会议请求赦免一只名叫杰克的宠物火鸡，因为这只被送进白宫的火鸡，即将成为人们的感恩节大餐。 ​2006年11月22日，布什在白宫玫瑰花园举行感恩节放生仪式上，特赦了一只名布什特赦“飞鸟”火鸡叫“飞鸟”的火鸡。 美国总统奥巴马25号特赦感恩节火鸡．并将火鸡被命名为“勇气”。这也是他上任以来，首次特赦火鸡．奥巴马并对保护美国人民身家安全的英勇战士表示感恩。 每年11月的第4个星期四是美国感恩节。在女儿萨莎和玛丽亚的陪伴下，奥巴马特赦了本来要用做盘中餐的火鸡．奥巴马说，我原本打算吃掉这只火鸡。由于萨莎和玛丽亚的干预，我赦免了“勇气”。这只火鸡将被送到迪士尼乐园。为防止意外，当局还准备了一只备用火鸡，名叫“卡罗琳娜”。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webview常见问题汇总]]></title>
    <url>%2Fposts%2F8c79d027.html</url>
    <content type="text"><![CDATA[前言 通常我们在自己开发的 APP 中打开网页无非两种方法： 一是跳转到系统自带的浏览器，二是使用 WebView 控件加载页面。使用 WebView 控件的好处就是可以通过各种 api 接口来定制各种行为，常用的几个设置地方为 WebSettings、JavaScriptInterface、WebViewClient 和WebChromeClient。平时出现的问题都可以通过修改这些设置来解决。 问题总结1、使用了 WebView 还是跳转到了系统自带的浏览器？ 很简单的解决方法，为你的 webview 设置一个新的 WebViewClient。 webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125;&#125;); // 或者直接添加，效果是一样的webView.setWebViewClient(new WebViewClient()); 2、获取网页的标题和图标 通过 WebChromeClient 可以获取到这些信息。 webView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onReceivedTitle(WebView view, String title) &#123; super.onReceivedTitle(view, title); setTitle(title); &#125; @Override public void onReceivedIcon(WebView view, Bitmap icon) &#123; super.onReceivedIcon(view, icon); setIcon(icon); &#125;&#125;); 但是，这里有个问题，当通过 webView.goBack() 方式返回上一级Web页面的时候不会触发这个方法，因此会导致标题无法跟随历史记录返回上一级页面。所以需要在 onPageFinished() 中对界面标题重新设置。 webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); setTitle(String.valueOf(view.getTitle())); &#125;&#125;); 3、返回键实现网页的后退键 在 WebView 中可以通过 goBack() 方法后退到历史记录的上一项。 // 在 Actvity 中监听返回键按钮 @Override public void onBackPressed() &#123; if (webView.canGoBack()) webView.goBack(); else super.onBackPressed(); &#125; 4、设置 WebView 的 header 在 WebView 的 loadUrl() 方法中传入 Header 参数即可。 public void loadURLWithHTTPHeaders() &#123; final String url = "http://cpacm.net"; WebView webView = new WebView(getActivity()); Map&lt;String,String&gt; extraHeaders = new HashMap&lt;String, String&gt;(); extraHeaders.put("Referer", "http://www.google.com"); webView.loadUrl(url, extraHeaders);&#125; 5、设置 WebView 的 User-Agent 不要试图在 Header 里面去修改，而是在 WebSettings 修改 webView.getSettings().setUserAgentString("Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0"); 6、如何设置 WebView 的缓存 当需要本地缓存网页的时候就需要打开 WebViewSettings 的缓存开关,这样子当下次进到该页面无网络的情况下也能打开页面。 WebSettings settings = webView.getSettings();settings.setAppCacheEnabled(true); //启用应用缓存settings.setDomStorageEnabled(true); //启用或禁用DOM缓存。settings.setDatabaseEnabled(true); //启用或禁用DOM缓存。if (SystemUtil.isNetworkConnected()) &#123; //判断是否联网 settings.setCacheMode(WebSettings.LOAD_DEFAULT); //默认的缓存使用模式&#125; else &#123; settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY); //不从网络加载数据，只从缓存加载数据。&#125; 7、无法下载文件？ 在自己写的 WebView 下是无法直接下载文件，需要自己监听下载事件并对下载的动作进行处理。 /*** 当下载文件时打开系统自带的浏览器进行下载，当然也可以对捕获到的 url 进行处理在应用内下载。**/webView.setDownloadListener(new FileDownLoadListener());private class FileDownLoadListener implements DownloadListener &#123; @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123; Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); &#125;&#125; 8、无法打开文件选择器？ 通过重写 WebChromeClient 来实现点击 来打开系统文件选择器。 一个完整的Activity示例 public class MainActivity extends AppCompatActivity &#123; /** Android 5.0以下版本的文件选择回调 */ protected ValueCallback&lt;Uri&gt; mFileUploadCallbackFirst; /** Android 5.0及以上版本的文件选择回调 */ protected ValueCallback&lt;Uri[]&gt; mFileUploadCallbackSecond; protected static final int REQUEST_CODE_FILE_PICKER = 51426; protected String mUploadableFileTypes = "image/*"; private WebView mWebView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initWebView(); &#125; private void initWebView() &#123; mWebView = (WebView) findViewById(R.id.my_webview); mWebView.loadUrl("file:///android_asset/index.html"); mWebView.setWebChromeClient(new OpenFileChromeClient()); &#125; private class OpenFileChromeClient extends WebChromeClient &#123; // Android 2.2 (API level 8)到Android 2.3 (API level 10)版本选择文件时会触发该隐藏方法 @SuppressWarnings("unused") public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; openFileChooser(uploadMsg, null); &#125; // Android 3.0 (API level 11)到 Android 4.0 (API level 15))版本选择文件时会触发，该方法为隐藏方法 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; openFileChooser(uploadMsg, acceptType, null); &#125; // Android 4.1 (API level 16) -- Android 4.3 (API level 18)版本选择文件时会触发，该方法为隐藏方法 @SuppressWarnings("unused") public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; openFileInput(uploadMsg, null, false); &#125; // Android 5.0 (API level 21)以上版本会触发该方法，该方法为公开方法 @SuppressWarnings("all") public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) &#123; if (Build.VERSION.SDK_INT &gt;= 21) &#123; final boolean allowMultiple = fileChooserParams.getMode() == FileChooserParams.MODE_OPEN_MULTIPLE;//是否支持多选 openFileInput(null, filePathCallback, allowMultiple); return true; &#125; else &#123; return false; &#125; &#125; &#125; @SuppressLint("NewApi") protected void openFileInput(final ValueCallback&lt;Uri&gt; fileUploadCallbackFirst, final ValueCallback&lt;Uri[]&gt; fileUploadCallbackSecond, final boolean allowMultiple) &#123; //Android 5.0以下版本 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(null); &#125; mFileUploadCallbackFirst = fileUploadCallbackFirst; //Android 5.0及以上版本 if (mFileUploadCallbackSecond != null) &#123; mFileUploadCallbackSecond.onReceiveValue(null); &#125; mFileUploadCallbackSecond = fileUploadCallbackSecond; Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); if (allowMultiple) &#123; if (Build.VERSION.SDK_INT &gt;= 18) &#123; i.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true); &#125; &#125; i.setType(mUploadableFileTypes); startActivityForResult(Intent.createChooser(i, "选择文件"), REQUEST_CODE_FILE_PICKER); &#125; public void onActivityResult(final int requestCode, final int resultCode, final Intent intent) &#123; if (requestCode == REQUEST_CODE_FILE_PICKER) &#123; if (resultCode == Activity.RESULT_OK) &#123; if (intent != null) &#123; //Android 5.0以下版本 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(intent.getData()); mFileUploadCallbackFirst = null; &#125; else if (mFileUploadCallbackSecond != null) &#123;//Android 5.0及以上版本 Uri[] dataUris = null; try &#123; if (intent.getDataString() != null) &#123; dataUris = new Uri[] &#123; Uri.parse(intent.getDataString()) &#125;; &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= 16) &#123; if (intent.getClipData() != null) &#123; final int numSelectedFiles = intent.getClipData().getItemCount(); dataUris = new Uri[numSelectedFiles]; for (int i = 0; i &lt; numSelectedFiles; i++) &#123; dataUris[i] = intent.getClipData().getItemAt(i).getUri(); &#125; &#125; &#125; &#125; &#125; catch (Exception ignored) &#123; &#125; mFileUploadCallbackSecond.onReceiveValue(dataUris); mFileUploadCallbackSecond = null; &#125; &#125; &#125; else &#123; //这里mFileUploadCallbackFirst跟mFileUploadCallbackSecond在不同系统版本下分别持有了 //WebView对象，在用户取消文件选择器的情况下，需给onReceiveValue传null返回值 //否则WebView在未收到返回值的情况下，无法进行任何操作，文件选择器会失效 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(null); mFileUploadCallbackFirst = null; &#125; else if (mFileUploadCallbackSecond != null) &#123; mFileUploadCallbackSecond.onReceiveValue(null); mFileUploadCallbackSecond = null; &#125; &#125; &#125; &#125;&#125; 9、怎么为 WebView 的加载添加进度条 这里的 onPageFinished() 有个问题，不能在这里监听页面是否加载完毕（我自己测试的时候，好像在重定向和加载完 iframes 时都会调用这个方法）。 把页面加载完毕的判断放在 onProgressChanged() 里可能会更为准确。 webView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onProgressChanged(WebView view, int position) &#123; progressBar.setProgress(position); if (position == 100) &#123; progressBar.setVisibility(View.GONE); &#125; super.onProgressChanged(view, position); &#125;&#125;);webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; progressBar.setVisibility(View.VISIBLE); super.onPageStarted(view, url, favicon); &#125;&#125;); 10、怎样对页面进行 Js 注入？ 首先你要在 WebView 开启 JavaScript,然后搭建桥梁 WebSettings webSettings = webView.getSettings();webSettings.setJavaScriptEnabled(true);webView.addJavascriptInterface(new WebAppBridge(new WebAppBridge.OauthLoginImpl() &#123; @Override public void getResult(String s) &#123; //TODO &#125; &#125;), "oauth");webView.loadUrl("javascript:" + getAssetsJs("autologin.js"));webView.loadUrl("javascript:adduplistener()"); WebAppBridge的代码 public class WebAppBridge &#123; private OauthLoginImpl oauthLogin; public WebAppBridge(OauthLoginImpl oauthLogin) &#123; this.oauthLogin = oauthLogin; &#125; @JavascriptInterface public void getResult(String str) &#123; if (oauthLogin != null) oauthLogin.getResult(str); &#125; public interface OauthLoginImpl &#123; void getResult(String s); &#125;&#125; 简单的说就是向网页注入一段 js, 在这段 js 里面设置回调到java中的方法 getResult()，由 WebAppBridge.getResult 来回收。其中js的核心代码为: oauth.getResult(str); 其中 oauth 这个名称要与 webView.addJavascriptInterface()方法的第二个参数一样。 具体的代码可以参考这个项目中写的 js 注入逻辑 OauthDialog地址：https://github.com/cpacm/MoeMusic/blob/master/app/src/main/java/com/cpacm/moemusic/ui/widgets/dialogs/OauthDialog.java 11、如何手动添加 Cookie 需要获得 CookieManager 的对象并将 cookie 设置进去。 从服务器的返回头中取出 cookie 根据Http请求的客户端不同，获取 cookie 的方式也不同，请自行获取。 /*** 将cookie设置到 WebView* @param url 要加载的 url* @param cookie 要同步的 cookie*/public static void syncCookie(String url,String cookie) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); /** * cookie 设置形式 * cookieManager.setCookie(url, "key=value;" + "domain=[your domain];path=/;") **/ cookieManager.setCookie(url, cookie);&#125; 删除 Cookie 的方法 /*** 这个两个在 API level 21 被抛弃* CookieManager.getInstance().removeSessionCookie();* CookieManager.getInstance().removeAllCookie();** 推荐使用这两个， level 21 新加的* CookieManager.getInstance().removeSessionCookies();* CookieManager.getInstance().removeAllCookies();**/public static void removeCookies() &#123; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeAllCookie(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; cookieManager.flush(); &#125; else &#123; CookieSyncManager.createInstance(Application.getInstance()); CookieSyncManager.getInstance().sync(); &#125;&#125; 12、如何使 HTML5 video 在 WebView 全屏显示 当网页全屏播放视频时会调用 WebChromeClient.onShowCustomView() 方法，所以可以通过将 video 播放的视图全屏达到目的。 @Overridepublic void onShowCustomView(View view, CustomViewCallback callback) &#123; if (view instanceof FrameLayout &amp;&amp; fullScreenView != null) &#123; // A video wants to be shown this.videoViewContainer = (FrameLayout) view; this.videoViewCallback = callback; fullScreenView.addView(videoViewContainer, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); fullScreenView.setVisibility(View.VISIBLE); isVideoFullscreen = true; &#125;&#125;@Overridepublic void onHideCustomView() &#123; if (isVideoFullscreen &amp;&amp; fullScreenView != null) &#123; // Hide the video view, remove it, and show the non-video view fullScreenView.setVisibility(View.INVISIBLE); fullScreenView.removeView(videoViewContainer); // Call back (only in API level &lt;19, because in API level 19+ with chromium webview it crashes) if (videoViewCallback != null &amp;&amp; !videoViewCallback.getClass().getName().contains(".chromium.")) &#123; videoViewCallback.onCustomViewHidden(); &#125; isVideoFullscreen = false; videoViewContainer = null; videoViewCallback = null; &#125;&#125; 但是很多的手机版本在网页视频播放时是不会调用这个方法的，所以这个方法局限性很大。 13、Android5.0上 WebView中Http和Https混合问题 /*** MIXED_CONTENT_ALWAYS_ALLOW：允许从任何来源加载内容，即使起源是不安全的；* MIXED_CONTENT_NEVER_ALLOW：不允许Https加载Http的内容，即不允许从安全的起源去加载一个不安全的资源；* MIXED_CONTENT_COMPATIBILITY_MODE：当涉及到混合式内容时，WebView 会尝试去兼容最新Web浏览器的风格。**/if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);&#125; 14、如何避免 WebView 的内存泄露问题 可以将 Webview 的 Activity 新起一个进程，结束的时候直接System.exit(0);退出当前进程； 不在xml中定义 WebView，而是在代码中创建，使用 getApplicationgContext() 作为传递的 Conetext； 在 Activity 销毁的时候，将 WebView 置空 @Overrideprotected void onDestroy() &#123; if (webView != null) &#123; webView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null); webView.clearHistory(); ((ViewGroup) webView.getParent()).removeView(webView); webView.destroy(); webView = null; &#125; super.onDestroy();&#125; 总结 如果你踩到了 WebView 上的坑，请先默哀一分钟，然后努力找找解决方法吧，总会有人体验过你的悲剧，也会有人重蹈你的覆辙。当然 WebView 里肯定不止我上面列出来的这些问题，如果你有更多的 WebView 问题解决方案欢迎评论交流。]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南]]></title>
    <url>%2Fposts%2Fca8423a1.html</url>
    <content type="text"><![CDATA[随着ReactNative、Weex与Flutter等跨端框架的发展，大前端的概念也逐渐普及开来，纯粹的Native开发相对变得比较少，前端也成为了客户端同学必须要掌握的一门技术，但是客户端同学做的是跨端开发，在学习路线上和前端同学又稍有不同，下面从客户端同学的视角去讨论如何学习前端知识。 这里为大家整理了一份跨端技术图谱，这份图谱并没有去穷尽所有的前端技术，只是从客户端开发的视角去梳理常用的技术点，帮助大家理清脉络。 更多关于跨端技术的讨论可以参见BeesHybrid项目。 开发工具IDE推荐VSCode，轻量级、插件丰富，常用插件如下所示： Terminal：命令行工具。 Git History：查看单行提交记录和文件提交记录。 Git Project Manager：Git项目管理工具。 Git Len：解决日常开发协作痛点，推荐安装。 vscode-icons：让你的文件都带上好看的图标。 Path Intellisense：文件路径自动补全。 Auto Close Tag：自动闭合HTML标签。 Baracket Pair Colorizer：成对括号分颜色显示，方便区分。 Settings Sync：同步你的配置和扩展，参见同步教程。 VS Color Picker：取色器。 ES7 React/Redux/GraphQL/React-Native snippets：React代码提示。 Vue 2 Snippets：Vue2代码提示。 更多关于VSCode的使用技巧可以参见强大的VSCode。 前端基础对于客户端同学来说，要想上手React、Vue这些框架，需要先掌握HTML、CSS与JavaScript等基础知识，这部分的内容建议通过书籍来学习 ，一点一滴打捞基础，要有耐心。 HTML书籍：《HTML5权威指南》 CSS书籍：《CSS权威指南》、《精通CSS》 JavaScript书籍：《JavaScript高级程序设计》、《你不知道的Javascript》 除了基础的JavaScript知识，你还需要掌握ES6相关概念，这块可以参考ECMAScript 6 入门。 NPM我们还需要了解NPM相关知识，NPM就像Android里的Maven仓库一样，它是一个JavaScript仓库。 Node.js的包管理工具。 官方文档 NPM新手教程 前端框架Vue Vue.js（读音 /vjuː/，类似于 view 的读音）是一套构建用户界面(user interface)的渐进式框架。 官方文档 awesome-vue Vue.js 2.0 快速上手精华梳理 Vue学习看这篇就够 [译] 从1万篇文章中挑出的40篇最棒的 Vue 学习指南（2018版） React 用于构建用户界面的 JavaScript 库。 官方文档 React.js 小书 React入门教程 揭秘react生态体系 [译] 从1.8万篇文章中脱颖而出45个最棒的 React.js 学习指南（2018版） [译] State of Vue.js report 2017 中文版 跨端框架从PC时代开始，Native与Web就一直是相互竞争、相互融合的关系，我们先来简单看看它们之间的优势与劣势。 Native Web 性能 高 低 用户体验 好 差 功能 可以充分利用平台自身的能力 只有使用W3C的标准能力 迭代 周期长，需要发布 周期短，随时发布 维护成本 高 低 跨平台 差 好 线程 多线程 单线程 可以看出，Native与Web之间各有优劣，在移动互联网发展的过程中，开发者们也一直在寻找融合双方优势的方案，经历了以下四个阶段的发展： Hybrid 1.0：为Web页面提供Naive API的能力，也就是用JS Bridge去增强系统的WebView的功能。缺点是：体验差，如滚动、动画与交互等，稳定性差，如列表内存占用大等。 Hybrid 2.0：将Native组件覆盖在WebView之上，例如微信的cover-view，提供更多的扩展能力。缺点是：用户体验融合性不好，如层级、事件、布局等。 Hybrid 3.0：前端DSL开发，Native渲染，例如React Native与Weex。缺点：对W3C标准能力支持有限，存在平台差异，三端并不完全统一。 Hybrid 4.0：百花齐放的小程序、快应用、轻应用方案，这个容器也有两种：WebView容器与类ReatNative容器。技术方案上并没有太多的花样，这种方案的兴起由微信带起，本质上 还是源于各大公司对于流量入口和生态的竞争。后续我们会着重聊一下。 注：值得一提的是，同层渲染现在已经逐渐在Android和iOS平台的WebView上实现，未来Hybrid会有更多的玩法。 ReactNative 使用JavaScript和React编写原生移动应用. 官方文档 React-Native学习指南 给所有开发者的React Native详细入门指南（第一阶段） Weex Weex是一个基于现代web开发经验构建高性能移动应用程序的框架。 官方文档 awesome-weex WEEX从入门到放肆-图文视频教程（完整版） awesome-weex：Weex 学习与开发资料 Flutter Flutter允许您通过一个代码库在iOS和Android上构建漂亮的本地应用程序。 官方文档 Flutter 开发资源汇总 [译] Awesome Flutter：带你从入门到进阶的 Flutter 指南 小程序小程序也属于跨端框架的范畴，但它与Weex这些框架不同，比起像ReactNative这种技术创新，它更像是一种商业创新，它源于各大巨头对于流量与入口的竞争。详情可参见2018年上半年小程序生态白皮书。 我们先就他们的技术方案做个简单的对比，如下所示： 微信小程序：基于WebView渲染，自建的DSL，与Vue 1.0有点像，不是很好用，后续又出了WePY、mpVue、Taro等DSL。 支付宝小程序：基于WebView与ReactNative两套容器渲染，自建了一套类React的DSL。 快应用：基于Native进行渲染，自己定义了一套类Vue的DSL。 淘宝轻应用：基于WebView与Weex两套容器渲染，自建了一套类Vue的DSL。 事实上，小程序承载的更多是业务形态，我们从业务开发角度对小程序的前端架构做个总结。 微信小程序 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 官方文档 微信小程序公开课 微信小程序开发资源汇总 支付宝小程序 支付宝小程序是一种全新的开放模式，它运行在支付宝客户端，可以被便捷地获取和传播，为终端用户提供更优的用户体验. 官方文档 支付宝小程序社区 快应用 快应用是基于手机硬件平台的新型应用形态；标准是由主流手机厂商组成的快应用联盟联合制定；快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台；以平台化的生态模式对个人开发者和企业开发者全品类开放。 官方文档 快应用官方开源项目 快应用开发圈资源汇总 小米直达服务介绍与开发实战 淘宝小程序 官方文档 模块化 commonjs AMD(CMD) UMD ES Module 任务管理器 npm scripts grunt gulp 模块打包工具 r.js webpack rollup browserify CSS预处理器 Sass Less Stylus Postcss 静态检查器 flow typescript 测试工具 mocha jasmine jest ava 代码检测工具 eslint jslint 附录资源 前端资源库 前端技能树 前端开发技能树魔兽天赋游戏版 JavaScript算法与数据结构 怎样成长为一个优秀的 Web 前端开发工程师？ 技术栈前端技术从底层到顶层一共可以分为20个，如下所示： 浏览器 渲染引擎、JavaScript引擎 HTML/JavaScript/CSS三支柱 编辑器 编译任务 编译工具 打包、调试、质量 测试 JS基础类库 JS类库 UI框架 CSS预处理器 模板 现代化 安全/模式 中间语言 跨平台解决方案 图片来源]]></content>
      <categories>
        <category>前端</category>
        <category>学习指南</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin常用语法以及注意事项]]></title>
    <url>%2Fposts%2Fa1a08df3.html</url>
    <content type="text"><![CDATA[类型的声明与使用val与varval 不可变引用，var 可变引用。 我们应该尽可能使用val关键字来声明所有的kotlin变量，why？ 首先一个变量在声明时是不可变的，那就代表你在使用的时候不需要考虑其他地方会对它重新赋值和改变(对于对象注意只是引用不可变)，直接使用。 val声明的类型由于必须初始化,它是线程安全的。 kotlin为了保证类型安全，所有变量声明的地方必须要做初始化，即显示赋一个初值。 空与非空kotlin对于可空类型和非空类型认为是两个完全不同的类型，比如Int与Int?,他们俩就不是相同的类型。利用这个特点和编译时检查，kotlin基本可以避免空指针异常。 上面已经说了kotlin的类型声明时必须要有初值，所以空与非空类型和val与var一组合就会变成4种情况，下面我们对一个Person对象进行声明: val p:Person = Person() val p:Person? = null // 这个情况是没有意义的var p:Person = Person() // 如果这个对象是非空类型，那么初始化的时候必须赋一个非null初值var p:Person? = null //可以给一个null,也可以给一个对象实例 上面这段代码基本解释了val与var和空与非空的关系。 空与非空的使用kotlin对空与非空做了严格的限制，那我们在使用时不都要对可空类型类型做判断吗？为了避免这个问题，kotlin提供了许多运算符来使开发人员对于可空与非空编码更加愉快。 安全调用运算符 “?.” 比如我们声明了这样一个类型var p:Person? = null。如果我们直接使用p.name，kotlin编译器是会报错的无法编译通过，所有我们必须这么做: if(p != null) p.name 这种代码写多了实在是太没有意义了，所有kotlin提供了?.。上面代码我们可以直接这样代替p?.name。它的实际执行过程是这样的:如果p为空则不操作，如果p不为空则调用p.name。 Elvis 运算符 “?:” 在kotlin中我们会写这种代码: val name = if(p != null) p.name else &quot;&quot; //kotlin中的if是一个表达式 不过使用?:可以更简单实现上面的逻辑 : val name = p?.name ?: &quot;&quot; 。 它的实际执行逻辑是如果p为null，p?.name就会为null， ?:会检查前面的结果，如果是null，那么则返回&quot;&quot;。 安全转换 “as?” 在kotlin中类型转换关键字为as。不过类型转换会伴随着转换失败的风险。使用as?我们可以更优雅的写出转换无风险的代码: //Person类中的方法fun equals(o:Any?):Boolean&#123; val otherPerson = o as? Person ?: return false ....&#125; 即as?在转换类型失败时会返回null 非空断言 “!!” 如果使用一个可空类型的方法，并且你不想做非空判断，那么你可以这样做: person!!.getAge()。 不过如果person为null，这里就会抛出空指针异常。 其实还是在蛮多case下可以使用它，但是不建议使用，意难忘你完全可以使用？、？来做更优雅的处理，你也可以使用lateinit来避免编译器的可空提示。 val与bylazy、var与lateinit bylazy 它只能和val一块使用。 private val mResultView：View = bylazy&#123; initResultView()&#125; 使用bylazy我们可以对一个变量延迟初始化，即懒加载。它是线程安全的。具体原理是:当我们使用bylazy声明的变量时，如果这个变量为null,那么就会调用bylazy代码块来初始化这个变量。 lateinit 它只能和var一块使用，并且不允许修饰可空类型，那它的使用场景是什么呢？ 在有些case下，比如一个构造复杂的对象，我们就是想把变量声明为非空类型并且就是不想给他一个初值(代价太大了),这时候我们就可以使用lateinit : lateinit var p : Person //Person的构造函数太复杂了，不想在这里给一个初值fun refreshUI(p2:Person)&#123; //p = p2 val name = p.name //注意这个地方是可能会抛p为初始化异常的！！！如果你没有初始化&#125; 由于使用lateinit的时候我们要人工保证这个变量已经被初始化，并且kotlin在你每个使用这个变量的地方都会添加一个非null判断。所以lateinit尽量少用。 when 与 ififif在kotlin中不只是一个控制结构它也是一个表达式,即它是有返回结果的，我们可以利用它来代替java中的三目运算符: val background = if(isBlcak) R.drawable.black_image else R.drawable.white_image when它的使用方法有多种: 代替switch的功能 when(color)&#123; &quot;red&quot;,&quot;green&quot; -&gt;&#123; &#125; &quot;blue&quot;-&gt;&#123; &#125;&#125; kotlin中的when可以用来判断任何对象，它会逐一检查每一个分支，如果满足这个分支的条件就执行。 多条件判断 可以使用when来避免if..elseif..elseif..else的写法: val a = 1val b = 2when&#123; a &gt; 0 &amp;&amp; b &gt; 0 -&gt;&#123;&#125; a &lt; 0 &amp;&amp; b &gt; 0 -&gt;&#123;&#125; a &lt; 0 &amp;&amp; b &lt; 0 -&gt;&#123;&#125; else -&gt;&#123; &#125;&#125; when是带有返回值的表达式 和if一样，when也是一个表达式: val desColor = when(color)&#123; &quot;red&quot;, &quot;gren&quot; -&gt; &quot;red&amp;green&quot; &quot;blue&quot; -&gt; &quot;blue&quot; else -&gt; &quot;black&quot; // when作为表达式时必须要有else分支。 &#125; 类类的构造与主构造函数 简单的声明一个 javabean 在kotlin中我们可以这样简单的定义一个类: class Person(val name:String = &quot;&quot;, var age:Int = 0) 这样就定义了一个Person类，这个类有两个属性:name和age。并且他有一个两个参数的构造函数来对这两个属性初始化。可以看出kotlin将一个类的声明变的十分方便。 主构造函数 普通的java构造函数是有代码块的，即可以做一些逻辑操作，那按照kotlin上面的方式，我们怎么做构造函数的逻辑操作呢? kotlin提供了初始化代码块: class Person(val name:String = &quot;&quot;, var age:Int = 0)&#123; init&#123; name = &quot;susion&quot; age = 13 &#125;&#125; init代码块会在主构造函数之后运行，注意不是所有的构造函数。 数据类 data class更方便的定义一个javabean，我们可以使用数据类: data class Person(val name:String = &quot;&quot;, val age:Int = 0) 使用data定义的Person会默认生成equals、hashCode、toString方法。需要注意的是数据类的属性我们应该尽量定义成val的。这是因为在主构造函数中声明的这些属性都会纳入到equals和hashCode方法中。如果某个属性是可变的， 那么这个对象在被加入到容器后就会是一个无效的状态。 object 和 companion object在kotlin中没有静态方法，也没有静态类。不过kotlin提供了object与companion object object 单例类 使用object我们可以很轻松的创建一个单例类 : object LoginStatus&#123; var isLogin = false fun login()&#123; isLogin = true &#125; ...&#125; 我们可以这样直接使用LoginStatus.isLogin()。 那这个单例在kotlin中是怎么实现的呢？我们可以反编译看一下它生成的java代码: public final class LoginStatus &#123; private static boolean isLogin; public static final LoginStatus INSTANCE; // for java调用 ..... //省略不重要的部分 public final void login() &#123; isLogin = true; &#125; private LoginStatus() &#123; INSTANCE = (LoginStatus)this; &#125; static &#123; //类加载的时候构造实例 new LoginStatus(); &#125;&#125; 即kotlin object实现的单例是线程安全的。它的对象是在类创建的时候就产生了。 object的静态方法的使用 上面我们已经知道object创建单例的原理了。这在某些case下就很棒，但是某些时候我们不是想要单例，我们只是想要一些静态方法呢？比如我们经常创建的一些工具类(UIUtils、StringUtils)等。我们可以直接使用object来完成: public object UIUtils&#123; ... ... ... ..很多方法&#125; 按照kotlin单例的设计，我们只要一旦使用这些方法，那么一直有一个单例对象UIUtils存在于内存中。那么这样好吗? 我们是否可以这样写呢 : public class UIUtils&#123; ... ... ... ..很多方法&#125; 然后在使用的时候:UIUtils().dp2Px(1)。这样至少不会有一个对象一直在内存中。我想我们在某些case下可以这样使用我们的工具类。或者你可以使用kotlin的扩展函数或顶层函数来定义一些工具方法。所以对于kotlin的object的使用需要注意。 companion object companion object主要是为了方便我们可以在一个类中创建一些静态方法而存在的，比如: class Person(val name: String) &#123; companion object &#123; fun isMeal(p: Person) = false &#125; &#125; 依旧看一下它反编译后的java代码: public final class Person &#123; ... public static final Person.Companion Companion = new Person.Companion((DefaultConstructorMarker)null); .... public static final class Companion &#123; public final boolean isMeal(@NotNull Person p) &#123; Intrinsics.checkParameterIsNotNull(p, &quot;p&quot;); return false; &#125; private Companion() &#123; &#125; ..... &#125;&#125; 即它也是生成了一个单例类Person.Companion。不过这个单例类是一个静态类。不允许构造。不过它的实现机制几乎和object相同。 lambdakotlin中lambda的本质就是可以传递给其他函数的一小段代码。kotlin中lambda使用的最多的就是和集合一块使用。 lambad与java接口 比如我们经常给View设置onClickListener,在kotlin中我们可以很方便的实现这段代码: userView.setOnClickListener&#123;&#125; // 如果lambda是函数的最后一个参数，那么是可以放在括号外面的。 即你可以直接传递给它一个lambda。kotlin在实际编译的时候会把这个lambda编译成一个匿名内部类。 那么所有java传对象的地方都可以这样使用吗？ 当然不是, 只有java参数满足下面条件才可以使用: 这个参数是一个接口，并且这个接口只有一个抽象方法。就可以这样使用，比如Runnable、Callable等。 with 与 apply with个人感觉比较鸡肋，这里就不讲它了。不过apply是十分实用的。在kotlin中apply被实现为一个函数: public inline fun &lt;T&gt; T.apply(block: T.() -&gt; kotlin.Unit): T &#123; &#125; 即它是一个扩展函数，接收一个lambda，并返回对象本身,并且他是一个内联的函数(下面会讲) 我最常用的一个case是给view设置参数: val tvName = TextView(context).apply&#123; textSize = 10 textColor = xx text = &quot;susion&quot; ...&#125; 常用的库函数内联函数kotlin集合库中很多函数可以接收lambda作为参数。但我们前面说了kotlin的lambda表达式会被编译为一个匿名内部类，即每一次lambda的调用都会创建一个匿名内部类，所以会带来运行时的开销。 kotlin集合库中函数时给我们使用的，如果有这种开销的话，这肯定是一个不好的设计，因此kotlin集合库中的大部分函数都是内联函数。 比如上面的apply声明 : public inline fun &lt;T&gt; T.apply(block: T.() -&gt; kotlin.Unit): T { .... } 何为内联呢？: 当一个函数被声明为inline时，它的函数体是内联的，即函数体会被直接替换到函数被调用的地方。即不会存在运行时开销，下面要说的filter和map都是内联函数。 filter 与 map filter接收一个返回Boolean的lambda，用于对一个集合做筛选工作,并返回一个新集合: val wangList = userList.filter&#123;it.firstName == &quot;wang&quot;&#125; map也是接收一个lambda，它的返回值是另一个类型的集合，即map可以把一个类型的集合变成另一个类型的集合。 val ageList = userList.map&#123; it.age &#125; 这两个函数虽然好用，不过我们要注意他们的实现，以免带来不必要的性能损耗 : filter和map函数都会创建一个新集合，因此如果你是下面这种用法就可能出现不必要的集合创建: val wangList = userList.map&#123; it.name &#125;.filter&#123;it == &quot;wang&quot;&#125; 在这种情况下，userList集合非常大的话，那么map操作之后生成的中间集合也可能非常大，对于这种情况可以考虑使用 kotlin序列。 count与find count用于统计集合中满足某个条件的数量，可以对比下面这种写法 val wangCount= userList.filter&#123;it.firstName == &quot;wang&quot;&#125;.sizeval wangCount2 = userList.count&#123;it.firstName == &quot;wang&quot;&#125; //很明显，这种写法远好于第一种 find用来寻找集合中满足某个case的元素。 具体用法就不写了。 Kotlin的一些优秀的设计思想kotlin是基于java的，不过它在设计摒弃了很多java不好的思想。下面简单列举一些: kotlin中并不区分受检查异常和未受检查异常。即不用指定函数抛出的异常，而且也可以不处理异常 kotlin中类和类的方法默认是final的，即不允许继承和重写。这主要是为了减少继承，避免脆弱基类的问题 kotlin中集合接口分为访问集合数据和修改集合数据。比如kotlin.collections.Collection中就没有修改集合的方法。 kotlin中的函数支持默认参数，避免了多次重写一个函数的情况 kotlin支持扩展函数。它实际上就是某个类的静态方法。 …..]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让hexo的首页只显示文章的部分内容而不是全部]]></title>
    <url>%2Fposts%2Fe778c36e.html</url>
    <content type="text"><![CDATA[Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？目标 &gt; 在网站首页只显示每篇文章的部分内容，不要全部内容都展示出来。解决 &gt; 要解决这个问题有两个方法：一是修改 主题 _config.yml 文件设置，而是直接在你的 md 中加一句代码即可。 第一种方法用文本编辑器打开 themes/ 目录下的对应的主题的theme文件夹下的 _config.yml 文件，找到这段代码，如果没有则新建，可能不同的主题会不支持这种方法： # Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。 修改后重启 hexo 就ok了。 第二种方法在你写 md 文章的时候，可以在内容中加上 &lt;!--more--&gt;，这样首页和列表页展示的文章内容就是 &lt;!--more--&gt; 之前的文字，而之后的就不会显示了。 效果 上面两种方式展示出来的效果是不一样的。 第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …。 而第二种加上 &lt;!--more--&gt;展示出来的就是你原本文章的样式，最后不会有…。 第三种方式在文章的 front-matter 中添加 description，并提供文章摘录 ---title: 让hexo的首页只显示文章的部分内容而不是全部id: set-hexo-show-more-button-on-indexcategories: - WEB开发date: 2017-09-30 11:01:40tags: - blog - hexodescription: Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？正如你现在看到的本篇文章，只显示到这里。--- 但是使用这种方式生成的描述信息在文章的详情页是不再显示的。 总结各种方式展示的效果各有好处，第二种方法保留了样式而且可以自行选择显示哪些内容来预览，推荐使用此方法，第一种方法显示的每篇文章的预览都是一样的高度，第三种则需要在文章的[front-matter]{https://hexo.io/docs/front-matter.html}里面添加。 综合考虑的话还是建议使用第二种方法，毕竟以后各种插件也能准确的获取到你想要输出的本篇的描述信息。 参考链接： http://www.5isjyx.com/coding/201704/nextreadthefulltext.html http://theme-next.iissnan.com/faqs.html]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudioGit设置忽略文件不生效]]></title>
    <url>%2Fposts%2F40a53d12.html</url>
    <content type="text"><![CDATA[在Android中git提交想忽略某些不想提交的文件，可以在项目目录中新建一个.gitignore，如果没有这个文件，可以手动建一个。里面匹配一下你不想提交的文件。 下面这是Android Studio的忽略规则 # OSX*.DS_Store# Gradle filesbuild/.gradle/*/build/# IDEA*.iml.idea/.name.idea/encodings.xml.idea/inspectionProfiles/Project_Default.xml.idea/inspectionProfiles/profiles_settings.xml.idea/misc.xml.idea/modules.xml.idea/scopes/scope_settings.xml.idea/vcs.xml.idea/workspace.xml.idea/libraries# Built application files*.apk*.ap_# Files for the Dalvik VM*.dex# Java class files*.class# Generated filesantLauncher/binantLauncher/gen# Local configuration file (sdk path, etc)local.properties# Log Files*.log 规则网上很多，可以自己搜下，或者自己写一个也行。但是当我们提交的时候，却发现这些规则并没有失效，原因就是因为.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启你的终端装逼第一步]]></title>
    <url>%2Fposts%2F9253a935.html</url>
    <content type="text"><![CDATA[作为开发人员，和终端的亲密度那肯定不是一般地高，以上便是我打开终端迎面而来的画面，是不是逼格满满，23333，下面来教大家如何在 mac 上配置，其他系统应该也同理。 首先打开终端（这一步要是不会，那老铁你就别配置了吧）。 输入 cd /etc 进入目录。 输入 sudo pico motd,然后输入密码后进入修改页面。 然后在其中输入你想显示的装逼内容，再此提供一个图形界面网站：这是一个神奇的网站，干货满满吧。 最后 control + x，输入 y 保存，重启终端就可以看到逼格满满的欢迎页了。 如下图是我的：]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>博客</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 性能优化]]></title>
    <url>%2Fposts%2F20aedb71.html</url>
    <content type="text"><![CDATA[数据处理和视图加载分离我们知道，从远端拉取数据肯定是要放在异步的，在我们拉取下来数据之后可能就匆匆把数据丢给了 VH 处理，其实，数据的处理逻辑我们也应该放在异步处理，这样 Adapter 在 notify change 后，ViewHolder 就可以简单无压力地做数据与视图的绑定逻辑，比如： mTextView.setText(Html.fromHtml(data).toString()); 这里的 Html.fromHtml(data) 方法可能就是比较耗时的，存在多个 TextView 的话耗时会更为严重，这样便会引发掉帧、卡顿，而如果把这一步与网络异步线程放在一起，站在用户角度，最多就是网络刷新时间稍长一点。 数据优化分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 来进行局部刷新数据，而不是一味地全局刷新数据。 布局优化减少过渡绘制减少布局层级，可以考虑使用自定义 View 来减少层级，或者更合理地设置布局来减少层级，不推荐在 RecyclerView 中使用 ConstraintLayout，有很多开发者已经反映了使用它效果更差，相关链接有：Is ConstraintLayout that slow?、constraintlayout 1.1.1 not work well in listview。 减少 xml 文件 inflate 时间这里的 xml 文件不仅包括 layout 的 xml，还包括 drawable 的 xml，xml 文件 inflate 出 ItemView 是通过耗时的 IO 操作，尤其当 Item 的复用几率很低的情况下，随着 Type 的增多，这种 inflate 带来的损耗是相当大的，此时我们可以用代码去生成布局，即 new View() 的方式，只要搞清楚 xml 中每个节点的属性对应的 API 即可。 减少 View 对象的创建一个稍微复杂的 Item 会包含大量的 View，而大量的 View 的创建也会消耗大量时间，所以要尽可能简化 ItemView；设计 ItemType 时，对多 ViewType 能够共用的部分尽量设计成自定义 View，减少 View 的构造和嵌套。 其他其他并不代表不重要，而是我不能把他们进行分类哈，其中可能某些操作会对你的 RecyclerView 有很大的优化。 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可参考 RecyclerView 数据预取。 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout浪费资源； 设置 RecyclerView.addOnScrollListener(listener); 来对滑动过程中停止加载的操作。 如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提神效率。 对 TextView 使用 String.toUpperCase 来替代 android:textAllCaps=&quot;true&quot;。 对 TextView 使用 StaticLayout 或者 DynamicLayout 的自定义 View 来代替它。 通过重写 RecyclerView.onViewRecycled(holder) 来回收资源。 通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。 通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示： new LinearLayoutManager(this) &#123; @Override protected int getExtraLayoutSpace(RecyclerView.State state) &#123; return size; &#125;&#125;;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC应用无法打开或文件损坏的处理方法]]></title>
    <url>%2Fposts%2Fef30a8ec.html</url>
    <content type="text"><![CDATA[有些用户下载了一些程序之后，却发现无法在MAC中安装，安装时会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。那么该如何解决这个问题呢？ 在MAC下安装一些软件时提示”来自身份不明开发者”，其实这是MAC新系统启用了新的安全机制。默认只信任 Mac App Store 下载的软件和拥有开发者 ID 签名的应用程序。换句话说就是 MAC 系统默认只能安装靠谱渠道（有苹果审核的 Mac App Store）下载的软件或被认可的人开发的软件。 这当然是为了用户不会稀里糊涂安装流氓软件中招，但没有开发者签名的 “老实软件” 也受影响了，安装就会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。 出现这个问题的解决方法有2种： 最简单的方式：按住Control后，再次点击软件图标，即可。 修改系统配置：系统偏好设置… -&gt; 安全性与隐私。 系统偏好设置 安全性与隐私 认证 修改为任何来源 高能预警！！！！！！！！(专门为不仔细看文章的准备的。。。。。。。没办法，只能放这么大了，要不老有人在评论里面问)如果没有这个选项的话（macOS Sierra 10.12）,打开终端，输入sudo spctl --master-disable然后按回车。然后会看见个password后面还有个钥匙图标，然后不用管他直接再继续输入你自己电脑解锁密码（输入的时候不显示你输入的密码，感觉就是输入不了东西一样，也不用管，凭感觉输入完按回车键）。然后再回到隐私里，就看见任何来源了。 ©软件著作权归作者所有;本站所有软件均来源于网络，仅供学习使用，请支持正版！ 转载请注明出处：精品MAC应用分享 » MAC应用无法打开或文件损坏的处理方法]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发技巧]]></title>
    <url>%2Fposts%2F56f29aad.html</url>
    <content type="text"><![CDATA[有同学问我，对应用开发你有没有值得注意或小技巧的地方可以分享的。比如适配、优化、排查错误什么的。鸡排把自己的总结笔记整理出来了。供大家参考。 开工准备在项目业务代码开工之前，最好把这些问题都解决掉，否则必将酿成大祸害。它们是： 组件路由 异步处理 组件化模块工程 全局网络拦截器 异常统一处理器 基础视图组件封装 日志记录工具 解决写无数次一模一样代码的模板（如自定义MVP模板） 机型适配特定的机型上出问题时，别着急。我们可以尝试以下几个办法。 反编译rom，看底层改动(条件略高) 联系该厂商的工程师（如果可以的话） 拷贝整个我们调用api的源码进行单独依赖，而放弃系统内的 逆向在该机型上正常的同类app，参考逆向后的代码实现 参考各个版本不同的Android API变化，可以从源码入手进行对 利用反射获取该特定机型上的某个我们想知道的方法，动态调试 排查崩溃闪退日志: 如果app在调试的过程中出现闪退,此时在logcat下日志会被新起来的进程冲刷掉。这时需要把过滤器选择为No filter 把日志级别选为 error即可查看到上一次崩溃的日志。 有一种情况是手机并不在我们身边,我们也无法使用调试工具。此时可以接入一些第三方的日志记录工具。在开发状态下不建议使用友盟 360之类sdk,因为很有可能我们的app根本无法连接到网络就崩溃了。 可以选择把日志存到本地文件中。再又使用手机的人发回来。一般这个人是测试。 如果app未接入任何日志保存工具,可以在data/anr/目录下查看到所有的ANR异常信息。但需要su权限。否则无法访问到。 APP性能体验优化 素材有必要使用压缩后的。推荐熊猫PNG压缩。 资源能用代码画尽量使用代码去画，而不要使用静态资源。 在复杂的布局上,比如很多app的首页需要加载不同类型的item。使用了RecyclerView多类型加载,刷新数据时一定要使用单独对item刷新api。切勿使用notifyitemchanged()方法,这里要用两个参数的notifyItemChanged(1,&quot;gfg&quot;)方法。 数据懒加载，或排队加载 混淆可以使包减小含:(xml 资源 class等) 如果玩得不是很6，尽量不要写静态引用，匿名内部类这种会导致内存泄漏的东西。如果很担心自己失误的写了，一定要去分析它们，把他们揪出来。 Activity的层级不要太深。过深会在低内存设备上被回收栈底的。 建议和技巧 发现某处代码可以复用性的封装一下或者改良一下会更好的时候一定要乘早，不要拖延。（烂泥巴只会越来越烂，后面改=永远没可能） debug编译期间可以把用不到的abi过滤掉，会让我们加速部署。 尽量保持较新的 support library依赖。因为较高的版本中修复了一些bug。 接入第三方包时，最好与自身模块保持独立，做到随时解耦，随便复用。 多个native库依赖时，若发现某些abi上不支持，那么就需要保持最小的abi。否则会给某些机型优先读取它更合适的架构。会造成灾难性的崩溃。如:ARM文件夹中含两个so，ARMv8中只有一个。届时手机优先加载了ARMV8的情况下，将带来找不到so库的崩溃异常。 不要太随性的引入第三方依赖库，如果只是用了很小一部分功能，建议剥出来自己封装。 第三方的包含私有api为暴露时，记得用反射去实现。当然这一切需要我们能翻他们的sdk源码读。也许被混淆了。这时就可以使用动态调试去跟踪。 多数情况下官方的support包比第三方要好得多。只是我们不知道，或者不熟悉。 渐变图、纯色图、带一根线的图用shape，不要静态图。会引发血案！ 当无法通过搜索解决问题的时候，读源码是最快的解决思路。千万不要瞎猜和尝试随缘写代码来解决问题。 封装控件时注意对资源类型做校验如:Image.setImageResource(img);这里的img需要做强校验，类型检测，防止别人用的时候不小心写错了。因为如果我们不主动抛出异常。靠LayoutInflater通过反射去解析xml时提示出了的错误日志非常难看。一般还会伴随一大堆调用栈和闪退出现。 冷启动优化，不要在Application启动时里做过多的任务&amp;第一个Activity里也是一样。最好把初始化的白屏Window设上一张图片过渡一下。 有不妥之处，欢迎指出和补充，拼死挣扎的Android程序员。]]></content>
      <categories>
        <category>Android</category>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 8.0采坑以及解决方法]]></title>
    <url>%2Fposts%2Fb2677b13.html</url>
    <content type="text"><![CDATA[虽然 Android 9.0 都已经面世了，本篇文章写的有点迟了。 但是迟到好过不到，因此基于此这边还是记录一下项目中遇到的 Android 8.0 的坑及对应解决方法。 每次系统升级，虽然系统功能更加强大了，各方面性能也提高了。 但是对于开发者而言，一个困扰的问题也是随之而来——兼容。 尤其对于一些已经上市的 App 而言，在新系统发布之前就要了解到底有哪些改动，以避免用户升级新系统后导致 App 没法正常运行。 好了，回归主题，说说 Android 8.0 里面的几个坑吧。 唤不起系统安装器如果你的 App 提供了更新功能，用户点击更新，你下载完 Apk 之后会自动弹出安装界面。 这个安装界面的弹出就是依赖于系统的安装器。 假设你在 Android 8.0 以下的手机操作正常，但是在 8.0 的手机上，你会发现，下载完之后完全没反应。 假设你以为说弹个提示让用户自己安装，我想说用户才不会理你。用户分分钟就不更新了。 所以说我们要解决这个问题。让这个安装器在 Android 8.0 的手机也能正常唤起。 其实解决方法非常简单。 只需要在 AndroidManifest.xml 中声明以下权限即可。 &lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt; 而且还不需要你在代码动态申请，是不是 So easy。 一行代码解决这个兼容性问题。 通知问题假设你的 App 需要在任务栏显示通知。如果你是按照 Android 8.0 之前的写法的话。那么在 8.0 的手机上面你是显示不了的。 那怎么办呢？ 关于通知的基本写法这边就不再赘余，如果不清楚的小伙伴自行查阅资料。这边重点说下解决方法。 首先说下下面代码出现的几个变量： private static NotificationManager manager;public static final String NOTIFICATION_CHANNEL = &quot;your app pkg name&quot;;private static final String NOTIFICATION_CHANNEL_NAME = &quot;App Channel&quot;; 第一个写过通知的都知道，一个管理类。 第二个是通知的一个 CHANNEL，这个也是 8.0 之后才引入的。取值 App 包名即可。 第三个自定义，只要保证唯一即可。 兼容有两步需要操作。 1. 创建Channelprivate static void createChannel() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; NotificationChannel notifyChannel = new NotificationChannel(NOTIFICATION_CHANNEL, NOTIFICATION_CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT); notifyChannel.setLightColor(Color.GREEN); notifyChannel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE); manager.createNotificationChannel(notifyChannel); &#125; &#125; 2. 获取 Notification.Builderprivate Notification.Builder getNotificationBuilder(Context sourceContext) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; return new Notification.Builder(sourceContext, NOTIFICATION_CHANNEL); &#125; else &#123; return new Notification.Builder(sourceContext); &#125; &#125; 可以看到，上面的操作都以 8.0 作为分界处理。 做完这两步，之前不能显示通知的 App 就可以显示了。 更多内容可以看官方示例： github.com/googlesampl…]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio清理缓存CleanProject与InvalidateCaches]]></title>
    <url>%2Fposts%2Fc7a76d2f.html</url>
    <content type="text"><![CDATA[####Android studio 有时找不到R文件、 导入的资源、布局 、 jar包 等 . 可能是studio 缓存造成的 . 1.使用clean project工具栏 Build –&gt; clean project 2. 使用invalidate caches restart选择工具栏 File –&gt; Invalidate Caches /Restart… -&gt; Invalidate and Restart 重启Android studio]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext点击搜索一直转圈圈，解决控制字符问题]]></title>
    <url>%2Fposts%2Fb30a2a4e.html</url>
    <content type="text"><![CDATA[1. 环境 macOS Sierra 10.13.6 vscode 1.29.0 最新版 2. 如何重现这个问题在使用中文输入法输入中文的时候，一直按后退键，例如输入sfsf，当你按了4下后退键时，你会发现，搜狗输入法弹出框虽然消失了，但是页面上还会剩下一个s, 这是你如何再次按一下后退的话，s就会变成bs, 变成隐藏字符。这个一般是右边有markdown渲染插件时才会出现。 从更确切的角度说，是你的编辑器一旦开了webview，就会出现这个问题，即使是vscode的欢迎页，也是webview，也会导致这个问题。所以最好在写代码时尽量关闭webview。 3. 如何让隐藏字符现身Mac版的vscode控制字符一般是不会显示出来的，可以用一下的方法让其显示出来 &quot;editor.renderControlCharacters&quot;: true 在编辑器中显示的像很小的BS, 表示backspace的意思。一般是在输入时，按了后退或者删除会偶尔出现这个字符。 4. 隐藏的控制字符会出现什么问题？4.1. 控制字符在github上会出现问号例如下图的的和同字之间就是出现一个隐藏字符，在github上就会出现一个带有背景的问号。 4.2. 控制字符在Hexo NexT Local Search 会导致search.xml渲染失败，搜索框一直在转圈如果你使用浏览器打开search.xml，会发现解析报错 5. 如何解决5.1. 手动删除隐藏字符可以使用替换，先复制一个隐藏字符，然后把隐藏字符替换成空 5.2. 使用插件 Remove backspace control characterRemove backspace control character 在本家chromium已被合并，因此，在8月上旬发行的vscode 1.15将会重新确定(vscode 1.15, electron 1.7.4)。事实上，到现在这个问题还是没解决的 特点 格式化程序，用于删除打开的文档中包含的控制字符。要被删除的控制字符默认如下。 /[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm 用法 “editor.formatOnSave”: true 如果被设定,保存时启动 “editor.formatOnType”: true 在被设定的情况下，进行变换时;输入时启动 7. 参考 Mac 上的 VSCode 编写 Markdown 总是出现隐藏字符？ Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层 Backspace can not erase the last one character during Chinese/Japanese IME conversion (macOS) #24981 Backspace can not erase the last one character during Japanese IME conversion (macOS) #9173 Two backspaces required to delete last character in webview input 控制字符 Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同的国家/地区与语言缩写代码]]></title>
    <url>%2Fposts%2Ff8376e8.html</url>
    <content type="text"><![CDATA[国家/地区 语言代码 国家地区 语言代码 简体中文(中国) zh-cn 简体中文(台湾地区) zh-tw 繁体中文(香港) zh-hk 英语(香港) en-hk 英语(美国) en-us 英语(英国) en-gb 英语(全球) en-ww 英语(加拿大) en-ca 英语(澳大利亚) en-au 英语(爱尔兰) en-ie 英语(芬兰) en-fi 芬兰语(芬兰) fi-fi 英语(丹麦) en-dk 丹麦语(丹麦) da-dk 英语(以色列) en-il 希伯来语(以色列) he-il 英语(南非) en-za 英语(印度) en-in 英语(挪威) en-no 英语(新加坡) en-sg 英语(新西兰) en-nz 英语(印度尼西亚) en-id 英语(菲律宾) en-ph 英语(泰国) en-th 英语(马来西亚) en-my 英语(阿拉伯) en-xa 韩文(韩国) ko-kr 日语(日本) ja-jp 荷兰语(荷兰) nl-nl 荷兰语(比利时) nl-be 葡萄牙语(葡萄牙) pt-pt 葡萄牙语(巴西) pt-br 法语(法国) fr-fr 法语(卢森堡) fr-lu 法语(瑞士) fr-ch 法语(比利时) fr-be 法语(加拿大) fr-ca 西班牙语(拉丁美洲) es-la 西班牙语(西班牙) es-es 西班牙语(阿根廷) es-ar 西班牙语(美国) es-us 西班牙语(墨西哥) es-mx 西班牙语(哥伦比亚) es-co 西班牙语(波多黎各) es-pr 德语(德国) de-de 德语(奥地利) de-at 德语(瑞士) de-ch 俄语(俄罗斯) ru-ru 意大利语(意大利) it-it 希腊语(希腊) el-gr 挪威语(挪威) no-no 匈牙利语(匈牙利) hu-hu 土耳其语(土耳其) tr-tr 捷克语(捷克共和国) cs-cz 斯洛文尼亚语 sl-sl 波兰语(波兰) pl-pl 瑞典语(瑞典) sv-se 西班牙语 (智利) es-cl]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android组件化，完全解耦]]></title>
    <url>%2Fposts%2Fd7e6359d.html</url>
    <content type="text"><![CDATA[目前,Android 组件化普遍使用于移动开发,但是组件化的初衷是为了解耦代码,并行开发效率;小型app似乎会care不到,完全解耦的组件化会在app越来越臃肿的时候带来很大的提升; 1.组件化介绍ok,那么我们需要知道完全解耦的组件化框架应该注意哪些点: 主app只加载业务组件,不可调用组件;组件与组件之间不存在调用关系;这样无论是主app和业务组件都是完全独立,完全解耦的; 主app和组件都依赖common组件,通过common的注册和分发实现组件之间的交互,这个common我们姑且叫做业务主线 android中page使用common下层接口和路由进行实现(在本框架中,ARouter实现Activity跳转,ARouter-Interceptor实现Activity跳转的拦截;Fragment通过common下沉注册分发实现Fragment的填充) 每一个组件应当是一个app可单独编译:Library和Application之间转化使用gradle配置相应的Manifest和applicationId 2.单独编译组件化配置(gradle)依赖关系 App 依赖common Home/Login/News 依赖common common 依赖component-base 2.1. 首先在整个工程的gradle.properties中配置组件 Library/Application切换的开关: isRunLogin = false //login组件isRunHome = false //home组件isRunNews = false //news组件 2.2. 由于android中Library(组件)/Application切换时的差异,需要单独配置主见以home组件为例:首先开build.gradle: //注释1: 配置切换application/Library的打包if (isRunHome.toBoolean())&#123; apply plugin: &apos;com.android.application&apos;&#125;else&#123; apply plugin: &apos;com.android.library&apos;&#125;android &#123; ....... sourceSets &#123; //注释2: Library/Application切换 AndroidManifest main &#123; if (isRunLogin.toBoolean())&#123; manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; &#125;else&#123; manifest.srcFile &apos;src/main/manifest/AndroidManifest.xml&apos; &#125; &#125; &#125; ......&#125;...... 注释1: 切换application/Libaray的打包配置 注释2: Application为单独编译,需要有applicationId,并且主Activity需要配置main属性;Libaray为集成编译,组件不能有applicationId,且不可以设置启动的main Activity下面看集成编译(Library)和单独编译(Application)的Manifest配置: //集成编译,打包为Library&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="component.android.com.home"&gt; &lt;application android:theme="@style/home_AppTheme"&gt; &lt;activity android:name=".view.activity.HomeActivity"/&gt; &lt;/application&gt;&lt;/manifest&gt; //单独编译,打包为单独Application 可单独编译&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="component.android.com.home"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:name=".global.HomeApp" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/home_AppTheme"&gt; &lt;activity android:name=".view.activity.HomeActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 3.组件之间activity跳转(Actiivity跳转)3.1. 组件之间的activity跳转,这里使用ARouter ARouter是阿里开源的一种页面跳转task 首先看ARouter在build.gralde的配置: //主app build.gradle......dependencies &#123; ...... androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' &#125;//home/login/news 组件 build.gradledependencies &#123; ........ annotationProcessor 'com.alibaba:arouter-compiler:1.1.4'&#125;//common build.gradledependencies &#123; ...... api 'com.alibaba:arouter-api:1.3.1' // arouter-compiler 的注解依赖需要所有使用 ARouter 的 module 都添加依赖 annotationProcessor 'com.alibaba:arouter-compiler:1.1.4'&#125; 3.2 在app和各组件中进行page跳转 首先是ARouter的初始化 public class MainApplication extends BaseApp &#123; @Override public void onCreate() &#123; super.onCreate(); //在主app中初始化ARouter initRouter(); initMoudleApp(this); initMoudleData(this); &#125; private void initRouter() &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); &#125; @Override public void initMoudleApp(Application application) &#123; for (String moduleApp : AppConfig.moduleApps) &#123; try &#123; Class clazz = Class.forName(moduleApp); BaseApp baseApp = (BaseApp) clazz.newInstance(); baseApp.initMoudleApp(this); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void initMoudleData(Application application) &#123; for (String moduleApp : AppConfig.moduleApps) &#123; try &#123; Class clazz = Class.forName(moduleApp); BaseApp baseApp = (BaseApp) clazz.newInstance(); baseApp.initMoudleData(this); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//组件中 home--HomeApplicationpublic class HomeApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 这里需要注意一下 当集成编译时候 ,组件仅仅是一个组件,不会单独具备Applicagtion入口,所以需要在主app的MainApplication中利用反射的方式 initMoudleData/initMoudleData进行ARouter等初始化的配置; 下面看ARouter的跳转实例: //app/MainActivity....private void initClick() &#123; findViewById(R.id.btn_nav_home).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ARouter.getInstance().build("/home/homeActivity").navigation() &#125;&#125; 在app中实现跳转,但是这个 path/home/homeActivity需要在home组件目标位置添加注解才能实现activity的跳转: @Route(path = "/myhome/homeActivity")public class HomeActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_home); &#125;&#125; 这样 就成功实现类组件之间的activity的跳转; 4.组件之间的逻辑交互App点击跳转home,须判断登录逻辑: 1.登录则跳转home组件的homeActivity 2.未登录则跳转login组件的loginActivity,点击登录,再重复以上逻辑这样 主app,home和login就实现了一个简单的交互逻辑首先开component: //ILoginServicepublic interface ILoginService &#123; boolean getLoginStatus(); int getLoginUserId();&#125;//DefultLoginServicepublic class DefultLoginService implements ILoginService &#123; @Override public boolean getLoginStatus() &#123; return false; &#125; @Override public int getLoginUserId() &#123; return 0; &#125;&#125;//ComponentServiceFactorypublic class ComponentServiceFactory &#123; ...... public static ComponentServiceFactory getInstance(Context context)&#123; if (instance == null)&#123; synchronized (ComponentServiceFactory.class)&#123; if (instance == null)&#123; instance = new ComponentServiceFactory(); &#125; &#125; &#125; return instance; &#125; private ILoginService loginService; public void setLoginService(ILoginService iloginService)&#123; loginService = iloginService; &#125; public ILoginService getLoginService()&#123; if (loginService == null)&#123; loginService = new DefultLoginService(); &#125; return loginService; &#125;&#125; 然后在login中通过common的ComponentServiceFactory注册对应的loginService //LoginServicepublic class LoginService implements ILoginService &#123; @Override public boolean getLoginStatus() &#123; return AccountUtils.getInstance().isAccountStatus(); &#125; @Override public int getLoginUserId() &#123; return 0; &#125;&#125;//Login组件LoginApp注册service........public class LoginApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; Log.i("LoginApp","initMoudleApp"); if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); ComponentServiceFactory.getInstance(this).setLoginService(new LoginService()); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 在App-MainActivity中跳转homeActivity,在home组件中使用ARouter的拦截器: //app-mainActivityprivate void initClick() &#123; findViewById(R.id.btn_nav_home).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ARouter.getInstance().build("/home/homeActivity").navigation(MainActivity.this, new NavCallback() &#123; //ARouter拦截器的监听 @Override public void onArrival(Postcard postcard) &#123; LogUtils.LogI("loginInterceptor","done"); &#125; @Override public void onFound(Postcard postcard) &#123; //super.onFound(postcard); LogUtils.LogI("loginInterceptor","found"); &#125; @Override public void onLost(Postcard postcard) &#123; //super.onLost(postcard); LogUtils.LogI("loginInterceptor","lost"); &#125; @Override public void onInterrupt(Postcard postcard) &#123; //super.onInterrupt(postcard); LogUtils.LogI("loginInterceptor","interrupt"); &#125; &#125;); &#125; &#125;); &#125;//home-HomeInterceptor@Interceptor(priority = 1,name = "homeInterceptor")public class HomeInterceptor implements IInterceptor &#123; private Context context; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; switch (postcard.getPath())&#123; case "/myhome/homeActivity": //通过component进行逻辑交互 if (ComponentServiceFactory.getInstance(context).getLoginService().getLoginStatus())&#123; callback.onContinue(postcard); &#125;else &#123; ARouter.getInstance().build("/login/loginActivity").navigation(); //callback.onInterrupt(new RuntimeException("请登录")); //callback.onContinue(postcard); &#125; break; default: callback.onContinue(postcard); break; &#125; &#125; @Override public void init(Context context) &#123; this.context = context; &#125;&#125;//login-loginInterceptor@Interceptor(priority = 2,name = "loginInterceptor")public class LoginInterceptor implements IInterceptor &#123; private Context context; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; switch (postcard.getPath())&#123; case "/login/loginActivity": LogUtils.LogI("loginInterceptor","请点击登录按钮"); callback.onContinue(postcard); break; default: callback.onContinue(postcard); //在每一个组件中添加一个navi的拦截器 逻辑在 &#125; &#125; @Override public void init(Context context) &#123; this.context = context; &#125;&#125; 1.在跳转homeActivity时,跳转到home组件的homeInterceptor拦截器 2.在homeInterceptor中通过component获取login注册的lohginservice来获取登录状态,实现下一步跳转 可以看到 app 通过ARouter跳home home通过component的注册分发,判断登录逻辑 进行下一步跳转;这样就实现了不依赖其他组件的逻辑交互 5.组件化fragment解耦在android中我们使用最多的就是fragment,一般情况下 我们会实例化fragment再进行下一步逻辑;为了解耦我们在component中注册fragment接口,在相应组件中注册fragmentservice,在其他组件中实现分发: //component-LoginFragmentServicepublic class LoginFragmentService implements IFragmentService &#123; @Override public Fragment getFragment(String tag) &#123; return new LginHomeFragment(); &#125; @Override public void newFragment(Activity activity, int resId, FragmentManager fragmentManager, Bundle bundle, String tag) &#123; FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.add(resId,new LginHomeFragment(),tag); transaction.commit(); &#125;&#125;//component-ComponentServiceFactorypublic class ComponentServiceFactory &#123; private static volatile ComponentServiceFactory instance; private IFragmentService newsFragmentService; private IFragmentService homeFragmentService; private IFragmentService loginFragmentService; public static ComponentServiceFactory getInstance(Context context)&#123; if (instance == null)&#123; synchronized (ComponentServiceFactory.class)&#123; if (instance == null)&#123; instance = new ComponentServiceFactory(); &#125; &#125; &#125; return instance; &#125;........ //主册fragmentservice入口 public void setHomeFragmentService(IFragmentService iFragmentService)&#123; homeFragmentService = iFragmentService; &#125; public void setLoginFragmentService(IFragmentService iFragmentService)&#123; loginFragmentService = iFragmentService; &#125; public void setNewsFragmentService(IFragmentService iFragmentService)&#123; newsFragmentService = iFragmentService; &#125; public IFragmentService getNewsFragmentService() &#123; return newsFragmentService; &#125; public IFragmentService getHomeFragmentService() &#123; return homeFragmentService; &#125; public IFragmentService getLoginFragmentService() &#123; return loginFragmentService; &#125;&#125; 在home组件中进行fragmentservice的注册工作: //home-HomeApppublic class HomeApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); ComponentServiceFactory.getInstance(this).setHomeFragmentService(new HomeFragmentService()); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 在App中调用: // app-MainActivity:private void initBaseView() &#123; FragmentManager supportFragmentManager = getSupportFragmentManager(); ComponentServiceFactory.getInstance(this) .getHomeFragmentService().newFragment(this,R.id.content,supportFragmentManager,null,null); &#125; 这样一个home组件中的homeFragment就加载到主app的xml中同理组件之间的fragment引用亦如此注意框架中component-IFragmentService实现了两个方法: //获取目标的fragment来进行操作 Fragment getFragment(String tag); //用于固定的区域来填充相应fragment void newFragment(Activity activity, int resId, FragmentManager fragmentManager, Bundle bundle, String tag); getFragment(String tag);为获取目标fragment接口,获取到实例之后开发者自己实现fragment相关逻辑 newFragment(...);适用于在布局中静态添加fragment,一步到位 当然框架中还有部分限制组件资源的gradle配置,有兴趣可以在github下载demo]]></content>
      <categories>
        <category>Android</category>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Handler消息机制学习]]></title>
    <url>%2Fposts%2F7a63eeca.html</url>
    <content type="text"><![CDATA[1.概述 Handler允许你发送和处理Message，以及和线程相关联的Runnable对象。每一个Handler实例都与一个线程及该线程的MessageQueue相关联。既当你创建一个Handler时，该Handler必须绑定一个线程以及该线程的消息队列，一旦它被创建，它能把messages和runnables传送到message queue，并在它们从message queue中出来的时候执行它们。 Handler主要有两个主要用途： 在未来的某个时间点调度messages和runnables的执行 将要在不同线程上执行的操作加入队列 当你的应用程序被创建出来的时候，主线程会专门运行一个message queue来管理最顶级的应用对象(如activities, broadcast receivers，等等)以及它们创建的任何其它窗口。你可以创建你自己的线程，通过Handler来与主线程建立联系 2.源码分析2.1 MessageQueue-消息队列 MessageQueue是一个通过Looper分发它持有的消息列表的低层级类。Messages没有直接添加到MessageQueue中，而是通过与Looper相关联的Handler对象。 Message-消息 该类实现了Parcelable接口，你可以把它看作一个数据类 ** * * Defines a message containing a description and arbitrary data object that can be * sent to a &#123;@link Handler&#125;. This object contains two extra int fields and an * extra object field that allow you to not do allocations in many cases. * 定义包含描述和任意数据对象的消息 * 发送到Handler。这个对象包含两个额外的int字段和一个 * 额外的对象字段，允许您在很多情况下不进行分配。 * &lt;p class="note"&gt;While the constructor of Message is public, the best way to get * one of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the * &#123;@link Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull * them from a pool of recycled objects.&lt;/p&gt; * 注意：不要直接使用New Message()创建Message对象，最好的方式是通过Handler.obtainMessage() * 方法，它会从对象回收池中拉取该消息对象 */public final class Message implements Parcelable &#123; /** @hide */ public static final Object sPoolSync = new Object(); /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. * 从全局池返回一个新的消息实例。让我们在很多情况下避免分配新对象。 */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; ** * Same as &#123;@link #obtain()&#125;, but sets the value for the target member on the Message returned. * 与obtain()相同，但在返回的消息上设置目标成员的值。 * @return A Message object from the global pool. * 返回来自全局池的消息对象 */ public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h;//接收传递过来的Handler return m; &#125;&#125; 2.2 Looper-消息轮询器 Looper用于为线程轮询messages。线程默认是没有与之相关联的Lopper，我们必须通过Looper.prepare()方法去创建它。示例： class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; ThreadLocal提供线程的局部变量，通过它访问线程独立初始化变量的副本。即Looper通过ThreadLocal类来与当前线程进行交互 //私用构造方法//quitAllowed是否允许退出private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//实例化消息队列 mThread = Thread.currentThread();//获取当前线程&#125;/** Initialize the current thread as a looper.* This gives you a chance to create handlers that then reference* this looper, before actually starting the loop. Be sure to call* &#123;@link #loop()&#125; after calling this method, and end it by calling* &#123;@link #quit()&#125;.* 初始化当前线程的Looper* 在它准备轮询之前，给你一个时机点去创建一个Handler并引用它* 调用该方法后一定记得Looper.loop()方法，并结束的时候调用Looper.quit()方法退出*/public static void prepare() &#123; prepare(true);&#125;// sThreadLocal.get() will return null unless you have called prepare().//必须先调用Looper.prepare()方法，否则返回空static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) &#123; //每一个线程只能有唯一的一个looper if (sThreadLocal.get() != null) &#123;//不为空抛出异常 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//设置Looper&#125;/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. * 返回与当前线程关联的looper */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125;/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. * 在当前线程运行消息队友 */public static void loop() &#123; final Looper me = myLooper();//获取looper if (me == null) &#123;//为空则抛出异常 throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue;//获取looper的消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. //确保这个线程的标识是本地进程的标识， //并跟踪身份令牌的实际情况。 Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0); boolean slowDeliveryDetected = false; for (;;) &#123;//无限轮询 Message msg = queue.next(); // might block if (msg == null) &#123; //没有message则不往下执行 // No message indicates that the message queue is quitting. return; &#125; ***省略代码*** final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg);//调用Handler的dispatchMessage(msg)方法 dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; //回收可能正在使用的消息。 //在处理消息队列时，MessageQueue和Looper在内部使用。 msg.recycleUnchecked(); &#125;&#125;//sThreadLocal.get()public T get() &#123; Thread t = Thread.currentThread();//通过Thread的静态方法获取当前的线程 //ThreadLocalMap是一个定制的HashMap(),仅适用于维护线程局部值,每一个线程都持有一个ThreadLocalMap对象 ThreadLocalMap map = getMap(t);//传入当前线程获取当前线程的ThreadLocalMap对象-------------------------------------------------------------------------------————————————— ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;-------------------------------------------------------------------------------————————————— if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 2.3 Handler2.3.1 创建Handler对象/** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. * 如果你不想通过继承Handler来实现，你必须实现Callback接口 */public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ public boolean handleMessage(Message msg);&#125;//默认构成器//如果该Handler所绑定的线程没有looper，它将收不到任何messages，并且会抛出异常public Handler() &#123; this(null, false);&#125;//默认构造器的Callback为空，所以当我们通过new Handler()来创建实例时，//我们必须重写Handler的handleMessage(Message msg)方法，即：companion object &#123;//注意写成静态内部类的形式，避免内存泄漏 private class MyHandler :Handler()&#123; override fun handleMessage(msg: Message?) &#123; super.handleMessage(msg) &#125; &#125;&#125;-------------------------------------------------------------------------------—————————————//主动实现Callback接口，来创建Handler实例public Handler(Callback callback) &#123; this(callback, false);&#125; companion object &#123; private val mHandler1:Handler = Handler(object :Handler.Callback&#123; override fun handleMessage(msg: Message?): Boolean &#123; return true &#125; &#125;) 或 private val mHandler2:Handler = Handler(Handler.Callback &#123; true &#125;)&#125;-------------------------------------------------------------------------------————————————— /** * Use the provided &#123;@link Looper&#125; instead of the default one. * * @param looper The looper, must not be null. * //不使用默认的looper */public Handler(Looper looper) &#123; this(looper, null, false);&#125;//之前我看到某些前辈是通过下面这种方式来创建Handler实例，通过传递主线程的looper//但这是没必要的，Handler默认就是使用主线程的looper(下面会分析)//并且源码注释也说了，使用你自己的提供的looper而不是默认的private val mHandler:Handler = object :Handler(Looper.getMainLooper())&#123; override fun handleMessage(msg: Message?) &#123; super.handleMessage(msg) &#125;&#125;-------------------------------------------------------------------------------—————————————//该构造同上，如果你不想重写handleMessage(msg: Message?)方法，那么你就重写Callback接口public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;//是否需要异步处理messages，默认是异步的public Handler(boolean async) &#123; this(null, async);&#125;//自己提供looper，实现Callback接口，决定是否异步public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125;-------------------------------------------------------------------------------—————————————/* * Set this flag to true to detect anonymous, local or member classes * that extend this Handler class and that are not static. These kind * of classes can potentially create leaks. * 将此标志设置为true以检测匿名类、本地类或成员类 * 继承了Handler不是静态的，可能存在内存泄漏 */private static final boolean FIND_POTENTIAL_LEAKS = false;//通过Handler()、Handler(Callback callback)、Handler(boolean async)//都会调用该构造器public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123;//检查可能存在的内存泄漏，默认是false final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//获取looper if (mLooper == null) &#123;//如果为空抛出异常 throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//获取Looper中的消息队列 mCallback = callback; mAsynchronous = async;&#125;private static void handleCallback(Message message) &#123; message.callback.run();//执行Message持有的Runnable&#125;/** * Handle system messages here. * 处理系统Messages */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123;//如果Message的Runnable不为空 handleCallback(msg);调用Handler的handleMessage(msg)方法处理Message &#125; else &#123; if (mCallback != null) &#123;//如果Handler的Callback不为空 if (mCallback.handleMessage(msg)) &#123;//调用Callback的handleMessage(msg)方法 return; &#125; &#125; //否则调用Handler的handleMessage(msg)方法 handleMessage(msg); &#125;&#125; 2.3.2 创建Message对象public final Message obtainMessage()&#123; return Message.obtain(this);&#125;public final Message obtainMessage(int what)&#123; return Message.obtain(this, what);&#125;public final Message obtainMessage(int what, Object obj)&#123; return Message.obtain(this, what, obj);&#125;public final Message obtainMessage(int what, int arg1, int arg2)&#123; return Message.obtain(this, what, arg1, arg2);&#125;public final Message obtainMessage(int what, int arg1, int arg2, Object obj)&#123; return Message.obtain(this, what, arg1, arg2, obj);&#125; 2.3.3 发送Message/** * Causes the Runnable r to be added to the message queue. * The runnable will be run on the thread to which this handler is * attached. * 将Runnable添加到消息队列中。 * runnable将在此Handler所在的线程上运行。 * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. * Runnable成功添加到消息队列中返回ture，失败返回false */public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain();创建Message对象 m.callback = r;把Runnale传递给Message return m;&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123;//延迟时间小于0，则置为0 delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;//延迟发送public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postDelayed(Runnable r, Object token, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r, token), delayMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this;//把当前的Handler传递给Message的Handler if (mAsynchronous) &#123;//是否异步 msg.setAsynchronous(true); &#125; //最终调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis);&#125;MessageQueue：boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123;//Message的Handler为空，抛出异常 throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123;//Message正在使用，抛出异常 throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123;//判断是否退出 IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle();//回收Message return false; &#125; msg.markInUse();设置Message是否正在使用的Flag msg.when = when; Message p = mMessages; boolean needWake;//是否需要唤醒 if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. //插入到队列的中间。通常我们不需要唤醒 //启动消息队列，除非队列头部有阻碍 //消息是队列中最早的异步消息。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123;//开启无限轮询 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 3.总结]]></content>
      <categories>
        <category>Android</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARouter路由框架]]></title>
    <url>%2Fposts%2Fa9949862.html</url>
    <content type="text"><![CDATA[一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦 Demo展示Demo apk下载、Demo Gif一、什么是路由说简单点就是映射页面跳转关系的，当然它也包含跳转相关的一切功能。 二、为什么需要路由Android系统已经给我们提供了api来做页面跳转，比如startActivity，为什么还需要路由框架呢？我们来简单分析下路由框架存在的意义： 在一些复杂的业务场景下（比如电商），灵活性比较强，很多功能都是运营人员动态配置的，比如下发一个活动页面，我们事先并不知道具体的目标页面，但如果事先做了约定，提前做好页面映射，便可以自由配置。 随着业务量的增长，客户端必然随之膨胀，开发人员的工作量越来越大，比如64K问题，比如协作开发问题。App一般都会走向组件化、插件化的道路，而组件化、插件化的前提就是解耦，那么我们首先要做的就是解耦页面之间的依赖关系。 简化代码。数行跳转代码精简成一行代码。 其他… 三、为什么需要路由ARouter是阿里巴巴开源的Android平台中对页面、服务提供路由功能的中间件，提倡的是简单且够用。GitHub：https://github.com/alibaba/ARouter 四、功能介绍 支持直接解析标准URL进行跳转，并自动注入参数到目标页面中 支持多模块工程使用 支持添加多个拦截器，自定义拦截顺序 支持依赖注入，可单独作为依赖注入框架使用 支持InstantRun 支持MultiDex(Google方案) 映射关系按组分类、多级管理，按需初始化 支持用户指定全局降级与局部降级策略 页面、拦截器、服务等组件均自动注册到框架 支持多种方式配置转场动画 支持获取Fragment 完全支持Kotlin以及混编(配置见文末 其他) 支持第三方 App 加固(使用 arouter-register 实现自动注册) 支持生成路由文档 五、典型应用 从外部URL映射到内部页面，以及参数传递与解析 跨模块页面跳转，模块间解耦 拦截跳转过程，处理登陆、埋点等逻辑 跨模块API调用，通过控制反转来做组件解耦 六、基础功能 添加依赖和配置 android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName()] &#125; &#125; &#125;&#125;dependencies &#123; // 替换成最新版本, 需要注意的是api // 要与compiler匹配使用，均使用最新版可以保证兼容 compile &apos;com.alibaba:arouter-api:x.x.x&apos; annotationProcessor &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125;// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末&apos;其他#4&apos;// Kotlin配置参考文末&apos;其他#5&apos; 添加注解 // 在支持路由的页面上添加注解(必选)// 这里的路径需要注意的是至少需要有两级，/xx/xx@Route(path = "/test/activity")public class YourActivity extend Activity &#123; ...&#125; 初始化SDK if (isDebug()) &#123; // 这两行必须写在init之前，否则这些配置在init过程中将无效 ARouter.openLog(); // 打印日志 ARouter.openDebug(); // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)&#125;ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化 发起路由操作 // 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)ARouter.getInstance().build("/test/activity").navigation();// 2. 跳转并携带参数ARouter.getInstance().build("/test/1") .withLong("key1", 666L) .withString("key3", "888") .withObject("key4", new Test("Jack", "Rose")) .navigation(); 添加混淆规则(如果使用了Proguard) -keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;-keep public class com.alibaba.android.arouter.facade.**&#123;*;&#125;-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125;# 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider# 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现# -keep class * implements com.alibaba.android.arouter.facade.template.IProvider 使用 Gradle 插件实现路由表的自动加载 apply plugin: &apos;com.alibaba.arouter&apos;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &quot;com.alibaba:arouter-register:?&quot; &#125;&#125; 可选使用，通过 ARouter 提供的注册插件进行路由表的自动加载(power by AutoRegister)， 默认通过扫描 dex 的方式进行加载通过 gradle 插件进行自动注册可以缩短初始化时间解决应用加固导致无法直接访问dex 文件，初始化失败的问题，需要注意的是，该插件必须搭配 api 1.3.0 以上版本使用！ 七、进阶用法 通过URL跳转// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可public class SchameFilterActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); ARouter.getInstance().build(uri).navigation(); finish(); &#125;&#125; AndroidManifest.xml&lt;activity android:name=".activity.SchameFilterActivity"&gt; &lt;!-- Schame --&gt; &lt;intent-filter&gt; &lt;data android:host="m.aliyun.com" android:scheme="arouter"/&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.BROWSABLE"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 解析URL中的参数 // 为每一个参数声明一个字段，并使用 @Autowired 标注// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象@Route(path = "/test/activity")public class Test1Activity extends Activity &#123; @Autowired public String name; @Autowired int age; @Autowired(name = "girl") // 通过name来映射URL中的不同参数 boolean boy; @Autowired TestObj obj; // 支持解析自定义对象，URL中使用json传递 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); // ARouter会自动对字段进行赋值，无需主动获取 Log.d("param", name + age + boy); &#125;&#125;// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：@Route(path = "/yourservicegroupname/json")public class JsonServiceImpl implements SerializationService &#123; @Override public void init(Context context) &#123; &#125; @Override public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123; return JSON.parseObject(text, clazz); &#125; @Override public String object2Json(Object instance) &#123; return JSON.toJSONString(instance); &#125;&#125; 声明拦截器(拦截跳转过程，面向切面编程) // 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行@Interceptor(priority = 8, name = "测试用拦截器")public class TestInterceptor implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; ... callback.onContinue(postcard); // 处理完成，交还控制权 // callback.onInterrupt(new RuntimeException("我觉得有点异常")); // 觉得有问题，中断路由流程 // 以上两种至少需要调用其中一种，否则不会继续路由 &#125; @Override public void init(Context context) &#123; // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次 &#125;&#125; 处理跳转结果 // 使用两个参数的navigation方法，可以获取单次跳转的结果ARouter.getInstance().build("/test/1").navigation(this, new NavigationCallback() &#123; @Override public void onFound(Postcard postcard) &#123; ... &#125; @Override public void onLost(Postcard postcard) &#123; ... &#125;&#125;); 自定义全局降级策略 // 实现DegradeService接口，并加上一个Path内容任意的注解即可@Route(path = "/xxx/xxx")public class DegradeServiceImpl implements DegradeService &#123; @Override public void onLost(Context context, Postcard postcard) &#123; // do something. &#125; @Override public void init(Context context) &#123; &#125;&#125; 为目标页面声明更多信息 // 我们经常需要在目标页面中配置一些属性，比方说"是否需要登陆"之类的// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断@Route(path = "/test/activity", extras = Consts.XXXX) 通过依赖注入解耦:服务管理(一) 暴露服务 // 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; String sayHello(String name);&#125;// 实现接口@Route(path = "/yourservicegroupname/hello", name = "测试服务")public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return "hello, " + name; &#125; @Override public void init(Context context) &#123; &#125;&#125; 通过依赖注入解耦:服务管理(二) 发现服务 public class Test &#123; @Autowired HelloService helloService; @Autowired(name = "/yourservicegroupname/hello") HelloService helloService2; HelloService helloService3; HelloService helloService4; public Test() &#123; ARouter.getInstance().inject(this); &#125; public void testService() &#123; // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务) helloService.sayHello("Vergil"); helloService2.sayHello("Vergil"); // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType helloService3 = ARouter.getInstance().navigation(HelloService.class); helloService4 = (HelloService) ARouter.getInstance().build("/yourservicegroupname/hello").navigation(); helloService3.sayHello("Vergil"); helloService4.sayHello("Vergil"); &#125;&#125; 八、更多功能 初始化中的其他设置 ARouter.openLog(); // 开启日志ARouter.openDebug(); // 使用InstantRun的时候，需要打开该开关，上线之后关闭，否则有安全风险ARouter.printStackTrace(); // 打印日志的时候打印线程堆栈 详细的API说明 // 构建标准的路由请求ARouter.getInstance().build("/home/main").navigation();// 构建标准的路由请求，并指定分组ARouter.getInstance().build("/home/main", "ap").navigation();// 构建标准的路由请求，通过Uri直接解析Uri uri;ARouter.getInstance().build(uri).navigation();// 构建标准的路由请求，startActivityForResult// navigation的第一个参数必须是Activity，第二个参数则是RequestCodeARouter.getInstance().build("/home/main", "ap").navigation(this, 5);// 直接传递BundleBundle params = new Bundle();ARouter.getInstance() .build("/home/main") .with(params) .navigation();// 指定FlagARouter.getInstance() .build("/home/main") .withFlags(); .navigation();// 获取FragmentFragment fragment = (Fragment) ARouter.getInstance().build("/test/fragment").navigation(); // 对象传递ARouter.getInstance() .withObject("key", new TestObj("Jack", "Rose")) .navigation();// 觉得接口不够多，可以直接拿出Bundle赋值ARouter.getInstance() .build("/home/main") .getExtra();// 转场动画(常规方式)ARouter.getInstance() .build("/test/activity2") .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom) .navigation(this);// 转场动画(API16+)ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);// ps. makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前ActivityARouter.getInstance() .build("/test/activity2") .withOptionsCompat(compat) .navigation(); // 使用绿色通道(跳过所有的拦截器)ARouter.getInstance().build("/home/main").greenChannel().navigation();// 使用自己的日志工具打印日志ARouter.setLogger();// 使用自己提供的线程池ARouter.setExecutor(); 获取原始的URI String uriStr = getIntent().getStringExtra(ARouter.RAW_URI); 重写跳转URL // 实现PathReplaceService接口，并加上一个Path内容任意的注解即可@Route(path = "/xxx/xxx") // 必须标明注解public class PathReplaceServiceImpl implements PathReplaceService &#123; /** * For normal path. * * @param path raw path */ String forString(String path) &#123; return path; // 按照一定的规则处理之后返回处理后的结果 &#125; /** * For uri type. * * @param uri raw uri */ Uri forUri(Uri uri) &#123; return url; // 按照一定的规则处理之后返回处理后的结果 &#125;&#125; 生成路由文档 // 更新 build.gradle, 添加参数 AROUTER_GENERATE_DOC = enable// 生成的文档路径 : build/generated/source/apt/(debug or release)/com/alibaba/android/arouter/docs/arouter-map-of-$&#123;moduleName&#125;.jsonandroid &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: &quot;enable&quot;] &#125; &#125; &#125;&#125; 九、其他 路由中的分组概念 SDK中针对所有的路径(/test/1 /test/2)进行分组，分组只有在分组中的某一个路径第一次被访问的时候，该分组才会被初始化 可以通过 @Route 注解主动指定分组，否则使用路径中第一段字符串(/*/)作为分组 注意：一旦主动指定分组之后，应用内路由需要使用 ARouter.getInstance().build(path, group) 进行跳转，手动指定分组，否则无法找到@Route(path = "/test/1", group = "app") 拦截器和服务的异同 拦截器和服务所需要实现的接口不同，但是结构类似，都存在 init(Context context) 方法，但是两者的调用时机不同 拦截器因为其特殊性，会被任何一次路由所触发，拦截器会在ARouter初始化的时候异步初始化，如果第一次路由的时候拦截器还没有初始化结束，路由会等待，直到初始化完成。 服务没有该限制，某一服务可能在App整个生命周期中都不会用到，所以服务只有被调用的时候才会触发初始化操作 旧版本gradle插件的配置方式 apply plugin: &apos;com.neenbedankt.android-apt&apos;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos; &#125;&#125;apt &#123; arguments &#123; AROUTER_MODULE_NAME project.getName(); &#125;&#125;dependencies &#123; compile &apos;com.alibaba:arouter-api:x.x.x&apos; apt &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125; Kotlin项目中的配置方式 // 可以参考 module-kotlin 模块中的写法apply plugin: &apos;kotlin-kapt&apos;kapt &#123; arguments &#123; arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName()) &#125;&#125;dependencies &#123; compile &apos;com.alibaba:arouter-api:x.x.x&apos; kapt &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125; 十、Q&amp;A “W/ARouter::: ARouter::No postcard![ ]” 这个Log正常的情况下也会打印出来，如果您的代码中没有实现DegradeService和PathReplaceService的话，因为ARouter本身的一些功能也依赖 自己提供的Service管理功能，ARouter在跳转的时候会尝试寻找用户实现的PathReplaceService，用于对路径进行重写(可选功能)，所以如果您没有 实现这个服务的话，也会抛出这个日志 推荐在app中实现DegradeService、PathReplaceService “W/ARouter::: ARouter::There is no route match the path [/xxx/xxx], in group [xxx][ ]” 通常来说这种情况是没有找到目标页面，目标不存在 如果这个页面是存在的，那么您可以按照下面的步骤进行排查 检查目标页面的注解是否配置正确，正确的注解形式应该是 (@Route(path=”/test/test”), 如没有特殊需求，请勿指定group字段，废弃功能) 检查目标页面所在的模块的gradle脚本中是否依赖了 arouter-compiler sdk (需要注意的是，要使用apt依赖，而不是compile关键字依赖) 检查编译打包日志，是否出现了形如 ARouter:Compiler &gt;&gt;&gt; xxxxx 的日志，日志中会打印出发现的路由目标 启动App的时候，开启debug、log(openDebug/openLog), 查看映射表是否已经被扫描出来，形如 D/ARouter::: LogisticsCenter has already been loaded, GroupIndex[4]，GroupIndex &gt; 0 开启InstantRun之后无法跳转(高版本Gradle插件下无法跳转)？​ 因为开启InstantRun之后，很多类文件不会放在原本的dex中，需要单独去加载，ARouter默认不会去加载这些文件，因为安全原因，只有在开启了openDebug之后 ARouter才回去加载InstantRun产生的文件，所以在以上的情况下，需要在init之前调用openDebug TransformException:java.util.zip.ZipException: duplicate entry …. ARouter有按组加载的机制，关于分组可以参考 6-1 部分，ARouter允许一个module中存在多个分组，但是不允许多个module中存在相同的分组，会导致映射文件冲突 Kotlin类中的字段无法注入如何解决？ 首先，Kotlin中的字段是可以自动注入的，但是注入代码为了减少反射，使用的字段赋值的方式来注入的，Kotlin默认会生成set/get方法，并把属性设置为private 所以只要保证Kotlin中字段可见性不是private即可，简单解决可以在字段上添加 @JvmField 通过URL跳转之后，在intent中拿不到参数如何解决？ 需要注意的是，如果不使用自动注入，那么可以不写 ARouter.getInstance().inject(this)，但是需要取值的字段仍然需要标上 @Autowired 注解，因为 只有标上注解之后，ARouter才能知道以哪一种数据类型提取URL中的参数并放入Intent中，这样您才能在intent中获取到对应的参数 新增页面之后，无法跳转？ ARouter加载Dex中的映射文件会有一定耗时，所以ARouter会缓存映射文件，直到新版本升级(版本号或者versionCode变化)，而如果是开发版本(ARouter.openDebug())， ARouter 每次启动都会重新加载映射文件，开发阶段一定要打开 Debug 功能]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node升级的正确方法]]></title>
    <url>%2Fposts%2Fc2ade9d5.html</url>
    <content type="text"><![CDATA[安装方法:1.查看node版本，没安装的请先安装； $ brew install node $ node -vn 2.清楚node缓存；$ sudo npm cache clean -f 3.安装node版本管理工具’n’;$ sudo npm install n -g 4.使用版本管理工具安装指定node或者升级到最新node版本；$ sudo n stable （安装node最新版本）$ sudo n 8.9.4 （安装node指定版本8.9.4） 5.使用node -v查看node版本，如果版本号改变为你想要的则升级成功。若版本号未改变则还需配置node环境变量1.查看通过n安装的node的位置；$ which node (如：/usr/local/n/versions/node/6.12.3） 2.cd进入/usr/local/n/versions/node/ 你应该能看到你刚通过n安装的node版本这里如：8.9.4；编辑/etc/profile;$ vim /etc/profile 3.将node安装的路径（这里为：/usr/local/n/versions/node/8.9.4）添加到文件末尾；set node pathexport NODE_HOME=/usr/local/n/versions/node/8.9.4export PATH=$NODE_HOME/bin:$PATH 4.wq退出保存文件，编译/etc/profile;$ source /etc/profile 5.再次使用node -v查看node版本，不出意外版本号应该变为你想要的。]]></content>
      <categories>
        <category>前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式的优点与缺点概况]]></title>
    <url>%2Fposts%2Fb5467332.html</url>
    <content type="text"><![CDATA[设计模式标签（空格分隔）： 设计模式优点 应用场景 单例模式优点： 只有一个实例，减少了内存开支； 可以避免对系统资源的多重占用； 可以在系统中设置全局的访问点，优化和共享资源访问； 缺点： 没有接口，扩展困难； 对测试开发不利； 应用场景： 要求生成唯一序列号的场景； 需要一个共享访问点； 创建一个对象需要消耗过多的资源时 需要定义大量的静态常量和静态方法时（也可直接声明为static的方式）； 工厂方法模式优点： 良好的封装性，代码结构清晰； 扩展非常好； 屏蔽产品类； 应用场景： 是new一个对象的替代品； 需要灵活的，可扩展的框架时； 使用在测试驱动开发的框架下； 抽象工厂模式优点： 封装性； 产品族内部的约束为非公开状态； 缺点： 产品族扩展困难； 模板方法模式优点： 封装不变部分，扩展可变部分，把不变的算法封装到父类实现，可变的部分则通过继承来扩展； 提取公共部分代码，便于维护； 行为由父类控制，子类实现; 缺点： 子类对父类产生影响，子类执行的结果影响了父类的结果; 应用场景： 多个子类有公有的方法，且逻辑相同时； 重要，复杂的算法，可以把核心算法设计为模板方法； 重构时，把相同的代码抽取到父类，然后通过钩子函数结束其行为； 建造者模式优点： 封装性，使得客户端不必知道产品内部的组成细节，我们不用关心每一个具体的模型内部是如何实现的。 建造者独立，容易扩展 便于控制细节风险，由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响; 建造者模式的应用场景： 相同的方法，不同的执行顺序，会产生不同的结果时； 多个部件或零件，都可以装配到一个对象中，但产生的运行结果又不相同时，如Android中的AlertDialog的构造; 产品类非常复杂，或产品类的的调用顺序不同产生不同的效果； 代理模式优点： 职责清晰，其实的角色就是实现实际的业务的逻辑，不用关心其他非本职责的事务； 高扩展性，具体主题角色随时都会发生变化，但只要它实现了接口，我们的代理类就可以在完全不做任何修改的情况下使用； 原型模式（通过实现Cloneable接口）优点： 性能优良，原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好，特别是要在循环体内产生大量对象时， 避免构造函数的约束，直接是在内存中拷贝的，构造函数是不会执行的。 应用场景： 类初始化需要消化非常多的资源时 性能和安全要求的场景，通过 new产生一个对象需要非常繁琐的数据准备和访问权限时； 一个对象多个修改者的场景，一个对象需要提供给多个对象访问，而且各个调用者都可以修改其值时； 注意地方：浅拷贝与深拷贝Java的Object类提供的clone方法只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，其他的原始类型如int,char等都会被拷贝，拷贝后的对象与原生对象共享内部元素的地址（浅拷贝），如果拷贝后的对象修改了原生对象的数组，则原生对象也会看到修改。如果需要进行深拷贝，则需要在复写的clone方法里对私有的类变量（内部数组，引用对象）进行独立的拷贝。并且使用final关键字修饰的变量不能被拷贝； 中介者模式优点： 减少了类间的依赖，把原有的一对多的依赖变成了一对一的依赖； 缺点： 中介者会膨胀得很大，而且逻辑复杂；原本N个对象的依赖关系转换为中介者与对象的依赖关系； 命令模式优点： 类间解耦，调用者与接收者之间没有任何依赖关系，调用者实现功能时不需要了解到底是哪个接收者执行，只需调用Command抽象类的execute方法就可以了； 可扩展性，Command的子类可以非常容易扩展，并且调用者和高层模块不产生严重的代码耦合； 缺点： Command类膨胀厉害，如果有N个命令，则Command类的子类就为N个； 应用场景：如Android中各种事件的处理； 责任链模式优点： 请求与处理分开，请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌； 缺点： 性能问题，每个请求都是从链头遍历到链尾的，当这个责任链比较长时，遍历开销会比较大； 应用场景: 如Android事件的传递机制； 装饰器模式优点： 装饰类和被装饰类可以独立发展，而不会互相耦合； 装饰模式是继承关系的一个替代方案，不管装饰多少层，最终返回的也还是那个对象； 装饰模式可以动态地扩展一个实现类的功能； 缺点： 多层的装饰比较复杂，当使用多层装饰出现问题时，排查问题的工作量比较大 应用场景： 需要扩展一个类的功能，或给一个类增加附加功能； 需要为一批兄弟类进行改装或加装功能； 策略模式优点： 算法可以自由切换，只要实现抽象策略，它就成为策略家庭的一个成员； 避免使用多重条件判断， 扩展性良好，在现有的系统中增加一个策略太容易，只要实现接口就可以了; 缺点： 策略类数量多，每一个策略都是一个类，复用的可能性很小； 所有的策略类都需要对外暴露，上层模块必须知道有哪些策略，然后决定使用哪一个策略； 应用场景： 多个类只有在算法或行为上稍有不同的场景； 算法需要自由切换的场景； 需要屏蔽算法规则的场景； 适配器模式优点： 让两个没有任何联系的类在一起运行； 增加了类的透明性； 提高了类的复用度； 灵活性好，当不需要适配器时，只要删掉这个适配器就可以了， 应用场景： 修改一个已经投产的接口时， Android中各种Adapter， 迭代器模式 迭代器模式是为解决遍历容器中的元素而诞生的，没有人会单独写一个迭代器，使用Java提供的Itreator就可以满足要求了； 组合模式优点： 高层模块调用简单，高层模块不需要关心自己处理的是单个对象还是整个组合结构， 节点可以自由增加； 缺点： 调用时会直接使用实现类，不符合面向接口编程思想； 应用场景： 维护和展示部分-整体关系的场景，如树型菜单，文件和文件夹的管理； 只要是树型结构，就要考虑使用组合模式； 观察者模式优点： 观察者与被观察者之间是抽象耦合，不管是增加观察者还是被观察者都非常容易扩展； 建立一套触发机制； 缺点： 一个被观察者，多个观察者，开发与调度会比较复杂，在Java中消息的通知默认是顺序执行，其中一个观察者卡壳，会影响整体的执行效率，一般要考虑采用异步的方式； 应用场景： 关联行为场景，如Android中数据变化会引起UI的变化； 事件多级触发场景； 跨系统的消息交换场景； 门面模式优点： 减少系统的相互依赖，所有的依赖都是与门面对象的依赖，与子系统无关。 提高了灵活性； 提高了安全性，想让你访问子系统的哪些业务就开通哪些逻辑； 缺点： 不符合开闭原则，当出现bug后，只能通过修改门面角色的代码来修复； 应用场景： 为一个复杂的模块或子系统提供一个供外界访问的接口，如Android的Context类只是一个抽象类，所有的功能都是在ContextImpl类实现的，我们不会察觉到ContextImpl的存在，只需要调用Context就可以了； 子系统相对独立，外界对子系统的访问只要黑箱操作即可； 预防低水平开发人员带来的风险，被限定在指定的子系统开发； 备忘录模式应用场景： 需要保存和恢复数据的相关状态场景； 提供一个可回滚的操作场景； 需要监控的副本场景中； 数据库连接的事务管理就是用的备忘录模式； 注意事项： 备忘录的生命期，要主动管理它的生命周期，建立就要使用，不使用就删除； 备忘录的性能，不要在频繁建立备份的场景中使用备忘录模式；（对象的创建是需要消耗资源的） 访问者模式优点： 符合单一职责原则，具体元素角色负责数据的加载，而访问者类则负责数据的呈现； 优秀的扩展性， 灵活性非常高； 缺点： 具体元素对访问者公布细节，访问者要访问一个类就必须要求这个类公布一些方法和数据； 具体元素变更比较困难；具体元素角色的增加、删除、修改都是比较困难； 违背了依赖倒置原则，访问者依赖的是具体的元素，而不是抽象的元素； 应用场景 ： 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作； 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作”污染“这些对象的类； 业务规则要求遍历多个不同的对象； 状态模式优点： 结构清晰，避免了过多的switch...case或if...else语句的使用； 遵循设计原则，每个状态就是一个子类； 封装性非常好，将状态变换放置到类的内部来实现； 缺点： 子类会太多，也就是类膨胀，有多少个状态，就会有多少个子类； 应用场景： 行为随状态改变而改变的场景，如权限设计； 条件、分支判断语句的替代者，通过扩展子类实现条件的判断处理； 状态的个数最好不要超过5个； 解释器模式（现在使用较少）优点： 扩展性好， 缺点： 解释器模式会引起类膨胀； 采用了递归调用方法； 享元模式优点： 大大减少应用程序创建的对象，降低程序内存的占用; 缺点： 提高了系统复杂性，需要分离出内部和外部状态； 应用场景： 系统中存在大量的相似对象； 需要缓冲池的场景； 细粒度的对象都具有较接近的外部状态；且内部状态与环境无关 桥梁模式优点： 抽象与实现分离； 优秀的扩充能力； 实现细节对客户透明； 应用场景： 不希望或不适用继承的场景； 接口或抽象类不稳定的情况； 重要性要求较高的场景；]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之23种常用模式]]></title>
    <url>%2Fposts%2F8af7915a.html</url>
    <content type="text"><![CDATA[在常用的23种设计模式中，根据设计模式的功能，我们又可以把这23个设计模式分为三大类：创建类模式，结构类模式，行为类模式； 创建类模式 工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一类，使一个类的实例化 延迟到其子类； 建造者模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示； 抽象工厂模式，为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。 单例模式，确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例； 原型模式，通过对象复制来实现的模式就叫做原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 结构类模式 适配器模式,将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作； 桥梁模式，将抽象与实现解耦，使得两者可以独立地变化； 组合模式，将对象组合成树形结构以表示“部分-整体”的场次结构，使得用户对单个对象和组合对象的使用具有一致性。 装饰模式，动态地给一个对象添加一些额外的职责。就增加功能来说 ，装饰模式相比生成子类更为灵活； 门面模式，要求一个子系统的外部与其内部通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 享元模式，是池技术的重要实现方式，使得共享对象可有效地支持大量的细粒度的对象。 代理模式，为其他对象提供一种代理以控制对这个对象的访问。 行为类模式 责任链模式，使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止； 命令模式，这是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能； 解释器模式，是一种按照规定语法进行解析的方案；定义为：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示业解释语言中的句子。 迭代器模式，，它提供一种方法访问一个容器对象中各个对象，而又不需暴露该对象的内部细节。（目前已经没落）； 中介者模式，用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 备忘录模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态。通俗地讲，备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法； 观察者模式，也叫做发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 状态模式，状态模式的核心是封装，状态的变更引起了行为的变更。当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。 策略模式，定义一组算法，将每个算法封装起来，并且使它们之间可以互换； 模板方法模式，定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些框架； 访问者模式，封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之6大设计原则]]></title>
    <url>%2Fposts%2Ffbde7e42.html</url>
    <content type="text"><![CDATA[单一职责原则单一职责的定义为：应该有且仅有一个可以引起类的变更，也就是一个职责一个接口（业务逻辑的划分）；好处： 类的复杂性降低； 可读性提高； 可维护性提高； 变更引起的风险降低；一个接口修改只对相应的实现类有影响，对其他接口没有影响 里氏替换原则通俗地说，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常；但反过来就不行，有子类出现的地方，父类未必就能适应；（因此在类中调用其他类时，就务必使用父类或接口，如果不能这样做，则说明类的设计已经违背了LSP原则了） 如果子类不能完整地实现实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖，聚集，组合等关系代替继承； 方法中的输入参数称为前置条件，并且子类中的方法的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松；（父类出现的地方，子类就可以出现） 依赖倒置原则最直接的理解就是：面向接口编程，抽象定义： 高层模块不应该依赖于低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象； 在Java语言中的表现为： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的； 接口或抽象类不依赖于实现类； 实现类依赖接口或抽象类； 接口隔离原则接口的种类： 实例接口，如我们在Java中声明一个类，然后用new 关键字来产生一个实例，它是对一个类型的事物的供述，这是一个接口； 类接口，在Java中使用关键字interface定义的接口； 定义：说白了就是接口尽量细化，同时接口中的方法尽量少 迪米特法则也叫最少知识原则，简单说应该对其他对象有最少的了解，也就是说一个类应该对自己需要耦合或调用的类知道得最少；也就是类间解耦，弱耦合 开闭原则定义：软件实体应该对扩展开放，对修改关闭，也就是说软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化；如何应用到实际编程中？： 抽象约束，也就是通过接口或抽象类约束实现扩展，对扩展进行边界的限定，不允许出现在接口或抽象类中不存在的public 方法；并且参数的类型、引用对象尽量使用接口或者抽象类，最后就是抽象层尽量保持稳定，一旦确定就不允许修改； 元数据控制模块行为，也就是说用元数据来控制程序的行为，减少重复开发。元数据就是用来描述环境和数据的数据，也就是我们常说的配置参数； 制定项目章程，让团队的所有成员都遵守约定； 封装变化，将相同的变化封装到一个接口或抽象类中，不同的变化封装到不同的接口或变化；]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom_For_ReactNative]]></title>
    <url>%2Fposts%2F321ed7e5.html</url>
    <content type="text"><![CDATA[Atom下载链接https://atom.io/ Atom插件https://atom.io/packages常用插件：​ 浏览器浏览功能 open-in-browser (可以设置快捷键)​ 分页展示html页面效果 atom-html-preview (可以设置快捷键)​ 文件路径补全 autocomplete-path​ React官网https://facebook.github.io/react/]]></content>
      <categories>
        <category>Android</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ReactNative</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局弹框GlobalDialog]]></title>
    <url>%2Fposts%2F5bbd3c9c.html</url>
    <content type="text"><![CDATA[Demo地址：GlobalDialogDemo 全局弹框，比如异地登录提示。思路就是通过非 Activity 的 Context 来启动一个透明 activity， 然后使用这个 activity 来显示一个 dialog。 AndroidManifest.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.whohelp.globaldialogdemo"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".GlobalDialogActivity" android:theme="@style/Transparent" /&gt; &lt;/application&gt;&lt;/manifest&gt; styles.xml&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="Transparent" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowAnimationStyle"&gt;@android:style/Animation&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void showDialog(View view) &#123; GlobalDialogActivity.start(this.getApplicationContext()); &#125;&#125; GlobalDialogActivitypublic class GlobalDialogActivity extends AppCompatActivity &#123; public static void start(Context context) &#123; Intent starter = new Intent(context, GlobalDialogActivity.class); //设置启动方式 starter.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(starter); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_global_dialog); //显示dialog new AlertDialog.Builder(this) .setTitle("全局dialog") .setMessage("这是一个全局dialog") .setNegativeButton("取消", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setCancelable(false) .show(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>GlobalDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用库和插件]]></title>
    <url>%2Fposts%2Fbb30f1ae.html</url>
    <content type="text"><![CDATA[下拉刷新PullLoadMoreRecyclerView 实现RecyclerView下拉刷新和上拉加载更多以及RecyclerView线性、网格、瀑布流效果演示 https://github.com/WuXiaolong/PullLoadMoreRecyclerView start 1247 android-Ultra-Pull-To-Refresh 这是现在已经停止维护的下拉刷新项目的替代方案。继承于ViewGroup可以包含任何View。功能比SwipeRefreshLayout强大。使用起来非常简单。良好的设计，如果你想定制自己的UI样式，非常简单，就像给ListView加一个Header View那么简单。 https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh start 9322 SmartRefreshLayout 下拉刷新、上拉加载、二级刷新、淘宝二楼、RefreshLayout、OverScroll，Android智能下拉刷新框架，支持越界回弹、越界拖动，具有极强的扩展性，集成了几十种炫酷的Header和 Footer。 https://github.com/scwang90/SmartRefreshLayout start 14453 一个实用的多条件筛选菜单DropDownMenu 一个实用的多条件筛选菜单，在很多App上都能看到这个效果，如美团，爱奇艺电影票等 https://github.com/dongjunkun/DropDownMenu start 2997 强大易用的安卓工具类库AndroidUtilCode 是一个强大易用的安卓工具类库，它合理地封装了安卓开发中常用的函数，具有完善的 Demo 和单元测试，利用其封装好的 APIs 可以大大提高开发效率，如今它主要包括两部分模块，其一是主工具类模块：utilcode，其中的工具类是开发中常用到的；其二是子工具类模块：subutil，它包含的工具类并不是很常用，它的出现是为了防止主工具类的臃肿。 https://github.com/Blankj/AndroidUtilCode start 20125 SuperUtils 囊括了一大部分Android应用开发过程当中常用的工具类。工具类来源整理自网络和自己编写。 https://github.com/AllenCoder/SuperUtils start 310 Android第三方相册选择器Matisse 知乎开源相册 https://github.com/hamuamu0/Matisse start 7881 ImagePicker 完全仿微信的图片选择 https://github.com/jeasonlzy/ImagePicker start 3262 PictureSelector 一款针对android平台下的图片选择器，支持从相册或拍照选择图片或视频、音频，支持动态权限获取、裁剪(单图or多图裁剪)、压缩、主题自定义配置等功能、适配android 6.0+系统的开源图片选择框架。 https://github.com/LuckSiege/PictureSelector start 4762 ImagePicker 一款功能超强的图片选择器。支持超大图预览(比如10000*5000的图)，支持图片裁剪，可配置头像模式和普通模式，支持动态配置ImageLoader以支持多种图片加载库，以及实现流畅的跳转动画 https://github.com/martin90s/ImagePicker start 832 TakePhoto 一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 https://github.com/crazycodeboy/TakePhoto start 5553 Album https://github.com/yanzhenjie/Album start 1802 可用于动态生成验证码，常见于金融类appVerificationCodeView https://github.com/Freshman111/VerificationCodeView start 354 类似于微信侧滑返回上一级Activity的工具SwipeBackHelper https://github.com/Jude95/SwipeBackHelper/blob/master/README_ch.md start 1266 SwipeBackLayout https://github.com/ikew0ng/SwipeBackLayout start 5352 Banner轮播ViewPagerandroid-auto-scroll-view-pager https://github.com/Trinea/android-auto-scroll-view-pager start 1603 UltraViewPager UltraViewPager是一个封装多种特性的ViewPager，主要是为多页面切换场景提供统一解决方案。支持横划竖划；支持一屏内显示多页；支持循环滚动；支持定时滚动，计时器使用Handler实现 https://github.com/alibaba/UltraViewPager start 3942 ViewPagerIndicator Indicator 取代 tabhost，实现网易顶部tab，新浪微博主页底部tab，引导页，无限轮播banner等效果，高度自定义tab和特效 https://github.com/LuckyJayce/ViewPagerIndicator start 2166 RecyclerViewPager 扩形式的recyclerView，配合ViewPager实现各种效果 https://github.com/lsjwzh/RecyclerViewPager start 3149 banner Android广告图片轮播控件，支持无限循环和多种主题，可以灵活设置轮播样式、动画、轮播和切换时间、位置、图片加载框架等！ https://github.com/youth5201314/banner start 6938 XBanner 支持图片无限轮播，支持自定义指示点、显示提示文字、切换动画等 https://github.com/xiaohaibin/XBanner start 516 BGABanner-Android 引导界面滑动导航 + 大于等于1页时无限轮播 + 各种切换动画轮播效果 https://github.com/bingoogolapple/BGABanner-Android start 2914 Android图片压缩工具Luban(鲁班) 可能是最接近微信朋友圈的图片压缩算法 https://github.com/Curzibn/Luban start 8469 侧滑菜单SlidingRootNav https://github.com/yarolegovich/SlidingRootNav start 2385 选择器Android-PickerView 一款仿iOS的PickerView控件，有时间选择和选项选择，并支持一二三级联动，支持自定义样式 https://github.com/Bigkoo/Android-PickerView start 8346 android-picker 安卓选择器类库，包括日期选择器、时间选择器、单项选择器、城市选择器、颜色选择器、文件选择器、目录选择器、数字选择器、星座选择器、生肖选择器等，可自定义顶部及底部界面，可自定义窗口动画。 https://github.com/sevenli777/android-picker start 36 MultiType-FilePicker 第三方选择器，可以选择文件、图片 https://github.com/fishwjy/MultiType-FilePicker 简洁验证码输入框，能自定义输入框个数和样式VerificationCodeInput https://github.com/liuguangli/VerificationCodeInput start 257 RecyclerViewIndexRecyclerView 一款联系人选择的recyclerView列表，支持顶部悬浮和侧边滑动首字母选择 https://github.com/jiang111/IndexRecyclerView start 1114 ExpandableLayout 点击可扩大隐藏列表 https://github.com/traex/ExpandableLayout start 1499 SwipeRecyclerView 侧滑菜单，长按拖拽，滑动删除，自动加载更多，和ViewPager结合使用，和任何下拉刷新框架结合使用。 https://github.com/yanzhenjie/SwipeRecyclerView start 3446 IndexableRecyclerView 轻轻松实现：选择城市，选择联系人等需要索引的功能松实现：选择城市，选择联系人等需要索引的功能 https://github.com/YoKeyword/IndexableRecyclerView start 982 Android换肤／夜间模式的Android框架MultipleTheme https://github.com/dersoncheng/MultipleTheme start 1521 强大的RecyclerAdapter框架BaseRecyclerViewAdapterHelper https://github.com/CymChad/BaseRecyclerViewAdapterHelper start 3215 SuperAdapter https://github.com/byteam/SuperAdapter start 629 更换主题、设置状态栏的工具类StatusBarUtil (实现沉浸栏状态栏颜色状态) https://github.com/laobie/StatusBarUtil start 6211 MagicaSakura Android 多主题框架 https://github.com/Bilibili/MagicaSakura start 2915 DialogBasePopup 打造通用的popupwindow https://github.com/razerdp/BasePopup start 1618 AndroidBottomSheet 底部弹出popupwindow https://github.com/michael-rapp/AndroidBottomSheet start 300 BottomDialog 自定义的从底部弹出的dialog，仿照微博的分享弹框 https://github.com/Curzibn/BottomDialog start 375 AndroidSuperDialog 支持自定义边框圆角、背景透明度、字体大小与色值等 https://github.com/mylhyl/AndroidSuperDialog start 131 material-dialogs md风格的dialog https://github.com/afollestad/material-dialogs start 14288 Android-AlertView 仿iOS的AlertViewController 几乎完美还原iOS 的 AlertViewController ，同时支持Alert和ActionSheet模式，每一个细节都是精雕细琢，并把api封装成懒到极致模式，一行代码就可以进行弹窗. https://github.com/Bigkoo/Android-AlertView start 1212 加载LoadingLoadingLayout 项目里都会遇到几种页面，分别为加载中、无网络、无数据、出错四种情况，经常要使用，所以封成库引用了 https://github.com/weavey/LoadingLayoutDemo start 634 NumberProgressBar 带数字的进度条滚动 https://github.com/daimajia/NumberProgressBar start 5162 KProgressHUD 仿iOS加载 https://github.com/Kaopiz/KProgressHUD start 1128 GifLoadingView https://github.com/Rogero0o/GifLoadingView start 1177 音乐播放Timber MD风格的音乐播放 https://github.com/naman14/Timber start 5145 CustomLrcView-master 自定义显示歌词的控件，实现了歌词的平滑向上滚动，当高亮歌词宽度超过了view的宽的时候，水平滚动 https://github.com/android-lili/CustomLrcView-master start 109 LyricViewDemo 歌词显示 https://github.com/zhengken/LyricViewDemo start 576 数据库LitePal https://github.com/LitePalFramework/LitePal start 5343 realm-java https://github.com/realm/realm-java start 9941 greenDAO https://github.com/greenrobot/greenDAO start 10559 动画库lottie-android 支持跨平台动画库，由UI设计指定切json，将json加载出来实现动画 https://github.com/airbnb/lottie-android start 22620 TransitionHelper 一个简单的Activity转场动画 工具类 https://github.com/ImmortalZ/TransitionHelper start 1569 TranslationCompat 页面过渡动画兼容库，兼容Android5.0之后转场动画至Android4.0。 https://github.com/zhangke3016/TranslationCompat start 259 android-pathview SVG动画库 https://github.com/geftimov/android-pathview start 2485 图表类工具MPAndroidChart 股票折线图、饼状图等 https://github.com/PhilJay/MPAndroidChart start 24227 KChartView 股票k线图 https://github.com/tifezh/KChartView start 356 hellocharts-android https://github.com/lecho/hellocharts-android start 6126 波浪效果WaveView https://github.com/gelitenight/WaveView start 1328 Android开源项目及库TimLiu-Android https://github.com/Tim9Liu9/TimLiu-Android#UI start 2334 播放器PLDroidPlayer 七牛推出的一款免费的适用于 Android 平台的播放器 SDK，采用全自研的跨平台播放内核，拥有丰富的功能和优异的性能，可高度定制化和二次开发 https://github.com/pili-engineering/PLDroidPlayer start 3518 标题导航栏ByeBurger 这是一个极其简便的快速实现隐藏标题栏和导航栏的库。 https://github.com/githubwing/ByeBurger start 1061 网络加载okhttp-OkGo 全新完美支持RxJava，比Retrofit更简单易用。该库是封装了okhttp的标准RESTful风格的网络框架，支持大文件上传下载，上传进度回调，下载进度回调，表单上传（多文件和多参数一起上传），链式调用，可以自定义返回对象，支持Https和自签名证书，支持超时自动重连，支持cookie的持久化和自动管理，支持五种缓存模式缓存网络数据，支持301和302重定向，扩展了统一的上传管理和下载管理功能 https://github.com/jeasonlzy/okhttp-OkGo start 8221 NoHttp Android实现Http标准协议框架，支持多种缓存模式，底层可动态切换OkHttp、URLConnection。 https://github.com/yanzhenjie/NoHttp start 3525 OkHttpFinal OkHttp封装的一个简单易用HTTP请求 https://github.com/pengjianbo/OkHttpFinal start 770 okhttputils okhttp的辅助类 https://github.com/hongyangAndroid/okhttputils start 6402 二维码android-zxingLibrary 几行代码快速集成二维码扫描功能 https://github.com/yipianfengye/android-zxingLibrary start 3531 QRCode-Android 二维码、条形码通用扫描 https://github.com/XuDaojie/QRCode-Android start 362 QrCodeScan Android手机客户端二维码扫描 https://github.com/chentao0707/QrCodeScan start 1080 自定义键盘CustomizeKeyboard 完全自定义的Android安全键盘 https://github.com/StomHong/CustomizeKeyboard start 312 蓝牙操作库BluetoothHelper https://github.com/a-voyager/BluetoothHelper start 1111 版本更新CheckVersionLib 版本检测升级（更新）库。 https://github.com/AlexLiuSheng/CheckVersionLib start 1432 UpdateApp 开箱即用的app更新，主要负责软件下载、软件安装等 Permission和Service默认添加在aar包里面的，如果使用gradle不需要 在意下面的配置了。 https://github.com/yaming116/UpdateApp start 327 缓存ASimpleCache 一个为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来） https://github.com/yangfuhai/ASimpleCache start 3147 权限管理AndPermission https://github.com/yanzhenjie/AndPermission start 4525 FcPermissions https://github.com/lypeer/FcPermissions start 406 RxPermissions https://github.com/tbruyelle/RxPermissions start 7166 Tag标签AndroidTagGroup https://github.com/2dxgujun/AndroidTagGroup start 2168 手势密码解锁LockPattern 仿支付宝手势密码解锁 https://github.com/sym900728/LockPattern start 184 PatternLockView MD风格的手机密码解锁 https://github.com/aritraroy/PatternLockView start 2219 BlurLockView 高斯模糊锁屏界面 https://github.com/Nightonke/BlurLockView start 987 AppLock AppLock应用锁，保护你的隐私。 https://github.com/lizixian18/AppLock start 463 LolliPin Pin解锁 https://github.com/omadahealth/LolliPin start 1480 PinLockView MD风格Pin解锁 https://www.cnblogs.com/abao0/p/6726763.html start 1145]]></content>
      <categories>
        <category>Android</category>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio自定义注释模板]]></title>
    <url>%2Fposts%2Fd339abc3.html</url>
    <content type="text"><![CDATA[代码的注释是我们平时必须面对的问题，今天我们就来看看如何自定义属于自己的注释模板，提高我们的开发效率。 1.新建的类自动生成的注释； 2.自定义注释模板。 新建类自动生成的注释1.打开相应的设置：​ File–&gt;Settings–&gt;Editor–&gt;File and code Template。 选择Files中的Class 在上面添加你想要添加的注释： 下面有一些变量可以选择： {USER} ：表示你系统名字；{DATE}： 表示当前时间；{NAME}:表示类名。而且后面都有注释，相信大家也都能看得懂。 这是设置后的结果画面： 这边有许多变量可以引用，想要哪些变量，或者想自定义成什么样的注释，就看你自己的想象力了。 万能注释模板 Java篇1.打开相应位置： File–&gt;Setting–&gt;Editor–&gt;LiveTemplate： 2.新建一个Live Group: 点击右边的+号，选择Template Group,命名自己的一个注释包。我自己命名为Zm Template Group。 3.新建一个LIve Template： 在你刚刚新建的group下点击+号，新建一个Live Template: Abbraviation:是你设置的快捷键，我的快捷键是z。 Expand with :补全你的注释的快捷键，默认为TAB,我改为了Enter。 4.添加你的注释： 在下面自定义你想要的注释，这边的注释有点不同了，这边可以自定义变量名，格式和我的一样，用双$包起来。 /** * @author $user$ * @email zm@zhangmiao.cc * @date $date$ $time$ * @describe $desc$ */ 5.点击Edit Variables，在Expression选择你需要方法，相当于给你的变量赋值: 6.选择你要运用的地方： 你可以选择Java，C++ 等等。 点击Apply。就成功了，下面让我们来看看效果：]]></content>
      <categories>
        <category>Android</category>
        <category>注释模板</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>注释模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android编译implement、api和compile区别]]></title>
    <url>%2Fposts%2Fde9d44d2.html</url>
    <content type="text"><![CDATA[2017 年google 后，Android studio版本更新至3.0，更新中，连带着com.android.tools.build:gradle 工具也升级到了3.0.0，在3.0.0中使用了最新的Gralde 4.0 里程碑版本作为gradle的编译版本，该版本gradle编译速度有所加速，更加欣喜的是，完全支持Java8。 当然，对于Kotlin的支持，在这个版本也有所体现，Kotlin插件默认是安装的。 我们来看看新建一个项目在Moudle中的 dependencies 中的变化。 dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;&#125; 下面我们来看看他们之前的差异： 首先是2.x版本的依赖方式 再来看看3.0的 可以看到在Android studio3.0中，compile依赖关系已被弃用，被implementation和api替代，provided被compile only替代，apk被runtime only替代。 我们先来看看implementation和api的区别： api：跟 2.x 版本的 compile完全相同implementation：使用了该命令编译的依赖，它仅仅对当前的Moudle提供接口。例如我们当前项目结构如下 LibraryA 中引用了 LibraryC 的库，如果对 LibraryC 的依赖用的是 implementation 关键字。 如下： dependencies &#123; . . . . implementation project（path：&apos;：libraryC&apos;）&#125; 那么LibraryC 中的接口，仅仅只能给 LibraryA 使用，而我们的 App Moudle 是无法访问到 LibraryC 提供的接口的，也就是将该依赖隐藏在内部，而不对外部公开。这就是implementation关键字的作用。 api 指令 完全等同于compile指令，没区别，你将所有的compile改成api，完全没有错。 implement指令 这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。 建议在Google IO 相关话题的中提到了一个建议，就是依赖首先应该设置为implement的，如果没有错，那就用implement，如果有错，那么使用api指令，这样会使编译速度有所增快。 那为什么要这么做呢？答案是： 1. 加快编译速度。2. 隐藏对外不必要的接口。 为什么能加快编译速度呢？ 这对于大型项目含有多个Moudle模块的， 以上图为例，比如我们改动 LibraryC 接口的相关代码，这时候编译只需要单独编译LibraryA模块就行， 如果使用的是api或者旧时代的compile，由于App Moudle 也可以访问到 LibraryC,所以 App Moudle部分也需要重新编译。当然这是在全编的情况下。 还不熟悉 2.x 版本依赖的可以看看下面的说明，括号里对应的是 3.0 版本的依赖方式。 compile（api）这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。 当我们依赖一些第三方的库时，可能会遇到com.android.support冲突的问题，就是因为开发者使用的compile依赖的com.android.support包，而他所依赖的包与我们本地所依赖的com.android.support包版本不一样，所以就会报All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes这个错误。 解决办法可以看这篇博客：com.android.support冲突的解决办法 provided（compileOnly）只在编译时有效，不会参与打包 可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。 testCompile（testImplementation）testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。 debugCompile（debugImplementation）debugCompile 只在 debug 模式的编译和最终的 debug apk 打包时有效 releaseCompile（releaseImplementation）Release compile仅仅针对 Release 模式的编译和最终的 Release apk 打包。 参考链接： Android Studio3.x新的依赖方式（implementation、api、compileOnly） 还再用compile依赖？那你就落后啦 android gradle tools 3.X 中依赖，implement、api 指令]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android快速开发框架推荐10个框架]]></title>
    <url>%2Fposts%2F7a5476f9.html</url>
    <content type="text"><![CDATA[一、 Afinal官方介绍： Afinal是一个Android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。详情请通过以下网址查看。 Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用； 使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。 Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。 项目地址：https://github.com/yangfuhai/afinal 功能： 一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。 优点：功能比较全面，文档完善，代码效率比较高。 缺点：没有项目demo，框架的时间比较久，代码冗余比较多（这也是无可避免的），文档比较老跟不上代码更新进度。 （这个评价是其他高人评的，他自己也有写了框架。我个人觉得以前Afinal算是经典了 用的人多）。 二、 xUtilsGit地址：https://github.com/wyouflf/xUtils xUtils：可以说是Afinal的升级版。 xUtils 包含了很多实用的android工具。 xUtils 支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响… xUitls 最低兼容android 2.2 (api level 8) 三、 ThinkAndroid项目地址：https://github.com/white-cat/ThinkAndroid 官方介绍： ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块,具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能，在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类，如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具 优点：功能看起来比较完善。个人觉得名字起的好。 缺点：从2013年就停止维护了，没有项目文档。 四、 LoonAndroid官方介绍： 如果你想看ui方面的东西，这里没有，想要看牛逼的效果这里也没有。这只是纯实现功能的框架，它的目标是节省代码量，降低耦合，让代码层次看起来更清晰。整个框架一部分是网上的，一部分是我改的，为了适应我的编码习惯，还有一部分像orm完全是网上的组件。在此感谢那些朋友们。 整个框架式的初衷是为了偷懒，之前都是一个功能一个jar，做项目的时候拉进去，这样对于我来说依然还是比较麻烦。最后就导致我把所有的jar做成了一个工具集合包。 有很多框架都含有这个工具集合里的功能，这些不一定都好用，因为这是根据我个人使用喜欢来实现的，如果你们有自己的想法，可以自己把架包解压了以后，源码拉出来改动下。 目前很多框架都用到了注解，除了androidannotations没有入侵我们应用的代码以外，其他的基本上都有，要么是必须继承框架里面的activity,要么是必须在activity的oncreat里面调用某个方法。 整个框架式不同于androidannotations，Roboguice等ioc框架，这是一个类似spring的实现方式。在整应用的生命周期中找到切入点，然后对activity的生命周期进行拦截，然后插入自己的功能。 开源地址：https://github.com/gdpancheng/LoonAndroid 功能： 1自动注入框架（只需要继承框架内的application既可） 2图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性） 3网络请求模块（继承了基本上现在所有的http请求） 4 eventbus（集成一个开源的框架） 5验证框架（集成开源框架） 6 json解析（支持解析成集合或者对象） 7 数据库（不知道是哪位写的 忘记了） 8 多线程断点下载（自动判断是否支持多线程，判断是否是重定向） 9 自动更新模块 10 一系列工具类 有点：功能多 缺点：文档方面 五、 KJFrameForAndroid项目地址：https://github.com/kymjs/KJFrameForAndroid 官方介绍： KJFrameForAndroid 又叫KJLibrary，是一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用；KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。我们提倡用最少的代码，完成最多的操作，用最高的效率，完成最复杂的功能。 功能： 一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用； KJFrameForAndroid开发框架的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。总共分为五大模块：UILibrary，UtilsLibrary，HttpLibrary，BitmapLibrary，DBLibrary。 优点：功能比较全面，代码效率很高，文档完善，有项目demo，出来的比较晚借鉴了很多大型框架经验。 缺点：项目文档是html页面，查看起来很不方便，项目交流平台没多少人说话（难道大神都是不说话的？） （这两个评价是KJFrameForAndroid的作者对自己的评价，个人觉得作者是个天才。他的评价可能刚写完网上发布后写的。我在给他更新评价。因为现在已经过去了几个月一直在时不时更新。功能很全，项目文档也很全面，而且代码里注释最多 这方面这个很难得。交流平台人很多挺热闹，作者希望更热闹这样框架越来越完善。对于初学者希望看到Demo更完善） 六、 dhroid官方介绍： dhroid 是基于android 平台, 极速开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展.使你更快,更好的开发商业级别应用 开源地址: http://git.oschina.net/tengzhinei/dhroid 功能： 1.Ioc容器: (用过spring的都知道)视图注入,对象注入,接口注入,解决类依赖关系 2.Eventbus: android平台事件总线框架,独创延时事件,事件管理轻松 3.Dhnet: 网络http请求的解决方案,使用简单,减少代码,自带多种网络访问缓存策略 4.adapter模块: 数据绑定轻松,不用写多余的adapter,天生网络支持(一行代码搞定加载,刷新问题) 5.DhDb: android中sqlite的最轻量orm框架(增删改查轻松搞定) 6.Perference: android自带Perference 升级版,让你的Perference更强大,更方便 工具集合 JSONUtil(安全处理json),ViewUtil(数据绑定更快) ThreadWorker(异步任务工具)… 优点：功能全面，有demo，作者也是为公司开发的框架。 缺点：文档方面现在不是很好，就eoe上的那些。 七、 SmartAndroid项目地址：http://www.aplesson.com/smartAndroid/demos 官方介绍： SmartAndroid是一套给 Android开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 SmartAndroid可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。 功能： SmartAndroid 拥有全范围的类库，可以完成大多数通常需要的APP开发任务，包括： 异步网络操作相关所有功能、强大的图片处理操作、轻量级ORM数据库Sqlite库、zip操作 、动画特效、Html等解析采集、事件总线EventBus/Otto、Gson(Json)、AQuery、主流所有UI控件（例如：ActionbarSherlock，SlidingMenu，BottomView，Actionbar，DragListView等10多种UI库）等。 优点：功能非常全，超出你索要、文档完善（作者很全面，官方网站是web响应式网站，框架里功能有UI各种特效应该最全了，一直更新中） 缺点：jar包大点？（功能多不可避免，不是问题），在线文档（随响应式的手机访问也方便，但是网速慢就不好了，页面打开不是很流畅） 八、 andBase官方介绍： andbase是为Android开发者量身打造的一款开源类库产品 开源地址：https://code.jd.com/zhaoqp2010_m/andbase 功能： 1.andbase中包含了大量的开发常用手段。 如网络下载，多线程与线程池的管理，数据库ORM，图片缓存管理，图片文件下载上传，Http请求工具，常用工具类（字符串，日期，文件处理，图片处理工具类等），能够使您的应用在团队开发中减少冗余代码，很大的提高了代码的维护性与开发高效性，能很好的规避由于开发疏忽而导致常犯的错误。 2.andbase封装了大量的常用控件。 如list分页，下拉刷新，图片轮播，表格，多线程下载器，侧边栏，图片上传，轮子选择，图表，Tab滑动，日历选择器等。 3.强大的AbActivity，您没有理由不继承它。 继承它你能够获得一个简单强大可设置的操作栏，以及一系列的简单调用，如弹出框，提示框，进度框，副操作栏等。 4.提供效率较高图片缓存管理策略，使内存大幅度节省，利用率提高，效率提高。 程序中要管理大量的图片资源，andbase提供简单的方法，几步完成下载与显示，并支持缩放，裁剪，缓存功能。 5.封装了大量常见工具类。 包括日期，字符，文件，图片等各种处理函数，多而全。 6.用andbase大量减少handler的使用，而采用回调函数，代码更整洁。 handler会产生大量代码，并且不好维护，andbase对handler进行了封装。 7.简单轻量支持注解自动建表的ORM框架（支持一/多对多的关联操作）。 写sql，建表，工作量大，andbase提供更傻瓜异步增删改查工具类。 8.异步请求http框架，网络请求标准化，支持文件上传下载，get，post，进度显示。 包含了异步与http请求的工具类，实用。 9.热情的支持群体。 优点：功能很全，demo做的好 、API文档完善、接近完美 缺点：希望文档更详细些。 九、 AndroidAnnotations项目地址：https://github.com/excilys/androidannotations 功能： 完全注解框架，一切皆为注解：声明控件，绑定控件，设置监听，setcontentview，长按事件，异步线程，全部通过注解实现。 优点：完全的注解，使开发起来更加便利，程序员写的代码也更少。 缺点：文档是全英文的加上功能比较少没有具体研究，由于一切都是注解，感觉效率不高，不过根据官方介绍说并不是使用的反射加载，所以效率比一般注解高很多。 十、 volley项目地址： https://github.com/smanikandan14/Volley-demo 功能： Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮异步加载网络图片、网络数据 优点：Google官方推荐，请看去年的开发者大会介绍。 缺点：功能比较少，只有网络数据加载和网络图片加载 十一、 android-async-http 项目地址：https://github.com/loopj/android-async-http文档介绍：http://loopj.com/android-async-http/ (1) 在匿名回调中处理请求结果 (2) 在UI线程外进行http请求 (3) 文件断点上传 (4) 智能重试 (5) 默认gzip压缩 (6) 支持解析成Json格式 (7) 可将Cookies持久化到SharedPreferences 有点：很简单很实用 缺点：功能比较少， （只是针对的功能不是什么缺点） 最后来个总结吧： ​ 以上的开发框架网上都可以下载源码，也有demo实例的。当然我没分析和对比框架的效率性能，但是都非常实用，其作者大部分是个人，都是些牛人或天才。你可以直接使用，也可以把有用跳出来用，至少有很多使用工具。如果有发现Bug，作者希望把bug交给他。 ​ Afinal 和 xUtils简单实用但是demo和更新的问题。 KJFrameForAndroid 算是新出的，功能也多，效率也应该好，代码也注释多 用起来也很方便。 Dhroid 作者自己公司的框架，也可以直接请教。 SmartAndroid 强劲的框架功能俱全。 andBase 出来早各个方面算是完整的吧。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 项目最新架构]]></title>
    <url>%2Fposts%2Fb043c117.html</url>
    <content type="text"><![CDATA[前言为了帮助开发着打造一款优秀的APP，Google可谓费尽心力，推出了各种诸如MVP,MVVM等等项目架构的思路，帮助开发者更加高效的开发，尽管这样，Google还是接着推出了一个新的项目架构，以便给予开发者更多的选择，至于这种架构思路和MVP等框架的优劣，各位看完文章或许自有定论。 1.生命周期在移动操作系统上开发软件其实是十分复杂的一件事情，因为我们随时需要面对系统和用户的各种不可预料的操作，很多时候，事情并不向着我们预设的方向方向进展。因此系统向我们提供了核心组件的生命周期这种东西，告知我们的APP正处在什么样的状况中，以便于我们做出相应的处理。 如上图。虽然Google给出了Activity非常详尽的生命周期结构，因此我们对根据生命周期做出相应的合理的安排，比如添加和移除实时GPS位置监听： 可是随着业务的逐渐复杂，我们可能在添加监听之间需要向服务器验证某些用户信息，等返回信息正确才去监听定位。那么在网络异步回调的时候，我们就很难知道当前的activity的生命周期状态。 如果发生上图的情况，那么我们的占用的相关资源就可能永远无法移除了。这还只是冰山一角，大家尽可以想想，当我们的异步调用面对无法预知的用户操作和系统处理的时候，什么问题都可能发生。 总而言之，由于我们对于UI实时的状态做不到了如指掌，以至于对数据和逻辑的处理就无法尽善尽美。这是类似隐患得不到很好的解决根本原因。 2. Google大礼包这次Google推出了一套新的项目架构组件和架构思路，从UI到Data,帮助我们更加精准的开发自己的APP。 2.1 核心：Lifecycle Components这套架构最核心的就是生命周期组件，：Lifecycle Components用于管理UI控制器（Activity/Freagment）的生命周期，方便查询当前组件生命周期的状态。 可查询的状态如下： 具体的使用方式有两种： 继承LifecycleActivity/LifecycleFragment即可 自己实现LifecycleRegistryOwner接口 java // 通过继承，就已经将自己的生命周期的交给了Lifecycle Components管理了。public class MainActivity extends LifecycleActivity &#123;&#125; 那我们如何使用呢？ // 通过继承LifecycleObserver，保证我们可以通过注解或者接口查询UI的生命周期public class MyTest implements LifecycleObserver &#123; private Lifecycle lifecycle; // Lifecycle包含了当前组件的生命周期 public MyTest(Lifecycle lifecycle)&#123; lifecycle.addObserver(this); this.lifecycle=lifecycle; &#125;// 当onResume发生的时候，该方法被调用 @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void resume()&#123; Log.i(&quot;TAG&quot;,&quot;it called when resume &quot;); &#125; public void doTest(String s)&#123; // 随时可以查询当前的UI状态 if(lifecycle.getCurrentState().equals(Lifecycle.State.RESUMED))&#123; Log.i(&quot;TAG&quot;,&quot;resume&quot;); &#125;else&#123; Log.i(&quot;TAG&quot;,&quot;is not resume !! &quot;); &#125; &#125;&#125;public class MainActivity extends LifecycleActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //将当前Activity的生命周期传递到MyTest中即可 MyTest myTest=new MyTest(this.getLifecycle()); &#125;&#125; 看到这里，你一定心头一喜，如果有这个组件，那么我们就完全有能力将Activity作为一个UI的控制器，仅仅用来显示UI和相应用户操作，把Activity的大小缩小至最小。不用着急，大礼包远不止这些。 3.ViewModel和LiveData ViewModel 是一个UI相关数据的暂存器，当所有相关的UI都finish掉的时候，它才会清除自己的数据。 LiveData则是一个持有具体数据并且可被观察，能感知生命周期的组件（它就像RxJava中一个能遵循组件生命周期的Observable） 他俩的关系，就是，ViewModel负责管理着不同的LiveData,并把它提供给UI。 3.1 LiveData我们可以先来说说LiveData。由于它已经能够感知生命周期，也就意味着我们并不需要在去查询当前UI的生命周期，由于可被观察，也就意味着当它持有的数据发生改变，观察者可以立即受到信息。livedata最重要的方法是一下几个： onActive() // 当前LiveData有超过一个的活跃的观察者时，被调用onInactive() // 当前没有任何活跃的观察时，着被调用setValue() // 勇于改变当前数据，这样观察者可以受到改变后的数据。// 观察数据变化，并感知当前UI的生命周期observe(LifecycleOwner owner, Observer&lt;T&gt; observer) 这里有一个活跃的观察者的概念，我们不妨把它放在后面来看。LiveData的用法如下： public class LocationLiveData extends LiveData&lt;Location&gt; &#123; private LocationManager locationManager; private SimpleLocationListener listener = new SimpleLocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; setValue(location); &#125; &#125;; public LocationLiveData(Context context) &#123; locationManager = (LocationManager) context.getSystemService( Context.LOCATION_SERVICE); &#125; @Override protected void onActive() &#123; locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); &#125; @Override protected void onInactive() &#123; locationManager.removeUpdates(listener); &#125;&#125;public class MainActivity extends LifecycleActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); LiveData&lt;Location&gt; myLocationListener = new LocationLiveData(); /* * observe(LifecycleOwner owner, Observer&lt;T&gt; observer) * 这个方法就是向LiveData中添加观察者， * LiveData则可以通过LifecycleOwner来判断 * 当前传入的观察者是否是活跃的（也就是UI是否可见了） */ myLocationListener.observe(this, new Observer&lt;Location&gt;() &#123; @Override public void onChanged(@Nullable Location location) &#123; // update //当LiveData中通过setValue()修改了数据时， //这里将会受到修改后的数据 &#125; &#125;); &#125;&#125; 好了，LiveData基本的用法讲完了，由于有了LiveData，我们的data更加“智能”了。当UI不可见的时候，改变的数据将不会被更新到UI上。 而且如果数据在不同的UI界面都会被用到的时候，我们还可以一个单例的LiveData，为不同的UI提供统一的数据。这些操作就不去细讲了。 现在回头看LiveData，我们发现它至少有以下几个优点： 可以避免内存泄露：由于 Observer 和 Lifecycle 绑定，当 Lifecycle 被销毁后，Observer 自动被清理。 避免在 Activity 被销毁后更新数据导致的崩溃情况 数据可共享 数据更新更智能：当数据在UI不可见的时候更新了，在恢复可见的时候，最新的数据会及时更新到UI上。 不需要在Activity中额外处理生命周期事件 一颗赛艇！ 3.2 ViewModelViewModel则相对简单些，因为他的作用是暂存UI相关的数据，保证即使Activity配置更改，重新创建时，数据依然能够被保存好。 基本用法如下： public class MyViewModel extends ViewModel &#123; // MyViewModel用于管理不同的LiveData private MutableLiveData&lt;List&lt;User&gt;&gt; users; public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123; if (users == null) &#123; users = new MutableLiveData&lt;List&lt;Users&gt;&gt;(); loadUsers(); &#125; return users; &#125; private void loadUsers() &#123; // do async operation to fetch users &#125;&#125;public class MyActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; // 通过了ViewModelProviders来获取ViewModel // 用户获取和Activity绑定的ViewModel MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class); model.getUsers().observe(this, users -&gt; &#123; // update UI &#125;); &#125;&#125; 这是ViewModel的最基本的用法，它负责从各个地方获取数据，然后把数据装到LiveData中，提供给UI；当然ViewModel也可以在不同的Fragment中共享，在这里就不多讲了。 由于ViewModel的本身和activity/fragment的生命周期绑定，当与之绑定的最后一个UI 销毁时，ViewModel才会clean自身的数据。 如图所示 4.数据持久化：RoomRoom是Google提供的SQLite的ORM的解决方案，其实本质上和其他的ORM框架没什么特别大的差别，没有太多新意，因此只给出大体的架构图，有兴趣的同学可以自行去学习 5.总结我们现在回头看整个架构 其实最有有趣的就是UI-ViewModel这个部分，这套架构至少可以帮助我们做到一下几点： UI与Data真正分离 异步调用和逻辑控制可以更加精细（因为对生命周期感知更多） 实现Model驱动UI 6.勘误暂无 附录android官网： https://developer.android.com/topic/libraries/architecture/index.html]]></content>
      <categories>
        <category>Android</category>
        <category>设计架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Glide4.x的使用]]></title>
    <url>%2Fposts%2F6944411e.html</url>
    <content type="text"><![CDATA[最近从Glidev3升级到了Glide4.x，我用的是最新的Glide4.1.1哈，由于3.x到4.x的变化还是很大的，在此记录一下，也和需要的朋友分享一下。 Glide官方学习地址 使用1、在app的build.gradle中添加如下配置 dependencies &#123;//Glide框架引入 compile 'com.github.bumptech.glide:glide:4.1.1' annotationProcessor 'com.github.bumptech.glide:compiler:4.1.1'&#125; 2、在project的build.gradle中添加如下仓库地址** repositories &#123; mavenCentral() maven &#123; url 'https://maven.google.com' &#125;&#125; 3、自定义AppGlideModule： 为运用程序定义一个带有@GlideModule注解的AppGlideModule，运用程序会使用和AppGlideMoudle同一个包下的GlideApp类。通过GlideApp.with()方式使用Glide的Generated API。具体操作，就是新建一个类，继承与AppGlideModule，还必须带有@GlideModule注解， @GlideModulepublic final class MyAppGlideModule extends AppGlideModule &#123; &#125; 注意： 必需带有@GlideModule注解。 官方文档明确说明，这个类，你可以让它保留空白，不用实现任何方法，就可以使用Glide的Generated API。当然你也可以实现一些方法，具体参考官方文档。 4、Glide加载圆形图片，和Glide3.x差异不大 ** * Glide圆形图片 */public class GlideCircleTransform extends BitmapTransformation &#123; public GlideCircleTransform() &#123; super(); &#125; @Override public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; // TODO this could be acquired from the pool too Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125;&#125;//调用/** * 加载圆形图片 */public static void loadCircleImg(Context context, String url, final ImageView imageView) &#123; GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .transform(new GlideCircleTransform()) .into(imageView); &#125; 5、Glide加载圆角图片 说道这个我不得不吐槽一下网上的各路大神了，4.x和3.x加载圆角真不一样了，下面举个网上的例子，和3.x差不多 public class GlideRoundTransform extends BitmapTransformation &#123;&#125; 尼玛，根本显示不了圆角啊，后来查资料才发现原来是Glide圆角和centerCrop的冲突，不过也得到了解决，感谢这位作者 Glide .centerCrop() 和transform圆角图片不能同时存在解决方法 下面贴出我的加载圆角的方法 /** * 圆角图片 */public class GlideRoundTransform extends CenterCrop &#123; private static float radius = 0f; public GlideRoundTransform() &#123; this(4); &#125; public GlideRoundTransform(int dp) &#123; super(); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; Bitmap transform = super.transform(pool, toTransform, outWidth, outHeight); return roundCrop(pool, transform);// return roundCrop(pool, toTransform); &#125; private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125;&#125;//调用/** * 加载圆角图片 * * @param context * @param url * @param imageView */ public static void loadRoundImg(Context context, String url, final ImageView imageView) &#123; GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .transform(new GlideRoundTransform(8)) .into(imageView); &#125; 6、Glide加载图片进度的监听 GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object o, Target&lt;Drawable&gt; target, boolean b) &#123; Log.i(TAG, "图片加载失败 "); return false; &#125; @Override public boolean onResourceReady(Drawable drawable, Object o, Target&lt;Drawable&gt; target, DataSource dataSource, boolean b) &#123; Log.i(TAG, "图片加载完成: "); return false; &#125; &#125;) .into(imageView);]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 图片处理之Glide4.0版本]]></title>
    <url>%2Fposts%2Faf2ff32e.html</url>
    <content type="text"><![CDATA[前言一般项目我都会使用Glide作为我的图片加载框架，他和Picasso ,真的很像，郭大神早就分析过了，很详细，这里也就简单做个记录。小白白一枚，学习路上 Android图片加载框架最全解析（一），Glide的基本用法 Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 Android图片加载框架最全解析（三），深入探究Glide的缓存机制 Android图片加载框架最全解析（四），玩转Glide的回调与监听 Android图片加载框架最全解析（五），Glide强大的图片变换功能 Android图片加载框架最全解析（六），探究Glide的自定义模块功能 Android图片加载框架最全解析（七），实现带进度的Glide图片加载功能 Android图片加载框架最全解析（八），带你全面了解Glide 4的用法 一：GitHubbumptech/glide二：下载使用点击，跳转到官网，介绍很详细 1. Gradlerepositories &#123; mavenCentral() maven &#123; url 'https://maven.google.com' &#125;&#125; dependencies &#123; compile 'com.github.bumptech.glide:glide:4.4.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'&#125; 2. Android SDK 要求 Min Sdk Version - 使用 Glide 需要 min SDK 版本 API 14 (Ice Cream Sandwich) 或更高。 Compile Sdk Version - Glide 必须使用 API 26 (Oreo) 或更高版本的 SDK 来编译。 Support Library Version - Glide 使用的支持库版本为 27。 否则会出现异常 解决方案dependencies &#123; implementation 'com.android.support:appcompat-v7:27.0.2' //这个版本的就可以了 implementation 'com.github.bumptech.glide:glide:4.4.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'&#125; 3.权限&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 二：apply &amp;&amp; RequestOptions4.0之前最常用的方式，当然现在也是哈 Glide.with(this) .load(url) .into(img); 4.0之后，有一个新的东西 Glide.with(this) .load(url)// .apply(RequestOptions options) .into(img); 比如 我们加载占位图和错误图 RequestOptions options = new RequestOptions() .error(R.drawable.error) .placeholder(R.drawable.loading);Glide.with(this) .load(url) .apply(options) .into(imageView); 小伙伴们没看错，这样的方式，摆脱了，以前链式写法中，Glide很长很长，现在的话，我们可以传入一个RequestOptions，对象，就有小伙伴问了，有啥用，我觉得，比较容易封装， 例如 public class GlideUtil &#123; public static void load(Context context, String url, ImageView imageView, RequestOptions options) &#123; Glide.with(context) .load(url) .apply(options) .into(imageView); &#125;&#125; 三：API 介绍 API 介绍 占位符(Placeholder) 当请求正在执行时被展示的 Drawable 错误符(Error) 请求永久性失败时展示 后备回调符(Fallback) 在请求的url/model为 null 时展示 override 指定了一个图片的尺寸,Target.SIZE_ORIGINAL加载图片的原始尺寸 skipMemoryCache(true) 禁用内存缓存功能 diskCacheStrategy(DiskCacheStrategy.NONE) 禁用硬盘缓存功能,参数列表如下 四（1） asBitmap() 只允许加载静态图片,。如果传入的是GIF图,会展示GIF图的第一帧 asFile() 指定文件格式 注意事项 如下 四（2） asDrawable() 指定Drawable格式 submit() 使用如下四（3） transforms 图片变换，Glide 默认有3个，如下四（4） 四： 补充说明1. diskCacheStrategy参数补充 参数 说明 DiskCacheStrategy.NONE 表示不缓存任何内容。 DiskCacheStrategy.DATA 表示只缓存原始图片。 DiskCacheStrategy.RESOURCE 表示只缓存转换过后的图片。 DiskCacheStrategy.ALL 表示既缓存原始图片，也缓存转换过后的图片。 DiskCacheStrategy.AUTOMATIC 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。 2. asBitmap()注意坑熟悉Glide 3的朋友对asBitmap()方法肯定不会陌生对吧？但是千万不要觉得这里就没有陷阱了，在Glide 3中的语法是先load()再asBitmap()的，而在Glide 4中是先asBitmap()再load()的。乍一看可能分辨不出来有什么区别，但如果你写错了顺序就肯定会报错了 3. submit()通过如下代码，可以获取到，下载好的图片放在哪，可以看到 都在cache下 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; File file = Glide.with(MainActivity.this) .asFile() .load(url) .submit() .get(); Log.e("Tag", "path--&gt;" + file.getPath()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();E/Tag: path--&gt;/data/user/0/com.allens.glidedemo/cache/image_manager_disk_cache/309df01e6362ddc8939a4e3c549e8276dffb0446a89f2facee371909301fe76a.0 4. transforms内置有这3个 RequestOptions options = new RequestOptions() .centerCrop();RequestOptions options = new RequestOptions() .fitCenter();RequestOptions options = new RequestOptions() .circleCrop();//圆形 一般我们还会自己去定义，以下是常用的3种转换 使用起来也很简单 RequestOptions options = new RequestOptions() .skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.NONE); //圆形 .transforms(new CircleTransform(mContext,2, Color.DKGRAY))//外圈宽度，外圈颜色 //黑白 .transforms(new BlackWhiteTransformation()); //高斯模糊 范围在 0 -- 25 越大模糊程度越高 .transforms(new BlurTransformation(mContext, 25)); // (0 &lt; r &lt;= 25) //可以使用多种 .transforms(new BlurTransformation(mContext, 25),new CircleTransform(mContext,2, Color.DKGRAY)) （1） 转成黑白package com.allens.lib_glide.Transformation;import android.graphics.Bitmap;import android.media.ThumbnailUtils;import android.support.annotation.NonNull;import android.view.animation.Transformation;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 黑白 * Created by allens on 2018/1/8. */public class BlackWhiteTransformation extends BitmapTransformation &#123; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return convertToBlackWhite(toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap convertToBlackWhite(Bitmap bmp) &#123; int width = bmp.getWidth(); // 获取位图的宽 int height = bmp.getHeight(); // 获取位图的高 int[] pixels = new int[width * height]; // 通过位图的大小创建像素点数组 bmp.getPixels(pixels, 0, width, 0, 0, width, height); int alpha = 0xFF &lt;&lt; 24; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; int grey = pixels[width * i + j]; //分离三原色 int red = ((grey &amp; 0x00FF0000) &gt;&gt; 16); int green = ((grey &amp; 0x0000FF00) &gt;&gt; 8); int blue = (grey &amp; 0x000000FF); //转化成灰度像素 grey = (int) (red * 0.3 + green * 0.59 + blue * 0.11); grey = alpha | (grey &lt;&lt; 16) | (grey &lt;&lt; 8) | grey; pixels[width * i + j] = grey; &#125; &#125; //新建图片 Bitmap newBmp = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); //设置图片数据 newBmp.setPixels(pixels, 0, width, 0, 0, width, height); Bitmap resizeBmp = ThumbnailUtils.extractThumbnail(newBmp, 380, 460); return resizeBmp; &#125;&#125; （2）高斯模糊package com.allens.lib_glide.Transformation;import android.annotation.TargetApi;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.os.Build;import android.renderscript.Allocation;import android.renderscript.Element;import android.renderscript.RSRuntimeException;import android.renderscript.RenderScript;import android.renderscript.ScriptIntrinsicBlur;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: 高斯模糊 * &lt;p&gt; * Created by allens on 2018/1/8. */public class BlurTransformation extends BitmapTransformation &#123; private Context context; private float blurRadius; public BlurTransformation(Context context, float blurRadius) &#123; this.context = context; this.blurRadius = blurRadius; &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return blurBitmap(context, toTransform, blurRadius, outWidth, outHeight); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; /** * @param context 上下文对象 * @param image 需要模糊的图片 * @param outWidth 输入出的宽度 * @param outHeight 输出的高度 * @return 模糊处理后的Bitmap */ @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public Bitmap blurBitmap(Context context, Bitmap image, float blurRadius, int outWidth, int outHeight) &#123; // 将缩小后的图片做为预渲染的图片 Bitmap inputBitmap = Bitmap.createScaledBitmap(image, outWidth, outHeight, false); // 创建一张渲染后的输出图片 Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap); // 创建RenderScript内核对象 RenderScript rs = RenderScript.create(context); // 创建一个模糊效果的RenderScript的工具对象 ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间 // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去 Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap); Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap); // 设置渲染的模糊程度, 25f是最大模糊度 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; blurScript.setRadius(blurRadius); &#125; // 设置blurScript对象的输入内存 blurScript.setInput(tmpIn); // 将输出数据保存到输出内存中 blurScript.forEach(tmpOut); // 将数据填充到Allocation中 tmpOut.copyTo(outputBitmap); return outputBitmap; &#125;&#125; （3） 圆形package com.allens.lib_glide.Transformation;import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 圆形 * Created by allens on 2018/1/8. */public class CircleTransform extends BitmapTransformation &#123; private Paint mBorderPaint; private float mBorderWidth; public CircleTransform(Context context) &#123; super(context); &#125; public CircleTransform(Context context, int borderWidth, int borderColor) &#123; super(context); mBorderWidth = Resources.getSystem().getDisplayMetrics().density * borderWidth; mBorderPaint = new Paint(); mBorderPaint.setDither(true); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(borderColor); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setStrokeWidth(mBorderWidth); &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) &#123; return null; &#125; int size = (int) (Math.min(source.getWidth(), source.getHeight()) - (mBorderWidth / 2)); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); if (mBorderPaint != null) &#123; float borderRadius = r - mBorderWidth / 2; canvas.drawCircle(r, r, borderRadius, mBorderPaint); &#125; return result; &#125;&#125; 4.0 圆角package com.starot.spark.transformation;import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 圆形 * * @author allens * @date 2018/1/8 */public class CircleTransform extends BitmapTransformation &#123; private Paint mBorderPaint; private float mBorderWidth; public CircleTransform(Context context) &#123; super(context); &#125; public CircleTransform(Context context, int borderWidth, int borderColor) &#123; super(context); mBorderWidth = Resources.getSystem().getDisplayMetrics().density * borderWidth; mBorderPaint = new Paint(); mBorderPaint.setDither(true); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(borderColor); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setStrokeWidth(mBorderWidth); &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) &#123; return null; &#125; int size = (int) (Math.min(source.getWidth(), source.getHeight()) - (mBorderWidth / 2)); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); if (mBorderPaint != null) &#123; float borderRadius = r - mBorderWidth / 2; canvas.drawCircle(r, r, borderRadius, mBorderPaint); &#125; return result; &#125;&#125; 5.Generated API如果4.0用的不爽，就想使用3.0版本的那种链式写法,将Glide 关键字改成 GlideApp即可 GlideApp.with(this) .load(url) .placeholder(R.drawable.loading) .error(R.drawable.error) .skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.NONE) .override(Target.SIZE_ORIGINAL) .circleCrop() .into(imageView);]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android：时间工具类 -- 时间戳转换成日期，日期转换成时间戳]]></title>
    <url>%2Fposts%2F29c9b34b.html</url>
    <content type="text"><![CDATA[public class DateUtils &#123; public static String getTodayDateTime() &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()); return format.format(new Date()); &#125; /** * 掉此方法输入所要转换的时间输入例如（"2014年06月14日16时09分00秒"）返回时间戳 * * @param time * @return */ public String data(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒", Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; public static String getTodayDateTimes() &#123; SimpleDateFormat format = new SimpleDateFormat("MM月dd日", Locale.getDefault()); return format.format(new Date()); &#125; /** * 获取当前时间 * * @return */ public static String getCurrentTime_Today() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); return sdf.format(new java.util.Date()); &#125; /** * 调此方法输入所要转换的时间输入例如（"2014-06-14-16-09-00"）返回时间戳 * * @param time * @return */ public static String dataOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss", Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; public static String getTimestamp(String time, String type) &#123; SimpleDateFormat sdr = new SimpleDateFormat(type, Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014年06月14日16时09分00秒"） * * @param time * @return */ public static String times(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014-06-14 16:09:00"） * * @param time * @return */ public static String timedate(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014年06月14日16:09"） * * @param time * @return */ public static String timet(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日 HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeslash(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy/MM/dd,HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeslashData(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy/MM/dd"); @SuppressWarnings("unused") long lcc = Long.valueOf(time);// int i = Integer.parseInt(time); String times = sdr.format(new Date(lcc * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeMinute(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String tim(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyyMMdd HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String time(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; // 调用此方法输入所要转换的时间戳例如（1402733340）输出（"2014年06月14日16时09分00秒"） public static String times(long timeStamp) &#123; SimpleDateFormat sdr = new SimpleDateFormat("MM月dd日 # HH:mm"); return sdr.format(new Date(timeStamp)).replaceAll("#", getWeek(timeStamp)); &#125; private static String getWeek(long timeStamp) &#123; int mydate = 0; String week = null; Calendar cd = Calendar.getInstance(); cd.setTime(new Date(timeStamp)); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 if (mydate == 1) &#123; week = "周日"; &#125; else if (mydate == 2) &#123; week = "周一"; &#125; else if (mydate == 3) &#123; week = "周二"; &#125; else if (mydate == 4) &#123; week = "周三"; &#125; else if (mydate == 5) &#123; week = "周四"; &#125; else if (mydate == 6) &#123; week = "周五"; &#125; else if (mydate == 7) &#123; week = "周六"; &#125; return week; &#125; // 并用分割符把时间分成时间数组 /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014-06-14-16-09-00"） * * @param time * @return */ public String timesOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String timesTwo(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 并用分割符把时间分成时间数组 * * @param time * @return */ public static String[] timestamp(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); String[] fenge = times.split("[年月日时分秒]"); return fenge; &#125; /** * 根据传递的类型格式化时间 * * @param str * @param type * 例如：yy-MM-dd * @return */ public static String getDateTimeByMillisecond(String str, String type) &#123; Date date = new Date(Long.valueOf(str)); SimpleDateFormat format = new SimpleDateFormat(type); String time = format.format(date); return time; &#125; /** * 分割符把时间分成时间数组 * * @param time * @return */ public String[] division(String time) &#123; String[] fenge = time.split("[年月日时分秒]"); return fenge; &#125; /** * 输入时间戳变星期 * * @param time * @return */ public static String changeweek(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); Date date = null; int mydate = 0; String week = null; try &#123; date = sdr.parse(times); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 获取日期和星期 例如：２０１４－１１－１３ １１:００ 星期一 * * @param time * @param type * @return */ public static String getDateAndWeek(String time, String type) &#123; return getDateTimeByMillisecond(time + "000", type) + " " + changeweekOne(time); &#125; /** * 输入时间戳变星期 * * @param time * @return */ public static String changeweekOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); Date date = null; int mydate = 0; String week = null; try &#123; date = sdr.parse(times); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 获取当前时间 * * @return */ public static String getCurrentTime() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm"); return sdf.format(new java.util.Date()); &#125; /** * 输入日期如（2014年06月14日16时09分00秒）返回（星期数） * * @param time * @return */ public String week(String time) &#123; Date date = null; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); int mydate = 0; String week = null; try &#123; date = sdr.parse(time); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 输入日期如（2014-06-14-16-09-00）返回（星期数） * * @param time * @return */ public String weekOne(String time) &#123; Date date = null; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); int mydate = 0; String week = null; try &#123; date = sdr.parse(time); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 音频amr文件时长]]></title>
    <url>%2Fposts%2F45412865.html</url>
    <content type="text"><![CDATA[一、文件时长获取 public int getDurations()&#123; String curAudioFile = “XXX.amr”; MediaPlayer mediaPlayer = new MediaPlayer(); mediaPlayer.setDataSource(curAudioFile); mediaPlayer.prepare(); return mediaPlayer.getDuration();// 单位毫秒&#125; 二、文件时长转换** private static String getAudioDuration(int nDuration0) &#123; DecimalFormat df = new DecimalFormat("#.00"); String fileSizeString = ""; String wrongSize = "0ms"; if (nDuration0 == 0) &#123; return wrongSize; &#125; if (nDuration0 &lt; 1000) &#123; fileSizeString = df.format((double) nDuration0) + "ms"; &#125; else if (nDuration0 &lt; 60000) &#123; fileSizeString = df.format((double) nDuration0 / 1000) + "s"; &#125; else if (nDuration0 &lt; 3600000) &#123; fileSizeString = df.format((double) nDuration0 / 60000) + "min"; &#125; else &#123; fileSizeString = df.format((double) nDuration0 / 3600000) + "h"; &#125; return fileSizeString;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中实现延时执行操作的几种方法]]></title>
    <url>%2Fposts%2Ffdc60895.html</url>
    <content type="text"><![CDATA[在Android开发中我们可能会有延时执行某个操作的需求，例如我们启动应用的时候，一开始呈现的是一个引导页面，过了两三秒后，会自动跳转到主界面。这就是一个延时操作。下面是实现延时执行操作的几种方法： 使用线程的休眠实现延时操作new Thread() &#123; @Override public void run() &#123; super.run(); Thread.sleep(3000);//休眠3秒 /** * 要执行的操作 */ &#125; &#125;.start(); 使用TimerTask实现延时操作**TimerTask task = new TimerTask() &#123; @Override public void run() &#123; /** *要执行的操作 */ &#125; &#125;; Timer timer = new Timer(); timer.schedule(task, 3000);//3秒后执行TimeTask的run方法 使用Handler的postDelayed方法实现延时操作Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /** *要执行的操作 */ &#125; &#125;, 3000);//3秒后执行Runnable中的run方法]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android判断文件是否存在,新建、删除]]></title>
    <url>%2Fposts%2F547382f.html</url>
    <content type="text"><![CDATA[public static boolean fileIsExists(String fileName) &#123; File folder = new File(fileName); if (!folder.exists()) &#123; folder.mkdir(); &#125; &#125; //判断文件是否存在 public boolean fileIsExists(String strFile) &#123; try &#123; File f = new File(strFile); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true;&#125; /** * 要删除的文件夹的所在位置 */ public static void deleteFile(File file) &#123; if (file.isDirectory()) &#123; File[] files = file.listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; File f = files[i]; deleteFile(f); &#125;// file.delete();//如要保留文件夹，只删除文件，请注释这行 &#125; else if (file.exists()) &#123; file.delete(); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView中添加的HeadView隐藏时仍然占用空间的解决方法]]></title>
    <url>%2Fposts%2Fdf7e47f7.html</url>
    <content type="text"><![CDATA[今天在开发的时候遇到了一个ListView中添加的HeadView隐藏时仍然占用空间的解决方法； 具体问题如下：listView.addHeadView(headView); 但是在执行headView.setVisibility(View.GONE);后headView虽然隐藏了，但是仍然占用了空间； 解决方法： 在添加HeadView之前首先创建一个父布局parentView,即：LinearLayout parentView=new LinearLayout (Context context);parentView.addView(headView);listView.addHeadView(parentView); 之后再进行隐藏：//就可以实现以上所说的效果了。headView.setVisibility(View.GONE);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android APP分享微信小程序]]></title>
    <url>%2Fposts%2F83fb494f.html</url>
    <content type="text"><![CDATA[需求：APP端 将公司的微信小程序 分享至微信好友 最近，微信小程序比较火热，公司也在做这一块，目前公司的小程序都是由H5端开发的，我们Android端也接到一个任务，那就是Android端应支持微信小程序的分享，并且通过分享出去的小程序可以启动我们的APP； 今天我们先来完成：Android端应支持微信小程序的分享！！！ 分析： 微信开放平台SDK支持小程序类型分享，详见官方文档： https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317340&amp;token=&amp;lang=zh_CN a) 要求发起分享的App与小程序属于同一微信开放平台帐号； b) 支持分享小程序类型消息至好友会话，不支持“分享至朋友圈” “收藏”； c) 微信客户端版本要求：6.5.6及以上微信客户端版本，若客户端版本低于6.5.6，小程序类型分享将自动转成网页类型分享。开发者必须填写网页链接字段，确保低版本客户端能正常打开网页链接； d) 支持分享大图卡片样式，自定义图片建议长宽比是 5:4。6.5.9及以上版本微信客户端小程序类型分享使用大图卡片样式。 e)支持分享开发版/体验版小程序，为支持开发者调试，开发者工具包支持分享开发版/体验版小程序至微信，开发者可控制分享的小程序版本。 把文档看了一遍，发现限制是比较多的，但是功能实现还是很简单的，下面让我们开始吧！！！ 开发： 前期准备 小程序与APP主体账号绑定开发人员希望通过APP分享小程序，需要先将小程序与APP主体账号（即APP的微信开放平台账号）绑定，APP才具有分享对应小程序的能力。如果没有与主体账号绑定，分享时是报错的，如下图：​ 登录APP所在的微信开放平台：https://open.weixin.qq.com/绑定小程序 由上图可以看到，绑定小程序的数量是有限制的。我们点击【绑定小程序】按钮，打开的新页面 输入小程序开发的主账号和密码，输入验证码提交就可以了，然后再通过手机微信扫码验证一下。 绑定成功后，直接就能在绑定列表中看到已绑定的小程序！！！ 代码实现小程序端提供参数：miniProgram.userName="xxx"; //小程序IDminiProgram.path="pages/xxx/xxx"; //小程序路径 配置gradledependencies &#123; compile 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'&#125; 分享小程序的核心代码public void shareMinP(ShareMiniPModel shareModel)&#123; if (shareModel == null) return; WXMiniProgramObject miniProgramObj = new WXMiniProgramObject(); miniProgramObj.webpageUrl = shareModel.getWebPageUrl(); // 兼容低版本的网页链接 miniProgramObj.miniprogramType = shareModel.getMiniProgramType(); // 分享小程序版 正式版:0，测试版:1，体验版:2 miniProgramObj.userName = shareModel.getMiniId(); // 小程序原始id miniProgramObj.path = shareModel.getMiniPath(); // 小程序页面路径 localWXMediaMessage = new WXMediaMessage(miniProgramObj); localWXMediaMessage.title = shareModel.getTitle(); // 小程序消息title localWXMediaMessage.description = shareModel.getDescription(); // 详细描述 if (!TextUtils.isEmpty(shareModel.getImageUrl()))&#123; inflateImage(shareModel.getImageUrl(), new Callback() &#123; // 小程序图片 @Override public void onLoadingComplete(String s, View view, Bitmap bitmap) &#123; thumbBmp = bitmap; localWXMediaMessage.thumbData = bmpToByteArray(thumbBmp, true); if (localWXMediaMessage.thumbData.length &lt; 131072)&#123; WXsendReq(SendMessageToWX.Req.WXSceneSession, localWXMediaMessage); &#125; else &#123; LogUtils.e("分享小程序，缩略图不得超过128kb"); &#125; &#125; &#125;); &#125; else if (shareModel.getImageBitmap() != null)&#123; thumbBmp = shareModel.getImageBitmap(); localWXMediaMessage.thumbData = bmpToByteArray(thumbBmp, true); if (localWXMediaMessage.thumbData.length &lt; 131072)&#123; WXsendReq(SendMessageToWX.Req.WXSceneSession, localWXMediaMessage); &#125; else &#123; LogUtils.e("分享小程序，缩略图不得超过128kb"); &#125; &#125;&#125; Demo演示为了避免麻烦，我们直接下载使用官方Demo，在其源代码上直接修改，修改的内容主要如下： a. 包名（必须修改，使用你项目APP的实际包名） b. 配置gradle（微信sdk包、签名文件） c. 增加分享小程序的按钮和事件 下载微信开放平台官方Demo https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_Android.zip 修改包名 使用Androidstudio打开demo，目录结构如下图，修改其包名 如上图，取消compact empty middle packages的默认选中在对应包名的文件夹上，直接右键修改名称，改成包名对应的名称，并全部应用可参考：https://www.jianshu.com/p/557e1906db1a修改后的包名，必须是你项目APP的实际包名，且已通过微信开放平台审核的APP包名； 配置gradle（修改依赖、修改签名） 签名必须使用你项目APP对应的签名文件，即你申请微信开放平台时APP对应的签名文件； 修改APP_IDpublic class Constants &#123; // APP_ID 替换为你的应用从官方网站申请到的合法appId public static final String APP_ID = "wxf666676666636666"; public static class ShowMsgActivity &#123; public static final String STitle = "showmsg_title"; public static final String SMessage = "showmsg_message"; public static final String BAThumbData = "showmsg_thumb_data"; &#125;&#125; 增加分享小程序的按钮和事件 测试 选择分享的人员 收到分享的小程序卡片]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android判断当前应用是否开启消息通知]]></title>
    <url>%2Fposts%2F7299f542.html</url>
    <content type="text"><![CDATA[当APP有推送功能时，需要判断当前app在手机中是否开启了允许消息推送，否则即使添加了推送代码仍然收不到通知 /** * 判断通知权限是否打开 */public static boolean isNotificationEnable(Context context) &#123; String CHECK_OP_NO_THROW = "checkOpNoThrow"; String OP_POST_NOTIFICATION = "OP_POST_NOTIFICATION"; AppOpsManager mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; Class appOpsClass = null; /* Context.APP_OPS_MANAGER */ try &#123; appOpsClass = Class.forName(AppOpsManager.class.getName()); Method checkOpNoThrowMethod = appOpsClass.getMethod(CHECK_OP_NO_THROW, Integer.TYPE, Integer.TYPE, String.class); Field opPostNotificationValue = appOpsClass.getDeclaredField(OP_POST_NOTIFICATION); int value = (Integer) opPostNotificationValue.get(Integer.class); return ((Integer) checkOpNoThrowMethod.invoke(mAppOps, value, uid, pkg) == AppOpsManager.MODE_ALLOWED); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false;&#125;/** * 设置消息通知 * @param context */public static void gotoSetNotification(Context context) &#123; Intent intent = new Intent(); if (Build.VERSION.SDK_INT &gt;= 26) &#123; // android 8.0引导 intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("android.provider.extra.APP_PACKAGE", context.getPackageName()); &#125; else if (Build.VERSION.SDK_INT &gt;= 21) &#123; // android 5.0-7.0 intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("app_package", context.getPackageName()); intent.putExtra("app_uid", context.getApplicationInfo().uid); &#125; else &#123; // 其他 intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); intent.setData(Uri.fromParts("package", context.getPackageName(), null)); &#125; intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent);&#125; Activity的onCreate中进行判断： //判断该app是否打开了通知，如果没有的话就打开手机设置页面 if (!isNotificationEnabled()) &#123; gotoSetNotification(); &#125; else &#123; //当前app允许消息通知 &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Snackbar的使用]]></title>
    <url>%2Fposts%2F30a2bcae.html</url>
    <content type="text"><![CDATA[Snackbar是design support library中的组件的其中之一，它的使用效果与Toast类似，但更加灵活Snackbar拥有的特性： 显示一段时间或当用户与之进行交互后，会自动消失 通过CoordinatorLayout可以实现向右滑动消除Snackbar的效果 同一时间只能显示一个Snackbar 与Toast类似地使用LENGTH_LONG 和 LENGTH_SHORT设置显示时间 提供Action属性供添加点击事件监听 提供回调函数可以对Snackbar进行监听 想要使用Snackbar，首先需要添加com.android.support:design依赖项 一、 Snackbar的最简单用法是和Toast一样声明Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT).show(); 大部分属性与Toast相同，不过第一个参数传入的不是Context，而应该是一个View，因为Snackbar需要一个控件容器用来容纳自身，这里使用一个TextView所以，主布局文件可修改为 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="Snackbar" /&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="点击按钮" /&gt;&lt;/LinearLayout&gt; MainActivity 修改为如下所示，当点击了Button后弹出Snackbar public class MainActivity extends AppCompatActivity &#123; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.text); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 二、 此外，Snackbar可以通过Action来与之进行交互button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .show(); &#125; &#125;); 三、 官方推荐使用CoordinatorLayout作为Snackbar的容纳容器，这样就可以实现向右滑动消除Snackbar的效果将主布局文件修改为 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id="@+id/layoutRoot" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="按钮" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/LinearLayout&gt; MainActivity 文件修改为 public class MainActivity extends AppCompatActivity &#123; private CoordinatorLayout layout; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); layout = (CoordinatorLayout) findViewById(R.id.layoutRoot); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .show(); &#125; &#125;); &#125;&#125; 四、 可以设置Snackbar的出现消失监听函数在Snackbar出现和消失时分别弹出一个Toast进行提示 button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this, "消失了", Toast.LENGTH_SHORT).show(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Toast.makeText(MainActivity.this, "出现了", Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(); &#125; &#125;); 五、改变Snackbar的背景色想要设置Snackbar的背景色，就要通过getView()方法了，这里Snackbar需要换一种声明方式 button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar snackbar = Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT); //设置背景色 snackbar.getView().setBackgroundColor(Color.parseColor("#375ED1")); snackbar.show(); &#125; &#125;); 六、Snackbar不一定只能从屏幕底端出现Snackbar会沿着View 的树状路径，找到第一个合适的布局或窗口视图，作为父 View因此，我们可以改变Snackbar的父View位置，从而改变Snackbar的出现位置修改主布局文件，将屏幕平均分为上下两个空间 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id="@+id/layoutRoot" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="按钮" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="#adc"&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View坐标详解]]></title>
    <url>%2Fposts%2Fbc32efd9.html</url>
    <content type="text"><![CDATA[转：https://blog.csdn.net/yanbober/article/details/50419117 背景学习自定义控件以此为基础，先总结一下自定义控件的一个核心知识点——坐标系。 很多人可能不屑一顾Android的坐标系，但是如果你想彻底学会自定义控件，我想说了解Android各种坐标系及一些API的坐标含义绝对算一个小而不可忽视的技能；所谓Android自定义View那几大主要onXXX()方法的重写实质其实大多数都是在处理坐标逻辑运算，所以我们就先来就题重谈一下Android坐标系。 android坐标系说到Android坐标系其实就是一个三维坐标，Z轴向上，X轴向右，Y轴向下。这三维坐标的点处理就能构成Android丰富的界面或者动画等效果，所以Android坐标系在整个Android界面中算是盖楼房的尺寸草图，下面我们就来看看这些相关的概念。 android屏幕区域划分我们先看一副图来了解一下Android屏幕的区域划分 通过上图我们可以很直观的看到Android对于屏幕的划分定义。下面我们就给出这些区域里常用区域的一些坐标或者度量方式。如下： //获取屏幕区域的宽高等尺寸获取DisplayMetrics metrics = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(metrics);int widthPixels = metrics.widthPixels;int heightPixels = metrics.heightPixels; //应用程序App区域宽高等尺寸获取Rect rect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect); //获取状态栏高度Rect rect= new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);int statusBarHeight = rectangle.top; //View布局区域宽高等尺寸获取Rect rect = new Rect(); getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect); 特别注意：上面这些方法最好在Activity的onWindowFocusChanged ()方法或者之后调运，因为只有这时候才是真正的显示OK，不懂的可以看我之前关于setContentView相关的博客。 android view绝对相对坐标系上面我们分析了Android屏幕的划分，可以发现我们平时开发的重点其实都在关注View布局区域，那么下面我们就来细说一下View区域相关的各种坐标系。先看下面这幅图： 通过上图我们可以很直观的给出View一些坐标相关的方法解释，不过必须要明确的是上面这些方法必须要在layout之后才有效，如下： View的静态坐标方法 解释 getLeft() 返回View自身左边到父布局左边的距离 getTop() 返回View自身顶边到父布局顶边的距离 getRight() 返回View自身右边到父布局左边的距离 getBottom() 返回View自身底边到父布局顶边的距离 getX() 返回值为getLeft()+getTranslationX()，当setTranslationX()时getLeft()不变，getX()变。 getY() 返回值为getTop()+getTranslationY()，当setTranslationY()时getTop()不变，getY()变。 同时也可以看见上图中给出了手指触摸屏幕时MotionEvent提供的一些方法解释，如下： MotionEvent坐标方法 解释 getX() 当前触摸事件距离当前View左边的距离 getY() 当前触摸事件距离当前View顶边的距离 getRawX() 当前触摸事件距离整个屏幕左边的距离 getRawY() 当前触摸事件距离整个屏幕顶边的距离 上面就解释了你在很多代码中看见各种getXXX方法进行数学逻辑运算判断的含义。不过上面只是说了一些相对静止的Android坐标点关系，下面我们来看看几个和上面方法紧密相关的View方法。如下： View宽高方法 解释 getWidth() layout后有效，返回值是mRight-mLeft，一般会参考measure的宽度（measure可能没用），但不是必须的。 getHeight() layout后有效，返回值是mBottom-mTop，一般会参考measure的高度（measure可能没用），但不是必须的。 getMeasuredWidth() 返回measure过程得到的mMeasuredWidth值，供layout参考，或许没用。 getMeasuredHeight() 返回measure过程得到的mMeasuredHeight值，供layout参考，或许没用。 上面解释了自定义View时各种获取宽高的一些含义，下面我们再来看看关于View获取屏幕中位置的一些方法，不过这些方法需要在Activity的onWindowFocusChanged ()方法之后才能使用。如下图： 下面我们就给出上面这幅图涉及的View的一些坐标方法的结果（结果采用使用方法返回的实际坐标，不依赖上面实际绝对坐标转换，上面绝对坐标只是为了说明例子中的位置而已），如下： View的方法 上图View1结果 上图View2结果 结论描述 getLocalVisibleRect() (0, 0 - 410, 100) (0, 0 - 410, 470) 获取View自身可见的坐标区域，坐标以自己的左上角为原点(0,0)，另一点为可见区域右下角相对自己(0,0)点的坐标，其实View2当前height为550，可见height为470。 getGlobalVisibleRect() (30, 100 - 440, 200) (30, 250 - 440, 720) 获取View在屏幕绝对坐标系中的可视区域，坐标以屏幕左上角为原点(0,0)，另一个点为可见区域右下角相对屏幕原点(0,0)点的坐标。 getLocationOnScreen() (30, 100) (30, 250) 坐标是相对整个屏幕而言，Y坐标为View左上角到屏幕顶部的距离。 getLocationInWindow() (30, 100) (30, 250) 如果为普通Activity则Y坐标为View左上角到屏幕顶部（此时Window与屏幕一样大）；如果为对话框式的Activity则Y坐标为当前Dialog模式Activity的标题栏顶部到View左上角的距离。 到此常用的相关View的静态坐标获取处理的方法和含义都已经叙述完了，下面我们看看动态的一些解释（所谓动静只是我个人称呼而已）。 Android View动画相关坐标系其实在我们使用动画时，尤其是补间动画时，你会发现其中涉及很多坐标参数，一会儿为相对的，一会儿为绝对的，你可能会各种蒙圈。那么不妨看下《Android应用开发之所有动画使用详解 》这篇博客，这里面详细介绍了关于Android动画相关的坐标系统，这里不再累赘叙述。 Android View滑动相关坐标系关于View提供的与坐标息息相关的另一组常用的重要方法就是滚动或者滑动相关的，下面我们给出相关的解释（特别注意：View的scrollTo()和scrollBy()是用于滑动View中的内容，而不是改变View的位置；改变View在屏幕中的位置可以使用offsetLeftAndRight()和offsetTopAndBottom()方法，他会导致getLeft()等值改变。），如下： View的滑动方法 效果及描述 offsetLeftAndRight(int offset) 水平方向挪动View，offset为正则x轴正向移动，移动的是整个View，getLeft()会变的，自定义View很有用。 offsetTopAndBottom(int offset) 垂直方向挪动View，offset为正则y轴正向移动，移动的是整个View，getTop()会变的，自定义View很有用。 scrollTo(int x, int y) 将View中内容（不是整个View）滑动到相应的位置，参考坐标原点为ParentView左上角，x，y为正则向xy轴反方向移动，反之同理。 scrollBy(int x, int y) 在scrollTo()的基础上继续滑动xy。 setScrollX(int value) 实质为scrollTo()，只是只改变Y轴滑动。 setScrollY(int value) 实质为scrollTo()，只是只改变X轴滑动。 getScrollX()/getScrollY() 获取当前滑动位置偏移量。 关于Android View的scrollBy()和scrollTo()参数传递正数却向坐标系负方向移动的特性可能很多人都有疑惑，甚至是死记结论，这里我们简单给出产生这种特性的真实原因—-源码分析，如下： public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; View的该方法注释里明确说明了调运他会触发onScrollChanged()和invalidated()方法，那我们就将矛头转向invalidated()方法触发的draw()过程，draw()过程中最终其实会触发下面的invalidate()方法，如下： public void invalidate(int l, int t, int r, int b) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; //scroller时为何参数和坐标反向的真实原因 invalidateInternal(l - scrollX, t - scrollY, r - scrollX, b - scrollY, true, false);&#125; 核心就在这里，相信不用我解释大家也知道咋回事了，自行脑补。 scrollTo()和scrollBy()方法特别注意：如果你给一个ViewGroup调用scrollTo()方法滚动的是ViewGroup里面的内容，如果想滚动一个ViewGroup则再给他嵌套一个外层，滚动外层即可。 总结可以发现，上面只是说明了一些View里常用的与坐标相关的概念，关于自定义控件了解学习这些坐标概念只是一个基础，也是一个后续内容的铺垫，所以有必要先完全吃透此部分内容才能继续拓展学习新的东东。 View中还有一些其他与坐标获取相关的方法，但是一般都比较不常用，所以用到时可以现查API或者Debug看现象进行学习即可，这里篇幅和时间有限就不一一道来了。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 控件 RecyclerView]]></title>
    <url>%2Fposts%2F4fcbe74a.html</url>
    <content type="text"><![CDATA[转自：https://www.jianshu.com/p/4f9591291365 概述RecyclerView是什么从Android 5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecylerView，可以用来代替传统的ListView，更加强大和灵活。RecyclerView的官方定义如下： A flexible view for providing a limited window into a large data set. 从定义可以看出，flexible（可扩展性）是RecyclerView的特点。 RecyclerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字Recyclerview即回收view也可以看出。 RecyclerView的优点RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如横向滚动的ListView, 横向滚动的GridView, 瀑布流控件，因为RecyclerView能够实现所有这些功能。 比如：有一个需求是屏幕竖着的时候的显示形式是ListView，屏幕横着的时候的显示形式是2列的GridView，此时如果用RecyclerView，则通过设置LayoutManager一行代码实现替换。 RecylerView相对于ListView的优点罗列如下： RecyclerView封装了viewholder的回收复用，也就是说RecyclerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。 直接省去了listview中convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。 提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。 设置布局管理器以控制Item的布局方式，横向、竖向以及瀑布流方式 例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还StaggeredGridLayoutManager等)。也就是说RecyclerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。 可设置Item的间隔样式（可绘制） 通过继承RecyclerView的ItemDecoration这个类，然后针对自己的业务需求去书写代码。 可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。 但是关于Item的点击和长按事件，需要用户自己去实现。 基本使用recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this ); //设置布局管理器 recyclerView.setLayoutManager(layoutManager); //设置为垂直布局，这也是默认的 layoutManager.setOrientation(OrientationHelper. VERTICAL); //设置Adapter recyclerView.setAdapter(recycleAdapter); //设置分隔线 recyclerView.addItemDecoration( new DividerGridItemDecoration(this )); //设置增加或删除条目的动画 recyclerView.setItemAnimator( new DefaultItemAnimator()); 在使用RecyclerView时候，必须指定一个适配器Adapter和一个布局管理器LayoutManager。适配器继承RecyclerView.Adapter类，具体实现类似ListView的适配器，取决于数据信息以及展示的UI。布局管理器用于确定RecyclerView中Item的展示方式以及决定何时复用已经不可见的Item，避免重复创建以及执行高成本的findViewById()方法。 可以看见RecyclerView相比ListView会多出许多操作，这也是RecyclerView灵活的地方，它将许多动能暴露出来，用户可以选择性的自定义属性以满足需求。 基本使用引用在build.gradle文件中引入该类。 compile &apos;com.android.support:recyclerview-v7:23.4.0&apos; 布局Activity布局文件activity_rv.xml … Item的布局文件item_1.xml … 创建适配器标准实现步骤如下： ① 创建Adapter：创建一个继承RecyclerView.Adapter的Adapter类（VH是ViewHolder的类名） ② 创建ViewHolder：在Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，记为VH。ViewHolder的实现和ListView的ViewHolder实现几乎一样。 ③ 在Adapter中实现3个方法： onCreateViewHolder()这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。 需要注意的是在onCreateViewHolder()中，映射Layout必须为 View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false); 而不能是： View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, null); onBindViewHolder()这个方法主要用于适配渲染数据到View中。方法提供给你了一viewHolder而不是原来的convertView。 getItemCount()这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。 可以看出，RecyclerView将ListView中getView()的功能拆分成了onCreateViewHolder()和onBindViewHolder()。 基本的Adapter实现如下： // ① 创建Adapterpublic class NormalAdapter extends RecyclerView.Adapter&lt;NormalAdapter.VH&gt;&#123; //② 创建ViewHolder public static class VH extends RecyclerView.ViewHolder&#123; public final TextView title; public VH(View v) &#123; super(v); title = (TextView) v.findViewById(R.id.title); &#125; &#125; private List&lt;String&gt; mDatas; public NormalAdapter(List&lt;String&gt; data) &#123; this.mDatas = data; &#125; //③ 在Adapter中实现3个方法 @Override public void onBindViewHolder(VH holder, int position) &#123; holder.title.setText(mDatas.get(position)); holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //item 点击事件 &#125; &#125;); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; @Override public VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; //LayoutInflater.from指定写法 View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false); return new VH(v); &#125;&#125; 设置RecyclerView创建完Adapter，接着对RecyclerView进行设置，一般来说，需要为RecyclerView进行四大设置，也就是后文说的四大组成： Layout Manager(必选) Adapter(必选) Item Decoration(可选，默认为空) Item Animator(可选，默认为DefaultItemAnimator) 如果要实现ListView的效果，只需要设置Adapter和Layout Manager，如下： List&lt;String&gt; data = initData();RecyclerView rv = (RecyclerView) findViewById(R.id.rv);rv.setLayoutManager(new LinearLayoutManager(this));rv.setAdapter(new NormalAdapter(data)); 四大组成RecyclerView的四大组成是： Layout Manager：Item的布局。 Adapter：为Item提供数据。 Item Decoration：Item之间的Divider。 Item Animator：添加、删除Item动画。 Layout Manager布局管理器在最开始就提到，RecyclerView 能够支持各种各样的布局效果，这是 ListView 所不具有的功能，那么这个功能如何实现的呢？其核心关键在于 RecyclerView.LayoutManager 类中。从前面的基础使用可以看到，RecyclerView 在使用过程中要比 ListView 多一个 setLayoutManager 步骤，这个 LayoutManager 就是用于控制我们 RecyclerView 最终的展示效果的。 LayoutManager负责RecyclerView的布局，其中包含了Item View的获取与回收。 RecyclerView提供了三种布局管理器： LinerLayoutManager 以垂直或者水平列表方式展示Item GridLayoutManager 以网格方式展示Item StaggeredGridLayoutManager 以瀑布流方式展示Item 如果你想用 RecyclerView 来实现自己自定义效果，则应该去继承实现自己的 LayoutManager，并重写相应的方法，而不应该想着去改写 RecyclerView。 LayoutManager 常见 API关于 LayoutManager 的使用有下面一些常见的 API（有些在 LayoutManager 实现的子类中） canScrollHorizontally();//能否横向滚动canScrollVertically();//能否纵向滚动scrollToPosition(int position);//滚动到指定位置setOrientation(int orientation);//设置滚动的方向getOrientation();//获取滚动方向findViewByPosition(int position);//获取指定位置的Item ViewfindFirstCompletelyVisibleItemPosition();//获取第一个完全可见的Item位置findFirstVisibleItemPosition();//获取第一个可见Item的位置findLastCompletelyVisibleItemPosition();//获取最后一个完全可见的Item位置findLastVisibleItemPosition();//获取最后一个可见Item的位置 上面仅仅是列出一些常用的 API 而已，更多的 API 可以查看官方文档，通常你想用 RecyclerView 实现某种效果，例如指定滚动到某个 Item 位置，但是你在 RecyclerView 中又找不到可以调用的 API 时，就可以跑到 LayoutManager 的文档去看看，基本都在那里。 另外还有一点关于瀑布流布局效果 StaggeredGridLayoutManager 想说的，看到网上有些文章写的示例代码，在设置了 StaggeredGridLayoutManager 后仍要去 Adapter 中动态设置 View 的高度，才能实现瀑布流，这种做法是完全错误的，之所以 StaggeredGridLayoutManager 的瀑布流效果出不来，基本是 item 布局的 xml 问题以及数据问题导致。如果要在 Adapter 中设置 View 的高度，则完全违背了 LayoutManager 的设计理念了。 LinearLayoutManager源码分析 这里我们简单分析LinearLayoutManager的实现。 对于LinearLayoutManager来说，比较重要的几个方法有： onLayoutChildren(): 对RecyclerView进行布局的入口方法。 fill(): 负责填充RecyclerView。 scrollVerticallyBy():根据手指的移动滑动一定距离，并调用fill()填充。 canScrollVertically()或canScrollHorizontally(): 判断是否支持纵向滑动或横向滑动。 onLayoutChildren()的核心实现如下： public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; detachAndScrapAttachedViews(recycler); //将原来所有的Item View全部放到Recycler的Scrap Heap或Recycle Pool fill(recycler, mLayoutState, state, false); //填充现在所有的Item View&#125; RecyclerView的回收机制有个重要的概念，即将回收站分为Scrap Heap和Recycle Pool，其中Scrap Heap的元素可以被直接复用，而不需要调用onBindViewHolder()。detachAndScrapAttachedViews()会根据情况，将原来的Item View放入Scrap Heap或Recycle Pool，从而在复用时提升效率。 fill()是对剩余空间不断地调用layoutChunk()，直到填充完为止。layoutChunk()的核心实现如下： public void layoutChunk() &#123; View view = layoutState.next(recycler); //调用了getViewForPosition() addView(view); //加入View measureChildWithMargins(view, 0, 0); //计算View的大小 layoutDecoratedWithMargins(view, left, top, right, bottom); //布局View&#125; 其中next()调用了getViewForPosition(currentPosition)，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，在后文的回收机制中会介绍该方法的具体实现。 如果要自定义LayoutManager，可以参考： 创建一个 RecyclerView LayoutManager – Part 1 创建一个 RecyclerView LayoutManager – Part 2 创建一个 RecyclerView LayoutManager – Part 3 Adapter适配器Adapter的使用方式前面已经介绍了，功能就是为RecyclerView提供数据，这里主要介绍万能适配器的实现。其实万能适配器的概念在ListView就已经存在了，即base-adapter-helper。 这里我们只针对RecyclerView，聊聊万能适配器出现的原因。为了创建一个RecyclerView的Adapter，每次我们都需要去做重复劳动，包括重写onCreateViewHolder(),getItemCount()、创建ViewHolder，并且实现过程大同小异，因此万能适配器出现了。 万能适配器这里讲解下万能适配器的实现思路。 我们通过public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;定义万能适配器QuickAdapter类，T是列表数据中每个元素的类型，QuickAdapter.VH是QuickAdapter的ViewHolder实现类，称为万能ViewHolder。 首先介绍QuickAdapter.VH的实现： static class VH extends RecyclerView.ViewHolder&#123; private SparseArray&lt;View&gt; mViews; private View mConvertView; private VH(View v)&#123; super(v); mConvertView = v; mViews = new SparseArray&lt;&gt;(); &#125; public static VH get(ViewGroup parent, int layoutId)&#123; View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false); return new VH(convertView); &#125; public &lt;T extends View&gt; T getView(int id)&#123; View v = mViews.get(id); if(v == null)&#123; v = mConvertView.findViewById(id); mViews.put(id, v); &#125; return (T)v; &#125; public void setText(int id, String value)&#123; TextView view = getView(id); view.setText(value); &#125;&#125; 其中的关键点在于通过SparseArray&lt;View&gt;存储item view的控件，getView(int id)的功能就是通过id获得对应的View（首先在mViews中查询是否存在，如果没有，那么findViewById()并放入mViews中，避免下次再执行findViewById()）。 QuickAdapter的实现如下： public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;&#123; private List&lt;T&gt; mDatas; public QuickAdapter(List&lt;T&gt; datas)&#123; this.mDatas = datas; &#125; public abstract int getLayoutId(int viewType); @Override public VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; return VH.get(parent,getLayoutId(viewType)); &#125; @Override public void onBindViewHolder(VH holder, int position) &#123; convert(holder, mDatas.get(position), position); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; public abstract void convert(VH holder, T data, int position); static class VH extends RecyclerView.ViewHolder&#123; private SparseArray&lt;View&gt; mViews; private View mConvertView; private VH(View v)&#123; super(v); mConvertView = v; mViews = new SparseArray&lt;&gt;(); &#125; public static VH get(ViewGroup parent, int layoutId)&#123; View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false); return new VH(convertView); &#125; public &lt;T extends View&gt; T getView(int id)&#123; View v = mViews.get(id); if(v == null)&#123; v = mConvertView.findViewById(id); mViews.put(id, v); &#125; return (T)v; &#125; public void setText(int id, String value)&#123; TextView view = getView(id); view.setText(value); &#125; &#125;&#125; 其中： getLayoutId(int viewType)是根据viewType返回布局ID。 convert()做具体的bind操作。 就这样，万能适配器实现完成了。 通过万能适配器能通过以下方式快捷地创建一个Adapter： mAdapter = new QuickAdapter&lt;String&gt;(data) &#123; @Override public int getLayoutId(int viewType) &#123; return R.layout.item; &#125; @Override public void convert(VH holder, String data, int position) &#123; holder.setText(R.id.text, data); //holder.itemView.setOnClickListener(); 此处还可以添加点击事件 &#125;&#125;; 是不是很方便。当然复杂情况也可以轻松解决。 mAdapter = new QuickAdapter&lt;Model&gt;(data) &#123; @Override public int getLayoutId(int viewType) &#123; switch(viewType)&#123; case TYPE_1: return R.layout.item_1; case TYPE_2: return R.layout.item_2; &#125; &#125; @Override public int getItemViewType(int position) &#123; if(position % 2 == 0)&#123; return TYPE_1; &#125; else&#123; return TYPE_2; &#125; &#125; @Override public void convert(VH holder, Model data, int position) &#123; int type = getItemViewType(position); switch(type)&#123; case TYPE_1: holder.setText(R.id.text, data.text); break; case TYPE_2: holder.setImage(R.id.image, data.image); break; &#125; &#125;&#125;; 结论 在一些场景下，如界面初始化，滑动等，ListView和RecyclerView都能很好地工作，两者并没有很大的差异： 数据源频繁更新的场景，如弹幕：http://www.jianshu.com/p/2232a63442d6等RecyclerView的优势会非常明显； 进一步来讲，结论是： 列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。 扩展阅读 Google I/O 2016: RecyclerView Ins and Outs RecyclerView优秀文章集 引用： ★★★★RecyclerView 必知必会 ★★★★Android ListView 与 RecyclerView 对比浅析–缓存机制 ★★★RecyclerView使用完全指南，是时候体验新控件了（一） ★★★RecyclerView使用完全指南，是时候体验新控件了（二） 一篇博客理解Recyclerview的使用 RecyclerView使用全解析 Demo地址： RecyclerView基本用法 RecyclerViewDemo Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。 Demo2: ListView实现局部刷新。 Demo3: RecyclerView实现拖拽、侧滑删除。 Demo4: RecyclerView闪屏问题。 Demo5: RecyclerView实现setEmptyView()。 Demo6: RecyclerView实现万能适配器，瀑布流布局，嵌套滑动机制。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向忙碌开发者的Android]]></title>
    <url>%2Fposts%2F793c26e.html</url>
    <content type="text"><![CDATA[面向忙碌开发者的 Android 视频教程（Tuts+） Android 开发资源列表（Sharif Ahmed） 我如何在23天内开发了一款 Android 游戏？（Bigosaur） Android 学习教程 Android Bootstrap [PDF] Android 性能小贴士（Romain Guy &amp; Chet Haase） [PDF] Android 应用中使用 Dagger（Jake Wharton） Android 应用性能优化 《Android 测试与调试实战》参考资料（@施懿民） [视频] Android 入门教程（@多贝公开课） Android 测试入门（Corey Scott） Android 事件传递机制（@唐韧_Ryan） [PDF] Android 开发技巧新整理（@51CTO技术社区） AndroidQuery - 一个处理异步任务的开源项目（Peter Liu） Android 开发者必备的42个链接（Mikail） 一些有用的 Android adb 命令（Daniel Imms） Android 布局优化（@唐韧_Ryan） 系列文章：前端之 Android 入门 (ct) Android 设计指南非官方简体中文版 系列教程：开发你的第一个 Android 应用 (Matt Luedke) 写给 iOS 开发者的 Android 教程 (Stuart Hall) [slide] Android 函数响应式编程 (Yaroslav Heriatovych) 面向 iOS 开发者的 Android 系列教程 [译] Android 通知中心（@唯木念） 使用 Android API 最佳实践 (MeetMe) 《50 Android Hacks》读书笔记 (Vector_Yi) [译] 响应式 Android 应用 (Daisyyaya) Android 开源项目分类汇总 (@Trinea) 系列文章：Android 开发小贴士 (Dan Lew) Android Arsenal - 一个 Android 学习资源网站 [译] Android 开发者必知的 5 个开源库（刘璐璐） SEAndroid 安全机制简要介绍和学习计划（@罗升阳） Material Design 中文版 Android 学习之路 (@googdev) SEAndroid 安全机制对 Binder IPC 的保护分析（罗升阳） 最流行的 Android 组件大全 (@colobu) [译] 2014 年 Android 碎片化报告 (boxi) 系列文章：Android UI 开发（@张兴业TBOW） Android 插件化 (@Trinea) [代码] 模仿 QQ 讨论组头像（@网易孔楠） Android 中 Java 和 JavaScript 交互 (androidyue) [视频合辑] 3 个月系统学习 Android 开发（极客学院） 正确使用 Android 性能分析工具——TraceView (@白瓦力) [译] 理解 Android 中垃圾回收日志信息 (@Android月) 放弃 WebView，使用 Crosswalk 做富文本编辑器 (GavinCT) 教你用 Visual Studio 2015 做 Android 应用 十大 Material Design 开源项目 (唐小引) Android Studio 系列教程 (@googdev) 创新、严肃、好玩的 Android 应用程序开发 Android 批量打包提速 (@GavinCT) 学 Android 开发仅用 3 个月，就是这么任性！ 代码规范和 Android 项目中的一些可用工具 (刘聪) 学 Android 开发仅用 3 个月，就是这么任性！ [译] Android 性能优化课程（一）：渲染性能 (@刘智勇同学) Java for Android Android 性能优化典范 (@胡凯me) Context-Menu.Android - Android 动画上下文菜单 (Yalantis) 大量 Material Design 学习资源 (@light_sky) 系列文章：50 个 Android 开发技巧 (fwy19930618) Android 开发教程大全（视频 + 源码） Android 开源项目源码解析 (android-cn) 深聊 Material Design 复杂响应式设计 Navigation drawer - 一个 Material Design 的抽屉式导航库 (Rudson Lima) Android 开发最佳实践 使用 Chrome 调试 Android App (@googdev) [译] 一次 Material Design 的设计探索 (郭楠) 系列文章：全面理解 Android 安全机制 (@stackvoid) [译] 关于 Material Design 你需要知道的一切 (DATS设计翻译组) Android 源码设计模式分析 (@MrSimp1e) [译] Android xUtils 源码解析 (@code-KK) [译] Android 性能优化后续 (@高建武_Gracker) 开源 Android 应用集锦 (Joker) Fresco - 一个强大的 Android 应用图片管理库 (Facebook) Euclid - 一个用户 Profile 界面动画的 Android 实现 (Yalantis) [译] 使用 Kotlin 创建一个 Android 应用 (Lollypo) 系列文章：Android 内存优化 (@高建武_Gracker) 深入理解 Android 中的自定义属性 (鸿洋_) Android 性能优化之内存篇 (@胡凯me) 一堆 Android 开发资源链接 (Anirudh S) 《Android 开发学习路径图》2.0 版 [译] Android Lollipop 5.1.1 面世 (@MrSimp1e) [译] Instagram 是如何提升 TextView 渲染性能的？ (@archieyang) Android 应用内社区 SDK 技术架构浅析 (liubin) Android 性能优化典范（第 2 季） (@胡凯me) 系列译文：Android 的 MVP 模式开发 (shadev) 一个 Mac 上的 Android 工具 (mortenjust) SquiDB - 一个用于 Android 的 SQLite 数据库框架 系列译文：Android 研发工程师高级进阶 (asce1885) Android 加载不同 DPI 资源与内存消耗之间的关系 (Will) MaterialViewPager - 一个易于使用的 Material Design ViewPager 库 (florent37) Android RecyclerView 使用完全解析 (鸿洋_) Android 中的 MVP (@鄭曉鵬-Rocko) Material 适配（二）：高级篇 (@GavinCT) Anko - 一个让 Android 应用开发更快、更简单的库 Android 开发中，可能会导致内存泄露的问题 (@给立乐) Android 布局优化之 ViewStub、include、merge 使用与源码分析 (@MrSimp1e) 腾讯手机管家 Android 版实战分析：内存突增是为神马？ (腾讯Bugly) 大量 Material Design 学习资源 (@light_sky) Google I/O 2015 为 Android 开发者带来了哪些福利？ (代码家) 系列文章：Android 内核开发之系统编译输出的镜像文件 (@卢_俊) [译] MVP 框架 Ted Mosby 的软件架构（Android） (@MrSimp1e) FlyRefresh：超赞的刷新动画（Android） (@谢权1991) Android 系统架构之微服务架构 (MrSimple) Android 异步指南 (@alexhilton) Gradle Android Plugin 使用手册（中文版） (@ChaosLeong) Android 开发教程大全（视频 + 源码） [译] Material Design 开发利器：Android Design Support Library 介绍 Android UITestRunner - 一个非常简单的用于测试 UI 的单元测试框架 (chengkai) FlyRefresh：让人眼前一亮的下拉刷新 (Android笔记) 浅谈 MVP 实现 Android 应用层开发 (工匠若水) 教你写 Android 网络框架之基本架构 (@MrSimp1e) Android 实现速度仪，仪表盘效果 (谢权1991) Android Studio 新手完全指引 (ASCE1885) 教你写 Android 网络框架之 HTTP 请求的分发与执行 (@MrSimp1e) 美团 Android DEX 自动拆包及动态加载简介 (xijianshuai &amp; lixiaoyang) 短信验证码助手：一款新的开源轻 App（Android） (Dracut) SublimePicker：Android Material 风格时间选择器 (vikramkakkar) 使用 Kotlin 进行 Android 开发 (@RagnarokStack) Android 应用程序 UI 硬件加速渲染的动画执行过程分析 (@罗升阳) [译] Android 开发最佳实践 (andyiac) [译] Android Design Support Library 的代码实验 (MrFu) Android 开源项目源码解析（第二期） (@code-KK) [译] Android 中的帧动画 (jianghejie) 推荐几个有用的 Android Studio 插件和工具 (@googdev) Dexposed：阿里巴巴开源的无侵入运行期 AOP 框架（Android） 小米开源的内核源代码 很棒的下拉刷新项目 Android Ultra Pull To Refresh 源码解析 (grumoon) Android 应用使用自定义字体的一些探究 (@码农明明桑) 一个 Demo 学会用 Android 兼容包新控件 (@安卓猴) Android 常用开发工具以及 Mac 常用软件 (肥肥鱼) DynamicLoadApk 源码解析 (code-KK) InstalMaterial 学习笔记之 Reveal 效果 (程序亦非猿) 快速提高 Android 开发效率的 Web 工具 (@技术小黑屋) [译] Android UI 自动化测试 (DorisMinmin) 系列译文：使用 Kotlin 开发 Android 应用 (ASCE1885) 使用 Gradle 管理你的 Android Studio 工程 (飞雪无情) [译] 学习 Android 开发的二十套免费理想资源 (核子可乐) HTTPDNSLib - 一个支持 DNSPod D+ 和自定义 HttpDNS 服务的 HttpDNS SDK（Android） (SinaMSRE) 一个优秀的 Android 应用从建项目开始 (Jude95) [译] 检测和解决 Android 应用的性能问题 (@MrSimp1e) Android 中 TextView 预渲染研究 (RagnarokStack) Android 开发者的浏览器书签 (鄭曉鵬-Rocko) Android 代码内存优化建议：OnTrimMemory 优化 (Android Performance) Android APK 加固技术方案调研 (ASCE1885) 使用 Android lint 发现并解决高版本 API 问题 (技术小黑屋) Smalidea 无源码调试 Android 应用 (瘦蛟舞) 如果让我重新设计一款 Android App (aspook) 探究 android:largeHeap (技术小黑屋) 跟我一起写 EventBus（一） (mcxiaoke) 一步一步教你 150 行代码实现简书滑动返回效果 (程序亦非猿) Android Material Design 动画实现 (阳春面) Android Gradle 插件中文指南 (飞雪无情) Android 多渠道打包工具 Gradle 插件 (mcxiaoke) AWebDB 可以在浏览器操作 Android 数据库啦 (Bai) 一个上传 APK 到 fir 的 Gradle 插件 (码农明明桑) Cool Android Apis 整理（一） (@Oak_Zmm) Android 应用开发之所有动画使用详解 (@工匠若水) Android 视频录制 App 解决方案汇总 (老牛) 5 种优化你的 Android 5.0 Lollipop 代码的方法 Android 项目中如何用好构建神器 Gradle？ (寒江不钓) 通过蓝牙* LE (BLE) 从 Android 连接到英特尔 EDISON Android 平台免 Root 无侵入 AOP 框架 Dexposed 使用详解 (ASCE1885) BatchPackApk：Apk 批量快速打包工具 (MasonLiuChn) SlideBottomPanel：底部划出视图，轻松实现“知乎日报 β 版”效果 (NeXT___) CNode 社区第三方 Android 客户端 (TakWolf) 开源中国 Maven 库 一个超赞超全的 Android Library (Huqiu Liao) Android 性能优化典范（第 3 季） (@胡凯me) 最美应用：从 Android 研发工程师的角度之“厨房故事” (ASCE1885) [译] 深入讲解 Android 中 Activity launchMode (技术小黑屋) [译] Android 中的 AOP 编程 (byronwind) 面向 Android* 目标的英特尔 INDE OpenCV 入门 Android 技术文档翻译：工具属性 (飞雪无情) Jenkin + Git + Gradle 为 Android 项目搭建 CI 环境 (离星运动) Google Places for Android 入门指南 (@汤奇V) [英] Parse 开源其所有 SDK（Android &amp; iOS） (Nikita Lutsenko) xBus 使用指南 (mcxiaoke) LayoutCast：把代码和资源文件的改动直接同步到手机上，应用不需要重启 (mmin18) Android 6.0 中新的新技术 (@Android笔记) Android 诀窍：Layouts 与 Views (llitfk@DockOne) Android NestedScrolling 实战 (Android笔记) Android 反编译的工具和方法 (@杨剑同學) Next 库使用指南之 Core 模块（Android） (mcxiaoke) [译] CoordinatorLayout 与快速返回的实现（Android） (hejie) SimpleCropView - 一个简单的图片剪裁库（Android） (IsseiAoki) TransitionPlayer - 一个 Android 引导动画库 (XMFE-TEAM) 微信 Android 客户端：会话速度提升 70% 的背后 (charven) [译] 使用 TDD 的方式开发一个 Hacker News Android 客户端 (Anthonyeef) 改变 support 中 AlertDialog 的样式（Android） (码农明明桑) 为什么 Android 中不建议使用 Enums (Lusfold) Android 逆向工程工具集 (J.D.Song) DroidPlugin：360 手机助手在 Android 系统上实现的一种新的插件机制 (Qihoo360) Android Log 最佳实践 (@天之界线2010) 剖析 Android 中进程与线程调度之 nice (技术小黑屋) Android OkHttp 文件上传与下载的进度监听扩展 (lizhangqu) 基于英特尔架构使用 Linderdaum 引擎开发 C++ 安卓 NDK 游戏 (英特尔开发人员专区) 全平台反编译工具 Jadx (程序亦非猿) 积木：帮助你快速搭建属于自己的应用 (汤奇V) Android Tips：填坑必备 (汤奇V) React Native for Android on GitHub (Facebook) Android 图标资源生成器 (JuneLegency) XLog：Android 调试神器 (promeG) DecompileApk：一键反编译 APK，输出所有反编译后的代码、资源 (MasonLiuChn) Colorful：基于 Theme 的 Android 动态换肤库 (@MrSimp1e) Otto 事件总线框架的使用 (Sunzxyong) React Native For Android 初体验 (ASCE1885) Android 进程线程调度之 cgroups (技术小黑屋) Gradle 多渠道打包 (安卓猴) Android 项目收集 (snowdream) Android 性能优化视频、文档和工具收集 (J.D.Song) [译] Retrofit 2.0：有史以来最大的改进 (hejie) 深入讲解 WebView（上） (张涛) [译] Android 6.0 新特性详解（运行时权限、存储、电源管理） (黑山龘) Android 开发最佳实践 (@胡凯me) AndroidCat：Android 开发相关的网址导航 (大花猫) Android 仿搜狗浏览器加载动画 (@_邓士伟) StatusBarColor：Android 4.4+ 设置状态栏、导航栏颜色、侧滑菜单沉浸 (MasonLiuChn) KJBitmap 与 KJHttp 的深度用法 (张涛) App 启动加速，以及使用 FSA 来处理状态转换避免 Activity State Loss (Piasy) RecyclerView 的通用适配器，和滚动时不加载图片的封装 (张涛) Android GC 那点事 Android 性能优化学习小结 Android 6.0 Runtime Permission 测试 一步一步带你仿各大主流 App 地图定位移动选址功能（Android） KJFrameForAndroid 2.25 发布，支持 6.0 网络请求 很少有人会告诉你的 Android 开发基本常识 Android Handler 消息机制的理解 Android UI：机智的远程动态更新策略 Android 快速开发框架 FastDev4Android 介绍（一） [译] Android 架构演化之路 Android 项目重构之路（架构篇） Android 开发中，有哪些坑需要注意？ [译] 通过 Hardware Layer 提升 Android 动画性能 关于 Android Log 的一些思考 Android Support Library 23.1 的变化 AVLoadingIndicatorView：Android 加载动画合集 移植 C 程序到 Android MVVM_Android-CleanArchitecture Android 打包的那些事 Android 6.0 运行时权限处理 TextViewForFullHtml：对原生 TextView 解析 HTML 格式文本的增强 DynamicAPK：携程 App 的插件化和动态加载框架 #Kotlin# 你好怪兽 TraceView 自动化抓取方案实践 InteractiveCanvas：炫酷的跨屏幕 Canvas 动画 Android 快捷方式解密 Android 微信上的 Wear 的开发总结 Android 分辨率相关知识 Android 热更新实现原理 如何姿势正确地做一个充满果味的 Android 应用 再议携程 Android 动态加载框架 DynamicAPK Treasure - 一个 Android 平台上基于 SharePreferences 的偏好存储库 Nuwa：热修复你的 Android 应用 EasyImage：Android 图片选择控件 [译] 掌握 Coordinator Layout BlurImageView：实现类 Medium 的图片加载 天猫 Android App 线上热修复方案 Andriod 性能优化之列表卡顿：以“简书” APP 为例 AndroidAutoLayout：Android 屏幕适配方案 WXTabBarController：实现 Android 版微信 TabBar 的滑动切换功能（OC） EZScalpel：Android 视图层级查看利器 实践自定义 UI：RLF Backboard - 一个基于 Facebook Rebound 的动效框架 加快 Android 编译速度 如何开发一个 Android App dex 分包变形记 面向对象六大原则 1000 个 Android 开源项目集合 Gradle 脚本基础全攻略 stetho-js-rhino：Facebook Stetho 插件，为 Android 提供 JavaScript 调试窗口 记一次 ListView 性能优化过程 XhsParallaxWelcome：小红书欢迎引导页实现（第二版） 微信抢红包插件源码解析（Android） [译] 每个 Android 开发者都应该了解的资源列表 Android 图片选择器 OverscrollScale：仿小米列表拉伸效果（Android） [译] 使用 Systrace 分析 UI 性能 [译] 开发安全的 Android 应用 说说 Android 的 MVP 模式 面试时，问哪些问题能试出一个 Android 应用开发者真正的水平？ 动态 Android 编程 EventBus 源码研读（上） 使用 Picasso 加载图片的内存优化实践 高仿微信 JustWeEngine：Android 轻量级游戏框架 Android 下拉刷新开源库对比 Android View 总结 关于 Android 中工作者线程的思考 Android 6.0 系统学习之 JNI Android Studio 你不知道的调试技巧 Android 开发者站点资源 [PDF] 深入理解 Android 之 Dalvik Android 代码质量检查利器 用黑客思维做测试：神器 Xposed 框架介绍 Android 单元测试研究与实践 构建更高质量的 Android 应用：2015 Playtime 之 Build Better 2015 年十大热门 Android 开源新项目 Android 软键盘和 emoji 表情切换方案 PeriscopeLayout - 一个类似 Android Periscope 点赞效果的 Layout HTextView：Android TextView 动画效果 值得推荐的 Android 应用性能检测工具列表 Android 生态的破与立 AndResGuard：微信的 Android 资源混淆方案 GalleryFinal：史上最强的图片选择器（Android） Android 性能优化典范 Android targetSdkVersion 原理 Android Linker 学习笔记 Android 应用开发架构概述 [译] Android UI 性能优化详解 Android 平台的崩溃捕获机制及实现 Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？ BasePedo - 一个稳定的 Android 计步源代码 一个非官方版的干净的 “ONE • 一个” BrokenView：玻璃破碎的效果（Android） Small：强大的轻量级 Android 插件框架 Binder 学习指南]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xBus-简洁的EventBus实现]]></title>
    <url>%2Fposts%2F9105b80c.html</url>
    <content type="text"><![CDATA[Demo地址：MyXBus 基于发布订阅(Pub/Sub)模式的一个事件消息库，使用通用的 register(target), unregister(target), post(event) 消息通信接口，能有效的减少甚至消除Android应用中异步任务逻辑和界面更新之间的耦合，实现模块化，提高开发效率。 2015.09.15 1.0.2 - 修复多线程发送事件的同步问题 2015.08.18 1.0.1 - 修复 unresiger() 的空指针问题 2015.08.08 1.0.0 - 基本功能全部完成，发布1.0.0正式版 使用指南Gradle集成compile &apos;com.mcxiaoke.xbus:bus:1.0.+&apos; 接收事件public class SimpleActivity extends Activity &#123; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 注册 Bus.getDefault().register(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消注册 Bus.getDefault().unregister(this); &#125; @BusReceiver public void onStringEvent(String event) &#123; // handle your event // 这里处理事件 &#125; @BusReceiver public void onSomeEvent(SomeEventClass event) &#123; // SomeEventClass表示任意的自定义类 // handle your event // 这里处理事件 &#125; @BusReceiver public void onObjectEvent(Object event) &#123; // 不建议使用Object，会收到所有类型的事件 // handle your event // 这里处理事件 &#125;&#125; 发送事件然后在需要的地方调用 post(event) 发送事件通知，如 Service 或某个线程里，可以在任何地方发送事件： // 比如在IntentService里public class SimpleService extends IntentService &#123; public SimpleService() &#123; super("SimpleService"); &#125; @Override protected void onHandleIntent(final Intent intent) &#123; // 这里是举例，可以在任何地方发送事件 Bus.getDefault().post("String Event"); Bus.getDefault().post(new SomeEventClass()); Bus.getDefault().post(new Object()); &#125;&#125; 高级用法任何地方注册你还可以选择在 onStart() 里注册，在 onStop() 里取消注册。你完全可以在任何地方注册和取消注册，没有任何限制。但是建议你在生命周期事件方法里注册和取消注册，如 Activity/Fragment/Service 的 onCreate/onDestroy 方法里， register() 和 unregister() 建议配对使用，避免内存泄露。 @Overrideprotected void onStart() &#123; super.onStart(); // you can also register here Bus.getDefault().register(this);&#125;@Overrideprotected void onStop() &#123; super.onStop(); // you can also unregister here Bus.getDefault().unregister(this);&#125; 自定义 Bus你也可以不使用默认的 Bus.getDefault()，改用自己创建的 Bus 对象： public class MainApp extends Application &#123; private Bus mBus = new Bus(); @Override public void onCreate() &#123; super.onCreate(); &#125; public Bus getBus() &#123; return mBus; &#125;&#125; Debug默认不输出任何LOG信息，可以这样启用调试模式： public Bus setDebug(final boolean debug) MethodFinder默认使用注解(@BusReceiver)识别事件接收器方法，可以这样修改 ： public Bus setMethodFinder(final MethodFinder finder) 默认使用的是 AnnotationMethodFinder，只有使用了 @BusReceiver 的方法才可以接受事件。 可选使用 NamedMethodFinder ，NamedMethodFinder 使用方法名识别，默认方法名是 onEvent ，你可以指定其它的方法名。 使用 NamedMethodFinder 会比使用 AnnotationMethodFinder 效率高一点，因为它忽略注解，直接使用方法名字符串匹配。一般使用，两者差别不大。 你还可以实现 MethodFinder 接口，自定义其它的事件接收器方法匹配模式： interface MethodFinder &#123; Set&lt;MethodInfo&gt; find(final Bus bus, final Class&lt;?&gt; targetClass);&#125; StrictMode宽泛匹配模式默认情况下， Bus 使用宽泛的事件类型匹配模式，事件参数会匹配它的父类和接口，如果你调用 post(String)，那么这几个方法都会收到举例： // 如果你调用这个方法，发送一个StringBuilder类型的事件Bus.getDefault().post(new StringBuilder("Event"));// 这几个方法会收到事件public void onEvent1(StringBuilder event) // 匹配，类型相符public void onEvent2(Object event) // 匹配，StringBuilder是Object的子类public void onEvent3(CharSequence event) // 匹配，StringBuilder是CharSequence的实现类public void onEvent4(Serializable event) // 匹配，StringBuilder实现了Serializable接口// 这几个方法不会收到事件public void onEvent5(Exception event) 不匹配，Exception与String完全无关public void onEvent6(String event) // 不匹配，StringBuilder不能转换成String类型 对于 post(event) 和 onEvent(EventType) ，匹配规则是：如果 event.getClass() 可以强制转换成 EventType，那么匹配成功，能收到事件。 严格匹配模式可以使用下面的方法更改默认行为，使用严格的事件类型匹配模式： public Bus setStrictMode(final boolean strictMode) 启用严格匹配模式后，发送和接受方法的参数类型必须严格匹配才能收到事件，举例： // setStrictMode(true) 启用严格模式后：Bus.getDefault().post(new StringBuilder("Event"));// 只有 onEvent1 能收到事件public void onEvent1(StringBuilder event)public void onEvent2(Object event)public void onEvent3(CharSequence event)public void onEvent4(Serializable event)public void onEvent5(Exception event)public void onEvent6(String event) 对于 post(event) 和 onEvent(EventType) ，严格模式的匹配规则是当且仅当 event.getClass().equals(EventType) 时才能收到事件。 说明：启用严格模式效率会稍微高一点，因为不会递归查找 event 的父类和实现的接口，但是由于 Bus 内部使用了缓存，对于同一个事件类型，并不会重复查找，所以实际使用几乎没有差别。 StickyEvent可以使用下面的方法发送 Sticky 事件，这种事件会保留在内存中，当下一个注册者注册时，会立即收到上一次发送的该类型事件，每种类型的事件只会保留一个， Sticky 事件使用严格匹配模式。 public &lt;E&gt; void postSticky(E event) 一般不需要使用 Sticky 事件，但在某些场景下可以用到，比如一个网络状态监听服务，会不断的发送网络状态信息，接受者一旦注册就可以立即收到一个事件，可以知道当前的网络状态。 @BusEvent还有一个注解 @BusEvent 可用于标注某个类是事件类，这个像 @Override 注解一样，纯标注用，没有其它用途，没有运行时消耗。 实现教程 跟我一起写EventBus（一） 跟我一起写EventBus（二） 跟我一起写EventBus（三） 跟我一起写EventBus（四） xBus使用教程]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>EventBus</tag>
        <tag>XBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android框架之路——EventBus的使用]]></title>
    <url>%2Fposts%2F6037db63.html</url>
    <content type="text"><![CDATA[一、简介EventBus是由greenrobot 组织贡献的一个Android事件发布/订阅轻量级框架。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。 官网地址：http://greenrobot.org/eventbus/翻译：http://blog.csdn.net/poorkick/article/details/55099311 二、添加依赖compile &apos;org.greenrobot:eventbus:3.0.0&apos; 三、解锁技能 EventBus的三要素 Event：事件，可以是任意类型的对象。 Subscriber：事件订阅者，在EventBus3.0之前消息处理的方法只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，他们分别代表四种线程模型。而在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING）。 Publisher：事件发布者，可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法。可以自己实例化EventBus对象，但一般使用EventBus.getDefault()就好了，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。 EventBus的四种线程模型（ThreadMode） POSTING（默认）：如果使用事件处理函数指定了线程模型为POSTING，那么该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在线程模型为POSTING的事件处理函数中尽量避免执行耗时操作，因为它会阻塞事件的传递，甚至有可能会引起应用程序无响应（ANR）。 MAIN：事件的处理会在UI线程中执行。事件处理时间不能太长，长了会ANR的。 BACKGROUND：如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。在此事件处理函数中禁止进行UI更新操作。 ASYNC：无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行，同样，此事件处理函数中禁止进行UI更新操作。 使用步骤 注册：EventBus.getDefault().register(this); 解注册（为防止内存泄漏）：EventBus.getDefault().unregister(this); 构造发送消息类： public class MessageEvent &#123; public String name; public String password; public MessageEvent(String name, String password) &#123; this.name = name; this.password = password; &#125;&#125; 发布消息：EventBus.getDefault().post(new MessageEvent(“name”,”password”)); 接收消息：可以有四种线程模型选择 @Subscribe(threadMode = ThreadMode.MAIN)public void messageEventBus(MessageEvent event)&#123; tv_result.setText("name:"+event.name+" passwrod:"+event.password);&#125; 粘性事件​ 之前说的使用方法，都是需要先注册(register)，再post,才能接受到事件；如果你使用postSticky发送事件，那么可以不需要先注册，也能接受到事件，也就是一个延迟注册的过程。​ 普通的事件我们通过post发送给EventBus，发送过后之后当前已经订阅过的方法可以收到。但是如果有些事件需要所有订阅了该事件的方法都能执行呢？例如一个Activity，要求它管理的所有Fragment都能执行某一个事件，但是当前我只初始化了3个Fragment，如果这时候通过post发送了事件，那么当前的3个Fragment当然能收到。但是这个时候又初始化了2个Fragment，那么我必须重新发送事件，这两个Fragment才能执行到订阅方法。​ 粘性事件就是为了解决这个问题，通过 postSticky 发送粘性事件，这个事件不会只被消费一次就消失，而是一直存在系统中，知道被 removeStickyEvent 删除掉。那么只要订阅了该粘性事件的所有方法，只要被register 的时候，就会被检测到，并且执行。订阅的方法需要添加 sticky = true 属性。 构造发送信息类： public class StickyEvent &#123; public String msg; public StickyEvent(String msg) &#123; this.msg = msg; &#125;&#125; 发布消息：EventBus.getDefault().postSticky(new StickyEvent(“我是粘性事件”)); 接收消息：和之前的方法一样，只是多了一个 sticky = true 的属性。 @Subscribe(threadMode = ThreadMode.MAIN, sticky = true)public void onEvent(StickyEvent event)&#123; tv_c_result.setText(event.msg);&#125; 注册： EventBus.getDefault().register(CActivity.this); 解注册： EventBus.getDefault().removeAllStickyEvents();EventBus.getDefault().unregister(CActivity.class); ### 四、举个栗子 主线程发送事件： 自定义事件（类似定义JavaBean），包含用户的姓名和密码； public class UserEvent &#123; private String name; private String password; public UserEvent() &#123; &#125; public UserEvent(String name, String password) &#123; this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "UserEvent&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 在onCreate方法中注册订阅者，在onDestroy中解注册。 public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.jump) Button mJump; @BindView(R.id.send) Button mSend; @BindView(R.id.tv_result) TextView mTvResult; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //注册订阅者 EventBus.getDefault().register(this); &#125; @OnClick(&#123;R.id.jump, R.id.send&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.jump: startActivity(new Intent(MainActivity.this, SecActivity.class)); break; case R.id.send: break; &#125; &#125; //定义处理接收的方法 @Subscribe(threadMode = ThreadMode.MAIN) public void userEventBus(UserEvent userEvent)&#123; mTvResult.setText(userEvent.toString()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //注销注册 EventBus.getDefault().unregister(this); &#125;&#125; 在另一个activity中发送事件，让订阅者能够接收； @OnClick(&#123;R.id.sendData, R.id.receive&#125;)public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.sendData: //发送事件 EventBus.getDefault().post(new UserEvent("Mr.sorrow", "123456")); finish(); break; case R.id.receive: break; &#125;&#125; 实现结果： 发送粘性事件： MainActivity中发送粘性事件； case R.id.send: EventBus.getDefault().postSticky(new MessageEvent("粘性事件", "urgent")); startActivity(new Intent(MainActivity.this, SecActivity.class)); break; SecActivity中接受注册并处理； public class SecActivity extends AppCompatActivity &#123; @BindView(R.id.sendData) Button mSendData; @BindView(R.id.receive) Button mReceive; @BindView(R.id.tv_receive) TextView mTvReceive; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sec); ButterKnife.bind(this); &#125; @OnClick(&#123;R.id.sendData, R.id.receive&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.sendData: //发送事件 EventBus.getDefault().post(new UserEvent("Mr.sorrow", "123456")); finish(); break; case R.id.receive: //要接收时开始注册 EventBus.getDefault().register(SecActivity.this); break; &#125; &#125; //处理事件逻辑 @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) public void receiveEventBus(MessageEvent messageEvent) &#123; mTvReceive.setText(messageEvent.toString()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //解注册 EventBus.getDefault().removeAllStickyEvents(); EventBus.getDefault().unregister(SecActivity.this); &#125;&#125; 实现效果]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用三方框架]]></title>
    <url>%2Fposts%2F4514f8cf.html</url>
    <content type="text"><![CDATA[1.下拉刷新Android-Ptr-Comparison-Android 下拉刷新开源库对比，非常nice！！ Android-PullToRefresh- 最经典、最多人用的下拉刷新、加载更多。 PullDownListView- 一个下拉刷新的控件，实现了仿微信下拉中眼睛动画的效果。 DragTopLayout- 实现整个layout下拉刷新。 ZrcListView- 一个顺滑又漂亮的Android下拉刷新与加载更多列表组件，增加下拉刷新及滚动到底部自动加载的功能；增加越界回弹效果；增加自定义列表项动画的功能。 TwitterCover-Android- Twitter Android客户端的下拉封面模糊效果。 android-Ultra-Pull-To-Refresh- 实现整个layout下拉刷新，没有加载更过，Demo，源码分析。 StikkyHeader- 【Android控件源码：头部固定的控件列表效果】这是一个可以支持头部固定的控件列表功能，源码StikkyHeader，StikkyHeader是一个可以在滚动的时候将头部固定的控件，还可以将动画效果和StikkyHeader一起使用，api非常简单， 支持ListView,RecyclerView,ScrollView。支持2.3一下设备使用的StikkyHeader PullDownListView- 实现了模仿微信眼睛下拉效果，源码PullDownListView，下拉刷新，上拉加载，模仿微信眼睛。 CircleRefreshLayout- 又一个下拉刷新的实现，水滴效果。 BGARefreshLayout-Android- 多种下拉刷新效果、上拉加载更多、可配置自定义头部广告位，目前已经实现了四种下拉刷新效果:新浪微博下拉刷新风格、慕课网下拉刷新风格、美团下拉刷新风格、类似qq好友列表黏性下拉刷新风格。 Pull-to-Refresh.Rentals-Android- 提供一个简单可以自定义的下拉刷新实现。 Pull-to-Refresh.Tours- Taurus，很精美的下拉刷新。 ParallaxListView- 模仿Path的下拉刷新，Head头部图片下拉放大。 WaveRefreshForAndroid- 下拉刷新水波纹动画。 CoordinatorLayoutDemos- 收集了不少资源写了一个基于CoordinatorLayout实现的下拉刷新效果。 Android_PullToRefreshLibrary_Collection- 下拉刷新开源库集锦 。 HitBlockRefresh- 下拉刷新：打砖块和打坦克。 jd_tmall_refresh_demo- 仿写京东、天猫下拉刷新。 android-Ultra-Pull-To-Refresh- 下拉刷新框架，非常强大，可扩展性非常强，兼容各种view的下拉刷新事件。 2.卫星菜单android-satellite-menu- 点击主按钮，会弹出多个围绕着主按钮排列的子按钮，从而形成一个弹出式菜单。子按钮弹出和消失的动画效果都很棒。这种弹出式菜单按钮应用在Path app中。 ArcMenu- 实现弹出式按钮群（菜单）。点击主按钮，会在住按钮旁边弹出多个按钮（菜单）。弹出的按钮有两种排列形式，一种是围绕着主按钮成圆弧形排列，一种是和主按钮并排成一字型排列， 仿Path 2.0 (for iOS)。 Radial Menu Widget- 实现各种圆形或者半圆形菜单，以及圆形进度条。 android-circlebutton- 圆形按钮，有动画点击效果 CircularFloatingActionMenu- 卫星菜单。 ElasticDownload- 挺酷的下载进度条。 android-snake-menu- 仿 Tumblr 的 Android 可拖拽蛇形动画菜单。 3.节选器SegmentView- 类似iOS的Segment Control控件，第一种方式是使用 RadioGroup 实现，O网页链接。 SHSegmentControl- 类似iOS的Segment Control控件，此种方式的可定制化更好。 android-segmentedradiobutton- 在Android中实现类似iOS的分段单选按钮（segmented control），本人以前项目一直使用，值得拥有。 android-segmented-control- RadioGroup实现类似ios的分段选择(UISegmentedControl)控件。 4.模糊效果BlurNavigationDrawer- 背景模糊的Navigation Drawer。 5.HUD与Toastandroid-UCToast- 在不申请任何权限的情况下在 Android 应用中弹出悬浮窗,实现文档。 sweet-alert-dialog- sweet-alert-dialog是一款清新文艺的 Android 弹窗, 灵感来自于 JS 版的 SweetAlert。 6.进度条easyloadingbtn- 模仿了一个Dribbble上的Material Design效果，环形loading， 进度条、进度圈。 android-square-progressbar- 一个不错的方形进度条。 Radial Menu Widget- 实现各种圆形或者半圆形菜单，以及圆形进度条。 AnimatedCircleLoadingView- 一个有限／无限加载动画效果。基于Nils Banner的android-watch-loading-animation设计图。该设计本来是针对智能手表的。 circular-progress-button- 带动态效果的Button(按钮)可要比静态的按钮炫酷的多了，大家看到效果图就知道了 CircularBarPager- Android实现的动态效果，一个数字圆圈进度效果，源码CircularBarPager，material 风格的数字圆圈进度显示库（api10 +）。 dotted-progress-bar- 一个小清新的进度条。 WhorlView- 一个炫酷的漩涡加载效果自定义View。 AVLoadingIndicatorView- AVLoadingIndicatorView整合了一些漂亮的 Android 动画加载效果。 MagicProgressWidget- 渐变的圆形进度条与轻量横向进度条。 GBSlideBar- GBSlideBar类似uber/滴滴等app的滑动选择工具条。 GifLoadingView- 一些好看的 loadingview。 HouseLoading- 一个有趣的android加载loading动画。实现原理 7.UI其他MixtureTextView- 富文本，支持Android图文混排、文字环绕图片等效果。 android-ActionQueue- Action Queue 用于执行有次序的队列操作，比如按次序弹出对话框，这在 Android 中尤其有用。 WheelView-Android- WheelView-Android 是一款开源的 Android 滚动选择控件, 适用于不少应用场景。 Android Wheel- 带有刻度的旋转器：日历、三级联动。 CharacterPickerView- 可实现三级联动的选择器，高仿iOS的滚轮控件,可实现单项选择，并支持一二三级联动效果。 Highlight- Highlight一款可应用于 Android 应用上的指向性功能高亮的库, 可以快速的给应用添加上应用引导的效果。 HeaderAndFooterRecyclerView- 支持addHeaderView、 addFooterView、分页加载的RecyclerView解决方案 。 CleverRecyclerView- 是一个基于RecyclerView的扩展库，提供了与ViewPager类似的滑动效果并且添加了一些有用的特性。 drag-select-recyclerview- 实现了类似 Google Photos 风格的图片多选效果。 FlycoTabLayout- 一个Android TabLayout库,目前有两个TabLayout:SlidingTabLayout、CommonTabLayout。 AndroidChangeSkin- 一种完全无侵入的 Android 应用换肤方式，支持插件式和应用内换肤，无需重启 Activity。 Lobsterpicker- Lobsterpicker 为 Android 开发者提供了满足 Material Design 风格的颜色选择器。 FlycoRoundView- 一个扩展原生控件支持圆角矩形框背景的库,可以减少相关shape资源文件使用。 FlowingDrawer- FlowingDrawer 一个弹性效果的抽屉菜单，图片是概念图，实际效果实现了70%（侧滑菜单）。 TextSurface-是用 Java 写的一款借助酷炫的动画效果来完成消息展示的微型动画框架。 android-animate-RichEditor-android-animate-RichEditor是一款支持图片插入动画效果的 Android 富文本编辑器。 FlycoPageIndicator- android-animate-RichEditor是一款支持图片插入动画效果的 Android 富文本编辑器。 AndroidMosaicLayout- 马赛克效果 Layout,磁片风格View 自适应大小。 DropDownMenu- 一个实用的多条件筛选菜单，在很多App上都能看到这个效果，如美团，爱奇艺电影票等。 Swipe-Deck- 仿 Tinder 的可以左右滑动消除卡片效果的自定义控件。 IntlPhoneInput- 一个支持国际化的电话号码输入的自定义控件。 AndroidUI4Web- AndroidUI4Web是一个高性能的WebApp框架, 在移动浏览器上有与原生App一致的体验。 SmoothCheckBox- SmoothCheckBox带有切换动画的CheckBox。 AndroidTimelineViewx- AndroidTimelineViewx仿微信朋友圈 时间轴。 CityPicker- CityPicker仿美团等选择城市列表。 material-intro- Material Design 风格的引导页。 EmphasisTextView- 支持部分文字高亮的 TextView。 greedo-layout-for-android- 深度定制的 LayoutManager，在显示网格布局的时候会考虑屏幕宽高比。 Rosie- 可以让你创建遵循 Clean Architecture 的应用的框架。 CreditCardView- 一个交互很赞的信用卡自定义 View。 android-md-core- Material风格bootstrap的框架。 SwipeCardView- 一个带渐变层叠动画的左右滑动效果（类似于探探左右刷脸）。 SwipeSelector- 可以左右滑动切换 item 的 Selector。 ForegroundViews- 类似于 FrameLayout 的支持的前景自定义 View。 android-material-chips- Material Design 的 Chips 控件实现。 XhsEmoticonsKeyboard- 表情键盘解决方案。 JKeyboardPanelSwitch- 一套 Android 键盘面板冲突, 布局闪动的处理方案。 GestureLibray- 九宫格解锁。 RecyclerItemDecoration- RecyclerView相关的ItemDecorstion仍然保持高度定制性，易用性。 materiallogindemo- 一个炫酷的Material Design 风格的登录和注册页面 。教程 ScrollablePanel- 一个二维可拖动的面板控件，交互像一个二维的RecyclerView，用法也非常简单和RecyclerView的用法基本一样，横向竖向滑动也都实现了View的复用。 如果你想做房态、计划表、待办事项、课程表等需要一个二维的面板的话，这个控件应该是比较适合的。 VerificationCodeView- 可用于动态生成验证码，常见于金融类app。 ShimmerRecyclerView- 类似 Facebook 加载时，条目的闪烁效果，酷酷的。 StatusView- 简洁优雅的网络状态提示。 8.动画Android应用开发之所有动画使用详解- Android应用开发之所有动画使用详解。 动画特效大全- Android 动画特效大全。 SwitchLayout- 国内开发者， Android的Activity切换动画特效库SwitchLayout，视图切换动画库，媲美IOS。 ActivityOptionsICS- 一个低版本activity动画兼容库——ActivityOptionsICS，可以很好的实现MD的动画效果。 SwipeBack- 一个可以通过手势返回到上一个Activity的开源库，支持上下左右四个方向返回，支持多个View为Child。 SpringIndicator- 模仿Morning Routine的引导页效果SpringIndicator；基于模仿红点拖拽的Demo实现：BezierDemo；sample中使用到 快速创建ViewPager和ListView等的第三方库：MultipleModel。 XhsWelcomeAnim- 国内开发者， 华丽酷炫欢迎引导界面 动画没有之一。 Material-Animations- Material风格动画，可以定义两个Activity之间的动画。 android-shapeLoadingView- android-shapeLoadingView实现高仿新版58 加载动画，loading。 一个绚丽的loading- 一个绚丽的loading动效分析与实现。 TransitionPlayer- 一个 Transition 动画控制控制库，可以让你很轻松的创建一个可交互的动画。 loading-balls- loading-balls 一款支持高度配置的 Android 加载进度球。 SogoLoading- 仿搜狗浏览器加载动画，实现说明。 ExplosionField- Android中View 炸裂特效的实现分析。 AZExplosion- AZExplosion：模仿ExplosionField的粒子破碎效果。 BrokenView-玻璃碎裂动画效果。 SwipeCardView- SwipeCardView一个带渐变层叠动画的左右滑动效果（类似于探探左右刷脸）。类似SwipeCard CRAudioVisualizationView- 水波纹效果的声音可视化自定义 View。 LoadingDrawable- 一些酷炫的加载动画， 可以与任何View配合使用，作为加载动画或者Progressbar, 此外很适合与RecyclerRefreshLayout 配合使用作为刷新的loading 动画。 Depth-LIB-Android-- 一款酷炫的 Android 界面过渡动画效果。 SwipeCaptcha- 自定义View，仿一个斗鱼web端滑动验证码。博文 AndroidAHRSView- 显示飞行器姿态的Android控件。 Material-Animations- 炫酷的Activity切换效果，共享元素。 BGASwipeBackLayout-Android- 修改 v4 包中 SlidingPaneLayout 的源码来实现滑动返回布局。 android-snowfall- 漂亮的下雪效果。 ViewSpreadTranslationController- 两行代码搞定Android视图扩散切换效果。 9.网络相关9.1网络连接​ ion- 一个异步网络请求和图片加载的库，一个库能搞定几乎所有的网络请求。 ​ 多线程下载- Android 实现多线程下载 完美代码。 ​ opandroid- android p2p的开源实现。 ​ okio- square出的Okio这个库，尤其擅长处理二进制数据。如果觉得Java的输入输出流实在太复杂啰嗦，不妨试试Okio。 ​ okhttp- square出的okhttp库。 ​ okhttp-OkGo- 全新完美支持RxJava，比Retrofit更简单易用。该库是封装了okhttp的标准RESTful风格的网络框架。 ​ OkHttpPlus- OkHttp 的一个工具类开源项目OkHttpPlus——支持GET、POST、UI线程回调、JSON格式解析、链式调 用、文件上传下载 ，OkHttpPlus介绍。https://github.com/jeasonlzy/okhttp-OkGo ​ Android-Download-Manager-Pro- 一个下载管理库，如果你的 App 有大量的下载工作，这个库能帮到你。 ​ FileDownloader- 文件下载引擎，稳定、高效、简单易用。 ​ jchat-android- 一个聊天 App,具有完备的即时通讯功能,JChat 的功能基于极光 JMessage SDK 来开发。 ​ RxDownload- 基于RxJava和Retrofit打造的下载工具, 支持多线程下载和断点续传, 智能判断是否支持断点续传等功能。 9.2网络测试​ augmented-traffic-control- Facebook宣布开源移动网络测试工具ATC，该工具支持利用Wi-Fi网络模拟2G、2.5G、3G以 及LTE 4G移动网络环境，让测试工程师们能够快速对智能手机和App在不同国家地区和应用环境下的性能表现进行测 试。 10.图像获取glide- glide google出品，使用教程、GlidePalette。5 个顶级 Android 开源库 Universal Image Loader- Universal Image Loader 是一个强大的、可高度定制的图片缓存，简称：UIL，可以高度配置的网络图片缓存库，非常灵活，用户量最多 。 picasso- picasso 功能单一，没有缓存过期，同androidQuery一样链式调用，载入本地文件速度慢（没有生成thumbnails） ,Picasso and Android-Universal-Image-Loader,另外的一些诸如裁剪图片：Picasso.with(context) .load(url) .resize(50, 50) .centerCrop() .into(imageView)。 fresco- Facebook 又放出的一个新项目，一个类似 Picasso, Glide 的库，不过比他们做的更好。 强烈推荐！［Fresco集成示例］（https://github.com/liaohuqiu/fresco-demo-for-gradle）。 tape- 类似于图片加载库（例如UIL、Picasso等）实现异步加载，但是加载的不一定是图片。！ ImageLoader- ImageLoader 。 Volley- Volley 综合框架,包含图片部分，Volley与Picasso的对比 enif- enif 。 wqgallery- wqgallery实现类似微信选择照片功能，可以通过相机或相册选择，支持单张裁剪，支持单选模式、支持多选模式。 httplite- A android http library。Android网络框架httplite使用指南 PanoramaImageView- 通过监听手腕旋转进行交互，自动滚动图片。 11.响应式编程RxAndroid- RxAndroid：函数响应式编程 ，RxJava- Rx和RxJava文档中文翻译项目,RxJava 详解，RxJava资料汇总。Rxjava+Retrofit 实现全局过期 Token 自动刷新 12.地图百度地图- Android百度地图 线路规划，模拟运动轨迹，及全景效果。 AirMapView- 支持多个本地地图提供者包括谷歌地图V2和亚马逊地图V2。如果设备没有任何受支持的本地地图提供者,AirMapView会回退到基于web的地图提供者(目前谷歌地图)。 13.数据库ORMLite- ORMLite做的最棒但是学习成本有点儿高，ORMLite的文档有点儿烂。 SugarORM- SugarORM比较轻便， 支持Has a 和 Has many映射，但无法保存集合，没有映射关系。 GreenDAO- GreenDAO要先建立一个java项目来生成对应的表，一变动又要生成，很不方便。 ActiveDriod- ActiveDriod也不错官网。 ORMDroid- ormdroid 。 sqlbrite- 良心企业Square的又一开源项目，当你不想给用ContentProvider，只想简单监听SQLite表增删改的数据变更时可以试试它。 sqlbrite- DBExecutor android ORM数据库 1.使用了读写锁，支持多线程操作数据。 2.支持操作多个数据库 3.支持事务 4.缓存Sql，缓存表结构。 Iron- 一个快速和易用的 NoSQL 数据存储框架。 hawk- 一个快速和易用的键值对数据存储框架，支持AES加密，支持SharedPreferences或Sqlite存储，支持Gson解析。 AndroidKeyValueStore- 一个基于 SQLite 的 Key/Value 存储框架。 DBFlow- 一个速度极快，功能强大，而且非常简单的 Android 数据库 ORM 库，为你编写数据库代码,DBFlow 已被证明是最好的解决方案。5 个顶级 Android 开源库 14.图像浏览及处理MPAndroidChart- MPAndroidChart是一个功能强大的图表开源类库：曲线图、柱形图、环形图。 XCL-Charts- (国人开发)基于Android Canvas来绘制各种图表,使用简便,定制灵活。 WilliamChart- 绘制图表的库，支持LineChartView、BarChartView和StackBarChartView三中图表类型，并且支持 Android 2.2及以上的系统。 CropImageView- 原生ImageView只支持centerCrop，这里有支持9个方向裁剪的ImageView。 SimpleCropView- 一个Android的图片裁剪库，使用简单，易于定制。 DrawableView- DrawableView实现画板功能，可以改变画笔粗细，颜色，支持撤销功能。 ImageCoverFlow- ImageCoverFlow效果不错的画廊控件 可以设置画廊一次可见图片的张数，和其他第三方Gallery控件不同的是，该控件直接继承自View，而不是sdk中的Gallery控件。 FancyCoverFlow- 支持Item切换动画效果的类似Gallery View。改进版本可以无限轮播，可以选择自动轮播或者 手动滑动。 BGABanner-Android- demo中演示了引导页、以及通过fresco、android-async-http、gson实现广告条的自动轮播效果（splash 、 ViewPager切换动画） 。 RecyclerViewPager- 重写后的 RecyclerViewPager 完全继承自RecyclerView，可以自定义触发翻页的距离，可自定义翻页速度，支持VerticalViewPager，支持Fragment。 StickerCamera- 可以说是一个完整的相机、图片编辑的 APP，集成了大部分市面上有的同类 APP 的功能，裁剪、滤镜、贴纸应有尽有。 demo6_PhotoRiver- 图片流动显示的demo，可以点击流动中的图片放大显示，双击空白处图片以九宫格排列。 glide-transformations- 一个基于Glide的transformation库，拥有裁剪，着色，模糊，滤镜等多种转换效果。 ColoringLoading- 一个用纯代码实现自动绘画效果动画的项目。 SmartDrawing- 一个轻量级的手绘板，加入了一点截图功能。这只是一个Demo。并不能作为类库，也不是完整的项目工程，仅供学习或参考使用。 SlidingCard- 漂亮的卡片滑动翻页特效。 LargeImage- 加载大图 可以高清显示10000*10000像素的图片。 GalleryFinal- 自定义相册，实现了拍照、图片选择（单选/多选）、 裁剪（单/多裁剪）、旋转、ImageLoader无绑定任由开发者选 择、功能可配置、主题样式可配置。GalleryFinal为你定制相册。 AndroidAlbum- AndroidAlbum图片选择器：1、MVP结构设计；2、工厂模式对载图框架进行封装抽象，方便替换其他载图框架；3、闪退日志的搜集，方便揪BUG。 uCrop- uCrop 是 Yalantis 推出的又一款力作, 用于裁剪 Android 系统上的图片, 致力于打造最佳的图片裁剪体验。 crop-image-layout- crop-image-layout：图片裁切布局。 RenderscriptHistogramEqualization-RenderScript :简单而快速的图像处理 15.视频音频处理ijkplayer- B站开源的视频播放器，支持Android和iOS。 DanmakuFlameMaster- 这里是Android上最好的开源弹幕引擎·烈焰弹幕使。 YouTubePlayerActivity- 一个可以播放YouTube视频的Activity，支持屏幕旋转、声音控制、播放失败处理、可以自定义Activity关闭动画以及在横屏播放的时候自动隐藏status bar。 AndroidVideoPlayer- 开源的 Android 视频播放器，支持 DLNA。 Hide-Music-Player- Hide音乐播放器。 JamsMusicPlayer- 是一个功能强大的 Android 开源播放器, 作者将原本收费的项目拿出来开源, 实在令人敬佩。 RxAndroidAudior- RxAndroidAudior目前最鲁棒的Android声音录制和播放封装库了,说明。 Timber- 一款遵循了Material Design并且设计精美的播放器 Timber Music Player，已经在google play上架。 LandscapeVideoCamera- 一款功能强大的 Android 视频录制库, 仅允许横屏录制, 提供细粒度控制视频的质量与文件大小。 MovieHub- 非常漂亮的一款 Android Movie 工具。 LyricViewDemo- 歌词显示控件，支持多行显示、拖曳播放、自动识别歌词文件的编码。 16.测试及调试DevelopQuickSetting- 快速开启关闭开发者设置的工具，提供了app界面和桌面widget，能快速打开关闭overdraw，layout border，gpu rendering，adb wifi，不保存activity实例等功能。 decompileandroid- 在线反编译apk文件。 jadx- 一个Android反编译神器，不同于常见的dex2jar，这个反编译器生成代码的try/catch次数更少，View也不再是数字id了，可读性更高。 Androguard- Androguard使用Python写的一系列逆向工具集，功能很强大哦，对逆向工程感兴趣的小伙伴可以这个系列，教程。 logger- 一个简单、漂亮、功能强大的Android日志程序。 stf- WEB 端批量移动设备管理控制工具 STF 的环境搭建和运行，使用说明。 DecompileApk- 一键反编译 APK，输出所有反编译后的代码、资源，使用方便。 AppCrashTracker- 一个异常追踪器，可以生成一个 JSON 格式的日志并可以上传到服务器。 preferator- 开发辅助工具，帮助你快速的在 Android 端修改 SharedPreference，以达到测试的目的。 17.动态更新热更新dexposed- 淘宝 支付宝的Android底层技术团队即将为Dexposed开源项目贡献一个重要的扩展能力 —— 方法粒度的完整替换，大幅度降低基于AOP方式替换大型方法的开发成本，使用教程，Android平台免Root无侵入AOP框架Dexposed使用详解。Android Hotpatch系列之-项目介绍-客户端例子实现,服务器简易实现。热更新。 Xposed- Xposed是一款可以在不修改APK的情况下影响程序运行的框架服务,Android Hook神器：XPosed入门与登陆劫持演示。热更新。 code-push-大微软推出的一套可以为用 React Native 和 Cordova 开发的 App 提供代码热更新的方案。 DynamicAPK- 实现Android App多apk插件化和动态加载，支持资源分包和热修复。 AndFixDemo- AndFix是alibaba出品的开源热更新技术。 gradle_plugin_android_aspectjx- 通过Gradle Transform和aspectj来实现代码动态修改，业务逻辑数据埋点、性能数据统计等侵入性修改从此不再需要修改业务代码，完美解决Dexposed兼容性问题，实现代码自动插桩。AspectJX-Demo RoboAspectJ- 美团出品的开源热更新技术。 18.消息推送与即时通讯即时通讯和sns开源项目汇总- 源码提供！Android即时通讯和sns开源项目汇总，github地址。 19.完整项目SuesNews新闻客户端- 腾飞新闻，一个符合 Google Material Design 的 Android 校园新闻客户端 ，新闻客户端说明。 新闻客户端- Android应用源码比较不错的新闻客户端，本项目启动引导登录注册用户中心列表显示文章分页下拉刷新文章收藏更新反馈等新闻客户端常见的功能都有，项目分层合理，代码质量较高。 materialistic- Material Desgin风格的Hacker News客户端。 Telegram- Telegram 是一款专注于速度、安全的短信息应用，快速、简单、免费。Telegram 支持群组聊天，最高200人，最高支持分享1GB的视频，其它图片等等更是不在话下。而且所有信息全部支持同步。由于频发的隐私问题，所以 Telegram 也很注重通信安全。 SuZhouTong-client-for-android- 苏州通android客户端，非常多的UI效果。 ele_demo- 仿【饿了么】订餐软件的一个demo。 MD-BiliBili- Material Design 版 BiliBili Android 客户端。 AisenWeiBo- Aisen微博是新浪微博的第三方客户端，UI遵循Material Design：遵循Material Design、发布多图、离线下载、私信（触屏版、颜色主题切换、手势返回，4.4、5.0状态栏变色、离线编辑，定时发布多图、gif、长微博预览。FrescoDemo。 快递查询- 使用了爱查快递www.ickd.cn的api接口，可以查询申通、EMS、顺风、圆通、中通、韵达、天天、汇通、全锋、德邦、宅急送等11种快递的单号信息，支持手动输入单号和扫描单号(红米测试的时候扫描单号有点问题)，可以保存单号查询记录方便下次查询，，另外还包括了网络状态判断、快递自动更新、软件更新等功能，项目完美运行，有很详细的中文注释和逻辑分层。 SmartCall- SmartCall Android 企业通讯录。 Android-高仿大众点评客户端源码- Android-高仿大众点评客户端源码。 八个Android项目源码- 八个Android项目源码，大部分功能相信可以在实战项目中直接使用，供大家下载学习，大部分项目是基于Android Studio开发，IDE为Eclipse的童鞋可通过网上教程自行转换，这里就不多说了。大家可以下载下来学习看看！百度云盘下载地址。 minicat- 一个简洁的饭否App，支持Android 4.0以上版本。 SimplifyReader- 一款基于Google Material Design设计开发的Android客户端，包括新闻简读，图片浏览，视频爽看 ，音乐轻听以及二维码扫描五个子模块。 GithubTrends- 是一个用来看查看 GitHub 热门项目的 Android App, 遵循 Material Design, 支持订阅 50 多种编程语言, 9 种颜色主题切换, 可在上面收藏喜欢的项目。 jianshi- jianshi简诗是国人开发的一个用于记录文字信息的 Android 完整应用, 作者仅用了一天便将其开发出来, 并将开发的流程记录成文放到了简书上。 BuildingBlocks- 积木： 一个以知乎日报作为数据展现内容；以抽屉菜单作为功能扩展入口；依循 Material Design 作为主导设计 UI 的应用。 Douya- 开源的 Material Design 豆瓣客户端。 TranslateApp- 一个实现『划词翻译』功能的 Android 开源应用。 likequanmintvp- 基于MVP的Retrofit2(okhttp3)+rxjava+dagger2+greendao+glide+rtmp直播。该项目系仿全民TV。 20.插件Android Studio 插件和工具- 5个 推荐几个有用的 Android Studio 插件和工具（ButterKnife、selectorChapek、GsonFormat、ParcelableGenerator、LeakCanary）。 8 个最优秀的 Android Studio 插件- 8 个最优秀的 Android Studio 插件（H.A.X.M（硬件加速执行管理器）、Genymotion、Android Drawable Importer、Android ButterKnife Zelezny、Android Holo Colors Generator、Robotium Recorder、jimu Mirror、Strings-xml-tools）。 smalidea- 一款 IntelliJ IDEA/Android Studio 的 smali 插件～ ，Smalidea 无源码调试 Android 应用。 gradle-fir-plugin- 一个上传apk到fir的gradle插件，使用说明。 android-butterknife-zelezny- 一个ButterKnife的Android Studio插件, 该插件可以让你手动生成上述注入代码。 GradleDependenciesHelperPlugin- Gradle 依赖自动补全插件。 android-selector-intellij-plugin- 可以根据指定颜色生成Selector Drawable的插件。 7个最佳的Android模拟器- 7个最佳的Android模拟器。 gradle-android-javadoc-plugin- 可以生成 java doc 的 Gradle 插件。 gradle-android-junit-jacoco-plugin- 可以生成代码单元测试覆盖率报告的 Gradle 插件。 gradle-android-apk-size-plugin- 可以将 Apk 大小记录到 CSV 文件的 Gradle 插件。 几款实用的Android Studio 插件- 几款实用的Android Studio 插件：1、android-butterknife-zelezny；2、Gsonformat：可根据json数据快速生成java实体类；3、Android Postfix Completion；4、AndroidAccessors；5、Lifecycle Sorter：根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K；6、JsonOnlineViewer；7、CodeGlance；8、findBugs-IDEA：帮你一起找bug的；9、ADB WIFI：使用wifi无线调试你的app，无需root权限。 Leisure- 闲暇(Leisure)是一款集”知乎日报”、“果壳科学人”、“新华网新闻”以及“豆瓣图书”于一体的阅读类Android应用。 果壳、知乎和豆瓣在国内拥有大量用户，这些社区的用户每天都产生很多高质量内容。闲暇以其简介的风格将这几大社区 的优质内容整合于一体，使得用户能有效地获取这些内容，大大节省了用户的时间。酷安下载地址. LayoutFormatter插件- 可自动将乱序的布局文件进行重新属性排序并格式化，比如 style 和 android:id 必须排在前面，紧接着 layout、padding，而值设定如 text 只能排在最后。 21.著名框架xUtils- xUtils 包含了很多实用的android工具。支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响。最低兼容android 2.2 (api level 8)。目前xUtils主要有四大模块：DbUtils模块、ViewUtils模块、HttpUtils模块、BitmapUtils模块。 afinal- Afinal是一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。 ButterKnife- ButterKnife是一个专注于Android系统的View注入框架，让你从此从这些烦人臃肿的代码中解脱出来，ButterKnife–View注入框架。5 个顶级 Android 开源库 EventBus- EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。xBus- xBus - 简洁的EventBus实现。 Small- 做最轻巧的跨平台插件化框架，目前已支持Android、iOS以及html5插件。并且三者之间可以通过同一套javascript接口进行通信。 LayoutCast- LayoutCast可以在应用不重启的情况下，将res文件夹下的改动直接同步到手机上。使用LayoutCast，可以节约Android开发者的大量编译等待时间，非常适合真机调试界面的时候使用，推荐每一位开发者安装该利器。BUCK很快，但入侵性强，项目改动大，LayoutCast对项目改动小。 retrofit- retrofit将 REST API 转换为 Java 接口。5 个顶级 Android 开源库 Dagger2- Dagger 2 是著名的依赖注入库Dagger的继承者，我们强烈推荐它。文档，5 个顶级 Android 开源库 22.其他java-zhconverter- java-zhconverter是一个简繁体中文互换的Java开源类库。 joda-time-android- 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。java版本 AssistiveTouch- 配合Android手机沉浸式隐藏虚拟按键后快捷操作 (Nexus5屏幕变大了)。 S-Tools- S-Tools一个可以实时查看的CPU状态和手机各类传感器数据，还有一些例如颜色选择、指南针和设备信息等功能。 JsBridge- 模仿微信webview的JsBridge，安全方便的实现js和Java的互相调用，主要通过loadUrl和shouldOverrideUrl实现。 Sample Of All Samples- 提供大部分Android5.0组件的示例应用。 Android-Package-Channel- 美团网做的把Android多渠道打包工具，打包时间缩短到一分钟，python脚本。 fast-apk-packaging- Android不需要重新编译打渠道包。 android_gradle_script- gradle批量打包脚本，用txt配置一下，就可以支持多个渠道打包，适合国内这种动不动上百个渠道包的环境。目前有个问题，一次打包脚本超过80个就会GC问题。 BatchPackApk- 免签名直接打包工具。 Android多渠道打包工具Gradle插件- Android多渠道打包工具Gradle插件。 Android批量打包极速版- 用python实现的在META-INF目录内添加空文件的方式，实现批量快速打包Android应用。 Gradle-Plugin-User-Guide-Chinese-Verision- Gradle插件使用指南中文版。 gradle-guide.books- Android Gradle 插件中文指南（GitBook）。 Android-package_tool- 该工程用于编译多渠道Android应用，替换相应的标签，然后重新打包，用perl脚本实现。 兰贝壳儿- Android多渠道打包解决方案(兰贝壳儿)，eclipse插件。 Algorithms- 常见算法问题的Java实现。 java-design-patterns- 一个常见设计模式的java实现。 PreferenceInjector- SharedPreference注入开源库，SharedPreference key与某个变量绑定、监听key变化、初始化key都可以通过注解完成。 prettytime- 一个实用的人性化的时间显示，比如：几分钟前，几天前。 Material-Movies- Material Design 下的Movie App（电影展示），可供学习，或者直接二次开发。 Clean-Contacts- 充满技术含量的一个 Contact App（联系人）。 RedEnvelopeAssistant- 完全免费开源的抢红包软件、做这个软件纯粹是发现Android的模拟点击十分好玩，然后顺道写了一个，有此基础，可以再扩展其他的很多模拟点击程序 。 superCleanMaster- 一键清理开源版，包括内存加速，缓存清理，自启管理，软件管理等。 LoadViewHelper- 切换加载中，加载失败，加载成功布局，定义一个LoadViewHelper所有界面通用。 android-best-practices- android最佳实践 Android最佳实践- 安卓最佳实践（1）：安卓开发–中文。 Android最佳实践- 从Futurice公司Android开发者中学到的经验。 遵循以下准则，避免重复发明轮子。若您对开发iOS或Windows Phone 有兴趣， 请看iOS Good Practices 和 Windows client Good Practices 这两篇文章。 如何安装ACRA- 如何安装ACRA-一个Android应用Crash跟踪系统—在自己的服务器上。 Android ocr识别文字介绍- Android ocr识别文字介绍 。 DaVinci- DaVinci是一个适用于Android Wear平台的图片下载和缓存library。 Point-of-Android- Android 一些重要知识点解析整理 。 AppStoreLibrary- 检测是否在appstore安装了应用，搜索应用。 LeakCanary- 利用此类库，排查内存泄露变得非常简单，LeakCanary 中文使用说明，LeakCanary: 让内存泄露无所遁形。 anko- 快速开发框架。 CommonAdapter- 通过对于原生Adapter的封装，产生了支持ListView，GridView，RecyclerView的简单通用的Adapter。这种方式将item变成独立的“视图”对象，方便操作，又增加了可扩展性。 MVPAndroidBootstrap- 一个Android MVP 模式实例项目。 json2notification- 一个多功能方便好用的notification通知栏通知开源库。 barcodescanner- 一个封装好的基于zxing二维码扫描库。 BGAQRCode-Android- 一个可高度定制二维码扫描界面、生成二维码、识别图片二维码库。 mqtt- MQTT 协议 3.1.1 中文翻译版。 Droid Plugin- DroidPlugin 是360手机助手在Android系统上实现了一种新的插件机制:它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。 JsonAnnotation- 利用注解自动生成Gson‘s Model的库。 WeChatLuckyMoney- 微信抢红包插件。 android-support-23.2-sample- support 库在 23.2 版本新增内容示例项目。 Sunoath- 基于MVP+Retrofit+Material Design的Demo。 ActivityRouter- 一个url打开activity的Router库，支持指定参数类型，支持参数transfer，支持callback。 AnalysisApp- 一个快速分析 Android App 使用了哪些 SDK 的工具。 AndroidLuaExample- 封装了最新Lua代码的Android库。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cannot resolve method getSupportFragmentManager();]]></title>
    <url>%2Fposts%2F2ed74455.html</url>
    <content type="text"><![CDATA[在使用Fragment的时候，我们尝尝会用到Fragment管理器，那么初始化Fragment管理器的时候我们会遇到getSupportFragmentManager();方法找不到的情况，这里主要有两个原因： import android.support.v4.app.FragmentManager; 没有导入v4包下的Fragmanager. Activity没有继承FragmentActivity。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager轮播图（文字&图片）]]></title>
    <url>%2Fposts%2F3bedd12e.html</url>
    <content type="text"><![CDATA[Demo地址：MyViewPager ViewPager常用来实现图片的轮播，比如淘宝首页，会把一些促销的商品的图片和描述信息来回的播放，这就是典型的使用ViewPager实现的。 ViewPager属于布局管理器，允许用户通过页面翻转查看左右的数据，下面通过一个实例来讲解ViewPager实现图片轮播和手势滑动。 效果图 布局文件 activity_main.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="180dp"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/vp" android:layout_width="match_parent" android:layout_height="180dp"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:background="#6000" android:gravity="center_horizontal" android:orientation="vertical" android:padding="5dp"&gt; &lt;TextView android:id="@+id/tv_desc" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="#fff"/&gt; &lt;LinearLayout android:id="@+id/ll_point" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="5dp" android:orientation="horizontal"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 小圆点选择器point_enable.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;corners android:radius="8dp"/&gt; &lt;solid android:color="#fff"/&gt;&lt;/shape&gt; point_disable.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;corners android:radius="8dp"/&gt; &lt;solid android:color="@android:color/darker_gray"/&gt;&lt;/shape&gt; point_selector.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_enabled="true" android:drawable="@drawable/point_enable"/&gt; &lt;item android:state_enabled="false" android:drawable="@drawable/point_disable"/&gt;&lt;/selector&gt; MainActivityMianActivity的代码如下，下面的代码主要是实现图片轮播和手势滑动，同时也提供里一个解决图片轮播到最后一个或滑动到最后一个（或第一个时）停了下来的问题，这个问题对用户体验来说是很糟糕的，所以要解决。同时提供了温习了一下MVC开发模型，这种模型能够让代码显得结构清晰。为了保证代码的连贯性，把代码写在了一个类中。 package com.zm.myviewpager;import android.os.Bundle;import android.support.v4.view.PagerAdapter;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import java.util.ArrayList;public class MainActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener &#123; private ViewPager vp; private LinearLayout ll_point; private TextView tv_desc; private int[] imageResIds; //存放图片资源id的数组 private ArrayList&lt;ImageView&gt; imageViews; //存放图片的集合 private String[] contentDescs; //图片内容描述 private int lastPosition; private boolean isRunning = false; //viewpager是否在自动轮询 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //使用M-V-C模型 //V--view视图 initViews(); //M--model数据 initData(); //C--control控制器(即适配器) initAdapter(); //开启图片的自动轮询 new Thread() &#123; @Override public void run() &#123; isRunning = true; while (isRunning) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //在子线程中开启子线程 //往下翻一页（setCurrentItem方法用来设置ViewPager的当前页） vp.setCurrentItem(vp.getCurrentItem() + 1); &#125; &#125;); &#125; &#125; &#125;.start(); &#125; /* 初始化视图 */ private void initViews() &#123; //初始化放小圆点的控件 ll_point = (LinearLayout) findViewById(R.id.ll_point); //初始化ViewPager控件 vp = (ViewPager) findViewById(R.id.vp); //设置ViewPager的滚动监听 vp.setOnPageChangeListener(this); //显示图片描述信息的控件 tv_desc = (TextView) findViewById(R.id.tv_desc); &#125; /* 初始化数据 */ private void initData() &#123; //初始化填充ViewPager的图片资源 imageResIds = new int[]&#123;R.mipmap.aa, R.mipmap.bb, R.mipmap.cc, R.mipmap.dd, R.mipmap.ee&#125;; //图片的描述信息 contentDescs = new String[]&#123; "忙碌的生活疏于彼此联系，但却无法冲淡对你的思念。相信我们的心电感应，会把我每一次祈祷和祝福悄悄传送。", "你会因为一首歌喜欢上一个人，因为一个人喜欢一个城市，因为一个城市喜欢上一种生活，然后成为一首歌，想念某个人。", "我们对亲人的思念是永不会停止的，而思念却是多种的，阿婆的伤痛，妈妈的文字，我的小女儿情绪，不管怎样，已故的亲人永远活在我们的心里。", "每一天醒来，你的清影就在我眼前转。不管手里干什么事，一会儿，准走神儿了，呆呆的只想你，算着你什么时候回来。", "在一年的每个日子，在一天每个小时，在一小时的每一分钟，在一分钟的每一秒，我都在想你。" &#125;; //保存图片资源的集合 imageViews = new ArrayList&lt;&gt;(); ImageView imageView; View pointView; //循环遍历图片资源，然后保存到集合中 for (int i = 0; i &lt; imageResIds.length; i++) &#123; //添加图片到集合中 imageView = new ImageView(this); imageView.setBackgroundResource(imageResIds[i]); imageViews.add(imageView); //加小白点，指示器（这里的小圆点定义在了drawable下的选择器中了，也可以用小图片代替） pointView = new View(this); pointView.setBackgroundResource(R.drawable.point_selector); //使用选择器设置背景 LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(8, 8); if (i != 0) &#123; //如果不是第一个点，则设置点的左边距 layoutParams.leftMargin = 10; &#125; pointView.setEnabled(false); //默认都是暗色的 ll_point.addView(pointView, layoutParams); &#125; &#125; /* 初始化适配器 */ private void initAdapter() &#123; ll_point.getChildAt(0).setEnabled(true); //初始化控件时，设置第一个小圆点为亮色 tv_desc.setText(contentDescs[0]); //设置第一个图片对应的文字 lastPosition = 0; //设置之前的位置为第一个 vp.setAdapter(new MyPagerAdapter()); //设置默认显示中间的某个位置（这样可以左右滑动），这个数只有在整数范围内，可以随便设置 vp.setCurrentItem(5000000); //显示5000000这个位置的图片 &#125; //界面销毁时，停止viewpager的轮询 @Override protected void onDestroy() &#123; super.onDestroy(); isRunning = false; &#125; //--------------以下是设置ViewPager的滚动监听所需实现的方法-------- //页面滑动 @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; //新的页面被选中 @Override public void onPageSelected(int position) &#123; //当前的位置可能很大，为了防止下标越界，对要显示的图片的总数进行取余 int newPosition = position % 5; //设置描述信息 tv_desc.setText(contentDescs[newPosition]); //设置小圆点为高亮或暗色 ll_point.getChildAt(lastPosition).setEnabled(false); ll_point.getChildAt(newPosition).setEnabled(true); lastPosition = newPosition; //记录之前的点 &#125; //页面滑动状态发生改变 @Override public void onPageScrollStateChanged(int state) &#123; &#125; /** * 自定义适配器，继承自PagerAdapter */ class MyPagerAdapter extends PagerAdapter &#123; //返回显示数据的总条数，为了实现无限循环，把返回的值设置为最大整数 @Override public int getCount() &#123; return Integer.MAX_VALUE; &#125; //指定复用的判断逻辑，固定写法：view == object @Override public boolean isViewFromObject(View view, Object object) &#123; //当创建新的条目，又反回来，判断view是否可以被复用(即是否存在) return view == object; &#125; //返回要显示的条目内容 @Override public Object instantiateItem(ViewGroup container, int position) &#123; //container 容器 相当于用来存放imageView //从集合中获得图片 int newPosition = position % 5; //数组中总共有5张图片，超过数组长度时，取摸，防止下标越界 ImageView imageView = imageViews.get(newPosition); //把图片添加到container中 container.addView(imageView); //把图片返回给框架，用来缓存 return imageView; &#125; //销毁条目 @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; //object:刚才创建的对象，即要销毁的对象 container.removeView((View) object); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之uri、file、path相互转化]]></title>
    <url>%2Fposts%2F6f91fcbd.html</url>
    <content type="text"><![CDATA[uri &amp; file 互转File file = new File(new URI(uri.toString())); URI uri = file.toURI(); uri &amp; path 互转private String getPath(Uri uri) &#123; String[] projection = &#123;MediaStore.Video.Media.DATA&#125;; Cursor cursor = managedQuery(uri, projection, null, null, null); int column_index = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA); cursor.moveToFirst(); return cursor.getString(column_index); &#125; Uri uri = Uri.parse(path); file &amp; path 互转String path = file.getPath() File file = new File(path)]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丰宁坝上草原2日游线路行程]]></title>
    <url>%2Fposts%2Fabebff90.html</url>
    <content type="text"><![CDATA[丰宁坝上草原2日游线路行程第一天07：00 北京约定地点集合 12：00 到达目的地，20人以上团队我们安排马队欢迎仪式，鞭炮欢迎！！！但晚上无法进行此活动 12：10 分房，午餐 14：00 骑马出发前往影视基地情人谷（草原上的另一番景色望不到边际的白桦林），影视村（原汁原味草原上的老村庄）情人谷北影厂的外景地（章子怡主演的《我的父亲母亲》；黄宏主演的《25个孩子一个爹》；电视剧《暖春》等多部影视剧的拍摄外景地）。 草原的落日也是值得一看的美景，你会感受到离开喧嚣世界，真正回归自然的那份自由自在，怡然自得。观赏草原夕阳，然后准备共进草原晚餐。 19：00 晚餐吃烤全羊、篝火聚会、观赏烟花、篝火跳舞，KTV。大家一起喝酒聊天，唱起我们喜欢的歌曲，在欢快的歌声中让我们舞动身体，度过美好的草原之夜。 第二天06：00 晨观日出 07：30 早餐后，前往草原娱乐场（价值180元已含），进入蒙古人家，感受蒙族风情，喝马奶酒，参加蒙古仪式祭祀敖包；可玩滑草、射箭、滑索、飞斧、野战搏击、弹跳飞人、喷火神枪、海盗船、激情转马、流星炮车、疯狂斗牛、蒙古人家、杂技表演等娱乐项目。 10：00前往美丽的草原滦河源头【闪电湖】拍照、看草原。滦河上游最大的湖，因入湖前的河流为闪电河而得名。在天苍苍、野茫茫的草原上闪现出这样敞亮清澈美丽的湖水，当地人叫它闪电湖。 或10:00开始团建活动，免费团建装备：拔河、背夹球、草地足球、袋鼠跳跳袋、多人跳绳、巨人脚步、摸石过河砖、珠行千里、撕名牌、指压板等活动。 12：00 午餐后返程北京，沿途一路美景相伴，也不会觉得枯燥，从海拔2000米到平原地带，各路美景让您充分领略。 住宿吃餐 标准型方案 128元/人3正餐+1早餐+1晚住宿（草原风农家院 两星标准,双人/三人标间,独立卫浴,热水,有线电视,WiFi）+免费篝火专业音响 超值型方案 168元/人3正餐+1早餐+1晚住宿（草原风农家院 两星标准,双人/三人标间,独立卫浴,热水,有线电视,WiFi）+免费篝火专业音响+15项娱乐场套票 特惠型方案 268元/人3正餐+1早餐+1晚住宿（远山.别院 准四星酒店标准,双人/三人标间,独立卫浴淋浴房,观景房,热水,有线电视,WiFi）+免费篝火专业音响+15项娱乐场套票 15项娱乐套票入场门票10元；高山滑草20元；缆车40元；弹跳飞人30元；射箭20元； 真人CS30元；竹林迷宫20元；蒙古人家20元；敖包祈福20元；欢乐转马20元；登月飞车20元；桑巴汽球20元；小海盗船20元；草原飞斧(6把/人)20元；高尔夫球20元；价值330元 费用包含 住宿费：酒店双人或三人标间； 餐费：三正餐一早餐； 活动费：拔河、放风筝、草地足球、趣味运动会等； 篝火晚会费：满20人即可组织篝火晚会； 全程司机、领队食宿费等； 医用装备：医药箱、急救包等（领队医药箱中包含药品种类：云南、白药喷雾剂、云南白药粉、风油精、绿药膏、烫伤膏、体温计、创可贴、绷带、纱布块、酒精、棉签、医用胶布、小剪刀）如需特殊药物请提前自备； 赠送娱乐套票：15项娱乐场套票（滑草、射箭、滑索、飞斧、野战搏击、弹跳飞人、喷火神枪、海盗船、激情转马、流星炮车、疯狂斗牛、蒙古人家、杂技表演等），此票不退不换；坝上独家帐篷营地、野餐基地、野外烧烤基地，可根据您的需要安排。 费用不含 骑马：骑马50元/小时，牵马费20元/小时； 烤全羊：30元/斤，活羊称重； 租车费用：6-55座各型旅游车，正规车，手续齐全； 景点门票：情人谷 免费、柳树沟70元/人、千松坝森林公园100元/人、大汗行宫90元/人、闪电湖30元/人、老掌沟20元/人、草原天路 免费；以上门票住宿咱家都有折扣票。 发票：不含发票，开发票需要另外加6%税点； 坝上草原旅游注意事项1、坝上风大，早晚温差大，建议多带些衣物。2、草原阳光较晒，应戴太阳镜、帽子并涂抹防晒霜。3、草原常有雷雨天气，雨具应必备。4、坝上草原有很多的村庄，虽然已经多年接待游客，但是山村人质朴、单纯的性格还是给游客带来很多的温馨，你敬他一尺，他敬你一丈，反之也是一样。所以处事要以和为贵，能饶人处且饶人，千万不可感情用事，有事多和您所住的酒店旅馆、农家小院的负责人商量，求其帮助解决。来坝上草原，尽量避免周末人多的的时候，根据以往的经验，周一到周四号人相对少些，各方面的价格也相对低一些。5、开心之时要特别注意管理好自己的东西。由于旅游区人员较多、比较杂，要特别小心。骑马是很多人喜好的娱乐和健身活动。外出骑马是一定要放好自己的东西，尽量不要带手机和钱包，如果带一定要放在妥善的、不易丢掉的地方。因为骑马会上下颠簸，口袋里的东西很容易掉出来，所以，骑马丢手机、钱包、眼镜、照相机、手表、钥匙、打火机、香烟等的人不少。6、放鞭炮、开越野车、四驱、摩托车等都要注意安全，安全第一。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[录音SoundRecording]]></title>
    <url>%2Fposts%2F58d30177.html</url>
    <content type="text"><![CDATA[效果图 首页 录音 播放 实现录音的 Service这个类可以说是这个包的核心了，如果理解了这个 Service，录音这一块基本就没什么问题了。 录音主要是利用 MediaRecoder 这个类，进行声音的记录，接下来我们一起来看看具体的实现。 public class RecordingService extends Service &#123; private static final String LOG_TAG = "RecordingService"; private String mFileName = null; private String mFilePath = null; private MediaRecorder mRecorder = null; private long mStartingTimeMillis = 0; private long mElapsedMillis = 0; private TimerTask mIncrementTimerTask = null; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; startRecording(); return START_STICKY; &#125; @Override public void onDestroy() &#123; if (mRecorder != null) &#123; stopRecording(); &#125; super.onDestroy(); &#125; public void startRecording() &#123; setFileNameAndPath(); mRecorder = new MediaRecorder(); mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mRecorder.setOutputFile(mFilePath); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC); mRecorder.setAudioChannels(1); mRecorder.setAudioSamplingRate(44100); mRecorder.setAudioEncodingBitRate(192000); try &#123; mRecorder.prepare(); mRecorder.start(); mStartingTimeMillis = System.currentTimeMillis(); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125; &#125; public void setFileNameAndPath() &#123; int count = 0; File f; do &#123; count++; mFileName = getString(R.string.default_file_name) + "_" + (System.currentTimeMillis()) + ".mp4"; mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath(); mFilePath += "/SoundRecorder/" + mFileName; f = new File(mFilePath); &#125; while (f.exists() &amp;&amp; !f.isDirectory()); &#125; public void stopRecording() &#123; mRecorder.stop(); mElapsedMillis = (System.currentTimeMillis() - mStartingTimeMillis); mRecorder.release(); getSharedPreferences("sp_name_audio", MODE_PRIVATE) .edit() .putString("audio_path", mFilePath) .putLong("elpased", mElapsedMillis) .apply(); if (mIncrementTimerTask != null) &#123; mIncrementTimerTask.cancel(); mIncrementTimerTask = null; &#125; mRecorder = null; &#125;&#125; 可以看到在 onStartCommand() 里面有一个 startRecording() 方法，在外部启动这个 RecordingService 的时候，便会调用这个 startRecording() 方法开始录音。 在 startRecording() 方法中先调用了 setFileNameAndPath 方法，初始化了录音文件的名字和保存的路径，为了让每个录音文件都有唯一的名字，我调用 System.currentMillis() 拼接到录音文件的名字里面。 public void setFileNameAndPath() &#123; int count = 0; File f; do &#123; count++; mFileName = getString(R.string.default_file_name) + "_" + (System.currentTimeMillis()) + ".mp4"; mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath(); mFilePath += "/SoundRecorder/" + mFileName; f = new File(mFilePath); &#125; while (f.exists() &amp;&amp; !f.isDirectory());&#125; 设置好了文件的名字和保存路径之后，对 mRecorder 进行一系列参数的设置，这个mRecorder 是 MediaRecorder 的一个实例，专门用于录音的存储。 public void startRecording() &#123; setFileNameAndPath(); mRecorder = new MediaRecorder(); mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mRecorder.setOutputFile(mFilePath); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC); mRecorder.setAudioChannels(1); mRecorder.setAudioSamplingRate(44100); mRecorder.setAudioEncodingBitRate(192000); try &#123; mRecorder.prepare(); mRecorder.start(); mStartingTimeMillis = System.currentTimeMillis(); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125;&#125; 设置好参数之后，启动 mRecorder 开始录音，可以看到启动 mRecorder 开始录音后，我还将当前的时间赋值给 mStartingTimeMills，这里主要是为了记录录音的时长，等到录音结束后再获取一次当前的时间，然后将两个时间进行相减，就能得到录音的具体时长了。 等到录音结束，停止服务后，便会回调 RecordingService 的 onDestroy() 方法，这时候便会调用 stopRecording() 方法，关闭 mRecorder，并用 SharedPreferences 保存录音文件的信息，最后将 mRecorder 置空，防止内存泄露。 public void stopRecording() &#123; mRecorder.stop(); mElapsedMillis = (System.currentTimeMillis() - mStartingTimeMillis); mRecorder.release(); getSharedPreferences("sp_name_audio", MODE_PRIVATE) .edit() .putString("audio_path", mFilePath) .putLong("elpased", mElapsedMillis) .apply(); if (mIncrementTimerTask != null) &#123; mIncrementTimerTask.cancel(); mIncrementTimerTask = null; &#125; mRecorder = null;&#125; 显示录音界面的 RecordAudioDialogFragmentpublic class RecordAudioDialogFragment extends DialogFragment &#123; private static final String TAG = "RecordAudioDialogFragme"; private int mRecordPromptCount = 0; private boolean mStartRecording = true; private boolean mPauseRecording = true; long timeWhenPaused = 0; private FloatingActionButton mFabRecord; private Chronometer mChronometerTime; private ImageView mIvClose; private OnAudioCancelListener mListener; public static RecordAudioDialogFragment newInstance() &#123; RecordAudioDialogFragment dialogFragment = new RecordAudioDialogFragment(); Bundle bundle = new Bundle(); dialogFragment.setArguments(bundle); return dialogFragment; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); &#125; @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_record_audio, null); initView(view); mFabRecord.setColorNormal(getResources().getColor(R.color.colorAccent)); mFabRecord.setColorPressed(getResources().getColor(R.color.colorAccent)); mFabRecord.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(getActivity() , new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO&#125;, 1); &#125; else &#123; onRecord(mStartRecording); mStartRecording = !mStartRecording; &#125; &#125; &#125;); mIvClose.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onCancel(); &#125; &#125;); builder.setCancelable(false); builder.setView(view); return builder.create(); &#125; private void initView(View view) &#123; mChronometerTime = (Chronometer) view.findViewById(R.id.record_audio_chronometer_time); mFabRecord = (FloatingActionButton) view.findViewById(R.id.record_audio_fab_record); mIvClose = (ImageView) view.findViewById(R.id.record_audio_iv_close); &#125; Intent intent; private void onRecord(boolean start) &#123; intent = new Intent(getActivity(), RecordingService.class); if (start) &#123; // start recording mFabRecord.setImageResource(R.drawable.ic_media_stop); //mPauseButton.setVisibility(View.VISIBLE); Toast.makeText(getActivity(), "开始录音...", Toast.LENGTH_SHORT).show(); File folder = new File(Environment.getExternalStorageDirectory() + "/SoundRecorder"); if (!folder.exists()) &#123; //folder /SoundRecorder doesn't exist, create the folder folder.mkdir(); &#125; //start Chronometer mChronometerTime.setBase(SystemClock.elapsedRealtime()); mChronometerTime.start(); //start RecordingService getActivity().startService(intent); //keep screen on while recording// getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125; @Override public void onDestroyView() &#123; if (!mStartRecording) &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; super.onDestroyView(); &#125; public void setOnCancelListener(OnAudioCancelListener listener) &#123; this.mListener = listener; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED) &#123; onRecord(mStartRecording); &#125; break; &#125; &#125; public interface OnAudioCancelListener &#123; void onCancel(); &#125;&#125; 可以看到在 RecordAudioDialogFragment 有一个 newInstance(int maxTime) 的静态方法供外部调用，如果想设置录音的最大时长，直接传参数进去就行了。 这个对话框的重点部分就是在 onCreateDialog()中，我们先加载了我们自定义的对话框的布局，当点击录音的按钮的时候，先进行相关权限的申请，录音权限 android.permission.RECORD_AUDIO public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_record_audio, null); initView(view); mFabRecord.setColorNormal(getResources().getColor(R.color.colorAccent)); mFabRecord.setColorPressed(getResources().getColor(R.color.colorAccent)); mFabRecord.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(getActivity() , new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO&#125;, 1); &#125; else &#123; onRecord(mStartRecording); mStartRecording = !mStartRecording; &#125; &#125; &#125;); mIvClose.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onCancel(); &#125; &#125;); builder.setCancelable(false); builder.setView(view); return builder.create();&#125; 申请好权限之后便会调用 onRecord() 这个方法，然后将 boolean mStartRecording 进行反转，这样就不用写难看的 if else 了，直接改变 mStartRecording 的值，然后在 onRecord() 里面进行处理。 private void onRecord(boolean start) &#123; intent = new Intent(getActivity(), RecordingService.class); if (start) &#123; // start recording mFabRecord.setImageResource(R.drawable.ic_media_stop); //mPauseButton.setVisibility(View.VISIBLE); Toast.makeText(getActivity(), "开始录音...", Toast.LENGTH_SHORT).show(); File folder = new File(Environment.getExternalStorageDirectory() + "/SoundRecorder"); if (!folder.exists()) &#123; //folder /SoundRecorder doesn't exist, create the folder folder.mkdir(); &#125; //start Chronometer mChronometerTime.setBase(SystemClock.elapsedRealtime()); mChronometerTime.start(); //start RecordingService getActivity().startService(intent); //keep screen on while recording// getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125; 创建了保存录音文件的文件夹，然后根据 mStartRecording 的值进行 RecordingService 的启动和关闭罢了。在启动时还顺便开始了 mChronometer 的计时显示，这是一个 Android 原生的显示计时的一个控件。 播放录音的 PlaybackDialogFragment外部调用这个对话框的时候，只需要传入一个包含录音文件信息的 RecordingItem，因为包含的信息比较多，所以最好将 RecordingItem 进行序列化。 public static PlaybackDialogFragment newInstance(RecordingItem item) &#123; PlaybackDialogFragment f = new PlaybackDialogFragment(); Bundle b = new Bundle(); b.putParcelable(ARG_ITEM, item); f.setArguments(b); return f;&#125; 来看看 onCreateDialog() 方法，在加载了布局之后，给 mSeekBar 设置监听，mSeekBar 是一个显示进度条的控件，当开始播放录音时候，将录音文件的时长，设置进 mSeekBar 里面，播放录音的同时，运行 mSeekBar，通过监听 mSeekBar 的进度，刷新显示的播放进度。 public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_media_playback, null); mFileNameTextView = (TextView) view.findViewById(R.id.file_name_text_view); mFileLengthTextView = (TextView) view.findViewById(R.id.file_length_text_view); mCurrentProgressTextView = (TextView) view.findViewById(R.id.current_progress_text_view); mSeekBar = (SeekBar) view.findViewById(R.id.seekbar); ColorFilter filter = new LightingColorFilter (getResources().getColor(R.color.green), getResources().getColor(R.color.green)); mSeekBar.getProgressDrawable().setColorFilter(filter); mSeekBar.getThumb().setColorFilter(filter); mFileLengthTextView.setText(String.valueOf(mFileLength)); mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; if(mMediaPlayer != null &amp;&amp; fromUser) &#123; mMediaPlayer.seekTo(progress); mHandler.removeCallbacks(mRunnable); long minutes = TimeUnit.MILLISECONDS.toMinutes(mMediaPlayer.getCurrentPosition()); long seconds = TimeUnit.MILLISECONDS.toSeconds(mMediaPlayer.getCurrentPosition()) - TimeUnit.MINUTES.toSeconds(minutes); mCurrentProgressTextView.setText(String.format("%02d:%02d", minutes,seconds)); updateSeekBar(); &#125; else if (mMediaPlayer == null &amp;&amp; fromUser) &#123; prepareMediaPlayerFromPoint(progress); updateSeekBar(); &#125; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; if(mMediaPlayer != null) &#123; // remove message Handler from updating progress bar mHandler.removeCallbacks(mRunnable); &#125; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; if (mMediaPlayer != null) &#123; mHandler.removeCallbacks(mRunnable); mMediaPlayer.seekTo(seekBar.getProgress()); long minutes = TimeUnit.MILLISECONDS.toMinutes(mMediaPlayer.getCurrentPosition()); long seconds = TimeUnit.MILLISECONDS.toSeconds(mMediaPlayer.getCurrentPosition()) - TimeUnit.MINUTES.toSeconds(minutes); mCurrentProgressTextView.setText(String.format("%02d:%02d", minutes,seconds)); updateSeekBar(); &#125; &#125; &#125;); mPlayButton = (FloatingActionButton) view.findViewById(R.id.fab_play); mPlayButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onPlay(isPlaying); isPlaying = !isPlaying; &#125; &#125;); mFileNameTextView.setText(item.getName()); mFileLengthTextView.setText(String.format("%02d:%02d", minutes,seconds)); builder.setView(view); // request a window without the title dialog.getWindow().requestFeature(Window.FEATURE_NO_TITLE); return builder.create();&#125; 当点击播放录音的按钮之后，会调用 onPlay() 方法，然后根据 isPlaying（标识当前是否播放录音）的值，来调用不同的方法。 private void onPlay(boolean isPlaying)&#123; if (!isPlaying) &#123; //currently MediaPlayer is not playing audio if(mMediaPlayer == null) &#123; startPlaying(); //start from beginning &#125; else &#123; resumePlaying(); //resume the currently paused MediaPlayer &#125; &#125; else &#123; pausePlaying(); &#125;&#125; 我们最关心的，莫过于 startPlaying() 这个方法，这个方法便是来开启播放录音的，我们首先将外部传入的有关的录音信息，设置给 MediaPlayer，然后开始调用 mMediaPlayer.start() 进行录音的播放，然后调用 updateSeekbar() 实时更新进度条的内容。当 MediaPlayer 的内容播放完成后，调用 stopPlaying() 方法，关闭 mMediaPlayer。 private void startPlaying() &#123; mPlayButton.setImageResource(R.drawable.ic_media_pause); mMediaPlayer = new MediaPlayer(); try &#123; mMediaPlayer.setDataSource(item.getFilePath()); mMediaPlayer.prepare(); mSeekBar.setMax(mMediaPlayer.getDuration()); mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; mMediaPlayer.start(); &#125; &#125;); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125; mMediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; stopPlaying(); &#125; &#125;); updateSeekBar(); //keep screen on while playing audio getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);&#125; 以上便是本文的全部内容，有关的代码我已经上传到 Github 上了，需要的 点击这里，喜欢的话，欢迎来波 star 和 fork。]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>录音</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[婚礼筹备]]></title>
    <url>%2Fposts%2F95cd02d2.html</url>
    <content type="text"><![CDATA[即将步入人生的第一件大事，在此记录下点滴事件：]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android Utils工具类方法大集合]]></title>
    <url>%2Fposts%2F1cc851d3.html</url>
    <content type="text"><![CDATA[/** * 提供精确的小数位四舍五入处理，保留几位小数。 * * @param v 需要四舍五入的数字 * @param scale 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException("The scale must be a positive integer or zero"); &#125; BigDecimal b = new BigDecimal(Double.toString(v)); BigDecimal one = new BigDecimal("1"); double bb = b.divide(one, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); return bb; &#125; /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 定精度，以后的数字四舍五入。 * * @param v1 被除数 * @param v2 除数 * @param scale 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double div(double v1, double v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException("The scale must be a positive integer or zero"); &#125; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /** * 提供精确的乘法运算。 * * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static double mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; /** * 检查手机上是否安装了指定的软件 * * @param context * @param packageName ：应用包名 * @return */ public static boolean isAvilible(Context context, String packageName) &#123; // 获取packagemanager PackageManager packageManager = context.getPackageManager(); // 获取所有已安装程序的包信息 List&lt;PackageInfo&gt; packageInfos = packageManager.getInstalledPackages(0); // 用于存储所有已安装程序的包名 List&lt;String&gt; packageNames = new ArrayList&lt;String&gt;(); // 从pinfo中将包名字逐一取出，压入pName list中 if (packageInfos != null) &#123; for (int i = 0; i &lt; packageInfos.size(); i++) &#123; String packName = packageInfos.get(i).packageName; packageNames.add(packName); &#125; &#125; // 判断packageNames中是否有目标程序的包名，有TRUE，没有FALSE return packageNames.contains(packageName); &#125; /** * 根据一个网络连接(String)获取bitmap图像 * * @param imageUri * @return */ public static Bitmap getbitmap(String imageUri) &#123; Log.v("", "getbitmap:" + imageUri); // 显示网络上的图片 Bitmap bitmap = null; try &#123; URL myFileUrl = new URL(imageUri); HttpURLConnection conn = (HttpURLConnection) myFileUrl .openConnection(); conn.setDoInput(true); conn.connect(); InputStream is = conn.getInputStream(); bitmap = BitmapFactory.decodeStream(is); is.close(); Log.v("", "image download finished." + imageUri); &#125; catch (OutOfMemoryError e) &#123; e.printStackTrace(); bitmap = null; &#125; catch (IOException e) &#123; e.printStackTrace(); Log.v("", "getbitmap bmp fail---"); bitmap = null; &#125; return bitmap; &#125; /** * 将字符串转换成Bitmap类型 * * @param * @return */ public static Bitmap stringtoBitmap(String string) &#123; Bitmap bitmap = null; try &#123; byte[] bitmapArray; bitmapArray = Base64.decode(string, Base64.DEFAULT); bitmap = BitmapFactory.decodeByteArray(bitmapArray, 0, bitmapArray.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125; /** * 将Bitmap转换成字符串 * * @param bitmap * @return */ public static String bitmaptoString(Bitmap bitmap) &#123; String string = null; ByteArrayOutputStream bStream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 100, bStream); byte[] bytes = bStream.toByteArray(); string = Base64.encodeToString(bytes, Base64.DEFAULT); return string; &#125; /** * 返回当前程序版本名-V2 三段修改---ex 5.2---5.21 * support 7.8.8.1, 7.18.8.1, 17.18.8.1 modified by chenhong, 2018-5-25 */ public static String getAppVersionNameV2(Context context) &#123; String versionCode = ""; try &#123; PackageInfo pi = MyApp.getAppContext().getPackageManager().getPackageInfo(MyApp.getAppContext().getPackageName(), 0); versionCode = pi.versionName; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (!TextUtils.isEmpty(versionCode)) &#123; int firstDotIndex = versionCode.indexOf("."); if (firstDotIndex &gt; -1) &#123; String mainVersion = versionCode.substring(0, firstDotIndex); String subVersion = ""; if (versionCode.length() &gt; firstDotIndex + 1) &#123; subVersion = versionCode.substring(firstDotIndex + 1); subVersion = subVersion.replace(".", ""); &#125; versionCode = mainVersion + "." + subVersion; int length = versionCode.length(); int dotIndex = versionCode.indexOf("."); if (dotIndex == length - 1) &#123; versionCode += "00"; &#125; else if (dotIndex == length - 2) &#123; versionCode += "0"; &#125; &#125; else &#123; versionCode += ".00"; &#125; &#125; return versionCode; &#125; /** * 获取IP地址 * * @param context * @return */ public static String getIPAddress(Context context) &#123; NetworkInfo info = ((ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo(); if (info != null &amp;&amp; info.isConnected()) &#123; if (info.getType() == ConnectivityManager.TYPE_MOBILE) &#123;//当前使用2G/3G/4G网络 try &#123; //Enumeration&lt;NetworkInterface&gt; en=NetworkInterface.getNetworkInterfaces(); for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) &#123; return inetAddress.getHostAddress(); &#125; &#125; &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; else if (info.getType() == ConnectivityManager.TYPE_WIFI) &#123;//当前使用无线网络 WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); String ipAddress = intIP2StringIP(wifiInfo.getIpAddress());//得到IPV4地址 return ipAddress; &#125; &#125; else &#123; //当前无网络连接,请在设置中打开网络 &#125; return null; &#125; /** * 将得到的int类型的IP转换为String类型 * * @param ip * @return */ public static String intIP2StringIP(int ip) &#123; return (ip &amp; 0xFF) + "." + ((ip &gt;&gt; 8) &amp; 0xFF) + "." + ((ip &gt;&gt; 16) &amp; 0xFF) + "." + (ip &gt;&gt; 24 &amp; 0xFF); &#125; /** * 获取屏幕高度 * * @param context * @return */ public static int getWindowHeight(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); int windowHeight = wm.getDefaultDisplay().getHeight(); return windowHeight; &#125; /** * 获取屏幕宽度 * * @param context * @return */ public static int getWindowWidth(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); int windowWidth = wm.getDefaultDisplay().getWidth(); return windowWidth; &#125; /** * json字符串转map * * @param jsonString * @return */ public static Map transStringToMap(String jsonString) &#123; Gson gson = new Gson(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map = gson.fromJson(jsonString, map.getClass()); return map; &#125; /** * 计算两个时间相隔多少天 * * @return */ public static String getDayNumberStr(String nowDate, String createDate) &#123; String str = ""; int strDay = 0; DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); try &#123; Date d1 = df.parse(nowDate); Date d2 = df.parse(createDate); long diff = d1.getTime() - d2.getTime();//这样得到的差值是微秒级别 long days = diff / (1000 * 60 * 60 * 24); long hours = (diff - days * (1000 * 60 * 60 * 24)) / (1000 * 60 * 60); long minutes = (diff - days * (1000 * 60 * 60 * 24) - hours * (1000 * 60 * 60)) / (1000 * 60);// System.out.println("" + days + "天" + hours + "小时" + minutes + "分"); str = days + ""; strDay = Integer.parseInt(str) + 1; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return strDay + ""; &#125; /** * 获得当天0点时间 */ public static int getTimesmorning() &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.MILLISECOND, 0); return (int) (cal.getTimeInMillis() / 1000); &#125; /** * 获得当天24点时间 */ public static int getTimesnight() &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, 24); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.MILLISECOND, 0); return (int) (cal.getTimeInMillis() / 1000); &#125; /** * 获得当天时间 */ public static String getTodayDate() &#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");//设置日期格式 String date = df.format(new Date());// new Date()为获取当前系统时间 return date; &#125; /** * 判断当前时间是否在时间date之前 date1 7点 date2 8点 * 时间格式 2005-4-21 16:16:34 "yyyy-MM-dd HH:mm:ss" * * @param date * @return * @throws ParseException */ public static boolean isDateBefore(String date) throws ParseException &#123; Date date1 = new Date();//当前时间 DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return date1.before(df.parse(date)); &#125; /** * 判断当前时间是否在时间date之后 date1 8点 date2 5点 * * @param date * @return * @throws ParseException */ public static boolean isDateAfter(String date) throws ParseException &#123; Date date1 = new Date();//当前时间 DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return (df.parse(date)).before(date1); &#125; /** * 大小写转换 * * @param UpperCasestr * @return * @throws Exception */ public static String toUpperCase(String UpperCasestr) throws Exception &#123; return UpperCasestr.toUpperCase().toString(); &#125; /** * 去除字符串空格 * * @return */ public static String removeAllSpace(String str) &#123; String tmpstr = str.replace(" ", ""); return tmpstr; &#125; /** * 获取当前网络类型 * * @return */ public static String getNetworkTypeAll() &#123; String strNetworkType = ""; ConnectivityManager cm = (ConnectivityManager) MyApp.mContext.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = cm.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isConnected()) &#123; if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) &#123; strNetworkType = "WIFI"; &#125; else if (networkInfo.getType() == ConnectivityManager.TYPE_MOBILE) &#123; String _strSubTypeName = networkInfo.getSubtypeName(); // TD-SCDMA networkType is 17 int networkType = networkInfo.getSubtype(); switch (networkType) &#123; case TelephonyManager.NETWORK_TYPE_GPRS: case TelephonyManager.NETWORK_TYPE_EDGE: case TelephonyManager.NETWORK_TYPE_CDMA: case TelephonyManager.NETWORK_TYPE_1xRTT: case TelephonyManager.NETWORK_TYPE_IDEN: //api&lt;8 : replace by 11 strNetworkType = "2G"; break; case TelephonyManager.NETWORK_TYPE_UMTS: case TelephonyManager.NETWORK_TYPE_EVDO_0: case TelephonyManager.NETWORK_TYPE_EVDO_A: case TelephonyManager.NETWORK_TYPE_HSDPA: case TelephonyManager.NETWORK_TYPE_HSUPA: case TelephonyManager.NETWORK_TYPE_HSPA: case TelephonyManager.NETWORK_TYPE_EVDO_B: //api&lt;9 : replace by 14 case TelephonyManager.NETWORK_TYPE_EHRPD: //api&lt;11 : replace by 12 case TelephonyManager.NETWORK_TYPE_HSPAP: //api&lt;13 : replace by 15 strNetworkType = "3G"; break; case TelephonyManager.NETWORK_TYPE_LTE: //api&lt;11 : replace by 13 strNetworkType = "4G"; break; default: if (_strSubTypeName.equalsIgnoreCase("TD-SCDMA") || _strSubTypeName.equalsIgnoreCase("WCDMA") || _strSubTypeName.equalsIgnoreCase("CDMA2000")) &#123; strNetworkType = "3G"; &#125; else &#123; strNetworkType = _strSubTypeName; &#125; break; &#125; &#125; &#125; return strNetworkType; &#125; /** * 获取sim卡运营商信息 */ public static String getSimOperator() &#123; String operator = ""; try &#123; TelephonyManager telManager = (TelephonyManager) MyApp.mContext.getSystemService(Context.TELEPHONY_SERVICE); operator = telManager.getSimOperator(); if (operator != null) &#123; if (operator.equals("46000") || operator.equals("46002") || operator.equals("46007")) &#123; operator = "中国移动"; &#125; else if (operator.equals("46001")) &#123; operator = "中国联通"; &#125; else if (operator.equals("46003")) &#123; operator = "中国电信"; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return operator; &#125; return operator; &#125; /** * 强制隐藏输入法键盘 * * @param context Context * @param view EditText */ public void hideInput(Context context, View view) &#123; InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), 0); &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android get请求和post请求区别]]></title>
    <url>%2Fposts%2Fcec09649.html</url>
    <content type="text"><![CDATA[Get请求与Post请求的区别Get是向服务器发索取数据的一种请求 Get是获取信息，而不是修改信息，类似数据库查询功能一样，数据不会被修改 Get请求的参数会跟在url后进行传递，请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连,％XX中的XX为该符号以16进制表示的ASCII，如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。 Get传输的数据有大小限制，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了，不同的浏览器对URL的长度的限制是不同的。 GET请求的数据会被浏览器缓存起来，用户名和密码将明文出现在URL上，其他人可以查到历史浏览记录，数据不太安全。在服务器端，用Request.QueryString来获取Get方式提交来的数据 Post是向服务器提交数据的一种请求 Post请求则作为http消息的实际内容发送给web服务器，数据放置在HTML Header内提交，Post没有限制提交的数据。Post比Get安全，当数据是中文或者不敏感的数据，则用get，因为使用get，参数会显示在地址，对于敏感数据和不是中文字符的数据，则用post POST表示可能修改变服务器上的资源的请求，在服务器端，用Post方式提交的数据只能用Request.Form来获取]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 切换账户]]></title>
    <url>%2Fposts%2F7f469116.html</url>
    <content type="text"><![CDATA[问题 提交代码，但github上的绿格子没有变绿 新老账户切换 如果你不知道现在本地Git用的帐号是什么，你可以输入 Step 1 查看用户名git config user.name Step 2 查看用户邮箱git config user.email Step 3 修改用户名和邮箱的命令git config --global user.name "Your_username"git config --global user.email "Your_email" 注意user.name，user.email 后面千万记得加空格，否则你就是提交了，Git也不会提醒你配置出错]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Webview里设置Cookie]]></title>
    <url>%2Fposts%2F3defa4a1.html</url>
    <content type="text"><![CDATA[Android中WebView加载网页，有时候需要通过cookie想网页传递信息，这时候这样操作。 Step 1 设置接收cookieCookieManager.setAcceptFileSchemeCookies(true);CookieManager.getInstance().setAcceptCookie(true);CookieManager.setAcceptFileSchemeCookies(true); Step 2 设置cookie的值，通过setcookie方法List&lt;String&gt; cookies = new ArrayList&lt;&gt;();cookies.add("app_key=" + App.getAppKey());cookies.add("os=" + "Android" + Build.VERSION.SDK_INT); Step 3 通过sync方法，将cookie同步if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context);&#125;CookieManager cookieManager = CookieManager.getInstance();cookieManager.setAcceptCookie(true);if (cookies != null) &#123; for (String cookie : cookies) &#123; cookieManager.setCookie(url, cookie); &#125;&#125;String s = "Domain=.***.com";String s1 = "Path=/";cookieManager.setCookie(url, s);cookieManager.setCookie(url, s1);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123; CookieManager.getInstance().flush();&#125; else &#123; CookieSyncManager.getInstance().sync();&#125; &quot;;Domain=.xxxx.xxx.com&quot;+//作用域（在哪个域名下cookie起作用）&quot;;Path=/&quot;;//Domain这个作用域下的哪个文件夹，“/”代表所有文件夹 注意 在调用设置Cookie之后不能再设置这类属性，否则设置Cookie无效。&gt; webView.getSettings().setBuiltInZoomControls(true); &gt; webView.getSettings().setJavaScriptEnabled(true); &gt; #### 完整代码​```javapublic class WebviewUtil &#123; public static void setWebCookie(Context context) &#123; CookieManager.setAcceptFileSchemeCookies(true); CookieManager.getInstance().setAcceptCookie(true); CookieManager.setAcceptFileSchemeCookies(true); setCookie(context); &#125; private static void setCookie(Context context) &#123; List&lt;String&gt; cookies = new ArrayList&lt;&gt;(); cookies.add(&quot;app_key=&quot; + App.getAppKey()); cookies.add(&quot;plat=&quot; + &quot;2&quot;); cookies.add(&quot;os=&quot; + &quot;Android&quot; + Build.VERSION.SDK_INT); cookies.add(&quot;channel=&quot; + AndroidUtil.getChannel()); cookies.add(&quot;cver=&quot; + String.valueOf(App.getVersionCode())); cookies.add(&quot;ctype=&quot; + 2); cookies.add(&quot;cspec=&quot; + &quot;&quot;); if (AccountManager.hasLogin()) &#123; cookies.add(&quot;user_id=&quot; + getUserId()); cookies.add(&quot;gz_id=&quot; + getUserId()); &#125; syncCookie(context, &quot;.7gz.com/&quot;, cookies); &#125; private static void syncCookie(Context context, String url, List&lt;String&gt; cookies) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); if (cookies != null) &#123; for (String cookie : cookies) &#123; cookieManager.setCookie(url, cookie); &#125; &#125; String s = &quot;Domain=.7gz.com&quot;; String s1 = &quot;Path=/&quot;; cookieManager.setCookie(url, s); cookieManager.setCookie(url, s1); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123; CookieManager.getInstance().flush(); &#125; else &#123; CookieSyncManager.getInstance().sync(); &#125; &#125; private static String getUserId() &#123; return AccountManager.getInstance().getAccount().id; &#125; //清空所有Cookie public static void removeAllCookie(Context context) &#123; CookieSyncManager.createInstance(context); //Create a singleton CookieSyncManager within a context CookieManager cookieManager = CookieManager.getInstance(); // the singleton CookieManager instance cookieManager.removeAllCookie();// Removes all cookies. CookieSyncManager.getInstance().sync(); // forces sync manager to sync now &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 圆角圆形ImageView]]></title>
    <url>%2Fposts%2F494f41c5.html</url>
    <content type="text"><![CDATA[效果预览 特点 基于AppCompatImageView扩展 支持圆角、圆形显示 可绘制边框，圆形时可绘制内外两层边框 支持边框不覆盖图片 可绘制遮罩 …… 支持的属性、方法 属性名 含义 默认值 对应方法 is_circle 是否显示为圆形（默认为矩形） false isCircle() corner_top_left_radius 左上角圆角半径 0dp setCornerTopLeftRadius() corner_top_right_radius 右上角圆角半径 0dp setCornerTopRightRadius() corner_bottom_left_radius 左下角圆角半径 0dp setCornerBottomLeftRadius() corner_bottom_right_radius 右下角圆角半径 0dp setCornerBottomRightRadius() corner_radius 统一设置四个角的圆角半径 0dp setCornerRadius() border_width 边框宽度 0dp setBorderWidth() border_color 边框颜色 #ffffff setBorderColor() inner_border_width 相当于内层边框（is_circle为true时支持） 0dp setInnerBorderWidth() inner_border_color 内边框颜色 #ffffff setInnerBorderColor() is_cover_src border、inner_border是否覆盖图片内容 false isCoverSrc() mask_color 图片上绘制的遮罩颜色 不设置颜色则不绘制 setMaskColor() 基本用法Step 1. 添加JitPack仓库 在项目根目录下的 build.gradle 中添加仓库: allprojects &#123; repositories &#123; ... maven &#123; url "https://jitpack.io" &#125; &#125;&#125; Step 2. 添加项目依赖 dependencies &#123; implementation 'com.github.zhangmiaocc:CircularImageView:1.0.0'&#125; **Step 3. 在布局文件中添加 CornerLabelView &lt;com.zm.library.CircularImageView android:layout_width="100dp" android:layout_height="100dp" android:src="@drawable/rabbit" app:border_color="#008B45" app:border_width="2dp" app:corner_radius="20dp" app:inner_border_color="#FF7F24" app:inner_border_width="4dp" app:is_circle="true" /&gt; 源码：CircularImageView]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>CircleImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnimationDrawable使用简介]]></title>
    <url>%2Fposts%2Fd6df4d7b.html</url>
    <content type="text"><![CDATA[Drawable animation可以加载Drawable资源实现帧动画。AnimationDrawable是实现Drawable animations的基本类。推荐用XML文件的方法实现Drawable动画，不推荐在代码中实现。这种XML文件存放在工程中res/drawable/目录下。XML文件的指令(即属性)为动画播放的顺序和时间间隔。 ​ 在XML文件中元素为根节点，节点定义了每一帧，表示一个drawable资源的帧和帧间隔。下面是一个XML文件的实例: &lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/loading1" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading2" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading3" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading4" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading5" android:duration="100" /&gt;&lt;/animation-list&gt; 设置Android:oneshot属性为true,表示此次动画只执行一次，最后停留在最后一帧。设置为false则动画循环播放。文件可以添加为Image背景，触发的时候播放。 下面简单通过一个例子，来给ImageView设置次动画效果，具体实现方法为 通过View. setBackgroundResource(resID). animation.start(). private AnimationDrawable animationDrawable; img = (ImageView) findViewById(R.id.img); img.setImageResource(R.drawable.anim_loading); animationDrawable = ((AnimationDrawable) img.getDrawable()); animationDrawable.start(); Demo地址：https://github.com/zhangmiaocc/AnimationDrawable Blog地址：https://zhangmiao.cc/]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android加载PDF文件的使用]]></title>
    <url>%2Fposts%2F44884a58.html</url>
    <content type="text"><![CDATA[Android PdfViewerAndroidPdfViewer 1.x可在AndroidPdfViewerV1 repo上获得，可以独立开发。版本1.x使用不同的引擎在画布上绘制文档，因此如果您不喜欢2.x版本，请尝试1.x. 图书馆在Android上显示的PDF文档，用animations，gestures，zoom和double tap支持。它基于PdfiumAndroid来解码PDF文件。适用于API 11（Android 3.0）及更高版本。在Apache License 2.0下获得许可。 3.1.0-beta.1有什么新功能？ 合并拉取请求＃557用于捕捉页面（逐页滚动） 合并拉出请求＃618用于夜间模式 合并拉取请求＃566 OnLongTapListener 将PdfiumAndroid更新为1.9.0，而c++_shared不是使用gnustl_static 更新Gradle插件 将编译SDK和支持库更新到26 将最低SDK更改为14 3.0 API的变化 换成Contants.PRELOAD_COUNT了PRELOAD_OFFSET 删除PDFView#fitToWidth()（没有参数的变体） 删除Configurator#invalidPageColor(int)方法，因为无法呈现无效页面 从OnRenderListener#onInitiallyRendered(int)方法中删除了页面大小参数，因为文档可能具有不同的页面大小 删除PDFView#setSwipeVertical()方法 安装添加到build.gradle： compile &#39;com.github.barteksc:android-pdf-viewer:3.1.0-beta.1&#39; 或者如果你想使用更稳定的版本： compile &#39;com.github.barteksc:android-pdf-viewer:2.8.2&#39; 库在jcenter存储库中可用，可能它很快就会在Maven Central中。 ProGuard的如果您使用的是ProGuard，请将以下规则添加到proguard配置文件中： -keep class com.shockwave.** 在布局中包含PDFView&lt;com.github.barteksc.pdfviewer.PDFView android:id=&quot;@+id/pdfView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 加载PDF文件所有可用选项都带有默认值： pdfView.fromUri(Uri)orpdfView.fromFile(File)orpdfView.fromBytes(byte[])orpdfView.fromStream(InputStream) // stream is written to bytearray - native code cannot use Java StreamsorpdfView.fromSource(DocumentSource)orpdfView.fromAsset(String) .pages(0, 2, 1, 3, 3, 3) // all pages are displayed by default .enableSwipe(true) // allows to block changing pages using swipe .swipeHorizontal(false) .enableDoubletap(true) .defaultPage(0) // allows to draw something on the current page, usually visible in the middle of the screen .onDraw(onDrawListener) // allows to draw something on all pages, separately for every page. Called only for visible pages .onDrawAll(onDrawListener) .onLoad(onLoadCompleteListener) // called after document is loaded and starts to be rendered .onPageChange(onPageChangeListener) .onPageScroll(onPageScrollListener) .onError(onErrorListener) .onPageError(onPageErrorListener) .onRender(onRenderListener) // called after document is rendered for the first time // called on single tap, return true if handled, false to toggle scroll handle visibility .onTap(onTapListener) .onLongPress(onLongPressListener) .enableAnnotationRendering(false) // render annotations (such as comments, colors or forms) .password(null) .scrollHandle(null) .enableAntialiasing(true) // improve rendering a little bit on low-res screens // spacing between pages in dp. To define spacing color, set view background .spacing(0) .autoSpacing(false) // add dynamic spacing to fit each page on its own on the screen .linkHandler(DefaultLinkHandler) .pageFitPolicy(FitPolicy.WIDTH) .pageSnap(true) // snap pages to screen boundaries .pageFling(false) // make a fling change only a single page like ViewPager .nightMode(false) // toggle night mode .load(); 注意pages 是可选的，它允许您根据需要过滤和排序PDF页面 滚动手柄Scroll handle是从1.x分支替换ScrollBar。 从版本2.1.0将PDFView放在RelativeLayout中以使用ScrollHandle不是必需的，您可以使用任何布局。 要使用滚动手柄，只需使用方法注册它Configurator#scrollHandle()。此方法接受ScrollHandle接口的实现。 AndroidPdfViewer附带默认实现，您可以使用它 .scrollHandle(new DefaultScrollHandle(this))。 DefaultScrollHandle位于右侧（垂直滚动时）或底部（水平滚动时）。通过使用带有第二个参数（new DefaultScrollHandle(this, true)）的构造函数，可以将句柄放在左侧或顶部。 您还可以创建自定义滚动句柄，只需实现ScrollHandle界面。所有方法都记录为接口源上的Javadoc注释。 文件来源2.3.0版引入了文档源，它们只是PDF文档的提供者。每个提供程序都实现DocumentSource接口。预定义的提供程序可以在com.github.barteksc.pdfviewer.source包中找到，可以用作创建自定义提供程序的示例。 预定义的提供程序可以与速记方法一起使用： pdfView.fromUri(Uri)pdfView.fromFile(File)pdfView.fromBytes(byte[])pdfView.fromStream(InputStream)pdfView.fromAsset(String) 自定义提供程序可与pdfView.fromSource(DocumentSource)方法一起使用。 链接3.0.0版引入了对PDF文档中链接的支持。默认情况下，使用DefaultLinkHandler 并单击引用同一文档中的页面的链接会导致跳转到目标页面并单击以某个URI为目标的链接导致在默认应用程序中打开它。 您还可以创建自定义链接处理程序，只需实现LinkHandler接口并使用Configurator#linkHandler(LinkHandler)方法进行设置 。查看DefaultLinkHandler 源以实现自定义行为。 页面符合政策从版本3.0.0开始，库支持以3种模式将页面装入屏幕： 宽度 - 最宽页面的宽度等于屏幕宽度 高度 - 最高页面的高度等于屏幕高度 BOTH - 基于最宽和最高的页面，每个页面都缩放为在屏幕上完全可见 除了选定的策略之外，每个页面都会缩放到相对于其他页面的大小。 可以使用适合的策略进行设置Configurator#pageFitPolicy(FitPolicy)。默认策略是WIDTH。 其他选项位图质量默认情况下，生成的位图使用格式压缩RGB_565以减少内存消耗。ARGB_8888可以使用pdfView.useBestQuality(true)方法强制渲染。 双击缩放有三种缩放级别：分钟（默认1），中间（默认1.75）和最大（默认3）。在第一次双击时，视图缩放到中等水平，在第二个到最大水平，第三个返回到最低水平。如果您处于中级和最高级别之间，则双击会导致缩放到最大值，依此类推。 可以使用以下方法更改缩放级别： void setMinZoom(float zoom);void setMidZoom(float zoom);void setMaxZoom(float zoom); 可能的问题为什么导致apk太大了？Android PdfViewer依赖于PdfiumAndroid，它是许多架构的本机库集（大约16 MB）。Apk必须包含所有这些库，以便在市场上的每个设备上运行。幸运的是，Google Play允许我们上传多个apks，例如每个架构一个。有一篇关于自动将您的应用程序拆分为多个apks的文章，可在此处获得。最重要的部分是使用APK Splits改进多个APK创建和版本代码处理，但整篇文章值得一读。您只需要在您的应用程序中执行此操作，无需分支PdfiumAndroid等。 为什么我无法从URL打开PDF？下载文件是一个长时间运行的过程，必须知道Activity生命周期，必须支持一些配置，数据清理和缓存，因此创建这样的模块可能最终会成为新的库。 如何在配置更改后显示上次打开的页面？您必须存储当前页码然后进行设置pdfView.defaultPage(page)，请参阅示例应用程序 如何将文档放入屏幕宽度（例如，方向更改）？FitPolicy.WIDTH如果要在具有不同页面大小的文档中放置所需页面，请使用策略或添加以下代码段： Configurator.onRender(new OnRenderListener() &#123; @Override public void onInitiallyRendered(int pages, float pageWidth, float pageHeight) &#123; pdfView.fitToWidth(pageIndex); &#125;&#125;); 如何像ViewPager一样滚动浏览单个页面？您可以使用以下设置的组合来获得类似于ViewPager的滚动和拖动行为： .swipeHorizontal(true).pageSnap(true).autoSpacing(true).pageFling(true) Demo地址：https://github.com/zhangmiaocc/AndroidPDFView 参考：https://github.com/barteksc/AndroidPdfViewer]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android日志框架Logger的详细使用（目前最新版2.1.1）]]></title>
    <url>%2Fposts%2Fe28061de.html</url>
    <content type="text"><![CDATA[前言在开发过程中，log日志是每个人多会用上的。平时在开发大项目的时候，几乎每个类多需要加log，然而在发布之前，要求全部删除，真是累。因为系统log暂时没有统一管理的方法。还有就是，特别是在调试的时候，对于线程并发或者子线程的调试，还是加log调试比较精确，用debug工具调试经常和实际不符合。那么，如果使用系统log，调试完又得找出来删除，累++。 作为程序猿，这种笨方法肯定是会鄙视的。对于这种需求，我们自己封装一个简单的工具包。当然这里介绍的是，github上很多人用log框架：logger。 相信很多人多用过，这里给还没有尝试过的人简单介绍下，使用也超级简单。 logger作为调试框架，可以支持多种格式： 线程的信息 类、方法的信息 格式化将 json、xml 输出 支持字符串格式参数 各种集合输出，list、map、array、set等，（只支持debug输出） 支持从日志跳转到源码 …… 如下图（引用原作者）： 可以看出，和系统对比，它最大的亮点是优雅的输出log信息，当然同时提供很多其他信息，一目了然，更清晰！ 如果你每天被log折磨的生不如死，那么让logger来拯救你吧~ 作者：Orhan Obut github：https://github.com/orhanobut/logger 目前，将近7.5k个star让他位列调试框架第二名，屈居facebook的stetho之后,8.5k个star。但这2个调试工具应用场景不用，所以简单的调试，logger是最佳选择了。这里简单介绍下stetho，它是一款提供在Chrome开发者工具上调试Android app的开源框架，可以在Chrome查看数据库，不用想以前那样把数据库导出，然后在用工具查看；配合网络框架可以直接打印查看网络请求的数据，而不需要一个一个添加打印出来，省去很多繁琐的事情。有兴趣的可以了解： 作者：FaceBook 官网地址： http://facebook.github.io/stetho/ github https://github.com/facebook/stetho 使用Logger使用框架，是比较简单的，如果可以看英文版，可以直接到https://github.com/orhanobut/logger了解。 logger目前的最新版本是2.1.1，网上也很多人使用1.15的版本，如果使用最新版，单独修改配置文件，是有报错的。因为，最新版在初始化这块和原来有了较大的改动。 主要是初始化、和控制Log打印这2方面。这里介绍2.11的版本使用，所以想升级的也可以往下看看哦。 3步，只要3步，你就学会使用Logger，请： 1.导入依赖 compile 'com.orhanobut:logger:2.1.1' Logger.addLogAdapter(new AndroidLogAdapter()); 注：如果在Application中初始化，记得修改 AndroidManifest.xml 中 application 标签属性，添加 android:name=”.MyApplication” ，不然不会打印。 3.使用 Logger.d("hello"); 如图： 当然，如果还有追求，继续往下看看它的其他功能。 支持的数据类型普通类型public void testNormal()&#123; Logger.d("DEBUG日志"); Logger.i("INFO日志"); Logger.e("ERROR日志");&#125; Format类型public void testFormat()&#123; Logger.d("hello %s, luck number is %d", "world", 5); &#125; 集合类型首先看看List： List list = new ArrayList();list.add("hello");list.add("world");Logger.d(list); Log.d(TAG, list.toString()); 首先是调用： @Override public void d(Object object) &#123; log(DEBUG, null, Utils.toString(object)); &#125; public static String toString(Object object) &#123; if (object == null) &#123; return "null"; &#125; if (!object.getClass().isArray()) &#123; return object.toString(); &#125; if (object instanceof boolean[]) &#123; return Arrays.toString((boolean[]) object); &#125; if (object instanceof byte[]) &#123; return Arrays.toString((byte[]) object); &#125; if (object instanceof char[]) &#123; return Arrays.toString((char[]) object); &#125; if (object instanceof short[]) &#123; return Arrays.toString((short[]) object); &#125; if (object instanceof int[]) &#123; return Arrays.toString((int[]) object); &#125; if (object instanceof long[]) &#123; return Arrays.toString((long[]) object); &#125; if (object instanceof float[]) &#123; return Arrays.toString((float[]) object); &#125; if (object instanceof double[]) &#123; return Arrays.toString((double[]) object); &#125; if (object instanceof Object[]) &#123; return Arrays.deepToString((Object[]) object); &#125; return "Couldn't find a correct type for the object"; &#125; 这样就不需要我们自己调用toString()，直接可以打印了。 其他的数据结构也是一样的，看图就可以了： public void testCollections()&#123; /** * Map */ Map map = new HashMap(); map.put("map1","hello"); map.put("map2","world"); Logger.d(map); /** * Set */ Set set = new HashSet(); set.add("hello"); set.add("world"); Logger.d(set); /** * Array */ String [] strs = &#123;"hello", "world"&#125;; Logger.d(strs); &#125; *注：打印集合的时候，特别是数组时，前面不要添加其他字符，如：Logger.d(“数组集合”+strs);这样会把整体当做一个参数，导致判断错误，不能正常输出数组类型。其次是，作者提示，打印集合时，使用DEBUG等级。* JSON数据public void testJson()&#123; String jsonDate = "&#123;\"id\":859,\"channelnumber\":681,\"bilingual\":0,\"name\":\"beIN Sports 2 English 600K H265\",\n" +" \"language\":\"EN\",\n" +" \"videotype\":\"MPEG2\",\"audiotype\":\"MPEP1\",\"callsign\":\"beIN Sports 2 English 600K H265\",\"country\":\"cn\"&#125;;"; Logger.json(jsonDate); Log.d(TAG, jsonDate); &#125; XML数据public void testXml() &#123; String xmlDate = "&lt;province id=\"01\" name=\"北京\"&gt; \n" + " &lt;city id=\"0101\" name=\"北京\"&gt; \n" + " &lt;county id=\"010101\" name=\"北京\" weatherCode=\"101010100\"/&gt; \n" + " &lt;county id=\"010102\" name=\"海淀\" weatherCode=\"101010200\"/&gt; \n" + " &lt;county id=\"010103\" name=\"朝阳\" weatherCode=\"101010300\"/&gt; \n" + " &lt;county id=\"010110\" name=\"石景山\" weatherCode=\"101011000\"/&gt; \n" + " &lt;/city&gt; \n" + " &lt;/province&gt; "; Logger.xml(xmlDate); Log.d(TAG, xmlDate); &#125; 修改默认配置最新版修改配置，和旧版也是有不同，如下： FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .showThreadInfo(false) //（可选）是否显示线程信息。 默认值为true .methodCount(2) // （可选）要显示的方法行数。 默认2 .methodOffset(7) // （可选）设置调用堆栈的函数偏移值，0的话则从打印该Log的函数开始输出堆栈信息，默认是0 .logStrategy(customLog) //（可选）更改要打印的日志策略。 默认LogCat .tag("MyTAG") //（可选）每个日志的全局标记。 默认PRETTY_LOGGER（如上图） .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy)); 具体配置大家可以自行去实践下。一般默认就可以了，这里说下，修改全局的TAG，和局部的TAG。 1.修改全局的TAG，在初始化的application中修改，如： FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .tag("MyTAG") .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy)); 2.修改局部的TAG，哪里打印就在哪里修改，只对当前打印有效，如： public void testNormal()&#123; Logger.t("hello").d("DEBUG日志"); Logger.i("INFO日志"); &#125; *注：如果尝试用局部的方法，在application初始化时修改。当然，这是有效果的，但只能用一次，其他打印还是会用全局的，可自行测试。* 控制打印开关这个功能是最喜欢的了，当我们发布软件，或者太多的log影响性能，那么就可以关闭logger打印，在application初始化的地方： Logger.addLogAdapter(new AndroidLogAdapter() &#123; @Override public boolean isLoggable(int priority, String tag) &#123; return BuildConfig.DEBUG; &#125;&#125;); 通过适配器控制打印，只要覆盖isLoggable()方法，返回BuildConfig.DEBUG即可。这样子，log就不再打印出来了。 *注：返回值导入的包是：import com.orhanobut.logger.BuildConfig; 有时顺手导入：com.gotechcn.frameworks，那就没有效果。* 保存log到文件Logger.addLogAdapter(new DiskLogAdapter()); 通过打印，找到保存的路径： /storage/emulated/0 但手机里面就是没有这个文件夹，不知道什么原因，真机和模拟机多没有，知道可以留言噢，感谢！ 工作流程原理图logg框架的整体流程如图（作者原图）： 其他对Log信息的设置与过滤： Filter：编辑默认或者自定义的标签，过滤标签以外的信息； Disable：设置user soft wraps，即设置换行 Setting：设置log头部的信息，比如时间、线程PID、包名、TAG等开关设置 好了，对于Logger框架的介绍就到这里了。有时会更新，记得使用时看看GitHub升级了没有，同时在使用是否和以前兼容。对于一些其他的方法，可以直接看源码，具体是干什么用的。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Log</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lottie Android For Animation]]></title>
    <url>%2Fposts%2F1444979e.html</url>
    <content type="text"><![CDATA[Lottie是一个支持Android、iOS、React Native，并由 Adobe After Effects制作aep格式的动画，然后经由bodymovin插件转化渲染为json格式可被移动端本地识别解析的Airbnb开源库。Lottie实时呈现After Effects动画效果，让应用程序可以像使用静态图片一样轻松地使用动画。Lottie支持API 14及以上。 一、预览 二 、基本使用 在自己项目module的build.gradle文件中添加如下代码： dependencies &#123; compile 'com.airbnb.android:lottie:2.0.0-beta4'&#125; LottieAnimationView使用最简单的方法是: &lt;com.airbnb.lottie.LottieAnimationView android:id="@+id/animation_view" android:layout_width="wrap_content" android:layout_height="wrap_content" app:lottie_fileName="hello-world.json" app:lottie_loop="true" app:lottie_autoPlay="true" /&gt; 其中lottie_loop属性为是否重复无限期动画，当为true时，动画无限次数播放，为false时，播放一次。 或者把json资源放在app/src/main/assets下，也可以这样使用它: LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view);animationView.setAnimation(&quot;hello-world.json&quot;);animationView.loop(true);animationView.playAnimation(); 该方法将加载文件并在后台解析动画，在完成后异步开始呈现。 如果您希望重用一个动画，例如在列表的每个项目中，或者从一个网络请求JSONObject中加载它: LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view);...Cancellable compositionCancellable = LottieComposition.Factory.fromJson(getResources(), jsonObject, (composition) -&gt; &#123; animationView.setComposition(composition); animationView.playAnimation();&#125;);// 取消异步加载// compositionCancellable.cancel(); 你也可以控制动画添加监听： animationView.addAnimatorUpdateListener((animation) -&gt; &#123; // Do something.&#125;);animationView.playAnimation();...if (animationView.isAnimating()) &#123; // Do something.&#125;...animationView.setProgress(0.5f);...// 自定义动画速度和时长ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f) .setDuration(500);animator.addUpdateListener(animation -&gt; &#123; animationView.setProgress(animation.getAnimatedValue());&#125;);animator.start();...animationView.cancelAnimation(); 你可以给整个动画，一个特定的图层，或者一个图层的特定内容添加一个颜色过滤器。 // 任何符合颜色过滤界面的类final PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.LIGHTEN);// 在整个视图中添加一个颜色过滤器animationView.addColorFilter(colorFilter);//在特定的图层中添加一个颜色滤镜animationView.addColorFilterToLayer("hello_layer", colorFilter);// 添加一个彩色过滤器特效“hello_layer”上的内容animationView.addColorFilterToContent("hello_layer", "hello", colorFilter);// 清除所有的颜色滤镜animationView.clearColorFilters(); 注意:颜色过滤器只适用于图层，如图像层和实层，以及包含填充、描边或组内容的内容。 在引擎盖下,LottieAnimationView使用LottieDrawable呈现其动画。如果需要，您可以直接使用可绘制的表单: LottieDrawable drawable = new LottieDrawable();LottieComposition.Factory.fromAssetFileName(getContext(), "hello-world.json", (composition) -&gt; &#123; drawable.setComposition(composition);&#125;); 如果你的动画会经常重用,LottieAnimationView内置了一个可选的缓存策略。使用LottieAnimationView .setAnimation(String,CacheStrategy)。CacheStrategy可以Strong, Weak, 或者None。LottieAnimationView对加载和解析的动画持有强或弱的参考。弱或强表示缓存中组合的GC参考强度。 三、Image 支持如果您的动画是从assets中加载的，并且您的图像文件位于assets 的子目录中，那么您可以对图像进行动画。你可以用LottieAnimationView或者LottieDrawable对象调用setImageAssetsFolder(String)方法，明确assets相对文件夹内的路径,确保图像bodymovin出口与他们的名字不变,文件夹应该img_ 开头。如果直接使用LottieDrawable,当你完成时您必须调用recycleBitmaps。 如果你需要提供你自己的位图，如果你从网络或其他地方下载，你可以提供一个委托来做这个: animationView.setImageAssetDelegate(new ImageAssetDelegate() &#123; @Override public Bitmap fetchBitmap(LottieImageAsset asset) &#123; getBitmap(asset); &#125; &#125;); 四、性能和内存如果该组合没有遮罩或mattes，那么性能和内存开销应该相当不错。没有创建任何位图，大多数操作都是简单的画布绘制操作。如果这个组合有遮罩或mattes，就会使用屏幕外的缓冲区，并且会有一个性能打击。 如果在你的动画列表中使用,推荐使用CacheStrategy，在调用LottieAnimationView.setAnimation(String, CacheStrategy)的时候，所以动画不需要每次都反序列化。 五、Lottie官方Demo下载https://fir.im/lottiedemo 六、参考资料http://airbnb.design/lottie/ http://www.lottiefiles.com/ https://github.com/airbnb/lottie-android http://www.adobe.com/cn/products/aftereffects.html https://github.com/bodymovin/bodymovin https://github.com/airbnb/lottie-react-native https://github.com/airbnb/lottie-ios https://github.com/airbnb]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android App的设计架构：MVC,MVP,MVVM与架构经验谈]]></title>
    <url>%2Fposts%2Faf73114b.html</url>
    <content type="text"><![CDATA[和MVC框架模式一样，Model模型处理数据代码不变在Android的App开发中，很多人经常会头疼于App的架构如何设计： 我的App需要应用这些设计架构吗？ MVC,MVP等架构讲的是什么？区别是什么？ 本文就来带你分析一下这几个架构的特性，优缺点，以及App架构设计中应该注意的问题。 1.架构设计的目的通过设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，并且更容易进行后续的测试以及定位问题。但设计不能违背目的，对于不同量级的工程，具体架构的实现方式必然是不同的，切忌犯为了设计而设计，为了架构而架构的毛病。 举个简单的例子： 一个Android App如果只有3个Java文件，那只需要做点模块和层次的划分就可以，引入框架或者架构反而提高了工作量，降低了生产力； 但如果当前开发的App最终代码量在10W行以上，本地需要进行复杂操作，同时也需要考虑到与其余的Android开发者以及后台开发人员之间的同步配合，那就需要在架构上进行一些思考！ 2.MVC设计架构 MVC简介MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。 Android中的MVCAndroid中界面部分也采用了当前比较流行的MVC框架，在Android中： 视图层(View) 一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。 控制层(Controller) Android的控制层的重任通常落在了众多的Activity的肩上。这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Actiivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 模型层(Model) 我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的（感谢@Xander的讲解）。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。就是应用程序中二进制的数据。 MVC代码实例我们来看看MVC在Android开发中是怎么应用的吧！ 先上界面图 Controller控制器&amp;View public class MainActivity extends ActionBarActivity implements OnWeatherListener, View.OnClickListener &#123; private WeatherModel weatherModel; private EditText cityNOInput; private TextView city; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); weatherModel = new WeatherModelImpl(); initView(); &#125; //初始化View private void initView() &#123; cityNOInput = findView(R.id.et_city_no); city = findView(R.id.tv_city); ... findView(R.id.btn_go).setOnClickListener(this); &#125; //显示结果 public void displayResult(Weather weather) &#123; WeatherInfo weatherInfo = weather.getWeatherinfo(); city.setText(weatherInfo.getCity()); ... &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_go: weatherModel.getWeather(cityNOInput.getText().toString().trim(), this); break; &#125; &#125; @Override public void onSuccess(Weather weather) &#123; displayResult(weather); &#125; @Override public void onError() &#123; Toast.makeText(this, 获取天气信息失败, Toast.LENGTH_SHORT).show(); &#125; private T findView(int id) &#123; return (T) findViewById(id); &#125;&#125; 从上面代码可以看到，Activity持有了WeatherModel模型的对象，当用户有点击Button交互的时候，Activity作为Controller控制层读取View视图层EditTextView的数据，然后向Model模型发起数据请求，也就是调用WeatherModel对象的方法 getWeather（）方法。当Model模型处理数据结束后，通过接口OnWeatherListener通知View视图层数据处理完毕，View视图层该更新界面UI了。然后View视图层调用displayResult（）方法更新UI。至此，整个MVC框架流程就在Activity中体现出来了。 Model模型 来看看WeatherModelImpl代码实现 public interface WeatherModel &#123; void getWeather(String cityNumber, OnWeatherListener listener);&#125;................public class WeatherModelImpl implements WeatherModel &#123; /*这部分代码范例有问题，网络访问不应该在Model中，应该把网络访问换成从数据库读取*/ @Override public void getWeather(String cityNumber, final OnWeatherListener listener) &#123; /*数据层操作*/ VolleyRequest.newInstance().newGsonRequest(http://www.weather.com.cn/data/sk/ + cityNumber + .html, Weather.class, new Response.Listener&lt;weather&gt;() &#123; @Override public void onResponse(Weather weather) &#123; if (weather != null) &#123; listener.onSuccess(weather); &#125; else &#123; listener.onError(); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; listener.onError(); &#125; &#125;); &#125;&#125; 以上代码看出，这里设计了一个WeatherModel模型接口，然后实现了接口WeatherModelImpl类。controller控制器activity调用WeatherModelImpl类中的方法发起网络请求，然后通过实现OnWeatherListener接口来获得网络请求的结果通知View视图层更新UI 。至此，Activity就将View视图显示和Model模型数据处理隔离开了。activity担当contronller完成了model和view之间的协调作用。 至于这里为什么不直接设计成类里面的一个getWeather（）方法直接请求网络数据？你考虑下这种情况：现在代码中的网络请求是使用Volley框架来实现的，如果哪天老板非要你使用Afinal框架实现网络请求，你怎么解决问题？难道是修改 getWeather（）方法的实现？ no no no，这样修改不仅破坏了以前的代码，而且还不利于维护， 考虑到以后代码的扩展和维护性，我们选择设计接口的方式来解决着一个问题，我们实现另外一个WeatherModelWithAfinalImpl类，继承自WeatherModel，重写里面的方法，这样不仅保留了以前的WeatherModelImpl类请求网络方式，还增加了WeatherModelWithAfinalImpl类的请求方式。Activity调用代码无需要任何修改。 3.MVP设计架构在App开发过程中，经常出现的问题就是某一部分的代码量过大，虽然做了模块划分和接口隔离，但也很难完全避免。从实践中看到，这更多的出现在UI部分，也就是Activity里。想象一下，一个2000+行以上基本不带注释的Activity，我的第一反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负与用户之间的操作交互，界面的展示，不是单纯的Controller或View。而且现在大部分的Activity还对整个App起到类似IOS中的【ViewController】的作用，这又带入了大量的逻辑代码，造成Activity的臃肿。为了解决这个问题，让我们引入MVP框架。 MVC的缺点在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户 界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。 什么是MVP?MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。 MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）： View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity) Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合) Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。 *View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试 Tips：*View interface的必要性 回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用 户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。 MVC → MVP当我们将Activity复杂的逻辑处理移至另外的一个类（Presenter）中时，Activity其实就是MVP模式中的View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由 Presenter处理）。 MVP的Presenter是框架的控制者，承担了大量的逻辑操作，而MVC的Controller更多时候承担一种转发的作用。因此在App中引入MVP的原因，是为了将此前在Activty中包含的大量逻辑操作放到控制层中，避免Activity的臃肿。 两种模式的主要区别： （最主要区别）View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。 因此我们可以发现MVP的优点如下： 1、模型与视图完全分离，我们可以修改视图而不影响模型； 2、可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部； 3、我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁； 4、如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。 具体到Android App中，一般可以将App根据程序的结构进行纵向划分，根据MVP可以将App分别为模型层(M)，UI层(V)和逻辑层(P)。 UI层一般包括Activity，Fragment，Adapter等直接和UI相关的类，UI层的Activity在启动之后实例化相应的Presenter，App的控制权后移，由UI转移到Presenter，两者之间的通信通过BroadCast、Handler或者接口完成，只传递事件和结果。 举个简单的例子，UI层通知逻辑层（Presenter）用户点击了一个Button，逻辑层（Presenter）自己决定应该用什么行为进行响应，该找哪个模型（Model）去做这件事，最后逻辑层（Presenter）将完成的结果更新到UI层。 MVP的变种：Passive ViewMVP的变种有很多，其中使用最广泛的是Passive View模式，即被动视图。在这种模式下，View和Model之间不能直接交互，View通过Presenter与Model打交道。Presenter接受View的UI请求，完成简单的UI处理逻辑，并调用Model进行业务处理，并调用View将相应的结果反映出来。View直接依赖Presenter，但是Presenter间接依赖View，它直接依赖的是View实现的接口。 相对于View的被动，那Presenter就是主动的一方。对于Presenter的主动，有如下的理解： Presenter是整个MVP体系的控制中心，而不是单纯的处理View请求的人； View仅仅是用户交互请求的汇报者，对于响应用户交互相关的逻辑和流程，View不参与决策，真正的决策者是Presenter； View向Presenter发送用户交互请求应该采用这样的口吻：“我现在将用户交互请求发送给你，你看着办，需要我的时候我会协助你”，不应该是这样：“我现在处理用户交互请求了，我知道该怎么办，但是我需要你的支持，因为实现业务逻辑的Model只信任你”； 对于绑定到View上的数据，不应该是View从Presenter上“拉”回来的，应该是Presenter主动“推”给View的； View尽可能不维护数据状态，因为其本身仅仅实现单纯的、独立的UI操作；Presenter才是整个体系的协调者，它根据处理用于交互的逻辑给View和Model安排工作。 MVP架构存在的问题与解决办法 加入模板方法（Template Method） 转移逻辑操作之后可能部分较为复杂的Activity内代码量还是不少，于是需要在分层的基础上再加入模板方法（Template Method）。 具体做法是在Activity内部分层。其中最顶层为BaseActivity，不做具体显示，而是提供一些基础样式，Dialog，ActionBar在内的内容，展现给用户的Activity继承BaseActivity，重写BaseActivity预留的方法。如有必要再进行二次继承，App中Activity之间的继承次数最多不超过3次。 Model内部分层 模型层（Model）中的整体代码量是最大的，一般由大量的Package组成，针对这部分需要做的就是在程序设计的过程中，做好模块的划分，进行接口隔离，在内部进行分层。 强化Presenter 强化Presenter的作用，将所有逻辑操作都放在Presenter内也容易造成Presenter内的代码量过大，对于这点，有一个方法是在UI层和Presenter之间设置中介者Mediator，将例如数据校验、组装在内的轻量级逻辑操作放在Mediator中；在Presenter和Model之间使用代理Proxy；通过上述两者分担一部分Presenter的逻辑操作，但整体框架的控制权还是在Presenter手中。Mediator和Proxy不是必须的，只在Presenter负担过大时才建议使用。 最终的架构如下图所示： MVP代码实例我们来看看MVP在Android开发中是怎么应用的吧！！ 我们用另一个例子来解释。 先来看包结构图 建立Bean public class UserBean &#123; private String mFirstName; private String mLastName; public UserBean(String firstName, String lastName) &#123; this. mFirstName = firstName; this. mLastName = lastName; &#125; public String getFirstName() &#123; return mFirstName; &#125; public String getLastName() &#123; return mLastName; &#125;&#125; 建立Model （处理业务逻辑，这里指数据读写），先写接口，后写实现 public interface IUserModel &#123; void setID(int id); void setFirstName(String firstName); void setLastName(String lastName); int getID(); UserBean load(int id);// 通过id读取user信息,返回一个UserBean&#125; 实现不在这里写了 Presenter控制器 建立presenter（主导器，通过iView和iModel接口操作model和view），activity可以把所有逻辑给presenter处理，这样java逻辑就从手机的activity中分离出来。 public class UserPresenter &#123; private IUserView mUserView; private IUserModel mUserModel; public UserPresenter(IUserView view) &#123; mUserView = view; mUserModel = new UserModel(); &#125; public void saveUser( int id, String firstName, String lastName) &#123; mUserModel.setID(id); mUserModel.setFirstName(firstName); mUserModel.setLastName(lastName); &#125; public void loadUser( int id) &#123; UserBean user = mUserModel.load(id); mUserView.setFirstName(user.getFirstName()); // 通过调用IUserView的方法来更新显示 mUserView.setLastName(user.getLastName()); &#125;&#125; View视图 建立view（更新ui中的view状态），这里列出需要操作当前view的方法，也是接口 public interface IUserView &#123; int getID(); String getFristName(); String getLastName(); void setFirstName(String firstName); void setLastName(String lastName);&#125; activity中实现iview接口，在其中操作view，实例化一个presenter变量。 public class MainActivity extends Activity implements OnClickListener,IUserView &#123; UserPresenter presenter; EditText id,first,last; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout. activity_main); findViewById(R.id. save).setOnClickListener( this); findViewById(R.id. load).setOnClickListener( this); id = (EditText) findViewById(R.id. id); first = (EditText) findViewById(R.id. first); last = (EditText) findViewById(R.id. last); presenter = new UserPresenter( this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id. save: presenter.saveUser(getID(), getFristName(), getLastName()); break; case R.id. load: presenter.loadUser(getID()); break; default: break; &#125; &#125; @Override public int getID() &#123; return new Integer( id.getText().toString()); &#125; @Override public String getFristName() &#123; return first.getText().toString(); &#125; @Override public String getLastName() &#123; return last.getText().toString(); &#125; @Override public void setFirstName(String firstName) &#123; first.setText(firstName); &#125; @Override public void setLastName(String lastName) &#123; last.setText(lastName); &#125;&#125; 因此，Activity及从MVC中的Controller中解放出来了，这会Activity主要做显示View的作用和用户交互。每个Activity可以根据自己显示View的不同实现View视图接口IUserView。 通过对比同一实例的MVC与MVP的代码，可以证实MVP模式的一些优点： 在MVP中，Activity的代码不臃肿； 在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会； 在MVP中，IUserView这个接口可以实现方便地对Presenter的测试； 在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。 4.MVC、MVP与MVVM的关系首先介绍下MVVM。 MVVMMVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。 在比较之前，先从图上看看三者的异同。 刚开始理解这些概念的时候认为这几种模式虽然都是要将view和model解耦，但是非此即彼，没有关系，一个应用只会用一种模式。后来慢慢发现世界绝对不是只有黑白两面，中间最大的一块其实是灰色地带，同样，这几种模式的边界并非那么明显，可能你在自己的应用中都会用到。实际上也根本没必要去纠结自己到底用的是MVC、MVP还是MVVP，不管黑猫白猫，捉住老鼠就是好猫。 MVC-&gt;MVP-&gt;MVVM演进过程MVC -&gt; MVP -&gt; MVVM 这几个软件设计模式是一步步演化发展的，MVVM 是从 MVP 的进一步发展与规范，MVP 隔离了MVC中的 M 与 V 的直接联系后，靠 Presenter 来中转，所以使用 MVP 时 P 是直接调用 View 的接口来实现对视图的操作的，这个 View 接口的东西一般来说是 showData、showLoading等等。M 与 V已经隔离了，方便测试了，但代码还不够优雅简洁，所以 MVVM 就弥补了这些缺陷。在 MVVM 中就出现的 Data Binding 这个概念，意思就是 View 接口的 showData 这些实现方法可以不写了，通过 Binding 来实现。 同如果把这三者放在一起比较，先说一下三者的共同点，也就是Model和View： Model：数据对象，同时，提供本应用外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。 View：UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。 异三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知 Controller Controller接收View的操作事件，根据事件不同，或者调用Model的接口进行数据操作，或者进行View的跳转，从而也意味着一个Controller可以对应多个View。Controller对View的实现不太关心，只会被动地接收，Model的数据变更不通过Controller直接通知View，通常View采用观察者模式监听Model的变化。 Presenter Presenter与Controller一样，接收View的命令，对Model进行操作；与Controller不同的是Presenter会反作用于View，Model的变更通知首先被Presenter获得，然后Presenter再去更新View。一个Presenter只对应于一个View。根据Presenter和View对逻辑代码分担的程度不同，这种模式又有两种情况：Passive View和Supervisor Controller。 ViewModel 注意这里的“Model”指的是View的Model，跟MVVM中的一个Model不是一回事。所谓View的Model就是包含View的一些数据属性和操作的这么一个东东，这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。 一点心得MVP和MVVM完全隔离了Model和View，但是在有些情况下，数据从Model到ViewModel或者Presenter的拷贝开销很大，可能也会结合MVC的方式，Model直接通知View进行变更。在实际的应用中很有可能你已经在不知不觉中将几种模式融合在一起，但是为了代码的可扩展、可测试性，必须做到模块的解耦，不相关的代码不要放在一起。网上有一个故事讲，一个人在一家公司做一个新产品时，一名外包公司的新员工直接在View中做了数据库持久化操作，而且一个hibernate代码展开后发现竟然有几百行的SQL语句，搞得他们惊讶不已，一时成为笑谈。 个人理解，在广义地谈论MVC架构时，并非指本文中严格定义的MVC，而是指的MV*，也就是视图和模型的分离，只要一个框架提供了视图和模型分离的功能，我们就可以认为它是一个MVC框架。在开发深入之后，可以再体会用到的框架到底是MVC、MVP还是MVVM。 5. 基于AOP的框架设计AOP(Aspect-Oriented Programming, 面向切面编程)，诞生于上个世纪90年代，是对OOP(Object-Oriented Programming, 面向对象编程)的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（Cross-Cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。 5.1 AOP在Android中的使用AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。在Android App中，哪些是我们需要的横切关注点？个人认为主要包括以下几个方面：Http, SharedPreferences, Json, Xml, File, Device, System, Log, 格式转换等。Android App的需求差别很大，不同的需求横切关注点必然是不一样的。一般的App工程中应该有一个Util Package来存放相关的切面操作，在项目多了之后可以将其中使用较多的Util封装为一个Jar包供工程调用。 在使用MVP和AOP对App进行纵向和横向的切割之后，能够使得App整体的结构更清晰合理，避免局部的代码臃肿，方便开发、测试以及后续的维护。 6. 干货：AndroidApp架构的设计经验首先是作者最最喜欢的一句话，也是对创业公司特别适用的一句话，也是对不要过度设计的一种诠释： 先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了（重要的事情说三遍) 6.1 整体架构代码和文档规范，根据需求进行模块划分，确定交互方式，形成接口文档，这些较为通用的内容不再细说。做Android App时，一般将App进行纵向和横向的划分。纵向的App由UI层，逻辑层和模型层构成，整体结构基于MVP思想(图片来自网络)。 UI层内部多用模板方法，以Activity为例一般有BaseActivity，提供包括一些基础样式，Dialog，ActionBar在内的内容，展现的Activity都会继承BaseActivity并实现预留的接口，Activity之间的继承不超过3次；为避免Activity内代码过多，将App的整体控制权后移，也借鉴了IOC做法，大量的逻辑操作放在逻辑层中，逻辑层和UI层通过接口或者Broadcast等实现通信，只传递结果。一般Activity里的代码量都很大，通过这两种方式一般我写的单个Activity内代码量不超过400行。 逻辑层实现的是绝大部分的逻辑操作，由UI层启动，在内部通过接口调用模型层的方法，在逻辑层内大量使用了代理。打个比方，UI层告诉逻辑层我需要做的事，逻辑层去找相应的人(模型层)去做，最后只告诉UI这件事做的结果。 模型层没什么好说的，这部分一般由大量的Package组成，代码量是三层中最大的，需要在内部进行分层。 横向的分割依据AOP面向切面的思想，主要是提取出共用方法作为一个单独的Util，这些Util会在App整体中穿插使用。很多人的App都会引入自己封装的Jar包，封装了包括文件、JSON、SharedPreference等在内的常用操作，自己写的用起来顺手，也大幅度降低了重复作业。 这样纵，横两次对于App代码的分割已经能使得程序不会过多堆积在一个Java文件里，但靠一次开发过程就写出高质量的代码是很困难的，趁着项目的间歇期，对代码进行重构很有必要。 6.2 类库的使用现在有很多帮助快速开发的类库，活用这些类库也是避免代码臃肿和混乱的好方法，下面给题主推荐几个常用类库。 减少Activity代码量的依赖注入框架ButterKnife: https://github.com/JakeWharton/butterknife 简化对于SQlite操作的对象关系映射框架OrmLite: https://github.com/j256/ormlite-android 图片缓存类库Fresco(by facebook): https://github.com/facebook/fresco 能用第三方库就用第三方库。别管是否稳定，是否被持续维护，因为，任何第三方库的作者，都能碾压刚入门的菜鸟，你绝对写不出比别人更好的代码了。 最后附上知乎上面点赞次数很高的一段话： 如果“从零开始”，用什么设计架构的问题属于想得太多做得太少的问题。 从零开始意味着一个项目的主要技术难点是基本功能实现。当每一个功能都需要考虑如何做到的时候，我觉得一般人都没办法考虑如何做好。 因为，所有的优化都是站在最上层进行统筹规划。在这之前，你必须对下层的每一个模块都非常熟悉，进而提炼可复用的代码、规划逻辑流程。 所以，如果真的是从零开始，别想太多了 参考文献： 1、http://blog.csdn.net/luyi325xyz/article/details/43085409 2、http://blog.csdn.net/napolunyishi/article/details/22722345 3、https://www.zhihu.com/question/27645587/answer/37579829 4、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0202/2397.html 5、http://www.tuicool.com/articles/VJZrYb 6、https://www.zhihu.com/question/27645587 7、http://blog.csdn.net/luyi325xyz/article/details/43482123 8、https://www.zhihu.com/question/30976423 9、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0313/2599.html 10、http://www.2cto.com/kf/201506/405766.html 11、https://www.zhihu.com/question/19766132 12、http://www.cnblogs.com/artech/archive/2010/03/25/1696205.html 13、https://segmentfault.com/a/1190000003927200 14、http://blog.csdn.net/knxw0001/article/details/39637273 版权声明 周鸿博]]></content>
      <categories>
        <category>Android</category>
        <category>设计架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制详解攻略，您值得拥有]]></title>
    <url>%2Fposts%2F92ff150b.html</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/carson_ho/article/details/54136311 前言 Android事件分发机制是Android开发者必须了解的基础 网上有大量关于Android事件分发机制的文章，但存在一些问题：内容不全、思路不清晰、无源码分析、简单问题复杂化等等 今天，我将全面总结Android的事件分发机制，我能保证这是市面上的最全面、最清晰、最易懂的 本文秉着“结论先行、详细分析在后”的原则，即先让大家感性认识，再通过理性分析从而理解问题； 所以，请各位读者先记住结论，再往下继续看分析； 文章较长，阅读需要较长时间，建议收藏等充足时间再进行阅读 目录 1. 基础认知1.1 事件分发的对象是谁？答：点击事件（Touch事件） 定义当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件） Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象 事件类型（4种） 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下View（所有事件的开始） MotionEvent.ACTION_UP 抬起View（与DOWN对应） MotionEvent.ACTION_MOVE 滑动View MotionEvent.ACTION_CANCEL 结束事件（非人为原因） 特别说明：事件列 从手指接触屏幕 至 手指离开屏幕，这个过程产生的一系列事件 注：一般情况下，事件列都是以DOWN事件开始、UP事件结束，中间有无数的MOVE事件，如下图： 即当一个点击事件（MotionEvent ）产生后，系统需把这个事件传递给一个具体的 View 去处理。 1.2 事件分发的本质答：将点击事件（MotionEvent）传递到某个具体的View &amp; 处理的整个过程 即 事件传递的过程 = 分发过程。 1.3 事件在哪些对象之间进行传递？答：Activity、ViewGroup、View Android的UI界面由Activity、ViewGroup、View 及其派生类组成 1.4 事件分发的顺序即 事件传递的顺序：Activity -&gt; ViewGroup -&gt; View 即：1个点击事件发生后，事件先传到Activity、再传到ViewGroup、最终再传到 View 1.5 事件分发过程由哪些方法协作完成？答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 下文会对这3个方法进行详细介绍 1.6 总结 至此，相信大家已经对 Android的事件分发有了感性的认知 下面，我将详细介绍Android事件分发机制 2. 事件分发机制 源码分析 请谨记：Android事件分发流程 = Activity -&gt; ViewGroup -&gt; View 即：1个点击事件发生后，事件先传到Activity、再传到ViewGroup、最终再传到 View 从上可知，要想充分理解Android分发机制，本质上是要理解： Activity对点击事件的分发机制 ViewGroup对点击事件的分发机制 View对点击事件的分发机制 下面，我将通过源码，全面解析 事件分发机制 即按顺序讲解：Activity事件分发机制、ViewGroup事件分发机制、View事件分发机制 2.1 Activity的事件分发机制当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发 2.1.1 源码分析/** * 源码分析：Activity.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); // -&gt;&gt;分析1 &#125; // -&gt;&gt;分析2 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent &#125; // -&gt;&gt;分析4 return onTouchEvent(ev); &#125;/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */ public void onUserInteraction() &#123; &#125; // 回到最初的调用原处/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 // -&gt;&gt; 分析3 &#125;/** * 分析3：mDecor.superDispatchTouchEvent(event) * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); // 调用父类的方法 = ViewGroup的dispatchTouchEvent() // 即 将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制 &#125; // 回到最初的调用原处/** * 分析4：Activity.onTouchEvent（） * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean onTouchEvent(MotionEvent event) &#123; // 当一个点击事件未被Activity下任何一个View接收 / 处理时 // 应用场景：处理发生在Window边界外的触摸事件 // -&gt;&gt; 分析5 if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false; // 即 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕 &#125;/** * 分析5：mWindow.shouldCloseOnTouch(this, event) */ public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; // 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等 if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) &#123; return true; &#125; return false; // 返回true：说明事件在边界外，即 消费事件 // 返回false：未消费（默认）&#125;// 回到分析4调用原处 2.1.2 总结 当一个点击事件发生时，从Activity的事件分发开始（Activity.dispatchTouchEvent()） 方法总结 那么，ViewGroup的dispatchTouchEvent()什么时候返回true / false？请继续往下看ViewGroup事件的分发机制 2.2 ViewGroup事件的分发机制从上面Activity事件分发机制可知，ViewGroup事件分发机制从dispatchTouchEvent()开始 2.2.1 源码分析 Android 5.0后，ViewGroup.dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同； 本文为了让读者容易理解，故采用Android 5.0前的版本 /** * 源码分析：ViewGroup.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... // 仅贴出关键代码 // 重点分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件 if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; // 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改 // 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反 // a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部 // b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断 // c. 关于onInterceptTouchEvent() -&gt;&gt;分析1 ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; // 重点分析2 // 通过for循环，遍历了当前ViewGroup下的所有子View for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); // 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View // 若是，则进入条件判断内部 if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; // 条件判断的内部调用了该View的dispatchTouchEvent() // 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制） if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; // 调用子View的dispatchTouchEvent后是有返回值的 // 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立 // 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出 // 即把ViewGroup的点击事件拦截掉 &#125; &#125; &#125; &#125; &#125; &#125; boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; // 重点分析3 // 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true） if (target == null) &#123; ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; return super.dispatchTouchEvent(ev); // 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent() // 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（）） // 此处需与上面区别：子View的dispatchTouchEvent（） &#125; ... &#125;/** * 分析1：ViewGroup.onInterceptTouchEvent() * 作用：是否拦截事件 * 说明： * a. 返回true = 拦截，即事件停止往下传递（需手动设置，即复写onInterceptTouchEvent（），从而让其返回true） * b. 返回false = 不拦截（默认） */ public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; // 回到调用原处 2.2.2 总结 结论：Android事件分发总是先传递到ViewGroup、再传递到View 过程：当点击了某个控件时 核心方法总结 2.2.3 Demo讲解 布局如下 测试代码 布局文件：activity_main.xml &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/my_layout" android:layout_width="match_parent" android:layout_height="match_parent" xmlns:app="http://schemas.android.com/apk/res-auto" android:focusableInTouchMode="true" android:orientation="vertical"&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮1" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮2" /&gt;&lt;/LinearLayout&gt; 核心代码：MainActivity.java /** * ViewGroup布局（myLayout）中有2个子View = 2个按钮 */ public class MainActivity extends AppCompatActivity &#123; Button button1,button2; ViewGroup myLayout; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1 = (Button)findViewById(R.id.button1); button2 = (Button)findViewById(R.id.button2); myLayout = (LinearLayout)findViewById(R.id.my_layout); // 1.为ViewGroup布局设置监听事件 myLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了ViewGroup"); &#125; &#125;); // 2. 为按钮1设置监听事件 button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了button1"); &#125; &#125;); // 3. 为按钮2设置监听事件 button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了button2"); &#125; &#125;); &#125;&#125; 结果测试 从上面的测试结果发现： 点击Button时，执行Button.onClick()，但ViewGroupLayout注册的onTouch（）不会执行 只有点击空白区域时，才会执行ViewGroupLayout的onTouch（） 结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。 2.3 View事件的分发机制从上面ViewGroup事件分发机制知道，View事件分发机制从dispatchTouchEvent()开始 2.3.1 源码分析/** * 源码分析：View.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; // 说明：只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent() // 1. mOnTouchListener != null // 2. (mViewFlags &amp; ENABLED_MASK) == ENABLED // 3. mOnTouchListener.onTouch(this, event) // 下面对这3个条件逐个分析/** * 条件1：mOnTouchListener != null * 说明：mOnTouchListener变量在View.setOnTouchListener（）方法里赋值 */ public void setOnTouchListener(OnTouchListener l) &#123; mOnTouchListener = l; // 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）&#125; /** * 条件2：(mViewFlags &amp; ENABLED_MASK) == ENABLED * 说明： * a. 该条件是判断当前点击的控件是否enable * b. 由于很多View默认enable，故该条件恒定为true *//** * 条件3：mOnTouchListener.onTouch(this, event) * 说明：即 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例） */ button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; return false; &#125; &#125;); // 若在onTouch（）返回true，就会让上述三个条件全部成立，从而使得View.dispatchTouchEvent（）直接返回true，事件分发结束 // 若在onTouch（）返回false，就会使得上述三个条件不全部成立，从而使得View.dispatchTouchEvent（）中跳出If，执行onTouchEvent(event) 接下来，我们继续看：onTouchEvent(event)的源码分析 详情请看注释 Android 5.0后 View.onTouchEvent()源码发生了变化（更加复杂），但原理相同； 本文为了让读者更好理解，所以采用Android 5.0前的版本 /** * 源码分析：View.onTouchEvent（） */ public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 若该控件可点击，则进入switch判断中 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; // a. 若当前的事件 = 抬起View（主要分析） case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; ...// 经过种种判断，此处省略 // 执行performClick() -&gt;&gt;分析1 performClick(); break; // b. 若当前的事件 = 按下View case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; // c. 若当前的事件 = 结束事件（非人为原因） case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; // d. 若当前的事件 = 滑动View case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; // 若该控件可点击，就一定返回true return true; &#125; // 若该控件不可点击，就一定返回false return false; &#125;/** * 分析1：performClick（） */ public boolean performClick() &#123; if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; // 只要我们通过setOnClickListener（）为控件View注册1个点击事件 // 那么就会给mOnClickListener变量赋值（即不为空） // 则会往下回调onClick（） &amp; performClick（）返回true &#125; return false; &#125; 2.3.2 总结 每当控件被点击时： 注：onTouch（）的执行 先于 onClick（） 核心方法总结 2.3.3 Demo讲解下面我将用Demo验证上述的结论 /** * 结论验证1：在回调onTouch()里返回false */ // 1. 通过OnTouchListener()复写onTouch()，从而手动设置返回false button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return false; &#125; &#125;); // 2. 通过 OnClickListener（）为控件设置点击事件，为mOnClickListener变量赋值（即不为空），从而往下回调onClick（） button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;);/** * 结论验证2：在回调onTouch()里返回true */ // 1. 通过OnTouchListener()复写onTouch()，从而手动设置返回true button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return true; &#125; &#125;); // 2. 通过 OnClickListener（）为控件设置点击事件，为mOnClickListener变量赋值（即不为空） // 但由于dispatchTouchEvent（）返回true，即事件不再向下传递，故不调用onClick()） button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;); 测试结果 2.4 总结 若您已经看到此处，那么恭喜你，你已经能非常熟悉掌握Android的事件分发机制了 即：Activity、ViewGroup、View 的事件分发机制 3. 工作流程 总结 在本节中，我将结合源码，梳理出1个事件分发的工作流程总结，具体如下： 左侧虚线：具备相关性 &amp; 逐层返回 以角色为核心的图解说明 以方法为核心的图解说明 4. 核心方法总结 已知事件分发过程的核心方法为：dispatchTouchEvent()、onInterceptTouchEvent() 和 onTouchEvent() 下面，我将结合总结的工作流程，再次详细讲解该3个方法 4.1 dispatchTouchEvent() 简介 返回情况说明 情况1：默认 情况2：返回true 情况3：返回false 4.2 onInterceptTouchEvent() 简介 注：Activity、View都无该方法 返回情况说明 情况1：true 情况2：false（默认） 4.3 onTouchEvent() 简介 返回情况说明 情况1：返回true 情况2：返回false（default） 4.4 三者关系下面，我用一段伪代码来阐述上述3个方法的关系 &amp; 事件传递规则 /** * 点击事件产生后 */ // 步骤1：调用dispatchTouchEvent（） public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; //代表 是否会消费事件 // 步骤2：判断是否拦截事件 if (onInterceptTouchEvent(ev)) &#123; // a. 若拦截，则将该事件交给当前View进行处理 // 即调用onTouchEvent (）方法去处理点击事件 consume = onTouchEvent (ev) ; &#125; else &#123; // b. 若不拦截，则将该事件传递到下层 // 即 下层元素的dispatchTouchEvent（）就会被调用，重复上述过程 // 直到点击事件被最终处理为止 consume = child.dispatchTouchEvent (ev) ; &#125; // 步骤3：最终返回通知 该事件是否被消费（接收 &amp; 处理） return consume; &#125; 5. 常见的事件分发场景下面，我将通过实例说明常见的事件传递情况 &amp; 流程 5.1 背景描述 讨论的布局如下： 情景 用户先触摸到屏幕上View C上的某个点（图中黄区） Action_DOWN事件在此处产生 用户移动手指 最后离开屏幕 5.2 一般的事件传递情况一般的事件传递场景有： 默认情况 处理事件 拦截DOWN事件 拦截后续事件（MOVE、UP） 场景1：默认 即不对控件里的方法（dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent()）进行重写 或 更改返回值 那么调用的是这3个方法的默认实现：调用下层的方法 &amp; 逐层返回 事件传递情况：（呈U型） 1.从上往下调用dispatchTouchEvent() Activity A -&gt;&gt; ViewGroup B -&gt;&gt; View C2.从下往上调用onTouchEvent() View C -&gt;&gt; ViewGroup B -&gt;&gt; Activity A 注：虽然ViewGroup B的onInterceptTouchEvent（）对DOWN事件返回了false，但后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent() 这一点与onTouchEvent（）的行为是不一样的：不再传递 &amp; 接收该事件列的其他事件 场景2：处理事件设View C希望处理该点击事件，即：设置View C为可点击的（Clickable） 或 复写其onTouchEvent（）返回true 最常见的：设置Button按钮来响应点击事件 事件传递情况：（如下图） DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理该事件 因为View C正在处理该事件，那么DOWN事件将不再往上传递给ViewGroup B 和 Activity A的onTouchEvent()； 该事件列的其他事件（Move、Up）也将传递给View C的onTouchEvent() 会逐层往dispatchTouchEvent() 返回，最终事件分发结束 场景3：拦截DOWN事件假设ViewGroup B希望处理该点击事件，即ViewGroup B复写了onInterceptTouchEvent()返回true、onTouchEvent()返回true事件传递情况：（如下图） DOWN事件被传递给ViewGroup B的onInterceptTouchEvent()，该方法返回true，表示拦截该事件，即自己处理该事件（事件不再往下传递） 调用自身的onTouchEvent()处理事件（DOWN事件将不再往上传递给Activity A的onTouchEvent()） 该事件列的其他事件（Move、Up）将直接传递给ViewGroup B的onTouchEvent() 注： 该事件列的其他事件（Move、Up）将不会再传递给ViewGroup B的onInterceptTouchEvent（）；因：该方法一旦返回一次true，就再也不会被调用 逐层往dispatchTouchEvent() 返回，最终事件分发结束 场景4：拦截DOWN的后续事件结论 若 ViewGroup 拦截了一个半路的事件（如MOVE），该事件将会被系统变成一个CANCEL事件 &amp; 传递给之前处理该事件的子View； 该事件不会再传递给ViewGroup 的onTouchEvent() 只有再到来的事件才会传递到ViewGroup的onTouchEvent() 场景描述ViewGroup B 无拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件 即 DOWN事件传递到View C的onTouchEvent（），返回了true 实例讲解 在后续到来的MOVE事件，ViewGroup B 的onInterceptTouchEvent（）返回true拦截该MOVE事件，但该事件并没有传递给ViewGroup B ；这个MOVE事件将会被系统变成一个CANCEL事件传递给View C的onTouchEvent（） 后续又来了一个MOVE事件，该MOVE事件才会直接传递给ViewGroup B 的onTouchEvent() 后续事件将直接传递给ViewGroup B 的onTouchEvent()处理，而不会再传递给ViewGroup B 的onInterceptTouchEvent（），因该方法一旦返回一次true，就再也不会被调用了。 View C再也不会收到该事件列产生的后续事件 至此，关于Android常见的事件传递情况 &amp; 流程已经讲解完毕。 6. 额外知识6.1 Touch事件的后续事件（MOVE、UP）层级传递 6.1 Touch事件的后续事件（MOVE、UP）层级传递 若给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等） 当dispatchTouchEvent（）事件分发时，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP） 即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE、ACTION_UP事件都不会执行从上面对事件分发机制分析知： dispatchTouchEvent()、 onTouchEvent() 消费事件、终结事件传递（返回true） 而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用 请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP）这里给出ACTION_MOVE和ACTION_UP事件的传递结论： 结论1若对象（Activity、ViewGroup、View）的dispatchTouchEvent()分发事件后消费了事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE 、 ACTION_UP事件传递方向 结论2若对象（Activity、ViewGroup、View）的onTouchEvent()处理了事件（返回true），那么ACTION_MOVE、ACTION_UP的事件从上往下传到该View后就不再往下传递，而是直接传给自己的onTouchEvent()&amp; 结束本次事件传递过程。 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE、ACTION_UP事件传递方向 6.2 onTouch()和onTouchEvent()的区别 该2个方法都是在View.dispatchTouchEvent（）中调用 但onTouch（）优先于onTouchEvent执行；若手动复写在onTouch（）中返回true（即 将事件消费掉），将不会再执行onTouchEvent（） 注：若1个控件不可点击（即非enable），那么给它注册onTouch事件将永远得不到执行，具体原因看如下代码 // &amp;&amp;为短路与，即如果前面条件为false，将不再往下执行// 故：onTouch（）能够得到执行需2个前提条件： // 1. mOnTouchListener的值不能为空 // 2. 当前点击的控件必须是enable的mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)// 对于该类控件，若需监听它的touch事件，就必须通过在该控件中重写onTouchEvent（）来实现12345678 7. 总结 通过阅读本文，相信您已经可以全面了解Android事件分发机制 与Android事件分发最相关的知识：自定义View系列文章自定义View基础 - 最易懂的自定义View原理系列（1）自定义View Measure过程 - 最易懂的自定义View原理系列（2）自定义View Layout过程 - 最易懂的自定义View原理系列（3）自定义View Draw过程- 最易懂的自定义View原理系列（4） 接下来我将继续介绍与Android事件分发最相关的知识：自定义View，有兴趣可以继续关注Carson_Ho的安卓开发笔记]]></content>
      <categories>
        <category>Android</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwitchHosts!]]></title>
    <url>%2Fposts%2F1bc98c52.html</url>
    <content type="text"><![CDATA[SwitchHosts! 英文 主页：https://oldj.github.io/SwitchHosts/ 这是一个用于快速切换 hosts 文件的小程序，基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。 截图 功能特性 快速切换 hosts hosts 文件语法高亮 在线 hosts 方案 系统托盘图标快速切换 macOS: 支持 Alfred workflow 快速切换 安装下载安装你可以直接下载源码到本地运行或编辑，或者在下面下载可执行版本： SwitchHosts! 下载地址1（GitHub release） SwitchHosts! 下载地址2（百度网盘） brew在 macOS 上，也可以使用 brew cast 安装，命令如下： brew cask install switchhosts 感谢 @gobinathm、@iamybj 更新 brew cask 版本。 文件备份SwitchHosts! 的数据文件在 ~/.SwitchHosts 目录下（Windows 用户为个人主目录下的 .SwitchHosts 目录下），其中 ~/.SwitchHosts/data.json 是 hosts 数据文件，~/.SwitchHosts/prefereces.json 是配置信息。 运行/打包方法环境配置 安装 Node.js 环境； 在根目录 ./ 下，运行 npm install 命令，安装开发依赖库； 在 ./app 目录下，运行 npm install 命令，安装 App 运行依赖库； npm installcd app &amp;&amp; npm install &amp;&amp; cd .. 构建及运行 在 ./ 目录下，运行 npm run dll 命令，构建公共文件（仅需在第一次构建或公共库发生改变时执行）； 在 ./ 目录下，运行 npm run build 命令，构建所需文件； 在 ./ 目录下，运行 npm start 命令，即可运行程序。 # create dll filenpm run dll# buildnpm run build# startnpm start# or start in developer modenpm run dev 打包发布 建议使用 electron-packager 进行打包 # install electron-packager for use from clinpm install electron-packager -g 在 ./ 目录下，运行 npm run pack 命令，打包后的文件位于 ./dist 目录； 首次执行此命令可能需要花费较多时间（需要下载对应的构建文件），也可先手动下载对应的发布版本（淘宝镜像），手动保存到 ~/.electron 目录下。更多信息请参考 Electron 文档。 # packnpm run pack # the packed files will be in ./dist# 也可以只打包特定平台的版本，如npm run pack-mac # pack for macOS, the packed files will be in ./distnpm run pack-win # pack for Windows, the packed files will be in ./dist 打包完成后，可运行以下命令将生成的程序压缩为 zip 文件。 # zipnpm run zip # the zipped files will be in ./dist 更新历史v3.3 2017-05-30 引入 Ant Design 重写部分 UI 组件 2017-04-03 支持通过 Alfred 快速切换（下载 workflow） 2017-04-01 代码重构，增加「分组」功能 v3.2 2016-09-06 使用 Electron 打包，增加 Windows 版下载。 v3.1 2016-04-29 更新自动清除 DNS 缓存功能 #90。 2016-01-15 搜索时增加模糊搜索支持（eg. go*le matches google）及正则支持（eg. /go.*le matches google）。 2016-01-10 远程方案可以设置自动更新时间。 2015-12-26 实现 Tray 菜单切换、Dock 图标隐藏、方案导入导出等功能。 2015-12-20 从 Electron 切换至 MacGap 。 v3.0 2015-11-30 完成 3.0 版基本功能。 v2.0 2013-02-06 解决 Linux/Mac 下没有修改系统 hosts 文件权限的问题。 2012-12-27 启动时检查是否为单一实例，禁止同时运行多个实例。 2012-11-16 接受 @charlestang 网友的 pull request，同时参考了 @allenm 的修改，实现了 Common Hosts 功能。 2012-11-09 简单优化：Common Hosts 不允许删除，不允许“切换到”，将右键菜单相关条目禁用，允许更换图标颜色。修复新增在线方案时，url 框默认禁用的小 bug。 2012-10-09 增加 hosts 方案拖拽排序功能。 2012-10-05 修复在中文目录下程序无法正常启动的问题。 2012-09-30 初步完成 0.2.0 版。 v1.0 2011-12-14 允许输入超长的 hosts 方案。 2011-10-09 发布 0.1.6 版，修复若干 bug，增加自动检查最新版本的功能。 2011-09-29 发布 0.1.5 版，新增 hosts 内容语法高亮。 2011-09-28 发布 0.1.4 版，新增“添加”、“删除”按钮；hosts 内容修改后自动保存；修复若干 bug。 2011-09-19 发布 0.1.3 版，修复若干 bug。 2011-09-15 发布 0.1.2 版，添加主面板，可以在主面板上对 hosts 进行增加、删除、编辑、重命名等操作。 2011-09-02 发布 0.1.0 版，完成基本功能。 版权本程序完全免费，并基于 MIT 协议开源。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout完全解析,快来优化你的布局吧]]></title>
    <url>%2Fposts%2Fa495ccb1.html</url>
    <content type="text"><![CDATA[Demo地址：ConstraintLayout 一、概述ConstraintLayout出现有一段时间了，不过一直没有特别去关注，也多多少少看了一些文字介绍，多数都是对使用可视化布局拖拽，个人对拖拽一直不看好，直到前段时间看到该文： 解析ConstraintLayout的性能优势 非常详尽的介绍了ConstraintLayout的性能优势，于是乎开始学习了一下ConstraintLayout。 本文的重点不在与可视化界面的学习，而在于如何手写各类约束布局属性。对于可视化界面学习推荐： Android新特性介绍，ConstraintLayout完全解析 下面开始进入正题，大家都知道，当布局嵌套深入比较深的时候，往往会伴随着一些性能问题。所以很多时候我们建议使用RelativeLayout或者GridLayout来简化掉布局的深度。 而对于简化布局深度，ConstraintLayout几乎可以做到极致，接下来我们通过实例来尽可能将所有常见的属性一步步的介绍清楚。 首先需要引入我们的ConstraintLayout，在build.gradle中加入： compile 'com.android.support.constraint:constraint-layout:1.0.2' 二、来编写一个Feed Item我们先看一个简单的新闻列表中常见的feed item。 看到这样的布局，大家条件反射应该就是使用RelativeLayout来做，当然了，本案例我们使用ConstraintLayout来写： &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#11ff0000" tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:id="@+id/tv1" android:layout_width="140dp" android:layout_height="86dp" android:layout_marginLeft="12dp" android:layout_marginTop="12dp" android:background="#fd3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/tv2" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginRight="12dp" android:text="马云:一年交税170多亿马云:一年交税170多亿马云:一年交税170多亿" android:textColor="#000000" android:textSize="16dp" app:layout_constraintLeft_toRightOf="@id/tv1" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="@id/tv1" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginTop="12dp" android:text="8分钟前" android:textColor="#333" android:textSize="12dp" app:layout_constraintLeft_toRightOf="@id/tv1" app:layout_constraintBottom_toBottomOf="@id/tv1" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 看上面的布局，我们好像看到了几个模式的属性： 首先是tv1，有两个没见过的属性： app:layout_constraintLeft_toLeftOf=&quot;parent&quot; 从字面上看，指的是让该控件的左侧与父布局对齐，当我们希望控件A与控件B左侧对齐时，就可以使用该属性。 app:layout_constraintLeft_toLeftOf="@id/viewB" 类似的还有个相似的属性为： app:layout_constraintLeft_toRightOf 很好理解，即当前属性的左侧在谁的右侧，当我们希望控件A在控件B的右侧时，可以设置： app:layout_constraintLeft_toRightOf="@id/viewB" 与之类似的还有几个属性： layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf 类推就可以了。 现在在头看刚才的布局： tv1设置了：app:layout_constraintLeft_toLeftOf="parent"app:layout_constraintTop_toTopOf="parent"tv2设置了：app:layout_constraintLeft_toRightOf="@id/tv1"app:layout_constraintRight_toRightOf="parent"app:layout_constraintTop_toTopOf="@id/tv1"tv3设置了：app:layout_constraintLeft_toRightOf="@id/tv1"app:layout_constraintBottom_toBottomOf="@id/tv1" 按照我们刚才的理解，再次的解读下： tv1应该是在父布局的左上角； tv2在tv1的右侧，tv2的右侧和父布局对其，tv2和tv1顶部对齐； tv3在tv1的右侧，tv3和tv1底部对其。 到这里，大家可以看到，目前我们已经可以控制任何一个控件与其他控件间的相对位置了，以及与parent间的相对位置。 和RL的差异大家是不是觉得目前来看和RelativeLayout特别像？ 其实还是有很明显的区别的，我们通过一个例子来看一下： &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/id_btn01" android:layout_width="100dp" android:text="Btn01" android:layout_height="wrap_content" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_toRightOf="@id/id_btn01" android:text="Btn02" android:layout_alignParentRight="true" /&gt;&lt;/RelativeLayout&gt; 那么经过我们刚才的学习，把： layout_toRightOf=&quot;@id/id_btn01&quot;，layout_alignParentRight=&quot;true&quot; 分别替换为： app:layout_constraintLeft_toRightOf=&quot;@id/id_btn01&quot;，app:layout_constraintRight_toRightOf=&quot;parent&quot; 是不是觉得so easy ，但是我们看一下效果图： 是不是和预期有一定的区别，假设你将Btn02的宽度设置的非常大，你会发现更加诡异的事情： 你会发现Btn02，好像疯了一样，我们设置的在btn01右侧，和与parent右侧对齐完全失效了！！！ 别怕，接下来就让你认识到为什么这个控件叫做“Constraint”Layout。 在当控件有自己设置的宽度，例如warp_content、固定值时，我们为控件添加的都是约束“Constraint”，这个约束有点像橡皮筋一样会拉这个控件，但是并不会改变控件的尺寸（RL很明显不是这样的）。 例如上例，当btn02的宽度较小时，我们为其左侧设置了一个约束（btn01右侧），右侧设置了一个约束（parent右侧对其），当两个约束同时生效的时候（你可以认为两边都是相同的一个拉力），btn02会居中。 当btn02特别大的时候，依然是这两个力，那么会发生什么？会造成左侧和右侧超出的距离一样大。 那么现在大家肯定有些疑问： 怎么样才能和上面的RL一样，宽度刚好占据剩下的距离呢（btn01右侧到屏幕右侧的距离）？ 这个问题，问得很好，我们刚才所有的尝试都是在控件自身拥有特定的宽度情况下执行的；那么如果希望控件的宽度根据由约束来控件，不妨去掉这个特定的宽度，即设置为0试试？ 对！当我们将btn02的宽度设置为0时，一切又变得很完美。 那么这里，你可能会问0值是什么含义，其实在ConstraintLayout中0代表：MATCH_CONSTRAINT，看到这个常量，是不是瞬间觉得好理解了一点。 最后一个问题，MATCH_PARENT哪去了? 看官网的解释： Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”.` 所以你可以认为：在ConstraintLayout中已经不支持MATCH_PARENT这个值了，你可以通过MATCH_CONSTRAINT配合约束实现类似的效果。 好了，到这里，目前我们已经看到其已经和RelativeLayout势均力敌了，接下来我们看一下RL做不到的特性。 三、增加一个banner我们现在以往在这个feed item顶部添加一个banner，宽度为占据整个屏幕，宽高比为16：6。 这里尴尬了，在之前的做法，很难在布局中设置宽高比，一般我们都需要在代码中显示的去操作，那么如果你用了ConstraintLayout，它就支持。 看一眼如何支持： &lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:id="@+id/banner" android:layout_width="0dp" android:layout_height="0dp" android:background="#765" android:gravity="center" android:text="Banner" app:layout_constraintDimensionRatio="H,16:6" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; &lt;TextView android:id="@+id/tv1" app:layout_constraintTop_toBottomOf="@id/banner" &gt;&lt;/TextView&gt; ...&lt;/...&gt; 我们添加了一个banner，还记得我们刚才所说的么，不要使用match_parent了，而是设置match_contraint，即0，让约束来控制布局宽高。 所以我们设置了宽、高都是match_contraint，然后这两个属性： app:layout_constraintLeft_toLeftOf="parent"app:layout_constraintRight_toRightOf="parent" 让我们的宽度充满整个父布局，在添加一个： app:layout_constraintDimensionRatio="16:6" 该属性指的是宽高比，所以16：6就可以完成我们的需求。 好了看下效果图： 这个宽高比属性，还支持这样的写法： app:layout_constraintDimensionRatio="W,16:6"app:layout_constraintDimensionRatio="H,16:6" 可以自己试验下。 好了，到这里，我们又新增了一个属性，还是个非常实用的属性。 那么，我们继续，再看一个似曾相识的功能。 四、增加几个Tab现在我们希望在底部增加3个tab，均分。是不是想到了LinearLayout和weight。 没错！ConstraintLayout也支持类似的属性。 虽然我知道，但是写到这我还是有点小惊喜~~ 看下如何实现： &lt;TextView android:id="@+id/tab1" android:layout_width="0dp" android:layout_height="30dp" android:background="#f67" android:gravity="center" android:text="Tab1" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@+id/tab2" /&gt;&lt;TextView android:id="@+id/tab2" android:layout_width="0dp" android:layout_height="30dp" android:background="#A67" android:gravity="center" android:text="Tab2" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/tab1" app:layout_constraintRight_toLeftOf="@+id/tab3" /&gt;&lt;TextView android:id="@+id/tab3" android:layout_width="0dp" android:layout_height="30dp" android:background="#767" android:gravity="center" android:text="Tab3" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/tab2" app:layout_constraintRight_toRightOf="parent" /&gt; 我们增加3个textview来冒充tab。我们看横向的依赖，3个tab两两设置了约束（即你在我们的左边，我在你的右边），最外层的设置了parent约束；再加上我们把宽度都设置为了match_constraint，so，这样我们就完成了3个tab等分。 看一眼效果图： 你可能会说，LL配合weight更加灵活，可以单个设置占据的比例。 对，没错，我们也支持，我不是还没说完么。 现在我们可以给每个tab设置一个属性： app:layout_constraintHorizontal_weight 看到这个名字，应该就明白了吧，假设我们分别设置值为2，1，1。 效果图为： 是不是很惊喜，别急，刚才你说我不如LL，现在我要让你再看一些LL配合weight做不到的。 这里需要借助几张官网上的图了： 刚才我们说了，3个tab两两设置了依赖，即类似下图： 横向的相当于组成了一个链(Chains)。在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果： 该属性为： layout_constraintHorizontal_chainStyle 我们已经见过一种效果了，即按照weight等分，可以成为weighted chain。设置条件为： chainStyle=”spread”，所有控件宽度设置为match_constraint，因为默认就是spread，所以我们没有显示设置。 其取值还可以为： packed spread_inside 我还是分别显示一下吧： spread + 宽度非0 spread + 宽度为0，且可以通过weight控制分配比例（上例） spread_inside + 宽度非0 packed + 宽度非0 好了，差不多了，我们可以在横向或者纵向组成一个Chain，然后在Chain head设置chainStyle来搞一些事情。 官网有个图： 前四个我们都演示了，最后一个设计到一个新的bias属性，别急，咱们慢慢说~~ 好了，到这里，我们再次见证了ConstraintLayout的强大。 我们最后再看一个例子。 五、增加浮动按钮一个很常见的功能，我们现在希望在右下角增加一个浮动按钮。 看下如何实现： &lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:layout_width="60dp" android:layout_height="60dp" android:background="#612" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.9" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintVertical_bias="0.9" /&gt;&lt;/....&gt; 我们在最后追加一个TextView冒充我们的浮动按钮。可以看到我们设置了固定值，被设置约束为右下角。 正常情况我们可以通过margin来设置与右侧与底部的距离。 但是这里我们尝试使用量个新的属性： layout_constraintHorizontal_biaslayout_constraintVertical_bias 即设置上下两侧间隙比例分别为90%与10%。这个很好理解，我们之前说了，再没有bias这个属性的时候，这两侧的拉力大小是一样的，但是你可以通过bias来控制哪一侧的力要大一些~~明白了么~ 所以，该属性可以用于约束之前，控制两侧的“拉力”。 我们看一下效果图： 那么到这里，ConstraintLayout的属性我们基本上介绍完了： 我们看一下： layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOflayout_constraintRight_toLeftOflayout_constraintRight_toRightOflayout_constraintTop_toTopOflayout_constraintTop_toBottomOflayout_constraintBottom_toTopOflayout_constraintBottom_toBottomOf# 即文章的baseline对齐layout_constraintBaseline_toBaselineOf# 与left,right类似layout_constraintStart_toEndOf layout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf# margin不需要解释android:layout_marginStartandroid:layout_marginEndandroid:layout_marginLeftandroid:layout_marginTopandroid:layout_marginRightandroid:layout_marginBottomlayout_constraintHorizontal_bias layout_constraintVertical_bias layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStylelayout_constraintVertical_weightGuideline 好像，还有个比较特殊的，叫Guideline。 好吧，继续~ 六、尝试使用Guidelineandroid.support.constraint.Guideline该类比较简单，主要用于辅助布局，即类似为辅助线，横向的、纵向的。该布局是不会显示到界面上的。 所以其有个属性为： android:orientation取值为”vertical”和”horizontal”. 除此以外，还差个属性，决定该辅助线的位置： layout_constraintGuide_begin layout_constraintGuide_end layout_constraintGuide_percent 可以通过上面3个属性其中之一来确定属性值位置。 begin=30dp，即可认为距离顶部30dp的地方有个辅助线，根据orientation来决定是横向还是纵向。 end=30dp，即为距离底部。percent=0.8即为距离顶部80%。 好了，下面看一个例子，刚才我们的浮点按钮，我决定通过两根辅助线来定位，一根横向距离底部80%，一个纵向距离顶部80%，浮点按钮就定位在他们交叉的地方。 &lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline_h" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" app:layout_constraintGuide_percent="0.8" /&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline_w" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_percent="0.8" /&gt; &lt;TextView android:layout_width="60dp" android:layout_height="60dp" android:background="#612" app:layout_constraintLeft_toRightOf="@id/guideline_w" app:layout_constraintTop_toBottomOf="@id/guideline_h" /&gt;&lt;/....&gt; 我感觉都不用解释了~~看眼效果图吧： 到此，属性基本上讲完啦~ 可以看到，上述相当复杂的一个布局，在ConstraintLayout中完全没有嵌套！ 六、总结本文通过实际的按钮，基本上介绍了ConstraintLayout所支持的所有的属性，全文没有提及拖拽，因为当界面复杂之后，想要完美的拖拽实在是太难了，而且谁也不期望，看不懂拖拽完成后的布局属性吧~ 所以，我建议还是尽可能手写，通过本文这样一个流程，虽然支持的属性有20多个，但是分类后并不难记，难记也可以拿出本文翻一翻~ 好了，思考了半天，如何通过一个案例介绍完所有的属性，总体来说还是完成了，给自己点个赞。 转载于：张鸿洋的博客]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑马灯MarqueeView（支持任何View）]]></title>
    <url>%2Fposts%2F553b92de.html</url>
    <content type="text"><![CDATA[类似TextView的android:ellipsize=”marquee”的跑马灯效果 任意View都可实现 源码：MarqueeViewpackage com.zm.marqueeview;import android.content.Context;import android.util.AttributeSet;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.WindowManager;import android.widget.HorizontalScrollView;import android.widget.LinearLayout;/** * 跑马灯MarqueeView */public class MarqueeView extends HorizontalScrollView implements Runnable &#123; private Context context; private LinearLayout mainLayout;//跑马灯滚动部分 private int scrollSpeed = 5;//滚动速度 private int scrollDirection = LEFT_TO_RIGHT;//滚动方向 private int currentX;//当前x坐标 private int viewMargin = 100;//View间距 private int viewWidth;//View总宽度 private int screenWidth;//屏幕宽度 public static final int LEFT_TO_RIGHT = 1; public static final int RIGHT_TO_LEFT = 2; public MarqueeView(Context context) &#123; this(context, null); &#125; public MarqueeView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MarqueeView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); this.context = context; initView(); &#125; void initView() &#123; WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE); screenWidth = wm.getDefaultDisplay().getWidth(); mainLayout = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.scroll_content, null); this.addView(mainLayout); &#125; public void addViewInQueue(View view) &#123; LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(viewMargin, 0, 0, 0); view.setLayoutParams(lp); mainLayout.addView(view); view.measure(0, 0);//测量view viewWidth = viewWidth + view.getMeasuredWidth() + viewMargin; &#125; //开始滚动 public void startScroll() &#123; removeCallbacks(this); currentX = (scrollDirection == LEFT_TO_RIGHT ? viewWidth : -screenWidth); post(this); &#125; //停止滚动 public void stopScroll() &#123; removeCallbacks(this); &#125; //设置View间距 public void setViewMargin(int viewMargin) &#123; this.viewMargin = viewMargin; &#125; //设置滚动速度 public void setScrollSpeed(int scrollSpeed) &#123; this.scrollSpeed = scrollSpeed; &#125; //设置滚动方向 默认从左向右 public void setScrollDirection(int scrollDirection) &#123; this.scrollDirection = scrollDirection; &#125; @Override public void run() &#123; switch (scrollDirection) &#123; case LEFT_TO_RIGHT: mainLayout.scrollTo(currentX, 0); currentX--; if (-currentX &gt;= screenWidth) &#123; mainLayout.scrollTo(viewWidth, 0); currentX = viewWidth; &#125; break; case RIGHT_TO_LEFT: mainLayout.scrollTo(currentX, 0); currentX++; if (currentX &gt;= viewWidth) &#123; mainLayout.scrollTo(-screenWidth, 0); currentX = -screenWidth; &#125; break; default: break; &#125; postDelayed(this, 50 / scrollSpeed); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 完美修改应用包名]]></title>
    <url>%2Fposts%2F9b574dca.html</url>
    <content type="text"><![CDATA[我们平时新建项目有些朋友可能当时就是随意写的一个包名，然后在项目过程中， 又感觉这个包名不太好，所以就要对包名进行修改。 修改最外层包名 修改中间层包名 看到没有，我们只需要在setting里面，把 compact empty middle packages 这个选项去掉，这样，我们的包的层次结构就分开了，这个时候我们就可以根据自己的需要去做相应的修改了。 新增：Studio 3.0 之后，setting 中的选项名字该成了 Hide empty middle packages 另外说明一点，在 Studio 里面我们的 getPackageName 对应的是 applicationId , 而manifest 的那个package，在这里的作用其实是为了引用内部资源文件，以及保证 Activity 等源文件的路径正确而已，所以，在 Studio 中修改发布程序包名，则只需要在 build 文件中修改 applicationId 就可以了。 补充在 Studio 3.0 还有一种可直接通过 Androidmenifest 修改部分包名的方法（亲测过）。这里就不上图了。语言给大家描述一下，有什么问题可以博客下方留言。 修改流程如下：进入 Androidmanifest.xml 文件，找到 package 名称，选中需要修改的部分。比如原包名为com.zm.android如果需要修改中间的 zm ，那么我们就选中 zm ,依次进行 右键 - &gt; Refactor -&gt; Rename , (Mac 快捷键为 fn + shift+F6)然后选择 Rename package , 输入要修改目标的名称 ，直接点击 Refactor , 左下方继续点击 Do Refactor , 等待修改成功~！]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿支付宝首页应用管理(拖拽排序，添加删除)]]></title>
    <url>%2Fposts%2Fed9fc033.html</url>
    <content type="text"><![CDATA[MenuManage-Imitate-Alipay仿支付宝首页应用管理(拖拽排序，添加删除) 效果图 Download Demo]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android解决qq分享后返回程序出现的Bug]]></title>
    <url>%2Fposts%2Fa03cc66a.html</url>
    <content type="text"><![CDATA[问题：当我们使用qq分享时，分享成功后选择留在qq,这个时候按home键，回到手机主界面，在点击回到我的app,这个时候会出现界面显示出来了，但是任何事件都不响应，即按钮没反应。 分析：这个时候回到我们的app时，会发现activity的生命周期只走了 onRestart()—onStart(),走到这里就结束了，onResume()并没有执行，所以界面不响应 这个时候我们又会发现qq分享用到的的一个AssistActivity 它的生命周期：.: –onActivityResult()—onStart()—onResume() 结论：至此，我们发现了原因，是这个AssistActivity的问题。 解决：我们可以在我们程序的onStart()方法判断一下，如果这个AssistActivity处在栈顶就把它清除掉。 @Overrideprotected void onStart() &#123; super.onStart(); Log.i("---share----", "-----start"); if(isNeedRestart())&#123; Intent intent = new Intent(context, this.getClass()); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //清除栈顶的activity intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);//不显示多余的动画，假装没有重新启动 //记得带需要的参数 startActivity(intent); &#125;&#125;private boolean isNeedRestart()&#123; ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; tasks = am.getRunningTasks(1); if (!tasks.isEmpty()) &#123; ComponentName topActivity = tasks.get(0).topActivity; ActivityManager.RunningTaskInfo taskInfo = tasks.get(0); if (topActivity.getPackageName().equals(context.getPackageName())) &#123; // 若当前栈顶界面是AssistActivity，则需要手动关闭 if (topActivity.getClassName().equals("com.tencent.connect.common.AssistActivity")) return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-仪表盘控件仿芝麻信用]]></title>
    <url>%2Fposts%2F8a91974c.html</url>
    <content type="text"><![CDATA[前言由于项目需要使用到仪表盘图表，所以就本着一贯的操作流程就来github上面找，结果发现很多图表或者不是我需要的或者扩展性不强，所以就自己动手写了一个扩展性较强的，希望能帮助到有需要的人。（不过本人能力有限，有不足的地方还请见谅） 效果来源：Github传送门 先定个小目标由于每个公司的UI肯定都有不同的想法，设计出来的效果图也千奇百怪。所以我一开始的想法是能写一个基类的仪表盘图表，不需要懂得太多的自定义View知识也能做出UI所需要的效果。 我就想尝试着能不能自己写一个，万一能帮助到其他人呢。（梦想还是要有的） 所以我就抽取了一个BaseDashboardView类，并实现了三个Style的仪表盘图表。而这三个仪表盘除去一些画笔的初始化和参数的设置，绘制的代码都在70行内。下面就来看一下如何定义一个自己的仪表盘图表吧。 然后去做吧创建一个View然后去继承 BaseDashboardView 这时需要实现以下方法： protected abstract void initView(); protected abstract void initArcRect(float left, float top, float right, float bottom); protected abstract void drawArc(Canvas canvas, float arcStartAngle, float arcSweepAngle); protected abstract void drawProgressArc(Canvas canvas, float arcStartAngle, float progressSweepAngle); protected abstract void drawText(Canvas canvas, int value, String valueLevel, String currentTime); 复制代码 然后让我们来看看每个方法都是什么用的。 initView() 就是初始化设置，如创建画笔等。 initArcRect(float left, float top, float right, float bottom) 在我们绘制圆弧的时候可以传入Rect对象来确定圆弧的绘制范围，需要这里就是给我们初始化圆弧的区域的。 如:mRectArc = new RectF(left, top, right, bottom); drawArc(Canvas canvas, float arcStartAngle, float arcSweepAngle)这是就是开始正式的绘制背景圆弧了，arcStartAngle表示圆弧的起始角度，arcSweepAngle表示圆环一共多少度。我们通过刚才的Rect就可以绘制出一个圆弧如：canvas.drawArc(mRectOuterArc, arcStartAngle, arcSweepAngle, false, mPaintArc);但是要主要画笔的样式要设置为Paint.Style.STROKE drawProgressArc(Canvas canvas, float arcStartAngle, float progressSweepAngle)而这里是绘制进度圆弧的地方，progressSweepAngle进度的幅度已经在BaseDashboardView中计算好，只需要通过drawArc中的一样绘制个圆弧就行。 drawText(Canvas canvas, int value, String valueLevel, String currentTime)在这里可以把文字绘制到你想要他出现的地方就OK拉。数据已经在BaseDashboardView中处理过，直接绘制就可以。 由于很多逻辑的计算和动画都是在BaseDashboardView中去实现，所以我们只需要实现这几个方法，然后实现一些绘制的逻辑就可以咯。如果在绘制方面有什么问题的可以查看一下3个样式的DashboardView，如果是对底层的计算有兴趣的可以看一下BaseDashboardView。 接下来就去扩展这里主要说一个方法setCalibration(int[] calibrationNumberText, String[] calibrationBetweenText,int largeCalibrationBetweenNumber) 然后主要说一下calibrationNumberText和calibrationBetweenText参数，他们的初始默认值是 int[]{350, 550, 600, 650, 700, 950}和String[]{&quot;较差&quot;, &quot;中等&quot;, &quot;良好&quot;, &quot;优秀&quot;, &quot;极好&quot;} 那这样其实组成了一个区间 350 较差 550 中等 600 良好 650 优秀 700 极好 950 他的意思为350-550的为较差，其他依次类推，但是每个区间的大小是不一样的，较差的区间为550-350=200，而中等区间为650-550=50。但是每个区间在图表上显示的区域大小确实相同的。那么在计算进度幅度的时候需要区别计算。 而我的实现方式是首先判断当前value在第几个区间中，如当前value=575。那么通过循环的方式可以知道当前value处在550和600之间。然后通过 (575 - 550) / (600 - 550)公式计算出当前值在这个区间内占的百分比。然后通过每个区间的角度算出当前进度条的幅度。 而除了刻度的扩展其实还有很多其他的可配置项，可以通过github进行查看。 公共方法介绍//设置当前数值 value:数值 isAnim:是否开启东湖 reset:是否从头开始进行动画setValue(int value, boolean isAnim, boolean reset)//设置动画时长 (默认为2.5秒)setProgressAnimTime(long time)//设置圆弧角度 //arcStartAngle:起始角度 (默认值: 165)//arcSweepAngle:圆弧度数 (默认值: 210)setArcAngle(float arcStartAngle,float arcSweepAngle)&#123;//设置刻度属性//calibrationNumberText 每个大刻度对应的数值 (默认值: int[]&#123;350, 550, 600, 650, 700, 950&#125;)//calibrationBetweenText 每个大刻度中间的文字 (默认值: String[]&#123;&quot;较差&quot;, &quot;中等&quot;, &quot;良好&quot;, &quot;优秀&quot;, &quot;极好&quot;&#125;)//largeCalibrationBetweenNumber 两个大刻度中间有多少个小刻度 (默认值: 3)setCalibration(int[] calibrationNumberText, String[] calibrationBetweenText,int largeCalibrationBetweenNumber)//设置日期格式化的格式 (默认值: yyyy-MM-dd)setDatePattern(String pattern)//设置时间的显示格式 格式(如: 评估时间：&#123;date&#125;) &#123;date&#125;为占位符setDateStrPattern(String pattern)//设置数值等级的模板 格式(如: 信用&#123;level&#125;) &#123;level&#125;为占位符setValueLevelPattern(String pattern)//设置数值的画笔属性 (默认值: 60sp white)setValuePaint(float spSize, @ColorInt int color)//设置数值等级的画笔属性 (默认值: 25sp white)setValueLevelPaint(float spSize, @ColorInt int color)//设置日期对应的画笔属性 (默认值: 10sp white)setDatePaint(float spSize, @ColorInt int color)//设置中间文字中间的间距 (默认值: 7dp)setTextSpacing(int spacingDp) Style 1 //设置圆环之间的距离 (默认值: 15dp)setArcSpacing(float dpSize)//设置外环的画笔属性 (默认值: 3dp Color.argb(80, 255, 255, 255))setOuterArcPaint(float dpSize, @ColorInt int color)//设置内环的画笔属性(默认值: 10dp Color.argb(80, 255, 255, 255))setInnerArcPaint(float dpSize, @ColorInt int color)//设置进度条的颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressArcColor(@ColorInt int color)//设置进度条的点的画笔属性 (默认值: 3dp white)setProgressPointPaint(float dpRadiusSize,@ColorInt int color)//设置大刻度的画笔属性 (默认值: 2dp Color.argb(200, 255, 255, 255))setLargeCalibrationPaint(float dpSize, @ColorInt int color)//设置小刻度的画笔属性 (默认值: 0.5dp Color.argb(100, 255, 255, 255))setSmallCalibrationPaint(float dpSize, @ColorInt int color)//设置刻度文字的画笔属性 (默认值: 10sp white)setCalibrationTextPaint(float spSize, @ColorInt int color)//设置大刻度中间的数值等级的画笔属性 (默认值: 10sp white)setCalibrationBetweenTextPaint(float spSize, @ColorInt int color) Style 2 //设置圆环颜色 (默认值: Color.argb(120, 255, 255, 255))setArcColor(@ColorInt int color)//设置进度圆环的颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressColor(@ColorInt int color)//设置圆环的刻度大小 (默认值: 2.5dp)setArcCalibrationSize(int dpSize) Style 3 //设置圆环之间的距离 (默认值: 10dp)setArcSpacing(float dpSize)//设置外环的画笔属性 (默认值: 1.5dp Color.argb(80, 255, 255, 255))setOuterArcPaint(float dpSize, @ColorInt int color)//设置外环的进度颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressOuterArcColor(@ColorInt int color)//设置内环的画笔属性 (默认值: 1.5dp Color.argb(50, 255, 255, 255))setInnerArcPaint(float dpSize, @ColorInt int color)//设置内环的进度颜色 (默认值: Color.argb(170, 255, 255, 255))setProgressInnerArcPaint(@ColorInt int color)//设置内环实线和虚线状态 (默认值: float[] &#123; 10, 10 &#125;)setInnerArcPathEffect(float[] intervals)//设置进度点的画笔属性 (默认值: 3dp white)setProgressPointPaint(float dpRadiusSize,@ColorInt int color)//设置指示器颜色 (默认值: Color.argb(200, 255, 255, 255))setIndicatorPaint(@ColorInt int color)]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中多线程切换的几种方法]]></title>
    <url>%2Fposts%2Ffbda19a9.html</url>
    <content type="text"><![CDATA[我们知道，多线程是Android开发中必现的场景，很多原生API和开源项目都有多线程的内容，这里简单总结和探讨一下常见的多线程切换方式。我们先回顾一下Java多线程的几个基础内容，然后再分析总结一些经典代码中对于线程切换的实现方式。 几点基础多线程切换，大概可以切分为这样几个内容：如何开启多个线程，如何定义每个线程的任务，如何在线程之间互相通信。 ThreadThread可以解决开启多个线程的问题。Thread是Java中实现多线程的线程类，每个Thread对象都可以启动一个新的线程，注意是可以启动，也可以不启动新线程： thread.run();//不启动新线程，在当前线程执行thread.start();//启动新线程。 另外就是Thread存在线程优先级问题，如果为Thread设置较高的线程优先级，就有机会获得更多的CPU资源，注意这里也是有机会，优先级高的Thread不是必然会先于其他Thread执行，只是系统会倾向于给它分配更多的CPU。默认情况下，新建的Thread和当前Thread的线程优先级一致。设置线程优先级有两种方式： thread.setPriority(Thread.MAX_PRIORITY);//1~10，通过线程设置Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);//-20~19，通过进程设置 这两种设置方式是相对独立的，在Android中，一般建议通过Process进程设置优先级。 ThreadPoolThread本身是需要占用内存的，开启/销毁过量的工作线程会造成过量的资源损耗，这种场景我们一般会通过对资源的复用来进行优化，针对IO资源我们会做IO复用（例如Http的KeepAlive），针对内存我们会做内存池复用（例如Fresco的内存池），针对CPU资源，我们一般会做线程复用，也就是线程池。所以，在Android开发中，一般不会直接开启大量的Thread，而是会使用ThreadPool来复用线程。 RunnableRunnable主要解决如何定义每个线程的工作任务的问题。Runnable是Java中实现多线程的接口，相对Thread而言，Runnable接口更容易扩展（不需要单继承），而且，Thread本身也是一种Runnable： public class Thread implements Runnable &#123; 相比Thread而言，Runnable不关注如何调度线程，只关心如何定义要执行的工作任务，所以在实际开发中，多使用Runnable接口完成多线程开发。 CallableCallable和Runnable基本类似，但是Callable可以返回执行结果。 线程间通信Thread和Runnable能实现切换到另一个线程工作（Runnable需要额外指派工作线程），但它们完成任务后就会退出，并不注重如何在线程间实现通信，所以切换线程时，还需要在线程间通信，这就需要一些线程间通信机制。 Future一般来说，如果要做简单的通信，我们最常用的是通过接口回调来实现。Future就是这样一种接口，它可以部分地解决线程通信的问题，Future接口定义了done、canceled等回调函数，当工作线程的任务完成时，它会（在工作线程中）通过回调告知我们，我们再采用其他手段通知其他线程。 mFuture = new FutureTask&lt;MyBizClass&gt;(runnable) &#123; @Override protected void done() &#123; ...//还是在工作线程里 &#125;&#125;; ConditionCondition其实是和Lock一起使用的，但如果把它视为一种线程间通信的工具，也说的通。因为，Condition本身定位就是一种多线程间协调通信的工具，Condition可以在某些条件下，唤醒等待线程。 Lock lock = new ReentrantLock(); Condition notFull = lock.newCondition(); //定义Lock的Condition... while (count == items.length) notFull.await();//等待condition的状态... notFull.signal();//达到condition的状态 Handler其实，最完整的线程间通信机制，也是我们最熟悉的线程间通信机制，莫过于Handler通信机制，Handler利用线程封闭的ThreadLocal维持一个消息队列，Handler的核心是通过这个消息队列来传递Message，从而实现线程间通信。 AsyncTask的多线程切换回顾完多线程的几个基础概念，先来看看简单的多线程切换，Android自带的AsyncTask。AsyncTask主要在doInBackground函数中定义工作线程的工作内容，在其他函数中定义主线程的工作内容，例如onPostExecute，这里面必然涉及两个问题：1.如何实现把doInBackground抛给工作线程2.如何实现把onPostExecute抛给主线程其实非常简单，我们先看第一个 1.如何实现把doInBackground抛给工作线程在使用AsyncTask时，我们一般会创建一个基于AsyncTask的扩展类或匿名类，在其中实现几个抽象函数，例如： private class MyTask extends AsyncTask&lt;String, Object, Long&gt; &#123; @Override protected void onPreExecute() &#123;... &#125; @Override protected Long doInBackground(String... params) &#123;... &#125; @Override protected void onProgressUpdate(Object... values) &#123;... &#125; @Override protected void onPostExecute(Long aLong) &#123;... &#125; @Override protected void onCancelled() &#123;... &#125; 然后，我们会实例化这个AsyncTask： MyTask mTask = new MyTask(); 在AsyncTask源码中，我们看到，构造函数里会创建一个WorkerRunnable： public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;//这是一个Callable public Result call() throws Exception &#123; ... result = doInBackground(mParams);//在工作线程中执行 ... WorkerRunnable实际上是一个Callable对象，所以，doInBackground是被包在一个Callable对象中了，这个Callable还会被继续包装，最终被交给一个线程池去执行： Runnable mActive;...if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive);//交给线程池执行&#125; 梳理一下，大致过程为：定义doInBackground–&gt;被一个Callable调用–&gt;层层包为一个Runnable–&gt;交给线程池执行。这样就解决了第一个问题，如何实现把doInBackground抛给工作线程。我们再来看第二个问题。 2.如何实现把onPostExecute抛给主线程首先，我们要知道工作任务何时执行完毕，就需要在工作完成时触发一个接口回调，也就是前面说过的Future，还是看AsyncTask源码： public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; ... &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123;//Future的回调 try &#123; postResultIfNotInvoked(get());//get()是FutureTask接口函数 ... &#125; &#125;; &#125; 这样，我们就知道可以处理onPostExecute函数了，但是，我们还需要把它抛给主线程，主要源码如下： //mWorker、mFuture和都会指向postResult函数private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125;//getHandler()会指向InternalHandlerprivate static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper());//指向MainLooper &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]);//通过handler机制，回到主线程，调用finish函数 ...&#125;//在Handler中，最终会在主线程中调用finishprivate void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result);//调用onPostExecute接口函数 &#125; mStatus = Status.FINISHED;&#125; 从源码可以看到，其实AsyncTask还是通过Handler机制，把任务抛给了主线程。 总体来说，AsyncTask的多线程任务是通过线程池实现的工作线程，在完成任务后利用Future的done回调来通知任务完成，并通过handler机制通知主线程去执行onPostExecute等回调函数。 EventBus的多线程切换EventBus会为每个订阅事件注册一个目标线程，所以需要从发布事件的线程中，根据注册信息，实时切换到目标线程中，所以，这是个很典型的多线程切换场景。根据EventBus源码，多线程切换的主要判断代码如下： switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event);//直接在当前线程执行 break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event);//在当前主线程执行 &#125; else &#123; mainThreadPoster.enqueue(subscription, event);//当然不是主线程，交给主线程执行 &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event);//当前线程为主线程，交给工作线程 &#125; else &#123; invokeSubscriber(subscription, event);//直接在当前工作线程执行 &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event);//异步执行 break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);&#125; 所以，在EventBus里，如果需要做线程间切换，主要是抛给不同的任务队列，实现线程间切换。从任务队列判断，切换目标包括主线程Poster、backgroundPoster和asyncPoster这样三种。我们先看任务队列的设计： 任务队列因为EventBus不能判断有哪些任务会并行，所以它采用了队列的设计，多线程任务（EventBus的事件）会先进入队列，然后再处理队列中的工作任务，这是典型的生产–消费场景。主线程Poster、backgroundPoster和asyncPoster都是任务队列的不同实现。 主线程Poster负责处理主线程的mainThreadPoster是Handler的子类： final class HandlerPoster extends Handler &#123;... void enqueue(Subscription subscription, Object event) &#123; ... synchronized (this) &#123;//因为主线程只有一个，需要线程安全 queue.enqueue(pendingPost); ... if (!sendMessage(obtainMessage())) &#123;//作为handler发送消息 ... //在主线程中处理消息 @Override public void handleMessage(Message msg) &#123; ...&#125; 从源码可以看出，这个Poster其实是一个Handler，它采用了哪个线程的消息队列，就决定了它能和哪个线程通信，我们确认一下： EventBus(EventBusBuilder builder) &#123; ... mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);//获取主线程的MainLooper 所以，EventBus是扩展了一个Handler，作为主线程的Handler，通过Handler消息机制实现的多线程切换。当然，这个Handler本事，又多了一层queue。 backgroundPoster和asyncPosterbackgroundPoster和asyncPoster其实都是使用了EventBus的线程池，默认是个缓存线程池： private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); 所以，backgroundPoster和asyncPoster都是把任务交给线程池处理，这样实现的多线程切换。不过，backgroundPoster和asyncPoster也有一些不同，我们知道，在newCachedThreadPool中，最大线程数就是Integer的最大值，相当于不设上限，所以可以尽可能多的启动线程，asyncPoster就是这样做的，enqueu和run都没做同步，为每个事件单独开启新线程处理。而在backgroundPoster中，可以尽量复用线程，主要方法是在run的时候，做个1秒的等待： @Overridepublic void run() &#123; ... PendingPost pendingPost = queue.poll(1000);//允许等待1秒 因为做了这一秒的挂起等待，在enqueue和run时，都需要用synchronized (this) 来确保线程安全。 另外，其实这里面还有个很重要的用法，就是Executors.newCachedThreadPool()中的SynchronousQueue： public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());//用于辅助线程切换的阻塞队列&#125; 这个SynchronousQueue，在OkHttp中也使用了： //okhttp3.Dispatcher源码public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false));//用于辅助线程切换的阻塞队列 &#125; return executorService;&#125; SynchronousQueue与普通队列不同，不是数据等线程，而是线程等数据，这样每次向SynchronousQueue里传入数据时，都会立即交给一个线程执行，这样可以提高数据得到处理的速度。 总的来看，EventBus还是采用线程池实现工作线程，采用handler机制通知到主线程。不同在于，它采用的queue的队列方式来管理所有的跨线程请求，而且它利用了SynchronousQueue阻塞队列来辅助实现线程切换。 RxJava的多线程切换其实在多线程管理这方面，RxJava的线程管理能力是非常令人赞叹的。RxJava的主要概念是工作流，它可以把一序列工作流定义在一个线程类型上： myWorkFlow.getActResponse(myParam) .subscribeOn(Schedulers.io())//指定线程 .xxx//其他操作 这个构建工作流的过程其实挺复杂的，不过如果我们只看线程操作这部分，其实流程非常清晰，我们追踪一下subscribeOn的源码（RxJava2）： //进入subscribeOnpublic final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return subscribeOn(scheduler, !(this instanceof FlowableCreate));&#125;//继续进入subscribeOnpublic final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler, boolean requestOn) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new FlowableSubscribeOn&lt;T&gt;(this, scheduler, requestOn));&#125; 然后，进入FlowableSubscribeOn类 //进入FlowableSubscribeOn类 public FlowableSubscribeOn(Flowable&lt;T&gt; source, Scheduler scheduler, boolean nonScheduledRequests) &#123; ... this.scheduler = scheduler; ...&#125;@Overridepublic void subscribeActual(final Subscriber&lt;? super T&gt; s) &#123; Scheduler.Worker w = scheduler.createWorker();//根据参数值，如Schedulers.io()创建worker final SubscribeOnSubscriber&lt;T&gt; sos = new SubscribeOnSubscriber&lt;T&gt;(s, w, source, nonScheduledRequests);//根据worker创建SubscribeOnSubscriber s.onSubscribe(sos); w.schedule(sos);&#125; 这个SubscribeOnSubscriber是个内部类： SubscribeOnSubscriber(Subscriber&lt;? super T&gt; actual, Scheduler.Worker worker, Publisher&lt;T&gt; source, boolean requestOn) &#123; ... this.worker = worker; ... &#125;... void requestUpstream(final long n, final Subscription s) &#123; ... worker.schedule(new Request(s, n));//worker会安排如何执行runnable（Request是一个runnable） ... &#125; 而这个worker，其实就是我们输入的线程参数，如Schedulers.io()，这个io是这样定义的： //io.reactivex.schedulers.Schedulers源码 static &#123; SINGLE = RxJavaPlugins.initSingleScheduler(new SingleTask()); COMPUTATION = RxJavaPlugins.initComputationScheduler(new ComputationTask()); IO = RxJavaPlugins.initIoScheduler(new IOTask()); TRAMPOLINE = TrampolineScheduler.instance(); NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask()); &#125;... static final class IOTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return IoHolder.DEFAULT; &#125; &#125; static final class NewThreadTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return NewThreadHolder.DEFAULT; &#125; &#125; static final class SingleTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return SingleHolder.DEFAULT; &#125; &#125; static final class ComputationTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return ComputationHolder.DEFAULT; &#125; &#125;... static final class SingleHolder &#123; static final Scheduler DEFAULT = new SingleScheduler(); &#125; static final class ComputationHolder &#123; static final Scheduler DEFAULT = new ComputationScheduler(); &#125; static final class IoHolder &#123; static final Scheduler DEFAULT = new IoScheduler(); &#125; static final class NewThreadHolder &#123; static final Scheduler DEFAULT = new NewThreadScheduler(); &#125; 这里的IO，最终会指向一个Scheduler，如IoScheduler： //io.reactivex.internal.schedulers.IoScheduler源码... static final class EventLoopWorker extends Scheduler.Worker &#123;//Scheduler.Worker的实现类 ... @NonNull @Override public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; if (tasks.isDisposed()) &#123; // don't schedule, we are unsubscribed return EmptyDisposable.INSTANCE; &#125; return threadWorker.scheduleActual(action, delayTime, unit, tasks);//交给线程池 &#125; 这样，Scheculer中的具体任务就交给了某个线程池来处理。 需要特别说明的是，RxJava中调用Android主线程(AndroidSchedulers.mainThread)，其实还是使用了Handler机制： public final class AndroidSchedulers &#123; ... static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper())); 这个HandlerScheduler其实就是实现了Scheduler和Scheduler.Worker内部类。 final class HandlerScheduler extends Scheduler &#123;private final Handler handler;HandlerScheduler(Handler handler) &#123; this.handler = handler;&#125;private static final class HandlerWorker extends Worker &#123; ... @Override public Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; ... handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); 总的来看，RxJava的多线程切换其实是利用了Scheculer.Worker这个内部类，把任务交给Scheculer的Worker去做，而这个Scheculer的Worker是根据定义的线程来实现了不同的线程池，其实还是交给线程池去处理了。至于主线程，RxJava也是使用了Handler机制。 总结小小总结一下，基本上来说，Android中的多线程切换，主要使用Runnable和Callable来定义工作内容，使用线程池来实现异步并行，使用Handler机制来通知主线程，有些场景下会视情况需要，使用Future的接口回调，使用SynchronousQueue阻塞队列等。 原文链接：mp.weixin.qq.com]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android珍藏】推荐10个炫酷的开源库]]></title>
    <url>%2Fposts%2F78b41fa0.html</url>
    <content type="text"><![CDATA[前言技术群里面经常有人问到一些炫酷的UI效果实现方法，有时候我都是给一个相同或者相似效果的Github链接，有同学私信给我说，大佬，怎么这些效果你都能找到？你是怎么搜索的，或者有其他什么秘方？会利用Google、百度等搜索工具搜索是一方面，另一个重要的方面是：记录搜藏，当看到一个炫酷的效果的时候，记得收藏起来，记录到自己云笔记或者收藏夹里，看得多了，印象就比较深刻，当遇到类似效果的时候，到自己记录收藏的地方找就是了。今天为大家推荐我所收藏的一些炫酷实用的效果的开源库（选择其中10个）。 1、 DiscreteScrollView简介： DiscreteScrollView是基于RecyclerView 实现的一个横向滑动列表，当前Item显示在屏幕中央并且可以左右滑动，有点像ViewPager,但是可以快速滑动。提供了简单的API来实现炫酷的动画效果。 效果展示： 2、MaterialViewPager简介： 和名字一样，Material Design 效果的ViewPager, 效果很nice,请看gif 效果展示(有多重模式)： Titlebar Logo Fading Logo Hide Logo and Toolbar Sticky Toolbar Transparent Toolbar Standard 3、BoomMenu简介： 传统的菜单是不是看得有些厌倦了，boom ….爆炸效果的菜单了解一下？功能强大、效果炫酷，有很多种模式。 效果展示： 4、LayoutManagerGroup简介： 自定义RecyclerView 的LayoutManager实现几种炫酷的效果。 效果展示： EchelonLayoutManager SkidRightLayoutManager SlideLayoutManager 5、Android-SpinKit简介： Android 自定义View 的方式实现的各种炫酷的动画，特别精致和优美，以前专门写文章介绍过。 效果展示： 6、Matisse简介： Matisse是知乎开源的一个本地选择照片和视频的库，UI设计得非常精美。有如特性： 可以在Fragment/Activity 中使用 选择照片的格式包括：PNG、JPEG 、GIF.视频格式包括：MPEG, MP4 支持不同的主题并且可以自定义主题 支持不同的图片加载方式（Picasso、Glide等） 自定义过滤规则 效果展示： Zhihu Style Dracula Style Preview 7、CosmoCalendar简介： 一个高度自定义的日历库，UI精美，支持多种模式。 效果展示： 单个日期选择 多个日期选择 选择一个范围日期 自定义 8、CardStackView简介： 三种炫酷的列表卡片滑动动画，分别为：alldown, updown, updownstack 效果展示： 9、CalendarExaple简介： 这是一个高仿钉钉和小米的日历控件，支持快速滑动，界面缓存。想要定制化UI，使用起来非常简单，就像使用ListView一样 一些特点： 可以自定义日历控件UI 支持快速滑动 支持农历和阳历 界面UI缓存和日历数据缓存 扩展view支持listView的滑动 效果展示： 10、MZBannerView简介： 仿魅族BannerView,图片轮播控件,支持多种模式切换：普通ViewPager使用，普通Banner使用，仿魅族Banner使用。 效果展示： 结尾在我们平时的工作、学习中，要养成记笔记的好习惯、好记性不如烂笔头。平时自己遇到一些炫酷的效果，我都喜欢记录到笔记中，遇到相似的需求就好找了。本文这些炫酷的效果有兴趣的可以去对应的Github 查看使用方式，试试效果，都挺赞的。 来源：掘金-依然范特稀西]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google推荐的图片加载库Glide介绍]]></title>
    <url>%2Fposts%2F6abab605.html</url>
    <content type="text"><![CDATA[英文原文 Introduction to Glide, Image Loader Library for Android, recommended by Google 在泰国举行的谷歌开发者论坛上，谷歌为我们介绍了一个名叫 Glide 的图片加载库，作者是bumptech。这个库被广泛的运用在google的开源项目中，包括2014年google I/O大会上发布的官方app。它的成功让我非常感兴趣。我花了一整晚的时间把玩，决定分享一些自己的经验。在开始之前我想说， Glide 和 Picasso 有90%的相似度，准确的说，就是Picasso的克隆版本。但是在细节上还是有不少区别的。 导入库 Glide 和 Picasso 都在jcenter上。在项目中添加依赖非常简单： Glidedependencies &#123; compile 'com.github.bumptech.glide:glide:3.5.2' compile 'com.android.support:support-v4:22.0.0'&#125; Picassodependencies &#123; compile 'com.squareup.picasso:picasso:2.5.1'&#125; 虽然两者看起来一样，但是Glide更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。 同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。 默认Bitmap格式是RGB_565下面是加载图片时和Picasso的比较（1920x1080 像素的图片加载到768x432的ImageView中） 可以看到Glide加载的图片质量要差于Picasso（ps：我看不出来哈），为什么？这是因为Glide默认的Bitmap格式是RGB_565 ，比ARGB_8888格式的内存开销要小一半。下面是Picasso在ARGB8888下与Glide在RGB565下的内存开销图（应用自身占用了8m，因此以8为基准线比较）： 如果你对默认的RGB_565效果还比较满意，可以不做任何事，但是如果你觉得难以接受，可以创建一个新的GlideModule将Bitmap格式转换到ARGB_8888： public class GlideConfiguration implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; // Apply options to the builder here. builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; // register ModelLoaders here. &#125; &#125; 同时在AndroidManifest.xml中将GlideModule定义为meta-data &lt;meta-data android:name="com.inthecheesefactory.lab.glidepicasso.GlideConfiguration" android:value="GlideModule"/&gt; 这样看起来就会好很多。我们再来看看内存开销图，这次貌似Glide花费了两倍于上次的内存，但是Picasso的内存开销仍然远大于Glide。 原因在于Picasso是加载了全尺寸的图片到内存，然后让GPU来实时重绘大小。而Glide加载的大小和ImageView的大小是一致的，因此更小。当然，Picasso也可以指定加载的图片大小的： Picasso.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .resize(768, 432) .into(ivImgPicasso); 但是问题在于你需要主动计算ImageView的大小，或者说你的ImageView大小是具体的值（而不是wrap_content），你也可以这样： Picasso.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .fit() .centerCrop() .into(ivImgPicasso); 现在Picasso的内存开销就和Glide差不多了。 虽然内存开销差距不到，但是在这个问题上Glide完胜Picasso。因为Glide可以自动计算出任意情况下的ImageView大小。 Image质量的细节这是将ImageView还原到真实大小时的比较。 你可以看到，Glide加载的图片没有Picasso那么平滑，我还没有找到一个可以直观改变图片大小调整算法的方法。但是这并不算什么坏事，因为很难察觉。 磁盘缓存Picasso和Glide在磁盘缓存策略上有很大的不同。Picasso缓存的是全尺寸的，而Glide缓存的是跟ImageView尺寸相同的。 上面提到的平滑度的问题依然存在，而且如果加载的是RGB565图片，那么缓存中的图片也是RGB565。我尝试将ImageView调整成不同大小，但不管大小如何Picasso只缓存一个全尺寸的。Glide则不同，它会为每种大小的ImageView缓存一次。尽管一张图片已经缓存了一次，但是假如你要在另外一个地方再次以不同尺寸显示，需要重新下载，调整成新尺寸的大小，然后将这个尺寸的也缓存起来。具体说来就是：假如在第一个页面有一个200x200的ImageView，在第二个页面有一个100x100的ImageView，这两个ImageView本来是要显示同一张图片，却需要下载两次。不过，你可以改变这种行为，让Glide既缓存全尺寸又缓存其他尺寸： Glide.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .diskCacheStrategy(DiskCacheStrategy.ALL) .into(ivImgGlide); 下次在任何ImageView中加载图片的时候，全尺寸的图片将从缓存中取出，重新调整大小，然后缓存。Glide的这种方式优点是加载显示非常快。而Picasso的方式则因为需要在显示之前重新调整大小而导致一些延迟，即便你添加了这段代码来让其立即显示：// Picasso.noFade(); Picasso和Glide各有所长，你根据自己的需求选择合适的。对我而言，我更喜欢Glide，因为它远比Picasso快，虽然需要更大的空间来缓存。（从上图也可以看出，Glide加载速度远快于Picasso） 特性你可以做到几乎和Picasso一样多的事情，代码也几乎一样。 Image Resizing// Picasso.resize(300, 200); //Glide.override(300, 200); Center Cropping// Picasso.centerCrop(); // Glide.centerCrop(); Transforming// Picasso.transform(new CircleTransform()) // Glide.transform(new CircleTransform(context)) 设置占位图或者加载错误图// Picasso.placeholder(R.drawable.placeholder).error(R.drawable.imagenotfound) // Glide.placeholder(R.drawable.placeholder).error(R.drawable.imagenotfound) 几乎和Picasso一样，从Picasso转换到Glide对你来说就是小菜一碟。 有什么Glide可以做而Picasso做不到Glide可以加载GIF动态图，而Picasso不能。 同时因为Glide和Activity/Fragment的生命周期是一致的，因此gif的动画也会自动的随着Activity/Fragment的状态暂停、重放。Glide 的缓存在gif这里也是一样，调整大小然后缓存。但是从我的一次测试结果来看Glide 动画会消费太多的内存，因此谨慎使用。除了gif动画之外，Glide还可以将任何的本地视频解码成一张静态图片。还有一个特性是你可以配置图片显示的动画，而Picasso只有一种动画：fading in。最后一个是可以使用thumbnail()产生一个你所加载图片的thumbnail。其实还有一些特性，不过不是非常重要，比如将图像转换成字节数组等。 配置有许多可以配置的选项，比如大小，缓存的磁盘位置，最大缓存空间，位图格式等等。可以在这个页面查看这些配置Configuration 。 库的大小Picasso (v2.5.1)的大小约118kb，而Glide (v3.5.2)的大小约430kb。 Anyway 312KB difference might not be that significant.不过312kb的差距并不是很重要。Picasso和Glide的方法个数分别是840和2678个。 必须指出，对于DEX文件65535个方法的限制来说，2678是一个相当大的数字了。建议在使用Glide的时候开启ProGuard。 总结Glide和Picasso都是非常完美的库。Glide加载图像以及磁盘缓存的方式都要优于Picasso，速度更快，并且Glide更有利于减少OutOfMemoryError的发生，GIF动画是Glide的杀手锏。不过Picasso的图片质量更高。你更喜欢哪个呢？虽然我使用了很长时间的Picasso，但是我得承认现在我更喜欢Glide。我的建议是使用Glide，但是将Bitmap格式换成 ARGB_8888、让Glide缓存同时缓存全尺寸和改变尺寸两种。]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug.keystore的SHA1和MD5]]></title>
    <url>%2Fposts%2F1a48ee1.html</url>
    <content type="text"><![CDATA[切换到debug.keystore目录cd ~/.android/ 查看debug.keystore的SHA1和MD5接着输入如下命令keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android 结果如下图]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex和Web的平台差异]]></title>
    <url>%2Fposts%2Fb78de55a.html</url>
    <content type="text"><![CDATA[Weex 和 Web 的平台差异Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。 Weex 环境中没有 DOMDOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。 不支持 DOM 操作原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。 有限的事件类型Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。 支持 Web 中的事件类型，详情请参考《通用事件》。 不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。 Weex 环境中没有 BOMBOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端并不基于浏览器运行，不支持浏览器提供的 BOM 接口。 没有 window 、screen 对象Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。 WXEnvironment weexVersion: WeexSDK 的版本。 appName: 应用的名称。 appVersion: 应用的版本。 platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。 osName: 系统的名称。 osVersion: 系统版本。 deviceWidth: 设备宽度。 deviceHeight: 设备高度。 没有 document 对象在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。 没有 history 、location 、navigator 对象 history 保存了当前页面的历史记录，并且提供了前进后退操作。 location 记录了当前页面 URL 相关的信息。 navigator 记录了当前浏览器中的信息。 这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。 此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。 能够调用移动设备原生 API在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。 《clipboard 剪切板》 《navigator 导航控制》 《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块。 有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex集成到Android应用]]></title>
    <url>%2Fposts%2F10965f08.html</url>
    <content type="text"><![CDATA[集成到Android应用 设置gradle依赖 配置混淆规则 声明权限 初始化sdk 创建WXSDKInstance 运行app 扩展Android能力 在执行以下步骤之前，请先确认您的Android开发环境是ok的。 JAVA环境, jdk7+ Android Studio NDK r16、Cmake 3.9.0+ (可选项：如果需要编译WEEX源码，需要NDK环境支持) 1. 设置gradle依赖dependencies &#123; ... // weex sdk and fastjson compile &apos;com.taobao.android:weex_sdk:0.20.0.2@aar&apos; compile &apos;com.alibaba:fastjson:1.1.46.android&apos; //support library dependencies compile &apos;com.android.support:recyclerview-v7:23.1.1&apos; compile &apos;com.android.support:support-v4:23.1.1&apos; compile &apos;com.android.support:appcompat-v7:23.1.1&apos;&#125; 2. 配置混淆规则混淆规则如下，建议参考最新的源码配置 -keep class com.taobao.weex.bridge.** &#123; *; &#125;-keep class com.taobao.weex.layout.** &#123; *; &#125;-keep class com.taobao.weex.WXSDKEngine &#123; *; &#125;-keep class com.taobao.weex.base.SystemMessageHandler &#123; *; &#125;-dontwarn com.taobao.weex.bridge.** 3. 声明权限在AndroidManifest.xml中声明权限 //网络&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;//sd卡读写&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 4. 初始化sdkInitConfig config = new InitConfig.Builder() //图片库接口 .setImgAdapter(new FrescoImageAdapter()) //网络库接口 .setHttpAdapter(new InterceptWXHttpAdapter()) .build();WXSDKEngine.initialize(applicationContext,config); demo初始化源码 其它扩展配置看这里 5. 创建WXSDKInstanceWXSDKInstance是weex渲染页面的基本单元， 通过instance.render(url)拉取bundle， 在回调IWXRenderListener的onViewCreated返回创建的view， 将返回的view 添加到Activity的view上（rootView） 参见源码: WXPageActivity public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * bundleUrl source http://dotwe.org/vue/38e202c16bdfefbdb88a8754f975454c */ String pageName = "WXSample"; String bundleUrl = "http://dotwe.org/raw/dist/38e202c16bdfefbdb88a8754f975454c.bundle.wx"; mWXSDKInstance.renderByUrl(pageName, bundleUrl, null, null,WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 6. 运行app运行app，您将会看到一个 hello world 页面。 Hello World Demo 源码 提示: 点击二维码, 可以看到最终编译的代码产物。 7. 扩展Android能力Weex 提供了能力扩展机制，可以根据自己的业务进行定制自己的功能。 主要分为： Module 扩展， 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展， 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展， Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex创建一个app]]></title>
    <url>%2Fposts%2Ffccf4639.html</url>
    <content type="text"><![CDATA[创建一个 App 以下步骤假设您已经了解了 Node.js 和 npm 的基本知识。如果对它们不熟悉，可以访问 https://docs.npmjs.com/ 来了解更多关于 npm 的用法。 Weex 提供了一个命令行工具 weex-toolkit 来帮助开发者使用 Weex。它可以用来快速创建一个空项目、初始化 iOS 和 Android 开发环境、调试、安装插件等操作。 目前 weex-toolkit 只支持创建 Vue.js 的项目。创建 Rax 的项目可以使用 rax-cli，参考 Rax 的官方网站 了解其用法。 初始化请确保你已经安装了 Node.js，然后全局安装 weex-toolkit。 npm install weex-toolkit -g 这条命令会向你命令行环境中注册一个 weex 命令。你可以用 weex create 命令来创建一个空的模板项目： weex create awesome-app 命令执行完以后，在当前目录的 awesome-app 文件夹里就有了一个空的 Weex + Vue.js 项目。 开发下一步就是进入刚刚创建的文件夹，并且安装依赖，然后执行 npm start： cd awesome-appnpm installnpm start 然后工具会启动一个本地的 web 服务，监听 8081 端口。你可以打开 http://localhost:8081 查看页面在 Web 下的渲染效果。 源代码在 src/ 目录中，你可以像一个普通的 Vue.js 项目一样来开发. 除此之外，你还可以打开 http://localhost:8081/preview.html 开启一个预览页面，它会把 web 端的页面放在一个 iframe 中渲染，而且在右侧生成一个二维码。用 Weex playground app 扫描这个二维码可以看到页面在手机上渲染的真实效果。 编译和运行默认情况下 weex create 命令并不初始化 iOS 和 Android 项目，你可以通过执行 weex platform add 来添加特定平台的项目。 weex platform add iosweex platform add android 由于网络环境的不同，安装过程可能需要一些时间，请耐心等待。如果安装失败，请确保自己的网络环境畅通。 为了能在本地机器上打开 Android 和 iOS 项目，你应该配置好客户端的开发环境。对于 iOS，你应该安装并且配置好 Xcode。对于 Android，你应该安装并且配置好 Android Studio。当开发环境准备就绪后，运行下面的命令，可以在模拟器或真实设备上启动应用： weex run iosweex run androidweex run web 调试weex-toolkit 还提供了强大的调试功能，只需要执行： weex debug 这条命令会启动一个调试服务，并且在 Chrome （目前只支持基于 V8 引擎的桌面浏览器） 中打开调试页面。详细用法请参考 weex-toolkit 的文档。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex设置开发环境]]></title>
    <url>%2Fposts%2F55bbc4a4.html</url>
    <content type="text"><![CDATA[使用 Weex Online Editor 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex，下面教你如何搭建本地开发环境进行 Weex 开发。 安装依赖Weex 官方提供了weex-toolkit 的脚手架工具来辅助开发和调试。 首先，你需要 Node.js 和 Weex CLi。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 更多安装方式可参考 Node.js 官方信息 ::: Tip 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit, 你也可以通过 yarn 来进行安装。 国内的开发者推荐将npm镜像切换至 Taobao NPM 镜像。 ::: 运行下面的命令安装最新的beta版本工具： $ npm install -g weex-toolkit@beta$ weex -v // 查看当前weex工具版本 安装结束后你可以直接使用 weex help 命令验证是否安装成功，它会显示 weex 支持的所有指令，同时，你也可以通过 weex doctor 命令检查你的本地开发环境。 初始化项目然后初始化 Weex 项目： $ weex create awesome-project 执行完命令后，在 awesome-project 目录中已经为我们生成了标准项目结构。 开发进入项目所在路径，如果你在生成项目的时候选择了自动安装依赖，在进入项目后只需直接运行 npm start 就可以将项目完整跑起来，否则，你需要预先在项目中运行一下 npm install 安装项目所需依赖。 关于 Weex 语法部分，你可以直接参考 Vue Guide]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 Weex ？]]></title>
    <url>%2Fposts%2F96214312.html</url>
    <content type="text"><![CDATA[Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架。“Weex” 的发音是 /wiːks/, 和 “Weeks“ 同音。 Write Once, Run EverywhereWeex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成了 WeexSDK 之后，你可以使用 JavaScript 语言和前端开发经验来开发移动应用。 Weex 渲染引擎与 DSL 语法层是分开的，Weex 并不强依赖任何特定的前端框架。目前 Vue.js 和 Rax 这两个前端框架被广泛应用于 Weex 页面开发，同时 Weex 也对这两个前端框架提供了最完善的支持。Weex 的另一个主要目标是跟进流行的 Web 开发技术并将其和原生开发的技术结合，实现开发效率和运行性能的高度统一。在开发阶段，一个 Weex 页面就像开发普通网页一样；在运行时，Weex 页面又充分利用了各种操作系统的原生组件和能力。 概述想初步了解 Weex 其实非常简单。 安装 WeexPlayground. 在 Playground 里，你可以打开各种示例。 访问 Weex online playground. 在这个网站上，你可以浏览、修改、新建各种基于 Vue.js 的单页面)例子，并用 WeexPlayground 应用扫码查看实时效果。 这里有一个使用 Weex 和 Vue.js 开发的最简单的例子。你可以大致了解 Weex 是如何工作的。 在 &lt;template&gt; 部分，包含了 &lt;div&gt; 元素，这个被广泛应用于 Web 页面中，在 Weex 里它也是一个通用的容器。&lt;text&gt;元素就和普通的 HTML 不太一样了，它提供了显示文本的能力，在 Weex 上，所有文本必须放在 &lt;text&gt; 标签中。 在 &lt;style&gt; 部分，你可以定义各种 CSS 样式。需要注意的是，这些样式在 Weex 里只能作用于当前组件，scoped。 原生组件在上面的例子中，&lt;div&gt; 和 &lt;text&gt; 在移动端上渲染出来的都是原生组件，充分利用了操作系统组件的能力与渲染速度。 Weex 提供了一套基础的内置组件。你可以对这些基础组件进行封装、组合形成自己的组件；也可以创建自己的全新组件来包装操作系统提供的地图、视频等功能。可以访问 扩展 iOS 能力 和 扩展 Android 能力来了解如何去实现自定义组件。 在框架内部，Weex 使用原生组件来渲染，并尽可能保持多平台一致性。但在不同平台上，或多或少会有一些渲染、行为上的差异。比如对于 组件，在不同平台上的视觉效果是不一致的。 原生模块对于那些不依赖于 UI 组件的功能，Weex 将它们包装成多个 模块，比如 动画模块。在前端代码中，使用 weex.requireModule(&#39;xxx&#39;) 引入一个模块，之后就可以调用它提供的各种方法。Weex 模块包装了网络、存储、剪切板、导航等各种功能供前端调用。比如你可以使用 stream 模块来获取 Vue.js 的 Star 数量。 Weex 已经提供了不少内置模块，同时也支持将 App 特有的功能包装成自定义模块提供给前端调用。如果想了解怎么做，可以浏览以下文档。 扩展 Web 组件 扩展 Android 能力 扩展 iOS 能力 一次编写，处处运行Weex 的目标就是使用开发者基于一份代码，编写出可以运行在 iOS，Android 和 Web 上的应用，并最大化地提高开发效率和简化测试、构建、发布流程。 有一些场景，你可能仍然需要写一些平台相关的代码。Weex 提供 WXEnvironment 用来获取 Weex 运行的环境变量，浏览 Weex 环境变量，了解更多。 使用前端框架Weex 应用需要依赖前端框架来编写，但 Weex 并没有绑定、限制在特定的框架上。目前 Vue.js 和 Rax 是最广泛应用于 Weex 开发的前端框架，也是目前功能最全、最稳定的方案。 Vue.js 是一个不断进化中的前端框架。 Rax 是提供类 React 语法和兼容性的前端框架。 Vue.js 和 Rax 都已经集成到 Weex 中，并默认提供。 将自己喜欢的前端框架和 Weex 进行结合是可以的，但并不是那么容易。我们也在不断开发和简化这种接入工作，如果想了解如何做，或有任何想法可以和我们联系。你也可以先阅读一下 使用前端框架 这篇文档了解它是做什么的。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通讯录获取/添加信息 AddressBook]]></title>
    <url>%2Fposts%2Fe1546149.html</url>
    <content type="text"><![CDATA[源码：AddressBook package com.example.zm.addressbook;import android.content.ContentResolver;import android.content.ContentUris;import android.content.Context;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.provider.ContactsContract;import android.text.TextUtils;import android.util.Log;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.InputStream;import java.util.ArrayList;import java.util.List;public class ContactUtil &#123; /** * 获取联系人信息，并把数据转换成json数据 * * @return * @throws JSONException */ public static String getContactInfo(Context context) throws JSONException &#123; JSONObject contactData = null; JSONObject jsonObject = null; JSONArray jsonArray = null; JSONObject jsonObject2 = null; JSONArray jsonArray2 = null; contactData = new JSONObject(); jsonArray = new JSONArray(); String mimetype = ""; int oldrid = -1; int contactId = -1; // 1.查询通讯录所有联系人信息，通过id排序，我们看下android联系人的表就知道，所有的联系人的数据是由RAW_CONTACT_ID来索引开的 // 所以，先获取所有的人的RAW_CONTACT_ID Cursor cursor = context.getContentResolver().query(ContactsContract.Data.CONTENT_URI, null, null, null, ContactsContract.Data.RAW_CONTACT_ID); contactData.put("userId", "11111"); while (cursor.moveToNext()) &#123; contactId = cursor.getInt(cursor.getColumnIndex(ContactsContract.Data.RAW_CONTACT_ID)); if (oldrid != contactId) &#123; jsonObject = new JSONObject(); jsonArray2 = new JSONArray(); jsonArray.put(jsonObject); oldrid = contactId; &#125; mimetype = cursor.getString(cursor.getColumnIndex(ContactsContract.Data.MIMETYPE)); // 取得mimetype类型,扩展的数据都在这个类型里面 Bitmap headPhoto = getHighPhoto(contactId + "", context.getContentResolver()); if (null == headPhoto) &#123; jsonObject.put("headImageUrl", ""); &#125; else &#123; jsonObject.put("headImageUrl", headPhoto); &#125; // 名字 if (ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME)); String firstName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.FAMILY_NAME)); String lastname = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.GIVEN_NAME)); String trueName = firstName + lastname; if (TextUtils.isEmpty(trueName)) &#123; jsonObject.put("trueName", ""); &#125; else &#123; jsonObject.put("trueName", trueName); &#125; &#125; // 昵称 if (ContactsContract.CommonDataKinds.Nickname.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Nickname.DISPLAY_NAME)); String nickName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Nickname.NAME)); if (TextUtils.isEmpty(nickName)) &#123; jsonObject.put("nickName", ""); &#125; else &#123; jsonObject.put("nickName", nickName); &#125; &#125; List&lt;AddressBookMoudle.ContactBook&gt; contactList = new ArrayList&lt;AddressBookMoudle.ContactBook&gt;(); // 1.2 获取各种电话信息 if (ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; int phoneType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE)); // 手机 // 个人电话 if (phoneType == ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE) &#123; String mobile = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); AddressBookMoudle.ContactBook contactBook = new AddressBookMoudle.ContactBook(); contactBook.setContact(mobile); contactBook.setContactType("0"); contactList.add(contactBook); &#125; &#125; // Email if (ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; String mobileEmail = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Email.DATA)); AddressBookMoudle.ContactBook contactBook = new AddressBookMoudle.ContactBook(); contactBook.setContact(mobileEmail); contactBook.setContactType("1"); contactList.add(contactBook); &#125; if (contactList.size() &gt; 0) &#123; for (int i = 0; i &lt; contactList.size(); i++) &#123; jsonObject2 = new JSONObject(); jsonObject2.put("contact", contactList.get(i).getContact()); jsonObject2.put("contactType", contactList.get(i).getContactType()); jsonArray2.put(jsonObject2); &#125; jsonObject.put("contactList", jsonArray2); &#125; // 查找event地址 if (ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; // 取出时间类型 int eventType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Event.TYPE)); // 生日 if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY) &#123; String birthday = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Event.START_DATE)); if (TextUtils.isEmpty(birthday)) &#123; jsonObject.put("birthDay", ""); &#125; else &#123; jsonObject.put("birthDay", birthday); &#125; &#125; &#125; // 获取组织信息 if (ContactsContract.CommonDataKinds.Organization.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; // 取出组织类型 int orgType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.TYPE)); // 单位 if (orgType == ContactsContract.CommonDataKinds.Organization.TYPE_CUSTOM) &#123; // if (orgType == // Organization.TYPE_WORK) // &#123; String company = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.COMPANY)); if (TextUtils.isEmpty(company)) &#123; jsonObject.put("company", ""); &#125; else &#123; jsonObject.put("company", company); &#125; String jobTitle = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.TITLE)); if (TextUtils.isEmpty(jobTitle)) &#123; jsonObject.put("jobtitle", ""); &#125; else &#123; jsonObject.put("jobtitle", jobTitle); &#125; String department = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.DEPARTMENT)); if (TextUtils.isEmpty(department)) &#123; jsonObject.put("department", ""); &#125; else &#123; jsonObject.put("department", department); &#125; &#125; &#125; &#125; cursor.close(); contactData.put("addressBookList", jsonArray); Log.i("contactData", contactData.toString()); return contactData.toString(); &#125; /** * 获取联系人高清头像 * * @param people_id 联系人ID * @param cr 调用容器 * @return 联系人的高清头像 */ public static Bitmap getHighPhoto(String people_id, ContentResolver cr) &#123; Uri uri = ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, Long.parseLong(people_id)); InputStream input = ContactsContract.Contacts.openContactPhotoInputStream(cr, uri, true); if (input == null) &#123; return null; &#125; return BitmapFactory.decodeStream(input); &#125;&#125; &#123; "userId": "11111", "addressBookList": [&#123; "headImageUrl": "", "trueName": "张三", "company": "北京xxx有限公司", "jobtitle": "研发工程师", "department": "", "contactList": [&#123; "contact": "185 0000 1234", "contactType": "0" &#125;, &#123; "contact": "zhangsan@163.com", "contactType": "1" &#125;], "birthDay": "2018-03-25" &#125;]&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_VSCode快捷键]]></title>
    <url>%2Fposts%2F550c573.html</url>
    <content type="text"><![CDATA[官方快捷键 全局 快捷键 描述 Command + Shift + P / F1 显示命令面板 Command + P 快速打开 Command + Shift + N 打开新窗口 Command + W 关闭窗口 基本 快捷键 描述 Command + X 剪切（未选中文本的情况下，剪切光标所在行） Command + C 复制（未选中文本的情况下，复制光标所在行） Option + Shift + F 格式化 Option + Up 向上移动行 Option + Down 向下移动行 Option + Shift + Up 向上复制行 Option + Shift + Down 向下复制行 Command + Shift + K 删除行 Command + Enter 下一行插入 Command + Shift + Enter 上一行插入 Command + Shift + \ 跳转到匹配的括号 Command + [ 减少缩进 Command + ] 增加缩进 Home 跳转至行首 End 跳转到行尾 Command + Up 跳转至文件开头 Command + Down 跳转至文件结尾 Ctrl + PgUp 按行向上滚动 Ctrl + PgDown 按行向下滚动 Command + PgUp 按屏向上滚动 Command + PgDown 按屏向下滚动 Command + Shift + [ 折叠代码块 Command + Shift + ] 展开代码块 Command + K Command + [ 折叠全部子代码块 Command + K Command + ] 展开全部子代码块 Command + K Command + 0 折叠全部代码块 Command + K Command + J 展开全部代码块 Command + K Command + C 添加行注释 Command + K Command + U 移除行注释 Command + / 添加、移除行注释 Option + Shift + A 添加、移除块注释 Option + Z 自动换行、取消自动换行 查找替换 快捷键 描述 Command + F 查找 Command + Option + F 替换 Command + G 查找下一个 Command + Shift + G 查找上一个 Option + Enter 选中所有匹配项 Command + D 向下选中相同内容 Command + K Command + D 移除前一个向下选中相同内容 多光标与选择 快捷键 描述 Option + 点击 插入多个光标 Command + Option + Up 向上插入光标 Command + Option + Down 向下插入光标 Command + U 撤销上一个光标操作 Option + Shift + I 在所选行的行尾插入光标 Command + I 选中当前行 Command + Shift + L 选中所有与当前选中内容相同部分 Command + F2 选中所有与当前选中单词相同的单词 Command + Ctrl + Shift + Left 折叠选中 Command + Ctrl + Shift + Right 展开选中 Alt + Shift + 拖动鼠标 选中代码块 Command + Shift + Option + Up 列选择 向上 Command + Shift + Option + Down 列选择 向下 Command + Shift + Option + Left 列选择 向左 Command + Shift + Option + Right 列选择 向右 Command + Shift + Option + PgUp 列选择 向上翻页 Command + Shift + Option + PgDown 列选择 向下翻页 进阶 快捷键 描述 Ctrl + Space 打开建议 Command + Shift + Space 参数提示 Tab Emmet 插件缩写补全 Option + Shift + F 格式化 Command + K Command + F 格式化选中内容 F12 跳转到声明位置 Option + F12 查看具体声明内容 Command + K F12 分屏查看具体声明内容 Command + . 快速修复 Shift + F12 显示引用 F2 重命名符号 Command + Shift + . 替换为上一个值 Command + Shift + , 替换为下一个值 Command + K Command + X 删除行尾多余空格 Command + K M 更改文件语言 导航 快捷键 描述 Command + T 显示所有符号 Ctrl + G 跳转至某行 Command + P 跳转到某个文件 Command + Shift + O 跳转到某个符号 Command + Shift + M 打开问题面板 F8 下一个错误或警告位置 Shift + F8 上一个错误或警告位置 Ctrl + Shift + Tab 编辑器历史记录 Ctrl + - 后退 Ctrl + Shift + - 前进 Ctrl + Shift + M Tab 切换焦点 编辑器管理 快捷键 描述 Command + W 关闭编辑器 Command + K F 关闭文件夹 Command + \ 编辑器分屏 Command + 1 切换到第一分组 Command + 2 切换到第二分组 Command + 3 切换到第三分组 Command + K Command + Left 切换到上一分组 Command + K Command + Right 切换到下一分组 Command + K Command + Shift + Left 左移编辑器 Command + K Command + Shift + Right 右移编辑器 Command + K Left 激活左侧编辑组 Command + K Right 激活右侧编辑组 文件管理 快捷键 描述 Command + N 新建文件 Command + O 打开文件 Command + S 保存文件 Command + Shift + S 另存为 Command + Option + S 全部保存 Command + W 关闭 Command + K Command + W 全部关闭 Command + Shift + T 重新打开被关闭的编辑器 Command + K Enter 保持打开 Ctrl + Tab 打开下一个 Ctrl + Shift + Tab 打开上一个 Command + K P 复制当前文件路径 Command + K R 在资源管理器中查看当前文件 Command + K O 新窗口打开当前文件 显示 快捷键 描述 Command + Ctrl + F 全屏、退出全屏 Command + Option + 1 切换编辑器分屏方式（横、竖） Command + + 放大 Command + - 缩小 Command + B 显示、隐藏侧边栏 Command + Shift + E 显示资源管理器 或 切换焦点 Command + Shift + F 显示搜索框 Ctrl + Shift + G 显示Git面板 Command + Shift + D 显示调试面板 Command + Shift + X 显示插件面板 Command + Shift + H 全局搜索替换 Command + Shift + J 显示、隐藏高级搜索 Command + Shift + C 打开新终端 Command + Shift + U 显示输出面板 Command + Shift + V Markdown预览窗口 Command + K V 分屏显示 Markdown预览窗口 调试 快捷键 描述 F9 设置 或 取消断点 F5 开始 或 继续 F11 进入 Shift + F11 跳出 F10 跳过Command + K Command + I 显示悬停信息 集成终端 快捷键 描述 Ctrl + ` 显示终端 Ctrl + Shift + ` 新建终端 Command + Up 向上滚动 Command + Down 向下滚动 PgUp 向上翻页 PgDown 向下翻页 Command + Home 滚动到顶部 Command + End 滚动到底部]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>VSCode</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_SDK版本号与APILevel的对应关系]]></title>
    <url>%2Fposts%2F46f6283e.html</url>
    <content type="text"><![CDATA[一、Android各版本对应的SDK版本 平台版本 API VERSION_CODE 备注 Android 9.0 28 Android P Preview（9.0） 平台亮点 Android 8.1 27 Oreo（8.1） 平台亮点 Android 8.0 26 Oreo（8.0） 平台亮点 Android 7.1 25 Nougat（牛轧糖） 平台亮点 Android 7.0 24 N（牛轧糖） 平台亮点 Android 6.0 23 M（棉花糖） 平台亮点 Android 5.1 22 LOLLIPOP_MR1（棒棒糖） 平台亮点 Android 5.0 21 LOLLIPOP （棒棒糖） Android 4.4W 20 KITKAT_WATCH（奇巧巧克力） 仅限 KitKat for Wearables Android 4.4 19 KITKAT （奇巧巧克力） 平台亮点 Android 4.3 18 JELLY_BEAN_MR2（果冻豆） 平台亮点 Android 4.2、4.2.2 17 JELLY_BEAN_MR1（果冻豆） 平台亮点 Android 4.1、4.1.1 16 JELLY_BEAN （果冻豆） 平台亮点 Android 4.0.3、4.0.4 15 ICE_CREAM_SANDWICH_MR1（冰激凌三明治） 平台亮点 Android 4.0、4.0.1、4.0.2 14 ICE_CREAM_SANDWICH（冰激凌三明治） Android 3.2 13 HONEYCOMB_MR2 （蜂巢） Android 3.1.x 12 HONEYCOMB_MR1（蜂巢） 平台亮点 Android 3.0.x 11 HONEYCOMB （蜂巢） 平台亮点 Android 2.3.4 Android 2.3.3 10 GINGERBREAD_MR1（姜饼） 平台亮点 Android 2.3.2 Android 2.3.1 Android 2.3 9 GINGERBREAD（姜饼） Android 2.2.x 8 FROYO（冻酸奶） 平台亮点 Android 2.1.x 7 ECLAIR_MR1 （埃克拉） 平台亮点 Android 2.0.1 6 ECLAIR_0_1（埃克拉） Android 2.0 5 ECLAIR（埃克拉） Android 1.6 4 DONUT（甜甜圈） 平台亮点 Android 1.5 3 CUPCAKE（纸杯蛋糕） 平台亮点 Android 1.1 2 BASE_1_1 Android 1.0 1 BASE 二、Android各版本的市场占有率和对应JDK版本 Version Codename API Distribution 2.3.3 - 2.3.7 Gingerbread 10 0.3% 4.0.3 - 4.0.4 Ice Cream Sandwich 15 0.4% 4.1.x Jelly Bean 16 1.5% 4.2.x Jelly Bean 17 2.2% 4.3 Jelly Bean 18 0.6% 4.4 KitKat 19 10.3% 5.0 Lollipop 21 4.8% 5.1 Lollipop 22 17.6% 6.0 Marshmallow 23 25.5% 7.0 Nougat 24 22.9% 7.1 Nougat 25 8.2% 8.0 Oreo 26 4.9% 8.1 Oreo 27 0.8% 以 7 天为周期收集的数据（截止于 2018 年 1 月 8 日）。 未显示任何分布份额不足 0.1% 的版本。 三、屏幕尺寸和密度 ldpi mdpi tvdpi hdpi xhdpi xxhdpi Total Small 0.4% 0.1% 0.5% Normal 0.9% 0.3% 27.3% 39.3% 23.3% 91.1% Large 2.4% 1.5% 0.4% 0.7% 0.5% 5.5% Xlarge 1.8% 0.6% 0.5% 2.9% Total 0.4% 5.1% 1.8% 28.3% 40.5% 23.9% 以 7 天为周期收集的数据（截止于 2018 年 1 月 8 日）。 未显示任何分布份额不足 0.1% 的屏幕配置。 数据来源：Android信息中心]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>SDK</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fposts%2F423abe9e.html</url>
    <content type="text"><![CDATA[常用git命令切换到git路径$ cd &lt;folder&gt; git命令 描述 git branch 查看本地分支 git branch -r 查看远程分支 git branch zm-develop 建立本地分支 git push origin zm-develop:zm-develop 将本地新的分支推送到git远程分支 git fetch origin zm-develop:zm-develop 拉取远程分支并创建本地分支 git fetch origin zm-develop:zm-develop 拉取远程分支并创建本地分支 git checkout zm-develop 切换到本地分支 git remote -v 查看当前在哪一个远程仓库 git branch -d zm-develop 删除分支zm-develop git config –list 查看配置信息 git status 查看项目状态信息 git log 查看提交日志 git reset –hard commit_id 完成撤销,同时将代码恢复到前一commit_id 对应的版本 git reset commit_id 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本号比较versionCompare]]></title>
    <url>%2Fposts%2Fd2f8db9f.html</url>
    <content type="text"><![CDATA[/** * 版本号比较versionCompare方法，java实现 * if v1 &gt; v2 , return 1; * if v1 &lt; v2 , return 2; * if equal , return 0; * input error ,return -1; */public class Test &#123; public static void main(String[] versions) &#123; int result1 = versionCompare("0.1.5", "0.1.5"); System.out.print("resultCode1:" + result1); int result2 = versionCompare("0.2.5", "0.1.5"); System.out.print("resultCode1:" + result2); int result3 = versionCompare("0.1.4", "0.1.5"); System.out.print("resultCode1:" + result3); int result4 = versionCompare("0.1.5c测试", "0.1.5"); System.out.print("resultCode1:" + result4); &#125; public static int versionCompare(String v1, String v2) &#123; Pattern pattern = Pattern.compile("\\d+(\\.\\d+)*"); if (!pattern.matcher(v1).matches() || !pattern.matcher(v2).matches()) &#123; return -1; &#125; String[] str1 = v1.split("\\."); String[] str2 = v2.split("\\."); int length = str1.length &lt; str2.length ? str1.length : str2.length; for (int i = 0; i &lt; length; i++) &#123; int diff = Integer.valueOf(str1[i]) - Integer.valueOf(str2[i]); if (diff == 0) &#123; continue; &#125; else &#123; return diff &gt; 0 ? 1 : 2; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android颜色透明度设置]]></title>
    <url>%2Fposts%2F54d6d461.html</url>
    <content type="text"><![CDATA[颜色简介Android中的颜色值通常遵循RGB/ARGB标准，使用时通常以“#”字符开头，以16进制表示。常用的颜色值格式为： #RGB #ARGB #RRGGBB #AARRGGBB 其中，ARGB 依次代表透明度（alpha）、红色(red)、绿色(green)、蓝色(blue)。以颜色值 #FF99CC00 为例，FF 是透明度，99 是红色值， CC 是绿色值， 00 是蓝色值。透明度 透明度分为256阶（0-255），计算机上用16进制表示为（00-ff）。透明就是0阶，不透明就是255阶,如果50%透明就是127阶（256的一半当然是128，但因为是从0开始，所以实际上是127）。 透明度 和 不透明度 是两个概念， 它们加起来是1，或者100%. ARGB 中的透明度alpha，表示的是不透明度。 如何换算 UI给出的颜色是#FFFFFF，透明度为40%。 换算过程： 将透明度转换成不透明度(转换方式参考“透明度”，第2条) 。不透明度为60% 不透明度乘以255。 我们得到结果：153 将计算结果转换成16进制。得到最终的不透明度：99 将不透明度和颜色值拼接成ARGB格式。得到最终的颜色值： #99FFFFFF 干货 说明：半透明颜色值不同于平时使用的颜色，半透明颜色值共8位，前2位是透明度，后6位是颜色。 参数 透明度 16进制表示 不透明 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 半透明 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 全透明 0% 00 举例： 全透明：#00000000 半透明：#80000000 不透明：#FF000000 白色半透明：#80FFFFFF 红色30%透明：#4Dca0d0d]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_iTerm2命令行工具]]></title>
    <url>%2Fposts%2Fc16bcf6c.html</url>
    <content type="text"><![CDATA[下载地址item 实用命令 多窗口切换 command + T 同个窗口横向分屏 command + d 同个窗口，竖向分屏 command + shift + d 搜索 command + f 直接打开文件 按住command键并点击文件名 自动复制 直接双击需要复制的文字，即可自动复制]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>快捷键</tag>
        <tag>iTem2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_OSX快捷键以及命令行]]></title>
    <url>%2Fposts%2F81828d81.html</url>
    <content type="text"><![CDATA[Mac OSX 快捷键 快捷键 描述 ctrl+shift 快速放大dock的图标会暂时放大，而如果你开启了dock放大 Command+Option+W 将所有窗口关闭 Command+W 将当前窗口关闭(可以关闭Safari标签栏,很实用) Command+Option+M 将所有窗口最小化 Command+Q 关闭当前应用程序(相当于Dock鼠标右键推出.很实用) Command+M 将目前使用的窗口最小化 Command+H 隐藏当前窗口或者软件 Command＋tab 为切换当前工作任务 Control＋Command＋S 切换控制条的显示和隐藏 Command＋i 常规信息（显示及设置图标属性） Command＋delete 移到废纸篓（删除） Optionion+鼠标 拖图像或文件夹可以将图像或文件夹拷贝到其它文件夹中，而不是移动 Command+Shift+backspace 清空废纸篓(再加上option一起按能跳过确认对话框) Command+N 键可以建立新文件夹 “return”或“enter”或“O”键可以打开所选项目 Command+Option+esc 键可以强行退出死机程序 Command+Shift+3 截图(当前屏幕) Command+Shift+4 截图(自由选取范围) Option＋F12 关机窗口(能选择关机、重起、睡眠) Command+1 以图标方式显示 Command+2 以分栏方式显示 Command+3 以列表方式显示 Command+4 以Cover Flow方式显示 return或enter 键可以编辑所选图像或文件夹的名称 Mac OSX 命令行目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftpftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df /tmp 显示文件系统的总空间和可用空间 w 显示当前系统活动的总信息]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端快捷键]]></title>
    <url>%2Fposts%2Fc7dcd830.html</url>
    <content type="text"><![CDATA[常用的快捷键 快捷键 描述 Ctrl + a 跳到行首 Ctrl + e 跳到行尾 Ctrl + b 光标往回(Backward)移动一个字符位置 Ctrl + c 取消当前行输入的命令 Ctrl + d 删除一个字符，相当于通常的Delete键 Ctrl + f 光标向前(Forward)移动一个字符位置 Ctrl + h 退格删除一个字符，相当于通常的Backspace键 Ctrl + k 删除光标之前到行尾的字符 Ctrl + l 清屏，相当于执行clear命令 Ctrl + u 删除光标之前到行首的字符 Ctrl + p 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 Ctrl + n 调出命令历史中的下一条（Next）命令，相当于通常的上箭头 Ctrl + r 显示：号提示，根据用户输入查找相关历史命令 Ctrl + w 删除从光标位置前到当前所处单词（Word）的开头 Ctrl + y 粘贴最后一次被删除的单词 Alt + d 删除从光标位置到当前所处单词的末尾 Command + K 清屏 Command + T 新建标签 Command +W 关闭当前标签页 Command + S 保存终端输出 Command + D 垂直分水平分隔当前标签页 Command + shift + {或} 向左/向右切换标签]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改NexT_Pisces主题内容区宽度]]></title>
    <url>%2Fposts%2F88baa841.html</url>
    <content type="text"><![CDATA[默认的宽度觉得有点窄，想改宽一点，手动修改样式在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码。 // 以下为新增代码header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125;]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建博客]]></title>
    <url>%2Fposts%2Feb656981.html</url>
    <content type="text"><![CDATA[准备工作 Hexo：快速、简洁且高效的博客框架,官网有中文文档 NexT：Hexo适用的主题 LeanCloud：数据库(可不用) GitHub：博客就发布在GitPage 安装&amp;配置 Hexo安装 Hexo全局安装 Hexo 官方的脚手架 $ npm install -g hexo-cli 然后初始化博客，并安装依赖包 $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install &lt;folder&gt; 就是博客的本地文件夹 配置 Hexo网站配置： /_config.yml 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区(默认为电脑时区) avatar(此参数需自己添加) 网站头像地址 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的链接格式 :year/:month/:day/:title/ 网站存放在子目录如果您的网站存放在子目录中，例如http://yoursite.com/blog，则请将您的 url 设为http://yoursite.com/blog 并把root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public _posts_dir 默认文件夹，这个文件夹用于存放生成的站点文件。 _posts tag_dir 标签文件夹 tags category_dir 分类文件夹 categories archive_dir 归档文件夹 archives about_dir 关于我们文件夹 about CNAME 域名文件(zhangmiao.cc) code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 更多网站参数参考：https://hexo.io/zh-cn/docs/configuration.html 添加站内搜索安装 hexo-generator-searchdb $ npm install hexo-generator-searchdb --save 网站配置： /_config.yml 新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 测试 Hexo新建文章运行命令新建一篇文章 $ hexo new [layout] &lt;title&gt; 启动服务$ hexo server 或$ hexo s 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 启动服务器。默认情况下，访问网址为：http://localhost:4000/。 部署网站$ hexo deploy 或$ $ hexo d 选项 描述 -g, –generate 部署之前预先生成静态文件 清除$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 更多命令参考：https://hexo.io/zh-cn/docs/commands.html 安装&amp;配置 NexT 主题安装 NexT 主题使用git克隆最新版本 $ cd &lt;folder&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 或者直接将 hexo-theme-next 下载下来放到 Hexo 站点目录下的 [themes/next] 目录中 启用 NexT 主题网站配置： /_config.yml搜索theme关键字，并将其值更改为 next theme: next 验证 NexT 主题 最好先使用 hexo clean 清除 Hexo 的缓存。 运行 hexo server 启动本地站点。此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行。 主题设定主题配置： /theme/next/_config.yml搜索scheme 关键字，选择使用的主题样式，将你需用启用的 scheme 前面注释 # 去掉并将其他两个 scheme 加上注释即可。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 #scheme: Muse#scheme: Mistscheme: Pisces 设置 菜单主题配置： /theme/next/_config.yml 搜索 menu 关键字 设置 头像主题配置： /theme/next/_config.yml 新增字段avatar,值设置成头像的链接地址 设置 作者名称主题配置： /theme/next/_config.yml 搜索 author 关键字 设置 描述主题配置： /theme/next/_config.yml 搜索 description 关键字 设置 首页列表是否显示 阅读更多主题配置： /theme/next/_config.yml 搜索auto_excerpt 关键字 将 enable 设置为true length 设置为期望截取保留的文章长度 集成第三方服务主题配置： /theme/next/_config.yml 参考：http://theme-next.iissnan.com/third-party-services.html 创建GitHub创建好账号之后，先创建一个仓库New repository进入 Settings ，找到下方的 GitHub Pages ，点击Choose a theme选择主题（这个无所谓，最后都会被替换），Source指向的就是GitPage站点所在的分支。 GitHub会给分配一个二级域名，GitHub昵称+github.io 部署网站安装hexo-deployer-git $ npm install hexo-deployer-git --save 配置网站配置： /_config.yml 搜索 deploy 关键字 type：git repo：github提交地址 branch：提交分支 部署$ hexo deploy 或$ hexo d 如果想在部署之前预先生成下静态文件，可以使用： $ hexo deploy -g 或$ hexo d --generate $ hexo deploy -g与$ hexo generate -d的效果其实是相同的 本地站点不要放在Git上，否则执行deploy的时候会把本地站点提交上去]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
